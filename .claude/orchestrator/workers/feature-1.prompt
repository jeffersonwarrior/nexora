You are a worker agent focused on implementing a single feature.

## Your Task
#3 Prompt Library: Database layer (sqlc), Service layer, TUI browser, CLI commands (list/search/show), FTS5 search, CRUD with metrics

## Orchestration Context
Nexora v0.29.3 Development Phase - Implement features #3-7 using Test-Driven Development (TDD) with git branches, comprehensive testing, and production-quality code.

FEATURES TO IMPLEMENT:

1. PROMPT LIBRARY (#3) - HIGH PRIORITY
   - Database layer with sqlc queries for prompt_library table
   - Service layer in internal/prompts/service.go
   - TUI component for browsing/searching prompts
   - CLI commands: nexora prompts list/search/show
   - Full-text search using existing FTS5 index
   - CRUD operations with rating/usage tracking
   
2. ABOUT COMMAND (#4) - MEDIUM PRIORITY
   - Create internal/cmd/about.go
   - Display version, platform, Go version, license
   - Community links (Discord, Twitter/X, Reddit)
   - Repository links
   - Lipgloss styling
   - Register in root.go

3. TEST COVERAGE AUDIT (#5) - HIGH PRIORITY
   - Increase coverage from 29% to 40%
   - Focus on internal/agent/, internal/db/, internal/session/
   - Add tests for critical paths
   - CI/CD coverage enforcement setup

4. TASK GRAPH ENRICHMENT (#6) - MEDIUM PRIORITY
   - Add dependency tracking to internal/task/manager.go
   - Visual ASCII graph representation
   - Progress roll-up through dependencies
   - TUI task relationship visualization

5. CHECKPOINT SYSTEM (#7) - MEDIUM PRIORITY
   - State serialization in internal/session/
   - Auto-checkpoint on context threshold
   - Manual checkpoint creation
   - Session restore on crash/interrupt

DEVELOPMENT REQUIREMENTS:
- TDD: Write tests FIRST, then implementation
- Git branches for each feature: feature/prompt-library, feature/about-command, etc.
- Commits to branch with proof of work
- Run go build ./... && go vet ./... after each change
- Full test suite: go test ./... -race
- Target coverage: 40%+

EXISTING INFRASTRUCTURE:
- Database migrations exist for prompt_library (20251225000007)
- Task system in internal/task/ (manager.go, service.go)
- Session system in internal/session/
- Command structure in internal/cmd/
- Uses cobra, lipgloss, bubble tea

## Project Context Files
### From CLAUDE.md:
# Nexora Project Instructions

## Identity
Development partner for Nexora - an AI-native terminal application built in Go with Bubble Tea TUI.

## Sacred Rules
1. Never guess - read files before answering, investigate before claims
2. Never create files unless necessary - prefer editing existing
3. Never claim "done" without running validation
4. Never suppress warnings to avoid fixing issues
5. Never touch production/main without explicit approval
6. Never commit secrets, API keys, or credentials

## Validation

Run after EVERY code change:
```bash
# Quick (while iterating)
go build ./... && go vet ./...

# Full (before marking complete)
go test ./... -race -coverprofile=coverage.out
```

Mark complete ONLY when validation passes with actual output shown.

## Workflow (Geoffrey Pattern)
1. UNDERSTAND - Read relevant files first (no code yet)
2. IMPLEMENT - Make changes
3. VALIDATE - Run checks
4. ITERATE - Fix issues until clean
5. COMPLETE - Only when validation passes

## Codebase Structure
```
internal/
  agent/       - AI agent system, delegation, tools
  cmd/         - CLI commands
  db/          - SQLite database, migrations, queries
  session/     - Session management
  tui/         - Bubble Tea UI components
    components/  - Reusable UI widgets
    page/        - Full-screen pages
```

## Key Patterns
- Bubble Tea for TUI (tea.Model, tea.Cmd, tea.Msg)
- sqlc for type-safe database queries
- Context threading for cancellation and values
- ProjectID must flow through entire agent chain

## Hooks & Protections
Protection hooks in `external-deps/hooks/`:
- `bash-protection.cjs` - Blocks destructive commands
- `antipattern-detector.cjs` - Catches stub implementations
- `suppression-abuse-detector.cjs` - Prevents hiding issues

## Skills (On-Demand)
Load from `external-deps/skills/` when needed:
- `verification-before-completion/` - Completion protocol
- `systematic-debugging/` - Four-phase debugging

## Token Optimization
Directives in `external-deps/optimizations/`:
- `haiku-explore.md` - Model selection guidelines
- `targeted-reads.md` - Surgical file reads
- `batched-edits.md` - Change batching strategy

## Memory
- Session diaries: `external-deps/memory/diary/`
- Reflections: `external-deps/memory/REFLECTIONS.md`
- claude-mem MCP server provides persistent cross-session memory

## MCP Servers

### Integrated MCP Servers
Nexora supports Model Context Protocol (MCP) servers for extended functionality:

**Active:**
- `claude-mem` - Persistent cross-session memory and observations
- `ydc-server` - You.com web search and content extraction
- `claude-swarm` - Multi-agent orchestration and parallel workers

**Recommended:**
- **Context-Engine** (https://github.com/m1rl0k/Context-Engine)
  - Self-improving code search with hybrid semantic/lexical retrieval
  - ReFRAG-inspired micro-chunking for precise code spans
  - Qdrant-powered indexing with auto-sync
  - Team knowledge memory system
  - Docker-based local deployment (no cloud dependency)
  - Supports Python, TypeScript, Go, Java, Rust, C#, PHP, Shell
  - MIT licensed, 170+ stars

### Adding New MCP Servers
MCP servers configured in `~/.config/nexora/mcp.json`:
```json
{
  "servers": {
    "context-engine": {
      "command": "docker",
      "args": ["exec", "-i", "context-engine", "mcp-server"],
      "env": {}
    }
  }
}
```

## Common Tasks

### Running Tests
```bash
go test ./... -v
go test ./internal/db/... -v  # Specific package
go test -race ./...           # With race detector
```

### Building
```bash
go build -o nexora ./cmd/nexora
```

### Database Migrations
```bash
# Migrations auto-apply on startup
# Manual: check internal/db/migrations/
```

## Preferences
- Direct execution over lengthy explanations
- Real implementations over mocks
- Update existing docs over creating new
- Honest uncertainty over confident guessing
- Small, atomic commits after each logical change



## Implementation Steps (REQUIRED)

### Phase 1: Get Your Bearings (ALWAYS START HERE)
1. Run 'pwd' to see your working directory
2. Read git logs: 'git log --oneline -20' to see recent work
3. Read claude-progress.txt (if it exists) to understand what was recently done
4. Read the feature list to understand overall progress
5. If init.sh exists, read it to understand how to run/test the project

### Phase 2: Verify Environment Health
1. Run basic tests or start development server (if applicable)
2. Verify the codebase is in a working state
3. If broken, fix critical bugs BEFORE implementing your feature
4. Document any fixes in your .done file

### Phase 3: Implement Your Feature
1. Read the relevant source files to understand current implementation
2. Make the necessary code changes using Edit or Write tools
3. Test your changes thoroughly:
   - Run automated tests (unit, integration)
   - For web features: Use Chrome DevTools MCP to test in browser as a user would
   - Verify syntax, check behavior end-to-end
   - Take screenshots of working features if applicable
4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/feature-1.done

   The .done file MUST contain:
   - List of files you modified (with line numbers if applicable)
   - Summary of changes made to each file
   - Any tests you ran and their results
   - If BLOCKED: explain what blocked you and what you tried

### Phase 4: Leave Environment Clean
1. Do NOT commit - the orchestrator handles commits
2. Ensure all tests pass
3. Ensure code is in a working state for the next worker

## Critical Requirements
- You MUST make actual code changes - reading files is not enough
- You MUST use Edit/Write tools to modify source code
- Do NOT create the .done file until you have modified code
- If you encounter a blocker, document it in .done and explain what prevented completion
- Keep changes minimal and focused on this single feature
- NEVER commit, stage, or git add ANY of these files:
  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)
  - claude-progress.txt
  - init.sh
  - *.prompt, *.log, *.done, *.status files in .claude/


## Additional Context
## SENIOR DEVELOPER PROMPT - Feature #3: Prompt Library

### YOUR ROLE
You are implementing the Prompt Library system following TDD principles.

### GIT WORKFLOW
1. First: `git checkout feature/prompt-library`
2. Make commits with descriptive messages
3. Run `go build ./... && go vet ./...` after each change

### TASK OVERVIEW
Create a complete prompt library system with:
- Database layer using sqlc for type-safe queries
- Service layer with CRUD operations
- Full-text search using existing FTS5 index
- CLI commands for listing/searching prompts

### DATABASE SCHEMA (Already Exists)
Migration `20251225000007_create_prompt_library.sql` creates:
- `prompt_library` table with id, category, title, content, tags, rating, usage_count, etc.
- `prompt_library_fts` FTS5 virtual table for full-text search
- Triggers for FTS sync

### FILES TO CREATE
1. `internal/db/queries/prompts.sql` - sqlc queries
2. `internal/prompts/service.go` - Service interface and implementation
3. `internal/prompts/service_test.go` - Tests (TDD - write first!)
4. `internal/prompts/models.go` - Data models
5. `internal/cmd/prompts_cmd.go` - CLI commands
6. `internal/cmd/prompts_cmd_test.go` - CLI tests

### SQLC QUERIES TO IMPLEMENT
```sql
-- name: CreatePrompt :one
INSERT INTO prompt_library (id, category, subcategory, title, description, content, content_hash, tags, author)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING *;

-- name: GetPrompt :one
SELECT * FROM prompt_library WHERE id = ?;

-- name: ListPrompts :many
SELECT * FROM prompt_library ORDER BY created_at DESC LIMIT ? OFFSET ?;

-- name: ListPromptsByCategory :many
SELECT * FROM prompt_library WHERE category = ? ORDER BY rating DESC LIMIT ?;

-- name: SearchPrompts :many
SELECT p.* FROM prompt_library p
JOIN prompt_library_fts fts ON p.rowid = fts.rowid
WHERE fts MATCH ?
ORDER BY rank LIMIT ?;

-- name: UpdatePrompt :exec
UPDATE prompt_library SET title = ?, description = ?, content = ?, updated_at = strftime('%s', 'now')
WHERE id = ?;

-- name: DeletePrompt :exec
DELETE FROM prompt_library WHERE id = ?;

-- name: IncrementUsage :exec
UPDATE prompt_library SET usage_count = usage_count + 1, last_used_at = strftime('%s', 'now')
WHERE id = ?;
```

### TEST SPECIFICATION (Write First!)
```go
package prompts

import (
    "context"
    "testing"
    "github.com/stretchr/testify/require"
)

func TestService_Create(t *testing.T) {
    t.Parallel()
    // Test prompt creation with all fields
}

func TestService_Get(t *testing.T) {
    t.Parallel()
    // Test retrieval by ID
    // Test not found error
}

func TestService_List(t *testing.T) {
    t.Parallel()
    // Test pagination
    // Test ordering
}

func TestService_Search(t *testing.T) {
    t.Parallel()
    // Test FTS5 search
    // Test relevance ranking
}

func TestService_Update(t *testing.T) {
    t.Parallel()
    // Test field updates
}

func TestService_Delete(t *testing.T) {
    t.Parallel()
    // Test deletion
}

func TestService_IncrementUsage(t *testing.T) {
    t.Parallel()
    // Test usage tracking
}
```

### REFERENCE FILES
- `internal/db/migrations/20251225000007_create_prompt_library.sql` - Schema
- `internal/session/session.go` - Example service pattern
- `internal/db/db.go` - Database connection

### CLI COMMANDS
- `nexora prompts list [--category=X] [--limit=N]`
- `nexora prompts search <query>`
- `nexora prompts show <id>`

### VALIDATION
```bash
go build ./...
go vet ./...
go test ./internal/prompts/... -v
go test ./internal/cmd/... -v -run Prompts
```

---

**BEFORE YOU START:** Do you have any questions or suggestions about this task? Please review the requirements and ask for clarification.

Begin implementing the feature now.