You are a worker agent focused on implementing a single feature.

## Your Task
#7 Checkpoint: State serialization, checkpoint creation/restore, session recovery, minimal overhead

## Orchestration Context
Nexora v0.29.3 Development Phase - Implement features #3-7 using Test-Driven Development (TDD) with git branches, comprehensive testing, and production-quality code.

FEATURES TO IMPLEMENT:

1. PROMPT LIBRARY (#3) - HIGH PRIORITY
   - Database layer with sqlc queries for prompt_library table
   - Service layer in internal/prompts/service.go
   - TUI component for browsing/searching prompts
   - CLI commands: nexora prompts list/search/show
   - Full-text search using existing FTS5 index
   - CRUD operations with rating/usage tracking
   
2. ABOUT COMMAND (#4) - MEDIUM PRIORITY
   - Create internal/cmd/about.go
   - Display version, platform, Go version, license
   - Community links (Discord, Twitter/X, Reddit)
   - Repository links
   - Lipgloss styling
   - Register in root.go

3. TEST COVERAGE AUDIT (#5) - HIGH PRIORITY
   - Increase coverage from 29% to 40%
   - Focus on internal/agent/, internal/db/, internal/session/
   - Add tests for critical paths
   - CI/CD coverage enforcement setup

4. TASK GRAPH ENRICHMENT (#6) - MEDIUM PRIORITY
   - Add dependency tracking to internal/task/manager.go
   - Visual ASCII graph representation
   - Progress roll-up through dependencies
   - TUI task relationship visualization

5. CHECKPOINT SYSTEM (#7) - MEDIUM PRIORITY
   - State serialization in internal/session/
   - Auto-checkpoint on context threshold
   - Manual checkpoint creation
   - Session restore on crash/interrupt

DEVELOPMENT REQUIREMENTS:
- TDD: Write tests FIRST, then implementation
- Git branches for each feature: feature/prompt-library, feature/about-command, etc.
- Commits to branch with proof of work
- Run go build ./... && go vet ./... after each change
- Full test suite: go test ./... -race
- Target coverage: 40%+

EXISTING INFRASTRUCTURE:
- Database migrations exist for prompt_library (20251225000007)
- Task system in internal/task/ (manager.go, service.go)
- Session system in internal/session/
- Command structure in internal/cmd/
- Uses cobra, lipgloss, bubble tea

## Project Context Files
### From CLAUDE.md:
# Nexora Project Instructions

## Identity
Development partner for Nexora - an AI-native terminal application built in Go with Bubble Tea TUI.

## Sacred Rules
1. Never guess - read files before answering, investigate before claims
2. Never create files unless necessary - prefer editing existing
3. Never claim "done" without running validation
4. Never suppress warnings to avoid fixing issues
5. Never touch production/main without explicit approval
6. Never commit secrets, API keys, or credentials

## Validation

Run after EVERY code change:
```bash
# Quick (while iterating)
go build ./... && go vet ./...

# Full (before marking complete)
go test ./... -race -coverprofile=coverage.out
```

Mark complete ONLY when validation passes with actual output shown.

## Workflow (Geoffrey Pattern)
1. UNDERSTAND - Read relevant files first (no code yet)
2. IMPLEMENT - Make changes
3. VALIDATE - Run checks
4. ITERATE - Fix issues until clean
5. COMPLETE - Only when validation passes

## Codebase Structure
```
internal/
  agent/       - AI agent system, delegation, tools
  cmd/         - CLI commands
  db/          - SQLite database, migrations, queries
  session/     - Session management
  tui/         - Bubble Tea UI components
    components/  - Reusable UI widgets
    page/        - Full-screen pages
```

## Key Patterns
- Bubble Tea for TUI (tea.Model, tea.Cmd, tea.Msg)
- sqlc for type-safe database queries
- Context threading for cancellation and values
- ProjectID must flow through entire agent chain

## Hooks & Protections
Protection hooks in `external-deps/hooks/`:
- `bash-protection.cjs` - Blocks destructive commands
- `antipattern-detector.cjs` - Catches stub implementations
- `suppression-abuse-detector.cjs` - Prevents hiding issues

## Skills (On-Demand)
Load from `external-deps/skills/` when needed:
- `verification-before-completion/` - Completion protocol
- `systematic-debugging/` - Four-phase debugging

## Token Optimization
Directives in `external-deps/optimizations/`:
- `haiku-explore.md` - Model selection guidelines
- `targeted-reads.md` - Surgical file reads
- `batched-edits.md` - Change batching strategy

## Memory
- Session diaries: `external-deps/memory/diary/`
- Reflections: `external-deps/memory/REFLECTIONS.md`
- claude-mem MCP server provides persistent cross-session memory

## MCP Servers

### Integrated MCP Servers
Nexora supports Model Context Protocol (MCP) servers for extended functionality:

**Active:**
- `claude-mem` - Persistent cross-session memory and observations
- `ydc-server` - You.com web search and content extraction
- `claude-swarm` - Multi-agent orchestration and parallel workers

**Recommended:**
- **Context-Engine** (https://github.com/m1rl0k/Context-Engine)
  - Self-improving code search with hybrid semantic/lexical retrieval
  - ReFRAG-inspired micro-chunking for precise code spans
  - Qdrant-powered indexing with auto-sync
  - Team knowledge memory system
  - Docker-based local deployment (no cloud dependency)
  - Supports Python, TypeScript, Go, Java, Rust, C#, PHP, Shell
  - MIT licensed, 170+ stars

### Adding New MCP Servers
MCP servers configured in `~/.config/nexora/mcp.json`:
```json
{
  "servers": {
    "context-engine": {
      "command": "docker",
      "args": ["exec", "-i", "context-engine", "mcp-server"],
      "env": {}
    }
  }
}
```

## Common Tasks

### Running Tests
```bash
go test ./... -v
go test ./internal/db/... -v  # Specific package
go test -race ./...           # With race detector
```

### Building
```bash
go build -o nexora ./cmd/nexora
```

### Database Migrations
```bash
# Migrations auto-apply on startup
# Manual: check internal/db/migrations/
```

## Preferences
- Direct execution over lengthy explanations
- Real implementations over mocks
- Update existing docs over creating new
- Honest uncertainty over confident guessing
- Small, atomic commits after each logical change



## Implementation Steps (REQUIRED)

### Phase 1: Get Your Bearings (ALWAYS START HERE)
1. Run 'pwd' to see your working directory
2. Read git logs: 'git log --oneline -20' to see recent work
3. Read claude-progress.txt (if it exists) to understand what was recently done
4. Read the feature list to understand overall progress
5. If init.sh exists, read it to understand how to run/test the project

### Phase 2: Verify Environment Health
1. Run basic tests or start development server (if applicable)
2. Verify the codebase is in a working state
3. If broken, fix critical bugs BEFORE implementing your feature
4. Document any fixes in your .done file

### Phase 3: Implement Your Feature
1. Read the relevant source files to understand current implementation
2. Make the necessary code changes using Edit or Write tools
3. Test your changes thoroughly:
   - Run automated tests (unit, integration)
   - For web features: Use Chrome DevTools MCP to test in browser as a user would
   - Verify syntax, check behavior end-to-end
   - Take screenshots of working features if applicable
4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/feature-5.done

   The .done file MUST contain:
   - List of files you modified (with line numbers if applicable)
   - Summary of changes made to each file
   - Any tests you ran and their results
   - If BLOCKED: explain what blocked you and what you tried

### Phase 4: Leave Environment Clean
1. Do NOT commit - the orchestrator handles commits
2. Ensure all tests pass
3. Ensure code is in a working state for the next worker

## Critical Requirements
- You MUST make actual code changes - reading files is not enough
- You MUST use Edit/Write tools to modify source code
- Do NOT create the .done file until you have modified code
- If you encounter a blocker, document it in .done and explain what prevented completion
- Keep changes minimal and focused on this single feature
- NEVER commit, stage, or git add ANY of these files:
  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)
  - claude-progress.txt
  - init.sh
  - *.prompt, *.log, *.done, *.status files in .claude/


## Additional Context
## SENIOR DEVELOPER PROMPT - Feature #7: Checkpoint System

### YOUR ROLE
You are implementing the Session Checkpoint system following TDD principles.

### GIT WORKFLOW
1. First: `git checkout feature/checkpoint`
2. Make commits with descriptive messages
3. Run `go build ./... && go vet ./...` after each change

### TASK OVERVIEW
Create a checkpoint system that:
- Serializes session state at configurable intervals
- Stores checkpoints in SQLite database
- Enables session recovery after crash/interrupt
- Provides manual checkpoint creation
- Manages checkpoint lifecycle (cleanup old checkpoints)

### FILES TO CREATE
1. `internal/session/checkpoint.go` - Checkpoint logic
2. `internal/session/checkpoint_test.go` - Tests (TDD - write first!)
3. Add migration for checkpoints table

### DATA MODELS
```go
package session

import "time"

// Checkpoint represents a saved session state
type Checkpoint struct {
    ID           string    `json:"id"`
    SessionID    string    `json:"session_id"`
    Timestamp    time.Time `json:"timestamp"`
    TokenCount   int64     `json:"token_count"`
    MessageCount int64     `json:"message_count"`
    ContextHash  string    `json:"context_hash"`
    State        []byte    `json:"state"`
    Compressed   bool      `json:"compressed"`
}

// CheckpointConfig configures checkpoint behavior
type CheckpointConfig struct {
    Enabled           bool  `json:"enabled"`
    TokenThreshold    int64 `json:"token_threshold"`
    IntervalSeconds   int   `json:"interval_seconds"`
    MaxCheckpoints    int   `json:"max_checkpoints"`
    CompressionLevel  int   `json:"compression_level"`
}

// CheckpointService interface
type CheckpointService interface {
    Create(ctx context.Context, session *Session) (*Checkpoint, error)
    GetLatest(ctx context.Context, sessionID string) (*Checkpoint, error)
    Get(ctx context.Context, id string) (*Checkpoint, error)
    List(ctx context.Context, sessionID string) ([]*Checkpoint, error)
    Restore(ctx context.Context, checkpointID string) (*Session, error)
    Delete(ctx context.Context, id string) error
    Cleanup(ctx context.Context, sessionID string) error
    ShouldCheckpoint(session *Session, config CheckpointConfig) bool
}
```

### TEST SPECIFICATION (Write First!)
```go
package session

import (
    "context"
    "testing"
    "github.com/stretchr/testify/require"
)

func TestCheckpoint_Create(t *testing.T) {
    t.Parallel()
    // Create checkpoint, verify fields populated
}

func TestCheckpoint_Restore(t *testing.T) {
    t.Parallel()
    // Create, checkpoint, restore, verify state matches
}

func TestCheckpoint_Compression(t *testing.T) {
    t.Parallel()
    // Verify compression reduces size
    // Verify restore works with compression
}

func TestCheckpoint_Cleanup(t *testing.T) {
    t.Parallel()
    // Create > MaxCheckpoints
    // Cleanup removes oldest, keeps MaxCheckpoints
}

func TestCheckpoint_ShouldCheckpoint(t *testing.T) {
    t.Parallel()
    // Test token threshold logic
    // Test interval logic
}
```

### SERIALIZATION
```go
import (
    "bytes"
    "compress/gzip"
    "encoding/gob"
)

func serializeSession(s *Session) ([]byte, error) {
    var buf bytes.Buffer
    enc := gob.NewEncoder(&buf)
    if err := enc.Encode(s); err != nil {
        return nil, err
    }
    return buf.Bytes(), nil
}
```

### REFERENCE FILES
- `internal/session/session.go` - Session struct
- `internal/db/migrations/` - Migration patterns
- `internal/agent/recovery/` - Existing recovery code

### VALIDATION
```bash
go build ./...
go vet ./...
go test ./internal/session/... -v
```

---

**BEFORE YOU START:** Do you have any questions or suggestions about this task?

Begin implementing the feature now.