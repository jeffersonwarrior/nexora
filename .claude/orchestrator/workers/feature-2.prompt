You are a worker agent focused on implementing a single feature.

## Your Task
#4 About Command: Create internal/cmd/about.go, version/platform info, community links, lipgloss styling, register in root.go

## Orchestration Context
Nexora v0.29.3 Development Phase - Implement features #3-7 using Test-Driven Development (TDD) with git branches, comprehensive testing, and production-quality code.

FEATURES TO IMPLEMENT:

1. PROMPT LIBRARY (#3) - HIGH PRIORITY
   - Database layer with sqlc queries for prompt_library table
   - Service layer in internal/prompts/service.go
   - TUI component for browsing/searching prompts
   - CLI commands: nexora prompts list/search/show
   - Full-text search using existing FTS5 index
   - CRUD operations with rating/usage tracking
   
2. ABOUT COMMAND (#4) - MEDIUM PRIORITY
   - Create internal/cmd/about.go
   - Display version, platform, Go version, license
   - Community links (Discord, Twitter/X, Reddit)
   - Repository links
   - Lipgloss styling
   - Register in root.go

3. TEST COVERAGE AUDIT (#5) - HIGH PRIORITY
   - Increase coverage from 29% to 40%
   - Focus on internal/agent/, internal/db/, internal/session/
   - Add tests for critical paths
   - CI/CD coverage enforcement setup

4. TASK GRAPH ENRICHMENT (#6) - MEDIUM PRIORITY
   - Add dependency tracking to internal/task/manager.go
   - Visual ASCII graph representation
   - Progress roll-up through dependencies
   - TUI task relationship visualization

5. CHECKPOINT SYSTEM (#7) - MEDIUM PRIORITY
   - State serialization in internal/session/
   - Auto-checkpoint on context threshold
   - Manual checkpoint creation
   - Session restore on crash/interrupt

DEVELOPMENT REQUIREMENTS:
- TDD: Write tests FIRST, then implementation
- Git branches for each feature: feature/prompt-library, feature/about-command, etc.
- Commits to branch with proof of work
- Run go build ./... && go vet ./... after each change
- Full test suite: go test ./... -race
- Target coverage: 40%+

EXISTING INFRASTRUCTURE:
- Database migrations exist for prompt_library (20251225000007)
- Task system in internal/task/ (manager.go, service.go)
- Session system in internal/session/
- Command structure in internal/cmd/
- Uses cobra, lipgloss, bubble tea

## Project Context Files
### From CLAUDE.md:
# Nexora Project Instructions

## Identity
Development partner for Nexora - an AI-native terminal application built in Go with Bubble Tea TUI.

## Sacred Rules
1. Never guess - read files before answering, investigate before claims
2. Never create files unless necessary - prefer editing existing
3. Never claim "done" without running validation
4. Never suppress warnings to avoid fixing issues
5. Never touch production/main without explicit approval
6. Never commit secrets, API keys, or credentials

## Validation

Run after EVERY code change:
```bash
# Quick (while iterating)
go build ./... && go vet ./...

# Full (before marking complete)
go test ./... -race -coverprofile=coverage.out
```

Mark complete ONLY when validation passes with actual output shown.

## Workflow (Geoffrey Pattern)
1. UNDERSTAND - Read relevant files first (no code yet)
2. IMPLEMENT - Make changes
3. VALIDATE - Run checks
4. ITERATE - Fix issues until clean
5. COMPLETE - Only when validation passes

## Codebase Structure
```
internal/
  agent/       - AI agent system, delegation, tools
  cmd/         - CLI commands
  db/          - SQLite database, migrations, queries
  session/     - Session management
  tui/         - Bubble Tea UI components
    components/  - Reusable UI widgets
    page/        - Full-screen pages
```

## Key Patterns
- Bubble Tea for TUI (tea.Model, tea.Cmd, tea.Msg)
- sqlc for type-safe database queries
- Context threading for cancellation and values
- ProjectID must flow through entire agent chain

## Hooks & Protections
Protection hooks in `external-deps/hooks/`:
- `bash-protection.cjs` - Blocks destructive commands
- `antipattern-detector.cjs` - Catches stub implementations
- `suppression-abuse-detector.cjs` - Prevents hiding issues

## Skills (On-Demand)
Load from `external-deps/skills/` when needed:
- `verification-before-completion/` - Completion protocol
- `systematic-debugging/` - Four-phase debugging

## Token Optimization
Directives in `external-deps/optimizations/`:
- `haiku-explore.md` - Model selection guidelines
- `targeted-reads.md` - Surgical file reads
- `batched-edits.md` - Change batching strategy

## Memory
- Session diaries: `external-deps/memory/diary/`
- Reflections: `external-deps/memory/REFLECTIONS.md`
- claude-mem MCP server provides persistent cross-session memory

## MCP Servers

### Integrated MCP Servers
Nexora supports Model Context Protocol (MCP) servers for extended functionality:

**Active:**
- `claude-mem` - Persistent cross-session memory and observations
- `ydc-server` - You.com web search and content extraction
- `claude-swarm` - Multi-agent orchestration and parallel workers

**Recommended:**
- **Context-Engine** (https://github.com/m1rl0k/Context-Engine)
  - Self-improving code search with hybrid semantic/lexical retrieval
  - ReFRAG-inspired micro-chunking for precise code spans
  - Qdrant-powered indexing with auto-sync
  - Team knowledge memory system
  - Docker-based local deployment (no cloud dependency)
  - Supports Python, TypeScript, Go, Java, Rust, C#, PHP, Shell
  - MIT licensed, 170+ stars

### Adding New MCP Servers
MCP servers configured in `~/.config/nexora/mcp.json`:
```json
{
  "servers": {
    "context-engine": {
      "command": "docker",
      "args": ["exec", "-i", "context-engine", "mcp-server"],
      "env": {}
    }
  }
}
```

## Common Tasks

### Running Tests
```bash
go test ./... -v
go test ./internal/db/... -v  # Specific package
go test -race ./...           # With race detector
```

### Building
```bash
go build -o nexora ./cmd/nexora
```

### Database Migrations
```bash
# Migrations auto-apply on startup
# Manual: check internal/db/migrations/
```

## Preferences
- Direct execution over lengthy explanations
- Real implementations over mocks
- Update existing docs over creating new
- Honest uncertainty over confident guessing
- Small, atomic commits after each logical change



## Implementation Steps (REQUIRED)

### Phase 1: Get Your Bearings (ALWAYS START HERE)
1. Run 'pwd' to see your working directory
2. Read git logs: 'git log --oneline -20' to see recent work
3. Read claude-progress.txt (if it exists) to understand what was recently done
4. Read the feature list to understand overall progress
5. If init.sh exists, read it to understand how to run/test the project

### Phase 2: Verify Environment Health
1. Run basic tests or start development server (if applicable)
2. Verify the codebase is in a working state
3. If broken, fix critical bugs BEFORE implementing your feature
4. Document any fixes in your .done file

### Phase 3: Implement Your Feature
1. Read the relevant source files to understand current implementation
2. Make the necessary code changes using Edit or Write tools
3. Test your changes thoroughly:
   - Run automated tests (unit, integration)
   - For web features: Use Chrome DevTools MCP to test in browser as a user would
   - Verify syntax, check behavior end-to-end
   - Take screenshots of working features if applicable
4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/feature-2.done

   The .done file MUST contain:
   - List of files you modified (with line numbers if applicable)
   - Summary of changes made to each file
   - Any tests you ran and their results
   - If BLOCKED: explain what blocked you and what you tried

### Phase 4: Leave Environment Clean
1. Do NOT commit - the orchestrator handles commits
2. Ensure all tests pass
3. Ensure code is in a working state for the next worker

## Critical Requirements
- You MUST make actual code changes - reading files is not enough
- You MUST use Edit/Write tools to modify source code
- Do NOT create the .done file until you have modified code
- If you encounter a blocker, document it in .done and explain what prevented completion
- Keep changes minimal and focused on this single feature
- NEVER commit, stage, or git add ANY of these files:
  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)
  - claude-progress.txt
  - init.sh
  - *.prompt, *.log, *.done, *.status files in .claude/


## Additional Context
## SENIOR DEVELOPER PROMPT - Feature #4: About Command

### YOUR ROLE
You are implementing the `nexora about` command following TDD principles.

### GIT WORKFLOW
1. First: `git checkout feature/about-command`
2. Make commits with descriptive messages
3. Run `go build ./... && go vet ./...` after each change

### TASK OVERVIEW
Create a new CLI command that displays project information including:
- Version and build info
- Platform details (OS, architecture, Go version)
- Community links (Discord, Twitter/X, Reddit)
- Repository links (GitHub, releases)
- License information

### FILES TO CREATE
1. `internal/cmd/about.go` - The command implementation
2. `internal/cmd/about_test.go` - Tests (TDD - write first!)

### TEST SPECIFICATION (Write These First!)
```go
package cmd

import (
    "bytes"
    "testing"
    "github.com/stretchr/testify/require"
)

func TestAboutCommand_Executes(t *testing.T) {
    // Test command runs without error
}

func TestAboutCommand_ContainsVersion(t *testing.T) {
    // Test output includes version string
}

func TestAboutCommand_ContainsPlatform(t *testing.T) {
    // Test output includes GOOS, GOARCH, Go version
}

func TestAboutCommand_ContainsCommunityLinks(t *testing.T) {
    // Discord: https://discord.gg/GCyC6qT79M
    // Twitter/X: https://x.com/i/communities/2004598673062216166/
    // Reddit: r/Zackor
}

func TestAboutCommand_ContainsRepoLinks(t *testing.T) {
    // GitHub: https://github.com/jeffersonwarrior/nexora
    // Releases: https://github.com/jeffersonwarrior/nexora/releases
}
```

### IMPLEMENTATION REQUIREMENTS
- Use `internal/version/version.go` for version info
- Use `charm.land/lipgloss/v2` for styling (already imported in other cmd files)
- Use `runtime.GOOS`, `runtime.GOARCH`, `runtime.Version()` for platform
- Register in `internal/cmd/root.go` via `rootCmd.AddCommand(aboutCmd)`

### REFERENCE FILES
- `internal/cmd/root.go` - See how other commands are structured and registered
- `internal/version/version.go` - Version information source
- `internal/cmd/dirs.go` - Example of a simple command

### EXPECTED OUTPUT FORMAT
```
Nexora v0.29.3
AI-Powered CLI Agent

Platform: linux/amd64
Go Version: go1.23.4
License: MIT

Community:
  Discord:   https://discord.gg/GCyC6qT79M
  Twitter/X: https://x.com/i/communities/2004598673062216166/
  Reddit:    r/Zackor

Repository:
  GitHub:    https://github.com/jeffersonwarrior/nexora
  Releases:  https://github.com/jeffersonwarrior/nexora/releases
```

### VALIDATION
After implementation:
```bash
go build ./...
go vet ./...
go test ./internal/cmd/... -v
```

### WORKFLOW
1. Checkout branch
2. Read reference files (root.go, version.go, dirs.go)
3. Write tests FIRST in about_test.go
4. Implement about.go
5. Run tests, fix until passing
6. Commit with descriptive message

---

**BEFORE YOU START:** Do you have any questions or suggestions about this task? Please review the requirements and ask for clarification on anything unclear.

Begin implementing the feature now.