{
  "file_path": "/work/external-deps/claude-mem/src/services/sqlite/SessionStore.ts",
  "file_hash": "0c32601bb5c05d339b1d25c39669bcdae4694564",
  "updated_at": "2025-12-26T17:34:20.075100",
  "symbols": {
    "class_SessionStore_20": {
      "name": "SessionStore",
      "type": "class",
      "start_line": 20,
      "end_line": 2004,
      "content_hash": "91c45366ebe506681fe77914a71e243c661b523c",
      "content": "export class SessionStore {\n  public db: Database;\n\n  constructor() {\n    ensureDir(DATA_DIR);\n    this.db = new Database(DB_PATH);\n\n    // Ensure optimized settings\n    this.db.run('PRAGMA journal_mode = WAL');\n    this.db.run('PRAGMA synchronous = NORMAL');\n    this.db.run('PRAGMA foreign_keys = ON');\n\n    // Initialize schema if needed (fresh database)\n    this.initializeSchema();\n\n    // Run migrations\n    this.ensureWorkerPortColumn();\n    this.ensurePromptTrackingColumns();\n    this.removeSessionSummariesUniqueConstraint();\n    this.addObservationHierarchicalFields();\n    this.makeObservationsTextNullable();\n    this.createUserPromptsTable();\n    this.ensureDiscoveryTokensColumn();\n    this.createPendingMessagesTable();\n  }\n\n  /**\n   * Initialize database schema using migrations (migration004)\n   * This runs the core SDK tables migration if no tables exist\n   *\n   * Note: Using console.log for migration messages since they run during constructor\n   * before structured logger is available. Actual errors use console.error.\n   */\n  private initializeSchema(): void {\n    try {\n      // Create schema_versions table if it doesn't exist\n      this.db.run(`\n        CREATE TABLE IF NOT EXISTS schema_versions (\n          id INTEGER PRIMARY KEY,\n          version INTEGER UNIQUE NOT NULL,\n          applied_at TEXT NOT NULL\n        )\n      `);\n\n      // Get applied migrations\n      const appliedVersions = this.db.prepare('SELECT version FROM schema_versions ORDER BY version').all() as SchemaVersion[];\n      const maxApplied = appliedVersions.length > 0 ? Math.max(...appliedVersions.map(v => v.version)) : 0;\n\n      // Only run migration004 if no migrations have been applied\n      // This creates the sdk_sessions, observations, and session_summaries tables\n      if (maxApplied === 0) {\n        console.log('[SessionStore] Initializing fresh database with migration004...');\n\n        // Migration004: SDK agent architecture tables\n        this.db.run(`\n          CREATE TABLE IF NOT EXISTS sdk_sessions (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            claude_session_id TEXT UNIQUE NOT NULL,\n            sdk_session_id TEXT UNIQUE,\n            project TEXT NOT NULL,\n            user_prompt TEXT,\n            started_at TEXT NOT NULL,\n            started_at_epoch INTEGER NOT NULL,\n            completed_at TEXT,\n            completed_at_epoch INTEGER,\n            status TEXT CHECK(status IN ('active', 'completed', 'failed')) NOT NULL DEFAULT 'active'\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_claude_id ON sdk_sessions(claude_session_id);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_sdk_id ON sdk_sessions(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_project ON sdk_sessions(project);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_status ON sdk_sessions(status);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_started ON sdk_sessions(started_at_epoch DESC);\n\n          CREATE TABLE IF NOT EXISTS observations (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            sdk_session_id TEXT NOT NULL,\n            project TEXT NOT NULL,\n            text TEXT NOT NULL,\n            type TEXT NOT NULL CHECK(type IN ('decision', 'bugfix', 'feature', 'refactor', 'discovery')),\n            created_at TEXT NOT NULL,\n            created_at_epoch INTEGER NOT NULL,\n            FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_observations_sdk_session ON observations(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_observations_project ON observations(project);\n          CREATE INDEX IF NOT EXISTS idx_observations_type ON observations(type);\n          CREATE INDEX IF NOT EXISTS idx_observations_created ON observations(created_at_epoch DESC);\n\n          CREATE TABLE IF NOT EXISTS session_summaries (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            sdk_session_id TEXT UNIQUE NOT NULL,\n            project TEXT NOT NULL,\n            request TEXT,\n            investigated TEXT,\n            learned TEXT,\n            completed TEXT,\n            next_steps TEXT,\n            files_read TEXT,\n            files_edited TEXT,\n            notes TEXT,\n            created_at TEXT NOT NULL,\n            created_at_epoch INTEGER NOT NULL,\n            FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_sdk_session ON session_summaries(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_project ON session_summaries(project);\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_created ON session_summaries(created_at_epoch DESC);\n        `);\n\n        // Record migration004 as applied\n        this.db.prepare('INSERT INTO schema_versions (version, applied_at) VALUES (?, ?)').run(4, new Date().toISOString());\n\n        console.log('[SessionStore] Migration004 applied successfully');\n      }\n    } catch (error: any) {\n      console.error('[SessionStore] Schema initialization error:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Ensure worker_port column exists (migration 5)\n   */\n  private ensureWorkerPortColumn(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(5) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if column exists\n    const tableInfo = this.db.query('PRAGMA table_info(sdk_sessions)').all() as TableColumnInfo[];\n    const hasWorkerPort = tableInfo.some(col => col.name === 'worker_port');\n\n    if (!hasWorkerPort) {\n      this.db.run('ALTER TABLE sdk_sessions ADD COLUMN worker_port INTEGER');\n      console.log('[SessionStore] Added worker_port column to sdk_sessions table');\n    }\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(5, new Date().toISOString());\n  }\n\n  /**\n   * Ensure prompt tracking columns exist (migration 6)\n   */\n  private ensurePromptTrackingColumns(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(6) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check sdk_sessions for prompt_counter\n    const sessionsInfo = this.db.query('PRAGMA table_info(sdk_sessions)').all() as TableColumnInfo[];\n    const hasPromptCounter = sessionsInfo.some(col => col.name === 'prompt_counter');\n\n    if (!hasPromptCounter) {\n      this.db.run('ALTER TABLE sdk_sessions ADD COLUMN prompt_counter INTEGER DEFAULT 0');\n      console.log('[SessionStore] Added prompt_counter column to sdk_sessions table');\n    }\n\n    // Check observations for prompt_number\n    const observationsInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const obsHasPromptNumber = observationsInfo.some(col => col.name === 'prompt_number');\n\n    if (!obsHasPromptNumber) {\n      this.db.run('ALTER TABLE observations ADD COLUMN prompt_number INTEGER');\n      console.log('[SessionStore] Added prompt_number column to observations table');\n    }\n\n    // Check session_summaries for prompt_number\n    const summariesInfo = this.db.query('PRAGMA table_info(session_summaries)').all() as TableColumnInfo[];\n    const sumHasPromptNumber = summariesInfo.some(col => col.name === 'prompt_number');\n\n    if (!sumHasPromptNumber) {\n      this.db.run('ALTER TABLE session_summaries ADD COLUMN prompt_number INTEGER');\n      console.log('[SessionStore] Added prompt_number column to session_summaries table');\n    }\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(6, new Date().toISOString());\n  }\n\n  /**\n   * Remove UNIQUE constraint from session_summaries.sdk_session_id (migration 7)\n   */\n  private removeSessionSummariesUniqueConstraint(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(7) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if UNIQUE constraint exists\n    const summariesIndexes = this.db.query('PRAGMA index_list(session_summaries)').all() as IndexInfo[];\n    const hasUniqueConstraint = summariesIndexes.some(idx => idx.unique === 1);\n\n    if (!hasUniqueConstraint) {\n      // Already migrated (no constraint exists)\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(7, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Removing UNIQUE constraint from session_summaries.sdk_session_id...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create new table without UNIQUE constraint\n      this.db.run(`\n        CREATE TABLE session_summaries_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          sdk_session_id TEXT NOT NULL,\n          project TEXT NOT NULL,\n          request TEXT,\n          investigated TEXT,\n          learned TEXT,\n          completed TEXT,\n          next_steps TEXT,\n          files_read TEXT,\n          files_edited TEXT,\n          notes TEXT,\n          prompt_number INTEGER,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n        )\n      `);\n\n      // Copy data from old table\n      this.db.run(`\n        INSERT INTO session_summaries_new\n        SELECT id, sdk_session_id, project, request, investigated, learned,\n               completed, next_steps, files_read, files_edited, notes,\n               prompt_number, created_at, created_at_epoch\n        FROM session_summaries\n      `);\n\n      // Drop old table\n      this.db.run('DROP TABLE session_summaries');\n\n      // Rename new table\n      this.db.run('ALTER TABLE session_summaries_new RENAME TO session_summaries');\n\n      // Recreate indexes\n      this.db.run(`\n        CREATE INDEX idx_session_summaries_sdk_session ON session_summaries(sdk_session_id);\n        CREATE INDEX idx_session_summaries_project ON session_summaries(project);\n        CREATE INDEX idx_session_summaries_created ON session_summaries(created_at_epoch DESC);\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(7, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully removed UNIQUE constraint from session_summaries.sdk_session_id');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }\n\n  /**\n   * Add hierarchical fields to observations table (migration 8)\n   */\n  private addObservationHierarchicalFields(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(8) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if new fields already exist\n    const tableInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const hasTitle = tableInfo.some(col => col.name === 'title');\n\n    if (hasTitle) {\n      // Already migrated\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(8, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Adding hierarchical fields to observations table...');\n\n    // Add new columns\n    this.db.run(`\n      ALTER TABLE observations ADD COLUMN title TEXT;\n      ALTER TABLE observations ADD COLUMN subtitle TEXT;\n      ALTER TABLE observations ADD COLUMN facts TEXT;\n      ALTER TABLE observations ADD COLUMN narrative TEXT;\n      ALTER TABLE observations ADD COLUMN concepts TEXT;\n      ALTER TABLE observations ADD COLUMN files_read TEXT;\n      ALTER TABLE observations ADD COLUMN files_modified TEXT;\n    `);\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(8, new Date().toISOString());\n\n    console.log('[SessionStore] Successfully added hierarchical fields to observations table');\n  }\n\n  /**\n   * Make observations.text nullable (migration 9)\n   * The text field is deprecated in favor of structured fields (title, subtitle, narrative, etc.)\n   */\n  private makeObservationsTextNullable(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(9) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if text column is already nullable\n    const tableInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const textColumn = tableInfo.find(col => col.name === 'text');\n\n    if (!textColumn || textColumn.notnull === 0) {\n      // Already migrated or text column doesn't exist\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(9, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Making observations.text nullable...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create new table with text as nullable\n      this.db.run(`\n        CREATE TABLE observations_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          sdk_session_id TEXT NOT NULL,\n          project TEXT NOT NULL,\n          text TEXT,\n          type TEXT NOT NULL CHECK(type IN ('decision', 'bugfix', 'feature', 'refactor', 'discovery', 'change')),\n          title TEXT,\n          subtitle TEXT,\n          facts TEXT,\n          narrative TEXT,\n          concepts TEXT,\n          files_read TEXT,\n          files_modified TEXT,\n          prompt_number INTEGER,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n        )\n      `);\n\n      // Copy data from old table (all existing columns)\n      this.db.run(`\n        INSERT INTO observations_new\n        SELECT id, sdk_session_id, project, text, type, title, subtitle, facts,\n               narrative, concepts, files_read, files_modified, prompt_number,\n               created_at, created_at_epoch\n        FROM observations\n      `);\n\n      // Drop old table\n      this.db.run('DROP TABLE observations');\n\n      // Rename new table\n      this.db.run('ALTER TABLE observations_new RENAME TO observations');\n\n      // Recreate indexes\n      this.db.run(`\n        CREATE INDEX idx_observations_sdk_session ON observations(sdk_session_id);\n        CREATE INDEX idx_observations_project ON observations(project);\n        CREATE INDEX idx_observations_type ON observations(type);\n        CREATE INDEX idx_observations_created ON observations(created_at_epoch DESC);\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(9, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully made observations.text nullable');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }\n\n  /**\n   * Create user_prompts table with FTS5 support (migration 10)\n   */\n  private createUserPromptsTable(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(10) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if table already exists\n    const tableInfo = this.db.query('PRAGMA table_info(user_prompts)').all() as TableColumnInfo[];\n    if (tableInfo.length > 0) {\n      // Already migrated\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(10, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Creating user_prompts table with FTS5 support...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create main table (using claude_session_id since sdk_session_id is set asynchronously by worker)\n      this.db.run(`\n        CREATE TABLE user_prompts (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          claude_session_id TEXT NOT NULL,\n          prompt_number INTEGER NOT NULL,\n          prompt_text TEXT NOT NULL,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(claude_session_id) REFERENCES sdk_sessions(claude_session_id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX idx_user_prompts_claude_session ON user_prompts(claude_session_id);\n        CREATE INDEX idx_user_prompts_created ON user_prompts(created_at_epoch DESC);\n        CREATE INDEX idx_user_prompts_prompt_number ON user_prompts(prompt_number);\n        CREATE INDEX idx_user_prompts_lookup ON user_prompts(claude_session_id, prompt_number);\n      `);\n\n      // Create FTS5 virtual table\n      this.db.run(`\n        CREATE VIRTUAL TABLE user_prompts_fts USING fts5(\n          prompt_text,\n          content='user_prompts',\n          content_rowid='id'\n        );\n      `);\n\n      // Create triggers to sync FTS5\n      this.db.run(`\n        CREATE TRIGGER user_prompts_ai AFTER INSERT ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(rowid, prompt_text)\n          VALUES (new.id, new.prompt_text);\n        END;\n\n        CREATE TRIGGER user_prompts_ad AFTER DELETE ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(user_prompts_fts, rowid, prompt_text)\n          VALUES('delete', old.id, old.prompt_text);\n        END;\n\n        CREATE TRIGGER user_prompts_au AFTER UPDATE ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(user_prompts_fts, rowid, prompt_text)\n          VALUES('delete', old.id, old.prompt_text);\n          INSERT INTO user_prompts_fts(rowid, prompt_text)\n          VALUES (new.id, new.prompt_text);\n        END;\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(10, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully created user_prompts table with FTS5 support');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }\n\n  /**\n   * Ensure discovery_tokens column exists (migration 11)\n   * CRITICAL: This migration was incorrectly using version 7 (which was already taken by removeSessionSummariesUniqueConstraint)\n   * The duplicate version number may have caused migration tracking issues in some databases\n   */\n  private ensureDiscoveryTokensColumn(): void {\n    try {\n      // Check if migration already applied to avoid unnecessary re-runs\n      const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(11) as SchemaVersion | undefined;\n      if (applied) return;\n\n      // Check if discovery_tokens column exists in observations table\n      const observationsInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n      const obsHasDiscoveryTokens = observationsInfo.some(col => col.name === 'discovery_tokens');\n\n      if (!obsHasDiscoveryTokens) {\n        this.db.run('ALTER TABLE observations ADD COLUMN discovery_tokens INTEGER DEFAULT 0');\n        console.log('[SessionStore] Added discovery_tokens column to observations table');\n      }\n\n      // Check if discovery_tokens column exists in session_summaries table\n      const summariesInfo = this.db.query('PRAGMA table_info(session_summaries)').all() as TableColumnInfo[];\n      const sumHasDiscoveryTokens = summariesInfo.some(col => col.name === 'discovery_tokens');\n\n      if (!sumHasDiscoveryTokens) {\n        this.db.run('ALTER TABLE session_summaries ADD COLUMN discovery_tokens INTEGER DEFAULT 0');\n        console.log('[SessionStore] Added discovery_tokens column to session_summaries table');\n      }\n\n      // Record migration only after successful column verification/addition\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(11, new Date().toISOString());\n    } catch (error: any) {\n      console.error('[SessionStore] Discovery tokens migration error:', error.message);\n      throw error; // Re-throw to prevent silent failures\n    }\n  }\n\n  /**\n   * Create pending_messages table for persistent work queue (migration 16)\n   * Messages are persisted before processing and deleted after success.\n   * Enables recovery from SDK hangs and worker crashes.\n   */\n  private createPendingMessagesTable(): void {\n    try {\n      // Check if migration already applied\n      const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(16) as SchemaVersion | undefined;\n      if (applied) return;\n\n      // Check if table already exists\n      const tables = this.db.query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='pending_messages'\").all() as TableNameRow[];\n      if (tables.length > 0) {\n        this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(16, new Date().toISOString());\n        return;\n      }\n\n      console.log('[SessionStore] Creating pending_messages table...');\n\n      this.db.run(`\n        CREATE TABLE pending_messages (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          session_db_id INTEGER NOT NULL,\n          claude_session_id TEXT NOT NULL,\n          message_type TEXT NOT NULL CHECK(message_type IN ('observation', 'summarize')),\n          tool_name TEXT,\n          tool_input TEXT,\n          tool_response TEXT,\n          cwd TEXT,\n          last_user_message TEXT,\n          last_assistant_message TEXT,\n          prompt_number INTEGER,\n          status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'processed', 'failed')),\n          retry_count INTEGER NOT NULL DEFAULT 0,\n          created_at_epoch INTEGER NOT NULL,\n          started_processing_at_epoch INTEGER,\n          completed_at_epoch INTEGER,\n          FOREIGN KEY (session_db_id) REFERENCES sdk_sessions(id) ON DELETE CASCADE\n        )\n      `);\n\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_session ON pending_messages(session_db_id)');\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_status ON pending_messages(status)');\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_claude_session ON pending_messages(claude_session_id)');\n\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(16, new Date().toISOString());\n\n      console.log('[SessionStore] pending_messages table created successfully');\n    } catch (error: any) {\n      console.error('[SessionStore] Pending messages table migration error:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get recent session summaries for a project\n   */\n  getRecentSummaries(project: string, limit: number = 10): Array<{\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        request, investigated, learned, completed, next_steps,\n        files_read, files_edited, notes, prompt_number, created_at\n      FROM session_summaries\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }\n\n  /**\n   * Get recent summaries with session info for context display\n   */\n  getRecentSummariesWithSessionInfo(project: string, limit: number = 3): Array<{\n    sdk_session_id: string;\n    request: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        sdk_session_id, request, learned, completed, next_steps,\n        prompt_number, created_at\n      FROM session_summaries\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }\n\n  /**\n   * Get recent observations for a project\n   */\n  getRecentObservations(project: string, limit: number = 20): Array<{\n    type: string;\n    text: string;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT type, text, prompt_number, created_at\n      FROM observations\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }\n\n  /**\n   * Get recent observations across all projects (for web UI)\n   */\n  getAllRecentObservations(limit: number = 100): Array<{\n    id: number;\n    type: string;\n    title: string | null;\n    subtitle: string | null;\n    text: string;\n    project: string;\n    prompt_number: number | null;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT id, type, title, subtitle, text, project, prompt_number, created_at, created_at_epoch\n      FROM observations\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }\n\n  /**\n   * Get recent summaries across all projects (for web UI)\n   */\n  getAllRecentSummaries(limit: number = 50): Array<{\n    id: number;\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    project: string;\n    prompt_number: number | null;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT id, request, investigated, learned, completed, next_steps,\n             files_read, files_edited, notes, project, prompt_number,\n             created_at, created_at_epoch\n      FROM session_summaries\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }\n\n  /**\n   * Get recent user prompts across all sessions (for web UI)\n   */\n  getAllRecentUserPrompts(limit: number = 100): Array<{\n    id: number;\n    claude_session_id: string;\n    project: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        up.id,\n        up.claude_session_id,\n        s.project,\n        up.prompt_number,\n        up.prompt_text,\n        up.created_at,\n        up.created_at_epoch\n      FROM user_prompts up\n      LEFT JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      ORDER BY up.created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }\n\n  /**\n   * Get all unique projects from the database (for web UI project filter)\n   */\n  getAllProjects(): string[] {\n    const stmt = this.db.prepare(`\n      SELECT DISTINCT project\n      FROM sdk_sessions\n      WHERE project IS NOT NULL AND project != ''\n      ORDER BY project ASC\n    `);\n\n    const rows = stmt.all() as Array<{ project: string }>;\n    return rows.map(row => row.project);\n  }\n\n  /**\n   * Get latest user prompt with session info for a Claude session\n   * Used for syncing prompts to Chroma during session initialization\n   */\n  getLatestUserPrompt(claudeSessionId: string): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at_epoch: number;\n  } | undefined {\n    const stmt = this.db.prepare(`\n      SELECT\n        up.*,\n        s.sdk_session_id,\n        s.project\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.claude_session_id = ?\n      ORDER BY up.created_at_epoch DESC\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) as LatestPromptResult | undefined;\n  }\n\n  /**\n   * Get recent sessions with their status and summary info\n   */\n  getRecentSessionsWithStatus(project: string, limit: number = 3): Array<{\n    sdk_session_id: string | null;\n    status: string;\n    started_at: string;\n    user_prompt: string | null;\n    has_summary: boolean;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT * FROM (\n        SELECT\n          s.sdk_session_id,\n          s.status,\n          s.started_at,\n          s.started_at_epoch,\n          s.user_prompt,\n          CASE WHEN sum.sdk_session_id IS NOT NULL THEN 1 ELSE 0 END as has_summary\n        FROM sdk_sessions s\n        LEFT JOIN session_summaries sum ON s.sdk_session_id = sum.sdk_session_id\n        WHERE s.project = ? AND s.sdk_session_id IS NOT NULL\n        GROUP BY s.sdk_session_id\n        ORDER BY s.started_at_epoch DESC\n        LIMIT ?\n      )\n      ORDER BY started_at_epoch ASC\n    `);\n\n    return stmt.all(project, limit);\n  }\n\n  /**\n   * Get observations for a specific session\n   */\n  getObservationsForSession(sdkSessionId: string): Array<{\n    title: string;\n    subtitle: string;\n    type: string;\n    prompt_number: number | null;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT title, subtitle, type, prompt_number\n      FROM observations\n      WHERE sdk_session_id = ?\n      ORDER BY created_at_epoch ASC\n    `);\n\n    return stmt.all(sdkSessionId);\n  }\n\n  /**\n   * Get a single observation by ID\n   */\n  getObservationById(id: number): ObservationRecord | null {\n    const stmt = this.db.prepare(`\n      SELECT *\n      FROM observations\n      WHERE id = ?\n    `);\n\n    return stmt.get(id) as ObservationRecord | undefined || null;\n  }\n\n  /**\n   * Get observations by array of IDs with ordering and limit\n   */\n  getObservationsByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string; type?: string | string[]; concepts?: string | string[]; files?: string | string[] } = {}\n  ): ObservationRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project, type, concepts, files } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n\n    // Build placeholders for IN clause\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n    const additionalConditions: string[] = [];\n\n    // Apply project filter\n    if (project) {\n      additionalConditions.push('project = ?');\n      params.push(project);\n    }\n\n    // Apply type filter\n    if (type) {\n      if (Array.isArray(type)) {\n        const typePlaceholders = type.map(() => '?').join(',');\n        additionalConditions.push(`type IN (${typePlaceholders})`);\n        params.push(...type);\n      } else {\n        additionalConditions.push('type = ?');\n        params.push(type);\n      }\n    }\n\n    // Apply concepts filter\n    if (concepts) {\n      const conceptsList = Array.isArray(concepts) ? concepts : [concepts];\n      const conceptConditions = conceptsList.map(() =>\n        'EXISTS (SELECT 1 FROM json_each(concepts) WHERE value = ?)'\n      );\n      params.push(...conceptsList);\n      additionalConditions.push(`(${conceptConditions.join(' OR ')})`);\n    }\n\n    // Apply files filter\n    if (files) {\n      const filesList = Array.isArray(files) ? files : [files];\n      const fileConditions = filesList.map(() => {\n        return '(EXISTS (SELECT 1 FROM json_each(files_read) WHERE value LIKE ?) OR EXISTS (SELECT 1 FROM json_each(files_modified) WHERE value LIKE ?))';\n      });\n      filesList.forEach(file => {\n        params.push(`%${file}%`, `%${file}%`);\n      });\n      additionalConditions.push(`(${fileConditions.join(' OR ')})`);\n    }\n\n    const whereClause = additionalConditions.length > 0\n      ? `WHERE id IN (${placeholders}) AND ${additionalConditions.join(' AND ')}`\n      : `WHERE id IN (${placeholders})`;\n\n    const stmt = this.db.prepare(`\n      SELECT *\n      FROM observations\n      ${whereClause}\n      ORDER BY created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as ObservationRecord[];\n  }\n\n  /**\n   * Get summary for a specific session\n   */\n  getSummaryForSession(sdkSessionId: string): {\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        request, investigated, learned, completed, next_steps,\n        files_read, files_edited, notes, prompt_number, created_at\n      FROM session_summaries\n      WHERE sdk_session_id = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT 1\n    `);\n\n    return stmt.get(sdkSessionId) || null;\n  }\n\n  /**\n   * Get aggregated files from all observations for a session\n   */\n  getFilesForSession(sdkSessionId: string): {\n    filesRead: string[];\n    filesModified: string[];\n  } {\n    const stmt = this.db.prepare(`\n      SELECT files_read, files_modified\n      FROM observations\n      WHERE sdk_session_id = ?\n    `);\n\n    const rows = stmt.all(sdkSessionId) as Array<{\n      files_read: string | null;\n      files_modified: string | null;\n    }>;\n\n    const filesReadSet = new Set<string>();\n    const filesModifiedSet = new Set<string>();\n\n    for (const row of rows) {\n      // Parse files_read\n      if (row.files_read) {\n        const files = JSON.parse(row.files_read);\n        if (Array.isArray(files)) {\n          files.forEach(f => filesReadSet.add(f));\n        }\n      }\n\n      // Parse files_modified\n      if (row.files_modified) {\n        const files = JSON.parse(row.files_modified);\n        if (Array.isArray(files)) {\n          files.forEach(f => filesModifiedSet.add(f));\n        }\n      }\n    }\n\n    return {\n      filesRead: Array.from(filesReadSet),\n      filesModified: Array.from(filesModifiedSet)\n    };\n  }\n\n  /**\n   * Get session by ID\n   */\n  getSessionById(id: number): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string | null;\n    project: string;\n    user_prompt: string;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT id, claude_session_id, sdk_session_id, project, user_prompt\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }\n\n  /**\n   * Get SDK sessions by SDK session IDs\n   * Used for exporting session metadata\n   */\n  getSdkSessionsBySessionIds(sdkSessionIds: string[]): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    user_prompt: string;\n    started_at: string;\n    started_at_epoch: number;\n    completed_at: string | null;\n    completed_at_epoch: number | null;\n    status: string;\n  }[] {\n    if (sdkSessionIds.length === 0) return [];\n\n    const placeholders = sdkSessionIds.map(() => '?').join(',');\n    const stmt = this.db.prepare(`\n      SELECT id, claude_session_id, sdk_session_id, project, user_prompt,\n             started_at, started_at_epoch, completed_at, completed_at_epoch, status\n      FROM sdk_sessions\n      WHERE sdk_session_id IN (${placeholders})\n      ORDER BY started_at_epoch DESC\n    `);\n\n    return stmt.all(...sdkSessionIds) as any[];\n  }\n\n  /**\n   * Find active SDK session for a Claude session\n   */\n  findActiveSDKSession(claudeSessionId: string): {\n    id: number;\n    sdk_session_id: string | null;\n    project: string;\n    worker_port: number | null;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT id, sdk_session_id, project, worker_port\n      FROM sdk_sessions\n      WHERE claude_session_id = ? AND status = 'active'\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) || null;\n  }\n\n  /**\n   * Find any SDK session for a Claude session (active, failed, or completed)\n   */\n  findAnySDKSession(claudeSessionId: string): { id: number } | null {\n    const stmt = this.db.prepare(`\n      SELECT id\n      FROM sdk_sessions\n      WHERE claude_session_id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) || null;\n  }\n\n  /**\n   * Reactivate an existing session\n   */\n  reactivateSession(id: number, userPrompt: string): void {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'active', user_prompt = ?, worker_port = NULL\n      WHERE id = ?\n    `);\n\n    stmt.run(userPrompt, id);\n  }\n\n  /**\n   * Increment prompt counter and return new value\n   */\n  incrementPromptCounter(id: number): number {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET prompt_counter = COALESCE(prompt_counter, 0) + 1\n      WHERE id = ?\n    `);\n\n    stmt.run(id);\n\n    const result = this.db.prepare(`\n      SELECT prompt_counter FROM sdk_sessions WHERE id = ?\n    `).get(id) as { prompt_counter: number } | undefined;\n\n    return result?.prompt_counter || 1;\n  }\n\n  /**\n   * Get current prompt counter for a session\n   */\n  getPromptCounter(id: number): number {\n    const result = this.db.prepare(`\n      SELECT prompt_counter FROM sdk_sessions WHERE id = ?\n    `).get(id) as { prompt_counter: number | null } | undefined;\n\n    return result?.prompt_counter || 0;\n  }\n\n  /**\n   * Create a new SDK session (idempotent - returns existing session ID if already exists)\n   *\n   * CRITICAL ARCHITECTURE: Session ID Threading\n   * ============================================\n   * This function is the KEY to how claude-mem stays unified across hooks:\n   *\n   * - NEW hook calls: createSDKSession(session_id, project, prompt)\n   * - SAVE hook calls: createSDKSession(session_id, '', '')\n   * - Both use the SAME session_id from Claude Code's hook context\n   *\n   * IDEMPOTENT BEHAVIOR (INSERT OR IGNORE):\n   * - Prompt #1: session_id not in database \u2192 INSERT creates new row\n   * - Prompt #2+: session_id exists \u2192 INSERT ignored, fetch existing ID\n   * - Result: Same database ID returned for all prompts in conversation\n   *\n   * WHY THIS MATTERS:\n   * - NO \"does session exist?\" checks needed anywhere\n   * - NO risk of creating duplicate sessions\n   * - ALL hooks automatically connected via session_id\n   * - SAVE hook observations go to correct session (same session_id)\n   * - SDKAgent continuation prompt has correct context (same session_id)\n   *\n   * This is KISS in action: Trust the database UNIQUE constraint and\n   * INSERT OR IGNORE to handle both creation and lookup elegantly.\n   */\n  createSDKSession(claudeSessionId: string, project: string, userPrompt: string): number {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // CRITICAL: INSERT OR IGNORE makes this idempotent\n    // First call (prompt #1): Creates new row\n    // Subsequent calls (prompt #2+): Ignored, returns existing ID\n    const stmt = this.db.prepare(`\n      INSERT OR IGNORE INTO sdk_sessions\n      (claude_session_id, sdk_session_id, project, user_prompt, started_at, started_at_epoch, status)\n      VALUES (?, ?, ?, ?, ?, ?, 'active')\n    `);\n\n    const result = stmt.run(claudeSessionId, claudeSessionId, project, userPrompt, now.toISOString(), nowEpoch);\n\n    // If lastInsertRowid is 0, insert was ignored (session exists), so fetch existing ID\n    if (result.lastInsertRowid === 0 || result.changes === 0) {\n      // Session exists - UPDATE project and user_prompt if we have non-empty values\n      // This fixes the bug where SAVE hook creates session with empty project,\n      // then NEW hook can't update it because INSERT OR IGNORE skips the insert\n      if (project && project.trim() !== '') {\n        this.db.prepare(`\n          UPDATE sdk_sessions\n          SET project = ?, user_prompt = ?\n          WHERE claude_session_id = ?\n        `).run(project, userPrompt, claudeSessionId);\n      }\n\n      const selectStmt = this.db.prepare(`\n        SELECT id FROM sdk_sessions WHERE claude_session_id = ? LIMIT 1\n      `);\n      const existing = selectStmt.get(claudeSessionId) as { id: number } | undefined;\n      return existing!.id;\n    }\n\n    return result.lastInsertRowid as number;\n  }\n\n  /**\n   * Update SDK session ID (captured from init message)\n   * Only updates if current sdk_session_id is NULL to avoid breaking foreign keys\n   * Returns true if update succeeded, false if skipped\n   */\n  updateSDKSessionId(id: number, sdkSessionId: string): boolean {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET sdk_session_id = ?\n      WHERE id = ? AND sdk_session_id IS NULL\n    `);\n\n    const result = stmt.run(sdkSessionId, id);\n\n    if (result.changes === 0) {\n      // This is expected behavior - sdk_session_id is already set\n      // Only log at debug level to avoid noise\n      logger.debug('DB', 'sdk_session_id already set, skipping update', {\n        sessionId: id,\n        sdkSessionId\n      });\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Set worker port for a session\n   */\n  setWorkerPort(id: number, port: number): void {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET worker_port = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(port, id);\n  }\n\n  /**\n   * Get worker port for a session\n   */\n  getWorkerPort(id: number): number | null {\n    const stmt = this.db.prepare(`\n      SELECT worker_port\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    const result = stmt.get(id) as { worker_port: number | null } | undefined;\n    return result?.worker_port || null;\n  }\n\n  /**\n   * Save a user prompt\n   */\n  saveUserPrompt(claudeSessionId: string, promptNumber: number, promptText: string): number {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      INSERT INTO user_prompts\n      (claude_session_id, prompt_number, prompt_text, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(claudeSessionId, promptNumber, promptText, now.toISOString(), nowEpoch);\n    return result.lastInsertRowid as number;\n  }\n\n  /**\n   * Get user prompt by session ID and prompt number\n   * Returns the prompt text, or null if not found\n   */\n  getUserPrompt(claudeSessionId: string, promptNumber: number): string | null {\n    const stmt = this.db.prepare(`\n      SELECT prompt_text\n      FROM user_prompts\n      WHERE claude_session_id = ? AND prompt_number = ?\n      LIMIT 1\n    `);\n\n    const result = stmt.get(claudeSessionId, promptNumber) as { prompt_text: string } | undefined;\n    return result?.prompt_text ?? null;\n  }\n\n  /**\n   * Store an observation (from SDK parsing)\n   * Auto-creates session record if it doesn't exist in the index\n   */\n  storeObservation(\n    sdkSessionId: string,\n    project: string,\n    observation: {\n      type: string;\n      title: string | null;\n      subtitle: string | null;\n      facts: string[];\n      narrative: string | null;\n      concepts: string[];\n      files_read: string[];\n      files_modified: string[];\n    },\n    promptNumber?: number,\n    discoveryTokens: number = 0\n  ): { id: number; createdAtEpoch: number } {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // Ensure session record exists in the index (auto-create if missing)\n    const checkStmt = this.db.prepare(`\n      SELECT id FROM sdk_sessions WHERE sdk_session_id = ?\n    `);\n    const existingSession = checkStmt.get(sdkSessionId) as { id: number } | undefined;\n\n    if (!existingSession) {\n      // Auto-create session record if it doesn't exist\n      const insertSession = this.db.prepare(`\n        INSERT INTO sdk_sessions\n        (claude_session_id, sdk_session_id, project, started_at, started_at_epoch, status)\n        VALUES (?, ?, ?, ?, ?, 'active')\n      `);\n      insertSession.run(\n        sdkSessionId, // claude_session_id and sdk_session_id are the same\n        sdkSessionId,\n        project,\n        now.toISOString(),\n        nowEpoch\n      );\n      console.log(`[SessionStore] Auto-created session record for session_id: ${sdkSessionId}`);\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO observations\n      (sdk_session_id, project, type, title, subtitle, facts, narrative, concepts,\n       files_read, files_modified, prompt_number, discovery_tokens, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      sdkSessionId,\n      project,\n      observation.type,\n      observation.title,\n      observation.subtitle,\n      JSON.stringify(observation.facts),\n      observation.narrative,\n      JSON.stringify(observation.concepts),\n      JSON.stringify(observation.files_read),\n      JSON.stringify(observation.files_modified),\n      promptNumber || null,\n      discoveryTokens,\n      now.toISOString(),\n      nowEpoch\n    );\n\n    return {\n      id: Number(result.lastInsertRowid),\n      createdAtEpoch: nowEpoch\n    };\n  }\n\n  /**\n   * Store a session summary (from SDK parsing)\n   * Auto-creates session record if it doesn't exist in the index\n   */\n  storeSummary(\n    sdkSessionId: string,\n    project: string,\n    summary: {\n      request: string;\n      investigated: string;\n      learned: string;\n      completed: string;\n      next_steps: string;\n      notes: string | null;\n    },\n    promptNumber?: number,\n    discoveryTokens: number = 0\n  ): { id: number; createdAtEpoch: number } {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // Ensure session record exists in the index (auto-create if missing)\n    const checkStmt = this.db.prepare(`\n      SELECT id FROM sdk_sessions WHERE sdk_session_id = ?\n    `);\n    const existingSession = checkStmt.get(sdkSessionId) as { id: number } | undefined;\n\n    if (!existingSession) {\n      // Auto-create session record if it doesn't exist\n      const insertSession = this.db.prepare(`\n        INSERT INTO sdk_sessions\n        (claude_session_id, sdk_session_id, project, started_at, started_at_epoch, status)\n        VALUES (?, ?, ?, ?, ?, 'active')\n      `);\n      insertSession.run(\n        sdkSessionId, // claude_session_id and sdk_session_id are the same\n        sdkSessionId,\n        project,\n        now.toISOString(),\n        nowEpoch\n      );\n      console.log(`[SessionStore] Auto-created session record for session_id: ${sdkSessionId}`);\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO session_summaries\n      (sdk_session_id, project, request, investigated, learned, completed,\n       next_steps, notes, prompt_number, discovery_tokens, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      sdkSessionId,\n      project,\n      summary.request,\n      summary.investigated,\n      summary.learned,\n      summary.completed,\n      summary.next_steps,\n      summary.notes,\n      promptNumber || null,\n      discoveryTokens,\n      now.toISOString(),\n      nowEpoch\n    );\n\n    return {\n      id: Number(result.lastInsertRowid),\n      createdAtEpoch: nowEpoch\n    };\n  }\n\n  /**\n   * Mark SDK session as completed\n   */\n  markSessionCompleted(id: number): void {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'completed', completed_at = ?, completed_at_epoch = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(now.toISOString(), nowEpoch, id);\n  }\n\n  /**\n   * Mark SDK session as failed\n   */\n  markSessionFailed(id: number): void {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'failed', completed_at = ?, completed_at_epoch = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(now.toISOString(), nowEpoch, id);\n  }\n\n  // REMOVED: cleanupOrphanedSessions - violates \"EVERYTHING SHOULD SAVE ALWAYS\"\n  // There's no such thing as an \"orphaned\" session. Sessions are created by hooks\n  // and managed by Claude Code's lifecycle. Worker restarts don't invalidate them.\n  // Marking all active sessions as 'failed' on startup destroys the user's current work.\n\n  /**\n   * Get session summaries by IDs (for hybrid Chroma search)\n   * Returns summaries in specified temporal order\n   */\n  getSessionSummariesByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string } = {}\n  ): SessionSummaryRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n\n    // Apply project filter\n    const whereClause = project\n      ? `WHERE id IN (${placeholders}) AND project = ?`\n      : `WHERE id IN (${placeholders})`;\n    if (project) params.push(project);\n\n    const stmt = this.db.prepare(`\n      SELECT * FROM session_summaries\n      ${whereClause}\n      ORDER BY created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as SessionSummaryRecord[];\n  }\n\n  /**\n   * Get user prompts by IDs (for hybrid Chroma search)\n   * Returns prompts in specified temporal order\n   */\n  getUserPromptsByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string } = {}\n  ): UserPromptRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n\n    // Apply project filter\n    const projectFilter = project ? 'AND s.project = ?' : '';\n    if (project) params.push(project);\n\n    const stmt = this.db.prepare(`\n      SELECT\n        up.*,\n        s.project,\n        s.sdk_session_id\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.id IN (${placeholders}) ${projectFilter}\n      ORDER BY up.created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as UserPromptRecord[];\n  }\n\n  /**\n   * Get a unified timeline of all records (observations, sessions, prompts) around an anchor point\n   * @param anchorEpoch The anchor timestamp (epoch milliseconds)\n   * @param depthBefore Number of records to retrieve before anchor (any type)\n   * @param depthAfter Number of records to retrieve after anchor (any type)\n   * @param project Optional project filter\n   * @returns Object containing observations, sessions, and prompts for the specified window\n   */\n  getTimelineAroundTimestamp(\n    anchorEpoch: number,\n    depthBefore: number = 10,\n    depthAfter: number = 10,\n    project?: string\n  ): {\n    observations: any[];\n    sessions: any[];\n    prompts: any[];\n  } {\n    return this.getTimelineAroundObservation(null, anchorEpoch, depthBefore, depthAfter, project);\n  }\n\n  /**\n   * Get timeline around a specific observation ID\n   * Uses observation ID offsets to determine time boundaries, then fetches all record types in that window\n   */\n  getTimelineAroundObservation(\n    anchorObservationId: number | null,\n    anchorEpoch: number,\n    depthBefore: number = 10,\n    depthAfter: number = 10,\n    project?: string\n  ): {\n    observations: any[];\n    sessions: any[];\n    prompts: any[];\n  } {\n    const projectFilter = project ? 'AND project = ?' : '';\n    const projectParams = project ? [project] : [];\n\n    let startEpoch: number;\n    let endEpoch: number;\n\n    if (anchorObservationId !== null) {\n      // Get boundary observations by ID offset\n      const beforeQuery = `\n        SELECT id, created_at_epoch\n        FROM observations\n        WHERE id <= ? ${projectFilter}\n        ORDER BY id DESC\n        LIMIT ?\n      `;\n      const afterQuery = `\n        SELECT id, created_at_epoch\n        FROM observations\n        WHERE id >= ? ${projectFilter}\n        ORDER BY id ASC\n        LIMIT ?\n      `;\n\n      try {\n        const beforeRecords = this.db.prepare(beforeQuery).all(anchorObservationId, ...projectParams, depthBefore + 1) as Array<{id: number; created_at_epoch: number}>;\n        const afterRecords = this.db.prepare(afterQuery).all(anchorObservationId, ...projectParams, depthAfter + 1) as Array<{id: number; created_at_epoch: number}>;\n\n        // Get the earliest and latest timestamps from boundary observations\n        if (beforeRecords.length === 0 && afterRecords.length === 0) {\n          return { observations: [], sessions: [], prompts: [] };\n        }\n\n        startEpoch = beforeRecords.length > 0 ? beforeRecords[beforeRecords.length - 1].created_at_epoch : anchorEpoch;\n        endEpoch = afterRecords.length > 0 ? afterRecords[afterRecords.length - 1].created_at_epoch : anchorEpoch;\n      } catch (err: any) {\n        console.error('[SessionStore] Error getting boundary observations:', err.message, project ? `(project: ${project})` : '(all projects)');\n        return { observations: [], sessions: [], prompts: [] };\n      }\n    } else {\n      // For timestamp-based anchors, use time-based boundaries\n      // Get observations to find the time window\n      const beforeQuery = `\n        SELECT created_at_epoch\n        FROM observations\n        WHERE created_at_epoch <= ? ${projectFilter}\n        ORDER BY created_at_epoch DESC\n        LIMIT ?\n      `;\n      const afterQuery = `\n        SELECT created_at_epoch\n        FROM observations\n        WHERE created_at_epoch >= ? ${projectFilter}\n        ORDER BY created_at_epoch ASC\n        LIMIT ?\n      `;\n\n      try {\n        const beforeRecords = this.db.prepare(beforeQuery).all(anchorEpoch, ...projectParams, depthBefore) as Array<{created_at_epoch: number}>;\n        const afterRecords = this.db.prepare(afterQuery).all(anchorEpoch, ...projectParams, depthAfter + 1) as Array<{created_at_epoch: number}>;\n\n        if (beforeRecords.length === 0 && afterRecords.length === 0) {\n          return { observations: [], sessions: [], prompts: [] };\n        }\n\n        startEpoch = beforeRecords.length > 0 ? beforeRecords[beforeRecords.length - 1].created_at_epoch : anchorEpoch;\n        endEpoch = afterRecords.length > 0 ? afterRecords[afterRecords.length - 1].created_at_epoch : anchorEpoch;\n      } catch (err: any) {\n        console.error('[SessionStore] Error getting boundary timestamps:', err.message, project ? `(project: ${project})` : '(all projects)');\n        return { observations: [], sessions: [], prompts: [] };\n      }\n    }\n\n    // Now query ALL record types within the time window\n    const obsQuery = `\n      SELECT *\n      FROM observations\n      WHERE created_at_epoch >= ? AND created_at_epoch <= ? ${projectFilter}\n      ORDER BY created_at_epoch ASC\n    `;\n\n    const sessQuery = `\n      SELECT *\n      FROM session_summaries\n      WHERE created_at_epoch >= ? AND created_at_epoch <= ? ${projectFilter}\n      ORDER BY created_at_epoch ASC\n    `;\n\n    const promptQuery = `\n      SELECT up.*, s.project, s.sdk_session_id\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.created_at_epoch >= ? AND up.created_at_epoch <= ? ${projectFilter.replace('project', 's.project')}\n      ORDER BY up.created_at_epoch ASC\n    `;\n\n    try {\n      const observations = this.db.prepare(obsQuery).all(startEpoch, endEpoch, ...projectParams) as ObservationRecord[];\n      const sessions = this.db.prepare(sessQuery).all(startEpoch, endEpoch, ...projectParams) as SessionSummaryRecord[];\n      const prompts = this.db.prepare(promptQuery).all(startEpoch, endEpoch, ...projectParams) as UserPromptRecord[];\n\n      return {\n        observations,\n        sessions: sessions.map(s => ({\n          id: s.id,\n          sdk_session_id: s.sdk_session_id,\n          project: s.project,\n          request: s.request,\n          completed: s.completed,\n          next_steps: s.next_steps,\n          created_at: s.created_at,\n          created_at_epoch: s.created_at_epoch\n        })),\n        prompts: prompts.map(p => ({\n          id: p.id,\n          claude_session_id: p.claude_session_id,\n          prompt_number: p.prompt_number,\n          prompt_text: p.prompt_text,\n          project: p.project,\n          created_at: p.created_at,\n          created_at_epoch: p.created_at_epoch\n        }))\n      };\n    } catch (err: any) {\n      console.error('[SessionStore] Error querying timeline records:', err.message, project ? `(project: ${project})` : '(all projects)');\n      return { observations: [], sessions: [], prompts: [] };\n    }\n  }\n\n  /**\n   * Get a single user prompt by ID\n   */\n  getPromptById(id: number): {\n    id: number;\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    project: string;\n    created_at: string;\n    created_at_epoch: number;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        p.id,\n        p.claude_session_id,\n        p.prompt_number,\n        p.prompt_text,\n        s.project,\n        p.created_at,\n        p.created_at_epoch\n      FROM user_prompts p\n      LEFT JOIN sdk_sessions s ON p.claude_session_id = s.claude_session_id\n      WHERE p.id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }\n\n  /**\n   * Get multiple user prompts by IDs\n   */\n  getPromptsByIds(ids: number[]): Array<{\n    id: number;\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    project: string;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const stmt = this.db.prepare(`\n      SELECT\n        p.id,\n        p.claude_session_id,\n        p.prompt_number,\n        p.prompt_text,\n        s.project,\n        p.created_at,\n        p.created_at_epoch\n      FROM user_prompts p\n      LEFT JOIN sdk_sessions s ON p.claude_session_id = s.claude_session_id\n      WHERE p.id IN (${placeholders})\n      ORDER BY p.created_at_epoch DESC\n    `);\n\n    return stmt.all(...ids) as Array<{\n      id: number;\n      claude_session_id: string;\n      prompt_number: number;\n      prompt_text: string;\n      project: string;\n      created_at: string;\n      created_at_epoch: number;\n    }>;\n  }\n\n  /**\n   * Get full session summary by ID (includes request_summary and learned_summary)\n   */\n  getSessionSummaryById(id: number): {\n    id: number;\n    sdk_session_id: string | null;\n    claude_session_id: string;\n    project: string;\n    user_prompt: string;\n    request_summary: string | null;\n    learned_summary: string | null;\n    status: string;\n    created_at: string;\n    created_at_epoch: number;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        id,\n        sdk_session_id,\n        claude_session_id,\n        project,\n        user_prompt,\n        request_summary,\n        learned_summary,\n        status,\n        created_at,\n        created_at_epoch\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    this.db.close();\n  }\n\n  // ===========================================\n  // Import Methods (for import-memories script)\n  // ===========================================\n\n  /**\n   * Import SDK session with duplicate checking\n   * Returns: { imported: boolean, id: number }\n   */\n  importSdkSession(session: {\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    user_prompt: string;\n    started_at: string;\n    started_at_epoch: number;\n    completed_at: string | null;\n    completed_at_epoch: number | null;\n    status: string;\n  }): { imported: boolean; id: number } {\n    // Check if session already exists\n    const existing = this.db.prepare(\n      'SELECT id FROM sdk_sessions WHERE claude_session_id = ?'\n    ).get(session.claude_session_id) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO sdk_sessions (\n        claude_session_id, sdk_session_id, project, user_prompt,\n        started_at, started_at_epoch, completed_at, completed_at_epoch, status\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      session.claude_session_id,\n      session.sdk_session_id,\n      session.project,\n      session.user_prompt,\n      session.started_at,\n      session.started_at_epoch,\n      session.completed_at,\n      session.completed_at_epoch,\n      session.status\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }\n\n  /**\n   * Import session summary with duplicate checking\n   * Returns: { imported: boolean, id: number }\n   */\n  importSessionSummary(summary: {\n    sdk_session_id: string;\n    project: string;\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    discovery_tokens: number;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if summary already exists for this session\n    const existing = this.db.prepare(\n      'SELECT id FROM session_summaries WHERE sdk_session_id = ?'\n    ).get(summary.sdk_session_id) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO session_summaries (\n        sdk_session_id, project, request, investigated, learned,\n        completed, next_steps, files_read, files_edited, notes,\n        prompt_number, discovery_tokens, created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      summary.sdk_session_id,\n      summary.project,\n      summary.request,\n      summary.investigated,\n      summary.learned,\n      summary.completed,\n      summary.next_steps,\n      summary.files_read,\n      summary.files_edited,\n      summary.notes,\n      summary.prompt_number,\n      summary.discovery_tokens || 0,\n      summary.created_at,\n      summary.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }\n\n  /**\n   * Import observation with duplicate checking\n   * Duplicates are identified by sdk_session_id + title + created_at_epoch\n   * Returns: { imported: boolean, id: number }\n   */\n  importObservation(obs: {\n    sdk_session_id: string;\n    project: string;\n    text: string | null;\n    type: string;\n    title: string | null;\n    subtitle: string | null;\n    facts: string | null;\n    narrative: string | null;\n    concepts: string | null;\n    files_read: string | null;\n    files_modified: string | null;\n    prompt_number: number | null;\n    discovery_tokens: number;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if observation already exists\n    const existing = this.db.prepare(`\n      SELECT id FROM observations\n      WHERE sdk_session_id = ? AND title = ? AND created_at_epoch = ?\n    `).get(obs.sdk_session_id, obs.title, obs.created_at_epoch) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO observations (\n        sdk_session_id, project, text, type, title, subtitle,\n        facts, narrative, concepts, files_read, files_modified,\n        prompt_number, discovery_tokens, created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      obs.sdk_session_id,\n      obs.project,\n      obs.text,\n      obs.type,\n      obs.title,\n      obs.subtitle,\n      obs.facts,\n      obs.narrative,\n      obs.concepts,\n      obs.files_read,\n      obs.files_modified,\n      obs.prompt_number,\n      obs.discovery_tokens || 0,\n      obs.created_at,\n      obs.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }\n\n  /**\n   * Import user prompt with duplicate checking\n   * Duplicates are identified by claude_session_id + prompt_number\n   * Returns: { imported: boolean, id: number }\n   */\n  importUserPrompt(prompt: {\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if prompt already exists\n    const existing = this.db.prepare(`\n      SELECT id FROM user_prompts\n      WHERE claude_session_id = ? AND prompt_number = ?\n    `).get(prompt.claude_session_id, prompt.prompt_number) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO user_prompts (\n        claude_session_id, prompt_number, prompt_text,\n        created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      prompt.claude_session_id,\n      prompt.prompt_number,\n      prompt.prompt_text,\n      prompt.created_at,\n      prompt.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_23": {
      "name": "constructor",
      "type": "method",
      "start_line": 23,
      "end_line": 44,
      "content_hash": "fb0b72c6772ff388ed4ee1fc7a5aa78b50dd8702",
      "content": "  constructor() {\n    ensureDir(DATA_DIR);\n    this.db = new Database(DB_PATH);\n\n    // Ensure optimized settings\n    this.db.run('PRAGMA journal_mode = WAL');\n    this.db.run('PRAGMA synchronous = NORMAL');\n    this.db.run('PRAGMA foreign_keys = ON');\n\n    // Initialize schema if needed (fresh database)\n    this.initializeSchema();\n\n    // Run migrations\n    this.ensureWorkerPortColumn();\n    this.ensurePromptTrackingColumns();\n    this.removeSessionSummariesUniqueConstraint();\n    this.addObservationHierarchicalFields();\n    this.makeObservationsTextNullable();\n    this.createUserPromptsTable();\n    this.ensureDiscoveryTokensColumn();\n    this.createPendingMessagesTable();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initializeSchema_53": {
      "name": "initializeSchema",
      "type": "method",
      "start_line": 53,
      "end_line": 141,
      "content_hash": "c704ddadbed34e409060ba4fcff6ff620ac0f871",
      "content": "  private initializeSchema(): void {\n    try {\n      // Create schema_versions table if it doesn't exist\n      this.db.run(`\n        CREATE TABLE IF NOT EXISTS schema_versions (\n          id INTEGER PRIMARY KEY,\n          version INTEGER UNIQUE NOT NULL,\n          applied_at TEXT NOT NULL\n        )\n      `);\n\n      // Get applied migrations\n      const appliedVersions = this.db.prepare('SELECT version FROM schema_versions ORDER BY version').all() as SchemaVersion[];\n      const maxApplied = appliedVersions.length > 0 ? Math.max(...appliedVersions.map(v => v.version)) : 0;\n\n      // Only run migration004 if no migrations have been applied\n      // This creates the sdk_sessions, observations, and session_summaries tables\n      if (maxApplied === 0) {\n        console.log('[SessionStore] Initializing fresh database with migration004...');\n\n        // Migration004: SDK agent architecture tables\n        this.db.run(`\n          CREATE TABLE IF NOT EXISTS sdk_sessions (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            claude_session_id TEXT UNIQUE NOT NULL,\n            sdk_session_id TEXT UNIQUE,\n            project TEXT NOT NULL,\n            user_prompt TEXT,\n            started_at TEXT NOT NULL,\n            started_at_epoch INTEGER NOT NULL,\n            completed_at TEXT,\n            completed_at_epoch INTEGER,\n            status TEXT CHECK(status IN ('active', 'completed', 'failed')) NOT NULL DEFAULT 'active'\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_claude_id ON sdk_sessions(claude_session_id);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_sdk_id ON sdk_sessions(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_project ON sdk_sessions(project);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_status ON sdk_sessions(status);\n          CREATE INDEX IF NOT EXISTS idx_sdk_sessions_started ON sdk_sessions(started_at_epoch DESC);\n\n          CREATE TABLE IF NOT EXISTS observations (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            sdk_session_id TEXT NOT NULL,\n            project TEXT NOT NULL,\n            text TEXT NOT NULL,\n            type TEXT NOT NULL CHECK(type IN ('decision', 'bugfix', 'feature', 'refactor', 'discovery')),\n            created_at TEXT NOT NULL,\n            created_at_epoch INTEGER NOT NULL,\n            FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_observations_sdk_session ON observations(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_observations_project ON observations(project);\n          CREATE INDEX IF NOT EXISTS idx_observations_type ON observations(type);\n          CREATE INDEX IF NOT EXISTS idx_observations_created ON observations(created_at_epoch DESC);\n\n          CREATE TABLE IF NOT EXISTS session_summaries (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            sdk_session_id TEXT UNIQUE NOT NULL,\n            project TEXT NOT NULL,\n            request TEXT,\n            investigated TEXT,\n            learned TEXT,\n            completed TEXT,\n            next_steps TEXT,\n            files_read TEXT,\n            files_edited TEXT,\n            notes TEXT,\n            created_at TEXT NOT NULL,\n            created_at_epoch INTEGER NOT NULL,\n            FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n          );\n\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_sdk_session ON session_summaries(sdk_session_id);\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_project ON session_summaries(project);\n          CREATE INDEX IF NOT EXISTS idx_session_summaries_created ON session_summaries(created_at_epoch DESC);\n        `);\n\n        // Record migration004 as applied\n        this.db.prepare('INSERT INTO schema_versions (version, applied_at) VALUES (?, ?)').run(4, new Date().toISOString());\n\n        console.log('[SessionStore] Migration004 applied successfully');\n      }\n    } catch (error: any) {\n      console.error('[SessionStore] Schema initialization error:', error.message);\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureWorkerPortColumn_146": {
      "name": "ensureWorkerPortColumn",
      "type": "method",
      "start_line": 146,
      "end_line": 162,
      "content_hash": "989e5891656b4abf72b85d237c4dbcf4741673a4",
      "content": "  private ensureWorkerPortColumn(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(5) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if column exists\n    const tableInfo = this.db.query('PRAGMA table_info(sdk_sessions)').all() as TableColumnInfo[];\n    const hasWorkerPort = tableInfo.some(col => col.name === 'worker_port');\n\n    if (!hasWorkerPort) {\n      this.db.run('ALTER TABLE sdk_sessions ADD COLUMN worker_port INTEGER');\n      console.log('[SessionStore] Added worker_port column to sdk_sessions table');\n    }\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(5, new Date().toISOString());\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensurePromptTrackingColumns_167": {
      "name": "ensurePromptTrackingColumns",
      "type": "method",
      "start_line": 167,
      "end_line": 201,
      "content_hash": "24c7fe8b76c0198a493e52cb4c73f26069f9401f",
      "content": "  private ensurePromptTrackingColumns(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(6) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check sdk_sessions for prompt_counter\n    const sessionsInfo = this.db.query('PRAGMA table_info(sdk_sessions)').all() as TableColumnInfo[];\n    const hasPromptCounter = sessionsInfo.some(col => col.name === 'prompt_counter');\n\n    if (!hasPromptCounter) {\n      this.db.run('ALTER TABLE sdk_sessions ADD COLUMN prompt_counter INTEGER DEFAULT 0');\n      console.log('[SessionStore] Added prompt_counter column to sdk_sessions table');\n    }\n\n    // Check observations for prompt_number\n    const observationsInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const obsHasPromptNumber = observationsInfo.some(col => col.name === 'prompt_number');\n\n    if (!obsHasPromptNumber) {\n      this.db.run('ALTER TABLE observations ADD COLUMN prompt_number INTEGER');\n      console.log('[SessionStore] Added prompt_number column to observations table');\n    }\n\n    // Check session_summaries for prompt_number\n    const summariesInfo = this.db.query('PRAGMA table_info(session_summaries)').all() as TableColumnInfo[];\n    const sumHasPromptNumber = summariesInfo.some(col => col.name === 'prompt_number');\n\n    if (!sumHasPromptNumber) {\n      this.db.run('ALTER TABLE session_summaries ADD COLUMN prompt_number INTEGER');\n      console.log('[SessionStore] Added prompt_number column to session_summaries table');\n    }\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(6, new Date().toISOString());\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_removeSessionSummariesUniqueConstraint_206": {
      "name": "removeSessionSummariesUniqueConstraint",
      "type": "method",
      "start_line": 206,
      "end_line": 282,
      "content_hash": "b8c734604f3954a5e5a0e273890b415d3e29c1a0",
      "content": "  private removeSessionSummariesUniqueConstraint(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(7) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if UNIQUE constraint exists\n    const summariesIndexes = this.db.query('PRAGMA index_list(session_summaries)').all() as IndexInfo[];\n    const hasUniqueConstraint = summariesIndexes.some(idx => idx.unique === 1);\n\n    if (!hasUniqueConstraint) {\n      // Already migrated (no constraint exists)\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(7, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Removing UNIQUE constraint from session_summaries.sdk_session_id...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create new table without UNIQUE constraint\n      this.db.run(`\n        CREATE TABLE session_summaries_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          sdk_session_id TEXT NOT NULL,\n          project TEXT NOT NULL,\n          request TEXT,\n          investigated TEXT,\n          learned TEXT,\n          completed TEXT,\n          next_steps TEXT,\n          files_read TEXT,\n          files_edited TEXT,\n          notes TEXT,\n          prompt_number INTEGER,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n        )\n      `);\n\n      // Copy data from old table\n      this.db.run(`\n        INSERT INTO session_summaries_new\n        SELECT id, sdk_session_id, project, request, investigated, learned,\n               completed, next_steps, files_read, files_edited, notes,\n               prompt_number, created_at, created_at_epoch\n        FROM session_summaries\n      `);\n\n      // Drop old table\n      this.db.run('DROP TABLE session_summaries');\n\n      // Rename new table\n      this.db.run('ALTER TABLE session_summaries_new RENAME TO session_summaries');\n\n      // Recreate indexes\n      this.db.run(`\n        CREATE INDEX idx_session_summaries_sdk_session ON session_summaries(sdk_session_id);\n        CREATE INDEX idx_session_summaries_project ON session_summaries(project);\n        CREATE INDEX idx_session_summaries_created ON session_summaries(created_at_epoch DESC);\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(7, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully removed UNIQUE constraint from session_summaries.sdk_session_id');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_addObservationHierarchicalFields_287": {
      "name": "addObservationHierarchicalFields",
      "type": "method",
      "start_line": 287,
      "end_line": 319,
      "content_hash": "22a663cf32d81c67c9c91b7e372edb77c782f647",
      "content": "  private addObservationHierarchicalFields(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(8) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if new fields already exist\n    const tableInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const hasTitle = tableInfo.some(col => col.name === 'title');\n\n    if (hasTitle) {\n      // Already migrated\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(8, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Adding hierarchical fields to observations table...');\n\n    // Add new columns\n    this.db.run(`\n      ALTER TABLE observations ADD COLUMN title TEXT;\n      ALTER TABLE observations ADD COLUMN subtitle TEXT;\n      ALTER TABLE observations ADD COLUMN facts TEXT;\n      ALTER TABLE observations ADD COLUMN narrative TEXT;\n      ALTER TABLE observations ADD COLUMN concepts TEXT;\n      ALTER TABLE observations ADD COLUMN files_read TEXT;\n      ALTER TABLE observations ADD COLUMN files_modified TEXT;\n    `);\n\n    // Record migration\n    this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(8, new Date().toISOString());\n\n    console.log('[SessionStore] Successfully added hierarchical fields to observations table');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_makeObservationsTextNullable_325": {
      "name": "makeObservationsTextNullable",
      "type": "method",
      "start_line": 325,
      "end_line": 403,
      "content_hash": "207b398f3a98aa65689f02eb2a8a21dc3506c14e",
      "content": "  private makeObservationsTextNullable(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(9) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if text column is already nullable\n    const tableInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n    const textColumn = tableInfo.find(col => col.name === 'text');\n\n    if (!textColumn || textColumn.notnull === 0) {\n      // Already migrated or text column doesn't exist\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(9, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Making observations.text nullable...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create new table with text as nullable\n      this.db.run(`\n        CREATE TABLE observations_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          sdk_session_id TEXT NOT NULL,\n          project TEXT NOT NULL,\n          text TEXT,\n          type TEXT NOT NULL CHECK(type IN ('decision', 'bugfix', 'feature', 'refactor', 'discovery', 'change')),\n          title TEXT,\n          subtitle TEXT,\n          facts TEXT,\n          narrative TEXT,\n          concepts TEXT,\n          files_read TEXT,\n          files_modified TEXT,\n          prompt_number INTEGER,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(sdk_session_id) REFERENCES sdk_sessions(sdk_session_id) ON DELETE CASCADE\n        )\n      `);\n\n      // Copy data from old table (all existing columns)\n      this.db.run(`\n        INSERT INTO observations_new\n        SELECT id, sdk_session_id, project, text, type, title, subtitle, facts,\n               narrative, concepts, files_read, files_modified, prompt_number,\n               created_at, created_at_epoch\n        FROM observations\n      `);\n\n      // Drop old table\n      this.db.run('DROP TABLE observations');\n\n      // Rename new table\n      this.db.run('ALTER TABLE observations_new RENAME TO observations');\n\n      // Recreate indexes\n      this.db.run(`\n        CREATE INDEX idx_observations_sdk_session ON observations(sdk_session_id);\n        CREATE INDEX idx_observations_project ON observations(project);\n        CREATE INDEX idx_observations_type ON observations(type);\n        CREATE INDEX idx_observations_created ON observations(created_at_epoch DESC);\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(9, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully made observations.text nullable');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createUserPromptsTable_408": {
      "name": "createUserPromptsTable",
      "type": "method",
      "start_line": 408,
      "end_line": 486,
      "content_hash": "c002d8d42763fc5dc63c00b10cf5901e31ad01d7",
      "content": "  private createUserPromptsTable(): void {\n    // Check if migration already applied\n    const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(10) as SchemaVersion | undefined;\n    if (applied) return;\n\n    // Check if table already exists\n    const tableInfo = this.db.query('PRAGMA table_info(user_prompts)').all() as TableColumnInfo[];\n    if (tableInfo.length > 0) {\n      // Already migrated\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(10, new Date().toISOString());\n      return;\n    }\n\n    console.log('[SessionStore] Creating user_prompts table with FTS5 support...');\n\n    // Begin transaction\n    this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Create main table (using claude_session_id since sdk_session_id is set asynchronously by worker)\n      this.db.run(`\n        CREATE TABLE user_prompts (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          claude_session_id TEXT NOT NULL,\n          prompt_number INTEGER NOT NULL,\n          prompt_text TEXT NOT NULL,\n          created_at TEXT NOT NULL,\n          created_at_epoch INTEGER NOT NULL,\n          FOREIGN KEY(claude_session_id) REFERENCES sdk_sessions(claude_session_id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX idx_user_prompts_claude_session ON user_prompts(claude_session_id);\n        CREATE INDEX idx_user_prompts_created ON user_prompts(created_at_epoch DESC);\n        CREATE INDEX idx_user_prompts_prompt_number ON user_prompts(prompt_number);\n        CREATE INDEX idx_user_prompts_lookup ON user_prompts(claude_session_id, prompt_number);\n      `);\n\n      // Create FTS5 virtual table\n      this.db.run(`\n        CREATE VIRTUAL TABLE user_prompts_fts USING fts5(\n          prompt_text,\n          content='user_prompts',\n          content_rowid='id'\n        );\n      `);\n\n      // Create triggers to sync FTS5\n      this.db.run(`\n        CREATE TRIGGER user_prompts_ai AFTER INSERT ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(rowid, prompt_text)\n          VALUES (new.id, new.prompt_text);\n        END;\n\n        CREATE TRIGGER user_prompts_ad AFTER DELETE ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(user_prompts_fts, rowid, prompt_text)\n          VALUES('delete', old.id, old.prompt_text);\n        END;\n\n        CREATE TRIGGER user_prompts_au AFTER UPDATE ON user_prompts BEGIN\n          INSERT INTO user_prompts_fts(user_prompts_fts, rowid, prompt_text)\n          VALUES('delete', old.id, old.prompt_text);\n          INSERT INTO user_prompts_fts(rowid, prompt_text)\n          VALUES (new.id, new.prompt_text);\n        END;\n      `);\n\n      // Commit transaction\n      this.db.run('COMMIT');\n\n      // Record migration\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(10, new Date().toISOString());\n\n      console.log('[SessionStore] Successfully created user_prompts table with FTS5 support');\n    } catch (error: any) {\n      // Rollback on error\n      this.db.run('ROLLBACK');\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureDiscoveryTokensColumn_493": {
      "name": "ensureDiscoveryTokensColumn",
      "type": "method",
      "start_line": 493,
      "end_line": 523,
      "content_hash": "d7643d9ab97f6512075f9fdfc62fef0a4dd2b442",
      "content": "  private ensureDiscoveryTokensColumn(): void {\n    try {\n      // Check if migration already applied to avoid unnecessary re-runs\n      const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(11) as SchemaVersion | undefined;\n      if (applied) return;\n\n      // Check if discovery_tokens column exists in observations table\n      const observationsInfo = this.db.query('PRAGMA table_info(observations)').all() as TableColumnInfo[];\n      const obsHasDiscoveryTokens = observationsInfo.some(col => col.name === 'discovery_tokens');\n\n      if (!obsHasDiscoveryTokens) {\n        this.db.run('ALTER TABLE observations ADD COLUMN discovery_tokens INTEGER DEFAULT 0');\n        console.log('[SessionStore] Added discovery_tokens column to observations table');\n      }\n\n      // Check if discovery_tokens column exists in session_summaries table\n      const summariesInfo = this.db.query('PRAGMA table_info(session_summaries)').all() as TableColumnInfo[];\n      const sumHasDiscoveryTokens = summariesInfo.some(col => col.name === 'discovery_tokens');\n\n      if (!sumHasDiscoveryTokens) {\n        this.db.run('ALTER TABLE session_summaries ADD COLUMN discovery_tokens INTEGER DEFAULT 0');\n        console.log('[SessionStore] Added discovery_tokens column to session_summaries table');\n      }\n\n      // Record migration only after successful column verification/addition\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(11, new Date().toISOString());\n    } catch (error: any) {\n      console.error('[SessionStore] Discovery tokens migration error:', error.message);\n      throw error; // Re-throw to prevent silent failures\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createPendingMessagesTable_530": {
      "name": "createPendingMessagesTable",
      "type": "method",
      "start_line": 530,
      "end_line": 578,
      "content_hash": "5a9350b50e7a478feaefbc00acf5d6fc20ea084f",
      "content": "  private createPendingMessagesTable(): void {\n    try {\n      // Check if migration already applied\n      const applied = this.db.prepare('SELECT version FROM schema_versions WHERE version = ?').get(16) as SchemaVersion | undefined;\n      if (applied) return;\n\n      // Check if table already exists\n      const tables = this.db.query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='pending_messages'\").all() as TableNameRow[];\n      if (tables.length > 0) {\n        this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(16, new Date().toISOString());\n        return;\n      }\n\n      console.log('[SessionStore] Creating pending_messages table...');\n\n      this.db.run(`\n        CREATE TABLE pending_messages (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          session_db_id INTEGER NOT NULL,\n          claude_session_id TEXT NOT NULL,\n          message_type TEXT NOT NULL CHECK(message_type IN ('observation', 'summarize')),\n          tool_name TEXT,\n          tool_input TEXT,\n          tool_response TEXT,\n          cwd TEXT,\n          last_user_message TEXT,\n          last_assistant_message TEXT,\n          prompt_number INTEGER,\n          status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'processed', 'failed')),\n          retry_count INTEGER NOT NULL DEFAULT 0,\n          created_at_epoch INTEGER NOT NULL,\n          started_processing_at_epoch INTEGER,\n          completed_at_epoch INTEGER,\n          FOREIGN KEY (session_db_id) REFERENCES sdk_sessions(id) ON DELETE CASCADE\n        )\n      `);\n\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_session ON pending_messages(session_db_id)');\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_status ON pending_messages(status)');\n      this.db.run('CREATE INDEX IF NOT EXISTS idx_pending_messages_claude_session ON pending_messages(claude_session_id)');\n\n      this.db.prepare('INSERT OR IGNORE INTO schema_versions (version, applied_at) VALUES (?, ?)').run(16, new Date().toISOString());\n\n      console.log('[SessionStore] pending_messages table created successfully');\n    } catch (error: any) {\n      console.error('[SessionStore] Pending messages table migration error:', error.message);\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentSummaries_583": {
      "name": "getRecentSummaries",
      "type": "method",
      "start_line": 583,
      "end_line": 606,
      "content_hash": "729464411f6ae5320820b047658a797c72c2966a",
      "content": "  getRecentSummaries(project: string, limit: number = 10): Array<{\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        request, investigated, learned, completed, next_steps,\n        files_read, files_edited, notes, prompt_number, created_at\n      FROM session_summaries\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentSummariesWithSessionInfo_611": {
      "name": "getRecentSummariesWithSessionInfo",
      "type": "method",
      "start_line": 611,
      "end_line": 631,
      "content_hash": "317432890e0c5792871cf5afcbae443287c8ef45",
      "content": "  getRecentSummariesWithSessionInfo(project: string, limit: number = 3): Array<{\n    sdk_session_id: string;\n    request: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        sdk_session_id, request, learned, completed, next_steps,\n        prompt_number, created_at\n      FROM session_summaries\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentObservations_636": {
      "name": "getRecentObservations",
      "type": "method",
      "start_line": 636,
      "end_line": 651,
      "content_hash": "30383df5b3fbdeb133122701305871eff6bec306",
      "content": "  getRecentObservations(project: string, limit: number = 20): Array<{\n    type: string;\n    text: string;\n    prompt_number: number | null;\n    created_at: string;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT type, text, prompt_number, created_at\n      FROM observations\n      WHERE project = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(project, limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllRecentObservations_656": {
      "name": "getAllRecentObservations",
      "type": "method",
      "start_line": 656,
      "end_line": 675,
      "content_hash": "d180a27b9264c66558d0ce6c63c56ef83898c67b",
      "content": "  getAllRecentObservations(limit: number = 100): Array<{\n    id: number;\n    type: string;\n    title: string | null;\n    subtitle: string | null;\n    text: string;\n    project: string;\n    prompt_number: number | null;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT id, type, title, subtitle, text, project, prompt_number, created_at, created_at_epoch\n      FROM observations\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllRecentSummaries_680": {
      "name": "getAllRecentSummaries",
      "type": "method",
      "start_line": 680,
      "end_line": 705,
      "content_hash": "20f0686947780251e43c034bc0e020da4e6bfa18",
      "content": "  getAllRecentSummaries(limit: number = 50): Array<{\n    id: number;\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    project: string;\n    prompt_number: number | null;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT id, request, investigated, learned, completed, next_steps,\n             files_read, files_edited, notes, project, prompt_number,\n             created_at, created_at_epoch\n      FROM session_summaries\n      ORDER BY created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllRecentUserPrompts_710": {
      "name": "getAllRecentUserPrompts",
      "type": "method",
      "start_line": 710,
      "end_line": 735,
      "content_hash": "8a64334e0af2997f72d137fccff61571fbe11628",
      "content": "  getAllRecentUserPrompts(limit: number = 100): Array<{\n    id: number;\n    claude_session_id: string;\n    project: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT\n        up.id,\n        up.claude_session_id,\n        s.project,\n        up.prompt_number,\n        up.prompt_text,\n        up.created_at,\n        up.created_at_epoch\n      FROM user_prompts up\n      LEFT JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      ORDER BY up.created_at_epoch DESC\n      LIMIT ?\n    `);\n\n    return stmt.all(limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllProjects_740": {
      "name": "getAllProjects",
      "type": "method",
      "start_line": 740,
      "end_line": 750,
      "content_hash": "5570d44810d69d5defdaa55bfe80aae40aa6a824",
      "content": "  getAllProjects(): string[] {\n    const stmt = this.db.prepare(`\n      SELECT DISTINCT project\n      FROM sdk_sessions\n      WHERE project IS NOT NULL AND project != ''\n      ORDER BY project ASC\n    `);\n\n    const rows = stmt.all() as Array<{ project: string }>;\n    return rows.map(row => row.project);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getLatestUserPrompt_756": {
      "name": "getLatestUserPrompt",
      "type": "method",
      "start_line": 756,
      "end_line": 778,
      "content_hash": "348054b91c2932ca36c3a05003d65aa69a3bcc44",
      "content": "  getLatestUserPrompt(claudeSessionId: string): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at_epoch: number;\n  } | undefined {\n    const stmt = this.db.prepare(`\n      SELECT\n        up.*,\n        s.sdk_session_id,\n        s.project\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.claude_session_id = ?\n      ORDER BY up.created_at_epoch DESC\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) as LatestPromptResult | undefined;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentSessionsWithStatus_783": {
      "name": "getRecentSessionsWithStatus",
      "type": "method",
      "start_line": 783,
      "end_line": 810,
      "content_hash": "736fa4e38985c51b2d841b53eb96a7ff1a3ca777",
      "content": "  getRecentSessionsWithStatus(project: string, limit: number = 3): Array<{\n    sdk_session_id: string | null;\n    status: string;\n    started_at: string;\n    user_prompt: string | null;\n    has_summary: boolean;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT * FROM (\n        SELECT\n          s.sdk_session_id,\n          s.status,\n          s.started_at,\n          s.started_at_epoch,\n          s.user_prompt,\n          CASE WHEN sum.sdk_session_id IS NOT NULL THEN 1 ELSE 0 END as has_summary\n        FROM sdk_sessions s\n        LEFT JOIN session_summaries sum ON s.sdk_session_id = sum.sdk_session_id\n        WHERE s.project = ? AND s.sdk_session_id IS NOT NULL\n        GROUP BY s.sdk_session_id\n        ORDER BY s.started_at_epoch DESC\n        LIMIT ?\n      )\n      ORDER BY started_at_epoch ASC\n    `);\n\n    return stmt.all(project, limit);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getObservationsForSession_815": {
      "name": "getObservationsForSession",
      "type": "method",
      "start_line": 815,
      "end_line": 829,
      "content_hash": "0a7882f0a5c670aae1b82162e42efee4e0b797ac",
      "content": "  getObservationsForSession(sdkSessionId: string): Array<{\n    title: string;\n    subtitle: string;\n    type: string;\n    prompt_number: number | null;\n  }> {\n    const stmt = this.db.prepare(`\n      SELECT title, subtitle, type, prompt_number\n      FROM observations\n      WHERE sdk_session_id = ?\n      ORDER BY created_at_epoch ASC\n    `);\n\n    return stmt.all(sdkSessionId);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getObservationById_834": {
      "name": "getObservationById",
      "type": "method",
      "start_line": 834,
      "end_line": 842,
      "content_hash": "ba4e3b621e923a7fe1c8cc98ba89591b9a51fb4f",
      "content": "  getObservationById(id: number): ObservationRecord | null {\n    const stmt = this.db.prepare(`\n      SELECT *\n      FROM observations\n      WHERE id = ?\n    `);\n\n    return stmt.get(id) as ObservationRecord | undefined || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getObservationsByIds_847": {
      "name": "getObservationsByIds",
      "type": "method",
      "start_line": 847,
      "end_line": 915,
      "content_hash": "5bd63454107baf79f27ca366ab42a106d3327220",
      "content": "  getObservationsByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string; type?: string | string[]; concepts?: string | string[]; files?: string | string[] } = {}\n  ): ObservationRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project, type, concepts, files } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n\n    // Build placeholders for IN clause\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n    const additionalConditions: string[] = [];\n\n    // Apply project filter\n    if (project) {\n      additionalConditions.push('project = ?');\n      params.push(project);\n    }\n\n    // Apply type filter\n    if (type) {\n      if (Array.isArray(type)) {\n        const typePlaceholders = type.map(() => '?').join(',');\n        additionalConditions.push(`type IN (${typePlaceholders})`);\n        params.push(...type);\n      } else {\n        additionalConditions.push('type = ?');\n        params.push(type);\n      }\n    }\n\n    // Apply concepts filter\n    if (concepts) {\n      const conceptsList = Array.isArray(concepts) ? concepts : [concepts];\n      const conceptConditions = conceptsList.map(() =>\n        'EXISTS (SELECT 1 FROM json_each(concepts) WHERE value = ?)'\n      );\n      params.push(...conceptsList);\n      additionalConditions.push(`(${conceptConditions.join(' OR ')})`);\n    }\n\n    // Apply files filter\n    if (files) {\n      const filesList = Array.isArray(files) ? files : [files];\n      const fileConditions = filesList.map(() => {\n        return '(EXISTS (SELECT 1 FROM json_each(files_read) WHERE value LIKE ?) OR EXISTS (SELECT 1 FROM json_each(files_modified) WHERE value LIKE ?))';\n      });\n      filesList.forEach(file => {\n        params.push(`%${file}%`, `%${file}%`);\n      });\n      additionalConditions.push(`(${fileConditions.join(' OR ')})`);\n    }\n\n    const whereClause = additionalConditions.length > 0\n      ? `WHERE id IN (${placeholders}) AND ${additionalConditions.join(' AND ')}`\n      : `WHERE id IN (${placeholders})`;\n\n    const stmt = this.db.prepare(`\n      SELECT *\n      FROM observations\n      ${whereClause}\n      ORDER BY created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as ObservationRecord[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSummaryForSession_920": {
      "name": "getSummaryForSession",
      "type": "method",
      "start_line": 920,
      "end_line": 943,
      "content_hash": "da5c287e9f9c127ca785c45baa0b9582fa2bdf7d",
      "content": "  getSummaryForSession(sdkSessionId: string): {\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    created_at: string;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        request, investigated, learned, completed, next_steps,\n        files_read, files_edited, notes, prompt_number, created_at\n      FROM session_summaries\n      WHERE sdk_session_id = ?\n      ORDER BY created_at_epoch DESC\n      LIMIT 1\n    `);\n\n    return stmt.get(sdkSessionId) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getFilesForSession_948": {
      "name": "getFilesForSession",
      "type": "method",
      "start_line": 948,
      "end_line": 988,
      "content_hash": "cfebbe4e2103b8a088528a7d68ce38de6a7430f6",
      "content": "  getFilesForSession(sdkSessionId: string): {\n    filesRead: string[];\n    filesModified: string[];\n  } {\n    const stmt = this.db.prepare(`\n      SELECT files_read, files_modified\n      FROM observations\n      WHERE sdk_session_id = ?\n    `);\n\n    const rows = stmt.all(sdkSessionId) as Array<{\n      files_read: string | null;\n      files_modified: string | null;\n    }>;\n\n    const filesReadSet = new Set<string>();\n    const filesModifiedSet = new Set<string>();\n\n    for (const row of rows) {\n      // Parse files_read\n      if (row.files_read) {\n        const files = JSON.parse(row.files_read);\n        if (Array.isArray(files)) {\n          files.forEach(f => filesReadSet.add(f));\n        }\n      }\n\n      // Parse files_modified\n      if (row.files_modified) {\n        const files = JSON.parse(row.files_modified);\n        if (Array.isArray(files)) {\n          files.forEach(f => filesModifiedSet.add(f));\n        }\n      }\n    }\n\n    return {\n      filesRead: Array.from(filesReadSet),\n      filesModified: Array.from(filesModifiedSet)\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionById_993": {
      "name": "getSessionById",
      "type": "method",
      "start_line": 993,
      "end_line": 1008,
      "content_hash": "d68e00f5c242e789694e94faae1f9695cfbf0df2",
      "content": "  getSessionById(id: number): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string | null;\n    project: string;\n    user_prompt: string;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT id, claude_session_id, sdk_session_id, project, user_prompt\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSdkSessionsBySessionIds_1014": {
      "name": "getSdkSessionsBySessionIds",
      "type": "method",
      "start_line": 1014,
      "end_line": 1038,
      "content_hash": "cda736ad18df4962731199b488964ffb15bab496",
      "content": "  getSdkSessionsBySessionIds(sdkSessionIds: string[]): {\n    id: number;\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    user_prompt: string;\n    started_at: string;\n    started_at_epoch: number;\n    completed_at: string | null;\n    completed_at_epoch: number | null;\n    status: string;\n  }[] {\n    if (sdkSessionIds.length === 0) return [];\n\n    const placeholders = sdkSessionIds.map(() => '?').join(',');\n    const stmt = this.db.prepare(`\n      SELECT id, claude_session_id, sdk_session_id, project, user_prompt,\n             started_at, started_at_epoch, completed_at, completed_at_epoch, status\n      FROM sdk_sessions\n      WHERE sdk_session_id IN (${placeholders})\n      ORDER BY started_at_epoch DESC\n    `);\n\n    return stmt.all(...sdkSessionIds) as any[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findActiveSDKSession_1043": {
      "name": "findActiveSDKSession",
      "type": "method",
      "start_line": 1043,
      "end_line": 1057,
      "content_hash": "e7536c4affb20a1df4d7d1b10c0429bc93dc711d",
      "content": "  findActiveSDKSession(claudeSessionId: string): {\n    id: number;\n    sdk_session_id: string | null;\n    project: string;\n    worker_port: number | null;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT id, sdk_session_id, project, worker_port\n      FROM sdk_sessions\n      WHERE claude_session_id = ? AND status = 'active'\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findAnySDKSession_1062": {
      "name": "findAnySDKSession",
      "type": "method",
      "start_line": 1062,
      "end_line": 1071,
      "content_hash": "cbafd111d6fdc4f5d407af83e3e1e19441accd74",
      "content": "  findAnySDKSession(claudeSessionId: string): { id: number } | null {\n    const stmt = this.db.prepare(`\n      SELECT id\n      FROM sdk_sessions\n      WHERE claude_session_id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(claudeSessionId) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_reactivateSession_1076": {
      "name": "reactivateSession",
      "type": "method",
      "start_line": 1076,
      "end_line": 1084,
      "content_hash": "8226a124c4ba68e09b47b49c8eb06af492d4f12c",
      "content": "  reactivateSession(id: number, userPrompt: string): void {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'active', user_prompt = ?, worker_port = NULL\n      WHERE id = ?\n    `);\n\n    stmt.run(userPrompt, id);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_incrementPromptCounter_1089": {
      "name": "incrementPromptCounter",
      "type": "method",
      "start_line": 1089,
      "end_line": 1103,
      "content_hash": "c338f53f19b611754964aa80101bc8dbb3596273",
      "content": "  incrementPromptCounter(id: number): number {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET prompt_counter = COALESCE(prompt_counter, 0) + 1\n      WHERE id = ?\n    `);\n\n    stmt.run(id);\n\n    const result = this.db.prepare(`\n      SELECT prompt_counter FROM sdk_sessions WHERE id = ?\n    `).get(id) as { prompt_counter: number } | undefined;\n\n    return result?.prompt_counter || 1;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPromptCounter_1108": {
      "name": "getPromptCounter",
      "type": "method",
      "start_line": 1108,
      "end_line": 1114,
      "content_hash": "66e58095a58b381345b15f102d8243ac4bb5b2af",
      "content": "  getPromptCounter(id: number): number {\n    const result = this.db.prepare(`\n      SELECT prompt_counter FROM sdk_sessions WHERE id = ?\n    `).get(id) as { prompt_counter: number | null } | undefined;\n\n    return result?.prompt_counter || 0;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createSDKSession_1142": {
      "name": "createSDKSession",
      "type": "method",
      "start_line": 1142,
      "end_line": 1178,
      "content_hash": "50c5d94005efa2ec05533e9ab849dcd3669c1126",
      "content": "  createSDKSession(claudeSessionId: string, project: string, userPrompt: string): number {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // CRITICAL: INSERT OR IGNORE makes this idempotent\n    // First call (prompt #1): Creates new row\n    // Subsequent calls (prompt #2+): Ignored, returns existing ID\n    const stmt = this.db.prepare(`\n      INSERT OR IGNORE INTO sdk_sessions\n      (claude_session_id, sdk_session_id, project, user_prompt, started_at, started_at_epoch, status)\n      VALUES (?, ?, ?, ?, ?, ?, 'active')\n    `);\n\n    const result = stmt.run(claudeSessionId, claudeSessionId, project, userPrompt, now.toISOString(), nowEpoch);\n\n    // If lastInsertRowid is 0, insert was ignored (session exists), so fetch existing ID\n    if (result.lastInsertRowid === 0 || result.changes === 0) {\n      // Session exists - UPDATE project and user_prompt if we have non-empty values\n      // This fixes the bug where SAVE hook creates session with empty project,\n      // then NEW hook can't update it because INSERT OR IGNORE skips the insert\n      if (project && project.trim() !== '') {\n        this.db.prepare(`\n          UPDATE sdk_sessions\n          SET project = ?, user_prompt = ?\n          WHERE claude_session_id = ?\n        `).run(project, userPrompt, claudeSessionId);\n      }\n\n      const selectStmt = this.db.prepare(`\n        SELECT id FROM sdk_sessions WHERE claude_session_id = ? LIMIT 1\n      `);\n      const existing = selectStmt.get(claudeSessionId) as { id: number } | undefined;\n      return existing!.id;\n    }\n\n    return result.lastInsertRowid as number;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateSDKSessionId_1185": {
      "name": "updateSDKSessionId",
      "type": "method",
      "start_line": 1185,
      "end_line": 1205,
      "content_hash": "6aa26bf14959c1d79ef0b38dd080b512cfedb68f",
      "content": "  updateSDKSessionId(id: number, sdkSessionId: string): boolean {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET sdk_session_id = ?\n      WHERE id = ? AND sdk_session_id IS NULL\n    `);\n\n    const result = stmt.run(sdkSessionId, id);\n\n    if (result.changes === 0) {\n      // This is expected behavior - sdk_session_id is already set\n      // Only log at debug level to avoid noise\n      logger.debug('DB', 'sdk_session_id already set, skipping update', {\n        sessionId: id,\n        sdkSessionId\n      });\n      return false;\n    }\n\n    return true;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setWorkerPort_1210": {
      "name": "setWorkerPort",
      "type": "method",
      "start_line": 1210,
      "end_line": 1218,
      "content_hash": "8adb45e9d5b246e3c4bda1ec544560693b3d233a",
      "content": "  setWorkerPort(id: number, port: number): void {\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET worker_port = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(port, id);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getWorkerPort_1223": {
      "name": "getWorkerPort",
      "type": "method",
      "start_line": 1223,
      "end_line": 1233,
      "content_hash": "6c0a8dc9641c58e87f81c4a2b7290284e3ac217e",
      "content": "  getWorkerPort(id: number): number | null {\n    const stmt = this.db.prepare(`\n      SELECT worker_port\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    const result = stmt.get(id) as { worker_port: number | null } | undefined;\n    return result?.worker_port || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_saveUserPrompt_1238": {
      "name": "saveUserPrompt",
      "type": "method",
      "start_line": 1238,
      "end_line": 1250,
      "content_hash": "c5f2316b18aba4d73fcf0cf35fdf1d6b8a79c3b6",
      "content": "  saveUserPrompt(claudeSessionId: string, promptNumber: number, promptText: string): number {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      INSERT INTO user_prompts\n      (claude_session_id, prompt_number, prompt_text, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(claudeSessionId, promptNumber, promptText, now.toISOString(), nowEpoch);\n    return result.lastInsertRowid as number;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getUserPrompt_1256": {
      "name": "getUserPrompt",
      "type": "method",
      "start_line": 1256,
      "end_line": 1266,
      "content_hash": "7a6080f3b9eb074bac1fba6e79fd656dd764cdfa",
      "content": "  getUserPrompt(claudeSessionId: string, promptNumber: number): string | null {\n    const stmt = this.db.prepare(`\n      SELECT prompt_text\n      FROM user_prompts\n      WHERE claude_session_id = ? AND prompt_number = ?\n      LIMIT 1\n    `);\n\n    const result = stmt.get(claudeSessionId, promptNumber) as { prompt_text: string } | undefined;\n    return result?.prompt_text ?? null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_storeObservation_1272": {
      "name": "storeObservation",
      "type": "method",
      "start_line": 1272,
      "end_line": 1342,
      "content_hash": "68fbe4c7e1418eadff677f5b9a78108ca2e072b7",
      "content": "  storeObservation(\n    sdkSessionId: string,\n    project: string,\n    observation: {\n      type: string;\n      title: string | null;\n      subtitle: string | null;\n      facts: string[];\n      narrative: string | null;\n      concepts: string[];\n      files_read: string[];\n      files_modified: string[];\n    },\n    promptNumber?: number,\n    discoveryTokens: number = 0\n  ): { id: number; createdAtEpoch: number } {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // Ensure session record exists in the index (auto-create if missing)\n    const checkStmt = this.db.prepare(`\n      SELECT id FROM sdk_sessions WHERE sdk_session_id = ?\n    `);\n    const existingSession = checkStmt.get(sdkSessionId) as { id: number } | undefined;\n\n    if (!existingSession) {\n      // Auto-create session record if it doesn't exist\n      const insertSession = this.db.prepare(`\n        INSERT INTO sdk_sessions\n        (claude_session_id, sdk_session_id, project, started_at, started_at_epoch, status)\n        VALUES (?, ?, ?, ?, ?, 'active')\n      `);\n      insertSession.run(\n        sdkSessionId, // claude_session_id and sdk_session_id are the same\n        sdkSessionId,\n        project,\n        now.toISOString(),\n        nowEpoch\n      );\n      console.log(`[SessionStore] Auto-created session record for session_id: ${sdkSessionId}`);\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO observations\n      (sdk_session_id, project, type, title, subtitle, facts, narrative, concepts,\n       files_read, files_modified, prompt_number, discovery_tokens, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      sdkSessionId,\n      project,\n      observation.type,\n      observation.title,\n      observation.subtitle,\n      JSON.stringify(observation.facts),\n      observation.narrative,\n      JSON.stringify(observation.concepts),\n      JSON.stringify(observation.files_read),\n      JSON.stringify(observation.files_modified),\n      promptNumber || null,\n      discoveryTokens,\n      now.toISOString(),\n      nowEpoch\n    );\n\n    return {\n      id: Number(result.lastInsertRowid),\n      createdAtEpoch: nowEpoch\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_storeSummary_1348": {
      "name": "storeSummary",
      "type": "method",
      "start_line": 1348,
      "end_line": 1414,
      "content_hash": "84b8496eb14b7866b46fdb8cd60edd4f28247b5a",
      "content": "  storeSummary(\n    sdkSessionId: string,\n    project: string,\n    summary: {\n      request: string;\n      investigated: string;\n      learned: string;\n      completed: string;\n      next_steps: string;\n      notes: string | null;\n    },\n    promptNumber?: number,\n    discoveryTokens: number = 0\n  ): { id: number; createdAtEpoch: number } {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    // Ensure session record exists in the index (auto-create if missing)\n    const checkStmt = this.db.prepare(`\n      SELECT id FROM sdk_sessions WHERE sdk_session_id = ?\n    `);\n    const existingSession = checkStmt.get(sdkSessionId) as { id: number } | undefined;\n\n    if (!existingSession) {\n      // Auto-create session record if it doesn't exist\n      const insertSession = this.db.prepare(`\n        INSERT INTO sdk_sessions\n        (claude_session_id, sdk_session_id, project, started_at, started_at_epoch, status)\n        VALUES (?, ?, ?, ?, ?, 'active')\n      `);\n      insertSession.run(\n        sdkSessionId, // claude_session_id and sdk_session_id are the same\n        sdkSessionId,\n        project,\n        now.toISOString(),\n        nowEpoch\n      );\n      console.log(`[SessionStore] Auto-created session record for session_id: ${sdkSessionId}`);\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO session_summaries\n      (sdk_session_id, project, request, investigated, learned, completed,\n       next_steps, notes, prompt_number, discovery_tokens, created_at, created_at_epoch)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      sdkSessionId,\n      project,\n      summary.request,\n      summary.investigated,\n      summary.learned,\n      summary.completed,\n      summary.next_steps,\n      summary.notes,\n      promptNumber || null,\n      discoveryTokens,\n      now.toISOString(),\n      nowEpoch\n    );\n\n    return {\n      id: Number(result.lastInsertRowid),\n      createdAtEpoch: nowEpoch\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markSessionCompleted_1419": {
      "name": "markSessionCompleted",
      "type": "method",
      "start_line": 1419,
      "end_line": 1430,
      "content_hash": "07c519c9f7370d4e73e627b1a2d972e640e3d7c3",
      "content": "  markSessionCompleted(id: number): void {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'completed', completed_at = ?, completed_at_epoch = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(now.toISOString(), nowEpoch, id);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markSessionFailed_1435": {
      "name": "markSessionFailed",
      "type": "method",
      "start_line": 1435,
      "end_line": 1446,
      "content_hash": "ff4db39161cdf0b610a936a0a69f86b1ec17de8f",
      "content": "  markSessionFailed(id: number): void {\n    const now = new Date();\n    const nowEpoch = now.getTime();\n\n    const stmt = this.db.prepare(`\n      UPDATE sdk_sessions\n      SET status = 'failed', completed_at = ?, completed_at_epoch = ?\n      WHERE id = ?\n    `);\n\n    stmt.run(now.toISOString(), nowEpoch, id);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionSummariesByIds_1457": {
      "name": "getSessionSummariesByIds",
      "type": "method",
      "start_line": 1457,
      "end_line": 1483,
      "content_hash": "01266c8caa6a2e9c6526af52fe8d1b5894df573c",
      "content": "  getSessionSummariesByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string } = {}\n  ): SessionSummaryRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n\n    // Apply project filter\n    const whereClause = project\n      ? `WHERE id IN (${placeholders}) AND project = ?`\n      : `WHERE id IN (${placeholders})`;\n    if (project) params.push(project);\n\n    const stmt = this.db.prepare(`\n      SELECT * FROM session_summaries\n      ${whereClause}\n      ORDER BY created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as SessionSummaryRecord[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getUserPromptsByIds_1489": {
      "name": "getUserPromptsByIds",
      "type": "method",
      "start_line": 1489,
      "end_line": 1518,
      "content_hash": "2a5fa30c4b8d3d7955e2b8ab62a7593068e5423e",
      "content": "  getUserPromptsByIds(\n    ids: number[],\n    options: { orderBy?: 'date_desc' | 'date_asc'; limit?: number; project?: string } = {}\n  ): UserPromptRecord[] {\n    if (ids.length === 0) return [];\n\n    const { orderBy = 'date_desc', limit, project } = options;\n    const orderClause = orderBy === 'date_asc' ? 'ASC' : 'DESC';\n    const limitClause = limit ? `LIMIT ${limit}` : '';\n    const placeholders = ids.map(() => '?').join(',');\n    const params: any[] = [...ids];\n\n    // Apply project filter\n    const projectFilter = project ? 'AND s.project = ?' : '';\n    if (project) params.push(project);\n\n    const stmt = this.db.prepare(`\n      SELECT\n        up.*,\n        s.project,\n        s.sdk_session_id\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.id IN (${placeholders}) ${projectFilter}\n      ORDER BY up.created_at_epoch ${orderClause}\n      ${limitClause}\n    `);\n\n    return stmt.all(...params) as UserPromptRecord[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTimelineAroundTimestamp_1528": {
      "name": "getTimelineAroundTimestamp",
      "type": "method",
      "start_line": 1528,
      "end_line": 1539,
      "content_hash": "5bac308cf2613181050912e788873848861c10c7",
      "content": "  getTimelineAroundTimestamp(\n    anchorEpoch: number,\n    depthBefore: number = 10,\n    depthAfter: number = 10,\n    project?: string\n  ): {\n    observations: any[];\n    sessions: any[];\n    prompts: any[];\n  } {\n    return this.getTimelineAroundObservation(null, anchorEpoch, depthBefore, depthAfter, project);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTimelineAroundObservation_1545": {
      "name": "getTimelineAroundObservation",
      "type": "method",
      "start_line": 1545,
      "end_line": 1682,
      "content_hash": "e54b45d788f0b164b22af7e3fd9329e98483dc92",
      "content": "  getTimelineAroundObservation(\n    anchorObservationId: number | null,\n    anchorEpoch: number,\n    depthBefore: number = 10,\n    depthAfter: number = 10,\n    project?: string\n  ): {\n    observations: any[];\n    sessions: any[];\n    prompts: any[];\n  } {\n    const projectFilter = project ? 'AND project = ?' : '';\n    const projectParams = project ? [project] : [];\n\n    let startEpoch: number;\n    let endEpoch: number;\n\n    if (anchorObservationId !== null) {\n      // Get boundary observations by ID offset\n      const beforeQuery = `\n        SELECT id, created_at_epoch\n        FROM observations\n        WHERE id <= ? ${projectFilter}\n        ORDER BY id DESC\n        LIMIT ?\n      `;\n      const afterQuery = `\n        SELECT id, created_at_epoch\n        FROM observations\n        WHERE id >= ? ${projectFilter}\n        ORDER BY id ASC\n        LIMIT ?\n      `;\n\n      try {\n        const beforeRecords = this.db.prepare(beforeQuery).all(anchorObservationId, ...projectParams, depthBefore + 1) as Array<{id: number; created_at_epoch: number}>;\n        const afterRecords = this.db.prepare(afterQuery).all(anchorObservationId, ...projectParams, depthAfter + 1) as Array<{id: number; created_at_epoch: number}>;\n\n        // Get the earliest and latest timestamps from boundary observations\n        if (beforeRecords.length === 0 && afterRecords.length === 0) {\n          return { observations: [], sessions: [], prompts: [] };\n        }\n\n        startEpoch = beforeRecords.length > 0 ? beforeRecords[beforeRecords.length - 1].created_at_epoch : anchorEpoch;\n        endEpoch = afterRecords.length > 0 ? afterRecords[afterRecords.length - 1].created_at_epoch : anchorEpoch;\n      } catch (err: any) {\n        console.error('[SessionStore] Error getting boundary observations:', err.message, project ? `(project: ${project})` : '(all projects)');\n        return { observations: [], sessions: [], prompts: [] };\n      }\n    } else {\n      // For timestamp-based anchors, use time-based boundaries\n      // Get observations to find the time window\n      const beforeQuery = `\n        SELECT created_at_epoch\n        FROM observations\n        WHERE created_at_epoch <= ? ${projectFilter}\n        ORDER BY created_at_epoch DESC\n        LIMIT ?\n      `;\n      const afterQuery = `\n        SELECT created_at_epoch\n        FROM observations\n        WHERE created_at_epoch >= ? ${projectFilter}\n        ORDER BY created_at_epoch ASC\n        LIMIT ?\n      `;\n\n      try {\n        const beforeRecords = this.db.prepare(beforeQuery).all(anchorEpoch, ...projectParams, depthBefore) as Array<{created_at_epoch: number}>;\n        const afterRecords = this.db.prepare(afterQuery).all(anchorEpoch, ...projectParams, depthAfter + 1) as Array<{created_at_epoch: number}>;\n\n        if (beforeRecords.length === 0 && afterRecords.length === 0) {\n          return { observations: [], sessions: [], prompts: [] };\n        }\n\n        startEpoch = beforeRecords.length > 0 ? beforeRecords[beforeRecords.length - 1].created_at_epoch : anchorEpoch;\n        endEpoch = afterRecords.length > 0 ? afterRecords[afterRecords.length - 1].created_at_epoch : anchorEpoch;\n      } catch (err: any) {\n        console.error('[SessionStore] Error getting boundary timestamps:', err.message, project ? `(project: ${project})` : '(all projects)');\n        return { observations: [], sessions: [], prompts: [] };\n      }\n    }\n\n    // Now query ALL record types within the time window\n    const obsQuery = `\n      SELECT *\n      FROM observations\n      WHERE created_at_epoch >= ? AND created_at_epoch <= ? ${projectFilter}\n      ORDER BY created_at_epoch ASC\n    `;\n\n    const sessQuery = `\n      SELECT *\n      FROM session_summaries\n      WHERE created_at_epoch >= ? AND created_at_epoch <= ? ${projectFilter}\n      ORDER BY created_at_epoch ASC\n    `;\n\n    const promptQuery = `\n      SELECT up.*, s.project, s.sdk_session_id\n      FROM user_prompts up\n      JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n      WHERE up.created_at_epoch >= ? AND up.created_at_epoch <= ? ${projectFilter.replace('project', 's.project')}\n      ORDER BY up.created_at_epoch ASC\n    `;\n\n    try {\n      const observations = this.db.prepare(obsQuery).all(startEpoch, endEpoch, ...projectParams) as ObservationRecord[];\n      const sessions = this.db.prepare(sessQuery).all(startEpoch, endEpoch, ...projectParams) as SessionSummaryRecord[];\n      const prompts = this.db.prepare(promptQuery).all(startEpoch, endEpoch, ...projectParams) as UserPromptRecord[];\n\n      return {\n        observations,\n        sessions: sessions.map(s => ({\n          id: s.id,\n          sdk_session_id: s.sdk_session_id,\n          project: s.project,\n          request: s.request,\n          completed: s.completed,\n          next_steps: s.next_steps,\n          created_at: s.created_at,\n          created_at_epoch: s.created_at_epoch\n        })),\n        prompts: prompts.map(p => ({\n          id: p.id,\n          claude_session_id: p.claude_session_id,\n          prompt_number: p.prompt_number,\n          prompt_text: p.prompt_text,\n          project: p.project,\n          created_at: p.created_at,\n          created_at_epoch: p.created_at_epoch\n        }))\n      };\n    } catch (err: any) {\n      console.error('[SessionStore] Error querying timeline records:', err.message, project ? `(project: ${project})` : '(all projects)');\n      return { observations: [], sessions: [], prompts: [] };\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPromptById_1687": {
      "name": "getPromptById",
      "type": "method",
      "start_line": 1687,
      "end_line": 1712,
      "content_hash": "a78ef161f3911ca60d6fab5f4f19edd4c27a1dea",
      "content": "  getPromptById(id: number): {\n    id: number;\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    project: string;\n    created_at: string;\n    created_at_epoch: number;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        p.id,\n        p.claude_session_id,\n        p.prompt_number,\n        p.prompt_text,\n        s.project,\n        p.created_at,\n        p.created_at_epoch\n      FROM user_prompts p\n      LEFT JOIN sdk_sessions s ON p.claude_session_id = s.claude_session_id\n      WHERE p.id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPromptsByIds_1717": {
      "name": "getPromptsByIds",
      "type": "method",
      "start_line": 1717,
      "end_line": 1753,
      "content_hash": "8c268738885074e13d0665f19049d03091741b46",
      "content": "  getPromptsByIds(ids: number[]): Array<{\n    id: number;\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    project: string;\n    created_at: string;\n    created_at_epoch: number;\n  }> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const stmt = this.db.prepare(`\n      SELECT\n        p.id,\n        p.claude_session_id,\n        p.prompt_number,\n        p.prompt_text,\n        s.project,\n        p.created_at,\n        p.created_at_epoch\n      FROM user_prompts p\n      LEFT JOIN sdk_sessions s ON p.claude_session_id = s.claude_session_id\n      WHERE p.id IN (${placeholders})\n      ORDER BY p.created_at_epoch DESC\n    `);\n\n    return stmt.all(...ids) as Array<{\n      id: number;\n      claude_session_id: string;\n      prompt_number: number;\n      prompt_text: string;\n      project: string;\n      created_at: string;\n      created_at_epoch: number;\n    }>;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionSummaryById_1758": {
      "name": "getSessionSummaryById",
      "type": "method",
      "start_line": 1758,
      "end_line": 1788,
      "content_hash": "be877d881fdb20c0ce25aa25951400843b448c71",
      "content": "  getSessionSummaryById(id: number): {\n    id: number;\n    sdk_session_id: string | null;\n    claude_session_id: string;\n    project: string;\n    user_prompt: string;\n    request_summary: string | null;\n    learned_summary: string | null;\n    status: string;\n    created_at: string;\n    created_at_epoch: number;\n  } | null {\n    const stmt = this.db.prepare(`\n      SELECT\n        id,\n        sdk_session_id,\n        claude_session_id,\n        project,\n        user_prompt,\n        request_summary,\n        learned_summary,\n        status,\n        created_at,\n        created_at_epoch\n      FROM sdk_sessions\n      WHERE id = ?\n      LIMIT 1\n    `);\n\n    return stmt.get(id) || null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_close_1793": {
      "name": "close",
      "type": "method",
      "start_line": 1793,
      "end_line": 1795,
      "content_hash": "dc791efba3a659c6cd0f129154be1ecbbae87054",
      "content": "  close(): void {\n    this.db.close();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_importSdkSession_1805": {
      "name": "importSdkSession",
      "type": "method",
      "start_line": 1805,
      "end_line": 1845,
      "content_hash": "d208de0dc33926c56e3c390ca131619a41a9d436",
      "content": "  importSdkSession(session: {\n    claude_session_id: string;\n    sdk_session_id: string;\n    project: string;\n    user_prompt: string;\n    started_at: string;\n    started_at_epoch: number;\n    completed_at: string | null;\n    completed_at_epoch: number | null;\n    status: string;\n  }): { imported: boolean; id: number } {\n    // Check if session already exists\n    const existing = this.db.prepare(\n      'SELECT id FROM sdk_sessions WHERE claude_session_id = ?'\n    ).get(session.claude_session_id) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO sdk_sessions (\n        claude_session_id, sdk_session_id, project, user_prompt,\n        started_at, started_at_epoch, completed_at, completed_at_epoch, status\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      session.claude_session_id,\n      session.sdk_session_id,\n      session.project,\n      session.user_prompt,\n      session.started_at,\n      session.started_at_epoch,\n      session.completed_at,\n      session.completed_at_epoch,\n      session.status\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_importSessionSummary_1851": {
      "name": "importSessionSummary",
      "type": "method",
      "start_line": 1851,
      "end_line": 1902,
      "content_hash": "3b0d9bd715a0df10b6a090d3e672be9ec9a1f59b",
      "content": "  importSessionSummary(summary: {\n    sdk_session_id: string;\n    project: string;\n    request: string | null;\n    investigated: string | null;\n    learned: string | null;\n    completed: string | null;\n    next_steps: string | null;\n    files_read: string | null;\n    files_edited: string | null;\n    notes: string | null;\n    prompt_number: number | null;\n    discovery_tokens: number;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if summary already exists for this session\n    const existing = this.db.prepare(\n      'SELECT id FROM session_summaries WHERE sdk_session_id = ?'\n    ).get(summary.sdk_session_id) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO session_summaries (\n        sdk_session_id, project, request, investigated, learned,\n        completed, next_steps, files_read, files_edited, notes,\n        prompt_number, discovery_tokens, created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      summary.sdk_session_id,\n      summary.project,\n      summary.request,\n      summary.investigated,\n      summary.learned,\n      summary.completed,\n      summary.next_steps,\n      summary.files_read,\n      summary.files_edited,\n      summary.notes,\n      summary.prompt_number,\n      summary.discovery_tokens || 0,\n      summary.created_at,\n      summary.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_importObservation_1909": {
      "name": "importObservation",
      "type": "method",
      "start_line": 1909,
      "end_line": 1963,
      "content_hash": "6eda2efa0e51bf0f0ae91b30860ab1b86a053304",
      "content": "  importObservation(obs: {\n    sdk_session_id: string;\n    project: string;\n    text: string | null;\n    type: string;\n    title: string | null;\n    subtitle: string | null;\n    facts: string | null;\n    narrative: string | null;\n    concepts: string | null;\n    files_read: string | null;\n    files_modified: string | null;\n    prompt_number: number | null;\n    discovery_tokens: number;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if observation already exists\n    const existing = this.db.prepare(`\n      SELECT id FROM observations\n      WHERE sdk_session_id = ? AND title = ? AND created_at_epoch = ?\n    `).get(obs.sdk_session_id, obs.title, obs.created_at_epoch) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO observations (\n        sdk_session_id, project, text, type, title, subtitle,\n        facts, narrative, concepts, files_read, files_modified,\n        prompt_number, discovery_tokens, created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      obs.sdk_session_id,\n      obs.project,\n      obs.text,\n      obs.type,\n      obs.title,\n      obs.subtitle,\n      obs.facts,\n      obs.narrative,\n      obs.concepts,\n      obs.files_read,\n      obs.files_modified,\n      obs.prompt_number,\n      obs.discovery_tokens || 0,\n      obs.created_at,\n      obs.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_importUserPrompt_1970": {
      "name": "importUserPrompt",
      "type": "method",
      "start_line": 1970,
      "end_line": 2003,
      "content_hash": "1d14d7f0b78dfdac0673101c01654fa81c860cc8",
      "content": "  importUserPrompt(prompt: {\n    claude_session_id: string;\n    prompt_number: number;\n    prompt_text: string;\n    created_at: string;\n    created_at_epoch: number;\n  }): { imported: boolean; id: number } {\n    // Check if prompt already exists\n    const existing = this.db.prepare(`\n      SELECT id FROM user_prompts\n      WHERE claude_session_id = ? AND prompt_number = ?\n    `).get(prompt.claude_session_id, prompt.prompt_number) as { id: number } | undefined;\n\n    if (existing) {\n      return { imported: false, id: existing.id };\n    }\n\n    const stmt = this.db.prepare(`\n      INSERT INTO user_prompts (\n        claude_session_id, prompt_number, prompt_text,\n        created_at, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      prompt.claude_session_id,\n      prompt.prompt_number,\n      prompt.prompt_text,\n      prompt.created_at,\n      prompt.created_at_epoch\n    );\n\n    return { imported: true, id: result.lastInsertRowid as number };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}