{
  "file_path": "/work/internal/cmd/logs.go",
  "file_hash": "39fbe76fd5e59d004f948387553df6d531f26d78",
  "updated_at": "2025-12-26T17:34:20.079509",
  "symbols": {
    "function_init_73": {
      "name": "init",
      "type": "function",
      "start_line": 73,
      "end_line": 77,
      "content_hash": "83c7b788c230c60c4f36cae518fe8329ffa82428",
      "content": "func init() {\n\tlogsCmd.Flags().BoolP(\"follow\", \"f\", false, \"Follow log output\")\n\tlogsCmd.Flags().IntP(\"tail\", \"t\", defaultTailLines, \"Show only the last N lines default: 1000 for performance\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_followLogs_78": {
      "name": "followLogs",
      "type": "function",
      "start_line": 78,
      "end_line": 132,
      "content_hash": "e2948c2fbd16956b581c18db1a099108b642b266",
      "content": "func followLogs(ctx context.Context, logsFile string, tailLines int) error {\n\tt, err := tail.TailFile(logsFile, tail.Config{\n\t\tFollow: false,\n\t\tReOpen: false,\n\t\tLogger: tail.DiscardingLogger,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to tail log file: %v\", err)\n\t}\n\n\tvar lines []string\n\tfor line := range t.Lines {\n\t\tif line.Err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tlines = append(lines, line.Text)\n\t\tif len(lines) > tailLines {\n\t\t\tlines = lines[len(lines)-tailLines:]\n\t\t}\n\t}\n\tt.Stop()\n\n\tfor _, line := range lines {\n\t\tprintLogLine(line)\n\t}\n\n\tif len(lines) == tailLines {\n\t\tfmt.Fprintf(os.Stderr, \"\\nShowing last %d lines. Full logs available at: %s\\n\", tailLines, logsFile)\n\t\tfmt.Fprintf(os.Stderr, \"Following new log entries...\\n\\n\")\n\t}\n\n\tt, err = tail.TailFile(logsFile, tail.Config{\n\t\tFollow:   true,\n\t\tReOpen:   true,\n\t\tLogger:   tail.DiscardingLogger,\n\t\tLocation: &tail.SeekInfo{Offset: 0, Whence: io.SeekEnd},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to tail log file: %v\", err)\n\t}\n\tdefer t.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase line := <-t.Lines:\n\t\t\tif line.Err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprintLogLine(line.Text)\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_showLogs_133": {
      "name": "showLogs",
      "type": "function",
      "start_line": 133,
      "end_line": 166,
      "content_hash": "82fb8fa216971ba1f0e52ea5bf4fe9af115797cf",
      "content": "func showLogs(logsFile string, tailLines int) error {\n\tt, err := tail.TailFile(logsFile, tail.Config{\n\t\tFollow:      false,\n\t\tReOpen:      false,\n\t\tLogger:      tail.DiscardingLogger,\n\t\tMaxLineSize: 0,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to tail log file: %v\", err)\n\t}\n\tdefer t.Stop()\n\n\tvar lines []string\n\tfor line := range t.Lines {\n\t\tif line.Err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tlines = append(lines, line.Text)\n\t\tif len(lines) > tailLines {\n\t\t\tlines = lines[len(lines)-tailLines:]\n\t\t}\n\t}\n\n\tfor _, line := range lines {\n\t\tprintLogLine(line)\n\t}\n\n\tif len(lines) == tailLines {\n\t\tfmt.Fprintf(os.Stderr, \"\\nShowing last %d lines. Full logs available at: %s\\n\", tailLines, logsFile)\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_printLogLine_167": {
      "name": "printLogLine",
      "type": "function",
      "start_line": 167,
      "end_line": 216,
      "content_hash": "d4cb9e3b5cb71aeeddd4f0cc46e140d08908a6b2",
      "content": "func printLogLine(lineText string) {\n\tvar data map[string]any\n\tif err := json.Unmarshal([]byte(lineText), &data); err != nil {\n\t\treturn\n\t}\n\tmsg := data[\"msg\"]\n\tlevel := data[\"level\"]\n\totherData := []any{}\n\tkeys := []string{}\n\tfor k := range data {\n\t\tkeys = append(keys, k)\n\t}\n\tslices.Sort(keys)\n\tfor _, k := range keys {\n\t\tswitch k {\n\t\tcase \"msg\", \"level\", \"time\":\n\t\t\tcontinue\n\t\tcase \"source\":\n\t\t\tsource, ok := data[k].(map[string]any)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsourceFile := fmt.Sprintf(\"%s:%d\", source[\"file\"], int(source[\"line\"].(float64)))\n\t\t\totherData = append(otherData, \"source\", sourceFile)\n\n\t\tdefault:\n\t\t\totherData = append(otherData, k, data[k])\n\t\t}\n\t}\n\tlog.SetTimeFunction(func(_ time.Time) time.Time {\n\t\t// parse the timestamp from the log line if available\n\t\tt, err := time.Parse(time.RFC3339, data[\"time\"].(string))\n\t\tif err != nil {\n\t\t\treturn time.Now() // fallback to current time if parsing fails\n\t\t}\n\t\treturn t\n\t})\n\tswitch level {\n\tcase \"INFO\":\n\t\tlog.Info(msg, otherData...)\n\tcase \"DEBUG\":\n\t\tlog.Debug(msg, otherData...)\n\tcase \"ERROR\":\n\t\tlog.Error(msg, otherData...)\n\tcase \"WARN\":\n\t\tlog.Warn(msg, otherData...)\n\tdefault:\n\t\tlog.Info(msg, otherData...)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}