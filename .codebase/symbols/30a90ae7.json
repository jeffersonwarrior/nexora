{
  "file_path": "/work/internal/agent/tools/glob_test.go",
  "file_hash": "9feb5f682773f1ff1828812c431a5231e287d8eb",
  "updated_at": "2025-12-26T17:34:22.573165",
  "symbols": {
    "function_TestGlobFiles_10": {
      "name": "TestGlobFiles",
      "type": "function",
      "start_line": 10,
      "end_line": 151,
      "content_hash": "9ce11757aedd2b51d58ab67b21785c4246ffdefc",
      "content": "func TestGlobFiles(t *testing.T) {\n\tctx := context.Background()\n\n\ttmpDir := t.TempDir()\n\n\t// Create test directory structure\n\ttestFiles := []string{\n\t\t\"file1.go\",\n\t\t\"file2.go\",\n\t\t\"test.txt\",\n\t\t\"subdir/nested.go\",\n\t\t\"subdir/data.json\",\n\t\t\"another/deep/path/file.go\",\n\t}\n\n\tfor _, f := range testFiles {\n\t\tfullPath := filepath.Join(tmpDir, f)\n\t\tdir := filepath.Dir(fullPath)\n\t\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\t\tt.Fatalf(\"Failed to create directory %s: %v\", dir, err)\n\t\t}\n\t\tif err := os.WriteFile(fullPath, []byte(\"test content\"), 0644); err != nil {\n\t\t\tt.Fatalf(\"Failed to create file %s: %v\", fullPath, err)\n\t\t}\n\t}\n\n\tt.Run(\"basic pattern matching\", func(t *testing.T) {\n\t\tfiles, truncated, err := globFiles(ctx, \"*.go\", tmpDir, 100)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\tif len(files) != 2 {\n\t\t\tt.Errorf(\"Expected 2 .go files in root, got %d\", len(files))\n\t\t}\n\n\t\tif truncated {\n\t\t\tt.Error(\"Expected truncated to be false\")\n\t\t}\n\n\t\t// Verify filenames\n\t\tfound := make(map[string]bool)\n\t\tfor _, f := range files {\n\t\t\tbase := filepath.Base(f)\n\t\t\tfound[base] = true\n\t\t}\n\n\t\tif !found[\"file1.go\"] || !found[\"file2.go\"] {\n\t\t\tt.Error(\"Expected to find file1.go and file2.go\")\n\t\t}\n\t})\n\n\tt.Run(\"recursive pattern\", func(t *testing.T) {\n\t\tfiles, truncated, err := globFiles(ctx, \"**/*.go\", tmpDir, 100)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\t// Should find all .go files including nested ones\n\t\tif len(files) < 4 {\n\t\t\tt.Errorf(\"Expected at least 4 .go files recursively, got %d\", len(files))\n\t\t}\n\n\t\tif truncated {\n\t\t\tt.Error(\"Expected truncated to be false\")\n\t\t}\n\t})\n\n\tt.Run(\"respects limit\", func(t *testing.T) {\n\t\t// Create many test files\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tfilename := filepath.Join(tmpDir, \"many_\"+string(rune('a'+i))+\".txt\")\n\t\t\tif err := os.WriteFile(filename, []byte(\"test\"), 0644); err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tfiles, truncated, err := globFiles(ctx, \"*.txt\", tmpDir, 10)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\tif len(files) > 10 {\n\t\t\tt.Errorf(\"Expected at most 10 files, got %d\", len(files))\n\t\t}\n\n\t\tif !truncated {\n\t\t\tt.Error(\"Expected truncated to be true when limit is exceeded\")\n\t\t}\n\t})\n\n\tt.Run(\"no matches\", func(t *testing.T) {\n\t\tfiles, truncated, err := globFiles(ctx, \"*.nonexistent\", tmpDir, 100)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\tif len(files) != 0 {\n\t\t\tt.Errorf(\"Expected no files, got %d\", len(files))\n\t\t}\n\n\t\tif truncated {\n\t\t\tt.Error(\"Expected truncated to be false with no matches\")\n\t\t}\n\t})\n\n\tt.Run(\"multiple extensions\", func(t *testing.T) {\n\t\tfiles, truncated, err := globFiles(ctx, \"**/*.{go,json}\", tmpDir, 100)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\t// Should find both .go and .json files\n\t\tfoundGo := false\n\t\tfoundJson := false\n\t\tfor _, f := range files {\n\t\t\tif filepath.Ext(f) == \".go\" {\n\t\t\t\tfoundGo = true\n\t\t\t}\n\t\t\tif filepath.Ext(f) == \".json\" {\n\t\t\t\tfoundJson = true\n\t\t\t}\n\t\t}\n\n\t\tif !foundGo {\n\t\t\tt.Error(\"Expected to find .go files\")\n\t\t}\n\t\tif !foundJson {\n\t\t\tt.Error(\"Expected to find .json files\")\n\t\t}\n\n\t\tif truncated {\n\t\t\tt.Error(\"Expected truncated to be false\")\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNormalizeFilePaths_152": {
      "name": "TestNormalizeFilePaths",
      "type": "function",
      "start_line": 152,
      "end_line": 188,
      "content_hash": "4e2eb3f4745bf85c6144e0e0f9cf848cd35fbfdb",
      "content": "func TestNormalizeFilePaths(t *testing.T) {\n\t// Test that normalizeFilePaths uses filepath.ToSlash\n\ttests := []struct {\n\t\tname  string\n\t\tinput []string\n\t}{\n\t\t{\n\t\t\tname:  \"unix paths\",\n\t\t\tinput: []string{\"/home/user/file.go\", \"path/to/file.txt\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: []string{},\n\t\t},\n\t\t{\n\t\t\tname:  \"single path\",\n\t\t\tinput: []string{\"test/file.go\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tpaths := make([]string, len(tt.input))\n\t\t\tcopy(paths, tt.input)\n\n\t\t\tnormalizeFilePaths(paths)\n\n\t\t\t// Verify all paths use forward slashes (filepath.ToSlash behavior)\n\t\t\tfor i, p := range paths {\n\t\t\t\tnormalized := filepath.ToSlash(tt.input[i])\n\t\t\t\tif p != normalized {\n\t\t\t\t\tt.Errorf(\"Path %d not normalized: expected %s, got %s\", i, normalized, p)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}