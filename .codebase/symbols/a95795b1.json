{
  "file_path": "/work/internal/lsp/handlers.go",
  "file_hash": "9a8a5914ccd5d5ec9bcd85841d66ec6adc431720",
  "updated_at": "2025-12-26T17:34:20.154247",
  "symbols": {
    "function_HandleWorkspaceConfiguration_14": {
      "name": "HandleWorkspaceConfiguration",
      "type": "function",
      "start_line": 14,
      "end_line": 18,
      "content_hash": "dd96be0fd2a1afcb08979125a379f6ce9a7a4b1a",
      "content": "func HandleWorkspaceConfiguration(_ context.Context, _ string, params json.RawMessage) (any, error) {\n\treturn []map[string]any{{}}, nil\n}\n\n// HandleRegisterCapability handles capability registration requests",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HandleRegisterCapability_19": {
      "name": "HandleRegisterCapability",
      "type": "function",
      "start_line": 19,
      "end_line": 47,
      "content_hash": "521ccd408d4650a63e29da3552dc7979acbe0f71",
      "content": "func HandleRegisterCapability(_ context.Context, _ string, params json.RawMessage) (any, error) {\n\tvar registerParams protocol.RegistrationParams\n\tif err := json.Unmarshal(params, &registerParams); err != nil {\n\t\tslog.Error(\"Error unmarshaling registration params\", \"error\", err)\n\t\treturn nil, err\n\t}\n\n\tfor _, reg := range registerParams.Registrations {\n\t\tswitch reg.Method {\n\t\tcase \"workspace/didChangeWatchedFiles\":\n\t\t\t// Parse the registration options\n\t\t\toptionsJSON, err := json.Marshal(reg.RegisterOptions)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"Error marshaling registration options\", \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar options protocol.DidChangeWatchedFilesRegistrationOptions\n\t\t\tif err := json.Unmarshal(optionsJSON, &options); err != nil {\n\t\t\t\tslog.Error(\"Error unmarshaling registration options\", \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Store the file watchers registrations\n\t\t\tnotifyFileWatchRegistration(reg.ID, options.Watchers)\n\t\t}\n\t}\n\treturn nil, nil\n}\n\n// HandleApplyEdit handles workspace edit requests",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HandleApplyEdit_48": {
      "name": "HandleApplyEdit",
      "type": "function",
      "start_line": 48,
      "end_line": 69,
      "content_hash": "1dc13cc4c325c4353c32e8e7b5fd2dd32ee3399f",
      "content": "func HandleApplyEdit(_ context.Context, _ string, params json.RawMessage) (any, error) {\n\tvar edit protocol.ApplyWorkspaceEditParams\n\tif err := json.Unmarshal(params, &edit); err != nil {\n\t\treturn nil, err\n\t}\n\n\terr := util.ApplyWorkspaceEdit(edit.Edit)\n\tif err != nil {\n\t\tslog.Error(\"Error applying workspace edit\", \"error\", err)\n\t\treturn protocol.ApplyWorkspaceEditResult{Applied: false, FailureReason: err.Error()}, nil\n\t}\n\n\treturn protocol.ApplyWorkspaceEditResult{Applied: true}, nil\n}\n\n// FileWatchRegistrationHandler is a function that will be called when file watch registrations are received\ntype FileWatchRegistrationHandler func(id string, watchers []protocol.FileSystemWatcher)\n\n// fileWatchHandler holds the current handler for file watch registrations\nvar fileWatchHandler FileWatchRegistrationHandler\n\n// RegisterFileWatchHandler sets the handler for file watch registrations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_RegisterFileWatchHandler_70": {
      "name": "RegisterFileWatchHandler",
      "type": "function",
      "start_line": 70,
      "end_line": 74,
      "content_hash": "c6e9043b8ec6758fddbab8b715ec685b942a9958",
      "content": "func RegisterFileWatchHandler(handler FileWatchRegistrationHandler) {\n\tfileWatchHandler = handler\n}\n\n// notifyFileWatchRegistration notifies the handler about new file watch registrations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_notifyFileWatchRegistration_75": {
      "name": "notifyFileWatchRegistration",
      "type": "function",
      "start_line": 75,
      "end_line": 81,
      "content_hash": "a45af7b04493e6d834c2fe48bb0ae52799cd8856",
      "content": "func notifyFileWatchRegistration(id string, watchers []protocol.FileSystemWatcher) {\n\tif fileWatchHandler != nil {\n\t\tfileWatchHandler(id, watchers)\n\t}\n}\n\n// HandleServerMessage handles server messages",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HandleServerMessage_82": {
      "name": "HandleServerMessage",
      "type": "function",
      "start_line": 82,
      "end_line": 106,
      "content_hash": "3540e198104d2066e0c327a625efc1b50481147a",
      "content": "func HandleServerMessage(_ context.Context, method string, params json.RawMessage) {\n\tcfg := config.Get()\n\tif !cfg.Options.DebugLSP {\n\t\treturn\n\t}\n\n\tvar msg protocol.ShowMessageParams\n\tif err := json.Unmarshal(params, &msg); err != nil {\n\t\tslog.Debug(\"Server message\", \"type\", msg.Type, \"message\", msg.Message)\n\t\treturn\n\t}\n\n\tswitch msg.Type {\n\tcase protocol.Error:\n\t\tslog.Error(\"LSP Server\", \"message\", msg.Message)\n\tcase protocol.Warning:\n\t\tslog.Warn(\"LSP Server\", \"message\", msg.Message)\n\tcase protocol.Info:\n\t\tslog.Info(\"LSP Server\", \"message\", msg.Message)\n\tcase protocol.Log:\n\t\tslog.Debug(\"LSP Server\", \"message\", msg.Message)\n\t}\n}\n\n// HandleDiagnostics handles diagnostic notifications from the LSP server",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HandleDiagnostics_107": {
      "name": "HandleDiagnostics",
      "type": "function",
      "start_line": 107,
      "end_line": 152,
      "content_hash": "07e73e0ff73fe172d09df51fd62f570d9a615178",
      "content": "func HandleDiagnostics(client *Client, params json.RawMessage) {\n\tvar diagParams protocol.PublishDiagnosticsParams\n\n\t// Try multiple parsing strategies\n\terr := json.Unmarshal(params, &diagParams)\n\tif err != nil {\n\t\tslog.Info(\"Initial unmarshal failed, trying alternative approaches\",\n\t\t\t\"error\", err, \"raw_length\", len(params))\n\n\t\t// Try parsing as a generic map and then converting\n\t\tvar genericParams map[string]interface{}\n\t\tif mapErr := json.Unmarshal(params, &genericParams); mapErr == nil {\n\t\t\tslog.Debug(\"Successfully parsed as generic map\")\n\n\t\t\t// Try to convert to the expected struct\n\t\t\tconvertedData, marshalErr := json.Marshal(genericParams)\n\t\t\tif marshalErr == nil {\n\t\t\t\tif convertErr := json.Unmarshal(convertedData, &diagParams); convertErr == nil {\n\t\t\t\t\tslog.Debug(\"Successfully converted generic map to diagnostics params\")\n\t\t\t\t\terr = nil // Clear the error since we succeeded\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If still failed, log detailed error info and return\n\t\tif err != nil {\n\t\t\tslog.Error(\"All parsing approaches failed for diagnostics params\",\n\t\t\t\t\"original_error\", err, \"raw_params\", string(params))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Set diagnostics if we successfully parsed\n\tclient.diagnostics.Set(diagParams.URI, diagParams.Diagnostics)\n\n\t// Calculate total diagnostic count\n\ttotalCount := 0\n\tfor _, diagnostics := range client.diagnostics.Seq2() {\n\t\ttotalCount += len(diagnostics)\n\t}\n\n\t// Trigger callback if set\n\tif client.onDiagnosticsChanged != nil {\n\t\tclient.onDiagnosticsChanged(client.name, totalCount)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}