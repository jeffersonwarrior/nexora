{
  "file_path": "/work/internal/pubsub/broker_test.go",
  "file_hash": "85c01acae7597078ea44a2ae717021cb92bbaa0a",
  "updated_at": "2025-12-26T17:34:20.751895",
  "symbols": {
    "function_TestNewBroker_11": {
      "name": "TestNewBroker",
      "type": "function",
      "start_line": 11,
      "end_line": 35,
      "content_hash": "6d54485545e7833bb921e0de263b3292c7d913d3",
      "content": "func TestNewBroker(t *testing.T) {\n\tbroker := NewBroker[string]()\n\n\tif broker == nil {\n\t\tt.Fatal(\"NewBroker returned nil\")\n\t}\n\n\tif broker.subs == nil {\n\t\tt.Error(\"subs map not initialized\")\n\t}\n\n\tif broker.done == nil {\n\t\tt.Error(\"done channel not initialized\")\n\t}\n\n\tif broker.subCount != 0 {\n\t\tt.Errorf(\"expected subCount 0, got %d\", broker.subCount)\n\t}\n\n\tif broker.maxEvents != 1000 {\n\t\tt.Errorf(\"expected maxEvents 1000, got %d\", broker.maxEvents)\n\t}\n}\n\n// TestNewBrokerWithOptions verifies custom initialization",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewBrokerWithOptions_36": {
      "name": "TestNewBrokerWithOptions",
      "type": "function",
      "start_line": 36,
      "end_line": 51,
      "content_hash": "0887bddbdc02ef9171b8fa2eed431ddfb1b26783",
      "content": "func TestNewBrokerWithOptions(t *testing.T) {\n\tbufferSize := 128\n\tmaxEvents := 5000\n\n\tbroker := NewBrokerWithOptions[int](bufferSize, maxEvents)\n\n\tif broker == nil {\n\t\tt.Fatal(\"NewBrokerWithOptions returned nil\")\n\t}\n\n\tif broker.maxEvents != maxEvents {\n\t\tt.Errorf(\"expected maxEvents %d, got %d\", maxEvents, broker.maxEvents)\n\t}\n}\n\n// TestBrokerSubscribe verifies subscription functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerSubscribe_52": {
      "name": "TestBrokerSubscribe",
      "type": "function",
      "start_line": 52,
      "end_line": 69,
      "content_hash": "597bb6dcbebac2ef4359b0824eb516923a691a1e",
      "content": "func TestBrokerSubscribe(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\tif sub == nil {\n\t\tt.Fatal(\"Subscribe returned nil channel\")\n\t}\n\n\tcount := broker.GetSubscriberCount()\n\tif count != 1 {\n\t\tt.Errorf(\"expected 1 subscriber, got %d\", count)\n\t}\n}\n\n// TestBrokerMultipleSubscribers verifies multiple subscriptions",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerMultipleSubscribers_70": {
      "name": "TestBrokerMultipleSubscribers",
      "type": "function",
      "start_line": 70,
      "end_line": 90,
      "content_hash": "756bb9ea26173055109addf4de8e7f87fcb88ff0",
      "content": "func TestBrokerMultipleSubscribers(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\n\tsub1 := broker.Subscribe(ctx)\n\tsub2 := broker.Subscribe(ctx)\n\tsub3 := broker.Subscribe(ctx)\n\n\tif sub1 == nil || sub2 == nil || sub3 == nil {\n\t\tt.Fatal(\"Subscribe returned nil channel\")\n\t}\n\n\tcount := broker.GetSubscriberCount()\n\tif count != 3 {\n\t\tt.Errorf(\"expected 3 subscribers, got %d\", count)\n\t}\n}\n\n// TestBrokerPublish verifies event publishing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerPublish_91": {
      "name": "TestBrokerPublish",
      "type": "function",
      "start_line": 91,
      "end_line": 116,
      "content_hash": "b1f1e22ebbf231c3a0286409087d31095d16a2b6",
      "content": "func TestBrokerPublish(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\t// Publish an event\n\ttestPayload := \"test message\"\n\tbroker.Publish(CreatedEvent, testPayload)\n\n\t// Receive the event\n\tselect {\n\tcase event := <-sub:\n\t\tif event.Type != CreatedEvent {\n\t\t\tt.Errorf(\"expected event type %s, got %s\", CreatedEvent, event.Type)\n\t\t}\n\t\tif event.Payload != testPayload {\n\t\t\tt.Errorf(\"expected payload %s, got %s\", testPayload, event.Payload)\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatal(\"timeout waiting for event\")\n\t}\n}\n\n// TestBrokerPublishToMultipleSubscribers verifies broadcast functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerPublishToMultipleSubscribers_117": {
      "name": "TestBrokerPublishToMultipleSubscribers",
      "type": "function",
      "start_line": 117,
      "end_line": 156,
      "content_hash": "08864be541c04537f40ebb972aafbda653919029",
      "content": "func TestBrokerPublishToMultipleSubscribers(t *testing.T) {\n\tbroker := NewBroker[int]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\n\tsub1 := broker.Subscribe(ctx)\n\tsub2 := broker.Subscribe(ctx)\n\tsub3 := broker.Subscribe(ctx)\n\n\ttestPayload := 42\n\tbroker.Publish(UpdatedEvent, testPayload)\n\n\t// All subscribers should receive the event\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\n\tcheckEvent := func(sub <-chan Event[int], name string) {\n\t\tdefer wg.Done()\n\t\tselect {\n\t\tcase event := <-sub:\n\t\t\tif event.Type != UpdatedEvent {\n\t\t\t\tt.Errorf(\"%s: expected event type %s, got %s\", name, UpdatedEvent, event.Type)\n\t\t\t}\n\t\t\tif event.Payload != testPayload {\n\t\t\t\tt.Errorf(\"%s: expected payload %d, got %d\", name, testPayload, event.Payload)\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Errorf(\"%s: timeout waiting for event\", name)\n\t\t}\n\t}\n\n\tgo checkEvent(sub1, \"sub1\")\n\tgo checkEvent(sub2, \"sub2\")\n\tgo checkEvent(sub3, \"sub3\")\n\n\twg.Wait()\n}\n\n// TestBrokerShutdown verifies graceful shutdown",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerShutdown_157": {
      "name": "TestBrokerShutdown",
      "type": "function",
      "start_line": 157,
      "end_line": 178,
      "content_hash": "511b31ae726fb30018065d2c9d726ff7d07b6ef8",
      "content": "func TestBrokerShutdown(t *testing.T) {\n\tbroker := NewBroker[string]()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\tbroker.Shutdown()\n\n\t// Subscriber count should be 0\n\tcount := broker.GetSubscriberCount()\n\tif count != 0 {\n\t\tt.Errorf(\"expected 0 subscribers after shutdown, got %d\", count)\n\t}\n\n\t// Channel should be closed\n\t_, ok := <-sub\n\tif ok {\n\t\tt.Error(\"subscriber channel should be closed after shutdown\")\n\t}\n}\n\n// TestBrokerShutdownIdempotent verifies shutdown can be called multiple times",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerShutdownIdempotent_179": {
      "name": "TestBrokerShutdownIdempotent",
      "type": "function",
      "start_line": 179,
      "end_line": 187,
      "content_hash": "9c6440540247eb1fb4f890163b8d040cef8dc698",
      "content": "func TestBrokerShutdownIdempotent(t *testing.T) {\n\tbroker := NewBroker[string]()\n\n\tbroker.Shutdown()\n\tbroker.Shutdown() // Should not panic\n\tbroker.Shutdown() // Should not panic\n}\n\n// TestBrokerSubscribeAfterShutdown verifies subscription after shutdown",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerSubscribeAfterShutdown_188": {
      "name": "TestBrokerSubscribeAfterShutdown",
      "type": "function",
      "start_line": 188,
      "end_line": 202,
      "content_hash": "352bf33d4b70da1a46a2789610d8ddd853372074",
      "content": "func TestBrokerSubscribeAfterShutdown(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tbroker.Shutdown()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\t// Should return closed channel\n\t_, ok := <-sub\n\tif ok {\n\t\tt.Error(\"subscription after shutdown should return closed channel\")\n\t}\n}\n\n// TestBrokerPublishAfterShutdown verifies publish after shutdown doesn't panic",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerPublishAfterShutdown_203": {
      "name": "TestBrokerPublishAfterShutdown",
      "type": "function",
      "start_line": 203,
      "end_line": 211,
      "content_hash": "9d0c35f1e5454249bcf6452071f9afe02bbf8297",
      "content": "func TestBrokerPublishAfterShutdown(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tbroker.Shutdown()\n\n\t// Should not panic\n\tbroker.Publish(CreatedEvent, \"test\")\n}\n\n// TestBrokerContextCancellation verifies subscriber cleanup on context cancel",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerContextCancellation_212": {
      "name": "TestBrokerContextCancellation",
      "type": "function",
      "start_line": 212,
      "end_line": 244,
      "content_hash": "ac0c86ad86653f87489821b8390d03f54f1490fc",
      "content": "func TestBrokerContextCancellation(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tdefer broker.Shutdown()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tsub := broker.Subscribe(ctx)\n\n\t// Verify subscription\n\tcount := broker.GetSubscriberCount()\n\tif count != 1 {\n\t\tt.Fatalf(\"expected 1 subscriber, got %d\", count)\n\t}\n\n\t// Cancel context\n\tcancel()\n\n\t// Wait for cleanup (goroutine needs time to process cancellation)\n\ttime.Sleep(50 * time.Millisecond)\n\n\t// Subscriber should be removed\n\tcount = broker.GetSubscriberCount()\n\tif count != 0 {\n\t\tt.Errorf(\"expected 0 subscribers after context cancel, got %d\", count)\n\t}\n\n\t// Channel should be closed\n\t_, ok := <-sub\n\tif ok {\n\t\tt.Error(\"subscriber channel should be closed after context cancel\")\n\t}\n}\n\n// TestBrokerEventTypes verifies different event types",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerEventTypes_245": {
      "name": "TestBrokerEventTypes",
      "type": "function",
      "start_line": 245,
      "end_line": 279,
      "content_hash": "8e6648fa6c1fa56307c0f46f774a44334fb66c97",
      "content": "func TestBrokerEventTypes(t *testing.T) {\n\tbroker := NewBroker[string]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\ttests := []struct {\n\t\teventType EventType\n\t\tpayload   string\n\t}{\n\t\t{CreatedEvent, \"created payload\"},\n\t\t{UpdatedEvent, \"updated payload\"},\n\t\t{DeletedEvent, \"deleted payload\"},\n\t\t{EventType(\"custom\"), \"custom payload\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tbroker.Publish(tt.eventType, tt.payload)\n\n\t\tselect {\n\t\tcase event := <-sub:\n\t\t\tif event.Type != tt.eventType {\n\t\t\t\tt.Errorf(\"expected event type %s, got %s\", tt.eventType, event.Type)\n\t\t\t}\n\t\t\tif event.Payload != tt.payload {\n\t\t\t\tt.Errorf(\"expected payload %s, got %s\", tt.payload, event.Payload)\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"timeout waiting for event type %s\", tt.eventType)\n\t\t}\n\t}\n}\n\n// TestBrokerSlowSubscriber verifies handling of slow subscribers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerSlowSubscriber_280": {
      "name": "TestBrokerSlowSubscriber",
      "type": "function",
      "start_line": 280,
      "end_line": 332,
      "content_hash": "5af30d9ecab2bc13c937db5bb64ba2e18644a917",
      "content": "func TestBrokerSlowSubscriber(t *testing.T) {\n\tbroker := NewBrokerWithOptions[int](2, 1000) // Small buffer\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\tslowSub := broker.Subscribe(ctx)\n\tfastSub := broker.Subscribe(ctx)\n\n\t// Fill slow subscriber's buffer\n\tfor i := 0; i < 5; i++ {\n\t\tbroker.Publish(CreatedEvent, i)\n\t}\n\n\t// Fast subscriber drains immediately\n\treceived := 0\n\ttimeout := time.After(500 * time.Millisecond)\n\ndrainLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-fastSub:\n\t\t\treceived++\n\t\tcase <-timeout:\n\t\t\tbreak drainLoop\n\t\tdefault:\n\t\t\t// No more events immediately available\n\t\t\tbreak drainLoop\n\t\t}\n\t}\n\n\t// Fast subscriber should receive at least some events\n\tif received == 0 {\n\t\tt.Error(\"fast subscriber received no events\")\n\t}\n\n\t// Slow subscriber buffer should have some events (but may drop some)\n\tslowReceived := 0\nslowLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-slowSub:\n\t\t\tslowReceived++\n\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\tbreak slowLoop\n\t\t}\n\t}\n\n\tif slowReceived == 0 {\n\t\tt.Error(\"slow subscriber received no events\")\n\t}\n}\n\n// TestBrokerConcurrentPublish verifies thread-safe publishing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerConcurrentPublish_333": {
      "name": "TestBrokerConcurrentPublish",
      "type": "function",
      "start_line": 333,
      "end_line": 395,
      "content_hash": "f1dea4f5f7ec6c505580f388fccc64323331da33",
      "content": "func TestBrokerConcurrentPublish(t *testing.T) {\n\tbroker := NewBroker[int]()\n\tdefer broker.Shutdown()\n\n\tctx := context.Background()\n\tsub := broker.Subscribe(ctx)\n\n\tconst numPublishers = 5\n\tconst numEventsPerPublisher = 50\n\n\tvar wg sync.WaitGroup\n\twg.Add(numPublishers)\n\n\t// Collect events in background (drain fast to avoid buffer overflow)\n\treceived := make(map[int]bool)\n\tvar receiveMu sync.Mutex\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tfor event := range sub {\n\t\t\treceiveMu.Lock()\n\t\t\treceived[event.Payload] = true\n\t\t\tcount := len(received)\n\t\t\treceiveMu.Unlock()\n\n\t\t\tif count >= numPublishers*numEventsPerPublisher {\n\t\t\t\tclose(done)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Start concurrent publishers after receiver is ready\n\tfor i := 0; i < numPublishers; i++ {\n\t\tgo func(publisherID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < numEventsPerPublisher; j++ {\n\t\t\t\tbroker.Publish(CreatedEvent, publisherID*1000+j)\n\t\t\t\ttime.Sleep(time.Microsecond) // Small delay to avoid overwhelming buffer\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\t// Give receiver time to process remaining events\n\tselect {\n\tcase <-done:\n\t\t// Success\n\tcase <-time.After(2 * time.Second):\n\t\treceiveMu.Lock()\n\t\tcount := len(received)\n\t\treceiveMu.Unlock()\n\n\t\t// Some events may be dropped if buffer is full, that's expected behavior\n\t\tif count < numPublishers*numEventsPerPublisher/2 {\n\t\t\tt.Errorf(\"received too few events: %d (expected at least %d)\",\n\t\t\t\tcount, numPublishers*numEventsPerPublisher/2)\n\t\t}\n\t}\n}\n\n// TestBrokerGenericTypes verifies different payload types",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBrokerGenericTypes_396": {
      "name": "TestBrokerGenericTypes",
      "type": "function",
      "start_line": 396,
      "end_line": 416,
      "content_hash": "7e5d519ef8a5b1bb79d743a119ac2284622ff973",
      "content": "func TestBrokerGenericTypes(t *testing.T) {\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tbroker := NewBroker[string]()\n\t\tdefer broker.Shutdown()\n\n\t\tctx := context.Background()\n\t\tsub := broker.Subscribe(ctx)\n\n\t\tbroker.Publish(CreatedEvent, \"test string\")\n\n\t\tselect {\n\t\tcase event := <-sub:\n\t\t\tif event.Payload != \"test string\" {\n\t\t\t\tt.Errorf(\"expected 'test string', got %s\", event.Payload)\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TestStruct_417": {
      "name": "TestStruct",
      "type": "struct",
      "start_line": 417,
      "end_line": 462,
      "content_hash": "cb3c4a848e850a3288823bdd9a971078c3b0296b",
      "content": "\t\ttype TestStruct struct {\n\t\t\tID   int\n\t\t\tName string\n\t\t}\n\n\t\tbroker := NewBroker[TestStruct]()\n\t\tdefer broker.Shutdown()\n\n\t\tctx := context.Background()\n\t\tsub := broker.Subscribe(ctx)\n\n\t\tpayload := TestStruct{ID: 42, Name: \"test\"}\n\t\tbroker.Publish(CreatedEvent, payload)\n\n\t\tselect {\n\t\tcase event := <-sub:\n\t\t\tif event.Payload.ID != 42 || event.Payload.Name != \"test\" {\n\t\t\t\tt.Errorf(\"unexpected payload: %+v\", event.Payload)\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t})\n\n\tt.Run(\"pointer\", func(t *testing.T) {\n\t\tbroker := NewBroker[*int]()\n\t\tdefer broker.Shutdown()\n\n\t\tctx := context.Background()\n\t\tsub := broker.Subscribe(ctx)\n\n\t\tvalue := 42\n\t\tbroker.Publish(CreatedEvent, &value)\n\n\t\tselect {\n\t\tcase event := <-sub:\n\t\t\tif event.Payload == nil || *event.Payload != 42 {\n\t\t\t\tt.Error(\"unexpected pointer payload\")\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t})\n}\n\n// TestUpdateAvailableMsg verifies the update message structure",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestUpdateAvailableMsg_463": {
      "name": "TestUpdateAvailableMsg",
      "type": "function",
      "start_line": 463,
      "end_line": 481,
      "content_hash": "448206bd25c9985c4383a34ef68d494f05f348f2",
      "content": "func TestUpdateAvailableMsg(t *testing.T) {\n\tmsg := UpdateAvailableMsg{\n\t\tCurrentVersion: \"0.1.0\",\n\t\tLatestVersion:  \"0.2.0\",\n\t\tIsDevelopment:  false,\n\t}\n\n\tif msg.CurrentVersion != \"0.1.0\" {\n\t\tt.Errorf(\"expected CurrentVersion '0.1.0', got %s\", msg.CurrentVersion)\n\t}\n\n\tif msg.LatestVersion != \"0.2.0\" {\n\t\tt.Errorf(\"expected LatestVersion '0.2.0', got %s\", msg.LatestVersion)\n\t}\n\n\tif msg.IsDevelopment {\n\t\tt.Error(\"expected IsDevelopment false\")\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}