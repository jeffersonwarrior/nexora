{
  "file_path": "/work/internal/shell/background_test.go",
  "file_hash": "01eba173cb12d6f93c70d6ac6da61b8f8f699ecd",
  "updated_at": "2025-12-26T17:34:21.349335",
  "symbols": {
    "function_TestBackgroundShellManager_Start_10": {
      "name": "TestBackgroundShellManager_Start",
      "type": "function",
      "start_line": 10,
      "end_line": 47,
      "content_hash": "2a422f04f2972e7f8e9f1e638190f92bd4bfe0cc",
      "content": "func TestBackgroundShellManager_Start(t *testing.T) {\n\tt.Skip(\"Skipping this until I figure out why its flaky\")\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\tbgShell, err := manager.Start(ctx, workingDir, nil, \"echo 'hello world'\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start background shell: %v\", err)\n\t}\n\n\tif bgShell.ID == \"\" {\n\t\tt.Error(\"expected shell ID to be non-empty\")\n\t}\n\n\t// Wait for the command to complete\n\tbgShell.Wait()\n\n\tstdout, stderr, done, err := bgShell.GetOutput()\n\tif !done {\n\t\tt.Error(\"expected shell to be done\")\n\t}\n\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, got: %v\", err)\n\t}\n\n\tif !strings.Contains(stdout, \"hello world\") {\n\t\tt.Errorf(\"expected stdout to contain 'hello world', got: %s\", stdout)\n\t}\n\n\tif stderr != \"\" {\n\t\tt.Errorf(\"expected empty stderr, got: %s\", stderr)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShellManager_Get_48": {
      "name": "TestBackgroundShellManager_Get",
      "type": "function",
      "start_line": 48,
      "end_line": 73,
      "content_hash": "425d2582ac18b46b4883860611d3427d7ca1e137",
      "content": "func TestBackgroundShellManager_Get(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\tbgShell, err := manager.Start(ctx, workingDir, nil, \"echo 'test'\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start background shell: %v\", err)\n\t}\n\n\t// Retrieve the shell\n\tretrieved, ok := manager.Get(bgShell.ID)\n\tif !ok {\n\t\tt.Error(\"expected to find the background shell\")\n\t}\n\n\tif retrieved.ID != bgShell.ID {\n\t\tt.Errorf(\"expected shell ID %s, got %s\", bgShell.ID, retrieved.ID)\n\t}\n\n\t// Clean up\n\tmanager.Kill(bgShell.ID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShellManager_Kill_74": {
      "name": "TestBackgroundShellManager_Kill",
      "type": "function",
      "start_line": 74,
      "end_line": 104,
      "content_hash": "e270c0d6d8885c6068893d1b83e0a3ded1b1c752",
      "content": "func TestBackgroundShellManager_Kill(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\t// Start a long-running command\n\tbgShell, err := manager.Start(ctx, workingDir, nil, \"sleep 10\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start background shell: %v\", err)\n\t}\n\n\t// Kill it\n\terr = manager.Kill(bgShell.ID)\n\tif err != nil {\n\t\tt.Errorf(\"failed to kill background shell: %v\", err)\n\t}\n\n\t// Verify it's no longer in the manager\n\t_, ok := manager.Get(bgShell.ID)\n\tif ok {\n\t\tt.Error(\"expected shell to be removed after kill\")\n\t}\n\n\t// Verify the shell is done\n\tif !bgShell.IsDone() {\n\t\tt.Error(\"expected shell to be done after kill\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShellManager_KillNonExistent_105": {
      "name": "TestBackgroundShellManager_KillNonExistent",
      "type": "function",
      "start_line": 105,
      "end_line": 115,
      "content_hash": "9c3459acc5dfe378312ed1cdd335d98ccbb81a95",
      "content": "func TestBackgroundShellManager_KillNonExistent(t *testing.T) {\n\tt.Parallel()\n\n\tmanager := GetBackgroundShellManager()\n\n\terr := manager.Kill(\"non-existent-id\")\n\tif err == nil {\n\t\tt.Error(\"expected error when killing non-existent shell\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShell_IsDone_116": {
      "name": "TestBackgroundShell_IsDone",
      "type": "function",
      "start_line": 116,
      "end_line": 138,
      "content_hash": "761d1f66c2d7bf7d8a6c9e6679db88a39ef437c8",
      "content": "func TestBackgroundShell_IsDone(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\tbgShell, err := manager.Start(ctx, workingDir, nil, \"echo 'quick'\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start background shell: %v\", err)\n\t}\n\n\t// Wait a bit for the command to complete\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif !bgShell.IsDone() {\n\t\tt.Error(\"expected shell to be done\")\n\t}\n\n\t// Clean up\n\tmanager.Kill(bgShell.ID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShell_WithBlockFuncs_139": {
      "name": "TestBackgroundShell_WithBlockFuncs",
      "type": "function",
      "start_line": 139,
      "end_line": 172,
      "content_hash": "857bd45668f3a9f7ddcb786cff77a500d89a7890",
      "content": "func TestBackgroundShell_WithBlockFuncs(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\tblockFuncs := []BlockFunc{\n\t\tCommandsBlocker([]string{\"curl\", \"wget\"}),\n\t}\n\n\tbgShell, err := manager.Start(ctx, workingDir, blockFuncs, \"curl example.com\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start background shell: %v\", err)\n\t}\n\n\t// Wait for the command to complete\n\tbgShell.Wait()\n\n\tstdout, stderr, done, execErr := bgShell.GetOutput()\n\tif !done {\n\t\tt.Error(\"expected shell to be done\")\n\t}\n\n\t// The command should have been blocked\n\toutput := stdout + stderr\n\tif !strings.Contains(output, \"not allowed\") && execErr == nil {\n\t\tt.Errorf(\"expected command to be blocked, got stdout: %s, stderr: %s, err: %v\", stdout, stderr, execErr)\n\t}\n\n\t// Clean up\n\tmanager.Kill(bgShell.ID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShellManager_List_173": {
      "name": "TestBackgroundShellManager_List",
      "type": "function",
      "start_line": 173,
      "end_line": 216,
      "content_hash": "209dcb6375c8066fef3b62157493ae9edb709160",
      "content": "func TestBackgroundShellManager_List(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\t// Start two shells\n\tbgShell1, err := manager.Start(ctx, workingDir, nil, \"sleep 1\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start first background shell: %v\", err)\n\t}\n\n\tbgShell2, err := manager.Start(ctx, workingDir, nil, \"sleep 1\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start second background shell: %v\", err)\n\t}\n\n\tids := manager.List()\n\n\t// Check that both shells are in the list\n\tfound1 := false\n\tfound2 := false\n\tfor _, id := range ids {\n\t\tif id == bgShell1.ID {\n\t\t\tfound1 = true\n\t\t}\n\t\tif id == bgShell2.ID {\n\t\t\tfound2 = true\n\t\t}\n\t}\n\n\tif !found1 {\n\t\tt.Errorf(\"expected to find shell %s in list\", bgShell1.ID)\n\t}\n\tif !found2 {\n\t\tt.Errorf(\"expected to find shell %s in list\", bgShell2.ID)\n\t}\n\n\t// Clean up\n\tmanager.Kill(bgShell1.ID)\n\tmanager.Kill(bgShell2.ID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBackgroundShellManager_KillAll_217": {
      "name": "TestBackgroundShellManager_KillAll",
      "type": "function",
      "start_line": 217,
      "end_line": 277,
      "content_hash": "71cd6f9e428a5206488afd81305bb0ca3024c1fc",
      "content": "func TestBackgroundShellManager_KillAll(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tworkingDir := t.TempDir()\n\tmanager := GetBackgroundShellManager()\n\n\t// Start multiple long-running shells\n\tshell1, err := manager.Start(ctx, workingDir, nil, \"sleep 10\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start shell 1: %v\", err)\n\t}\n\n\tshell2, err := manager.Start(ctx, workingDir, nil, \"sleep 10\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start shell 2: %v\", err)\n\t}\n\n\tshell3, err := manager.Start(ctx, workingDir, nil, \"sleep 10\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start shell 3: %v\", err)\n\t}\n\n\t// Verify shells are running\n\tif shell1.IsDone() || shell2.IsDone() || shell3.IsDone() {\n\t\tt.Error(\"shells should not be done yet\")\n\t}\n\n\t// Kill all shells\n\tmanager.KillAll()\n\n\t// Verify all shells are done\n\tif !shell1.IsDone() {\n\t\tt.Error(\"shell1 should be done after KillAll\")\n\t}\n\tif !shell2.IsDone() {\n\t\tt.Error(\"shell2 should be done after KillAll\")\n\t}\n\tif !shell3.IsDone() {\n\t\tt.Error(\"shell3 should be done after KillAll\")\n\t}\n\n\t// Verify they're removed from the manager\n\tif _, ok := manager.Get(shell1.ID); ok {\n\t\tt.Error(\"shell1 should be removed from manager\")\n\t}\n\tif _, ok := manager.Get(shell2.ID); ok {\n\t\tt.Error(\"shell2 should be removed from manager\")\n\t}\n\tif _, ok := manager.Get(shell3.ID); ok {\n\t\tt.Error(\"shell3 should be removed from manager\")\n\t}\n\n\t// Verify list is empty (or doesn't contain our shells)\n\tids := manager.List()\n\tfor _, id := range ids {\n\t\tif id == shell1.ID || id == shell2.ID || id == shell3.ID {\n\t\t\tt.Errorf(\"shell %s should not be in list after KillAll\", id)\n\t\t}\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}