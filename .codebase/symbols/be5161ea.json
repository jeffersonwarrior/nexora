{
  "file_path": "/work/context-engine/tests/test_router_batching.py",
  "file_hash": "d0992efe501b6d014786dc4bd81987fdacc81b6e",
  "updated_at": "2025-12-26T17:34:24.045761",
  "symbols": {
    "class__Counter_9": {
      "name": "_Counter",
      "type": "class",
      "start_line": 9,
      "end_line": 17,
      "content_hash": "747258a08afd76e0551434954a9d9c19343bfe88",
      "content": "class _Counter:\n    def __init__(self):\n        self.n = 0\n        self.lock = threading.Lock()\n\n    def inc(self):\n        with self.lock:\n            self.n += 1\n            return self.n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___10": {
      "name": "__init__",
      "type": "method",
      "start_line": 10,
      "end_line": 12,
      "content_hash": "67c58481d7625819f51a2435e2befb98eea9aa03",
      "content": "    def __init__(self):\n        self.n = 0\n        self.lock = threading.Lock()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inc_14": {
      "name": "inc",
      "type": "method",
      "start_line": 14,
      "end_line": 17,
      "content_hash": "8ecf5ad3e1907aa22a3675a826d4582b38684a70",
      "content": "    def inc(self):\n        with self.lock:\n            self.n += 1\n            return self.n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__fake_call_factory_20": {
      "name": "_fake_call_factory",
      "type": "function",
      "start_line": 20,
      "end_line": 46,
      "content_hash": "ac9fdbeac875bd3c66657fd3bb7f70566cb21f14",
      "content": "def _fake_call_factory(counter: _Counter):\n    def _fake_call(base_url: str, tool: str, args: dict, timeout: float = 1.0):\n        # Simulate a tiny network call and count invocations\n        counter.inc()\n        time.sleep(0.01)\n        q = args.get(\"query\")\n        queries = args.get(\"queries\") or ([q] if q else ([] if q is None else ([q] if not isinstance(q, list) else q)))\n        # When multiple queries are provided (aggregated call), return structured per-query answers\n        answers_by_query = None\n        if isinstance(q, list) and len(q) > 1:\n            answers_by_query = [\n                {\"query\": str(qi), \"answer\": \"ok\", \"citations\": []} for qi in q\n            ]\n        return {\n            \"result\": {\n                \"structuredContent\": {\n                    \"result\": {\n                        \"answer\": \"ok\",\n                        \"citations\": [],\n                        \"query\": queries,\n                        **({\"answers_by_query\": answers_by_query} if answers_by_query else {}),\n                    }\n                }\n            }\n        }\n\n    return _fake_call",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__fake_call_21": {
      "name": "_fake_call",
      "type": "function",
      "start_line": 21,
      "end_line": 44,
      "content_hash": "7f22bb82ef58008deec6bd42619327466eabfdb8",
      "content": "    def _fake_call(base_url: str, tool: str, args: dict, timeout: float = 1.0):\n        # Simulate a tiny network call and count invocations\n        counter.inc()\n        time.sleep(0.01)\n        q = args.get(\"query\")\n        queries = args.get(\"queries\") or ([q] if q else ([] if q is None else ([q] if not isinstance(q, list) else q)))\n        # When multiple queries are provided (aggregated call), return structured per-query answers\n        answers_by_query = None\n        if isinstance(q, list) and len(q) > 1:\n            answers_by_query = [\n                {\"query\": str(qi), \"answer\": \"ok\", \"citations\": []} for qi in q\n            ]\n        return {\n            \"result\": {\n                \"structuredContent\": {\n                    \"result\": {\n                        \"answer\": \"ok\",\n                        \"citations\": [],\n                        \"query\": queries,\n                        **({\"answers_by_query\": answers_by_query} if answers_by_query else {}),\n                    }\n                }\n            }\n        }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_batching_merges_identical_queries_49": {
      "name": "test_batching_merges_identical_queries",
      "type": "function",
      "start_line": 49,
      "end_line": 82,
      "content_hash": "5b66b87bb6b20aa1a15ade726f3420fbb4774d27",
      "content": "def test_batching_merges_identical_queries():\n    counter = _Counter()\n    client = BatchingContextAnswerClient(\n        call_func=_fake_call_factory(counter),\n        enable=True,\n        window_ms=120,\n        max_batch=8,\n        budget_ms=2000,\n    )\n\n    results: list[dict] = []\n    barrier = threading.Barrier(3)\n\n    def worker():\n        barrier.wait()\n        res = client.call_or_enqueue(\n            \"http://localhost:8003/mcp\",\n            \"context_answer\",\n            {\"query\": \"What is batching?\", \"limit\": 5},\n            timeout=1.0,\n        )\n        results.append(res)\n\n    t1 = threading.Thread(target=worker)\n    t2 = threading.Thread(target=worker)\n    t1.start(); t2.start()\n    barrier.wait()  # release both workers\n    t1.join(); t2.join()\n\n    # Exactly one underlying call, two client results\n    assert counter.n == 1\n    assert len(results) == 2\n    for r in results:\n        assert r.get(\"result\", {}).get(\"structuredContent\", {}).get(\"result\", {}).get(\"answer\") == \"ok\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_worker_62": {
      "name": "worker",
      "type": "function",
      "start_line": 62,
      "end_line": 70,
      "content_hash": "7445f5124860d7edd339f2db362b3adba5864d88",
      "content": "    def worker():\n        barrier.wait()\n        res = client.call_or_enqueue(\n            \"http://localhost:8003/mcp\",\n            \"context_answer\",\n            {\"query\": \"What is batching?\", \"limit\": 5},\n            timeout=1.0,\n        )\n        results.append(res)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_batching_cap_flushes_early_85": {
      "name": "test_batching_cap_flushes_early",
      "type": "function",
      "start_line": 85,
      "end_line": 116,
      "content_hash": "3b43e71d147d6f265c1637090d702b3a70f4e58f",
      "content": "def test_batching_cap_flushes_early():\n    counter = _Counter()\n    client = BatchingContextAnswerClient(\n        call_func=_fake_call_factory(counter),\n        enable=True,\n        window_ms=5000,  # long window, but cap will force immediate flush\n        max_batch=2,\n        budget_ms=2000,\n    )\n\n    results: list[dict] = []\n    barrier = threading.Barrier(3)\n\n    def worker(q):\n        barrier.wait()\n        res = client.call_or_enqueue(\n            \"http://localhost:8003/mcp\",\n            \"context_answer\",\n            {\"query\": q, \"limit\": 5},\n            timeout=1.0,\n        )\n        results.append(res)\n\n    t1 = threading.Thread(target=worker, args=(\"A\",))\n    t2 = threading.Thread(target=worker, args=(\"B\",))\n    t1.start(); t2.start()\n    barrier.wait()\n    t1.join(); t2.join()\n\n    # Cap reached: we flush once and make a single aggregated call\n    assert counter.n == 1\n    assert len(results) == 2",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_worker_98": {
      "name": "worker",
      "type": "function",
      "start_line": 98,
      "end_line": 106,
      "content_hash": "742e3396e0b765a7d22a3abcf51ff65c6a30c1fb",
      "content": "    def worker(q):\n        barrier.wait()\n        res = client.call_or_enqueue(\n            \"http://localhost:8003/mcp\",\n            \"context_answer\",\n            {\"query\": q, \"limit\": 5},\n            timeout=1.0,\n        )\n        results.append(res)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_bypass_immediate_flag_calls_direct_119": {
      "name": "test_bypass_immediate_flag_calls_direct",
      "type": "function",
      "start_line": 119,
      "end_line": 145,
      "content_hash": "4d413e1a13692d8e34cf5d1fb9d03b14534a1858",
      "content": "def test_bypass_immediate_flag_calls_direct():\n    counter = _Counter()\n    client = BatchingContextAnswerClient(\n        call_func=_fake_call_factory(counter),\n        enable=True,\n        window_ms=200,\n        max_batch=8,\n        budget_ms=2000,\n    )\n\n    # Two direct calls because of immediate flag; they should not be batched\n    r1 = client.call_or_enqueue(\n        \"http://localhost:8003/mcp\",\n        \"context_answer\",\n        {\"query\": \"Q1\", \"limit\": 5, \"immediate\": True},\n        timeout=1.0,\n    )\n    r2 = client.call_or_enqueue(\n        \"http://localhost:8003/mcp\",\n        \"context_answer\",\n        {\"query\": \"Q2\", \"limit\": 5, \"immediate\": True},\n        timeout=1.0,\n    )\n\n    assert counter.n == 2\n    assert r1.get(\"result\", {}).get(\"structuredContent\", {}).get(\"result\", {}).get(\"answer\") == \"ok\"\n    assert r2.get(\"result\", {}).get(\"structuredContent\", {}).get(\"result\", {}).get(\"answer\") == \"ok\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}