{
  "file_path": "/work/internal/config/init.go",
  "file_hash": "18e8856a65e71664189c978a55ed9f8b761de83d",
  "updated_at": "2025-12-26T17:34:20.585133",
  "symbols": {
    "struct_ProjectInitFlag_18": {
      "name": "ProjectInitFlag",
      "type": "struct",
      "start_line": 18,
      "end_line": 29,
      "content_hash": "b23ed2fad0575cd0eb901b70d991386a7df1e60a",
      "content": "type ProjectInitFlag struct {\n\tInitialized bool `json:\"initialized\"`\n}\n\n// Migration note: Global config pattern for legacy compatibility\n// The atomic.Pointer instance serves as a bridge during gradual migration\n// Future refactoring should:\n// 1. Remove global dependency by injecting config where needed\n// 2. Update callers to pass config explicitly\n// 3. Eliminate this singleton pattern for better testability\nvar instance atomic.Pointer[Config]\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Init_30": {
      "name": "Init",
      "type": "function",
      "start_line": 30,
      "end_line": 38,
      "content_hash": "3e9b3a0e212d431f3afcf8b640d887beade8c93e",
      "content": "func Init(workingDir, dataDir string, debug bool) (*Config, error) {\n\tcfg, err := Load(workingDir, dataDir, debug)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinstance.Store(cfg)\n\treturn instance.Load(), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Get_39": {
      "name": "Get",
      "type": "function",
      "start_line": 39,
      "end_line": 43,
      "content_hash": "c0c9b596933b3ceb7134320ffa3a8618b41581e4",
      "content": "func Get() *Config {\n\tcfg := instance.Load()\n\treturn cfg\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ProjectNeedsInitialization_44": {
      "name": "ProjectNeedsInitialization",
      "type": "function",
      "start_line": 44,
      "end_line": 80,
      "content_hash": "fad2d6c6c3d103ddb2b5977f774c1212a6b529a6",
      "content": "func ProjectNeedsInitialization() (bool, error) {\n\tcfg := Get()\n\tif cfg == nil {\n\t\treturn false, fmt.Errorf(\"config not loaded\")\n\t}\n\n\tflagFilePath := filepath.Join(cfg.Options.DataDirectory, InitFlagFilename)\n\n\t_, err := os.Stat(flagFilePath)\n\tif err == nil {\n\t\treturn false, nil\n\t}\n\n\tif !os.IsNotExist(err) {\n\t\treturn false, fmt.Errorf(\"failed to check init flag file: %w\", err)\n\t}\n\n\tsomeContextFileExists, err := contextPathsExist(cfg.WorkingDir())\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check for context files: %w\", err)\n\t}\n\tif someContextFileExists {\n\t\treturn false, nil\n\t}\n\n\t// If the working directory has no non-ignored files, skip initialization step\n\tempty, err := dirHasNoVisibleFiles(cfg.WorkingDir())\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check if directory is empty: %w\", err)\n\t}\n\tif empty {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_contextPathsExist_81": {
      "name": "contextPathsExist",
      "type": "function",
      "start_line": 81,
      "end_line": 109,
      "content_hash": "0cec1cdacf5fbb769fa50198eef70dd5288d5cd7",
      "content": "func contextPathsExist(dir string) (bool, error) {\n\tentries, err := os.ReadDir(dir)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// Create a slice of lowercase filenames for lookup with slices.Contains\n\tvar files []string\n\tfor _, entry := range entries {\n\t\tif !entry.IsDir() {\n\t\t\tfiles = append(files, strings.ToLower(entry.Name()))\n\t\t}\n\t}\n\n\t// Check if any of the default context paths exist in the directory\n\tfor _, path := range defaultContextPaths {\n\t\t// Extract just the filename from the path\n\t\t_, filename := filepath.Split(path)\n\t\tfilename = strings.ToLower(filename)\n\n\t\tif slices.Contains(files, filename) {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// dirHasNoVisibleFiles returns true if the directory has no files/dirs after applying ignore rules",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_dirHasNoVisibleFiles_110": {
      "name": "dirHasNoVisibleFiles",
      "type": "function",
      "start_line": 110,
      "end_line": 117,
      "content_hash": "7b2f421e822564e3fe05f3a0d118a8b492d55c9c",
      "content": "func dirHasNoVisibleFiles(dir string) (bool, error) {\n\tfiles, _, err := fsext.ListDirectory(dir, nil, 1, 1)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn len(files) == 0, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_MarkProjectInitialized_118": {
      "name": "MarkProjectInitialized",
      "type": "function",
      "start_line": 118,
      "end_line": 133,
      "content_hash": "770dc7599b35995d2abc87b4c357852fd706f07a",
      "content": "func MarkProjectInitialized() error {\n\tcfg := Get()\n\tif cfg == nil {\n\t\treturn fmt.Errorf(\"config not loaded\")\n\t}\n\tflagFilePath := filepath.Join(cfg.Options.DataDirectory, InitFlagFilename)\n\n\tfile, err := os.Create(flagFilePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create init flag file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HasInitialDataConfig_134": {
      "name": "HasInitialDataConfig",
      "type": "function",
      "start_line": 134,
      "end_line": 140,
      "content_hash": "e54e1cc6bdeb493e4d28ad0bd11419c4f7a700bf",
      "content": "func HasInitialDataConfig() bool {\n\tcfgPath := GlobalConfigData()\n\tif _, err := os.Stat(cfgPath); err != nil {\n\t\treturn false\n\t}\n\treturn Get().IsConfigured()\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}