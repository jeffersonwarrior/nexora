{
  "file_path": "/work/context-engine/scripts/mcp_router/hints.py",
  "file_hash": "a444012a22d93ac85ed57982d9d991ecfecbd2b1",
  "updated_at": "2025-12-26T17:34:21.736422",
  "symbols": {
    "function_parse_repo_hints_14": {
      "name": "parse_repo_hints",
      "type": "function",
      "start_line": 14,
      "end_line": 66,
      "content_hash": "dc328261282dbc358a002b7db499bf0e099dc900",
      "content": "def parse_repo_hints(q: str) -> Dict[str, Any]:\n    \"\"\"Extract light filters from the query: language, under, symbol, ext, path_glob, not_glob.\"\"\"\n    s = q.strip()\n    low = s.lower()\n    out: Dict[str, Any] = {}\n    \n    # language\n    for lang in sorted(LANGS, key=len, reverse=True):\n        if re.search(rf\"\\b{re.escape(lang)}\\b\", low):\n            out[\"language\"] = {\"javascript\": \"js\", \"typescript\": \"ts\", \"c++\": \"cpp\", \"c#\": \"csharp\"}.get(lang, lang)\n            break\n    \n    # under / in folder\n    m_under = re.search(r\"\\bunder\\s+([\\w./-]+)\", low)\n    m_in = re.search(r\"\\b(?:in|inside)\\s+([\\w./-]+)\", low)\n    m = m_under or m_in\n    if m:\n        cand = m.group(1)\n        if len(cand) >= 2 and cand not in LANGS:\n            out[\"under\"] = cand\n    \n    # symbol-like tokens\n    m2 = re.search(r\"([A-Za-z_][A-Za-z0-9_]*\\s*\\(\\))|([A-Za-z_][\\w]*\\.[A-Za-z_][\\w]*)|([A-Za-z_][\\w]*::[A-Za-z_][\\w]*)\", s)\n    if m2:\n        sym = m2.group(0)\n        sym = re.sub(r\"\\s*\\(\\)\\s*$\", \"\", sym)\n        out[\"symbol\"] = sym\n    \n    # file extension\n    m3 = re.search(r\"\\.(py|ts|tsx|js|jsx|go|java|rs|kt|rb|php|scala|swift)$\", s)\n    if m3:\n        out[\"ext\"] = m3.group(1)\n    \n    # glob inclusions\n    globs: List[str] = []\n    if re.search(r\"\\bonly\\b\", low):\n        m_glob = re.search(r\"\\*\\.[A-Za-z0-9]+\", s)\n        if m_glob:\n            globs.append(\"**/\" + m_glob.group(0))\n        if \"python\" in low and \"*.py\" not in \" \".join(globs):\n            globs.append(\"**/*.py\")\n    if globs:\n        out[\"path_glob\"] = globs\n    \n    # exclusions\n    not_glob: List[str] = []\n    for ex in [\"vendor\", \"node_modules\", \"dist\", \"build\", \"tests\", \"__pycache__\"]:\n        if re.search(rf\"\\bexclude\\s+{re.escape(ex)}\\b\", low):\n            not_glob.append(f\"**/{ex}/**\")\n    if not_glob:\n        out[\"not_glob\"] = not_glob\n    \n    return out",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_clean_query_and_dsl_69": {
      "name": "clean_query_and_dsl",
      "type": "function",
      "start_line": 69,
      "end_line": 76,
      "content_hash": "a73e9b4ae095e26bca79368d64cb22b29bb39a51",
      "content": "def clean_query_and_dsl(q: str) -> Tuple[str, Dict[str, Any]]:\n    \"\"\"Strip DSL tokens from query and return (clean_query, dsl_filters).\"\"\"\n    try:\n        from scripts.hybrid_search import parse_query_dsl\n        clean, extracted = parse_query_dsl([q])\n        return (clean[0] if clean else \"\"), (extracted or {})\n    except Exception:\n        return q, {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__signature_text_79": {
      "name": "_signature_text",
      "type": "function",
      "start_line": 79,
      "end_line": 91,
      "content_hash": "7bdadc2b32910af5cb31fbf8c7fa10d54ebd60f4",
      "content": "def _signature_text(t: dict) -> str:\n    \"\"\"Build signature text for tool similarity matching.\"\"\"\n    name = (t.get(\"name\") or \"\").strip()\n    desc = (t.get(\"description\") or \"\").strip()\n    params = []\n    try:\n        schema = t.get(\"inputSchema\") or {}\n        props = (schema.get(\"properties\") or {}) if isinstance(schema, dict) else {}\n        params = [k for k in props.keys()]\n    except Exception:\n        params = []\n    ptxt = (\" params:\" + \",\".join(params)) if params else \"\"\n    return (name + \"\\n\" + desc + ptxt).strip()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_select_best_search_tool_by_signature_94": {
      "name": "select_best_search_tool_by_signature",
      "type": "function",
      "start_line": 94,
      "end_line": 137,
      "content_hash": "4efe45c8192bda2c10fe1d52c558f320bfb56648",
      "content": "def select_best_search_tool_by_signature(q: str, tool_dict: dict[str, str], allow_network: bool = True) -> str | None:\n    \"\"\"Select best matching search tool based on signature similarity.\"\"\"\n    candidates = [n for n in tool_dict.keys() if n == \"repo_search\" or n.startswith(\"search_\")]\n    if not candidates:\n        return None\n    \n    per_server: dict[str, list[dict]] = {}\n    for base in set(tool_dict[t] for t in candidates):\n        try:\n            per_server[base] = tools_describe_cached(base, allow_network=allow_network)\n        except Exception:\n            per_server[base] = []\n    \n    sig_map: dict[str, str] = {}\n    for tname in candidates:\n        base = tool_dict.get(tname)\n        descs = per_server.get(base, [])\n        obj = None\n        for td in descs:\n            if (td.get(\"name\") or \"\").strip() == tname:\n                obj = td\n                break\n        sig_map[tname] = _signature_text(obj or {\"name\": tname, \"description\": \"\"})\n    \n    texts = [q] + [sig_map[n] for n in candidates]\n    vecs = _embed_texts(texts)\n    if not vecs or len(vecs) < 1 + len(candidates):\n        return None\n    \n    qv = vecs[0]\n    scores: list[tuple[str, float]] = []\n    for i, name in enumerate(candidates):\n        sv = vecs[1 + i]\n        scores.append((name, _cosine(qv, sv)))\n    scores.sort(key=lambda x: x[1], reverse=True)\n    \n    best, best_s = scores[0]\n    repo_s = next((s for n, s in scores if n == \"repo_search\"), None)\n    margin = 0.02\n    if best == \"repo_search\" or repo_s is None:\n        return best\n    if best != \"repo_search\" and best_s >= (repo_s + margin):\n        return best\n    return \"repo_search\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}