{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/FormattingService.ts",
  "file_hash": "bf52709ca502477b2cdabb3c821637ae421196d6",
  "updated_at": "2025-12-26T17:34:24.076147",
  "symbols": {
    "class_FormattingService_12": {
      "name": "FormattingService",
      "type": "class",
      "start_line": 12,
      "end_line": 170,
      "content_hash": "0a00b690fb7ca99ffd28e4a9bb76cc4937663e93",
      "content": "export class FormattingService {\n  /**\n   * Format search tips footer\n   */\n  formatSearchTips(): string {\n    return `\\n---\n\ud83d\udca1 Search Strategy:\n1. Search with index to see titles, dates, IDs\n2. Use timeline to get context around interesting results\n3. Batch fetch full details: get_observations(ids=[...])\n\nTips:\n\u2022 Filter by type: obs_type=\"bugfix,feature\"\n\u2022 Filter by date: dateStart=\"2025-01-01\"\n\u2022 Sort: orderBy=\"date_desc\" or \"date_asc\"`;\n  }\n\n  /**\n   * Format time from epoch (matches context-generator formatTime)\n   */\n  private formatTime(epoch: number): string {\n    return new Date(epoch).toLocaleString('en-US', {\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: true\n    });\n  }\n\n  /**\n   * Estimate read tokens for an observation\n   */\n  private estimateReadTokens(obs: ObservationSearchResult): number {\n    const size = (obs.title?.length || 0) +\n                 (obs.subtitle?.length || 0) +\n                 (obs.narrative?.length || 0) +\n                 (obs.facts?.length || 0);\n    return Math.ceil(size / CHARS_PER_TOKEN_ESTIMATE);\n  }\n\n  /**\n   * Format observation as table row\n   * | ID | Time | T | Title | Read | Work |\n   */\n  formatObservationIndex(obs: ObservationSearchResult, _index: number): string {\n    const id = `#${obs.id}`;\n    const time = this.formatTime(obs.created_at_epoch);\n    const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n    const title = obs.title || 'Untitled';\n    const readTokens = this.estimateReadTokens(obs);\n    const workEmoji = ModeManager.getInstance().getWorkEmoji(obs.type);\n    const workTokens = obs.discovery_tokens || 0;\n    const workDisplay = workTokens > 0 ? `${workEmoji} ${workTokens}` : '-';\n\n    return `| ${id} | ${time} | ${icon} | ${title} | ~${readTokens} | ${workDisplay} |`;\n  }\n\n  /**\n   * Format session summary as table row\n   * | ID | Time | T | Title | - | - |\n   */\n  formatSessionIndex(session: SessionSummarySearchResult, _index: number): string {\n    const id = `#S${session.id}`;\n    const time = this.formatTime(session.created_at_epoch);\n    const icon = '\ud83c\udfaf';\n    const title = session.request || `Session ${session.sdk_session_id?.substring(0, 8) || 'unknown'}`;\n\n    return `| ${id} | ${time} | ${icon} | ${title} | - | - |`;\n  }\n\n  /**\n   * Format user prompt as table row\n   * | ID | Time | T | Title | - | - |\n   */\n  formatUserPromptIndex(prompt: UserPromptSearchResult, _index: number): string {\n    const id = `#P${prompt.id}`;\n    const time = this.formatTime(prompt.created_at_epoch);\n    const icon = '\ud83d\udcac';\n    // Truncate long prompts for table display\n    const title = prompt.prompt_text.length > 60\n      ? prompt.prompt_text.substring(0, 57) + '...'\n      : prompt.prompt_text;\n\n    return `| ${id} | ${time} | ${icon} | ${title} | - | - |`;\n  }\n\n  /**\n   * Generate table header for observations\n   */\n  formatTableHeader(): string {\n    return `| ID | Time | T | Title | Read | Work |\n|-----|------|---|-------|------|------|`;\n  }\n\n  /**\n   * Generate table header for search results (no Work column)\n   */\n  formatSearchTableHeader(): string {\n    return `| ID | Time | T | Title | Read |\n|----|------|---|-------|------|`;\n  }\n\n  /**\n   * Format observation as table row for search results (no Work column)\n   */\n  formatObservationSearchRow(obs: ObservationSearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#${obs.id}`;\n    const time = this.formatTime(obs.created_at_epoch);\n    const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n    const title = obs.title || 'Untitled';\n    const readTokens = this.estimateReadTokens(obs);\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | ~${readTokens} |`,\n      time\n    };\n  }\n\n  /**\n   * Format session summary as table row for search results (no Work column)\n   */\n  formatSessionSearchRow(session: SessionSummarySearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#S${session.id}`;\n    const time = this.formatTime(session.created_at_epoch);\n    const icon = '\ud83c\udfaf';\n    const title = session.request || `Session ${session.sdk_session_id?.substring(0, 8) || 'unknown'}`;\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | - |`,\n      time\n    };\n  }\n\n  /**\n   * Format user prompt as table row for search results (no Work column)\n   */\n  formatUserPromptSearchRow(prompt: UserPromptSearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#P${prompt.id}`;\n    const time = this.formatTime(prompt.created_at_epoch);\n    const icon = '\ud83d\udcac';\n    // Truncate long prompts for table display\n    const title = prompt.prompt_text.length > 60\n      ? prompt.prompt_text.substring(0, 57) + '...'\n      : prompt.prompt_text;\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | - |`,\n      time\n    };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatSearchTips_16": {
      "name": "formatSearchTips",
      "type": "method",
      "start_line": 16,
      "end_line": 27,
      "content_hash": "5a82798a3347682f5b791c230cd77ff2a8d36339",
      "content": "  formatSearchTips(): string {\n    return `\\n---\n\ud83d\udca1 Search Strategy:\n1. Search with index to see titles, dates, IDs\n2. Use timeline to get context around interesting results\n3. Batch fetch full details: get_observations(ids=[...])\n\nTips:\n\u2022 Filter by type: obs_type=\"bugfix,feature\"\n\u2022 Filter by date: dateStart=\"2025-01-01\"\n\u2022 Sort: orderBy=\"date_desc\" or \"date_asc\"`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatTime_32": {
      "name": "formatTime",
      "type": "method",
      "start_line": 32,
      "end_line": 38,
      "content_hash": "9ec495a4cdae278640ff1e550c33957574962436",
      "content": "  private formatTime(epoch: number): string {\n    return new Date(epoch).toLocaleString('en-US', {\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: true\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_estimateReadTokens_43": {
      "name": "estimateReadTokens",
      "type": "method",
      "start_line": 43,
      "end_line": 49,
      "content_hash": "e7f43dfe71d8f7bc7fe76def914ef664bcfa18b3",
      "content": "  private estimateReadTokens(obs: ObservationSearchResult): number {\n    const size = (obs.title?.length || 0) +\n                 (obs.subtitle?.length || 0) +\n                 (obs.narrative?.length || 0) +\n                 (obs.facts?.length || 0);\n    return Math.ceil(size / CHARS_PER_TOKEN_ESTIMATE);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatObservationIndex_55": {
      "name": "formatObservationIndex",
      "type": "method",
      "start_line": 55,
      "end_line": 66,
      "content_hash": "bb62b1971420a3a9b971ec16b5db05dd22605590",
      "content": "  formatObservationIndex(obs: ObservationSearchResult, _index: number): string {\n    const id = `#${obs.id}`;\n    const time = this.formatTime(obs.created_at_epoch);\n    const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n    const title = obs.title || 'Untitled';\n    const readTokens = this.estimateReadTokens(obs);\n    const workEmoji = ModeManager.getInstance().getWorkEmoji(obs.type);\n    const workTokens = obs.discovery_tokens || 0;\n    const workDisplay = workTokens > 0 ? `${workEmoji} ${workTokens}` : '-';\n\n    return `| ${id} | ${time} | ${icon} | ${title} | ~${readTokens} | ${workDisplay} |`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatSessionIndex_72": {
      "name": "formatSessionIndex",
      "type": "method",
      "start_line": 72,
      "end_line": 79,
      "content_hash": "206a7da0e5a0d97a449e46a124961bdd07ed4964",
      "content": "  formatSessionIndex(session: SessionSummarySearchResult, _index: number): string {\n    const id = `#S${session.id}`;\n    const time = this.formatTime(session.created_at_epoch);\n    const icon = '\ud83c\udfaf';\n    const title = session.request || `Session ${session.sdk_session_id?.substring(0, 8) || 'unknown'}`;\n\n    return `| ${id} | ${time} | ${icon} | ${title} | - | - |`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatUserPromptIndex_85": {
      "name": "formatUserPromptIndex",
      "type": "method",
      "start_line": 85,
      "end_line": 95,
      "content_hash": "11e8a605f8416d1ea25635cd9404ef67ed36af14",
      "content": "  formatUserPromptIndex(prompt: UserPromptSearchResult, _index: number): string {\n    const id = `#P${prompt.id}`;\n    const time = this.formatTime(prompt.created_at_epoch);\n    const icon = '\ud83d\udcac';\n    // Truncate long prompts for table display\n    const title = prompt.prompt_text.length > 60\n      ? prompt.prompt_text.substring(0, 57) + '...'\n      : prompt.prompt_text;\n\n    return `| ${id} | ${time} | ${icon} | ${title} | - | - |`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatTableHeader_100": {
      "name": "formatTableHeader",
      "type": "method",
      "start_line": 100,
      "end_line": 103,
      "content_hash": "9f195dd7a556638f797fd95a4dd01d2913c31f5f",
      "content": "  formatTableHeader(): string {\n    return `| ID | Time | T | Title | Read | Work |\n|-----|------|---|-------|------|------|`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatSearchTableHeader_108": {
      "name": "formatSearchTableHeader",
      "type": "method",
      "start_line": 108,
      "end_line": 111,
      "content_hash": "08017c064ea502883fda355c2585dbaf4b1aa56e",
      "content": "  formatSearchTableHeader(): string {\n    return `| ID | Time | T | Title | Read |\n|----|------|---|-------|------|`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatObservationSearchRow_116": {
      "name": "formatObservationSearchRow",
      "type": "method",
      "start_line": 116,
      "end_line": 130,
      "content_hash": "501f0de6de35590598e94f87b4575b0501a5e3ec",
      "content": "  formatObservationSearchRow(obs: ObservationSearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#${obs.id}`;\n    const time = this.formatTime(obs.created_at_epoch);\n    const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n    const title = obs.title || 'Untitled';\n    const readTokens = this.estimateReadTokens(obs);\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | ~${readTokens} |`,\n      time\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatSessionSearchRow_135": {
      "name": "formatSessionSearchRow",
      "type": "method",
      "start_line": 135,
      "end_line": 148,
      "content_hash": "ecedde65d6709a6950d3d2bcf758434a16dc70ad",
      "content": "  formatSessionSearchRow(session: SessionSummarySearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#S${session.id}`;\n    const time = this.formatTime(session.created_at_epoch);\n    const icon = '\ud83c\udfaf';\n    const title = session.request || `Session ${session.sdk_session_id?.substring(0, 8) || 'unknown'}`;\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | - |`,\n      time\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatUserPromptSearchRow_153": {
      "name": "formatUserPromptSearchRow",
      "type": "method",
      "start_line": 153,
      "end_line": 169,
      "content_hash": "1e0c4e0baad29b0f202453d05b03673f34227e40",
      "content": "  formatUserPromptSearchRow(prompt: UserPromptSearchResult, lastTime: string): { row: string; time: string } {\n    const id = `#P${prompt.id}`;\n    const time = this.formatTime(prompt.created_at_epoch);\n    const icon = '\ud83d\udcac';\n    // Truncate long prompts for table display\n    const title = prompt.prompt_text.length > 60\n      ? prompt.prompt_text.substring(0, 57) + '...'\n      : prompt.prompt_text;\n\n    // Use ditto mark if same time as previous row\n    const timeDisplay = time === lastTime ? '\u2033' : time;\n\n    return {\n      row: `| ${id} | ${timeDisplay} | ${icon} | ${title} | - |`,\n      time\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}