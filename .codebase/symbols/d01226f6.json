{
  "file_path": "/work/internal/agent/tools/self_heal.go",
  "file_hash": "60c4d4feca4481c137648985f31874a60cc19709",
  "updated_at": "2025-12-26T17:34:24.012141",
  "symbols": {
    "struct_EditRetryStrategy_17": {
      "name": "EditRetryStrategy",
      "type": "struct",
      "start_line": 17,
      "end_line": 23,
      "content_hash": "232f72ec9954d597bee3614f52e8c65e4d5c50ef",
      "content": "type EditRetryStrategy struct {\n\tctx    context.Context\n\tviewFn func(ctx context.Context, filePath string, offset, limit int) (string, error)\n\tgrepFn func(ctx context.Context, pattern string, workingDir string) ([]string, error)\n}\n\n// NewEditRetryStrategy creates a new retry strategy for failed edits.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewEditRetryStrategy_24": {
      "name": "NewEditRetryStrategy",
      "type": "function",
      "start_line": 24,
      "end_line": 38,
      "content_hash": "03b39a06b0ed552c8f2e5f84895ba4a4679aa209",
      "content": "func NewEditRetryStrategy(ctx context.Context) *EditRetryStrategy {\n\treturn &EditRetryStrategy{\n\t\tctx: ctx,\n\t\tviewFn: func(ctx context.Context, filePath string, offset, limit int) (string, error) {\n\t\t\tcontent, err := os.ReadFile(filePath)\n\t\t\treturn string(content), err\n\t\t},\n\t\tgrepFn: func(ctx context.Context, pattern string, workingDir string) ([]string, error) {\n\t\t\treturn []string{}, nil // Placeholder for grep integration\n\t\t},\n\t}\n}\n\n// RetryWithContext attempts to fix a failed edit by extracting context from the file.\n// This is called when \"old_string not found\" error occurs.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RetryWithContext_39": {
      "name": "RetryWithContext",
      "type": "method",
      "start_line": 39,
      "end_line": 89,
      "content_hash": "210ef83af637b564070451b3657f663c925c1f43",
      "content": "func (s *EditRetryStrategy) RetryWithContext(\n\tfilePath string,\n\toldString string,\n\tnewString string,\n\tfailureReason string,\n) (EditParams, error) {\n\t// Read the file to find the target pattern\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn EditParams{}, fmt.Errorf(\"failed to read file for retry: %w\", err)\n\t}\n\n\tfileContent := string(content)\n\n\t// Try to find a similar pattern by removing extra whitespace\n\tnormalized := normalizeWhitespace(oldString)\n\tif idx := findSimilarPattern(fileContent, normalized); idx >= 0 {\n\t\t// Extract context around the match (7 lines of context as per guidelines)\n\t\tlines := strings.Split(fileContent, \"\\n\")\n\t\tmatchLine := countNewlines(fileContent[:idx])\n\t\tstartLine := max(0, matchLine-3)\n\t\tendLine := min(len(lines), matchLine+4)\n\n\t\t// Build the new old_string with proper context\n\t\tcontextLines := lines[startLine:endLine]\n\t\timprovedOldString := strings.Join(contextLines, \"\\n\")\n\n\t\tslog.Debug(\"self-healing edit\",\n\t\t\t\"file\", filePath,\n\t\t\t\"original_length\", len(oldString),\n\t\t\t\"improved_length\", len(improvedOldString),\n\t\t\t\"context_lines\", len(contextLines),\n\t\t)\n\n\t\treturn EditParams{\n\t\t\tFilePath:   filePath,\n\t\t\tOldString:  improvedOldString,\n\t\t\tNewString:  newString,\n\t\t\tReplaceAll: false,\n\t\t}, nil\n\t}\n\n\t// Try advanced context extraction\n\tif improvedParams := s.extractContextFromPattern(fileContent, oldString, newString); improvedParams.OldString != \"\" {\n\t\treturn improvedParams, nil\n\t}\n\n\treturn EditParams{}, fmt.Errorf(\"could not recover from edit failure: %s\", failureReason)\n}\n\n// extractContextFromPattern uses advanced pattern matching to extract better context",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractContextFromPattern_90": {
      "name": "extractContextFromPattern",
      "type": "method",
      "start_line": 90,
      "end_line": 131,
      "content_hash": "002ea7f18bf3d6b14da650905813bc5cb3e0c8e9",
      "content": "func (s *EditRetryStrategy) extractContextFromPattern(fileContent, oldString, newString string) EditParams {\n\tlines := strings.Split(fileContent, \"\\n\")\n\n\t// Look for each line of the old_string in the file\n\toldLines := strings.Split(oldString, \"\\n\")\n\n\tfor lineIdx := 0; lineIdx < len(lines); lineIdx++ {\n\t\t// Try to find the start of a matching sequence\n\t\tif strings.Contains(lines[lineIdx], oldLines[0]) {\n\t\t\t// Check if this could be the start of our target sequence\n\t\t\tremainingLines := len(lines) - lineIdx\n\t\t\tif remainingLines >= len(oldLines) {\n\t\t\t\t// Extract a 7-line block around this potential match\n\t\t\t\tstartIdx := max(0, lineIdx-3)\n\t\t\t\tendIdx := min(len(lines), lineIdx+4)\n\n\t\t\t\tcontextBlock := lines[startIdx:endIdx]\n\t\t\t\tcontextString := strings.Join(contextBlock, \"\\n\")\n\n\t\t\t\t// Check if the old_string pattern appears in this context block\n\t\t\t\tif strings.Contains(contextString, oldString) {\n\t\t\t\t\tslog.Debug(\"extracted context block\",\n\t\t\t\t\t\t\"start_line\", startIdx,\n\t\t\t\t\t\t\"end_line\", endIdx,\n\t\t\t\t\t\t\"block_length\", len(contextBlock),\n\t\t\t\t\t)\n\n\t\t\t\t\treturn EditParams{\n\t\t\t\t\t\tFilePath:   \"\", // Will be filled by caller\n\t\t\t\t\t\tOldString:  contextString,\n\t\t\t\t\t\tNewString:  newString,\n\t\t\t\t\t\tReplaceAll: false,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EditParams{} // Return empty if no context found\n}\n\n// normalizeWhitespace removes leading/trailing whitespace and collapses multiple spaces.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeWhitespace_132": {
      "name": "normalizeWhitespace",
      "type": "function",
      "start_line": 132,
      "end_line": 144,
      "content_hash": "46763662b694f71ae58e1726ae751414ec7fa7b5",
      "content": "func normalizeWhitespace(s string) string {\n\t// Replace tabs with spaces for comparison\n\ts = strings.ReplaceAll(s, \"\\t\", \"    \")\n\t// Collapse multiple spaces in each line\n\tlines := strings.Split(s, \"\\n\")\n\tfor i, line := range lines {\n\t\tlines[i] = strings.TrimSpace(line)\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}\n\n// findSimilarPattern searches for a pattern that matches the normalized version.\n// Returns the index in the file where the pattern was found, or -1 if not found.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findSimilarPattern_145": {
      "name": "findSimilarPattern",
      "type": "function",
      "start_line": 145,
      "end_line": 167,
      "content_hash": "2ffbb3cf1e0a57d2bf0a57d189015e3e76c3b046",
      "content": "func findSimilarPattern(fileContent string, normalizedPattern string) int {\n\t// Try exact match first\n\tif idx := strings.Index(fileContent, normalizedPattern); idx >= 0 {\n\t\treturn idx\n\t}\n\n\t// Try matching with normalized content\n\tnormalized := normalizeWhitespace(fileContent)\n\tif idx := strings.Index(normalized, normalizedPattern); idx >= 0 {\n\t\treturn idx\n\t}\n\n\t// Try matching individual lines\n\tlines := strings.Split(normalizedPattern, \"\\n\")\n\tif len(lines) == 1 {\n\t\t// Single line search - try various whitespace variations\n\t\treturn findLineVariation(fileContent, lines[0])\n\t}\n\n\treturn -1\n}\n\n// findLineVariation tries to find a line accounting for different whitespace.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findLineVariation_168": {
      "name": "findLineVariation",
      "type": "function",
      "start_line": 168,
      "end_line": 185,
      "content_hash": "c845c4f32086510332844e0d298dae09c58de45b",
      "content": "func findLineVariation(content string, targetLine string) int {\n\tlines := strings.Split(content, \"\\n\")\n\tnormTarget := strings.TrimSpace(targetLine)\n\n\tfor i, line := range lines {\n\t\tif strings.TrimSpace(line) == normTarget {\n\t\t\t// Calculate the byte offset for this line\n\t\t\toffset := 0\n\t\t\tfor j := range i {\n\t\t\t\toffset += len(lines[j]) + 1 // +1 for newline\n\t\t\t}\n\t\t\treturn offset\n\t\t}\n\t}\n\treturn -1\n}\n\n// countNewlines returns the number of newlines before the given byte position.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_countNewlines_186": {
      "name": "countNewlines",
      "type": "function",
      "start_line": 186,
      "end_line": 191,
      "content_hash": "d56d48d59eedc33e263026a1a997ebff22e1b506",
      "content": "func countNewlines(s string) int {\n\treturn strings.Count(s, \"\\n\")\n}\n\n// ExtractContextLines extracts N lines around a target line for better edit matching.\n// This helps create unique old_string matches by including surrounding context.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ExtractContextLines_192": {
      "name": "ExtractContextLines",
      "type": "function",
      "start_line": 192,
      "end_line": 225,
      "content_hash": "101c45f43fa62ae424ca274749ef78b29f587f8f",
      "content": "func ExtractContextLines(\n\tfilePath string,\n\ttargetLine string,\n\tcontextLinesCount int,\n) (string, error) {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlines := strings.Split(string(content), \"\\n\")\n\n\t// Find the target line\n\tvar targetIdx int = -1\n\tfor i, line := range lines {\n\t\tif strings.Contains(line, strings.TrimSpace(targetLine)) {\n\t\t\ttargetIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif targetIdx < 0 {\n\t\treturn \"\", fmt.Errorf(\"target line not found in file\")\n\t}\n\n\t// Extract context\n\tstartIdx := max(0, targetIdx-contextLinesCount)\n\tendIdx := min(len(lines), targetIdx+contextLinesCount+1)\n\n\tcontextLines := lines[startIdx:endIdx]\n\treturn strings.Join(contextLines, \"\\n\"), nil\n}\n\n// max returns the larger of two integers.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_max_226": {
      "name": "max",
      "type": "function",
      "start_line": 226,
      "end_line": 233,
      "content_hash": "13231e5e54bc268ebb2a84bca2f896644c4cdf3b",
      "content": "func max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// min returns the smaller of two integers.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_min_234": {
      "name": "min",
      "type": "function",
      "start_line": 234,
      "end_line": 242,
      "content_hash": "b97debfa2e267dc8bcd6ca95cd82f97d8f60c5d0",
      "content": "func min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// ValidateEditPattern checks if an old_string is unique in the file.\n// Returns true if the pattern appears exactly once, false otherwise.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ValidateEditPattern_243": {
      "name": "ValidateEditPattern",
      "type": "function",
      "start_line": 243,
      "end_line": 263,
      "content_hash": "e9e3b6449b3f3d243a2c91dee1976dc27de51e1b",
      "content": "func ValidateEditPattern(filePath string, oldString string) (bool, error) {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfileContent := string(content)\n\tmatches := strings.Count(fileContent, oldString)\n\n\tif matches == 0 {\n\t\treturn false, fmt.Errorf(\"pattern not found in file\")\n\t}\n\tif matches > 1 {\n\t\treturn false, fmt.Errorf(\"pattern appears %d times (must be unique)\", matches)\n\t}\n\n\treturn true, nil\n}\n\n// FindBestMatch searches for the best matching context around a target line.\n// This is useful when the exact old_string fails to match.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_FindBestMatch_264": {
      "name": "FindBestMatch",
      "type": "function",
      "start_line": 264,
      "end_line": 298,
      "content_hash": "85b20b969ef6f8d21d615f432c83bd7baab1103d",
      "content": "func FindBestMatch(\n\tfilePath string,\n\ttargetContent string,\n\tcontextSize int,\n) (string, error) {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlines := strings.Split(string(content), \"\\n\")\n\n\t// Find best matching line using regex\n\tpattern := regexp.MustCompile(regexp.QuoteMeta(strings.TrimSpace(targetContent)))\n\tvar bestIdx int = -1\n\n\tfor i, line := range lines {\n\t\tif pattern.MatchString(line) {\n\t\t\tbestIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif bestIdx < 0 {\n\t\treturn \"\", fmt.Errorf(\"no matching line found\")\n\t}\n\n\t// Extract context around the match\n\tstart := max(0, bestIdx-contextSize)\n\tend := min(len(lines), bestIdx+contextSize+1)\n\n\treturn strings.Join(lines[start:end], \"\\n\"), nil\n}\n\n// tryNormalizedMatch attempts to find oldString in content after normalizing whitespace",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_tryNormalizedMatch_299": {
      "name": "tryNormalizedMatch",
      "type": "function",
      "start_line": 299,
      "end_line": 305,
      "content_hash": "77477074bfadd7cc00cce861fbae1800f5f559ca",
      "content": "func tryNormalizedMatch(content, oldString string) (string, bool) {\n\tnormalized := normalizeWhitespace(oldString)\n\tif strings.Contains(content, normalized) {\n\t\treturn normalized, true\n\t}\n\treturn \"\", false\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}