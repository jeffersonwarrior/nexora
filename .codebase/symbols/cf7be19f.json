{
  "file_path": "/work/external-deps/Context-Engine/tests/test_toon_encoder.py",
  "file_hash": "8f6eb8827938ae355a6f90493848cc155aff559d",
  "updated_at": "2025-12-26T17:34:21.621044",
  "symbols": {
    "class_TestFeatureFlags_25": {
      "name": "TestFeatureFlags",
      "type": "class",
      "start_line": 25,
      "end_line": 37,
      "content_hash": "12a6a8a60a9e5d60b110a848515752f5b520d08e",
      "content": "class TestFeatureFlags:\n    \"\"\"Test feature flag behavior.\"\"\"\n\n    def test_toon_disabled_by_default(self, monkeypatch):\n        monkeypatch.delenv(\"TOON_ENABLED\", raising=False)\n        assert is_toon_enabled() is False\n\n    def test_toon_enabled_when_set(self, monkeypatch):\n        monkeypatch.setenv(\"TOON_ENABLED\", \"1\")\n        assert is_toon_enabled() is True\n        \n        monkeypatch.setenv(\"TOON_ENABLED\", \"true\")\n        assert is_toon_enabled() is True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_toon_disabled_by_default_28": {
      "name": "test_toon_disabled_by_default",
      "type": "method",
      "start_line": 28,
      "end_line": 30,
      "content_hash": "b9fd82d91e873821d85551c2c38f589e39b3a9c0",
      "content": "    def test_toon_disabled_by_default(self, monkeypatch):\n        monkeypatch.delenv(\"TOON_ENABLED\", raising=False)\n        assert is_toon_enabled() is False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_toon_enabled_when_set_32": {
      "name": "test_toon_enabled_when_set",
      "type": "method",
      "start_line": 32,
      "end_line": 37,
      "content_hash": "f4fef56057c0fc01d18465cd01fe76fb0f51ea3d",
      "content": "    def test_toon_enabled_when_set(self, monkeypatch):\n        monkeypatch.setenv(\"TOON_ENABLED\", \"1\")\n        assert is_toon_enabled() is True\n        \n        monkeypatch.setenv(\"TOON_ENABLED\", \"true\")\n        assert is_toon_enabled() is True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestValueEncoding_40": {
      "name": "TestValueEncoding",
      "type": "class",
      "start_line": 40,
      "end_line": 63,
      "content_hash": "de35eb12a8d13896f7beb14032bdda31dbd25ec3",
      "content": "class TestValueEncoding:\n    \"\"\"Test individual value encoding per TOON spec.\"\"\"\n\n    def test_encode_primitives(self):\n        # Per spec \u00a72: null is encoded as literal \"null\"\n        assert _encode_value(None, \",\") == \"null\"\n        assert _encode_value(True, \",\") == \"true\"\n        assert _encode_value(False, \",\") == \"false\"\n        assert _encode_value(42, \",\") == \"42\"\n        assert _encode_value(3.14, \",\") == \"3.14\"\n        assert _encode_value(\"hello\", \",\") == \"hello\"\n\n    def test_encode_string_with_delimiter(self):\n        # String containing delimiter should be quoted\n        assert _encode_value(\"hello,world\", \",\") == '\"hello,world\"'\n\n    def test_encode_string_with_newline(self):\n        # Per spec \u00a77.1: newlines escaped as \\n\n        assert _encode_value(\"line1\\nline2\", \",\") == '\"line1\\\\nline2\"'\n\n    def test_encode_nested_object(self):\n        # Nested objects become compact JSON\n        result = _encode_value({\"a\": 1}, \",\")\n        assert result == '{\"a\":1}'",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_primitives_43": {
      "name": "test_encode_primitives",
      "type": "method",
      "start_line": 43,
      "end_line": 50,
      "content_hash": "d00fca432007ea22b62e79f07eb0df4a14d5071d",
      "content": "    def test_encode_primitives(self):\n        # Per spec \u00a72: null is encoded as literal \"null\"\n        assert _encode_value(None, \",\") == \"null\"\n        assert _encode_value(True, \",\") == \"true\"\n        assert _encode_value(False, \",\") == \"false\"\n        assert _encode_value(42, \",\") == \"42\"\n        assert _encode_value(3.14, \",\") == \"3.14\"\n        assert _encode_value(\"hello\", \",\") == \"hello\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_string_with_delimiter_52": {
      "name": "test_encode_string_with_delimiter",
      "type": "method",
      "start_line": 52,
      "end_line": 54,
      "content_hash": "422af3d4d5047ab7893f1b51c26b2e82208eb77b",
      "content": "    def test_encode_string_with_delimiter(self):\n        # String containing delimiter should be quoted\n        assert _encode_value(\"hello,world\", \",\") == '\"hello,world\"'",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_string_with_newline_56": {
      "name": "test_encode_string_with_newline",
      "type": "method",
      "start_line": 56,
      "end_line": 58,
      "content_hash": "5debadcc9a8ed969d591fed0fc3c1414383b15fe",
      "content": "    def test_encode_string_with_newline(self):\n        # Per spec \u00a77.1: newlines escaped as \\n\n        assert _encode_value(\"line1\\nline2\", \",\") == '\"line1\\\\nline2\"'",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_nested_object_60": {
      "name": "test_encode_nested_object",
      "type": "method",
      "start_line": 60,
      "end_line": 63,
      "content_hash": "5914803ebda1ea20861f5909dc27dda331e154c2",
      "content": "    def test_encode_nested_object(self):\n        # Nested objects become compact JSON\n        result = _encode_value({\"a\": 1}, \",\")\n        assert result == '{\"a\":1}'",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestArrayDetection_66": {
      "name": "TestArrayDetection",
      "type": "class",
      "start_line": 66,
      "end_line": 81,
      "content_hash": "6d92ef864337d3b016419b2d8a8cb54de66ddaa1",
      "content": "class TestArrayDetection:\n    \"\"\"Test uniform array detection.\"\"\"\n\n    def test_uniform_array(self):\n        arr = [{\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4}]\n        assert _is_uniform_array_of_objects(arr) is True\n\n    def test_non_uniform_array(self):\n        arr = [{\"a\": 1}, {\"b\": 2}]  # Different keys\n        assert _is_uniform_array_of_objects(arr) is False\n\n    def test_empty_array(self):\n        assert _is_uniform_array_of_objects([]) is False\n\n    def test_primitive_array(self):\n        assert _is_uniform_array_of_objects([1, 2, 3]) is False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uniform_array_69": {
      "name": "test_uniform_array",
      "type": "method",
      "start_line": 69,
      "end_line": 71,
      "content_hash": "757b2dc830fee85e2a8ea880824a419ad7861971",
      "content": "    def test_uniform_array(self):\n        arr = [{\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4}]\n        assert _is_uniform_array_of_objects(arr) is True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_non_uniform_array_73": {
      "name": "test_non_uniform_array",
      "type": "method",
      "start_line": 73,
      "end_line": 75,
      "content_hash": "466143db5be9b68b0d16bf3bef3d5522549a776f",
      "content": "    def test_non_uniform_array(self):\n        arr = [{\"a\": 1}, {\"b\": 2}]  # Different keys\n        assert _is_uniform_array_of_objects(arr) is False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_empty_array_77": {
      "name": "test_empty_array",
      "type": "method",
      "start_line": 77,
      "end_line": 78,
      "content_hash": "5ed17708f2243ca0ac7b81e267c8800092fa7548",
      "content": "    def test_empty_array(self):\n        assert _is_uniform_array_of_objects([]) is False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_primitive_array_80": {
      "name": "test_primitive_array",
      "type": "method",
      "start_line": 80,
      "end_line": 81,
      "content_hash": "653f38bca1bb2e680eb689facb1149230fccff5c",
      "content": "    def test_primitive_array(self):\n        assert _is_uniform_array_of_objects([1, 2, 3]) is False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestTabularEncoding_84": {
      "name": "TestTabularEncoding",
      "type": "class",
      "start_line": 84,
      "end_line": 116,
      "content_hash": "c7316f5539d3d10f58df667e977d2b29c2872b1d",
      "content": "class TestTabularEncoding:\n    \"\"\"Test tabular array encoding.\"\"\"\n\n    def test_encode_tabular_basic(self):\n        arr = [\n            {\"id\": 1, \"name\": \"Alice\"},\n            {\"id\": 2, \"name\": \"Bob\"},\n        ]\n        lines = encode_tabular(\"users\", arr)\n        # python-toon uses [N,] format for comma delimiter\n        assert lines[0] == \"users[2,]{id,name}:\"\n        assert lines[1] == \"  1,Alice\"\n        assert lines[2] == \"  2,Bob\"\n\n    def test_encode_tabular_no_length(self):\n        # Note: python-toon always includes length markers\n        arr = [{\"x\": 1}]\n        lines = encode_tabular(\"items\", arr, include_length=False)\n        # Still includes length due to python-toon behavior\n        assert \"items\" in lines[0]\n        assert \"x\" in lines[0]\n\n    def test_encode_tabular_tab_delimiter(self):\n        # Per spec \u00a76: tab delimiter appears inside brackets [N<TAB>] and braces\n        arr = [{\"a\": 1, \"b\": 2}]\n        lines = encode_tabular(\"data\", arr, delimiter=\"\\t\")\n        assert lines[0] == \"data[1\\t]{a\\tb}:\"\n        assert lines[1] == \"  1\\t2\"\n\n    def test_encode_empty_array(self):\n        # Per spec \u00a79.1: empty arrays are key[0]: (no values after colon)\n        lines = encode_tabular(\"empty\", [])\n        assert lines == [\"empty[0]:\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_tabular_basic_87": {
      "name": "test_encode_tabular_basic",
      "type": "method",
      "start_line": 87,
      "end_line": 96,
      "content_hash": "2ad9740d3a41087c403071edddade30d4f2a745d",
      "content": "    def test_encode_tabular_basic(self):\n        arr = [\n            {\"id\": 1, \"name\": \"Alice\"},\n            {\"id\": 2, \"name\": \"Bob\"},\n        ]\n        lines = encode_tabular(\"users\", arr)\n        # python-toon uses [N,] format for comma delimiter\n        assert lines[0] == \"users[2,]{id,name}:\"\n        assert lines[1] == \"  1,Alice\"\n        assert lines[2] == \"  2,Bob\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_tabular_no_length_98": {
      "name": "test_encode_tabular_no_length",
      "type": "method",
      "start_line": 98,
      "end_line": 104,
      "content_hash": "2d76a8fd8cf1e03a6464c156f32b3e9707b301e4",
      "content": "    def test_encode_tabular_no_length(self):\n        # Note: python-toon always includes length markers\n        arr = [{\"x\": 1}]\n        lines = encode_tabular(\"items\", arr, include_length=False)\n        # Still includes length due to python-toon behavior\n        assert \"items\" in lines[0]\n        assert \"x\" in lines[0]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_tabular_tab_delimiter_106": {
      "name": "test_encode_tabular_tab_delimiter",
      "type": "method",
      "start_line": 106,
      "end_line": 111,
      "content_hash": "f7945e75efd5c01dd44672ab62df5bd90476cb22",
      "content": "    def test_encode_tabular_tab_delimiter(self):\n        # Per spec \u00a76: tab delimiter appears inside brackets [N<TAB>] and braces\n        arr = [{\"a\": 1, \"b\": 2}]\n        lines = encode_tabular(\"data\", arr, delimiter=\"\\t\")\n        assert lines[0] == \"data[1\\t]{a\\tb}:\"\n        assert lines[1] == \"  1\\t2\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_empty_array_113": {
      "name": "test_encode_empty_array",
      "type": "method",
      "start_line": 113,
      "end_line": 116,
      "content_hash": "2cb9ad3d44a9bb6ea1eaeb633827670d88956fb8",
      "content": "    def test_encode_empty_array(self):\n        # Per spec \u00a79.1: empty arrays are key[0]: (no values after colon)\n        lines = encode_tabular(\"empty\", [])\n        assert lines == [\"empty[0]:\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestSimpleArrayEncoding_119": {
      "name": "TestSimpleArrayEncoding",
      "type": "class",
      "start_line": 119,
      "end_line": 128,
      "content_hash": "c2c2ab65b04137ed36f736c2f65042a9be4ea788",
      "content": "class TestSimpleArrayEncoding:\n    \"\"\"Test simple array encoding.\"\"\"\n\n    def test_encode_simple_array(self):\n        lines = encode_simple_array(\"tags\", [\"python\", \"async\", \"api\"])\n        assert lines == [\"tags[3]: python,async,api\"]\n\n    def test_encode_numeric_array(self):\n        lines = encode_simple_array(\"nums\", [1, 2, 3])\n        assert lines == [\"nums[3]: 1,2,3\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_simple_array_122": {
      "name": "test_encode_simple_array",
      "type": "method",
      "start_line": 122,
      "end_line": 124,
      "content_hash": "f51754383b16376e2611948457ef251d2737a4f3",
      "content": "    def test_encode_simple_array(self):\n        lines = encode_simple_array(\"tags\", [\"python\", \"async\", \"api\"])\n        assert lines == [\"tags[3]: python,async,api\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_numeric_array_126": {
      "name": "test_encode_numeric_array",
      "type": "method",
      "start_line": 126,
      "end_line": 128,
      "content_hash": "69ae1c6134984ecaecba32e512318686a3901a46",
      "content": "    def test_encode_numeric_array(self):\n        lines = encode_simple_array(\"nums\", [1, 2, 3])\n        assert lines == [\"nums[3]: 1,2,3\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestFullEncoding_131": {
      "name": "TestFullEncoding",
      "type": "class",
      "start_line": 131,
      "end_line": 185,
      "content_hash": "0cf76dc310856cd58554eafe28b01c3f5e77b2f0",
      "content": "class TestFullEncoding:\n    \"\"\"Test full object encoding.\"\"\"\n\n    def test_encode_simple_object(self):\n        obj = {\"name\": \"Alice\", \"age\": 30, \"active\": True}\n        result = encode(obj)\n        assert \"name: Alice\" in result\n        assert \"age: 30\" in result\n        assert \"active: true\" in result\n\n    def test_encode_nested_object(self):\n        obj = {\n            \"user\": {\n                \"name\": \"Bob\",\n                \"role\": \"admin\",\n            }\n        }\n        result = encode(obj)\n        assert \"user:\" in result\n        assert \"  name: Bob\" in result\n\n    def test_encode_with_tabular_array(self):\n        obj = {\n            \"users\": [\n                {\"id\": 1, \"name\": \"Alice\"},\n                {\"id\": 2, \"name\": \"Bob\"},\n            ]\n        }\n        result = encode(obj)\n        # python-toon uses [N,] format for comma delimiter\n        assert \"users[2,]{id,name}:\" in result\n        assert \"  1,Alice\" in result\n        assert \"  2,Bob\" in result\n\n    def test_encode_mixed_structure(self):\n        \"\"\"Test the hikes example from TOON spec.\"\"\"\n        obj = {\n            \"context\": {\n                \"task\": \"Our favorite hikes together\",\n                \"location\": \"Boulder\",\n            },\n            \"friends\": [\"ana\", \"luis\", \"sam\"],\n            \"hikes\": [\n                {\"id\": 1, \"name\": \"Blue Lake Trail\", \"distanceKm\": 7.5},\n                {\"id\": 2, \"name\": \"Ridge Overlook\", \"distanceKm\": 9.2},\n            ]\n        }\n        result = encode(obj)\n        # Context nested\n        assert \"context:\" in result\n        assert \"  task: Our favorite hikes together\" in result\n        # Friends inline\n        assert \"friends[3]: ana,luis,sam\" in result\n        # Hikes tabular - python-toon uses [N,] format\n        assert \"hikes[2,]{id,name,distanceKm}:\" in result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_simple_object_134": {
      "name": "test_encode_simple_object",
      "type": "method",
      "start_line": 134,
      "end_line": 139,
      "content_hash": "4376e6d8b02b687eb6d6427007f33c7db533dc37",
      "content": "    def test_encode_simple_object(self):\n        obj = {\"name\": \"Alice\", \"age\": 30, \"active\": True}\n        result = encode(obj)\n        assert \"name: Alice\" in result\n        assert \"age: 30\" in result\n        assert \"active: true\" in result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_nested_object_141": {
      "name": "test_encode_nested_object",
      "type": "method",
      "start_line": 141,
      "end_line": 150,
      "content_hash": "18f735613063bb492409027bcb6e885a893e3835",
      "content": "    def test_encode_nested_object(self):\n        obj = {\n            \"user\": {\n                \"name\": \"Bob\",\n                \"role\": \"admin\",\n            }\n        }\n        result = encode(obj)\n        assert \"user:\" in result\n        assert \"  name: Bob\" in result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_with_tabular_array_152": {
      "name": "test_encode_with_tabular_array",
      "type": "method",
      "start_line": 152,
      "end_line": 163,
      "content_hash": "95b2c23b2caf7f1a5e2dd5258e80da2f44b11b10",
      "content": "    def test_encode_with_tabular_array(self):\n        obj = {\n            \"users\": [\n                {\"id\": 1, \"name\": \"Alice\"},\n                {\"id\": 2, \"name\": \"Bob\"},\n            ]\n        }\n        result = encode(obj)\n        # python-toon uses [N,] format for comma delimiter\n        assert \"users[2,]{id,name}:\" in result\n        assert \"  1,Alice\" in result\n        assert \"  2,Bob\" in result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_mixed_structure_165": {
      "name": "test_encode_mixed_structure",
      "type": "method",
      "start_line": 165,
      "end_line": 185,
      "content_hash": "263261d5108b7e72000522b590cb3fef8898db51",
      "content": "    def test_encode_mixed_structure(self):\n        \"\"\"Test the hikes example from TOON spec.\"\"\"\n        obj = {\n            \"context\": {\n                \"task\": \"Our favorite hikes together\",\n                \"location\": \"Boulder\",\n            },\n            \"friends\": [\"ana\", \"luis\", \"sam\"],\n            \"hikes\": [\n                {\"id\": 1, \"name\": \"Blue Lake Trail\", \"distanceKm\": 7.5},\n                {\"id\": 2, \"name\": \"Ridge Overlook\", \"distanceKm\": 9.2},\n            ]\n        }\n        result = encode(obj)\n        # Context nested\n        assert \"context:\" in result\n        assert \"  task: Our favorite hikes together\" in result\n        # Friends inline\n        assert \"friends[3]: ana,luis,sam\" in result\n        # Hikes tabular - python-toon uses [N,] format\n        assert \"hikes[2,]{id,name,distanceKm}:\" in result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestSearchResults_188": {
      "name": "TestSearchResults",
      "type": "class",
      "start_line": 188,
      "end_line": 212,
      "content_hash": "3021e79b07c98526ffe603c8ebc5b232f6614a81",
      "content": "class TestSearchResults:\n    \"\"\"Test search result encoding specifically.\"\"\"\n\n    def test_encode_search_results_compact(self):\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n            {\"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n        ]\n        output = encode_search_results(results, compact=True)\n        assert \"results[2]{path,start_line,end_line}:\" in output\n        assert \"  /src/main.py,10,20\" in output\n        assert \"0.95\" not in output  # Score excluded in compact\n\n    def test_encode_search_results_full(self):\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95, \"symbol\": \"main\"},\n        ]\n        output = encode_search_results(results, compact=False)\n        assert \"score\" in output\n        assert \"0.95\" in output\n\n    def test_encode_empty_results(self):\n        # Per spec: empty arrays are key[0]: (nothing after colon)\n        output = encode_search_results([])\n        assert output == \"results[0]:\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_search_results_compact_191": {
      "name": "test_encode_search_results_compact",
      "type": "method",
      "start_line": 191,
      "end_line": 199,
      "content_hash": "b53a94bc2ed2a9fa06f8af7a329174cda86d1f3d",
      "content": "    def test_encode_search_results_compact(self):\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n            {\"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n        ]\n        output = encode_search_results(results, compact=True)\n        assert \"results[2]{path,start_line,end_line}:\" in output\n        assert \"  /src/main.py,10,20\" in output\n        assert \"0.95\" not in output  # Score excluded in compact",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_search_results_full_201": {
      "name": "test_encode_search_results_full",
      "type": "method",
      "start_line": 201,
      "end_line": 207,
      "content_hash": "67809044a9e33ffa45e927344df4814bddd67792",
      "content": "    def test_encode_search_results_full(self):\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95, \"symbol\": \"main\"},\n        ]\n        output = encode_search_results(results, compact=False)\n        assert \"score\" in output\n        assert \"0.95\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_empty_results_209": {
      "name": "test_encode_empty_results",
      "type": "method",
      "start_line": 209,
      "end_line": 212,
      "content_hash": "98f2587bee0ce77c8e96b5f8b79256b240867b03",
      "content": "    def test_encode_empty_results(self):\n        # Per spec: empty arrays are key[0]: (nothing after colon)\n        output = encode_search_results([])\n        assert output == \"results[0]:\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestTokenComparison_215": {
      "name": "TestTokenComparison",
      "type": "class",
      "start_line": 215,
      "end_line": 251,
      "content_hash": "d1fef96e82a3fb8bb4dfee2052ac5294321acd0e",
      "content": "class TestTokenComparison:\n    \"\"\"Test token counting and comparison.\"\"\"\n\n    def test_compare_formats_basic(self):\n        data = {\n            \"users\": [\n                {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n                {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n                {\"id\": 3, \"name\": \"Carol\", \"role\": \"viewer\"},\n            ]\n        }\n        stats = compare_formats(data)\n\n        assert stats[\"json_tokens\"] > 0\n        assert stats[\"toon_tokens\"] > 0\n        # TOON should be smaller than pretty JSON for tabular data\n        assert stats[\"toon_tokens\"] < stats[\"json_tokens\"]\n        assert stats[\"savings_vs_json\"] > 0\n\n    def test_compare_formats_larger_dataset(self):\n        \"\"\"Simulate search results - where TOON shines.\"\"\"\n        data = {\n            \"results\": [\n                {\"path\": f\"/src/file{i}.py\", \"start_line\": i * 10, \"end_line\": i * 10 + 5, \"score\": 0.9 - i * 0.05}\n                for i in range(20)\n            ]\n        }\n        stats = compare_formats(data)\n\n        # Should see significant savings on uniform arrays\n        assert stats[\"savings_vs_json\"] > 30  # Expect 30%+ savings\n        print(f\"\\nToken comparison for 20 search results:\")\n        print(f\"  JSON (pretty):  {stats['json_tokens']} tokens\")\n        print(f\"  JSON (compact): {stats['json_compact_tokens']} tokens\")\n        print(f\"  TOON (comma):   {stats['toon_tokens']} tokens\")\n        print(f\"  TOON (tab):     {stats['toon_tab_tokens']} tokens\")\n        print(f\"  Savings vs JSON: {stats['savings_vs_json']}%\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_compare_formats_basic_218": {
      "name": "test_compare_formats_basic",
      "type": "method",
      "start_line": 218,
      "end_line": 232,
      "content_hash": "ce76f5ddd7e913cba4a95e933715a8f14aaa8e99",
      "content": "    def test_compare_formats_basic(self):\n        data = {\n            \"users\": [\n                {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n                {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n                {\"id\": 3, \"name\": \"Carol\", \"role\": \"viewer\"},\n            ]\n        }\n        stats = compare_formats(data)\n\n        assert stats[\"json_tokens\"] > 0\n        assert stats[\"toon_tokens\"] > 0\n        # TOON should be smaller than pretty JSON for tabular data\n        assert stats[\"toon_tokens\"] < stats[\"json_tokens\"]\n        assert stats[\"savings_vs_json\"] > 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_compare_formats_larger_dataset_234": {
      "name": "test_compare_formats_larger_dataset",
      "type": "method",
      "start_line": 234,
      "end_line": 251,
      "content_hash": "44157d8fe3e5459bed7a05a819bdf66da42ab72f",
      "content": "    def test_compare_formats_larger_dataset(self):\n        \"\"\"Simulate search results - where TOON shines.\"\"\"\n        data = {\n            \"results\": [\n                {\"path\": f\"/src/file{i}.py\", \"start_line\": i * 10, \"end_line\": i * 10 + 5, \"score\": 0.9 - i * 0.05}\n                for i in range(20)\n            ]\n        }\n        stats = compare_formats(data)\n\n        # Should see significant savings on uniform arrays\n        assert stats[\"savings_vs_json\"] > 30  # Expect 30%+ savings\n        print(f\"\\nToken comparison for 20 search results:\")\n        print(f\"  JSON (pretty):  {stats['json_tokens']} tokens\")\n        print(f\"  JSON (compact): {stats['json_compact_tokens']} tokens\")\n        print(f\"  TOON (comma):   {stats['toon_tokens']} tokens\")\n        print(f\"  TOON (tab):     {stats['toon_tab_tokens']} tokens\")\n        print(f\"  Savings vs JSON: {stats['savings_vs_json']}%\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestMCPIntegration_254": {
      "name": "TestMCPIntegration",
      "type": "class",
      "start_line": 254,
      "end_line": 326,
      "content_hash": "ddc7c046d6c73cfe53cc9695a075472f491904bc",
      "content": "class TestMCPIntegration:\n    \"\"\"Test TOON integration with MCP server helpers.\"\"\"\n\n    def test_should_use_toon_explicit_param(self, monkeypatch):\n        \"\"\"Test explicit output_format parameter takes precedence.\"\"\"\n        # Import the helpers from mcp_indexer_server\n        monkeypatch.delenv(\"TOON_ENABLED\", raising=False)\n\n        # We need to test the helper functions directly\n        # Since they're in mcp_indexer_server, we'll test the logic here\n        from scripts.toon_encoder import is_toon_enabled\n\n        # When TOON_ENABLED is not set, default is False\n        assert is_toon_enabled() is False\n\n        # When explicitly set\n        monkeypatch.setenv(\"TOON_ENABLED\", \"1\")\n        assert is_toon_enabled() is True\n\n    def test_format_results_as_toon_structure(self):\n        \"\"\"Test that TOON formatting adds expected fields.\"\"\"\n        # Simulate a search response\n        response = {\n            \"results\": [\n                {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n                {\"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n            ],\n            \"total\": 2,\n            \"args\": {\"query\": \"test\"},\n        }\n\n        # Apply TOON formatting\n        toon_output = encode_search_results(response[\"results\"], compact=True)\n\n        # Verify TOON output structure\n        assert \"results[2]{path,start_line,end_line}:\" in toon_output\n        assert \"/src/main.py,10,20\" in toon_output\n        assert \"/src/utils.py,5,15\" in toon_output\n\n    def test_toon_replaces_results_array(self):\n        \"\"\"Test that TOON formatting replaces JSON array with TOON string.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20},\n        ]\n\n        # When TOON is applied, results becomes a string\n        toon_output = encode_search_results(results, compact=True)\n        assert isinstance(toon_output, str)\n        assert \"results[1]{path,start_line,end_line}:\" in toon_output\n        assert \"/src/main.py,10,20\" in toon_output\n\n    def test_toon_compact_mode_excludes_score(self):\n        \"\"\"Test that compact mode excludes score field.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n        ]\n\n        output = encode_search_results(results, compact=True)\n\n        # Score should not be in compact output\n        assert \"0.95\" not in output\n        assert \"score\" not in output\n\n    def test_toon_full_mode_includes_score(self):\n        \"\"\"Test that full mode includes score field.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        # Score should be in full output\n        assert \"0.95\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_should_use_toon_explicit_param_257": {
      "name": "test_should_use_toon_explicit_param",
      "type": "method",
      "start_line": 257,
      "end_line": 271,
      "content_hash": "43fc3e80fd4236c5ea553296f967618c4934860b",
      "content": "    def test_should_use_toon_explicit_param(self, monkeypatch):\n        \"\"\"Test explicit output_format parameter takes precedence.\"\"\"\n        # Import the helpers from mcp_indexer_server\n        monkeypatch.delenv(\"TOON_ENABLED\", raising=False)\n\n        # We need to test the helper functions directly\n        # Since they're in mcp_indexer_server, we'll test the logic here\n        from scripts.toon_encoder import is_toon_enabled\n\n        # When TOON_ENABLED is not set, default is False\n        assert is_toon_enabled() is False\n\n        # When explicitly set\n        monkeypatch.setenv(\"TOON_ENABLED\", \"1\")\n        assert is_toon_enabled() is True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_results_as_toon_structure_273": {
      "name": "test_format_results_as_toon_structure",
      "type": "method",
      "start_line": 273,
      "end_line": 291,
      "content_hash": "a7ffb26fd97601aa8c99ebc48c489e874b59538f",
      "content": "    def test_format_results_as_toon_structure(self):\n        \"\"\"Test that TOON formatting adds expected fields.\"\"\"\n        # Simulate a search response\n        response = {\n            \"results\": [\n                {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n                {\"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n            ],\n            \"total\": 2,\n            \"args\": {\"query\": \"test\"},\n        }\n\n        # Apply TOON formatting\n        toon_output = encode_search_results(response[\"results\"], compact=True)\n\n        # Verify TOON output structure\n        assert \"results[2]{path,start_line,end_line}:\" in toon_output\n        assert \"/src/main.py,10,20\" in toon_output\n        assert \"/src/utils.py,5,15\" in toon_output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_toon_replaces_results_array_293": {
      "name": "test_toon_replaces_results_array",
      "type": "method",
      "start_line": 293,
      "end_line": 303,
      "content_hash": "955825e27dd8929efb4bddccf1a043f5336d39d5",
      "content": "    def test_toon_replaces_results_array(self):\n        \"\"\"Test that TOON formatting replaces JSON array with TOON string.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20},\n        ]\n\n        # When TOON is applied, results becomes a string\n        toon_output = encode_search_results(results, compact=True)\n        assert isinstance(toon_output, str)\n        assert \"results[1]{path,start_line,end_line}:\" in toon_output\n        assert \"/src/main.py,10,20\" in toon_output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_toon_compact_mode_excludes_score_305": {
      "name": "test_toon_compact_mode_excludes_score",
      "type": "method",
      "start_line": 305,
      "end_line": 315,
      "content_hash": "de56fa99304954bbcd1c86afb6d7cf93ac9d5999",
      "content": "    def test_toon_compact_mode_excludes_score(self):\n        \"\"\"Test that compact mode excludes score field.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n        ]\n\n        output = encode_search_results(results, compact=True)\n\n        # Score should not be in compact output\n        assert \"0.95\" not in output\n        assert \"score\" not in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_toon_full_mode_includes_score_317": {
      "name": "test_toon_full_mode_includes_score",
      "type": "method",
      "start_line": 317,
      "end_line": 326,
      "content_hash": "cae402682dc15b260b89cb14d0b516c428e5843a",
      "content": "    def test_toon_full_mode_includes_score(self):\n        \"\"\"Test that full mode includes score field.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        # Score should be in full output\n        assert \"0.95\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestContextResults_329": {
      "name": "TestContextResults",
      "type": "class",
      "start_line": 329,
      "end_line": 411,
      "content_hash": "0d2d893079916467f8c8d31abd3ab14bbfc82102",
      "content": "class TestContextResults:\n    \"\"\"Test encode_context_results for mixed code/memory results.\"\"\"\n\n    def test_encode_empty_context_results(self):\n        \"\"\"Test empty results return proper TOON format per spec.\"\"\"\n        output = encode_context_results([])\n        # Per spec: empty arrays are key[0]: (nothing after colon)\n        assert output == \"results[0]:\"\n\n    def test_encode_code_only_results(self):\n        \"\"\"Test encoding results with only code entries.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n            {\"source\": \"code\", \"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have code section\n        assert \"code[2]{path,start_line,end_line}:\" in output\n        assert \"/src/main.py,10,20\" in output\n        assert \"/src/utils.py,5,15\" in output\n        # Should not have memory section\n        assert \"memory[\" not in output\n\n    def test_encode_memory_only_results(self):\n        \"\"\"Test encoding results with only memory entries.\"\"\"\n        results = [\n            {\"source\": \"memory\", \"content\": \"API uses OAuth2\", \"score\": 0.92},\n            {\"source\": \"memory\", \"content\": \"Database is PostgreSQL\", \"score\": 0.85},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have memory section\n        assert \"memory[2]{content,score}:\" in output\n        assert \"API uses OAuth2\" in output\n        assert \"Database is PostgreSQL\" in output\n        # Should not have code section\n        assert \"code[\" not in output\n\n    def test_encode_mixed_code_and_memory(self):\n        \"\"\"Test encoding results with both code and memory entries.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/auth.py\", \"start_line\": 100, \"end_line\": 150, \"score\": 0.95},\n            {\"source\": \"memory\", \"content\": \"Auth uses JWT tokens\", \"score\": 0.90},\n            {\"source\": \"code\", \"path\": \"/src/jwt.py\", \"start_line\": 20, \"end_line\": 40, \"score\": 0.88},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have both sections\n        assert \"code[2]{path,start_line,end_line}:\" in output\n        assert \"memory[1]{content,score}:\" in output\n        assert \"/src/auth.py,100,150\" in output\n        assert \"/src/jwt.py,20,40\" in output\n        assert \"Auth uses JWT tokens\" in output\n\n    def test_encode_context_results_full_mode(self):\n        \"\"\"Test full mode includes additional fields.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95, \"symbol\": \"main\"},\n            {\"source\": \"memory\", \"content\": \"Note about main\", \"score\": 0.90, \"id\": \"mem-123\"},\n        ]\n\n        output = encode_context_results(results, compact=False)\n\n        # Full mode should include score and symbol for code\n        assert \"code[1]{path,start_line,end_line,score,symbol}:\" in output\n        # Full mode should include id for memory\n        assert \"memory[1]{content,score,id}:\" in output\n\n    def test_encode_context_results_with_delimiter(self):\n        \"\"\"Test custom delimiter works correctly.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20},\n        ]\n\n        output = encode_context_results(results, delimiter=\"\\t\", compact=True)\n\n        # Should use tab delimiter with [N\\t] format\n        assert \"code[1\\t]{path\\tstart_line\\tend_line}:\" in output\n        assert \"/src/main.py\\t10\\t20\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_empty_context_results_332": {
      "name": "test_encode_empty_context_results",
      "type": "method",
      "start_line": 332,
      "end_line": 336,
      "content_hash": "940282c4839872a39318c86cf7db8b97b50023c9",
      "content": "    def test_encode_empty_context_results(self):\n        \"\"\"Test empty results return proper TOON format per spec.\"\"\"\n        output = encode_context_results([])\n        # Per spec: empty arrays are key[0]: (nothing after colon)\n        assert output == \"results[0]:\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_code_only_results_338": {
      "name": "test_encode_code_only_results",
      "type": "method",
      "start_line": 338,
      "end_line": 352,
      "content_hash": "ed0c22bb762e18383c96f3be61fdbeb07468dfbd",
      "content": "    def test_encode_code_only_results(self):\n        \"\"\"Test encoding results with only code entries.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95},\n            {\"source\": \"code\", \"path\": \"/src/utils.py\", \"start_line\": 5, \"end_line\": 15, \"score\": 0.87},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have code section\n        assert \"code[2]{path,start_line,end_line}:\" in output\n        assert \"/src/main.py,10,20\" in output\n        assert \"/src/utils.py,5,15\" in output\n        # Should not have memory section\n        assert \"memory[\" not in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_memory_only_results_354": {
      "name": "test_encode_memory_only_results",
      "type": "method",
      "start_line": 354,
      "end_line": 368,
      "content_hash": "987a075669d5603c6d1726cce47e39cacb7c60e8",
      "content": "    def test_encode_memory_only_results(self):\n        \"\"\"Test encoding results with only memory entries.\"\"\"\n        results = [\n            {\"source\": \"memory\", \"content\": \"API uses OAuth2\", \"score\": 0.92},\n            {\"source\": \"memory\", \"content\": \"Database is PostgreSQL\", \"score\": 0.85},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have memory section\n        assert \"memory[2]{content,score}:\" in output\n        assert \"API uses OAuth2\" in output\n        assert \"Database is PostgreSQL\" in output\n        # Should not have code section\n        assert \"code[\" not in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_mixed_code_and_memory_370": {
      "name": "test_encode_mixed_code_and_memory",
      "type": "method",
      "start_line": 370,
      "end_line": 385,
      "content_hash": "4bb9ad7444fc1213e731dbea32bd70945efdc98a",
      "content": "    def test_encode_mixed_code_and_memory(self):\n        \"\"\"Test encoding results with both code and memory entries.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/auth.py\", \"start_line\": 100, \"end_line\": 150, \"score\": 0.95},\n            {\"source\": \"memory\", \"content\": \"Auth uses JWT tokens\", \"score\": 0.90},\n            {\"source\": \"code\", \"path\": \"/src/jwt.py\", \"start_line\": 20, \"end_line\": 40, \"score\": 0.88},\n        ]\n\n        output = encode_context_results(results, compact=True)\n\n        # Should have both sections\n        assert \"code[2]{path,start_line,end_line}:\" in output\n        assert \"memory[1]{content,score}:\" in output\n        assert \"/src/auth.py,100,150\" in output\n        assert \"/src/jwt.py,20,40\" in output\n        assert \"Auth uses JWT tokens\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_context_results_full_mode_387": {
      "name": "test_encode_context_results_full_mode",
      "type": "method",
      "start_line": 387,
      "end_line": 399,
      "content_hash": "cac1f808b1ed33fbee7af008c8822d2a0fc159be",
      "content": "    def test_encode_context_results_full_mode(self):\n        \"\"\"Test full mode includes additional fields.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20, \"score\": 0.95, \"symbol\": \"main\"},\n            {\"source\": \"memory\", \"content\": \"Note about main\", \"score\": 0.90, \"id\": \"mem-123\"},\n        ]\n\n        output = encode_context_results(results, compact=False)\n\n        # Full mode should include score and symbol for code\n        assert \"code[1]{path,start_line,end_line,score,symbol}:\" in output\n        # Full mode should include id for memory\n        assert \"memory[1]{content,score,id}:\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_context_results_with_delimiter_401": {
      "name": "test_encode_context_results_with_delimiter",
      "type": "method",
      "start_line": 401,
      "end_line": 411,
      "content_hash": "8972f88f074ddbb474e3a7d2b5348efd8f9d3574",
      "content": "    def test_encode_context_results_with_delimiter(self):\n        \"\"\"Test custom delimiter works correctly.\"\"\"\n        results = [\n            {\"source\": \"code\", \"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20},\n        ]\n\n        output = encode_context_results(results, delimiter=\"\\t\", compact=True)\n\n        # Should use tab delimiter with [N\\t] format\n        assert \"code[1\\t]{path\\tstart_line\\tend_line}:\" in output\n        assert \"/src/main.py\\t10\\t20\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestFormatContextResultsAsToon_414": {
      "name": "TestFormatContextResultsAsToon",
      "type": "class",
      "start_line": 414,
      "end_line": 460,
      "content_hash": "64ab3622d5bca19b60f688b236eaa78d0d3e0677",
      "content": "class TestFormatContextResultsAsToon:\n    \"\"\"Test _format_context_results_as_toon MCP helper.\"\"\"\n\n    def test_format_empty_results_adds_marker(self):\n        \"\"\"Test that empty results still get output_format marker.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\"results\": [], \"total\": 0}\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"output_format\"] == \"toon\"\n        # Empty array per spec: key[0]:\n        assert result[\"results\"] == \"results[0]:\"\n\n    def test_format_mixed_results(self):\n        \"\"\"Test formatting mixed code/memory results.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\n            \"results\": [\n                {\"source\": \"code\", \"path\": \"/src/api.py\", \"start_line\": 1, \"end_line\": 10},\n                {\"source\": \"memory\", \"content\": \"API docs here\", \"score\": 0.9},\n            ],\n            \"total\": 2,\n        }\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"output_format\"] == \"toon\"\n        assert isinstance(result[\"results\"], str)\n        assert \"code[1]\" in result[\"results\"]\n        assert \"memory[1]\" in result[\"results\"]\n\n    def test_format_preserves_other_fields(self):\n        \"\"\"Test that formatting preserves non-results fields.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\n            \"results\": [{\"source\": \"code\", \"path\": \"/a.py\", \"start_line\": 1, \"end_line\": 5}],\n            \"total\": 1,\n            \"diag\": {\"code_hits\": 1, \"mem_hits\": 0},\n            \"args\": {\"query\": \"test\"},\n        }\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"total\"] == 1\n        assert result[\"diag\"] == {\"code_hits\": 1, \"mem_hits\": 0}\n        assert result[\"args\"] == {\"query\": \"test\"}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_empty_results_adds_marker_417": {
      "name": "test_format_empty_results_adds_marker",
      "type": "method",
      "start_line": 417,
      "end_line": 426,
      "content_hash": "905e86b39bced79f9a299dba236feb1a81575737",
      "content": "    def test_format_empty_results_adds_marker(self):\n        \"\"\"Test that empty results still get output_format marker.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\"results\": [], \"total\": 0}\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"output_format\"] == \"toon\"\n        # Empty array per spec: key[0]:\n        assert result[\"results\"] == \"results[0]:\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_mixed_results_428": {
      "name": "test_format_mixed_results",
      "type": "method",
      "start_line": 428,
      "end_line": 444,
      "content_hash": "5b5d36a5247dd6a14ca12ee6fe77b7391439bbd0",
      "content": "    def test_format_mixed_results(self):\n        \"\"\"Test formatting mixed code/memory results.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\n            \"results\": [\n                {\"source\": \"code\", \"path\": \"/src/api.py\", \"start_line\": 1, \"end_line\": 10},\n                {\"source\": \"memory\", \"content\": \"API docs here\", \"score\": 0.9},\n            ],\n            \"total\": 2,\n        }\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"output_format\"] == \"toon\"\n        assert isinstance(result[\"results\"], str)\n        assert \"code[1]\" in result[\"results\"]\n        assert \"memory[1]\" in result[\"results\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_preserves_other_fields_446": {
      "name": "test_format_preserves_other_fields",
      "type": "method",
      "start_line": 446,
      "end_line": 460,
      "content_hash": "0bde541483d3f76df7d3d203cc278da60e08cd59",
      "content": "    def test_format_preserves_other_fields(self):\n        \"\"\"Test that formatting preserves non-results fields.\"\"\"\n        from scripts.mcp_indexer_server import _format_context_results_as_toon\n\n        response = {\n            \"results\": [{\"source\": \"code\", \"path\": \"/a.py\", \"start_line\": 1, \"end_line\": 5}],\n            \"total\": 1,\n            \"diag\": {\"code_hits\": 1, \"mem_hits\": 0},\n            \"args\": {\"query\": \"test\"},\n        }\n        result = _format_context_results_as_toon(response.copy())\n\n        assert result[\"total\"] == 1\n        assert result[\"diag\"] == {\"code_hits\": 1, \"mem_hits\": 0}\n        assert result[\"args\"] == {\"query\": \"test\"}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestDynamicFieldInclusion_463": {
      "name": "TestDynamicFieldInclusion",
      "type": "class",
      "start_line": 463,
      "end_line": 531,
      "content_hash": "45c1906caee2ff4c8bb304234a5e75b38cd74910",
      "content": "class TestDynamicFieldInclusion:\n    \"\"\"Test that TOON encoding doesn't drop fields.\"\"\"\n\n    def test_encode_with_snippet_field(self):\n        \"\"\"Test that snippet field is included in full mode.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20,\n             \"score\": 0.95, \"snippet\": \"def main():\\n    pass\"},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"snippet\" in output\n        assert \"def main()\" in output\n\n    def test_encode_with_information_field(self):\n        \"\"\"Test that info_request's information field is included.\"\"\"\n        results = [\n            {\"path\": \"/src/auth.py\", \"start_line\": 1, \"end_line\": 50,\n             \"score\": 0.9, \"information\": \"Authentication handler at /src/auth.py:1-50\",\n             \"relevance_score\": 0.9},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"information\" in output\n        assert \"relevance_score\" in output\n        assert \"Authentication handler\" in output\n\n    def test_encode_with_relationships_field(self):\n        \"\"\"Test that relationships dict is encoded as JSON.\"\"\"\n        results = [\n            {\"path\": \"/src/api.py\", \"start_line\": 10, \"end_line\": 30,\n             \"relationships\": {\"imports_from\": [\"os\", \"sys\"], \"calls\": [\"auth.login\"]}},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"relationships\" in output\n        # Nested objects become compact JSON\n        assert \"imports_from\" in output\n\n    def test_encode_preserves_all_custom_fields(self):\n        \"\"\"Test that any custom fields added by tools are preserved.\"\"\"\n        results = [\n            {\"path\": \"/a.py\", \"start_line\": 1, \"end_line\": 5,\n             \"custom_field\": \"custom_value\", \"another_field\": 123},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"custom_field\" in output\n        assert \"custom_value\" in output\n        assert \"another_field\" in output\n        assert \"123\" in output\n\n    def test_context_results_with_extra_memory_fields(self):\n        \"\"\"Test memory results preserve all fields in full mode.\"\"\"\n        results = [\n            {\"source\": \"memory\", \"content\": \"API note\", \"score\": 0.9,\n             \"id\": \"mem-123\", \"created_at\": \"2024-01-01\", \"tags\": [\"api\", \"docs\"]},\n        ]\n\n        output = encode_context_results(results, compact=False)\n\n        assert \"content\" in output\n        assert \"id\" in output\n        assert \"created_at\" in output\n        assert \"tags\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_with_snippet_field_466": {
      "name": "test_encode_with_snippet_field",
      "type": "method",
      "start_line": 466,
      "end_line": 476,
      "content_hash": "5b91daac87071b8980f8e713dc1023c25daff21b",
      "content": "    def test_encode_with_snippet_field(self):\n        \"\"\"Test that snippet field is included in full mode.\"\"\"\n        results = [\n            {\"path\": \"/src/main.py\", \"start_line\": 10, \"end_line\": 20,\n             \"score\": 0.95, \"snippet\": \"def main():\\n    pass\"},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"snippet\" in output\n        assert \"def main()\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_with_information_field_478": {
      "name": "test_encode_with_information_field",
      "type": "method",
      "start_line": 478,
      "end_line": 490,
      "content_hash": "dbac87d3a48ceae56f73ff4c50883f06a8699f09",
      "content": "    def test_encode_with_information_field(self):\n        \"\"\"Test that info_request's information field is included.\"\"\"\n        results = [\n            {\"path\": \"/src/auth.py\", \"start_line\": 1, \"end_line\": 50,\n             \"score\": 0.9, \"information\": \"Authentication handler at /src/auth.py:1-50\",\n             \"relevance_score\": 0.9},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"information\" in output\n        assert \"relevance_score\" in output\n        assert \"Authentication handler\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_with_relationships_field_492": {
      "name": "test_encode_with_relationships_field",
      "type": "method",
      "start_line": 492,
      "end_line": 503,
      "content_hash": "a33109135dcdc4d1fa92e17920adb714bb8e56f4",
      "content": "    def test_encode_with_relationships_field(self):\n        \"\"\"Test that relationships dict is encoded as JSON.\"\"\"\n        results = [\n            {\"path\": \"/src/api.py\", \"start_line\": 10, \"end_line\": 30,\n             \"relationships\": {\"imports_from\": [\"os\", \"sys\"], \"calls\": [\"auth.login\"]}},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"relationships\" in output\n        # Nested objects become compact JSON\n        assert \"imports_from\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encode_preserves_all_custom_fields_505": {
      "name": "test_encode_preserves_all_custom_fields",
      "type": "method",
      "start_line": 505,
      "end_line": 517,
      "content_hash": "9cf643af4f2f5b8a6c11d3300826815de83ac5b8",
      "content": "    def test_encode_preserves_all_custom_fields(self):\n        \"\"\"Test that any custom fields added by tools are preserved.\"\"\"\n        results = [\n            {\"path\": \"/a.py\", \"start_line\": 1, \"end_line\": 5,\n             \"custom_field\": \"custom_value\", \"another_field\": 123},\n        ]\n\n        output = encode_search_results(results, compact=False)\n\n        assert \"custom_field\" in output\n        assert \"custom_value\" in output\n        assert \"another_field\" in output\n        assert \"123\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_context_results_with_extra_memory_fields_519": {
      "name": "test_context_results_with_extra_memory_fields",
      "type": "method",
      "start_line": 519,
      "end_line": 531,
      "content_hash": "803f3b848df3999996ff76557fdbfc461d486fae",
      "content": "    def test_context_results_with_extra_memory_fields(self):\n        \"\"\"Test memory results preserve all fields in full mode.\"\"\"\n        results = [\n            {\"source\": \"memory\", \"content\": \"API note\", \"score\": 0.9,\n             \"id\": \"mem-123\", \"created_at\": \"2024-01-01\", \"tags\": [\"api\", \"docs\"]},\n        ]\n\n        output = encode_context_results(results, compact=False)\n\n        assert \"content\" in output\n        assert \"id\" in output\n        assert \"created_at\" in output\n        assert \"tags\" in output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}