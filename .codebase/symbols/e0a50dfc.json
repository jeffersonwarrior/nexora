{
  "file_path": "/work/context-engine/scripts/ingest/vectors.py",
  "file_hash": "5b7b1823a50090a8eb78f50645dbf61274f72ed4",
  "updated_at": "2025-12-26T17:34:24.482240",
  "symbols": {
    "function__get_mini_proj_27": {
      "name": "_get_mini_proj",
      "type": "function",
      "start_line": 27,
      "end_line": 46,
      "content_hash": "d09c8e9297f978840cd02a3c5905ccf6e0dcd4ad",
      "content": "def _get_mini_proj(\n    in_dim: int, out_dim: int, seed: int | None = None\n) -> list[list[float]]:\n    \"\"\"Get or create a random projection matrix for mini vectors.\"\"\"\n    import math\n    import random\n\n    s = int(os.environ.get(\"MINI_VEC_SEED\", \"1337\")) if seed is None else int(seed)\n    key = (in_dim, out_dim, s)\n    M = _MINI_PROJ_CACHE.get(key)\n    if M is None:\n        rnd = random.Random(s)\n        scale = 1.0 / math.sqrt(out_dim)\n        # Dense Rademacher matrix (+/-1) scaled; good enough for fast gating\n        M = [\n            [scale * (1.0 if rnd.random() < 0.5 else -1.0) for _ in range(out_dim)]\n            for _ in range(in_dim)\n        ]\n        _MINI_PROJ_CACHE[key] = M\n    return M",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_project_mini_49": {
      "name": "project_mini",
      "type": "function",
      "start_line": 49,
      "end_line": 65,
      "content_hash": "b38e4f13756b3bb6ededa68cdb4f66ba9edaa91c",
      "content": "def project_mini(vec: list[float], out_dim: int | None = None) -> list[float]:\n    \"\"\"Project a dense vector to a compact mini vector using random projection.\"\"\"\n    if not vec:\n        return [0.0] * (int(out_dim or MINI_VEC_DIM))\n    od = int(out_dim or MINI_VEC_DIM)\n    M = _get_mini_proj(len(vec), od)\n    out = [0.0] * od\n    # y = x @ M\n    for i, val in enumerate(vec):\n        if val == 0.0:\n            continue\n        row = M[i]\n        for j in range(od):\n            out[j] += val * row[j]\n    # L2 normalize to keep scale consistent\n    norm = (sum(x * x for x in out) or 0.0) ** 0.5 or 1.0\n    return [x / norm for x in out]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__split_ident_lex_68": {
      "name": "_split_ident_lex",
      "type": "function",
      "start_line": 68,
      "end_line": 77,
      "content_hash": "1d8a335c7773458403ba8e22ddf2898e95acd850",
      "content": "def _split_ident_lex(s: str) -> List[str]:\n    \"\"\"Split identifier into tokens (snake_case and camelCase aware).\"\"\"\n    parts = re.split(r\"[^A-Za-z0-9]+\", s)\n    out: List[str] = []\n    for p in parts:\n        if not p:\n            continue\n        segs = re.findall(r\"[A-Z]?[a-z]+|[A-Z]+(?![a-z])|\\d+\", p)\n        out.extend([x for x in segs if x])\n    return [x.lower() for x in out if x and x.lower() not in _STOP]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__lex_hash_vector_80": {
      "name": "_lex_hash_vector",
      "type": "function",
      "start_line": 80,
      "end_line": 96,
      "content_hash": "89b3bc266ab3a797e4f861576cceae44af32e753",
      "content": "def _lex_hash_vector(text: str, dim: int = LEX_VECTOR_DIM) -> list[float]:\n    \"\"\"Create a lexical hash vector from text using hashing trick.\"\"\"\n    if not text:\n        return [0.0] * dim\n    vec = [0.0] * dim\n    # Tokenize identifiers & words\n    toks = _split_ident_lex(text)\n    if not toks:\n        return vec\n    for t in toks:\n        h = int(hashlib.md5(t.encode(\"utf-8\", errors=\"ignore\")).hexdigest()[:8], 16)\n        idx = h % dim\n        vec[idx] += 1.0\n    # L2 normalize (avoid huge magnitudes)\n    import math\n    norm = math.sqrt(sum(v * v for v in vec)) or 1.0\n    return [v / norm for v in vec]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}