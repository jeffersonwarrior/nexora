{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/compatibility_tests.rs",
  "file_hash": "2c06cfdbc490adc0e50c14714262177fbdd02e6c",
  "updated_at": "2025-12-26T17:34:20.499185",
  "symbols": {
    "function_test_old_node_hashmap_to_new_immutable_map_23": {
      "name": "test_old_node_hashmap_to_new_immutable_map",
      "type": "function",
      "start_line": 23,
      "end_line": 58,
      "content_hash": "ed43ab52bf7da2244d11c74ed8bc0add1de57bce",
      "content": "    fn test_old_node_hashmap_to_new_immutable_map() {\n        let id = 12345u128;\n\n        // Create old-style node with HashMap\n        let old_node = create_old_node(\n            id,\n            \"LegacyNode\",\n            0,\n            vec![\n                (\"name\", Value::String(\"test\".to_string())),\n                (\"count\", Value::I32(42)),\n            ],\n        );\n\n        // Serialize with old format\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        // Deserialize with new format\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena);\n\n        assert!(new_node.is_ok(), \"Should deserialize old format\");\n        let restored = new_node.unwrap();\n\n        assert_eq!(restored.id, id);\n        assert_eq!(restored.label, \"LegacyNode\");\n        assert!(restored.properties.is_some());\n\n        // Verify properties were preserved\n        let props = restored.properties.unwrap();\n        assert_eq!(props.len(), 2);\n        assert!(props.get(\"name\").is_some());\n        assert!(props.get(\"count\").is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_node_empty_properties_59": {
      "name": "test_old_node_empty_properties",
      "type": "function",
      "start_line": 59,
      "end_line": 73,
      "content_hash": "1dbcd6e06a1ae41ec7c95f2147aa409dfab0e047",
      "content": "    fn test_old_node_empty_properties() {\n        let id = 11111u128;\n\n        let old_node = create_old_node(id, \"EmptyProps\", 0, vec![]);\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(new_node.label, \"EmptyProps\");\n        assert!(new_node.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_node_version_0_to_current_74": {
      "name": "test_old_node_version_0_to_current",
      "type": "function",
      "start_line": 74,
      "end_line": 87,
      "content_hash": "5d207b6c0d9e8918be43e34f52bd537d2c413c9a",
      "content": "    fn test_old_node_version_0_to_current() {\n        let id = 22222u128;\n\n        let old_node = create_old_node(id, \"V0Node\", 0, vec![]);\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(new_node.version, 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_node_with_all_value_types_88": {
      "name": "test_old_node_with_all_value_types",
      "type": "function",
      "start_line": 88,
      "end_line": 112,
      "content_hash": "6f4acbf504835cc313a5fc02db0d77c565f1f3d4",
      "content": "    fn test_old_node_with_all_value_types() {\n        let id = 33333u128;\n\n        let props = vec![\n            (\"str\", Value::String(\"text\".to_string())),\n            (\"i32\", Value::I32(-100)),\n            (\"i64\", Value::I64(-1000)),\n            (\"u64\", Value::U64(1000)),\n            (\"f64\", Value::F64(3.14)),\n            (\"bool\", Value::Boolean(true)),\n            (\"empty\", Value::Empty),\n        ];\n\n        let old_node = create_old_node(id, \"AllTypes\", 0, props);\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert!(new_node.properties.is_some());\n        let new_props = new_node.properties.unwrap();\n        assert_eq!(new_props.len(), 7);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_node_with_many_properties_113": {
      "name": "test_old_node_with_many_properties",
      "type": "function",
      "start_line": 113,
      "end_line": 135,
      "content_hash": "07b2f3a5896dc7c05d389f92a5422e1b746e4b43",
      "content": "    fn test_old_node_with_many_properties() {\n        let id = 44444u128;\n\n        let props: Vec<(&str, Value)> = (0..50)\n            .map(|i| {\n                (Box::leak(format!(\"key_{}\", i).into_boxed_str()) as &str, Value::I32(i))\n            })\n            .collect();\n\n        let old_node = create_old_node(id, \"ManyProps\", 0, props);\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(new_node.properties.unwrap().len(), 50);\n    }\n\n    // ========================================================================\n    // EDGE BACKWARDS COMPATIBILITY TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_edge_hashmap_to_new_immutable_map_136": {
      "name": "test_old_edge_hashmap_to_new_immutable_map",
      "type": "function",
      "start_line": 136,
      "end_line": 167,
      "content_hash": "83b3c4b5949aa71b4ce6f0012dcdc8743b67323b",
      "content": "    fn test_old_edge_hashmap_to_new_immutable_map() {\n        let id = 55555u128;\n\n        let old_edge = create_old_edge(\n            id,\n            \"LegacyEdge\",\n            0,\n            100,\n            200,\n            vec![\n                (\"weight\", Value::F64(0.85)),\n                (\"type\", Value::String(\"connection\".to_string())),\n            ],\n        );\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena);\n\n        assert!(new_edge.is_ok(), \"Should deserialize old edge format\");\n        let restored = new_edge.unwrap();\n\n        assert_eq!(restored.id, id);\n        assert_eq!(restored.label, \"LegacyEdge\");\n        assert_eq!(restored.from_node, 100);\n        assert_eq!(restored.to_node, 200);\n        assert!(restored.properties.is_some());\n        assert_eq!(restored.properties.unwrap().len(), 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_edge_empty_properties_168": {
      "name": "test_old_edge_empty_properties",
      "type": "function",
      "start_line": 168,
      "end_line": 183,
      "content_hash": "4f943fdd479d3dd09322543f8b363b4f5cbe3d01",
      "content": "    fn test_old_edge_empty_properties() {\n        let id = 66666u128;\n\n        let old_edge = create_old_edge(id, \"SimpleEdge\", 0, 1, 2, vec![]);\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(new_edge.from_node, 1);\n        assert_eq!(new_edge.to_node, 2);\n        assert!(new_edge.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_edge_with_nested_values_184": {
      "name": "test_old_edge_with_nested_values",
      "type": "function",
      "start_line": 184,
      "end_line": 213,
      "content_hash": "9048a20ef262419079a4fe9f87fac7b55431e4f5",
      "content": "    fn test_old_edge_with_nested_values() {\n        let id = 77777u128;\n\n        let props = vec![\n            (\n                \"metadata\",\n                Value::Object(\n                    vec![\n                        (\"created\".to_string(), Value::I64(1234567890)),\n                        (\"tags\".to_string(), Value::Array(vec![\n                            Value::String(\"tag1\".to_string()),\n                            Value::String(\"tag2\".to_string()),\n                        ])),\n                    ]\n                    .into_iter()\n                    .collect(),\n                ),\n            ),\n        ];\n\n        let old_edge = create_old_edge(id, \"NestedEdge\", 0, 10, 20, props);\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert!(new_edge.properties.is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_edge_version_field_214": {
      "name": "test_old_edge_version_field",
      "type": "function",
      "start_line": 214,
      "end_line": 231,
      "content_hash": "4ce48edff96b5a437b98d99ce382bebfdfaf26f3",
      "content": "    fn test_old_edge_version_field() {\n        let id = 88888u128;\n\n        let old_edge = create_old_edge(id, \"VersionedEdge\", 5, 1, 2, vec![]);\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(new_edge.version, 5);\n    }\n\n    // ========================================================================\n    // VECTOR BACKWARDS COMPATIBILITY TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_vector_to_new_vector_232": {
      "name": "test_old_vector_to_new_vector",
      "type": "function",
      "start_line": 232,
      "end_line": 264,
      "content_hash": "08e44b5bb3fe0bbe14f5e4193e2a85e564c870a7",
      "content": "    fn test_old_vector_to_new_vector() {\n        let id = 99999u128;\n\n        let old_vector = create_old_vector(\n            id,\n            \"LegacyVector\",\n            1,\n            false,\n            vec![(\"source\", Value::String(\"embedding\".to_string()))],\n        );\n\n        let old_bytes = bincode::serialize(&old_vector).unwrap();\n        let data = vec![1.0, 2.0, 3.0];\n        let data_bytes = create_vector_bytes(&data);\n\n        let arena = Bump::new();\n        let new_vector = HVector::from_bincode_bytes(\n            &arena,\n            Some(&old_bytes),\n            &data_bytes,\n            id,\n        );\n\n        assert!(new_vector.is_ok(), \"Should deserialize old vector format\");\n        let restored = new_vector.unwrap();\n\n        assert_eq!(restored.id, id);\n        assert_eq!(restored.label, \"LegacyVector\");\n        assert_eq!(restored.version, 1);\n        assert_eq!(restored.deleted, false);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_vector_deleted_flag_265": {
      "name": "test_old_vector_deleted_flag",
      "type": "function",
      "start_line": 265,
      "end_line": 284,
      "content_hash": "2aacb10d92f956e8985047157120dfcf2e63600a",
      "content": "    fn test_old_vector_deleted_flag() {\n        let id = 111000u128;\n\n        let old_vector = create_old_vector(id, \"DeletedVector\", 1, true, vec![]);\n\n        let old_bytes = bincode::serialize(&old_vector).unwrap();\n        let data_bytes = create_vector_bytes(&[0.0]);\n\n        let arena = Bump::new();\n        let new_vector = HVector::from_bincode_bytes(\n            &arena,\n            Some(&old_bytes),\n            &data_bytes,\n            id,\n        ).unwrap();\n\n        assert_eq!(new_vector.deleted, true);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_vector_with_properties_285": {
      "name": "test_old_vector_with_properties",
      "type": "function",
      "start_line": 285,
      "end_line": 316,
      "content_hash": "7b28da4fc22c594361396afbea0c2f37e67dd2ed",
      "content": "    fn test_old_vector_with_properties() {\n        let id = 222000u128;\n\n        let props = vec![\n            (\"model\", Value::String(\"ada-002\".to_string())),\n            (\"dimension\", Value::I32(1536)),\n        ];\n\n        let old_vector = create_old_vector(id, \"PropsVector\", 1, false, props);\n\n        let old_bytes = bincode::serialize(&old_vector).unwrap();\n        let data_bytes = create_vector_bytes(&vec![0.0; 1536]);\n\n        let arena = Bump::new();\n        let new_vector = HVector::from_bincode_bytes(\n            &arena,\n            Some(&old_bytes),\n            &data_bytes,\n            id,\n        ).unwrap();\n\n        assert!(new_vector.properties.is_some());\n        let props = new_vector.properties.unwrap();\n        assert!(props.get(\"model\").is_some());\n        assert!(props.get(\"dimension\").is_some());\n    }\n\n    // ========================================================================\n    // VERSION MIGRATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_version_migration_v0_to_v1_317": {
      "name": "test_node_version_migration_v0_to_v1",
      "type": "function",
      "start_line": 317,
      "end_line": 335,
      "content_hash": "2e9d42075972a50d6cacd4269beb45185eddcc02",
      "content": "    fn test_node_version_migration_v0_to_v1() {\n        let arena1 = Bump::new();\n        let id = 333000u128;\n\n        // Create v0 node\n        let node_v0 = create_arena_node(&arena1, id, \"NodeV0\", 0, vec![]);\n        let bytes = bincode::serialize(&node_v0).unwrap();\n\n        // Deserialize (implicitly treats as current version)\n        let arena2 = Bump::new();\n        let restored = Node::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        assert_eq!(restored.version, 0);\n\n        // Could manually update version in application code\n        // This test demonstrates version field is preserved\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_version_migration_across_versions_336": {
      "name": "test_edge_version_migration_across_versions",
      "type": "function",
      "start_line": 336,
      "end_line": 359,
      "content_hash": "01ab3f2519a26cb9e4173703f27ad0fe91aa72c3",
      "content": "    fn test_edge_version_migration_across_versions() {\n        let arena = Bump::new();\n        let id = 444000u128;\n\n        // Test that different versions can coexist\n        let edge_v0 = create_arena_edge(&arena, id, \"E0\", 0, 1, 2, vec![]);\n        let edge_v1 = create_arena_edge(&arena, id, \"E1\", 1, 1, 2, vec![]);\n        let edge_v5 = create_arena_edge(&arena, id, \"E5\", 5, 1, 2, vec![]);\n\n        let bytes_v0 = bincode::serialize(&edge_v0).unwrap();\n        let bytes_v1 = bincode::serialize(&edge_v1).unwrap();\n        let bytes_v5 = bincode::serialize(&edge_v5).unwrap();\n\n        let arena2 = Bump::new();\n        let restored_v0 = Edge::from_bincode_bytes(id, &bytes_v0, &arena2).unwrap();\n        let restored_v1 = Edge::from_bincode_bytes(id, &bytes_v1, &arena2).unwrap();\n        let restored_v5 = Edge::from_bincode_bytes(id, &bytes_v5, &arena2).unwrap();\n\n        assert_eq!(restored_v0.version, 0);\n        assert_eq!(restored_v1.version, 1);\n        assert_eq!(restored_v5.version, 5);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_version_compatibility_360": {
      "name": "test_vector_version_compatibility",
      "type": "function",
      "start_line": 360,
      "end_line": 395,
      "content_hash": "81aea3ba435b4ad070fa945e2fcf0c08d5bef272",
      "content": "    fn test_vector_version_compatibility() {\n        let arena = Bump::new();\n        let id = 555000u128;\n        let data = vec![1.0, 2.0];\n\n        // Different vector versions\n        let vec_v1 = create_arena_vector(&arena, id, \"V1\", 1, false, 0, &data, vec![]);\n        let vec_v2 = create_arena_vector(&arena, id, \"V2\", 2, false, 0, &data, vec![]);\n\n        let props_v1 = bincode::serialize(&vec_v1).unwrap();\n        let props_v2 = bincode::serialize(&vec_v2).unwrap();\n        let data_bytes = create_vector_bytes(&data);\n\n        let arena2 = Bump::new();\n        let restored_v1 = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_v1),\n            &data_bytes,\n            id,\n        ).unwrap();\n        let restored_v2 = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_v2),\n            &data_bytes,\n            id,\n        ).unwrap();\n\n        assert_eq!(restored_v1.version, 1);\n        assert_eq!(restored_v2.version, 2);\n    }\n\n    // ========================================================================\n    // FORWARD COMPATIBILITY TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_future_version_node_still_deserializes_396": {
      "name": "test_future_version_node_still_deserializes",
      "type": "function",
      "start_line": 396,
      "end_line": 412,
      "content_hash": "97f94112d5992674d8ff461fc890835135769158",
      "content": "    fn test_future_version_node_still_deserializes() {\n        let arena = Bump::new();\n        let id = 666000u128;\n\n        // Simulate \"future\" version (e.g., version 100)\n        let future_node = create_arena_node(&arena, id, \"FutureNode\", 100, vec![]);\n        let bytes = bincode::serialize(&future_node).unwrap();\n\n        // Current code should still deserialize it\n        let arena2 = Bump::new();\n        let restored = Node::from_bincode_bytes(id, &bytes, &arena2);\n\n        assert!(restored.is_ok(), \"Should handle future versions gracefully\");\n        assert_eq!(restored.unwrap().version, 100);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unknown_property_types_preserved_413": {
      "name": "test_unknown_property_types_preserved",
      "type": "function",
      "start_line": 413,
      "end_line": 441,
      "content_hash": "48d9ab6fb675cdebb7d193b9cd94e55674cc07ad",
      "content": "    fn test_unknown_property_types_preserved() {\n        let id = 777000u128;\n\n        // Old node with various Value types\n        let old_node = create_old_node(\n            id,\n            \"UnknownTypes\",\n            0,\n            vec![\n                (\"known\", Value::String(\"value\".to_string())),\n                (\"i64_max\", Value::I64(i64::MAX)),\n                (\"u128\", Value::U128(u128::MAX)),\n            ],\n        );\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        // Properties should be preserved even if we add new Value variants\n        assert!(new_node.properties.is_some());\n    }\n\n    // ========================================================================\n    // MIXED VERSION BATCH TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_batch_with_mixed_versions_442": {
      "name": "test_batch_with_mixed_versions",
      "type": "function",
      "start_line": 442,
      "end_line": 467,
      "content_hash": "46fc88d863726097e0b77a23b1a85a95ae992b49",
      "content": "    fn test_batch_with_mixed_versions() {\n        let arena = Bump::new();\n\n        // Create nodes with different versions\n        let nodes: Vec<(u128, u8, Node)> = vec![\n            (1, 0, create_arena_node(&arena, 1, \"N0\", 0, vec![])),\n            (2, 1, create_arena_node(&arena, 2, \"N1\", 1, vec![])),\n            (3, 2, create_arena_node(&arena, 3, \"N2\", 2, vec![])),\n            (4, 0, create_arena_node(&arena, 4, \"N0b\", 0, vec![])),\n        ];\n\n        // Serialize all\n        let serialized: Vec<(u128, u8, Vec<u8>)> = nodes\n            .iter()\n            .map(|(id, ver, node)| (*id, *ver, bincode::serialize(node).unwrap()))\n            .collect();\n\n        // Deserialize all\n        let arena2 = Bump::new();\n        for (id, expected_ver, bytes) in serialized {\n            let restored = Node::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n            assert_eq!(restored.version, expected_ver);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_and_new_formats_coexist_468": {
      "name": "test_old_and_new_formats_coexist",
      "type": "function",
      "start_line": 468,
      "end_line": 504,
      "content_hash": "c916985ba4d5c41a382a48a57f7d507a01aadda2",
      "content": "    fn test_old_and_new_formats_coexist() {\n        // Simulate database with both old and new format data\n\n        // Old format node\n        let old_node = create_old_node(\n            1,\n            \"OldFormat\",\n            0,\n            vec![(\"data\", Value::String(\"old\".to_string()))],\n        );\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        // New format node\n        let arena_new = Bump::new();\n        let new_node = create_arena_node(\n            &arena_new,\n            2,\n            \"NewFormat\",\n            1,\n            vec![(\"data\", Value::String(\"new\".to_string()))],\n        );\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Both should deserialize correctly\n        let arena_restore = Bump::new();\n        let restored_old = Node::from_bincode_bytes(1, &old_bytes, &arena_restore).unwrap();\n        let restored_new = Node::from_bincode_bytes(2, &new_bytes, &arena_restore).unwrap();\n\n        assert_eq!(restored_old.label, \"OldFormat\");\n        assert_eq!(restored_new.label, \"NewFormat\");\n    }\n\n    // ========================================================================\n    // PROPERTY MAP EVOLUTION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hashmap_to_immutable_map_preserves_order_505": {
      "name": "test_hashmap_to_immutable_map_preserves_order",
      "type": "function",
      "start_line": 505,
      "end_line": 530,
      "content_hash": "a223505109a5b631c5ae4d13c4af577939fe381d",
      "content": "    fn test_hashmap_to_immutable_map_preserves_order() {\n        let id = 888000u128;\n\n        // Note: HashMap doesn't guarantee order, but all keys should be present\n        let props = vec![\n            (\"z_last\", Value::I32(1)),\n            (\"a_first\", Value::I32(2)),\n            (\"m_middle\", Value::I32(3)),\n        ];\n\n        let old_node = create_old_node(id, \"OrderTest\", 0, props);\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        let new_props = new_node.properties.unwrap();\n        assert_eq!(new_props.len(), 3);\n\n        // All keys should be present (order may differ)\n        assert!(new_props.get(\"z_last\").is_some());\n        assert!(new_props.get(\"a_first\").is_some());\n        assert!(new_props.get(\"m_middle\").is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_property_value_types_preserved_across_migration_531": {
      "name": "test_property_value_types_preserved_across_migration",
      "type": "function",
      "start_line": 531,
      "end_line": 561,
      "content_hash": "6b211edb2a2e4ba6f081642b2028457dec67e1c3",
      "content": "    fn test_property_value_types_preserved_across_migration() {\n        let id = 999000u128;\n\n        let props = vec![\n            (\"str\", Value::String(\"text\".to_string())),\n            (\"int\", Value::I64(42)),\n            (\"float\", Value::F64(3.14)),\n            (\"bool\", Value::Boolean(true)),\n            (\"empty\", Value::Empty),\n        ];\n\n        let old_edge = create_old_edge(id, \"TypePreserve\", 0, 1, 2, props);\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        let new_props = new_edge.properties.unwrap();\n\n        // Verify each type is preserved\n        match new_props.get(\"str\").unwrap() {\n            Value::String(s) => assert_eq!(s, \"text\"),\n            _ => panic!(\"String type not preserved\"),\n        }\n\n        match new_props.get(\"int\").unwrap() {\n            Value::I64(i) => assert_eq!(*i, 42),\n            _ => panic!(\"I64 type not preserved\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}