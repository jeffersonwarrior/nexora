{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/gateway.rs",
  "file_hash": "264b823d1bd0ee956bb93982bb5c38d30aec8ef5",
  "updated_at": "2025-12-26T17:34:19.955194",
  "symbols": {
    "struct_GatewayOpts_30": {
      "name": "GatewayOpts",
      "type": "struct",
      "start_line": 30,
      "end_line": 31,
      "content_hash": "c412728edac2a338e238ec97da82d1a7679ce88f",
      "content": "pub struct GatewayOpts {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_GatewayOpts_32": {
      "name": "GatewayOpts",
      "type": "impl",
      "start_line": 32,
      "end_line": 35,
      "content_hash": "2dc6f6147dbb2fccbd12f00b39209c9477c55760",
      "content": "impl GatewayOpts {\n    pub const DEFAULT_WORKERS_PER_CORE: usize = 8;\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HelixGateway_36": {
      "name": "HelixGateway",
      "type": "struct",
      "start_line": 36,
      "end_line": 44,
      "content_hash": "7664e595d9b9b7d7f28dbb268269f961d52d4dbb",
      "content": "pub struct HelixGateway {\n    pub(crate) address: String,\n    pub(crate) workers_per_core: usize,\n    pub(crate) graph_access: Arc<HelixGraphEngine>,\n    pub(crate) router: Arc<HelixRouter>,\n    pub(crate) opts: Option<HelixGraphEngineOpts>,\n    pub(crate) cluster_id: Option<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixGateway_45": {
      "name": "HelixGateway",
      "type": "impl",
      "start_line": 45,
      "end_line": 45,
      "content_hash": "d39d7fed2a9ad0b6d95d6b7059cd5736810bdf21",
      "content": "impl HelixGateway {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_46": {
      "name": "new",
      "type": "method",
      "start_line": 46,
      "end_line": 66,
      "content_hash": "96076719e4fb47c4894bc49f27d0d527a8103e9f",
      "content": "    pub fn new(\n        address: &str,\n        graph_access: Arc<HelixGraphEngine>,\n        workers_per_core: usize,\n        routes: Option<HashMap<String, HandlerFn>>,\n        mcp_routes: Option<HashMap<String, MCPHandlerFn>>,\n        write_routes: Option<HashSet<String>>,\n        opts: Option<HelixGraphEngineOpts>,\n    ) -> HelixGateway {\n        let router = Arc::new(HelixRouter::new(routes, mcp_routes, write_routes));\n        let cluster_id = std::env::var(\"CLUSTER_ID\").ok();\n        HelixGateway {\n            address: address.to_string(),\n            graph_access,\n            router,\n            workers_per_core,\n            opts,\n            cluster_id,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_67": {
      "name": "run",
      "type": "method",
      "start_line": 67,
      "end_line": 224,
      "content_hash": "848a830e3f664932d18959a08bb4ccb629bf8078",
      "content": "    pub fn run(self) -> Result<(), Box<dyn std::error::Error>> {\n        trace!(\"Starting Helix Gateway\");\n\n        let all_core_ids = core_affinity::get_core_ids().expect(\"unable to get core IDs\");\n\n        let tokio_core_ids = all_core_ids.clone();\n        let tokio_core_setter = Arc::new(CoreSetter::new(tokio_core_ids, 1));\n\n        let rt = Arc::new(\n            tokio::runtime::Builder::new_multi_thread()\n                .worker_threads(tokio_core_setter.num_threads())\n                .on_thread_unpark(move || Arc::clone(&tokio_core_setter).set_current_once())\n                .enable_all()\n                .build()?,\n        );\n\n        let worker_core_ids = all_core_ids.clone();\n        let worker_core_setter = Arc::new(CoreSetter::new(worker_core_ids, self.workers_per_core));\n\n        let worker_pool = WorkerPool::new(\n            worker_core_setter,\n            Arc::clone(&self.graph_access),\n            Arc::clone(&self.router),\n            Arc::clone(&rt),\n        );\n\n        let mut axum_app = axum::Router::new();\n\n        axum_app = axum_app\n            .route(\"/{*path}\", post(post_handler))\n            .route(\"/introspect\", get(introspect_schema_handler));\n\n        #[cfg(feature = \"dev-instance\")]\n        {\n            axum_app = axum_app\n                .route(\"/nodes-edges\", get(nodes_edges_handler))\n                .route(\"/nodes-by-label\", get(nodes_by_label_handler))\n                .route(\"/node-connections\", get(node_connections_handler))\n                .route(\"/node-details\", get(node_details_handler));\n        }\n\n        let axum_app = axum_app.with_state(Arc::new(AppState {\n            worker_pool,\n            schema_json: self.opts.and_then(|o| o.config.schema),\n            cluster_id: self.cluster_id,\n        }));\n\n        rt.block_on(async move {\n            // Initialize metrics system\n            helix_metrics::init_metrics_system();\n\n            let listener = tokio::net::TcpListener::bind(self.address)\n                .await\n                .expect(\"Failed to bind listener\");\n            info!(\"Listener has been bound, starting server\");\n            axum::serve(listener, axum_app)\n                .with_graceful_shutdown(shutdown_signal())\n                .await\n                .expect(\"Failed to serve\");\n\n            // Shutdown metrics system to flush all pending events\n            info!(\"Shutting down metrics system...\");\n            let shutdown_result = tokio::time::timeout(\n                std::time::Duration::from_secs(5),\n                helix_metrics::shutdown_metrics_system(),\n            )\n            .await;\n\n            match shutdown_result {\n                Ok(_) => info!(\"Metrics system shutdown complete\"),\n                Err(_) => warn!(\"Metrics system shutdown timed out after 5 seconds\"),\n            }\n        });\n\n        Ok(())\n    }\n}\n\nasync fn shutdown_signal() {\n    // Respond to either Ctrl-C (SIGINT) or SIGTERM (e.g. `kill` or systemd stop)\n    #[cfg(unix)]\n    {\n        tokio::select! {\n            _ = tokio::signal::ctrl_c() => {\n                info!(\"Received Ctrl-C, starting graceful shutdown\u2026\");\n            }\n            _ = sigterm() => {\n                info!(\"Received SIGTERM, starting graceful shutdown\u2026\");\n            }\n        }\n    }\n    #[cfg(not(unix))]\n    {\n        let _ = tokio::signal::ctrl_c().await;\n        info!(\"Received Ctrl-C, starting graceful shutdown\u2026\");\n    }\n}\n\n#[cfg(unix)]\nasync fn sigterm() {\n    use tokio::signal::unix::{SignalKind, signal};\n    let mut term = signal(SignalKind::terminate()).expect(\"install SIGTERM handler\");\n    term.recv().await;\n}\n\nasync fn post_handler(\n    State(state): State<Arc<AppState>>,\n    req: protocol::request::Request,\n) -> axum::http::Response<Body> {\n    let start_time = Instant::now();\n    #[cfg(feature = \"api-key\")]\n    {\n        use crate::helix_gateway::key_verification::verify_key;\n        if let Err(e) = verify_key(req.api_key.as_ref().unwrap()) {\n            info!(?e, \"Invalid API key\");\n            helix_metrics::log_event(\n                helix_metrics::events::EventType::InvalidApiKey,\n                helix_metrics::events::InvalidApiKeyEvent {\n                    cluster_id: state.cluster_id.clone(),\n                    time_taken_usec: start_time.elapsed().as_micros() as u32,\n                },\n            );\n            return e.into_response();\n        }\n    }\n    let body = req.body.to_vec();\n    let query_name = req.name.clone();\n    let res = state.worker_pool.process(req).await;\n\n    match res {\n        Ok(r) => {\n            helix_metrics::log_event(\n                helix_metrics::events::EventType::QuerySuccess,\n                helix_metrics::events::QuerySuccessEvent {\n                    cluster_id: state.cluster_id.clone(),\n                    query_name,\n                    time_taken_usec: start_time.elapsed().as_micros() as u32,\n                },\n            );\n            r.into_response()\n        }\n        Err(e) => {\n            info!(?e, \"Got error\");\n            helix_metrics::log_event(\n                helix_metrics::events::EventType::QueryError,\n                helix_metrics::events::QueryErrorEvent {\n                    cluster_id: state.cluster_id.clone(),\n                    query_name,\n                    input_json: sonic_rs::to_string(&body).ok(),\n                    output_json: Some(format!(r#\"{{\"error\":\"{e}\"}}\"#)),\n                    time_taken_usec: start_time.elapsed().as_micros() as u32,\n                },\n            );\n            e.into_response()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AppState_225": {
      "name": "AppState",
      "type": "struct",
      "start_line": 225,
      "end_line": 230,
      "content_hash": "f12e7fef264cb2a06d6bbfd8e539667be8c31200",
      "content": "pub struct AppState {\n    pub worker_pool: WorkerPool,\n    pub schema_json: Option<String>,\n    pub cluster_id: Option<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CoreSetter_231": {
      "name": "CoreSetter",
      "type": "struct",
      "start_line": 231,
      "end_line": 236,
      "content_hash": "4f376550816977ab07c53d52b39e1187b99bff48",
      "content": "pub struct CoreSetter {\n    pub(crate) cores: Vec<CoreId>,\n    pub(crate) threads_per_core: usize,\n    pub(crate) incrementing_index: AtomicUsize,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_CoreSetter_237": {
      "name": "CoreSetter",
      "type": "impl",
      "start_line": 237,
      "end_line": 237,
      "content_hash": "55317a1a5009f071731215ba67b75b5dd50818cb",
      "content": "impl CoreSetter {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_238": {
      "name": "new",
      "type": "method",
      "start_line": 238,
      "end_line": 245,
      "content_hash": "32a10a1a9dc95cbaa2debb06b0c1b9dd274013e0",
      "content": "    pub fn new(cores: Vec<CoreId>, threads_per_core: usize) -> Self {\n        Self {\n            cores,\n            threads_per_core,\n            incrementing_index: AtomicUsize::new(0),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_num_threads_246": {
      "name": "num_threads",
      "type": "method",
      "start_line": 246,
      "end_line": 249,
      "content_hash": "5ade7c2d4e7c3fdb5fba478ee88654d2322a9eee",
      "content": "    pub fn num_threads(&self) -> usize {\n        self.cores.len() * self.threads_per_core\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_current_250": {
      "name": "set_current",
      "type": "method",
      "start_line": 250,
      "end_line": 266,
      "content_hash": "1988f85b18d445b1d19b47feebbb62d34f7ca61a",
      "content": "    pub fn set_current(self: Arc<Self>) {\n        let curr_idx = self\n            .incrementing_index\n            .fetch_add(1, atomic::Ordering::SeqCst);\n\n        let core_index = curr_idx / self.threads_per_core;\n        match self.cores.get(core_index) {\n            Some(c) => {\n                core_affinity::set_for_current(*c);\n                trace!(\"Set core affinity to: {c:?}\");\n            }\n            None => warn!(\n                \"CoreSetter::set_current called more times than cores.len() * threads_per_core. Core affinity not set\"\n            ),\n        };\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_current_once_267": {
      "name": "set_current_once",
      "type": "method",
      "start_line": 267,
      "end_line": 278,
      "content_hash": "72543913a773d30b74bf476027408fc9640a2c0b",
      "content": "    pub fn set_current_once(self: Arc<Self>) {\n        use std::sync::OnceLock;\n\n        thread_local! {\n            static CORE_SET: OnceLock<()> = const { OnceLock::new() };\n        }\n\n        CORE_SET.with(|flag| {\n            flag.get_or_init(move || self.set_current());\n        });\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}