{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/github_issue.rs",
  "file_hash": "3f594e7844aad97c8544a6fe51d7e60d31973712",
  "updated_at": "2025-12-26T17:34:21.497757",
  "symbols": {
    "struct_GitHubIssueBuilder_19": {
      "name": "GitHubIssueBuilder",
      "type": "struct",
      "start_line": 19,
      "end_line": 26,
      "content_hash": "749933771f04202230d2aa1414a243b2b92daf77",
      "content": "pub struct GitHubIssueBuilder {\n    cargo_errors: String,\n    hx_content: Option<String>,\n    generated_rust: Option<String>,\n    error_line_refs: Vec<usize>,\n    first_error: Option<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_GitHubIssueBuilder_27": {
      "name": "GitHubIssueBuilder",
      "type": "impl",
      "start_line": 27,
      "end_line": 28,
      "content_hash": "3ef3c34eda53cdb1e4c87380ceb4df6c4f73fe46",
      "content": "impl GitHubIssueBuilder {\n    /// Create a new issue builder with cargo error output.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_29": {
      "name": "new",
      "type": "method",
      "start_line": 29,
      "end_line": 41,
      "content_hash": "81cbb1d51f81c1231e550588f1a51186174c6093",
      "content": "    pub fn new(cargo_errors: String) -> Self {\n        let error_line_refs = parse_error_line_numbers(&cargo_errors);\n        let first_error = extract_first_error(&cargo_errors);\n        Self {\n            cargo_errors,\n            hx_content: None,\n            generated_rust: None,\n            error_line_refs,\n            first_error,\n        }\n    }\n\n    /// Add the full .hx file contents.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_hx_content_42": {
      "name": "with_hx_content",
      "type": "method",
      "start_line": 42,
      "end_line": 47,
      "content_hash": "9c1e296cec3753979d8e7ac239aec9b20204d731",
      "content": "    pub fn with_hx_content(mut self, content: String) -> Self {\n        self.hx_content = Some(content);\n        self\n    }\n\n    /// Add the generated Rust code.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_generated_rust_48": {
      "name": "with_generated_rust",
      "type": "method",
      "start_line": 48,
      "end_line": 53,
      "content_hash": "63dcce16e1a541eb7f2216f37f25b718b78480b3",
      "content": "    pub fn with_generated_rust(mut self, rust_code: String) -> Self {\n        self.generated_rust = Some(rust_code);\n        self\n    }\n\n    /// Build the GitHub issue URL with query parameters.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_build_url_54": {
      "name": "build_url",
      "type": "method",
      "start_line": 54,
      "end_line": 94,
      "content_hash": "94bd7ea6d8db435ca56e7478c83d6938c4f5f503",
      "content": "    pub fn build_url(&self) -> String {\n        let title = match &self.first_error {\n            Some(error) => format!(\"bug (hql): rust generation failure - {}\", error),\n            None => \"bug (hql): rust generation failure\".to_string(),\n        };\n\n        // URL encode the fixed parameters\n        let encoded_title = urlencoding::encode(&title);\n        let encoded_labels = urlencoding::encode(\"bug,cli\");\n        let encoded_type = urlencoding::encode(\"Bug\");\n\n        // Calculate the URL overhead (everything except the body)\n        // Format: {base}?type={type}&title={title}&body={body}&labels={labels}\n        let url_overhead = GITHUB_ISSUE_URL.len()\n            + \"?type=&title=&body=&labels=\".len()\n            + encoded_type.len()\n            + encoded_title.len()\n            + encoded_labels.len();\n\n        let max_body_encoded_len = MAX_URL_LENGTH.saturating_sub(url_overhead);\n\n        // First try the full body\n        let body = self.build_body();\n        let body_encoded_len = urlencoding::encoded_len(&body);\n\n        let final_body = if body_encoded_len <= max_body_encoded_len {\n            body\n        } else {\n            // Need to truncate - use adaptive truncation based on available space\n            self.build_truncated_body_to_fit(max_body_encoded_len)\n        };\n\n        let encoded_body = urlencoding::encode(&final_body);\n\n        format!(\n            \"{}?type={}&title={}&body={}&labels={}\",\n            GITHUB_ISSUE_URL, encoded_type, encoded_title, encoded_body, encoded_labels\n        )\n    }\n\n    /// Open the issue URL in the default browser.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_open_in_browser_95": {
      "name": "open_in_browser",
      "type": "method",
      "start_line": 95,
      "end_line": 100,
      "content_hash": "f7a56a98baadd3f476ad47c459553ca0cb09f756",
      "content": "    pub fn open_in_browser(&self) -> Result<()> {\n        let url = self.build_url();\n        open::that(&url).map_err(|e| eyre::eyre!(\"Failed to open browser: {}\", e))\n    }\n\n    /// Build the full issue body.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_build_body_101": {
      "name": "build_body",
      "type": "method",
      "start_line": 101,
      "end_line": 142,
      "content_hash": "3a0fcc66bf276a7d57f6c67589cd17d018b90eb7",
      "content": "    fn build_body(&self) -> String {\n        let mut body = String::new();\n\n        // Environment section\n        body.push_str(\"## Environment\\n\");\n        body.push_str(&format!(\n            \"- Helix CLI version: {}\\n\",\n            env!(\"CARGO_PKG_VERSION\")\n        ));\n        body.push_str(&format!(\"- OS: {}\\n\\n\", std::env::consts::OS));\n\n        // Error output section\n        body.push_str(\"## Error Output\\n\");\n        body.push_str(\"```\\n\");\n        body.push_str(&self.cargo_errors);\n        body.push_str(\"\\n```\\n\\n\");\n\n        // Schema/Queries section\n        if let Some(hx_content) = &self.hx_content {\n            body.push_str(\"## Schema/Queries (.hx files)\\n\");\n            body.push_str(\"```helix\\n\");\n            body.push_str(hx_content);\n            body.push_str(\"\\n```\\n\\n\");\n        }\n\n        // Relevant Generated Rust Code section\n        if let Some(rust_code) = &self.generated_rust {\n            let relevant_rust = self.extract_relevant_rust_lines(rust_code);\n            if !relevant_rust.is_empty() {\n                body.push_str(\"## Relevant Generated Rust Code\\n\");\n                body.push_str(\"<details>\\n<summary>Click to expand</summary>\\n\\n\");\n                body.push_str(\"```rust\\n\");\n                body.push_str(&relevant_rust);\n                body.push_str(\"\\n```\\n</details>\\n\");\n            }\n        }\n\n        body\n    }\n\n    /// Build a truncated body that fits within the specified encoded length limit.\n    /// Uses adaptive truncation to maximize content while staying under the limit.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_build_truncated_body_to_fit_143": {
      "name": "build_truncated_body_to_fit",
      "type": "method",
      "start_line": 143,
      "end_line": 221,
      "content_hash": "9142d1704306844f26fc80b8f385ae2525dbbd38",
      "content": "    fn build_truncated_body_to_fit(&self, max_encoded_len: usize) -> String {\n        // Start with aggressive truncation limits and adjust if needed\n        // We use conservative estimates: assume ~2x expansion for URL encoding on average\n        // (actual expansion varies from 1x for alphanumeric to 3x for special chars)\n\n        // Reserve space for the fixed template parts (markdown headers, code fences, etc.)\n        // These are mostly alphanumeric so they encode ~1:1\n        let template_overhead = 300; // Conservative estimate for markdown structure\n        let available_for_content = max_encoded_len.saturating_sub(template_overhead);\n\n        // Divide available space among sections (errors get priority, then schema)\n        // Use ~2.5x divisor to account for URL encoding expansion\n        let max_error_chars = (available_for_content / 3).min(1500);\n        let max_hx_chars = (available_for_content / 4).min(1000);\n\n        let mut body = String::new();\n\n        // Environment section (always include - small and important)\n        body.push_str(\"## Environment\\n\");\n        body.push_str(&format!(\n            \"- Helix CLI version: {}\\n\",\n            env!(\"CARGO_PKG_VERSION\")\n        ));\n        body.push_str(&format!(\"- OS: {}\\n\\n\", std::env::consts::OS));\n\n        // Error output section (truncated)\n        body.push_str(\"## Error Output\\n\");\n        body.push_str(\"```\\n\");\n        let truncated_errors: String = self.cargo_errors.chars().take(max_error_chars).collect();\n        body.push_str(&truncated_errors);\n        if self.cargo_errors.chars().count() > max_error_chars {\n            body.push_str(\"\\n... [truncated]\");\n        }\n        body.push_str(\"\\n```\\n\\n\");\n\n        // Check if we still have room for schema content\n        let current_encoded_len = urlencoding::encoded_len(&body);\n        if current_encoded_len < max_encoded_len {\n            let remaining = max_encoded_len.saturating_sub(current_encoded_len);\n            let actual_max_hx = (remaining / 3).min(max_hx_chars);\n\n            // Schema/Queries section (truncated)\n            if let Some(hx_content) = &self.hx_content\n                && actual_max_hx > 100\n            {\n                // Only include if we have reasonable space\n                body.push_str(\"## Schema/Queries (.hx files)\\n\");\n                body.push_str(\"```helix\\n\");\n                let truncated_hx: String = hx_content.chars().take(actual_max_hx).collect();\n                body.push_str(&truncated_hx);\n                if hx_content.chars().count() > actual_max_hx {\n                    body.push_str(\"\\n... [truncated]\");\n                }\n                body.push_str(\"\\n```\\n\\n\");\n            }\n        }\n\n        body.push_str(\"_Note: Content truncated due to URL length limits. Please add full details manually._\\n\");\n\n        // Final safety check - if still too long, do emergency truncation\n        let final_encoded_len = urlencoding::encoded_len(&body);\n        if final_encoded_len > max_encoded_len {\n            // Emergency: just return minimal body\n            let mut minimal = String::new();\n            minimal.push_str(\"## Environment\\n\");\n            minimal.push_str(&format!(\n                \"- Helix CLI version: {}\\n\",\n                env!(\"CARGO_PKG_VERSION\")\n            ));\n            minimal.push_str(&format!(\"- OS: {}\\n\\n\", std::env::consts::OS));\n            minimal.push_str(\"## Error\\n\");\n            minimal.push_str(\"Content too large for URL. Please describe the issue manually.\\n\");\n            return minimal;\n        }\n\n        body\n    }\n\n    /// Extract only the Rust lines referenced in error messages, plus context.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_relevant_rust_lines_222": {
      "name": "extract_relevant_rust_lines",
      "type": "method",
      "start_line": 222,
      "end_line": 281,
      "content_hash": "de6dbe640ba017b2b59358cfa74a365fffb07f47",
      "content": "    fn extract_relevant_rust_lines(&self, rust_code: &str) -> String {\n        if self.error_line_refs.is_empty() {\n            // If no line references found, return first 100 lines\n            return rust_code\n                .lines()\n                .take(100)\n                .enumerate()\n                .map(|(i, line)| format!(\"{:4} | {}\", i + 1, line))\n                .collect::<Vec<_>>()\n                .join(\"\\n\");\n        }\n\n        let lines: Vec<&str> = rust_code.lines().collect();\n        let total_lines = lines.len();\n\n        // Collect all line numbers we want to include (with context)\n        let mut included_lines: HashSet<usize> = HashSet::new();\n        for &error_line in &self.error_line_refs {\n            let start = error_line.saturating_sub(CONTEXT_LINES);\n            let end = (error_line + CONTEXT_LINES).min(total_lines);\n            for line_num in start..=end {\n                if line_num > 0 && line_num <= total_lines {\n                    included_lines.insert(line_num);\n                }\n            }\n        }\n\n        // Sort and output with line numbers\n        let mut sorted_lines: Vec<usize> = included_lines.into_iter().collect();\n        sorted_lines.sort();\n\n        let mut result = String::new();\n        let mut last_line: Option<usize> = None;\n\n        for line_num in sorted_lines {\n            // Add separator if there's a gap\n            if let Some(last) = last_line\n                && line_num > last + 1\n            {\n                result.push_str(\"     ...\\n\");\n            }\n\n            // Line numbers are 1-indexed, array is 0-indexed\n            if let Some(line_content) = lines.get(line_num - 1) {\n                let marker = if self.error_line_refs.contains(&line_num) {\n                    \">>>\"\n                } else {\n                    \"   \"\n                };\n                result.push_str(&format!(\"{} {:4} | {}\\n\", marker, line_num, line_content));\n            }\n\n            last_line = Some(line_num);\n        }\n\n        result\n    }\n}\n\n/// Parse cargo error output to extract line numbers from queries.rs errors.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_error_line_numbers_282": {
      "name": "parse_error_line_numbers",
      "type": "method",
      "start_line": 282,
      "end_line": 299,
      "content_hash": "b5580eedb7224f3b6df58be7ac72da46f815a6b3",
      "content": "fn parse_error_line_numbers(cargo_output: &str) -> Vec<usize> {\n    // Match patterns like:\n    // --> src/queries.rs:42:5\n    // --> src/queries.rs:123:10\n    let re = Regex::new(r\"-->\\s+[^:]+/queries\\.rs:(\\d+):\\d+\").unwrap();\n\n    let mut line_numbers: Vec<usize> = re\n        .captures_iter(cargo_output)\n        .filter_map(|cap| cap.get(1).and_then(|m| m.as_str().parse().ok()))\n        .collect();\n\n    line_numbers.sort();\n    line_numbers.dedup();\n    line_numbers\n}\n\n/// Extract the first error code and message from cargo output.\n/// Returns something like \"error[E0308]: mismatched types\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_first_error_300": {
      "name": "extract_first_error",
      "type": "method",
      "start_line": 300,
      "end_line": 312,
      "content_hash": "4088511fc592287de7ba28a8c9b2cd48694e9a07",
      "content": "fn extract_first_error(cargo_output: &str) -> Option<String> {\n    // Match patterns like:\n    // error[E0308]: mismatched types\n    // error[E0425]: cannot find value `foo` in this scope\n    let re = Regex::new(r\"(error\\[E\\d+\\]: [^\\n]+)\").unwrap();\n\n    re.captures(cargo_output)\n        .and_then(|cap| cap.get(1))\n        .map(|m| m.as_str().to_string())\n}\n\n/// Filter cargo output to include only errors (not warnings).\n/// Preserves full error context including code snippets and line numbers.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_filter_errors_only_313": {
      "name": "filter_errors_only",
      "type": "method",
      "start_line": 313,
      "end_line": 386,
      "content_hash": "e836b1fb09c12fcd02981536ff336494d88cb341",
      "content": "pub fn filter_errors_only(cargo_output: &str) -> String {\n    let mut result = String::new();\n    let mut in_error_block = false;\n    let lines: Vec<&str> = cargo_output.lines().collect();\n\n    for (i, line) in lines.iter().enumerate() {\n        // Check if this is the start of an error block\n        if line.starts_with(\"error[\") || line.starts_with(\"error:\") {\n            in_error_block = true;\n            result.push_str(line);\n            result.push('\\n');\n        } else if line.starts_with(\"warning[\") || line.starts_with(\"warning:\") {\n            // Start of warning block - skip\n            in_error_block = false;\n        } else if line.trim().starts_with(\"= note:\") && in_error_block {\n            // Include notes that are part of error blocks\n            result.push_str(line);\n            result.push('\\n');\n        } else if line.trim().starts_with(\"= help:\") && in_error_block {\n            // Include help messages that are part of error blocks\n            result.push_str(line);\n            result.push('\\n');\n        } else if in_error_block {\n            // Check if this line ends the error block\n            // Error blocks end at blank lines followed by another error/warning, or at EOF\n            let is_blank = line.trim().is_empty();\n            let next_starts_new_block = lines\n                .get(i + 1)\n                .map(|next| {\n                    next.starts_with(\"error[\")\n                        || next.starts_with(\"error:\")\n                        || next.starts_with(\"warning[\")\n                        || next.starts_with(\"warning:\")\n                        || next.starts_with(\"For more information\")\n                })\n                .unwrap_or(true);\n\n            if is_blank && next_starts_new_block {\n                // End of error block\n                in_error_block = false;\n                result.push('\\n');\n            } else {\n                // Continue error block\n                result.push_str(line);\n                result.push('\\n');\n            }\n        }\n        // Skip warning blocks entirely\n    }\n\n    // If result is empty or only has summary lines, return the full output\n    // (better to have too much info than too little)\n    let trimmed = result.trim();\n    if trimmed.is_empty()\n        || (trimmed.starts_with(\"error: could not compile\") && !trimmed.contains(\"-->\"))\n    {\n        // Filter out just warning lines from full output\n        return cargo_output\n            .lines()\n            .filter(|line| !line.starts_with(\"warning\"))\n            .filter(|line| !line.trim().starts_with(\"= note: `#[warn\"))\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n            .trim()\n            .to_string();\n    }\n\n    result.trim().to_string()\n}\n\n/// Generic builder for creating GitHub issue URLs with any content.\n///\n/// This is a simpler builder for general-purpose issue creation (like feedback).\n/// For compile error issues, use `GitHubIssueBuilder` instead.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GitHubIssueUrlBuilder_387": {
      "name": "GitHubIssueUrlBuilder",
      "type": "struct",
      "start_line": 387,
      "end_line": 393,
      "content_hash": "2d3023a3136fa4eea313842d526f400a4eb21934",
      "content": "pub struct GitHubIssueUrlBuilder {\n    title: String,\n    body: String,\n    labels: String,\n    issue_type: String,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_GitHubIssueUrlBuilder_394": {
      "name": "GitHubIssueUrlBuilder",
      "type": "impl",
      "start_line": 394,
      "end_line": 395,
      "content_hash": "bc3d07b5f425a3a9afb2bcbf9be18b89304a33f7",
      "content": "impl GitHubIssueUrlBuilder {\n    /// Create a new URL builder with the given title.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_396": {
      "name": "new",
      "type": "method",
      "start_line": 396,
      "end_line": 405,
      "content_hash": "3f0d08b1e44faa68584f954d44d450b190659903",
      "content": "    pub fn new(title: impl Into<String>) -> Self {\n        Self {\n            title: title.into(),\n            body: String::new(),\n            labels: String::new(),\n            issue_type: String::new(),\n        }\n    }\n\n    /// Set the issue body content.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_body_406": {
      "name": "body",
      "type": "method",
      "start_line": 406,
      "end_line": 411,
      "content_hash": "e2fa8c1b2ad277e85885e2f4ed2f4e54a662a6ba",
      "content": "    pub fn body(mut self, body: impl Into<String>) -> Self {\n        self.body = body.into();\n        self\n    }\n\n    /// Set the issue labels (comma-separated).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_labels_412": {
      "name": "labels",
      "type": "method",
      "start_line": 412,
      "end_line": 417,
      "content_hash": "128cabf64b0b59a807860283defd1156939ecbd7",
      "content": "    pub fn labels(mut self, labels: impl Into<String>) -> Self {\n        self.labels = labels.into();\n        self\n    }\n\n    /// Set the issue type (Bug, Feature, etc.).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_issue_type_418": {
      "name": "issue_type",
      "type": "method",
      "start_line": 418,
      "end_line": 423,
      "content_hash": "9dda39fa3ab23f45ec09abc010a5348c209bbb8c",
      "content": "    pub fn issue_type(mut self, issue_type: impl Into<String>) -> Self {\n        self.issue_type = issue_type.into();\n        self\n    }\n\n    /// Build the GitHub issue URL with proper truncation.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_build_url_424": {
      "name": "build_url",
      "type": "method",
      "start_line": 424,
      "end_line": 454,
      "content_hash": "c319efb16a34d962a957bc39b4319c5298c80439",
      "content": "    pub fn build_url(&self) -> String {\n        let encoded_title = urlencoding::encode(&self.title);\n        let encoded_labels = urlencoding::encode(&self.labels);\n        let encoded_type = urlencoding::encode(&self.issue_type);\n\n        // Calculate the URL overhead (everything except the body)\n        let url_overhead = GITHUB_ISSUE_URL.len()\n            + \"?type=&title=&body=&labels=\".len()\n            + encoded_type.len()\n            + encoded_title.len()\n            + encoded_labels.len();\n\n        let max_body_encoded_len = MAX_URL_LENGTH.saturating_sub(url_overhead);\n\n        // Check if body fits, truncate if needed\n        let body_encoded_len = urlencoding::encoded_len(&self.body);\n        let final_body = if body_encoded_len <= max_body_encoded_len {\n            self.body.clone()\n        } else {\n            self.truncate_body_to_fit(max_body_encoded_len)\n        };\n\n        let encoded_body = urlencoding::encode(&final_body);\n\n        format!(\n            \"{}?type={}&title={}&body={}&labels={}\",\n            GITHUB_ISSUE_URL, encoded_type, encoded_title, encoded_body, encoded_labels\n        )\n    }\n\n    /// Truncate the body to fit within the encoded length limit.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_truncate_body_to_fit_455": {
      "name": "truncate_body_to_fit",
      "type": "method",
      "start_line": 455,
      "end_line": 481,
      "content_hash": "984883ac4a6ef3b37eeb64bf230259f371680ea3",
      "content": "    fn truncate_body_to_fit(&self, max_encoded_len: usize) -> String {\n        // Use conservative estimate: ~2.5x expansion for URL encoding\n        let approx_max_chars = max_encoded_len / 3;\n\n        let mut truncated: String = self.body.chars().take(approx_max_chars).collect();\n\n        // Verify and adjust if still too long\n        while urlencoding::encoded_len(&truncated) > max_encoded_len && !truncated.is_empty() {\n            // Remove 10% of remaining chars\n            let new_len = (truncated.chars().count() * 9) / 10;\n            truncated = truncated.chars().take(new_len).collect();\n        }\n\n        if truncated.len() < self.body.len() {\n            truncated.push_str(\"\\n\\n_[Content truncated due to URL length limits]_\");\n\n            // Final check - if the note itself pushed us over, truncate more aggressively\n            while urlencoding::encoded_len(&truncated) > max_encoded_len && truncated.len() > 100 {\n                let new_len = (truncated.chars().count() * 9) / 10;\n                truncated = truncated.chars().take(new_len).collect();\n            }\n        }\n\n        truncated\n    }\n\n    /// Open the issue URL in the default browser.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_open_in_browser_482": {
      "name": "open_in_browser",
      "type": "method",
      "start_line": 482,
      "end_line": 489,
      "content_hash": "0059543f6a9158fecb87bec3802c9feb8361a72b",
      "content": "    pub fn open_in_browser(&self) -> Result<()> {\n        let url = self.build_url();\n        open::that(&url).map_err(|e| eyre::eyre!(\"Failed to open browser: {}\", e))\n    }\n}\n\n/// Simple URL encoding for the issue URL.\npub mod urlencoding {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_encode_490": {
      "name": "encode",
      "type": "method",
      "start_line": 490,
      "end_line": 506,
      "content_hash": "a0f7d27002125f324bc4cd0333d664ce8c7ca66f",
      "content": "    pub fn encode(input: &str) -> String {\n        let mut encoded = String::new();\n        for byte in input.bytes() {\n            match byte {\n                b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {\n                    encoded.push(byte as char);\n                }\n                b' ' => encoded.push_str(\"%20\"),\n                _ => {\n                    encoded.push_str(&format!(\"%{:02X}\", byte));\n                }\n            }\n        }\n        encoded\n    }\n\n    /// Calculate the length of a string after URL encoding without allocating.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_encoded_len_507": {
      "name": "encoded_len",
      "type": "method",
      "start_line": 507,
      "end_line": 522,
      "content_hash": "68bc48accf83fb09903d928380b02dcead7ba5f6",
      "content": "    pub fn encoded_len(input: &str) -> usize {\n        input\n            .bytes()\n            .map(|b| match b {\n                b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => 1,\n                _ => 3,\n            })\n            .sum()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_error_line_numbers_523": {
      "name": "test_parse_error_line_numbers",
      "type": "method",
      "start_line": 523,
      "end_line": 542,
      "content_hash": "a578b96f4ee14c66847b2d758dcff4fefc1db874",
      "content": "    fn test_parse_error_line_numbers() {\n        let cargo_output = r#\"\nerror[E0433]: failed to resolve: use of undeclared type `Foo`\n --> src/queries.rs:42:5\n  |\n42 |     let x: Foo = Foo::new();\n  |            ^^^ not found in this scope\n\nerror[E0425]: cannot find value `bar` in this scope\n --> src/queries.rs:100:10\n   |\n100 |     bar.do_something();\n   |     ^^^ not found in this scope\n\"#;\n\n        let line_numbers = parse_error_line_numbers(cargo_output);\n        assert_eq!(line_numbers, vec![42, 100]);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_filter_errors_only_543": {
      "name": "test_filter_errors_only",
      "type": "method",
      "start_line": 543,
      "end_line": 570,
      "content_hash": "c731cdccb8cad7650e94af11189c12eaa60ff267",
      "content": "    fn test_filter_errors_only() {\n        let cargo_output = r#\"warning: unused variable: `x`\n --> src/queries.rs:10:5\n  |\n10 |     let x = 5;\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n\nerror[E0433]: failed to resolve: use of undeclared type `Foo`\n --> src/queries.rs:42:5\n  |\n42 |     let x: Foo = Foo::new();\n  |            ^^^ not found in this scope\n\nwarning: unused import\n --> src/queries.rs:1:5\n\nerror: aborting due to 1 previous error\n\"#;\n\n        let errors_only = filter_errors_only(cargo_output);\n        assert!(errors_only.contains(\"error[E0433]\"));\n        assert!(errors_only.contains(\"--> src/queries.rs:42:5\"));\n        assert!(errors_only.contains(\"Foo::new()\"));\n        assert!(!errors_only.contains(\"warning: unused variable\"));\n        assert!(!errors_only.contains(\"warning: unused import\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_filter_errors_preserves_context_571": {
      "name": "test_filter_errors_preserves_context",
      "type": "method",
      "start_line": 571,
      "end_line": 589,
      "content_hash": "0a6b337690586b0c7e700c5ecf630e5b3f94b6f6",
      "content": "    fn test_filter_errors_preserves_context() {\n        let cargo_output = r#\"error[E0425]: cannot find value `undefined_var` in this scope\n  --> src/queries.rs:100:5\n   |\n100 |     undefined_var.do_something();\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `helix-container` due to 1 previous error\n\"#;\n\n        let errors_only = filter_errors_only(cargo_output);\n        assert!(errors_only.contains(\"error[E0425]\"));\n        assert!(errors_only.contains(\"--> src/queries.rs:100:5\"));\n        assert!(errors_only.contains(\"undefined_var\"));\n        assert!(errors_only.contains(\"not found in this scope\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_extract_first_error_590": {
      "name": "test_extract_first_error",
      "type": "method",
      "start_line": 590,
      "end_line": 610,
      "content_hash": "5ba5f09f6fc24afae2f1c2f10eabe5c4a81d8e6b",
      "content": "    fn test_extract_first_error() {\n        let cargo_output = r#\"error[E0308]: mismatched types\n   --> helix-container/src/queries.rs:192:43\n    |\n192 | .insert_v::<fn(&HVector, &RoTxn) -> bool>(&data.vec, \"File8Vec\", Some(...\n    |  ---------------------------------------- ^^^^^^^^^ expected `&[f64]`, found `&Vec<f32>`\n\nerror[E0308]: mismatched types\n   --> helix-container/src/queries.rs:194:43\n\nerror: could not compile `helix-container` due to 2 previous errors\n\"#;\n\n        let first_error = extract_first_error(cargo_output);\n        assert_eq!(\n            first_error,\n            Some(\"error[E0308]: mismatched types\".to_string())\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_extract_first_error_none_611": {
      "name": "test_extract_first_error_none",
      "type": "method",
      "start_line": 611,
      "end_line": 617,
      "content_hash": "c4503d9b3db89271614db5779ed83837f6a4e302",
      "content": "    fn test_extract_first_error_none() {\n        let cargo_output = \"error: could not compile `helix-container`\";\n        let first_error = extract_first_error(cargo_output);\n        assert_eq!(first_error, None);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_encoded_len_618": {
      "name": "test_encoded_len",
      "type": "method",
      "start_line": 618,
      "end_line": 629,
      "content_hash": "5f16abc4012354d9944118ba2e20343c6cf530fc",
      "content": "    fn test_encoded_len() {\n        // Alphanumeric stays same length\n        assert_eq!(urlencoding::encoded_len(\"abc123\"), 6);\n        // Spaces become %20 (3 chars each)\n        assert_eq!(urlencoding::encoded_len(\"a b c\"), 9); // a(1) + %20(3) + b(1) + %20(3) + c(1) = 9\n        // Special chars triple\n        assert_eq!(urlencoding::encoded_len(\"{}\"), 6); // %7B(3) + %7D(3) = 6\n        // Mix: \"error: test\" = e(1)+r(1)+r(1)+o(1)+r(1)+:(3)+space(3)+t(1)+e(1)+s(1)+t(1) = 15\n        assert_eq!(urlencoding::encoded_len(\"error: test\"), 15);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_url_length_with_long_content_stays_under_limit_630": {
      "name": "test_url_length_with_long_content_stays_under_limit",
      "type": "method",
      "start_line": 630,
      "end_line": 647,
      "content_hash": "1cb22c41189e81aa30c2959848a1958653fc0916",
      "content": "    fn test_url_length_with_long_content_stays_under_limit() {\n        // Create very long error message with lots of special characters\n        let long_error = \"error[E0308]: mismatched types\\n\".repeat(500);\n\n        let builder = GitHubIssueBuilder::new(long_error.clone())\n            .with_hx_content(\"N {}\\nE {}\\nQ test() {}\".repeat(200));\n\n        let url = builder.build_url();\n\n        assert!(\n            url.len() <= MAX_URL_LENGTH,\n            \"URL length {} exceeds limit {}\",\n            url.len(),\n            MAX_URL_LENGTH\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_url_includes_content_when_short_648": {
      "name": "test_url_includes_content_when_short",
      "type": "method",
      "start_line": 648,
      "end_line": 661,
      "content_hash": "2689743659d1ff14d7472dc9c3dc76cccd03661a",
      "content": "    fn test_url_includes_content_when_short() {\n        let short_error = \"error[E0308]: mismatched types\";\n        let builder = GitHubIssueBuilder::new(short_error.to_string())\n            .with_hx_content(\"N User {}\".to_string());\n\n        let url = builder.build_url();\n\n        // URL should contain the error\n        assert!(url.contains(\"mismatched\"));\n        // URL should be well under the limit\n        assert!(url.len() < MAX_URL_LENGTH / 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_generic_url_builder_truncates_long_content_662": {
      "name": "test_generic_url_builder_truncates_long_content",
      "type": "method",
      "start_line": 662,
      "end_line": 680,
      "content_hash": "66816324b4e2ddf2ca3803dbf08b44ffa6048a4e",
      "content": "    fn test_generic_url_builder_truncates_long_content() {\n        // Create very long content with special characters\n        let long_body = \"This is feedback with special chars: {} [] <> \\n\".repeat(500);\n\n        let url = GitHubIssueUrlBuilder::new(\"Test Issue\")\n            .body(long_body)\n            .labels(\"feedback\")\n            .issue_type(\"Feature\")\n            .build_url();\n\n        assert!(\n            url.len() <= MAX_URL_LENGTH,\n            \"URL length {} exceeds limit {}\",\n            url.len(),\n            MAX_URL_LENGTH\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_generic_url_builder_preserves_short_content_681": {
      "name": "test_generic_url_builder_preserves_short_content",
      "type": "method",
      "start_line": 681,
      "end_line": 695,
      "content_hash": "e78e0a80109638e712d6d1cbc10b709e3994f2c4",
      "content": "    fn test_generic_url_builder_preserves_short_content() {\n        let short_body = \"This is a short feedback message.\";\n\n        let url = GitHubIssueUrlBuilder::new(\"Short Test\")\n            .body(short_body)\n            .labels(\"feedback\")\n            .issue_type(\"Feature\")\n            .build_url();\n\n        // URL should contain the message\n        assert!(url.contains(\"short%20feedback\"));\n        // URL should be well under the limit\n        assert!(url.len() < MAX_URL_LENGTH / 2);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}