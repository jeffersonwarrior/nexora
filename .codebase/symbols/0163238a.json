{
  "file_path": "/work/external-deps/Context-Engine/tests/test_watcher_events.py",
  "file_hash": "96a882789fac08b37aefa2c656a89d1bb3c7120e",
  "updated_at": "2025-12-26T17:34:20.905882",
  "symbols": {
    "class_FakeQueue_12": {
      "name": "FakeQueue",
      "type": "class",
      "start_line": 12,
      "end_line": 17,
      "content_hash": "1257152f880803887e1fce52fac4392050a42793",
      "content": "class FakeQueue:\n    def __init__(self):\n        self.added = []\n\n    def add(self, p: Path):\n        self.added.append(str(p))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___13": {
      "name": "__init__",
      "type": "method",
      "start_line": 13,
      "end_line": 14,
      "content_hash": "1e2d3be3877adeafb737e05907b9a5b65dd3848b",
      "content": "    def __init__(self):\n        self.added = []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_16": {
      "name": "add",
      "type": "method",
      "start_line": 16,
      "end_line": 17,
      "content_hash": "ee57d11dcb11e12a587d6203da60aef8744a5a63",
      "content": "    def add(self, p: Path):\n        self.added.append(str(p))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_FakeClient_20": {
      "name": "FakeClient",
      "type": "class",
      "start_line": 20,
      "end_line": 21,
      "content_hash": "81ba7d26cf2f606a95ae75c751b2718c03a7c6e8",
      "content": "class FakeClient:\n    pass",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_E_24": {
      "name": "E",
      "type": "class",
      "start_line": 24,
      "end_line": 28,
      "content_hash": "1f2017fe8ab635e92a024b9c1faad6cf253b89eb",
      "content": "class E:\n    def __init__(self, src, dest=None, is_dir=False):\n        self.src_path = str(src)\n        self.dest_path = str(dest) if dest else None\n        self.is_directory = is_dir",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___25": {
      "name": "__init__",
      "type": "method",
      "start_line": 25,
      "end_line": 28,
      "content_hash": "37387b0ca809085244960aff071ddb7414c995fe",
      "content": "    def __init__(self, src, dest=None, is_dir=False):\n        self.src_path = str(src)\n        self.dest_path = str(dest) if dest else None\n        self.is_directory = is_dir",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_on_deleted_calls_delete_points_32": {
      "name": "test_on_deleted_calls_delete_points",
      "type": "function",
      "start_line": 32,
      "end_line": 51,
      "content_hash": "bf34c4ebe69f77a008177355066bff389dd30ba8",
      "content": "def test_on_deleted_calls_delete_points(monkeypatch, tmp_path):\n    monkeypatch.setenv(\"MULTI_REPO_MODE\", \"0\")\n    q = FakeQueue()\n    handler = wi.IndexHandler(root=tmp_path, queue=q, client=FakeClient(), collection=\"c\")\n\n    called = {}\n\n    def fake_delete(client, collection, p):\n        called[\"args\"] = (collection, p)\n\n    monkeypatch.setattr(idx, \"delete_points_by_path\", fake_delete)\n\n    # Create a code-like file to pass suffix filter; then delete event on it\n    f = tmp_path / \"a.py\"\n    f.write_text(\"print('x')\\n\")\n    handler.on_deleted(E(f))\n\n    assert \"args\" in called\n    assert called[\"args\"][0] == \"c\"\n    assert called[\"args\"][1].endswith(\"/a.py\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_fake_delete_39": {
      "name": "fake_delete",
      "type": "function",
      "start_line": 39,
      "end_line": 40,
      "content_hash": "f5128d57be0d42acc8154fa515c91ce51c5a4972",
      "content": "    def fake_delete(client, collection, p):\n        called[\"args\"] = (collection, p)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_on_moved_enqueues_new_dest_55": {
      "name": "test_on_moved_enqueues_new_dest",
      "type": "function",
      "start_line": 55,
      "end_line": 71,
      "content_hash": "f152e0307f9c3b9236c69bcec31e4f73db149454",
      "content": "def test_on_moved_enqueues_new_dest(monkeypatch, tmp_path):\n    monkeypatch.setenv(\"MULTI_REPO_MODE\", \"0\")\n    q = FakeQueue()\n    handler = wi.IndexHandler(root=tmp_path, queue=q, client=FakeClient(), collection=\"c\")\n\n    # Ensure .py suffix passes filters\n    src = tmp_path / \"a.py\"\n    dst = tmp_path / \"b.py\"\n    src.write_text(\"print('a')\\n\")\n    dst.write_text(\"print('b')\\n\")\n\n    # Monkeypatch excluder to allow all; and code extensions are already .py\n    handler.on_moved(E(src, dest=dst))\n\n    # Debounced queue adds; but our FakeQueue records immediately via add()\n    assert q.added, \"expected destination to be enqueued\"\n    assert any(s.endswith(\"/b.py\") for s in q.added)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_ignore_reload_rebuilds_excluder_75": {
      "name": "test_ignore_reload_rebuilds_excluder",
      "type": "function",
      "start_line": 75,
      "end_line": 89,
      "content_hash": "8f276586807939cd22abbd5be7191bdb48f765f6",
      "content": "def test_ignore_reload_rebuilds_excluder(monkeypatch, tmp_path):\n    monkeypatch.setenv(\"MULTI_REPO_MODE\", \"0\")\n    # Place .qdrantignore; construct handler (captures mtime)\n    ign = tmp_path / \".qdrantignore\"\n    ign.write_text(\"# initial\\n\")\n    q = FakeQueue()\n    handler = wi.IndexHandler(root=tmp_path, queue=q, client=FakeClient(), collection=\"c\")\n    old = handler.excl\n\n    # Touch ignore file to bump mtime and trigger reload\n    time.sleep(0.01)\n    ign.write_text(\"*.gen\\n\")\n    handler._maybe_reload_excluder()\n\n    assert handler.excl is not old, \"excluder should be rebuilt after ignore file change\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_remote_git_manifest_is_enqueued_even_if_excluded_93": {
      "name": "test_remote_git_manifest_is_enqueued_even_if_excluded",
      "type": "function",
      "start_line": 93,
      "end_line": 107,
      "content_hash": "50dbeb661943de04ffd1ccd4376807ba298f072c",
      "content": "def test_remote_git_manifest_is_enqueued_even_if_excluded(monkeypatch, tmp_path):\n    monkeypatch.setenv(\"MULTI_REPO_MODE\", \"0\")\n    q = FakeQueue()\n    handler = wi.IndexHandler(root=tmp_path, queue=q, client=FakeClient(), collection=\"c\")\n\n    # .remote-git should be excluded by default excluder rules for code indexing\n    assert handler.excl.exclude_dir(\"/.remote-git\")\n\n    manifest_dir = tmp_path / \".remote-git\"\n    manifest_dir.mkdir(parents=True, exist_ok=True)\n    manifest = manifest_dir / \"git_history_test.json\"\n    manifest.write_text(\"{}\\n\")\n\n    handler.on_created(E(manifest))\n    assert any(p.endswith(\"/.remote-git/git_history_test.json\") for p in q.added)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}