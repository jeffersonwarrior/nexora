{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/traversal_core/ops/source/add_e.rs",
  "file_hash": "a18f0819b82d091caa6c790554631f2eb00ec960",
  "updated_at": "2025-12-26T17:34:23.142949",
  "symbols": {
    "struct_AddE_11": {
      "name": "AddE",
      "type": "struct",
      "start_line": 11,
      "end_line": 21,
      "content_hash": "5fb8687dfaa4c3655b03138aaaf0dabd2168dd12",
      "content": "pub struct AddE<'db, 'arena, 'txn>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    pub storage: &'db HelixGraphStorage,\n    pub arena: &'arena bumpalo::Bump,\n    pub txn: &'txn RwTxn<'db>,\n    inner: std::iter::Once<Result<TraversalValue<'arena>, GraphError>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_22": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 22,
      "end_line": 24,
      "content_hash": "a56afc13680bfccacd33da04d4ee3a1789a03637",
      "content": "impl<'db, 'arena, 'txn> Iterator for AddE<'db, 'arena, 'txn> {\n    type Item = Result<TraversalValue<'arena>, GraphError>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_25": {
      "name": "next",
      "type": "method",
      "start_line": 25,
      "end_line": 29,
      "content_hash": "61902b91c5a2d5de9a1728d89548a399c974e36a",
      "content": "    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_AddEAdapter_30": {
      "name": "AddEAdapter",
      "type": "trait",
      "start_line": 30,
      "end_line": 32,
      "content_hash": "4208a6186679f37b714e9210a53f0ca189aefe93",
      "content": "pub trait AddEAdapter<'db, 'arena, 'txn, 's>:\n    Iterator<Item = Result<TraversalValue<'arena>, GraphError>>\n{",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_edge_33": {
      "name": "add_edge",
      "type": "method",
      "start_line": 33,
      "end_line": 43,
      "content_hash": "c1e43e0530e0747ff0459dacfb6651eb3c05fabc",
      "content": "    fn add_edge(\n        self,\n        label: &'arena str,\n        properties: Option<ImmutablePropertiesMap<'arena>>,\n        from_node: u128,\n        to_node: u128,\n        should_check: bool,\n    ) -> RwTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_44": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 44,
      "end_line": 52,
      "content_hash": "ea16d1d7f1edcb6daf5efc43be26be0cd0a80cd7",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n}\n\nimpl<'db, 'arena, 'txn, 's, I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>>\n    AddEAdapter<'db, 'arena, 'txn, 's> for RwTraversalIterator<'db, 'arena, 'txn, I>\n{\n    #[inline(always)]\n    #[allow(unused_variables)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_edge_53": {
      "name": "add_edge",
      "type": "method",
      "start_line": 53,
      "end_line": 63,
      "content_hash": "c1e43e0530e0747ff0459dacfb6651eb3c05fabc",
      "content": "    fn add_edge(\n        self,\n        label: &'arena str,\n        properties: Option<ImmutablePropertiesMap<'arena>>,\n        from_node: u128,\n        to_node: u128,\n        should_check: bool,\n    ) -> RwTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_64": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 64,
      "end_line": 136,
      "content_hash": "f70ba4c58f728ab607006848dec1f30f6f5f741c",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let version = self.storage.version_info.get_latest(label);\n        let edge = Edge {\n            id: v6_uuid(),\n            label,\n            version,\n            properties,\n            from_node,\n            to_node,\n        };\n\n        let mut result: Result<TraversalValue, GraphError> = Ok(TraversalValue::Empty);\n\n        match edge.to_bincode_bytes() {\n            Ok(bytes) => {\n                if let Err(e) = self.storage.edges_db.put_with_flags(\n                    self.txn,\n                    PutFlags::APPEND,\n                    HelixGraphStorage::edge_key(&edge.id),\n                    &bytes,\n                ) {\n                    result = Err(GraphError::from(e));\n                }\n            }\n            Err(e) => result = Err(GraphError::from(e)),\n        }\n\n        let label_hash = hash_label(edge.label, None);\n\n        match self.storage.out_edges_db.put_with_flags(\n            self.txn,\n            PutFlags::APPEND_DUP,\n            &HelixGraphStorage::out_edge_key(&from_node, &label_hash),\n            &HelixGraphStorage::pack_edge_data(&edge.id, &to_node),\n        ) {\n            Ok(_) => {}\n            Err(e) => {\n                println!(\n                    \"add_e => error adding out edge between {from_node:?} and {to_node:?}: {e:?}\"\n                );\n                result = Err(GraphError::from(e));\n            }\n        }\n\n        match self.storage.in_edges_db.put_with_flags(\n            self.txn,\n            PutFlags::APPEND_DUP,\n            &HelixGraphStorage::in_edge_key(&to_node, &label_hash),\n            &HelixGraphStorage::pack_edge_data(&edge.id, &from_node),\n        ) {\n            Ok(_) => {}\n            Err(e) => {\n                println!(\n                    \"add_e => error adding in edge between {from_node:?} and {to_node:?}: {e:?}\"\n                );\n                result = Err(GraphError::from(e));\n            }\n        }\n\n        let result = match result {\n            Ok(_) => Ok(TraversalValue::Edge(edge)),\n            Err(e) => Err(e),\n        };\n\n        RwTraversalIterator {\n            arena: self.arena,\n            storage: self.storage,\n            txn: self.txn,\n            inner: std::iter::once(result), // TODO: change to support adding multiple edges\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}