{
  "file_path": "/work/external-deps/claude-mem/src/services/sqlite/Database.ts",
  "file_hash": "b8179356a812bdec80c0660155328d2ddff58fa0",
  "updated_at": "2025-12-26T17:34:23.794104",
  "symbols": {
    "class_DatabaseManager_19": {
      "name": "DatabaseManager",
      "type": "class",
      "start_line": 19,
      "end_line": 155,
      "content_hash": "6bd1db33295d9847fc98b3d5d7da2bbd99e603d9",
      "content": "export class DatabaseManager {\n  private static instance: DatabaseManager;\n  private db: Database | null = null;\n  private migrations: Migration[] = [];\n\n  static getInstance(): DatabaseManager {\n    if (!DatabaseManager.instance) {\n      DatabaseManager.instance = new DatabaseManager();\n    }\n    return DatabaseManager.instance;\n  }\n\n  /**\n   * Register a migration to be run during initialization\n   */\n  registerMigration(migration: Migration): void {\n    this.migrations.push(migration);\n    // Keep migrations sorted by version\n    this.migrations.sort((a, b) => a.version - b.version);\n  }\n\n  /**\n   * Initialize database connection with optimized settings\n   */\n  async initialize(): Promise<Database> {\n    if (this.db) {\n      return this.db;\n    }\n\n    // Ensure the data directory exists\n    ensureDir(DATA_DIR);\n\n    this.db = new Database(DB_PATH, { create: true, readwrite: true });\n\n    // Apply optimized SQLite settings\n    this.db.run('PRAGMA journal_mode = WAL');\n    this.db.run('PRAGMA synchronous = NORMAL');\n    this.db.run('PRAGMA foreign_keys = ON');\n    this.db.run('PRAGMA temp_store = memory');\n    this.db.run(`PRAGMA mmap_size = ${SQLITE_MMAP_SIZE_BYTES}`);\n    this.db.run(`PRAGMA cache_size = ${SQLITE_CACHE_SIZE_PAGES}`);\n\n    // Initialize schema_versions table\n    this.initializeSchemaVersions();\n\n    // Run migrations\n    await this.runMigrations();\n\n    dbInstance = this.db;\n    return this.db;\n  }\n\n  /**\n   * Get the current database connection\n   */\n  getConnection(): Database {\n    if (!this.db) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }\n\n  /**\n   * Execute a function within a transaction\n   */\n  withTransaction<T>(fn: (db: Database) => T): T {\n    const db = this.getConnection();\n    const transaction = db.transaction(fn);\n    return transaction(db);\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n      dbInstance = null;\n    }\n  }\n\n  /**\n   * Initialize the schema_versions table\n   */\n  private initializeSchemaVersions(): void {\n    if (!this.db) return;\n\n    this.db.run(`\n      CREATE TABLE IF NOT EXISTS schema_versions (\n        id INTEGER PRIMARY KEY,\n        version INTEGER UNIQUE NOT NULL,\n        applied_at TEXT NOT NULL\n      )\n    `);\n  }\n\n  /**\n   * Run all pending migrations\n   */\n  private async runMigrations(): Promise<void> {\n    if (!this.db) return;\n\n    const query = this.db.query('SELECT version FROM schema_versions ORDER BY version');\n    const appliedVersions = query.all().map((row: any) => row.version);\n\n    const maxApplied = appliedVersions.length > 0 ? Math.max(...appliedVersions) : 0;\n\n    for (const migration of this.migrations) {\n      if (migration.version > maxApplied) {\n        console.log(`Applying migration ${migration.version}...`);\n\n        const transaction = this.db.transaction(() => {\n          migration.up(this.db!);\n\n          const insertQuery = this.db!.query('INSERT INTO schema_versions (version, applied_at) VALUES (?, ?)');\n          insertQuery.run(migration.version, new Date().toISOString());\n        });\n\n        transaction();\n        console.log(`Migration ${migration.version} applied successfully`);\n      }\n    }\n  }\n\n  /**\n   * Get current schema version\n   */\n  getCurrentVersion(): number {\n    if (!this.db) return 0;\n\n    const query = this.db.query('SELECT MAX(version) as version FROM schema_versions');\n    const result = query.get() as { version: number } | undefined;\n\n    return result?.version || 0;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getInstance_24": {
      "name": "getInstance",
      "type": "method",
      "start_line": 24,
      "end_line": 29,
      "content_hash": "33c0f6ab6a4df341402fb9e1bfe5db36b8391260",
      "content": "  static getInstance(): DatabaseManager {\n    if (!DatabaseManager.instance) {\n      DatabaseManager.instance = new DatabaseManager();\n    }\n    return DatabaseManager.instance;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_registerMigration_34": {
      "name": "registerMigration",
      "type": "method",
      "start_line": 34,
      "end_line": 38,
      "content_hash": "335e7b075a2eb84f0c1b46a3730e40939b42db8b",
      "content": "  registerMigration(migration: Migration): void {\n    this.migrations.push(migration);\n    // Keep migrations sorted by version\n    this.migrations.sort((a, b) => a.version - b.version);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initialize_43": {
      "name": "initialize",
      "type": "method",
      "start_line": 43,
      "end_line": 69,
      "content_hash": "303c4712681ebc63ce6f287307059e7fa04a0c3a",
      "content": "  async initialize(): Promise<Database> {\n    if (this.db) {\n      return this.db;\n    }\n\n    // Ensure the data directory exists\n    ensureDir(DATA_DIR);\n\n    this.db = new Database(DB_PATH, { create: true, readwrite: true });\n\n    // Apply optimized SQLite settings\n    this.db.run('PRAGMA journal_mode = WAL');\n    this.db.run('PRAGMA synchronous = NORMAL');\n    this.db.run('PRAGMA foreign_keys = ON');\n    this.db.run('PRAGMA temp_store = memory');\n    this.db.run(`PRAGMA mmap_size = ${SQLITE_MMAP_SIZE_BYTES}`);\n    this.db.run(`PRAGMA cache_size = ${SQLITE_CACHE_SIZE_PAGES}`);\n\n    // Initialize schema_versions table\n    this.initializeSchemaVersions();\n\n    // Run migrations\n    await this.runMigrations();\n\n    dbInstance = this.db;\n    return this.db;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getConnection_74": {
      "name": "getConnection",
      "type": "method",
      "start_line": 74,
      "end_line": 79,
      "content_hash": "c0046adae9286cf0d984059d6fdec015ced65075",
      "content": "  getConnection(): Database {\n    if (!this.db) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_withTransaction_84": {
      "name": "withTransaction",
      "type": "method",
      "start_line": 84,
      "end_line": 88,
      "content_hash": "1bc0e12a269acd06dc3fb6ef4df8577ea5c90dfa",
      "content": "  withTransaction<T>(fn: (db: Database) => T): T {\n    const db = this.getConnection();\n    const transaction = db.transaction(fn);\n    return transaction(db);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_close_93": {
      "name": "close",
      "type": "method",
      "start_line": 93,
      "end_line": 99,
      "content_hash": "a7b7dd8f4af23a2f6b96068eb7ff50928c8aa65c",
      "content": "  close(): void {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n      dbInstance = null;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initializeSchemaVersions_104": {
      "name": "initializeSchemaVersions",
      "type": "method",
      "start_line": 104,
      "end_line": 114,
      "content_hash": "ed43e13519887f6d31b1d9de5bb8044eae468ba2",
      "content": "  private initializeSchemaVersions(): void {\n    if (!this.db) return;\n\n    this.db.run(`\n      CREATE TABLE IF NOT EXISTS schema_versions (\n        id INTEGER PRIMARY KEY,\n        version INTEGER UNIQUE NOT NULL,\n        applied_at TEXT NOT NULL\n      )\n    `);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_runMigrations_119": {
      "name": "runMigrations",
      "type": "method",
      "start_line": 119,
      "end_line": 142,
      "content_hash": "a6dcd3d8199b5f65730e34745e17ec4237cfbf75",
      "content": "  private async runMigrations(): Promise<void> {\n    if (!this.db) return;\n\n    const query = this.db.query('SELECT version FROM schema_versions ORDER BY version');\n    const appliedVersions = query.all().map((row: any) => row.version);\n\n    const maxApplied = appliedVersions.length > 0 ? Math.max(...appliedVersions) : 0;\n\n    for (const migration of this.migrations) {\n      if (migration.version > maxApplied) {\n        console.log(`Applying migration ${migration.version}...`);\n\n        const transaction = this.db.transaction(() => {\n          migration.up(this.db!);\n\n          const insertQuery = this.db!.query('INSERT INTO schema_versions (version, applied_at) VALUES (?, ?)');\n          insertQuery.run(migration.version, new Date().toISOString());\n        });\n\n        transaction();\n        console.log(`Migration ${migration.version} applied successfully`);\n      }\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getCurrentVersion_147": {
      "name": "getCurrentVersion",
      "type": "method",
      "start_line": 147,
      "end_line": 154,
      "content_hash": "5431470df0f0422c04de3100272be8707ae2cf90",
      "content": "  getCurrentVersion(): number {\n    if (!this.db) return 0;\n\n    const query = this.db.query('SELECT MAX(version) as version FROM schema_versions');\n    const result = query.get() as { version: number } | undefined;\n\n    return result?.version || 0;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getDatabase_160": {
      "name": "getDatabase",
      "type": "function",
      "start_line": 160,
      "end_line": 165,
      "content_hash": "dacfb76200f305d53c0db19d1156f6c47b6c135b",
      "content": "export function getDatabase(): Database {\n  if (!dbInstance) {\n    throw new Error('Database not initialized. Call DatabaseManager.getInstance().initialize() first.');\n  }\n  return dbInstance;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_initializeDatabase_170": {
      "name": "initializeDatabase",
      "type": "function",
      "start_line": 170,
      "end_line": 173,
      "content_hash": "46e9cf84db5da6a6437e4dbdfb9ec117b872eda6",
      "content": "export async function initializeDatabase(): Promise<Database> {\n  const manager = DatabaseManager.getInstance();\n  return await manager.initialize();\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}