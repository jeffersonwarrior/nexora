{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/cleanup.rs",
  "file_hash": "9794198a0e2ff80bf33e90bc9bf18227ab9294e4",
  "updated_at": "2025-12-26T17:34:20.373593",
  "symbols": {
    "struct_CleanupTracker_7": {
      "name": "CleanupTracker",
      "type": "struct",
      "start_line": 7,
      "end_line": 18,
      "content_hash": "38a13a33817d0524ca68bf4c17d48c03a4678995",
      "content": "pub struct CleanupTracker {\n    /// Files created during the operation (tracked in creation order)\n    created_files: Vec<PathBuf>,\n    /// Directories created during the operation (tracked in creation order)\n    created_dirs: Vec<PathBuf>,\n    /// In-memory backup of the config before modification\n    original_config: Option<HelixConfig>,\n    /// Path to the config file\n    config_path: Option<PathBuf>,\n}\n\n/// Summary of cleanup operations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CleanupSummary_19": {
      "name": "CleanupSummary",
      "type": "struct",
      "start_line": 19,
      "end_line": 27,
      "content_hash": "29c3afe434dd8ecca4a6b5163db997ae3bf3b17d",
      "content": "pub struct CleanupSummary {\n    pub files_removed: usize,\n    pub files_failed: usize,\n    pub dirs_removed: usize,\n    pub dirs_failed: usize,\n    pub config_restored: bool,\n    pub errors: Vec<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_28": {
      "name": "Default",
      "type": "impl",
      "start_line": 28,
      "end_line": 28,
      "content_hash": "f5fe3f1734ccda15f8306af5b781d680c84eda4a",
      "content": "impl Default for CleanupTracker {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_29": {
      "name": "default",
      "type": "method",
      "start_line": 29,
      "end_line": 33,
      "content_hash": "0bfc0b5dc630e980580df80d5e54d3932858b373",
      "content": "    fn default() -> Self {\n        Self::new()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_CleanupTracker_34": {
      "name": "CleanupTracker",
      "type": "impl",
      "start_line": 34,
      "end_line": 35,
      "content_hash": "07370f8bea32727158e708ef1b602ce88774167d",
      "content": "impl CleanupTracker {\n    /// Create a new cleanup tracker",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_36": {
      "name": "new",
      "type": "method",
      "start_line": 36,
      "end_line": 45,
      "content_hash": "3acbc85d1596ac40c1654111cec117212848f905",
      "content": "    pub fn new() -> Self {\n        Self {\n            created_files: Vec::new(),\n            created_dirs: Vec::new(),\n            original_config: None,\n            config_path: None,\n        }\n    }\n\n    /// Track a file that was created",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_track_file_46": {
      "name": "track_file",
      "type": "method",
      "start_line": 46,
      "end_line": 50,
      "content_hash": "cf863556813ca0f4aa705b516597949365b04d55",
      "content": "    pub fn track_file(&mut self, path: PathBuf) {\n        self.created_files.push(path);\n    }\n\n    /// Track a directory that was created",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_track_dir_51": {
      "name": "track_dir",
      "type": "method",
      "start_line": 51,
      "end_line": 55,
      "content_hash": "7e45935e40d7fc2348bd599439756d88023520f9",
      "content": "    pub fn track_dir(&mut self, path: PathBuf) {\n        self.created_dirs.push(path);\n    }\n\n    /// Backup the config in memory before modification",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_backup_config_56": {
      "name": "backup_config",
      "type": "method",
      "start_line": 56,
      "end_line": 62,
      "content_hash": "415124831aa10a058041a86eb28345e9ab333300",
      "content": "    pub fn backup_config(&mut self, config: &HelixConfig, config_path: PathBuf) {\n        self.original_config = Some(config.clone());\n        self.config_path = Some(config_path);\n    }\n\n    /// Execute cleanup in reverse order of creation\n    /// Logs errors but continues cleanup process",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cleanup_63": {
      "name": "cleanup",
      "type": "method",
      "start_line": 63,
      "end_line": 139,
      "content_hash": "cd212098a66dd1a314507270decdb4c46647920a",
      "content": "    pub fn cleanup(self) -> CleanupSummary {\n        let mut summary = CleanupSummary {\n            files_removed: 0,\n            files_failed: 0,\n            dirs_removed: 0,\n            dirs_failed: 0,\n            config_restored: false,\n            errors: Vec::new(),\n        };\n\n        // Step 1: Restore config from in-memory backup if modified\n        if let (Some(original_config), Some(config_path)) =\n            (self.original_config, self.config_path)\n        {\n            match original_config.save_to_file(&config_path) {\n                Ok(_) => {\n                    summary.config_restored = true;\n                    eprintln!(\"Restored config file to original state\");\n                }\n                Err(e) => {\n                    let error_msg = format!(\"Failed to restore config: {}\", e);\n                    eprintln!(\"Error: {}\", error_msg);\n                    summary.errors.push(error_msg);\n                }\n            }\n        }\n\n        // Step 2: Delete files in reverse order (newest first)\n        for file_path in self.created_files.iter().rev() {\n            match fs::remove_file(file_path) {\n                Ok(_) => {\n                    summary.files_removed += 1;\n                    eprintln!(\"Removed file: {}\", file_path.display());\n                }\n                Err(e) => {\n                    summary.files_failed += 1;\n                    let error_msg = format!(\"Failed to remove file {}: {}\", file_path.display(), e);\n                    eprintln!(\"Warning: {}\", error_msg);\n                    summary.errors.push(error_msg);\n                }\n            }\n        }\n\n        // Step 3: Delete directories in reverse order (deepest first)\n        // Sort by path depth (deepest first) to ensure we delete children before parents\n        let mut sorted_dirs = self.created_dirs.clone();\n        sorted_dirs.sort_by(|a, b| {\n            let a_depth = a.components().count();\n            let b_depth = b.components().count();\n            b_depth.cmp(&a_depth) // Reverse order (deepest first)\n        });\n\n        for dir_path in sorted_dirs.iter() {\n            // Only try to remove if directory exists\n            if !dir_path.exists() {\n                continue;\n            }\n\n            // Try to remove directory - will only succeed if empty\n            match fs::remove_dir(dir_path) {\n                Ok(_) => {\n                    summary.dirs_removed += 1;\n                    eprintln!(\"Removed directory: {}\", dir_path.display());\n                }\n                Err(_e) => {\n                    // This might fail if directory is not empty, which is fine\n                    // We only want to remove directories we created if they're still empty\n                    summary.dirs_failed += 1;\n                    // Don't add to errors since this is expected for non-empty dirs\n                }\n            }\n        }\n\n        summary\n    }\n\n    /// Check if any resources are being tracked",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_has_tracked_resources_140": {
      "name": "has_tracked_resources",
      "type": "method",
      "start_line": 140,
      "end_line": 146,
      "content_hash": "2c71b4f2d342bf6350cab6a274d86a738e7b9a16",
      "content": "    pub fn has_tracked_resources(&self) -> bool {\n        !self.created_files.is_empty()\n            || !self.created_dirs.is_empty()\n            || self.original_config.is_some()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_CleanupSummary_147": {
      "name": "CleanupSummary",
      "type": "impl",
      "start_line": 147,
      "end_line": 148,
      "content_hash": "cd18b0cf788a4c36ca4c770f2a408372f118741d",
      "content": "impl CleanupSummary {\n    /// Log the cleanup summary",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_log_summary_149": {
      "name": "log_summary",
      "type": "method",
      "start_line": 149,
      "end_line": 179,
      "content_hash": "fb1679ee917bf94600938c205acc45afa31a3b26",
      "content": "    pub fn log_summary(&self) {\n        if self.files_removed > 0 || self.dirs_removed > 0 || self.config_restored {\n            eprintln!(\"Cleanup summary:\");\n            if self.config_restored {\n                eprintln!(\"  - Config file restored\");\n            }\n            if self.files_removed > 0 {\n                eprintln!(\"  - Removed {} file(s)\", self.files_removed);\n            }\n            if self.dirs_removed > 0 {\n                eprintln!(\"  - Removed {} directory(ies)\", self.dirs_removed);\n            }\n        }\n\n        if self.files_failed > 0 || self.dirs_failed > 0 || !self.errors.is_empty() {\n            eprintln!(\"Cleanup encountered {} error(s):\", self.errors.len());\n            for error in &self.errors {\n                eprintln!(\"  - {}\", error);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::io::Write;\n    use tempfile::TempDir;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_track_and_cleanup_files_180": {
      "name": "test_track_and_cleanup_files",
      "type": "method",
      "start_line": 180,
      "end_line": 200,
      "content_hash": "2717d9a57d0fb83fdf0e7f43208e2dba3b2c555f",
      "content": "    fn test_track_and_cleanup_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"test.txt\");\n\n        // Create a file\n        let mut file = fs::File::create(&file_path).unwrap();\n        file.write_all(b\"test\").unwrap();\n\n        let mut tracker = CleanupTracker::new();\n        tracker.track_file(file_path.clone());\n\n        assert!(file_path.exists());\n\n        // Cleanup should remove the file\n        let summary = tracker.cleanup();\n        assert_eq!(summary.files_removed, 1);\n        assert_eq!(summary.files_failed, 0);\n        assert!(!file_path.exists());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_track_and_cleanup_dirs_201": {
      "name": "test_track_and_cleanup_dirs",
      "type": "method",
      "start_line": 201,
      "end_line": 219,
      "content_hash": "4a263b17031262842436e5f619dbff50c7cbc165",
      "content": "    fn test_track_and_cleanup_dirs() {\n        let temp_dir = TempDir::new().unwrap();\n        let dir_path = temp_dir.path().join(\"test_dir\");\n\n        // Create a directory\n        fs::create_dir(&dir_path).unwrap();\n\n        let mut tracker = CleanupTracker::new();\n        tracker.track_dir(dir_path.clone());\n\n        assert!(dir_path.exists());\n\n        // Cleanup should remove the directory\n        let summary = tracker.cleanup();\n        assert_eq!(summary.dirs_removed, 1);\n        assert!(!dir_path.exists());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cleanup_order_220": {
      "name": "test_cleanup_order",
      "type": "method",
      "start_line": 220,
      "end_line": 242,
      "content_hash": "e843549744b2764b8f171078fe471e6e8c086172",
      "content": "    fn test_cleanup_order() {\n        let temp_dir = TempDir::new().unwrap();\n\n        // Create nested structure\n        let parent_dir = temp_dir.path().join(\"parent\");\n        let child_dir = parent_dir.join(\"child\");\n        let file_path = child_dir.join(\"file.txt\");\n\n        fs::create_dir(&parent_dir).unwrap();\n        fs::create_dir(&child_dir).unwrap();\n        fs::File::create(&file_path).unwrap();\n\n        let mut tracker = CleanupTracker::new();\n        tracker.track_dir(parent_dir.clone());\n        tracker.track_dir(child_dir.clone());\n        tracker.track_file(file_path.clone());\n\n        // Cleanup should handle nested structure\n        let summary = tracker.cleanup();\n        assert_eq!(summary.files_removed, 1);\n        assert!(summary.dirs_removed >= 1); // At least child dir should be removed\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}