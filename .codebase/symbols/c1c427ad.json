{
  "file_path": "/work/internal/agent/tools/view.go",
  "file_hash": "dd871a4127f5ddda5f5a0fbc615e4352ccd39a01",
  "updated_at": "2025-12-26T17:34:22.613164",
  "symbols": {
    "struct_ViewParams_28": {
      "name": "ViewParams",
      "type": "struct",
      "start_line": 28,
      "end_line": 33,
      "content_hash": "b13524a5ba60d49f1ac7d4b2065188877f09e720",
      "content": "type ViewParams struct {\n\tFilePath string `json:\"file_path\" description:\"The path to the file to read\"`\n\tOffset   int    `json:\"offset,omitempty\" description:\"The line number to start reading from (0-based)\"`\n\tLimit    int    `json:\"limit,omitempty\" description:\"The number of lines to read (defaults to 2000)\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ViewPermissionsParams_34": {
      "name": "ViewPermissionsParams",
      "type": "struct",
      "start_line": 34,
      "end_line": 39,
      "content_hash": "cf4522300f3401faba16b5d93c8e69b0ae493cd9",
      "content": "type ViewPermissionsParams struct {\n\tFilePath string `json:\"file_path\"`\n\tOffset   int    `json:\"offset\"`\n\tLimit    int    `json:\"limit\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_viewTool_40": {
      "name": "viewTool",
      "type": "struct",
      "start_line": 40,
      "end_line": 45,
      "content_hash": "8674f1b8c8f5f66083a4d444d6872e3f806d4bf9",
      "content": "type viewTool struct {\n\tlspClients  *csync.Map[string, *lsp.Client]\n\tworkingDir  string\n\tpermissions permission.Service\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ViewResponseMetadata_46": {
      "name": "ViewResponseMetadata",
      "type": "struct",
      "start_line": 46,
      "end_line": 57,
      "content_hash": "acb58c8de01db12402c7b02b9e446c851871dcb5",
      "content": "type ViewResponseMetadata struct {\n\tFilePath string `json:\"file_path\"`\n\tContent  string `json:\"content\"`\n}\n\nconst (\n\tViewToolName     = \"view\"\n\tMaxReadSize      = 5 * 1024 * 1024 // 5MB\n\tDefaultReadLimit = 100\n\tMaxLineLength    = 2000\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewViewTool_58": {
      "name": "NewViewTool",
      "type": "function",
      "start_line": 58,
      "end_line": 278,
      "content_hash": "98b2a278a01d89428b3c4b9e27e5a7e88943e075",
      "content": "func NewViewTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, workingDir string) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tViewToolName,\n\t\tstring(viewDescription),\n\t\tfunc(ctx context.Context, params ViewParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\tstartTime := time.Now()\n\t\t\tif params.FilePath == \"\" {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"file_path is required\"), nil\n\t\t\t}\n\n\t\t\t// Handle relative paths\n\t\t\tfilePath := filepathext.SmartJoin(workingDir, params.FilePath)\n\n\t\t\t// Check if file is outside working directory and request permission if needed\n\t\t\tabsWorkingDir, err := filepath.Abs(workingDir)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error resolving working directory: %w\", err)\n\t\t\t}\n\n\t\t\tabsFilePath, err := filepath.Abs(filePath)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error resolving file path: %w\", err)\n\t\t\t}\n\n\t\t\trelPath, err := filepath.Rel(absWorkingDir, absFilePath)\n\t\t\tif err != nil || strings.HasPrefix(relPath, \"..\") {\n\t\t\t\t// File is outside working directory, request permission\n\t\t\t\tsessionID := GetSessionFromContext(ctx)\n\t\t\t\tif sessionID == \"\" {\n\t\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for accessing files outside working directory\")\n\t\t\t\t}\n\n\t\t\t\tgranted := permissions.Request(\n\t\t\t\t\tpermission.CreatePermissionRequest{\n\t\t\t\t\t\tSessionID:   sessionID,\n\t\t\t\t\t\tPath:        absFilePath,\n\t\t\t\t\t\tToolCallID:  call.ID,\n\t\t\t\t\t\tToolName:    ViewToolName,\n\t\t\t\t\t\tAction:      \"read\",\n\t\t\t\t\t\tDescription: fmt.Sprintf(\"Read file outside working directory: %s\", absFilePath),\n\t\t\t\t\t\tParams:      ViewPermissionsParams(params),\n\t\t\t\t\t},\n\t\t\t\t)\n\n\t\t\t\tif !granted {\n\t\t\t\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if file exists\n\t\t\tfileInfo, err := os.Stat(filePath)\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\t// Try to offer suggestions for similarly named files\n\t\t\t\t\tdir := filepath.Dir(filePath)\n\t\t\t\t\tbase := filepath.Base(filePath)\n\n\t\t\t\t\tdirEntries, dirErr := os.ReadDir(dir)\n\t\t\t\t\tif dirErr == nil {\n\t\t\t\t\t\tvar suggestions []string\n\t\t\t\t\t\tfor _, entry := range dirEntries {\n\t\t\t\t\t\t\tif strings.Contains(strings.ToLower(entry.Name()), strings.ToLower(base)) ||\n\t\t\t\t\t\t\t\tstrings.Contains(strings.ToLower(base), strings.ToLower(entry.Name())) {\n\t\t\t\t\t\t\t\tsuggestions = append(suggestions, filepath.Join(dir, entry.Name()))\n\t\t\t\t\t\t\t\tif len(suggestions) >= 3 {\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif len(suggestions) > 0 {\n\t\t\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"File not found: %s\\nTried paths:\\n- %s\\n- %s\\n\\nDid you mean one of these?\\n%s\",\n\t\t\t\t\t\t\t\tparams.FilePath, filePath, absFilePath, strings.Join(suggestions, \"\\n\"))), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tLogViewError(ViewDiagnosticsInfo{\n\t\t\t\t\t\tFilePath: filePath,\n\t\t\t\t\t\tOffset:   params.Offset,\n\t\t\t\t\t\tLimit:    params.Limit,\n\t\t\t\t\t}, \"file not found\")\n\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"File not found: %s\", filePath)), nil\n\t\t\t\t}\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error accessing file: %w\", err)\n\t\t\t}\n\n\t\t\t// Check if it's a directory - provide helpful response instead of error\n\t\t\tif fileInfo.IsDir() {\n\t\t\t\t// List directory contents to help AI understand what's available\n\t\t\t\tdirEntries, err := os.ReadDir(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"Cannot read directory: %s. Error: %v\", filePath, err)), nil\n\t\t\t\t}\n\n\t\t\t\t// Build helpful response with directory contents\n\t\t\t\tvar fileList []string\n\t\t\t\tfor _, entry := range dirEntries {\n\t\t\t\t\tfileList = append(fileList, entry.Name())\n\t\t\t\t}\n\n\t\t\t\t// Create AI-friendly response with suggestions\n\t\t\t\tresponse := fmt.Sprintf(\"Path is a directory: %s\\n\\nDirectory contents:\\n\", filePath)\n\t\t\t\tfor i, file := range fileList {\n\t\t\t\t\tresponse += fmt.Sprintf(\"%d. %s\\n\", i+1, file)\n\t\t\t\t}\n\n\t\t\t\tresponse += \"\\n\ud83d\udca1 Suggestions:\\n\"\n\t\t\t\tresponse += \"- Use 'view' with a specific file path (e.g., 'view internal/db/db.go')\\n\"\n\t\t\t\tresponse += \"- Use 'ls' command to explore directory structure\\n\"\n\t\t\t\tresponse += \"- Try 'find' to search for specific files\\n\"\n\n\t\t\t\treturn fantasy.NewTextResponse(response), nil\n\t\t\t}\n\n\t\t\t// Check file size\n\t\t\tif fileInfo.Size() > MaxReadSize {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"File is too large (%d bytes). Maximum size is %d bytes\",\n\t\t\t\t\tfileInfo.Size(), MaxReadSize)), nil\n\t\t\t}\n\n\t\t\t// Set default limit if not provided\n\t\t\tif params.Limit <= 0 {\n\t\t\t\tparams.Limit = DefaultReadLimit\n\t\t\t}\n\n\t\t\t// Validate offset to prevent negative slice bounds panic\n\t\t\tif params.Offset < 0 {\n\t\t\t\tparams.Offset = 0\n\t\t\t}\n\n\t\t\tisImage, mimeType := getImageMimeType(filePath)\n\t\t\tif isImage {\n\t\t\t\tif !GetSupportsImagesFromContext(ctx) {\n\t\t\t\t\tmodelName := GetModelNameFromContext(ctx)\n\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"This model (%s) does not support image data.\", modelName)), nil\n\t\t\t\t}\n\n\t\t\t\timageData, err := os.ReadFile(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error reading image file: %w\", err)\n\t\t\t\t}\n\n\t\t\t\tencoded := base64.StdEncoding.EncodeToString(imageData)\n\t\t\t\treturn fantasy.NewImageResponse([]byte(encoded), mimeType), nil\n\t\t\t}\n\n\t\t\t// Read the file content\n\t\t\tcontent, lineCount, err := readTextFile(filePath, params.Offset, params.Limit)\n\t\t\t// Validate and sanitize UTF-8 content to prevent crashes\n\t\t\tif !utf8.ValidString(content) {\n\t\t\t\t// Fix invalid UTF-8 sequences instead of failing\n\t\t\t\tcontent = strings.ToValidUTF8(content, \"\ufffd\")\n\t\t\t\tif !utf8.ValidString(content) {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"Warning: Content still contains invalid UTF-8 after repair attempts\")\n\t\t\t\t\t// As a last resort, filter out all invalid sequences\n\t\t\t\t\tcontent = strings.ToValidUTF8(content, \"\")\n\t\t\t\t\tif !utf8.ValidString(content) {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"Warning: Using fallback UTF-8 sanitization\")\n\t\t\t\t\t\t// Final fallback - remove all non-ASCII characters\n\t\t\t\t\t\tcontent = strings.Map(func(r rune) rune {\n\t\t\t\t\t\t\tif r < 128 {\n\t\t\t\t\t\t\t\treturn r\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn '\ufffd'\n\t\t\t\t\t\t}, content)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLogViewError(ViewDiagnosticsInfo{\n\t\t\t\t\tFilePath: filePath,\n\t\t\t\t\tFileSize: fileInfo.Size(),\n\t\t\t\t}, \"invalid UTF-8 sanitized\")\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error reading file: %w\", err)\n\t\t\t}\n\n\t\t\tnotifyLSPs(ctx, lspClients, filePath)\n\t\t\toutput := \"<file>\\n\"\n\t\t\t// Format the output with line numbers\n\t\t\toutput += addLineNumbers(content, params.Offset+1)\n\n\t\t\t// Add a note if the content was truncated\n\t\t\tif lineCount > params.Offset+len(strings.Split(content, \"\\n\")) {\n\t\t\t\toutput += fmt.Sprintf(\"\\n\\n(File has more lines. Use 'offset' parameter to read beyond line %d)\",\n\t\t\t\t\tparams.Offset+len(strings.Split(content, \"\\n\")))\n\t\t\t}\n\t\t\toutput += \"\\n</file>\\n\"\n\n\t\t\t// Add file information to help context awareness\n\t\t\tlinesRead := len(strings.Split(content, \"\\n\"))\n\t\t\toutput += fmt.Sprintf(\"\\n\\n\ud83d\udcc4 File: %d KB \u2014 showing lines %d-%d of %d total (default chunks: 100 lines)\",\n\t\t\t\tint(fileInfo.Size()/1024),\n\t\t\t\tparams.Offset+1,\n\t\t\t\tparams.Offset+linesRead,\n\t\t\t\tlineCount)\n\n\t\t\t// Suggest how to read more if needed\n\t\t\tif lineCount > params.Offset+linesRead {\n\t\t\t\toutput += fmt.Sprintf(\"\\n\ud83d\udca1 Use offset=%d to read next chunk\", params.Offset+linesRead)\n\t\t\t}\n\n\t\t\toutput += getDiagnostics(filePath, lspClients)\n\t\t\trecordFileRead(filePath)\n\t\t\tduration := time.Since(startTime).Seconds() * 1000\n\t\t\tLogViewOperation(ViewDiagnosticsInfo{\n\t\t\t\tFilePath:  filePath,\n\t\t\t\tOffset:    params.Offset,\n\t\t\t\tLimit:     params.Limit,\n\t\t\t\tFileSize:  fileInfo.Size(),\n\t\t\t\tLineCount: lineCount,\n\t\t\t}, duration)\n\t\t\treturn fantasy.WithResponseMetadata(\n\t\t\t\tfantasy.NewTextResponse(output),\n\t\t\t\tViewResponseMetadata{\n\t\t\t\t\tFilePath: filePath,\n\t\t\t\t\tContent:  content,\n\t\t\t\t},\n\t\t\t), nil\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_addLineNumbers_279": {
      "name": "addLineNumbers",
      "type": "function",
      "start_line": 279,
      "end_line": 305,
      "content_hash": "ca149832f0a69c5c3053c5f67d32711180e4a048",
      "content": "func addLineNumbers(content string, startLine int) string {\n\tif content == \"\" {\n\t\treturn \"\"\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\n\tvar result []string\n\tfor i, line := range lines {\n\t\tline = strings.TrimSuffix(line, \"\\r\")\n\t\t// Replace tabs with visible indicator for clarity in output\n\t\tline = strings.ReplaceAll(line, \"\\t\", \"\u2192\\t\")\n\n\t\tlineNum := i + startLine\n\t\tnumStr := fmt.Sprintf(\"%d\", lineNum)\n\n\t\tif len(numStr) >= 6 {\n\t\t\tresult = append(result, fmt.Sprintf(\"%s|%s\", numStr, line))\n\t\t} else {\n\t\t\tpaddedNum := fmt.Sprintf(\"%6s\", numStr)\n\t\t\tresult = append(result, fmt.Sprintf(\"%s|%s\", paddedNum, line))\n\t\t}\n\t}\n\n\treturn strings.Join(result, \"\\n\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_readTextFile_306": {
      "name": "readTextFile",
      "type": "function",
      "start_line": 306,
      "end_line": 357,
      "content_hash": "6b70d44fe4f21908a9713961613e156dd77253b6",
      "content": "func readTextFile(filePath string, offset, limit int) (string, int, error) {\n\t// Ensure start is non-negative to prevent panic\n\tif offset < 0 {\n\t\toffset = 0\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", 0, err\n\t}\n\tdefer file.Close()\n\n\tlineCount := 0\n\n\t// Read entire file with UTF-8 handling\n\tcontent, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn \"\", 0, err\n\t}\n\n\t// Ensure UTF-8 validity\n\tif !utf8.Valid(content) {\n\t\t// Fix invalid UTF-8 sequences\n\t\tcontent = bytes.ToValidUTF8(content, []byte(\"\ufffd\"))\n\t}\n\n\t// Split into lines\n\tlines := strings.Split(string(content), \"\\n\")\n\tlineCount = len(lines)\n\n\t// Validate each line and truncate if necessary\n\tfor i := range lines {\n\t\tif len(lines[i]) > MaxLineLength {\n\t\t\tlines[i] = lines[i][:MaxLineLength] + \"...\"\n\t\t}\n\t}\n\n\t// Apply offset and limit\n\tstart := offset\n\tif start >= lineCount {\n\t\treturn \"\", lineCount, nil\n\t}\n\n\tend := start + limit\n\tif end > lineCount {\n\t\tend = lineCount\n\t}\n\n\tresultLines := lines[start:end]\n\treturn strings.Join(resultLines, \"\\n\"), lineCount, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getImageMimeType_358": {
      "name": "getImageMimeType",
      "type": "function",
      "start_line": 358,
      "end_line": 377,
      "content_hash": "e0dc619f9f88e40505cce5ec1ba3f187dab8b2a1",
      "content": "func getImageMimeType(filePath string) (bool, string) {\n\text := strings.ToLower(filepath.Ext(filePath))\n\tswitch ext {\n\tcase \".jpg\", \".jpeg\":\n\t\treturn true, \"image/jpeg\"\n\tcase \".png\":\n\t\treturn true, \"image/png\"\n\tcase \".gif\":\n\t\treturn true, \"image/gif\"\n\tcase \".bmp\":\n\t\treturn true, \"image/bmp\"\n\tcase \".svg\":\n\t\treturn true, \"image/svg+xml\"\n\tcase \".webp\":\n\t\treturn true, \"image/webp\"\n\tdefault:\n\t\treturn false, \"\"\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_LineScanner_378": {
      "name": "LineScanner",
      "type": "struct",
      "start_line": 378,
      "end_line": 381,
      "content_hash": "1f7c0e1bec358189ef0ba4291fdd8d0d844add60",
      "content": "type LineScanner struct {\n\tscanner *bufio.Scanner\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewLineScanner_382": {
      "name": "NewLineScanner",
      "type": "function",
      "start_line": 382,
      "end_line": 392,
      "content_hash": "9f00b044e95a7787c90e22c61c0ccf3ad188f0e6",
      "content": "func NewLineScanner(r io.Reader) *LineScanner {\n\tscanner := bufio.NewScanner(r)\n\t// Increase buffer size to handle large lines (e.g., minified JSON, HTML)\n\t// Default is 64KB, set to 1MB\n\tbuf := make([]byte, 0, 64*1024)\n\tscanner.Buffer(buf, 1024*1024)\n\treturn &LineScanner{\n\t\tscanner: scanner,\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Scan_393": {
      "name": "Scan",
      "type": "method",
      "start_line": 393,
      "end_line": 396,
      "content_hash": "e4020fda02dffa51d6e5103e5914525f76cd3164",
      "content": "func (s *LineScanner) Scan() bool {\n\treturn s.scanner.Scan()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Text_397": {
      "name": "Text",
      "type": "method",
      "start_line": 397,
      "end_line": 400,
      "content_hash": "2ebdbf623e0c3eacb2c60870e7b89ffde1ad852f",
      "content": "func (s *LineScanner) Text() string {\n\treturn s.scanner.Text()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Err_401": {
      "name": "Err",
      "type": "method",
      "start_line": 401,
      "end_line": 403,
      "content_hash": "6789ddf7a44289f65465d3b96928976a1dea71cd",
      "content": "func (s *LineScanner) Err() error {\n\treturn s.scanner.Err()\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}