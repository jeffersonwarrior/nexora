{
  "file_path": "/work/.local/tools/modelscan/sdk/storage/database.go",
  "file_hash": "4218fcdc29b88672ada516f77b615ab7cacdca4d",
  "updated_at": "2025-12-26T17:34:21.632870",
  "symbols": {
    "struct_AgentDB_17": {
      "name": "AgentDB",
      "type": "struct",
      "start_line": 17,
      "end_line": 21,
      "content_hash": "5aaf5a345a774fed4f87ca1bc741c3edfc67ccb7",
      "content": "type AgentDB struct {\n\tdb *sql.DB\n}\n\n// NewAgentDB creates a new agent database instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewAgentDB_22": {
      "name": "NewAgentDB",
      "type": "function",
      "start_line": 22,
      "end_line": 43,
      "content_hash": "c7076cfb58afd1a38ab41789c9c6d331ab312d22",
      "content": "func NewAgentDB(dbPath string) (*AgentDB, error) {\n\t// Ensure directory exists\n\tif dir := filepath.Dir(dbPath); dir != \".\" {\n\t\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create database directory: %w\", err)\n\t\t}\n\t}\n\n\tdb, err := sql.Open(\"sqlite3\", dbPath+\"?_journal=WAL&_fk=true\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open database: %w\", err)\n\t}\n\n\tagentDB := &AgentDB{db: db}\n\tif err := agentDB.init(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize database: %w\", err)\n\t}\n\n\treturn agentDB, nil\n}\n\n// init creates tables and runs migrations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_init_44": {
      "name": "init",
      "type": "method",
      "start_line": 44,
      "end_line": 56,
      "content_hash": "6438fb6c9f48d33b9f5cab01fd645bb2c81fa9d5",
      "content": "func (adb *AgentDB) init() error {\n\tif err := adb.createTables(); err != nil {\n\t\treturn fmt.Errorf(\"failed to create tables: %w\", err)\n\t}\n\n\tif err := adb.runMigrations(); err != nil {\n\t\treturn fmt.Errorf(\"failed to run migrations: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// createTables creates the initial database schema",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createTables_57": {
      "name": "createTables",
      "type": "method",
      "start_line": 57,
      "end_line": 186,
      "content_hash": "45054302c56d208f8837e283edf3fc68efdd5058",
      "content": "func (adb *AgentDB) createTables() error {\n\tqueries := []string{\n\t\t`CREATE TABLE IF NOT EXISTS schema_migrations (\n\t\t\tversion INTEGER PRIMARY KEY,\n\t\t\tapplied_at DATETIME DEFAULT CURRENT_TIMESTAMP\n\t\t)`,\n\n\t\t// Agents table\n\t\t`CREATE TABLE IF NOT EXISTS agents (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tname TEXT NOT NULL,\n\t\t\tcapabilities TEXT,\n\t\t\tconfig TEXT,\n\t\t\tstatus TEXT DEFAULT 'inactive',\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tupdated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n\t\t)`,\n\n\t\t// Teams table\n\t\t`CREATE TABLE IF NOT EXISTS teams (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tname TEXT NOT NULL,\n\t\t\tconfig TEXT,\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tupdated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n\t\t)`,\n\n\t\t// Team membership\n\t\t`CREATE TABLE IF NOT EXISTS team_members (\n\t\t\tteam_id TEXT,\n\t\t\tagent_id TEXT,\n\t\t\trole TEXT DEFAULT 'member',\n\t\t\tjoined_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tPRIMARY KEY (team_id, agent_id),\n\t\t\tFOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,\n\t\t\tFOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE\n\t\t)`,\n\n\t\t// Tasks table\n\t\t`CREATE TABLE IF NOT EXISTS tasks (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tagent_id TEXT NOT NULL,\n\t\t\tteam_id TEXT,\n\t\t\ttype TEXT NOT NULL,\n\t\t\tstatus TEXT DEFAULT 'pending',\n\t\t\tpriority INTEGER DEFAULT 1,\n\t\t\tinput TEXT,\n\t\t\toutput TEXT,\n\t\t\tmetadata TEXT,\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tstarted_at DATETIME,\n\t\t\tcompleted_at DATETIME,\n\t\t\tupdated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tFOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE,\n\t\t\tFOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE SET NULL\n\t\t)`,\n\n\t\t// Messages table\n\t\t`CREATE TABLE IF NOT EXISTS messages (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tfrom_agent TEXT,\n\t\t\tto_agent TEXT,\n\t\t\tteam_id TEXT,\n\t\t\tmessage_type TEXT,\n\t\t\tcontent TEXT,\n\t\t\tdata TEXT,\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tFOREIGN KEY (from_agent) REFERENCES agents(id),\n\t\t\tFOREIGN KEY (to_agent) REFERENCES agents(id),\n\t\t\tFOREIGN KEY (team_id) REFERENCES teams(id)\n\t\t)`,\n\n\t\t// Tool executions\n\t\t`CREATE TABLE IF NOT EXISTS tool_executions (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\ttask_id TEXT,\n\t\t\tagent_id TEXT,\n\t\t\ttool_name TEXT NOT NULL,\n\t\t\ttool_type TEXT,\n\t\t\tinput TEXT,\n\t\t\toutput TEXT,\n\t\t\terror TEXT,\n\t\t\tstatus TEXT DEFAULT 'pending',\n\t\t\tduration INTEGER DEFAULT 0,\n\t\t\tmetadata TEXT,\n\t\t\tstarted_at DATETIME,\n\t\t\tcompleted_at DATETIME,\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tFOREIGN KEY (agent_id) REFERENCES agents(id)\n\t\t)`,\n\n\t\t// Agent statistics\n\t\t`CREATE TABLE IF NOT EXISTS agent_stats (\n\t\t\tagent_id TEXT PRIMARY KEY,\n\t\t\ttasks_completed INTEGER DEFAULT 0,\n\t\t\ttasks_failed INTEGER DEFAULT 0,\n\t\t\ttotal_execution_time_ms INTEGER DEFAULT 0,\n\t\t\tlast_activity DATETIME,\n\t\t\tupdated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n\t\t\tFOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE\n\t\t)`,\n\t}\n\n\tfor _, query := range queries {\n\t\tif _, err := adb.db.Exec(query); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute query: %s: %w\", query, err)\n\t\t}\n\t}\n\n\t// Create indexes for common queries\n\tindexes := []string{\n\t\t`CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority DESC)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_tasks_agent_id ON tasks(agent_id, status)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at DESC)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_messages_between_agents ON messages(from_agent, to_agent)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_tool_executions_agent ON tool_executions(agent_id, created_at DESC)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status)`,\n\t}\n\n\tfor _, query := range indexes {\n\t\tif _, err := adb.db.Exec(query); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create index: %s: %w\", query, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// runMigrations handles database schema versioning",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_runMigrations_187": {
      "name": "runMigrations",
      "type": "method",
      "start_line": 187,
      "end_line": 225,
      "content_hash": "5392db64c2166e5340ba9bd50148d8fdbdfae919",
      "content": "func (adb *AgentDB) runMigrations() error {\n\t// Get current migration version\n\tvar version int\n\terr := adb.db.QueryRow(\"SELECT COALESCE(MAX(version), 0) FROM schema_migrations\").Scan(&version)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get migration version: %w\", err)\n\t}\n\n\t// Apply migrations in order\n\tmigrations := []func(*sql.DB) error{\n\t\tmigrationV1InitialSchema,\n\t\tmigrationV2AddTeamDescription,\n\t\tmigrationV3UpdateToolExecutions,\n\t}\n\n\tfor i, migration := range migrations {\n\t\tmigrationVersion := i + 1\n\t\tif version >= migrationVersion {\n\t\t\tcontinue // Skip already applied migrations\n\t\t}\n\n\t\tlog.Printf(\"Applying migration v%d\", migrationVersion)\n\t\tif err := migration(adb.db); err != nil {\n\t\t\treturn fmt.Errorf(\"migration v%d failed: %w\", migrationVersion, err)\n\t\t}\n\n\t\t// Mark migration as applied\n\t\tif _, err := adb.db.Exec(\n\t\t\t\"INSERT INTO schema_migrations (version) VALUES (?)\",\n\t\t\tmigrationVersion,\n\t\t); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to mark migration v%d: %w\", migrationVersion, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// migrationV1InitialSchema is the initial schema migration",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_migrationV1InitialSchema_226": {
      "name": "migrationV1InitialSchema",
      "type": "function",
      "start_line": 226,
      "end_line": 232,
      "content_hash": "cb12dac985e41aaf9d6f96572071ecb67bbcc589",
      "content": "func migrationV1InitialSchema(db *sql.DB) error {\n\t// Initial schema is already created in createTables()\n\t// This migration is a placeholder for future schema changes\n\treturn nil\n}\n\n// migrationV2AddTeamDescription adds the description column to teams table",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_migrationV2AddTeamDescription_233": {
      "name": "migrationV2AddTeamDescription",
      "type": "function",
      "start_line": 233,
      "end_line": 304,
      "content_hash": "d50eeda321ef2e943080b9f381ece39433d1eec9",
      "content": "func migrationV2AddTeamDescription(db *sql.DB) error {\n\t// Add description column to teams table\n\t_, err := db.Exec(\"ALTER TABLE teams ADD COLUMN description TEXT\")\n\tif err != nil {\n\t\t// Check if column already exists (SQLite doesn't support IF NOT EXISTS for columns)\n\t\t// If the error indicates the column already exists, that's okay\n\t\tif !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\t\treturn fmt.Errorf(\"failed to add description column to teams: %w\", err)\n\t\t}\n\t}\n\n\t// Add metadata column to teams table\n\t_, err = db.Exec(\"ALTER TABLE teams ADD COLUMN metadata TEXT\")\n\tif err != nil {\n\t\tif !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\t\treturn fmt.Errorf(\"failed to add metadata column to teams: %w\", err)\n\t\t}\n\t}\n\n\t// Update schema for tasks table to match Task struct\n\t// Add agent_id column (if assigned_to doesn't exist, use it)\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN agent_id TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add agent_id column to tasks: %w\", err)\n\t}\n\n\t// Add team_id column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN team_id TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add team_id column to tasks: %w\", err)\n\t}\n\n\t// Add type column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN type TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add type column to tasks: %w\", err)\n\t}\n\n\t// Add input column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN input TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add input column to tasks: %w\", err)\n\t}\n\n\t// Add output column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN output TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add output column to tasks: %w\", err)\n\t}\n\n\t// Add metadata column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN metadata TEXT\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add metadata column to tasks: %w\", err)\n\t}\n\n\t// Add started_at column\n\t_, err = db.Exec(\"ALTER TABLE tasks ADD COLUMN started_at DATETIME\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add started_at column to tasks: %w\", err)\n\t}\n\n\t// Add updated_at column to team_members table\n\t_, err = db.Exec(\"ALTER TABLE team_members ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\")\n\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\treturn fmt.Errorf(\"failed to add updated_at column to team_members: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// migrationV3UpdateToolExecutions updates the tool_executions table schema",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_migrationV3UpdateToolExecutions_305": {
      "name": "migrationV3UpdateToolExecutions",
      "type": "function",
      "start_line": 305,
      "end_line": 335,
      "content_hash": "b7fe91cefd2a28104fc9b37d41efd7f34a287d5b",
      "content": "func migrationV3UpdateToolExecutions(db *sql.DB) error {\n\t// Add missing columns to tool_executions table\n\tcolumns := []struct {\n\t\tname, sqlType string\n\t}{\n\t\t{\"task_id\", \"TEXT\"},\n\t\t{\"tool_type\", \"TEXT\"},\n\t\t{\"status\", \"TEXT DEFAULT 'pending'\"},\n\t\t{\"duration\", \"INTEGER DEFAULT 0\"},\n\t\t{\"metadata\", \"TEXT\"},\n\t\t{\"started_at\", \"DATETIME\"},\n\t\t{\"completed_at\", \"DATETIME\"},\n\t}\n\n\tfor _, col := range columns {\n\t\t_, err := db.Exec(fmt.Sprintf(\"ALTER TABLE tool_executions ADD COLUMN %s %s\", col.name, col.sqlType))\n\t\tif err != nil && !strings.Contains(err.Error(), \"duplicate column name\") {\n\t\t\treturn fmt.Errorf(\"failed to add %s column to tool_executions: %w\", col.name, err)\n\t\t}\n\t}\n\n\t// Rename error_message to error if it exists\n\t_, err := db.Exec(\"ALTER TABLE tool_executions RENAME COLUMN error_message TO error\")\n\tif err != nil && !strings.Contains(err.Error(), \"no such column\") {\n\t\t// Column might not exist or rename failed, that's okay for this migration\n\t}\n\n\treturn nil\n}\n\n// Close closes the database connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_336": {
      "name": "Close",
      "type": "method",
      "start_line": 336,
      "end_line": 343,
      "content_hash": "027ed12c66c77907e0f43e2fba5a49fd0617be20",
      "content": "func (adb *AgentDB) Close() error {\n\tif adb.db != nil {\n\t\treturn adb.db.Close()\n\t}\n\treturn nil\n}\n\n// GetDB returns the underlying database connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetDB_344": {
      "name": "GetDB",
      "type": "method",
      "start_line": 344,
      "end_line": 348,
      "content_hash": "ad387ed920812b422a49526aac2132c6e3fff345",
      "content": "func (adb *AgentDB) GetDB() *sql.DB {\n\treturn adb.db\n}\n\n// CleanupOldData removes records older than the specified duration",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CleanupOldData_349": {
      "name": "CleanupOldData",
      "type": "method",
      "start_line": 349,
      "end_line": 380,
      "content_hash": "999c6b6909a56a86a8a8540ee7af6c654df2478c",
      "content": "func (adb *AgentDB) CleanupOldData(ctx context.Context, olderThan time.Duration) error {\n\tcutoffTime := time.Now().Add(-olderThan)\n\n\tqueries := []string{\n\t\t\"DELETE FROM messages WHERE created_at < ?\",\n\t\t\"DELETE FROM tool_executions WHERE started_at < ? OR (started_at IS NULL AND created_at < ?)\",\n\t\t\"DELETE FROM tasks WHERE status IN ('completed', 'failed') AND completed_at < ?\",\n\t}\n\n\tfor _, query := range queries {\n\t\tvar args []interface{}\n\t\tif strings.Contains(query, \"tool_executions\") {\n\t\t\targs = []interface{}{cutoffTime, cutoffTime}\n\t\t} else {\n\t\t\targs = []interface{}{cutoffTime}\n\t\t}\n\n\t\tresult, err := adb.db.ExecContext(ctx, query, args...)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cleanup query failed: %s: %w\", query, err)\n\t\t}\n\n\t\trowsAffected, _ := result.RowsAffected()\n\t\tif rowsAffected > 0 {\n\t\t\tlog.Printf(\"Cleaned up %d rows with query: %s\", rowsAffected, query)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// StartCleanupScheduler starts a goroutine that periodically cleans up old data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StartCleanupScheduler_381": {
      "name": "StartCleanupScheduler",
      "type": "method",
      "start_line": 381,
      "end_line": 397,
      "content_hash": "8c4ca0a5f7d73a3c5bf07ca930d5355db3a833e5",
      "content": "func (adb *AgentDB) StartCleanupScheduler(ctx context.Context, interval time.Duration, retention time.Duration) {\n\tgo func() {\n\t\tticker := time.NewTicker(interval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tif err := adb.CleanupOldData(ctx, retention); err != nil {\n\t\t\t\t\tlog.Printf(\"Cleanup failed: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}