{
  "file_path": "/work/internal/agent/tools/multiedit.go",
  "file_hash": "0933165c41d2b9be815d7353e1f959b6f34420cd",
  "updated_at": "2025-12-26T17:34:20.541261",
  "symbols": {
    "struct_MultiEditOperation_24": {
      "name": "MultiEditOperation",
      "type": "struct",
      "start_line": 24,
      "end_line": 29,
      "content_hash": "5a96d67ebfc217955425f3cae0e5e4eadd12b63e",
      "content": "type MultiEditOperation struct {\n\tOldString  string `json:\"old_string\" description:\"The text to replace\"`\n\tNewString  string `json:\"new_string\" description:\"The text to replace it with\"`\n\tReplaceAll bool   `json:\"replace_all,omitempty\" description:\"Replace all occurrences of old_string (default false).\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MultiEditParams_30": {
      "name": "MultiEditParams",
      "type": "struct",
      "start_line": 30,
      "end_line": 34,
      "content_hash": "77b7b4324836260a54e40e68e5c0e79fcb74c076",
      "content": "type MultiEditParams struct {\n\tFilePath string               `json:\"file_path\" description:\"The absolute path to the file to modify\"`\n\tEdits    []MultiEditOperation `json:\"edits\" description:\"Array of edit operations to perform sequentially on the file\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MultiEditPermissionsParams_35": {
      "name": "MultiEditPermissionsParams",
      "type": "struct",
      "start_line": 35,
      "end_line": 40,
      "content_hash": "ef08dc67b30d21bec52259f6d260366c06921a2b",
      "content": "type MultiEditPermissionsParams struct {\n\tFilePath   string `json:\"file_path\"`\n\tOldContent string `json:\"old_content,omitempty\"`\n\tNewContent string `json:\"new_content,omitempty\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FailedEdit_41": {
      "name": "FailedEdit",
      "type": "struct",
      "start_line": 41,
      "end_line": 46,
      "content_hash": "a6e90089594ea7041f5d3ab11244601ab59a40f0",
      "content": "type FailedEdit struct {\n\tIndex int                `json:\"index\"`\n\tError string             `json:\"error\"`\n\tEdit  MultiEditOperation `json:\"edit\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MultiEditResponseMetadata_47": {
      "name": "MultiEditResponseMetadata",
      "type": "struct",
      "start_line": 47,
      "end_line": 61,
      "content_hash": "20afb63a397f879b2b4dcf630159f632badde41a",
      "content": "type MultiEditResponseMetadata struct {\n\tAdditions    int          `json:\"additions\"`\n\tRemovals     int          `json:\"removals\"`\n\tOldContent   string       `json:\"old_content,omitempty\"`\n\tNewContent   string       `json:\"new_content,omitempty\"`\n\tEditsApplied int          `json:\"edits_applied\"`\n\tEditsFailed  []FailedEdit `json:\"edits_failed,omitempty\"`\n\tFailedEdits  []FailedEdit `json:\"failed_edits,omitempty\"`\n}\n\nconst MultiEditToolName = \"multiedit\"\n\n//go:embed multiedit.md\nvar multieditDescription []byte\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMultiEditTool_62": {
      "name": "NewMultiEditTool",
      "type": "function",
      "start_line": 62,
      "end_line": 111,
      "content_hash": "232e1beca021eb398a8ea7d2b75b9eb8d5c03b5f",
      "content": "func NewMultiEditTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, files history.Service, workingDir string, aiops aiops.Ops) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tMultiEditToolName,\n\t\tstring(multieditDescription),\n\t\tfunc(ctx context.Context, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\tif params.FilePath == \"\" {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"file_path is required\"), nil\n\t\t\t}\n\n\t\t\tif len(params.Edits) == 0 {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"at least one edit operation is required\"), nil\n\t\t\t}\n\n\t\t\tparams.FilePath = filepathext.SmartJoin(workingDir, params.FilePath)\n\n\t\t\t// Validate all edits before applying any\n\t\t\tif err := validateEdits(params.Edits); err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(err.Error()), nil\n\t\t\t}\n\n\t\t\tvar response fantasy.ToolResponse\n\t\t\tvar err error\n\n\t\t\teditCtx := editContext{ctx, permissions, files, workingDir, aiops}\n\t\t\t// Handle file creation case (first edit has empty old_string)\n\t\t\tif len(params.Edits) > 0 && params.Edits[0].OldString == \"\" {\n\t\t\t\tresponse, err = processMultiEditWithCreation(editCtx, params, call)\n\t\t\t} else {\n\t\t\t\tresponse, err = processMultiEditExistingFile(editCtx, params, call)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn response, err\n\t\t\t}\n\n\t\t\tif response.IsError {\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\t\t// Notify LSP clients about the change\n\t\t\tnotifyLSPs(ctx, lspClients, params.FilePath)\n\n\t\t\t// Wait for LSP diagnostics and add them to the response\n\t\t\ttext := fmt.Sprintf(\"<result>\\n%s\\n</result>\\n\", response.Content)\n\t\t\ttext += getDiagnostics(params.FilePath, lspClients)\n\t\t\tresponse.Content = text\n\t\t\treturn response, nil\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_validateEdits_112": {
      "name": "validateEdits",
      "type": "function",
      "start_line": 112,
      "end_line": 121,
      "content_hash": "ba60d2bc68f198514f1d6dc374cd5ecb3df0a06b",
      "content": "func validateEdits(edits []MultiEditOperation) error {\n\tfor i, edit := range edits {\n\t\t// Only the first edit can have empty old_string (for file creation)\n\t\tif i > 0 && edit.OldString == \"\" {\n\t\t\treturn fmt.Errorf(\"edit %d: only the first edit can have empty old_string (for file creation)\", i+1)\n\t\t}\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_processMultiEditWithCreation_122": {
      "name": "processMultiEditWithCreation",
      "type": "function",
      "start_line": 122,
      "end_line": 233,
      "content_hash": "60f3cb97f614dd40ffdc1ac2a05c110fb304282b",
      "content": "func processMultiEditWithCreation(edit editContext, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t// First edit creates the file\n\tfirstEdit := params.Edits[0]\n\tif firstEdit.OldString != \"\" {\n\t\treturn fantasy.NewTextErrorResponse(\"first edit must have empty old_string for file creation\"), nil\n\t}\n\n\t// Check if file already exists\n\tif _, err := os.Stat(params.FilePath); err == nil {\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"file already exists: %s\", params.FilePath)), nil\n\t} else if !os.IsNotExist(err) {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to access file: %w\", err)\n\t}\n\n\t// Create parent directories\n\tdir := filepath.Dir(params.FilePath)\n\tif err := os.MkdirAll(dir, 0o755); err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to create parent directories: %w\", err)\n\t}\n\n\t// Start with the content from the first edit\n\tcurrentContent := firstEdit.NewString\n\n\t// Apply remaining edits to the content, tracking failures\n\tvar failedEdits []FailedEdit\n\tfor i := 1; i < len(params.Edits); i++ {\n\t\teditOp := params.Edits[i]\n\t\tnewContent, err := applyEditToContent(edit.ctx, params.FilePath, currentContent, editOp)\n\t\tif err != nil {\n\t\t\tfailedEdits = append(failedEdits, FailedEdit{\n\t\t\t\tIndex: i + 1,\n\t\t\t\tError: err.Error(),\n\t\t\t\tEdit:  editOp,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tcurrentContent = newContent\n\t}\n\n\t// Get session and message IDs\n\tsessionID := GetSessionFromContext(edit.ctx)\n\tif sessionID == \"\" {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for creating a new file\")\n\t}\n\n\t// Check permissions\n\t_, additions, removals := diff.GenerateDiff(\"\", currentContent, strings.TrimPrefix(params.FilePath, edit.workingDir))\n\n\teditsApplied := len(params.Edits) - len(failedEdits)\n\tvar description string\n\tif len(failedEdits) > 0 {\n\t\tdescription = fmt.Sprintf(\"Create file %s with %d of %d edits (%d failed)\", params.FilePath, editsApplied, len(params.Edits), len(failedEdits))\n\t} else {\n\t\tdescription = fmt.Sprintf(\"Create file %s with %d edits\", params.FilePath, editsApplied)\n\t}\n\tp := edit.permissions.Request(permission.CreatePermissionRequest{\n\t\tSessionID:   sessionID,\n\t\tPath:        fsext.PathOrPrefix(params.FilePath, edit.workingDir),\n\t\tToolCallID:  call.ID,\n\t\tToolName:    MultiEditToolName,\n\t\tAction:      \"write\",\n\t\tDescription: description,\n\t\tParams: MultiEditPermissionsParams{\n\t\t\tFilePath:   params.FilePath,\n\t\t\tOldContent: \"\",\n\t\t\tNewContent: currentContent,\n\t\t},\n\t})\n\tif !p {\n\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t}\n\n\t// Write the file\n\terr := os.WriteFile(params.FilePath, []byte(currentContent), 0o644)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\t// Update file history\n\t_, err = edit.files.Create(edit.ctx, sessionID, params.FilePath, \"\")\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error creating file history: %w\", err)\n\t}\n\n\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, currentContent)\n\tif err != nil {\n\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t}\n\n\trecordFileWrite(params.FilePath)\n\trecordFileRead(params.FilePath)\n\n\tvar message string\n\tif len(failedEdits) > 0 {\n\t\tmessage = fmt.Sprintf(\"File created with %d of %d edits: %s (%d edit(s) failed)\", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))\n\t} else {\n\t\tmessage = fmt.Sprintf(\"File created with %d edits: %s\", len(params.Edits), params.FilePath)\n\t}\n\n\treturn fantasy.WithResponseMetadata(\n\t\tfantasy.NewTextResponse(message),\n\t\tMultiEditResponseMetadata{\n\t\t\tOldContent:   \"\",\n\t\t\tNewContent:   currentContent,\n\t\t\tAdditions:    additions,\n\t\t\tRemovals:     removals,\n\t\t\tEditsApplied: editsApplied,\n\t\t\tEditsFailed:  failedEdits,\n\t\t},\n\t), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_processMultiEditExistingFile_234": {
      "name": "processMultiEditExistingFile",
      "type": "function",
      "start_line": 234,
      "end_line": 389,
      "content_hash": "3b115e78340b337ff036430a68136eeab37647be",
      "content": "func processMultiEditExistingFile(edit editContext, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t// Validate file exists and is readable\n\tfileInfo, err := os.Stat(params.FilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"file not found: %s\", params.FilePath)), nil\n\t\t}\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to access file: %w\", err)\n\t}\n\n\tif fileInfo.IsDir() {\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"path is a directory, not a file: %s\", params.FilePath)), nil\n\t}\n\n\t// Check if file was read before editing\n\tif getLastReadTime(params.FilePath).IsZero() {\n\t\treturn fantasy.NewTextErrorResponse(\"you must read the file before editing it. Use the View tool first\"), nil\n\t}\n\n\t// Check if file was modified since last read\n\tmodTime := fileInfo.ModTime()\n\tlastRead := getLastReadTime(params.FilePath)\n\tif modTime.After(lastRead) {\n\t\treturn fantasy.NewTextErrorResponse(\n\t\t\tfmt.Sprintf(\"file %s has been modified since it was last read (mod time: %s, last read: %s)\",\n\t\t\t\tparams.FilePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),\n\t\t\t)), nil\n\t}\n\n\t// Read current file content\n\tcontent, err := os.ReadFile(params.FilePath)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\toldContent, isCrlf := fsext.ToUnixLineEndings(string(content))\n\tcurrentContent := oldContent\n\n\t// Apply all edits sequentially, tracking failures\n\tvar failedEdits []FailedEdit\n\tfor i, editOp := range params.Edits {\n\t\tnewContent, err := applyEditToContent(edit.ctx, params.FilePath, currentContent, editOp)\n\t\tif err != nil {\n\t\t\tfailedEdits = append(failedEdits, FailedEdit{\n\t\t\t\tIndex: i + 1,\n\t\t\t\tError: err.Error(),\n\t\t\t\tEdit:  editOp,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tcurrentContent = newContent\n\t}\n\n\t// Check if content actually changed\n\tif oldContent == currentContent {\n\t\t// If we have failed edits, report them\n\t\tif len(failedEdits) > 0 {\n\t\t\treturn fantasy.WithResponseMetadata(\n\t\t\t\tfantasy.NewTextErrorResponse(fmt.Sprintf(\"no changes made - all %d edit(s) failed\", len(failedEdits))),\n\t\t\t\tMultiEditResponseMetadata{\n\t\t\t\t\tEditsApplied: 0,\n\t\t\t\t\tEditsFailed:  failedEdits,\n\t\t\t\t},\n\t\t\t), nil\n\t\t}\n\t\treturn fantasy.NewTextErrorResponse(\"no changes made - all edits resulted in identical content\"), nil\n\t}\n\n\t// Get session and message IDs\n\tsessionID := GetSessionFromContext(edit.ctx)\n\tif sessionID == \"\" {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for editing file\")\n\t}\n\n\t// Generate diff and check permissions\n\t_, additions, removals := diff.GenerateDiff(oldContent, currentContent, strings.TrimPrefix(params.FilePath, edit.workingDir))\n\n\teditsApplied := len(params.Edits) - len(failedEdits)\n\tvar description string\n\tif len(failedEdits) > 0 {\n\t\tdescription = fmt.Sprintf(\"Apply %d of %d edits to file %s (%d failed)\", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))\n\t} else {\n\t\tdescription = fmt.Sprintf(\"Apply %d edits to file %s\", editsApplied, params.FilePath)\n\t}\n\tp := edit.permissions.Request(permission.CreatePermissionRequest{\n\t\tSessionID:   sessionID,\n\t\tPath:        fsext.PathOrPrefix(params.FilePath, edit.workingDir),\n\t\tToolCallID:  call.ID,\n\t\tToolName:    MultiEditToolName,\n\t\tAction:      \"write\",\n\t\tDescription: description,\n\t\tParams: MultiEditPermissionsParams{\n\t\t\tFilePath:   params.FilePath,\n\t\t\tOldContent: oldContent,\n\t\t\tNewContent: currentContent,\n\t\t},\n\t})\n\tif !p {\n\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t}\n\n\tif isCrlf {\n\t\tcurrentContent, _ = fsext.ToWindowsLineEndings(currentContent)\n\t}\n\n\t// Write the updated content\n\terr = os.WriteFile(params.FilePath, []byte(currentContent), 0o644)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\t// Update file history\n\tfile, err := edit.files.GetByPathAndSession(edit.ctx, params.FilePath, sessionID)\n\tif err != nil {\n\t\t_, err = edit.files.Create(edit.ctx, sessionID, params.FilePath, oldContent)\n\t\tif err != nil {\n\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error creating file history: %w\", err)\n\t\t}\n\t}\n\tif file.Content != oldContent {\n\t\t// User manually changed the content, store an intermediate version\n\t\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, oldContent)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t\t}\n\t}\n\n\t// Store the new version\n\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, currentContent)\n\tif err != nil {\n\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t}\n\n\trecordFileWrite(params.FilePath)\n\trecordFileRead(params.FilePath)\n\n\tvar message string\n\tif len(failedEdits) > 0 {\n\t\tmessage = fmt.Sprintf(\"Applied %d of %d edits to file: %s (%d edit(s) failed)\", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))\n\t} else {\n\t\tmessage = fmt.Sprintf(\"Applied %d edits to file: %s\", len(params.Edits), params.FilePath)\n\t}\n\n\treturn fantasy.WithResponseMetadata(\n\t\tfantasy.NewTextResponse(message),\n\t\tMultiEditResponseMetadata{\n\t\t\tOldContent:   oldContent,\n\t\t\tNewContent:   currentContent,\n\t\t\tAdditions:    additions,\n\t\t\tRemovals:     removals,\n\t\t\tEditsApplied: editsApplied,\n\t\t\tEditsFailed:  failedEdits,\n\t\t},\n\t), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyEditToContent_390": {
      "name": "applyEditToContent",
      "type": "function",
      "start_line": 390,
      "end_line": 424,
      "content_hash": "02239eb5557014a488d14bbe428f9da5ea0e18fd",
      "content": "func applyEditToContent(ctx context.Context, filePath string, content string, edit MultiEditOperation) (string, error) {\n\tif edit.OldString == \"\" && edit.NewString == \"\" {\n\t\treturn content, nil\n\t}\n\n\tif edit.OldString == \"\" {\n\t\treturn \"\", fmt.Errorf(\"old_string cannot be empty for content replacement\")\n\t}\n\n\tvar newContent string\n\tvar replacementCount int\n\n\tif edit.ReplaceAll {\n\t\tnewContent = strings.ReplaceAll(content, edit.OldString, edit.NewString)\n\t\treplacementCount = strings.Count(content, edit.OldString)\n\t\tif replacementCount == 0 {\n\t\t\treturn \"\", fmt.Errorf(\"old_string not found in content. Make sure it matches exactly, including whitespace and line breaks\")\n\t\t}\n\t} else {\n\t\tindex := strings.Index(content, edit.OldString)\n\t\tif index == -1 {\n\t\t\treturn \"\", fmt.Errorf(\"old_string not found in content. Make sure it matches exactly, including whitespace and line breaks\")\n\t\t}\n\n\t\tlastIndex := strings.LastIndex(content, edit.OldString)\n\t\tif index != lastIndex {\n\t\t\treturn \"\", fmt.Errorf(\"old_string appears multiple times in the content. Please provide more context to ensure a unique match, or set replace_all to true\")\n\t\t}\n\n\t\tnewContent = content[:index] + edit.NewString + content[index+len(edit.OldString):]\n\t\treplacementCount = 1\n\t}\n\n\treturn newContent, nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}