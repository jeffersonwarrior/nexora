{
  "file_path": "/work/internal/indexer/events.go",
  "file_hash": "298760a543f3e8d4c8469fefacd008662de6bfce",
  "updated_at": "2025-12-26T17:34:22.625848",
  "symbols": {
    "struct_FileChangeEvent_13": {
      "name": "FileChangeEvent",
      "type": "struct",
      "start_line": 13,
      "end_line": 30,
      "content_hash": "ebd5dbad74104e99ce18d3e4ce15e4ab3d424b16",
      "content": "type FileChangeEvent struct {\n\tPath      string    `json:\"path\"`\n\tType      EventType `json:\"type\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n\tSize      int64     `json:\"size,omitempty\"`\n\tChecksum  string    `json:\"checksum,omitempty\"`\n}\n\n// EventType represents the type of file change\ntype EventType string\n\nconst (\n\tEventAdded    EventType = \"added\"\n\tEventModified EventType = \"modified\"\n\tEventRemoved  EventType = \"removed\"\n)\n\n// String returns the string representation of EventType",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_String_31": {
      "name": "String",
      "type": "method",
      "start_line": 31,
      "end_line": 35,
      "content_hash": "2002629ee665153fa76393396aac8b94c76bdda4",
      "content": "func (e EventType) String() string {\n\treturn string(e)\n}\n\n// EventHandler defines the interface for processing file change events",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_EventHandler_36": {
      "name": "EventHandler",
      "type": "interface",
      "start_line": 36,
      "end_line": 42,
      "content_hash": "a92277ea88613e65e6783170563fe697b10b06ae",
      "content": "type EventHandler interface {\n\tHandleEvent(ctx context.Context, event FileChangeEvent) error\n\tName() string\n\tPriority() int\n}\n\n// EventBus manages event distribution to handlers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EventBus_43": {
      "name": "EventBus",
      "type": "struct",
      "start_line": 43,
      "end_line": 52,
      "content_hash": "899db74826e66fa6f32c7b6169ea5fad42505cac",
      "content": "type EventBus struct {\n\thandlers  map[string][]EventHandler\n\tqueuing   bool\n\tqueue     []FileChangeEvent\n\tctx       context.Context\n\tcancel    context.CancelFunc\n\tbatchSize int\n}\n\n// NewEventBus creates a new event bus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewEventBus_53": {
      "name": "NewEventBus",
      "type": "function",
      "start_line": 53,
      "end_line": 65,
      "content_hash": "dfa8394a480f466b63ddc51c24b377d941853e51",
      "content": "func NewEventBus(ctx context.Context) *EventBus {\n\tbusCtx, cancel := context.WithCancel(ctx)\n\treturn &EventBus{\n\t\thandlers:  make(map[string][]EventHandler),\n\t\tqueuing:   false,\n\t\tqueue:     make([]FileChangeEvent, 0),\n\t\tctx:       busCtx,\n\t\tcancel:    cancel,\n\t\tbatchSize: 10,\n\t}\n}\n\n// RegisterHandler registers an event handler for specific event types",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RegisterHandler_66": {
      "name": "RegisterHandler",
      "type": "method",
      "start_line": 66,
      "end_line": 78,
      "content_hash": "2cbfbd0e8fbbaab53f02e22cc02619b05ca4d3c3",
      "content": "func (eb *EventBus) RegisterHandler(eventTypes []EventType, handler EventHandler) {\n\tfor _, eventType := range eventTypes {\n\t\teventTypeStr := string(eventType)\n\t\teb.handlers[eventTypeStr] = append(eb.handlers[eventTypeStr], handler)\n\t}\n\n\tslog.Info(\"Event handler registered\",\n\t\t\"handler\", handler.Name(),\n\t\t\"types\", eventTypes,\n\t\t\"priority\", handler.Priority())\n}\n\n// PublishEvent publishes an event to all registered handlers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_PublishEvent_79": {
      "name": "PublishEvent",
      "type": "method",
      "start_line": 79,
      "end_line": 88,
      "content_hash": "b67d2c359139e0de53fe32b1cf7726dc02987f82",
      "content": "func (eb *EventBus) PublishEvent(event FileChangeEvent) error {\n\tif eb.queuing {\n\t\teb.queue = append(eb.queue, event)\n\t\treturn nil\n\t}\n\n\treturn eb.processEvent(event)\n}\n\n// PublishEvents publishes multiple events",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_PublishEvents_89": {
      "name": "PublishEvents",
      "type": "method",
      "start_line": 89,
      "end_line": 98,
      "content_hash": "f253b905c072811f5d74b4e2ca636c3d9e7c481d",
      "content": "func (eb *EventBus) PublishEvents(events []FileChangeEvent) error {\n\tfor _, event := range events {\n\t\tif err := eb.PublishEvent(event); err != nil {\n\t\t\tslog.Warn(\"Failed to process event\", \"event\", event, \"error\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// StartQueuing enables event queuing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StartQueuing_99": {
      "name": "StartQueuing",
      "type": "method",
      "start_line": 99,
      "end_line": 105,
      "content_hash": "444686b2d644682825fa6f3077cb92dfdacb8d1d",
      "content": "func (eb *EventBus) StartQueuing() {\n\teb.queuing = true\n\teb.queue = make([]FileChangeEvent, 0)\n\tslog.Debug(\"Event queuing started\")\n}\n\n// StopQueuing stops queuing and processes all queued events",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StopQueuing_106": {
      "name": "StopQueuing",
      "type": "method",
      "start_line": 106,
      "end_line": 117,
      "content_hash": "1c6abc3661c96c6b151c5190ad408c20c9182f09",
      "content": "func (eb *EventBus) StopQueuing() error {\n\teb.queuing = false\n\n\tevents := make([]FileChangeEvent, len(eb.queue))\n\tcopy(events, eb.queue)\n\teb.queue = make([]FileChangeEvent, 0)\n\n\tslog.Info(\"Event queuing stopped\", \"queued_events\", len(events))\n\treturn eb.PublishEvents(events)\n}\n\n// processEvent processes a single event",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_processEvent_118": {
      "name": "processEvent",
      "type": "method",
      "start_line": 118,
      "end_line": 170,
      "content_hash": "d8db51a73963b477730e12b6e5eef8b7bf9579f1",
      "content": "func (eb *EventBus) processEvent(event FileChangeEvent) error {\n\teventTypeStr := string(event.Type)\n\thandlers, exists := eb.handlers[eventTypeStr]\n\tif !exists {\n\t\tslog.Debug(\"No handlers for event type\", \"type\", event.Type)\n\t\treturn nil\n\t}\n\n\t// Sort handlers by priority (higher first)\n\tsortedHandlers := make([]EventHandler, len(handlers))\n\tcopy(sortedHandlers, handlers)\n\n\t// Simple sort by priority\n\tfor i := 0; i < len(sortedHandlers)-1; i++ {\n\t\tfor j := i + 1; j < len(sortedHandlers); j++ {\n\t\t\tif sortedHandlers[i].Priority() < sortedHandlers[j].Priority() {\n\t\t\t\tsortedHandlers[i], sortedHandlers[j] = sortedHandlers[j], sortedHandlers[i]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Execute handlers\n\tvar lastError error\n\tfor _, handler := range sortedHandlers {\n\t\tselect {\n\t\tcase <-eb.ctx.Done():\n\t\t\treturn eb.ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tstart := time.Now()\n\t\terr := handler.HandleEvent(eb.ctx, event)\n\t\tduration := time.Since(start)\n\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Event handler failed\",\n\t\t\t\t\"handler\", handler.Name(),\n\t\t\t\t\"event\", event.Path,\n\t\t\t\t\"error\", err,\n\t\t\t\t\"duration\", duration)\n\t\t\tlastError = err\n\t\t} else {\n\t\t\tslog.Debug(\"Event handler succeeded\",\n\t\t\t\t\"handler\", handler.Name(),\n\t\t\t\t\"event\", event.Path,\n\t\t\t\t\"duration\", duration)\n\t\t}\n\t}\n\n\treturn lastError\n}\n\n// GetStats returns event bus statistics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetStats_171": {
      "name": "GetStats",
      "type": "method",
      "start_line": 171,
      "end_line": 179,
      "content_hash": "4f45899cc7e850b1bdf9ebf88a33fb19ef1cce6b",
      "content": "func (eb *EventBus) GetStats() EventBusStats {\n\treturn EventBusStats{\n\t\tTotalHandlers: len(eb.handlers),\n\t\tQueuedEvents:  len(eb.queue),\n\t\tIsQueuing:     eb.queuing,\n\t}\n}\n\n// EventBusStats represents event bus statistics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EventBusStats_180": {
      "name": "EventBusStats",
      "type": "struct",
      "start_line": 180,
      "end_line": 188,
      "content_hash": "b264808cbe59615d5f70438c1a22ca648d244b3e",
      "content": "type EventBusStats struct {\n\tTotalHandlers int  `json:\"total_handlers\"`\n\tQueuedEvents  int  `json:\"queued_events\"`\n\tIsQueuing     bool `json:\"is_queuing\"`\n}\n\n// Concrete event handlers\n\n// SymbolUpdateHandler updates symbols when files change",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SymbolUpdateHandler_189": {
      "name": "SymbolUpdateHandler",
      "type": "struct",
      "start_line": 189,
      "end_line": 196,
      "content_hash": "4d62d9ebc943594066be1f49715710efc214b0eb",
      "content": "type SymbolUpdateHandler struct {\n\tindexer  SymbolStore\n\tparser   CodeParser\n\tengine   EmbeddingGenerator\n\tpriority int\n}\n\n// NewSymbolUpdateHandler creates a symbol update handler",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewSymbolUpdateHandler_197": {
      "name": "NewSymbolUpdateHandler",
      "type": "function",
      "start_line": 197,
      "end_line": 205,
      "content_hash": "83c99534e9a34775605c8e8c5196b89510d39a9c",
      "content": "func NewSymbolUpdateHandler(indexer SymbolStore, parser CodeParser, engine EmbeddingGenerator) *SymbolUpdateHandler {\n\treturn &SymbolUpdateHandler{\n\t\tindexer:  indexer,\n\t\tparser:   parser,\n\t\tengine:   engine,\n\t\tpriority: 100, // High priority\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HandleEvent_206": {
      "name": "HandleEvent",
      "type": "method",
      "start_line": 206,
      "end_line": 216,
      "content_hash": "6c39b308b3664a50a4db593f23d9b42e6b7ece28",
      "content": "func (h *SymbolUpdateHandler) HandleEvent(ctx context.Context, event FileChangeEvent) error {\n\tswitch event.Type {\n\tcase EventAdded, EventModified:\n\t\treturn h.handleAddOrUpdate(ctx, event)\n\tcase EventRemoved:\n\t\treturn h.handleRemove(ctx, event)\n\tdefault:\n\t\treturn nil\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleAddOrUpdate_217": {
      "name": "handleAddOrUpdate",
      "type": "method",
      "start_line": 217,
      "end_line": 253,
      "content_hash": "45df24b85b0be773be8acec4e73bcaa6b1a9638d",
      "content": "func (h *SymbolUpdateHandler) handleAddOrUpdate(ctx context.Context, event FileChangeEvent) error {\n\t// Validate file is supported\n\tif !h.shouldProcessFile(event.Path) {\n\t\treturn nil\n\t}\n\n\t// Parse symbols from file\n\tsymbols, err := h.parser.ParseFile(ctx, event.Path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse file %s: %w\", event.Path, err)\n\t}\n\n\t// Store symbols\n\tif err := h.indexer.StoreSymbols(ctx, symbols); err != nil {\n\t\treturn fmt.Errorf(\"failed to store symbols for %s: %w\", event.Path, err)\n\t}\n\n\t// Generate embeddings if available\n\tif h.engine != nil {\n\t\tembeddings, err := h.engine.GenerateSymbolEmbeddings(ctx, symbols)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Failed to generate embeddings\", \"file\", event.Path, \"error\", err)\n\t\t} else if storage, ok := h.engine.(EmbeddingStore); ok {\n\t\t\tif err := storage.StoreEmbeddings(ctx, embeddings); err != nil {\n\t\t\t\tslog.Warn(\"Failed to store embeddings\", \"file\", event.Path, \"error\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tslog.Info(\"File indexed successfully\",\n\t\t\"file\", event.Path,\n\t\t\"symbols\", len(symbols),\n\t\t\"event\", event.Type)\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleRemove_254": {
      "name": "handleRemove",
      "type": "method",
      "start_line": 254,
      "end_line": 263,
      "content_hash": "9183672e285ebca29fb16beb73ded5ac26f07df6",
      "content": "func (h *SymbolUpdateHandler) handleRemove(ctx context.Context, event FileChangeEvent) error {\n\t// Remove symbols for deleted file\n\tif err := h.indexer.DeleteSymbolsByFile(ctx, event.Path); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete symbols for %s: %w\", event.Path, err)\n\t}\n\n\tslog.Info(\"File removed from index\", \"file\", event.Path)\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldProcessFile_264": {
      "name": "shouldProcessFile",
      "type": "method",
      "start_line": 264,
      "end_line": 277,
      "content_hash": "bbdd752624c09d9148facf1aed0b9d2897269e8f",
      "content": "func (h *SymbolUpdateHandler) shouldProcessFile(path string) bool {\n\t// Only process Go files\n\tif !strings.HasSuffix(path, \".go\") {\n\t\treturn false\n\t}\n\n\t// Skip test files for now\n\tif strings.HasSuffix(path, \"_test.go\") {\n\t\treturn false\n\t}\n\n\treturn true\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_278": {
      "name": "Name",
      "type": "method",
      "start_line": 278,
      "end_line": 281,
      "content_hash": "62a0ee143fe3e1c02e16d174999af2d686c7b2c8",
      "content": "func (h *SymbolUpdateHandler) Name() string {\n\treturn \"SymbolUpdateHandler\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Priority_282": {
      "name": "Priority",
      "type": "method",
      "start_line": 282,
      "end_line": 286,
      "content_hash": "9640eb5ab6763c4613e2f9bfa19b65815ddfbc8d",
      "content": "func (h *SymbolUpdateHandler) Priority() int {\n\treturn h.priority\n}\n\n// CacheInvalidationHandler invalidates cache entries when files change",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CacheInvalidationHandler_287": {
      "name": "CacheInvalidationHandler",
      "type": "struct",
      "start_line": 287,
      "end_line": 292,
      "content_hash": "3eda11758eb0006c82e89b626b91424aad2e896e",
      "content": "type CacheInvalidationHandler struct {\n\tcache    CacheManager\n\tpriority int\n}\n\n// NewCacheInvalidationHandler creates a cache invalidation handler",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCacheInvalidationHandler_293": {
      "name": "NewCacheInvalidationHandler",
      "type": "function",
      "start_line": 293,
      "end_line": 299,
      "content_hash": "a4467e1f3e14dc746be2e93b59a59426b2f2f6ef",
      "content": "func NewCacheInvalidationHandler(cache CacheManager) *CacheInvalidationHandler {\n\treturn &CacheInvalidationHandler{\n\t\tcache:    cache,\n\t\tpriority: 50, // Medium priority\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HandleEvent_300": {
      "name": "HandleEvent",
      "type": "method",
      "start_line": 300,
      "end_line": 309,
      "content_hash": "2ed1699c6956a6a3630ace44c10d0310acfd2064",
      "content": "func (h *CacheInvalidationHandler) HandleEvent(ctx context.Context, event FileChangeEvent) error {\n\t// For now, clear all cache entries on any file change\n\t// In a more sophisticated implementation, we could track which cache keys\n\t// are related to which files and invalidate only those\n\th.cache.Clear(ctx)\n\n\tslog.Debug(\"Cache cleared due to file change\", \"file\", event.Path, \"event\", event.Type)\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_310": {
      "name": "Name",
      "type": "method",
      "start_line": 310,
      "end_line": 313,
      "content_hash": "6d18d4d42d4280445a42eb77fd98f768a28ac782",
      "content": "func (h *CacheInvalidationHandler) Name() string {\n\treturn \"CacheInvalidationHandler\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Priority_314": {
      "name": "Priority",
      "type": "method",
      "start_line": 314,
      "end_line": 318,
      "content_hash": "daacfe52b23f1cdc38e8f45a580470f3c10e86d4",
      "content": "func (h *CacheInvalidationHandler) Priority() int {\n\treturn h.priority\n}\n\n// LoggingHandler logs all file change events",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_LoggingHandler_319": {
      "name": "LoggingHandler",
      "type": "struct",
      "start_line": 319,
      "end_line": 323,
      "content_hash": "aa941a9c13f892c03b7de2e48ea4f0cc8dd9807b",
      "content": "type LoggingHandler struct {\n\tpriority int\n}\n\n// NewLoggingHandler creates a logging handler",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewLoggingHandler_324": {
      "name": "NewLoggingHandler",
      "type": "function",
      "start_line": 324,
      "end_line": 329,
      "content_hash": "6bedcf4d7e01595b089609ef319f464bd3188ac1",
      "content": "func NewLoggingHandler() *LoggingHandler {\n\treturn &LoggingHandler{\n\t\tpriority: 10, // Low priority\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HandleEvent_330": {
      "name": "HandleEvent",
      "type": "method",
      "start_line": 330,
      "end_line": 339,
      "content_hash": "88a69e5481020eb303cd7bd215c750e197d0ec41",
      "content": "func (h *LoggingHandler) HandleEvent(ctx context.Context, event FileChangeEvent) error {\n\tslog.Info(\"File system event\",\n\t\t\"event\", event.Type,\n\t\t\"path\", event.Path,\n\t\t\"timestamp\", event.Timestamp,\n\t\t\"size\", event.Size)\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_340": {
      "name": "Name",
      "type": "method",
      "start_line": 340,
      "end_line": 343,
      "content_hash": "88a347e5e3bcddbe4049343fcff38e161d5927fc",
      "content": "func (h *LoggingHandler) Name() string {\n\treturn \"LoggingHandler\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Priority_344": {
      "name": "Priority",
      "type": "method",
      "start_line": 344,
      "end_line": 350,
      "content_hash": "a9e336985d85e9041d67c879358b07e39648a5da",
      "content": "func (h *LoggingHandler) Priority() int {\n\treturn h.priority\n}\n\n// Helper functions for creating FileChangeEvents\n\n// NewFileChangeEvent creates a new file change event",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewFileChangeEvent_351": {
      "name": "NewFileChangeEvent",
      "type": "function",
      "start_line": 351,
      "end_line": 359,
      "content_hash": "ec35ddbcecf399d400bc583604ce7718550ebffd",
      "content": "func NewFileChangeEvent(path string, eventType EventType) FileChangeEvent {\n\treturn FileChangeEvent{\n\t\tPath:      path,\n\t\tType:      eventType,\n\t\tTimestamp: time.Now(),\n\t}\n}\n\n// CreateBatchFromFSWatch creates a batch of file change events from file system changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_CreateBatchFromFSWatch_360": {
      "name": "CreateBatchFromFSWatch",
      "type": "function",
      "start_line": 360,
      "end_line": 378,
      "content_hash": "74ec506bbc7d779520d9d1dbc41db397d61a082e",
      "content": "func CreateBatchFromFSWatch(added, modified, removed []string) []FileChangeEvent {\n\tevents := make([]FileChangeEvent, 0)\n\n\tfor _, path := range added {\n\t\tevents = append(events, NewFileChangeEvent(path, EventAdded))\n\t}\n\n\tfor _, path := range modified {\n\t\tevents = append(events, NewFileChangeEvent(path, EventModified))\n\t}\n\n\tfor _, path := range removed {\n\t\tevents = append(events, NewFileChangeEvent(path, EventRemoved))\n\t}\n\n\treturn events\n}\n\n// IsGoFile checks if a file is a Go source file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_IsGoFile_379": {
      "name": "IsGoFile",
      "type": "function",
      "start_line": 379,
      "end_line": 383,
      "content_hash": "12fa5e9df75c0ea4791b4e1e9602ecd669b95e23",
      "content": "func IsGoFile(path string) bool {\n\treturn strings.HasSuffix(path, \".go\")\n}\n\n// IsTestFile checks if a file is a test file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_IsTestFile_384": {
      "name": "IsTestFile",
      "type": "function",
      "start_line": 384,
      "end_line": 387,
      "content_hash": "af54c71b3c117f4ea629104875ce327a4e7455bf",
      "content": "func IsTestFile(path string) bool {\n\tbase := filepath.Base(path)\n\treturn strings.HasSuffix(base, \"_test.go\") || strings.HasPrefix(base, \"example_\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}