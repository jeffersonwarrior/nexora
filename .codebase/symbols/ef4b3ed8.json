{
  "file_path": "/work/context-engine/scripts/upload_service.py",
  "file_hash": "9dd91c84333efb47008b84a1d457150f20a842c7",
  "updated_at": "2025-12-26T17:34:24.312392",
  "symbols": {
    "function__admin_ui_unavailable_76": {
      "name": "_admin_ui_unavailable",
      "type": "function",
      "start_line": 76,
      "end_line": 77,
      "content_hash": "5a7fd7a1f2fc52438a8cc88b58850391e9c8ecd9",
      "content": "    def _admin_ui_unavailable(*args, **kwargs):\n        raise HTTPException(status_code=500, detail=\"Admin UI unavailable\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_logical_repo_reuse_enabled_128": {
      "name": "logical_repo_reuse_enabled",
      "type": "function",
      "start_line": 128,
      "end_line": 129,
      "content_hash": "09002e2eb032a9c2f1c9d162354d2cf63ff84751",
      "content": "    def logical_repo_reuse_enabled() -> bool:  # type: ignore[no-redef]\n        return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__int_env_183": {
      "name": "_int_env",
      "type": "function",
      "start_line": 183,
      "end_line": 194,
      "content_hash": "26a50474759577da18204b9b68f619be9e6483d9",
      "content": "def _int_env(name: str, default: int) -> int:\n    \"\"\"Read integer env vars safely; blank/invalid values fall back to default.\"\"\"\n    raw = os.environ.get(name)\n    if raw is None:\n        return default\n    try:\n        trimmed = str(raw).strip()\n        if not trimmed:\n            return default\n        return int(trimmed)\n    except (TypeError, ValueError):\n        return default",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_UploadResponse_196": {
      "name": "UploadResponse",
      "type": "class",
      "start_line": 196,
      "end_line": 203,
      "content_hash": "640ceb00916da14affe7fefafa7a2f2d6e01c312",
      "content": "class UploadResponse(BaseModel):\n    success: bool\n    bundle_id: Optional[str] = None\n    sequence_number: Optional[int] = None\n    processed_operations: Optional[Dict[str, int]] = None\n    processing_time_ms: Optional[int] = None\n    next_sequence: Optional[int] = None\n    error: Optional[Dict[str, Any]] = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_StatusResponse_205": {
      "name": "StatusResponse",
      "type": "class",
      "start_line": 205,
      "end_line": 212,
      "content_hash": "ed5d17e0f024713a1279d1da536e0a90c67ea0f4",
      "content": "class StatusResponse(BaseModel):\n    workspace_path: str\n    collection_name: str\n    last_sequence: int\n    last_upload: Optional[str] = None\n    pending_operations: int\n    status: str\n    server_info: Dict[str, Any]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_HealthResponse_214": {
      "name": "HealthResponse",
      "type": "class",
      "start_line": 214,
      "end_line": 219,
      "content_hash": "67ebc08a322756ecb15516d6910ac8f26d075f93",
      "content": "class HealthResponse(BaseModel):\n    status: str\n    timestamp: str\n    version: str\n    qdrant_url: str\n    work_dir: str",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_BridgeCollectionStateResponse_222": {
      "name": "BridgeCollectionStateResponse",
      "type": "class",
      "start_line": 222,
      "end_line": 231,
      "content_hash": "4768f205237933474465c52ee39e23e859342427",
      "content": "class BridgeCollectionStateResponse(BaseModel):\n    workspace_path: str\n    repo_name: Optional[str]\n    active_collection: Optional[str]\n    serving_collection: Optional[str]\n    previous_collection: Optional[str]\n    active_repo_slug: Optional[str]\n    serving_repo_slug: Optional[str]\n    indexing_status: Optional[Dict[str, Any]]\n    staging: Optional[Dict[str, Any]]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_AuthLoginRequest_234": {
      "name": "AuthLoginRequest",
      "type": "class",
      "start_line": 234,
      "end_line": 237,
      "content_hash": "9c185ab28602e8dad0652749843e66727800efe6",
      "content": "class AuthLoginRequest(BaseModel):\n    client: str\n    workspace: Optional[str] = None\n    token: Optional[str] = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_AuthLoginResponse_240": {
      "name": "AuthLoginResponse",
      "type": "class",
      "start_line": 240,
      "end_line": 243,
      "content_hash": "a81376c8e6c5cc5e3b1f213568f7bdadda75e551",
      "content": "class AuthLoginResponse(BaseModel):\n    session_id: str\n    user_id: Optional[str] = None\n    expires_at: Optional[int] = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_AuthStatusResponse_246": {
      "name": "AuthStatusResponse",
      "type": "class",
      "start_line": 246,
      "end_line": 249,
      "content_hash": "4f310f2881c708a3a26b5167eb7ff4be977e2166",
      "content": "class AuthStatusResponse(BaseModel):\n    enabled: bool\n    has_users: Optional[bool] = None\n    session_ttl_seconds: int",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_AuthUserCreateRequest_252": {
      "name": "AuthUserCreateRequest",
      "type": "class",
      "start_line": 252,
      "end_line": 254,
      "content_hash": "afa2630855575cdc91b4188391ed0cfe266b7d43",
      "content": "class AuthUserCreateRequest(BaseModel):\n    username: str\n    password: str",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_AuthUserCreateResponse_257": {
      "name": "AuthUserCreateResponse",
      "type": "class",
      "start_line": 257,
      "end_line": 259,
      "content_hash": "365c91921da2864f8056593d469f59b3fb79988b",
      "content": "class AuthUserCreateResponse(BaseModel):\n    user_id: str\n    username: str",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_PasswordLoginRequest_262": {
      "name": "PasswordLoginRequest",
      "type": "class",
      "start_line": 262,
      "end_line": 265,
      "content_hash": "071e5e02d1401ffc203d472de2fe4d9d47d96211",
      "content": "class PasswordLoginRequest(BaseModel):\n    username: str\n    password: str\n    workspace: Optional[str] = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__get_session_candidate_from_request_271": {
      "name": "_get_session_candidate_from_request",
      "type": "function",
      "start_line": 271,
      "end_line": 288,
      "content_hash": "5755de7c2b4e804f4cbcbb7c15593c1f7857645f",
      "content": "def _get_session_candidate_from_request(request: Request) -> Dict[str, Any]:\n    sid = (request.cookies.get(ADMIN_SESSION_COOKIE_NAME) or \"\").strip()\n    if sid:\n        return {\"session_id\": sid, \"source\": \"cookie\"}\n    try:\n        qp = request.query_params\n        sid = (qp.get(\"session\") or qp.get(\"session_id\") or qp.get(\"sessionId\") or \"\").strip()\n    except Exception:\n        sid = \"\"\n    if sid:\n        return {\"session_id\": sid, \"source\": \"query\"}\n    sid = (\n        (request.headers.get(\"X-Session-Id\") or \"\").strip()\n        or (request.headers.get(\"X-Auth-Session\") or \"\").strip()\n    )\n    if sid:\n        return {\"session_id\": sid, \"source\": \"header\"}\n    return {\"session_id\": \"\", \"source\": \"\"}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__set_admin_session_cookie_291": {
      "name": "_set_admin_session_cookie",
      "type": "function",
      "start_line": 291,
      "end_line": 309,
      "content_hash": "b1d05287a73a24600e62a4cd87cc68eab97a4ce8",
      "content": "def _set_admin_session_cookie(resp: Any, session_id: str) -> Any:\n    sid = (session_id or \"\").strip()\n    if not sid:\n        return resp\n    try:\n        kwargs: Dict[str, Any] = {\n            \"key\": ADMIN_SESSION_COOKIE_NAME,\n            \"value\": sid,\n            \"httponly\": True,\n            \"samesite\": \"lax\",\n            \"path\": \"/\",\n        }\n        ttl = int(AUTH_SESSION_TTL_SECONDS or 0)\n        if ttl > 0:\n            kwargs[\"max_age\"] = ttl\n        resp.set_cookie(**kwargs)\n    except Exception:\n        pass\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__get_valid_session_record_312": {
      "name": "_get_valid_session_record",
      "type": "function",
      "start_line": 312,
      "end_line": 322,
      "content_hash": "db0274c3574ce5b4760f8efca1fefff80b1dc64c",
      "content": "def _get_valid_session_record(request: Request) -> Optional[Dict[str, Any]]:\n    sid = (_get_session_candidate_from_request(request).get(\"session_id\") or \"\").strip()\n    if not sid:\n        return None\n    try:\n        return validate_session(sid)\n    except AuthDisabledError:\n        return None\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to validate session cookie: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to validate auth session\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__require_admin_session_325": {
      "name": "_require_admin_session",
      "type": "function",
      "start_line": 325,
      "end_line": 334,
      "content_hash": "989c8d172bd7b0dec1a09dcc7c945908d1ec4ad5",
      "content": "def _require_admin_session(request: Request) -> Dict[str, Any]:\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    record = _get_valid_session_record(request)\n    if record is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\")\n    user_id = str(record.get(\"user_id\") or \"\").strip()\n    if not user_id or not is_admin_user(user_id):\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Admin required\")\n    return record",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__bridge_state_authorized_337": {
      "name": "_bridge_state_authorized",
      "type": "function",
      "start_line": 337,
      "end_line": 361,
      "content_hash": "172373b65a9a8d77a2879c8fd777994845da7e27",
      "content": "def _bridge_state_authorized(request: Request) -> None:\n    header_token = (request.headers.get(\"X-Bridge-State-Token\") or \"\").strip()\n    if BRIDGE_STATE_TOKEN:\n        if header_token:\n            try:\n                if secrets.compare_digest(header_token, BRIDGE_STATE_TOKEN):\n                    return\n            except Exception:\n                pass\n        try:\n            _require_admin_session(request)\n            return\n        except HTTPException as exc:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail=\"Unauthorized bridge request\"\n            ) from exc\n\n    else:\n        try:\n            _require_admin_session(request)\n            return\n        except HTTPException as exc:\n            raise HTTPException(\n                status_code=exc.status_code, detail=\"Unauthorized bridge request\"\n            ) from exc",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__infer_repo_from_workspace_364": {
      "name": "_infer_repo_from_workspace",
      "type": "function",
      "start_line": 364,
      "end_line": 371,
      "content_hash": "91a3fedf9bfd6134426a0ca85ab70a78a9e84079",
      "content": "def _infer_repo_from_workspace(workspace_path: str) -> Optional[str]:\n    try:\n        candidate = Path(workspace_path).name\n        if candidate and _SLUGGED_REPO_RE.match(candidate):\n            return candidate\n    except Exception:\n        return None\n    return None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__resolve_bridge_state_target_374": {
      "name": "_resolve_bridge_state_target",
      "type": "function",
      "start_line": 374,
      "end_line": 398,
      "content_hash": "398799f22d5f34128ea696dfdf4478170dee2910",
      "content": "def _resolve_bridge_state_target(\n    *,\n    collection: Optional[str],\n    workspace: Optional[str],\n    repo_name: Optional[str],\n) -> Tuple[str, Optional[str]]:\n    \"\"\"Resolve workspace path + repo_name for bridge state lookups.\"\"\"\n    workspace_path = (workspace or \"\").strip()\n    if not workspace_path:\n        workspace_path = WORK_DIR\n\n    repo = (repo_name or \"\").strip() or None\n\n    if collection:\n        if resolve_collection_root is None:\n            raise HTTPException(status_code=400, detail=\"collection mapping unavailable\")\n        root, resolved_repo = resolve_collection_root(collection=collection, work_dir=WORK_DIR)\n        if not root:\n            raise HTTPException(status_code=404, detail=\"collection mapping not found\")\n        workspace_path = root\n        repo = resolved_repo\n    elif not repo:\n        repo = _infer_repo_from_workspace(workspace_path)\n\n    return workspace_path, repo",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_next_sequence_401": {
      "name": "get_next_sequence",
      "type": "function",
      "start_line": 401,
      "end_line": 407,
      "content_hash": "407b5db92b5bf765345c855207af3b32b7fba8a1",
      "content": "def get_next_sequence(workspace_path: str) -> int:\n    \"\"\"Get next sequence number for workspace.\"\"\"\n    key = get_workspace_key(workspace_path)\n    current = _sequence_tracker.get(key, 0)\n    next_seq = current + 1\n    _sequence_tracker[key] = next_seq\n    return next_seq",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_last_sequence_409": {
      "name": "get_last_sequence",
      "type": "function",
      "start_line": 409,
      "end_line": 412,
      "content_hash": "05419559488fa2159b190c652ff7d5482dcdac7d",
      "content": "def get_last_sequence(workspace_path: str) -> int:\n    \"\"\"Get last sequence number for workspace.\"\"\"\n    key = get_workspace_key(workspace_path)\n    return _sequence_tracker.get(key, 0)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_validate_bundle_format_414": {
      "name": "validate_bundle_format",
      "type": "function",
      "start_line": 414,
      "end_line": 451,
      "content_hash": "e9f59bf7dd9defa5613295e90e80b115af2d568b",
      "content": "def validate_bundle_format(bundle_path: Path) -> Dict[str, Any]:\n    \"\"\"Validate delta bundle format and return manifest.\"\"\"\n    try:\n        with tarfile.open(bundle_path, \"r:gz\") as tar:\n            # Check for required files\n            required_files = [\"manifest.json\", \"metadata/operations.json\", \"metadata/hashes.json\"]\n            members = tar.getnames()\n\n            for req_file in required_files:\n                if not any(req_file in member for member in members):\n                    raise ValueError(f\"Missing required file: {req_file}\")\n\n            # Extract and validate manifest\n            manifest_member = None\n            for member in members:\n                if member.endswith(\"manifest.json\"):\n                    manifest_member = member\n                    break\n\n            if not manifest_member:\n                raise ValueError(\"manifest.json not found in bundle\")\n\n            manifest_file = tar.extractfile(manifest_member)\n            if not manifest_file:\n                raise ValueError(\"Cannot extract manifest.json\")\n\n            manifest = json.loads(manifest_file.read().decode('utf-8'))\n\n            # Validate manifest structure\n            required_fields = [\"version\", \"bundle_id\", \"workspace_path\", \"created_at\", \"sequence_number\"]\n            for field in required_fields:\n                if field not in manifest:\n                    raise ValueError(f\"Missing required field in manifest: {field}\")\n\n            return manifest\n\n    except Exception as e:\n        raise ValueError(f\"Invalid bundle format: {str(e)}\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__process_bundle_background_454": {
      "name": "_process_bundle_background",
      "type": "function",
      "start_line": 454,
      "end_line": 494,
      "content_hash": "a1005f9afb6076ad7f3ec982d7d9fb31ade1e350",
      "content": "async def _process_bundle_background(\n    workspace_path: str,\n    bundle_path: Path,\n    manifest: Dict[str, Any],\n    sequence_number: Optional[int],\n    bundle_id: Optional[str],\n) -> None:\n    try:\n        start_time = datetime.now()\n        operations_count = await asyncio.to_thread(\n            process_delta_bundle, workspace_path, bundle_path, manifest\n        )\n        if sequence_number is not None:\n            key = get_workspace_key(workspace_path)\n            _sequence_tracker[key] = sequence_number\n        if log_activity:\n            try:\n                repo = _extract_repo_name_from_path(workspace_path) if _extract_repo_name_from_path else None\n                log_activity(\n                    repo_name=repo,\n                    action=\"uploaded\",\n                    file_path=bundle_id,\n                    details={\n                        \"bundle_id\": bundle_id,\n                        \"operations\": operations_count,\n                        \"source\": \"delta_upload\",\n                    },\n                )\n            except Exception as activity_err:\n                logger.debug(f\"[upload_service] Failed to log activity for bundle {bundle_id}: {activity_err}\")\n        processing_time = (datetime.now() - start_time).total_seconds() * 1000\n        logger.info(\n            f\"[upload_service] Finished processing bundle {bundle_id} seq {sequence_number} in {int(processing_time)}ms\"\n        )\n    except Exception as e:\n        logger.error(f\"[upload_service] Error in background processing for bundle {bundle_id}: {e}\")\n    finally:\n        try:\n            bundle_path.unlink()\n        except Exception:\n            pass",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_auth_status_498": {
      "name": "auth_status",
      "type": "function",
      "start_line": 498,
      "end_line": 517,
      "content_hash": "1a45f21e682540fd00061c298e74a46a1e1b31f9",
      "content": "async def auth_status():\n    try:\n        if not AUTH_ENABLED:\n            return AuthStatusResponse(enabled=False, has_users=None, session_ttl_seconds=0)\n        try:\n            users_exist = has_any_users()\n        except AuthDisabledError:\n            return AuthStatusResponse(\n                enabled=False,\n                has_users=None,\n                session_ttl_seconds=AUTH_SESSION_TTL_SECONDS,\n            )\n        return AuthStatusResponse(\n            enabled=True,\n            has_users=users_exist,\n            session_ttl_seconds=AUTH_SESSION_TTL_SECONDS,\n        )\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to report auth status: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to read auth status\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_auth_login_521": {
      "name": "auth_login",
      "type": "function",
      "start_line": 521,
      "end_line": 539,
      "content_hash": "1fd7f9ff5ad24abc6ff5950d37819f6ebeab5dd1",
      "content": "async def auth_login(payload: AuthLoginRequest):\n    try:\n        session = create_session_for_token(\n            client=payload.client,\n            workspace=payload.workspace,\n            token=payload.token,\n        )\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except AuthInvalidToken:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid auth token\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to create auth session: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create auth session\")\n    return AuthLoginResponse(\n        session_id=session.get(\"session_id\"),\n        user_id=session.get(\"user_id\"),\n        expires_at=session.get(\"expires_at\"),\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_root_543": {
      "name": "admin_root",
      "type": "function",
      "start_line": 543,
      "end_line": 568,
      "content_hash": "a25beb99217779cc6192f78a2d8bce1f19d71eb0",
      "content": "async def admin_root(request: Request):\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    try:\n        users_exist = has_any_users()\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to inspect user state for admin UI: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to inspect user state\")\n\n    if not users_exist:\n        return RedirectResponse(url=\"/admin/bootstrap\", status_code=302)\n\n    candidate = _get_session_candidate_from_request(request)\n    record = _get_valid_session_record(request)\n    if record is None:\n        return RedirectResponse(url=\"/admin/login\", status_code=302)\n\n    user_id = str(record.get(\"user_id\") or \"\").strip()\n    if user_id and is_admin_user(user_id):\n        resp = RedirectResponse(url=\"/admin/acl\", status_code=302)\n        if candidate.get(\"source\") and candidate.get(\"source\") != \"cookie\":\n            _set_admin_session_cookie(resp, str(candidate.get(\"session_id\") or \"\"))\n        return resp\n    return RedirectResponse(url=\"/admin/login\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_bootstrap_form_572": {
      "name": "admin_bootstrap_form",
      "type": "function",
      "start_line": 572,
      "end_line": 584,
      "content_hash": "876f0550697eb63161d59a563be0002ae20e165d",
      "content": "async def admin_bootstrap_form(request: Request):\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    try:\n        users_exist = has_any_users()\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to inspect user state for bootstrap: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to inspect user state\")\n    if users_exist:\n        return RedirectResponse(url=\"/admin/login\", status_code=302)\n    return render_admin_bootstrap(request)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_bootstrap_submit_588": {
      "name": "admin_bootstrap_submit",
      "type": "function",
      "start_line": 588,
      "end_line": 624,
      "content_hash": "399e7ae4ae11b5e5ce5a1783f5ef2adba7d66915",
      "content": "async def admin_bootstrap_submit(\n    request: Request,\n    username: str = Form(...),\n    password: str = Form(...),\n):\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    try:\n        users_exist = has_any_users()\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to inspect user state for bootstrap submit: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to inspect user state\")\n    if users_exist:\n        return RedirectResponse(url=\"/admin/login\", status_code=302)\n\n    try:\n        user = create_user(username, password)\n    except Exception as e:\n        return render_admin_error(\n            request=request,\n            title=\"Bootstrap Failed\",\n            message=str(e),\n            back_href=\"/admin/bootstrap\",\n            status_code=400,\n        )\n\n    try:\n        session = create_session(user_id=user.get(\"user_id\"), metadata={\"client\": \"admin_ui\"})\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to create session after bootstrap: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create auth session\")\n\n    resp = RedirectResponse(url=\"/admin/acl\", status_code=302)\n    _set_admin_session_cookie(resp, str(session.get(\"session_id\") or \"\"))\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_login_form_628": {
      "name": "admin_login_form",
      "type": "function",
      "start_line": 628,
      "end_line": 631,
      "content_hash": "2bc34cc8676a924156135ca6c4008436880bf7e8",
      "content": "async def admin_login_form(request: Request):\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    return render_admin_login(request)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_login_submit_635": {
      "name": "admin_login_submit",
      "type": "function",
      "start_line": 635,
      "end_line": 665,
      "content_hash": "f8486053c6576865cba31843787b8d2ad1c08fac",
      "content": "async def admin_login_submit(\n    request: Request,\n    username: str = Form(...),\n    password: str = Form(...),\n):\n    if not AUTH_ENABLED:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    try:\n        user = authenticate_user(username, password)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Error authenticating user for admin UI: {e}\")\n        raise HTTPException(status_code=500, detail=\"Authentication error\")\n\n    if not user:\n        return render_admin_login(\n            request=request,\n            error=\"Invalid credentials\",\n            status_code=401,\n        )\n\n    try:\n        session = create_session(user_id=user.get(\"id\"), metadata={\"client\": \"admin_ui\"})\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to create session for admin UI: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create auth session\")\n\n    resp = RedirectResponse(url=\"/admin/acl\", status_code=302)\n    _set_admin_session_cookie(resp, str(session.get(\"session_id\") or \"\"))\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_logout_669": {
      "name": "admin_logout",
      "type": "function",
      "start_line": 669,
      "end_line": 672,
      "content_hash": "2843b363251ddc6d865f078c33cfdaa300102932",
      "content": "async def admin_logout():\n    resp = RedirectResponse(url=\"/admin/login\", status_code=302)\n    resp.delete_cookie(key=ADMIN_SESSION_COOKIE_NAME, path=\"/\")\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_acl_page_676": {
      "name": "admin_acl_page",
      "type": "function",
      "start_line": 676,
      "end_line": 704,
      "content_hash": "dc5334196fa4973ba41ccd74231145c837ea6abc",
      "content": "async def admin_acl_page(request: Request):\n    _require_admin_session(request)\n    try:\n        users = list_users()\n        collections = list_collections(include_deleted=False)\n        grants = list_collection_acl()\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to load admin UI data: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to load admin data\")\n\n    enriched = await asyncio.to_thread(\n        build_admin_collections_view, collections=collections, work_dir=WORK_DIR\n    )\n\n    resp = render_admin_acl(\n        request,\n        users=users,\n        collections=enriched,\n        grants=grants,\n        deletion_enabled=ADMIN_COLLECTION_DELETE_ENABLED,\n        work_dir=WORK_DIR,\n        refresh_ms=ADMIN_COLLECTION_REFRESH_MS,\n    )\n    candidate = _get_session_candidate_from_request(request)\n    if candidate.get(\"source\") and candidate.get(\"source\") != \"cookie\":\n        _set_admin_session_cookie(resp, str(candidate.get(\"session_id\") or \"\"))\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_acl_grant_708": {
      "name": "admin_acl_grant",
      "type": "function",
      "start_line": 708,
      "end_line": 721,
      "content_hash": "17cf14d013a2eec5a294116c2a068f16e79797d4",
      "content": "async def admin_acl_grant(\n    request: Request,\n    user_id: str = Form(...),\n    collection: str = Form(...),\n    permission: str = Form(\"read\"),\n):\n    _require_admin_session(request)\n    try:\n        grant_collection_access(user_id=user_id, qdrant_collection=collection, permission=permission)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        return render_admin_error(request, title=\"Grant Failed\", message=str(e), back_href=\"/admin/acl\")\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_collections_status_725": {
      "name": "admin_collections_status",
      "type": "function",
      "start_line": 725,
      "end_line": 737,
      "content_hash": "eb81ccf48dc4bb3378da0ef9741e1ac3f973ab2f",
      "content": "async def admin_collections_status(request: Request):\n    _require_admin_session(request)\n    try:\n        collections = list_collections(include_deleted=False)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception:\n        raise HTTPException(status_code=500, detail=\"Failed to load collections\")\n\n    enriched = await asyncio.to_thread(\n        lambda: build_admin_collections_view(collections=collections, work_dir=WORK_DIR)\n    )\n    return JSONResponse({\"collections\": enriched})",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_reindex_collection_741": {
      "name": "admin_reindex_collection",
      "type": "function",
      "start_line": 741,
      "end_line": 781,
      "content_hash": "36bc904654f0df74332a24384064f4de00b445be",
      "content": "async def admin_reindex_collection(\n    request: Request,\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Reindex Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    root, repo_name = resolve_collection_root(collection=name, work_dir=WORK_DIR)\n    if not root:\n        return render_admin_error(\n            request,\n            title=\"Reindex Failed\",\n            message=\"No workspace mapping found for collection (no state.json mapping)\",\n            back_href=\"/admin/acl\",\n        )\n\n    try:\n        spawn_ingest_code(\n            root=root,\n            work_dir=WORK_DIR,\n            collection=name,\n            recreate=False,\n            repo_name=repo_name,\n            clear_caches=True,\n        )\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Reindex Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bridge_collection_state_785": {
      "name": "bridge_collection_state",
      "type": "function",
      "start_line": 785,
      "end_line": 818,
      "content_hash": "b8a6e2c2f16abc3581cf2d24948916ac46517e86",
      "content": "async def bridge_collection_state(\n    request: Request,\n    collection: Optional[str] = None,\n    workspace: Optional[str] = None,\n    repo_name: Optional[str] = None,\n):\n    if get_collection_state_snapshot is None:\n        raise HTTPException(status_code=503, detail=\"workspace_state helper unavailable\")\n\n    _bridge_state_authorized(request)\n\n    workspace_path, repo = _resolve_bridge_state_target(collection=collection, workspace=workspace, repo_name=repo_name)\n\n    snapshot = get_collection_state_snapshot(workspace_path=workspace_path, repo_name=repo)\n    if not snapshot:\n        raise HTTPException(status_code=404, detail=\"Workspace state not found\")\n\n    if not (is_staging_enabled() if callable(is_staging_enabled) else False):\n        # Classic mode: ignore any serving_* overrides from staging/migration.\n        snapshot = dict(snapshot)\n        snapshot.pop(\"serving_collection\", None)\n        snapshot.pop(\"serving_repo_slug\", None)\n\n    return BridgeCollectionStateResponse(\n        workspace_path=str(snapshot.get(\"workspace_path\") or workspace_path),\n        repo_name=snapshot.get(\"repo_name\") or repo,\n        active_collection=snapshot.get(\"active_collection\"),\n        serving_collection=snapshot.get(\"serving_collection\") or snapshot.get(\"active_collection\"),\n        previous_collection=snapshot.get(\"previous_collection\"),\n        active_repo_slug=snapshot.get(\"active_repo_slug\") or repo,\n        serving_repo_slug=snapshot.get(\"serving_repo_slug\") or snapshot.get(\"active_repo_slug\"),\n        indexing_status=snapshot.get(\"indexing_status\"),\n        staging=snapshot.get(\"staging\"),\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_recreate_collection_823": {
      "name": "admin_recreate_collection",
      "type": "function",
      "start_line": 823,
      "end_line": 868,
      "content_hash": "c2f518eaa78dcaba2d9e3ff32bad5363c0352398",
      "content": "async def admin_recreate_collection(\n    request: Request,\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Recreate Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    root, repo_name = resolve_collection_root(collection=name, work_dir=WORK_DIR)\n    if not root:\n        return render_admin_error(\n            request,\n            title=\"Recreate Failed\",\n            message=\"No workspace mapping found for collection (no state.json mapping)\",\n            back_href=\"/admin/acl\",\n        )\n\n    try:\n        recreate_collection_qdrant(\n            qdrant_url=QDRANT_URL,\n            api_key=os.environ.get(\"QDRANT_API_KEY\") or None,\n            collection=name,\n        )\n        spawn_ingest_code(\n            root=root,\n            work_dir=WORK_DIR,\n            collection=name,\n            recreate=False,\n            repo_name=repo_name,\n            clear_caches=True,\n        )\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Recreate Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_delete_collection_872": {
      "name": "admin_delete_collection",
      "type": "function",
      "start_line": 872,
      "end_line": 930,
      "content_hash": "8c87f72472d254500fe8ab0ee8cbed4d0bcac60d",
      "content": "async def admin_delete_collection(\n    request: Request,\n    collection: str = Form(...),\n    delete_fs: str = Form(\"\"),\n):\n    _require_admin_session(request)\n    if not ADMIN_COLLECTION_DELETE_ENABLED:\n        try:\n            return render_admin_error(\n                request,\n                title=\"Delete Collection Disabled\",\n                message=\"Collection deletion is disabled by server configuration\",\n                back_href=\"/admin/acl\",\n                status_code=403,\n            )\n        except Exception:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Collection deletion is disabled by server configuration\",\n            )\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Delete Collection Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    if delete_collection_everywhere is None:\n        return render_admin_error(\n            request,\n            title=\"Delete Collection Failed\",\n            message=\"Collection delete helper unavailable\",\n            back_href=\"/admin/acl\",\n        )\n\n    # Default is Qdrant-only (no filesystem cleanup). Users must explicitly opt in.\n    try:\n        cleanup_fs = (delete_fs or \"\").strip().lower() in {\"1\", \"true\", \"yes\", \"on\"}\n    except Exception:\n        cleanup_fs = False\n\n    try:\n        delete_collection_everywhere(\n            collection=name,\n            work_dir=WORK_DIR,\n            qdrant_url=QDRANT_URL,\n            cleanup_fs=cleanup_fs,\n        )\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Delete Collection Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_start_staging_934": {
      "name": "admin_start_staging",
      "type": "function",
      "start_line": 934,
      "end_line": 1053,
      "content_hash": "39c2c12ebabc9bbe6a8d2b78395648b9726623ab",
      "content": "async def admin_start_staging(\n    request: Request,\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    if not (is_staging_enabled() if callable(is_staging_enabled) else False):\n        return render_admin_error(\n            request,\n            title=\"Start Staging Failed\",\n            message=\"Staging is disabled (set CTXCE_STAGING_ENABLED=1 to enable)\",\n            back_href=\"/admin/acl\",\n        )\n\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Start Staging Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    if start_staging_rebuild is None:\n        return render_admin_error(\n            request,\n            title=\"Start Staging Failed\",\n            message=\"Staging helper unavailable\",\n            back_href=\"/admin/acl\",\n        )\n\n    root: Optional[str] = None\n    repo_name: Optional[str] = None\n    try:\n        root, repo_name = resolve_collection_root(collection=name, work_dir=WORK_DIR)\n    except Exception:\n        root, repo_name = None, None\n    if not root:\n        return render_admin_error(\n            request,\n            title=\"Start Staging Failed\",\n            message=\"No workspace mapping found for collection\",\n            back_href=\"/admin/acl\",\n        )\n\n    staged_clone_name = f\"{name}_old\"\n    request_id = secrets.token_hex(8)\n    now = datetime.utcnow().isoformat()\n    staging_payload = {\n        \"collection\": staged_clone_name,\n        \"started_at\": now,\n        \"updated_at\": now,\n        \"env_hash\": None,\n        \"workspace_path\": root,\n        \"repo_name\": repo_name,\n        \"status\": {\n            \"state\": \"queued\",\n            \"queued_at\": now,\n            \"request_id\": request_id,\n        },\n    }\n\n    if set_staging_state:\n        try:\n            set_staging_state(workspace_path=root, repo_name=repo_name, staging=staging_payload)\n        except Exception as set_err:\n            logger.warning(f\"[admin] Failed to persist queued staging state for {name}: {set_err}\")\n    elif update_workspace_state:\n        try:\n            update_workspace_state(\n                workspace_path=root,\n                repo_name=repo_name,\n                updates={\"staging\": staging_payload},\n            )\n        except Exception as set_err:\n            logger.warning(f\"[admin] Failed to update workspace state for queued staging {name}: {set_err}\")\n\n    if update_staging_status:\n        try:\n            update_staging_status(\n                workspace_path=root,\n                repo_name=repo_name,\n                status={\"state\": \"queued\", \"queued_at\": now, \"request_id\": request_id},\n            )\n        except Exception as status_err:\n            logger.debug(f\"[admin] Failed to mark staging status queued for {name}: {status_err}\")\n\n    try:\n        async def _bg_start() -> None:\n            try:\n                staging_collection = await asyncio.to_thread(\n                    start_staging_rebuild, collection=name, work_dir=WORK_DIR\n                )\n                logger.info(f\"[admin] Started staging rebuild for {name} -> {staging_collection}\")\n            except Exception as e:\n                logger.error(f\"[admin] Background staging start failed for {name}: {e}\")\n                # Ensure we don't leave the workspace stuck in a queued staging state.\n                try:\n                    if clear_staging_collection:\n                        clear_staging_collection(workspace_path=root, repo_name=repo_name)\n                    elif update_workspace_state:\n                        update_workspace_state(\n                            workspace_path=root,\n                            repo_name=repo_name,\n                            updates={\"staging\": None},\n                        )\n                except Exception as clear_err:\n                    logger.warning(\n                        f\"[admin] Failed to clear staging state after start failure for {name}: {clear_err}\"\n                    )\n\n        asyncio.create_task(_bg_start())\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Start Staging Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__bg_start_1021": {
      "name": "_bg_start",
      "type": "function",
      "start_line": 1021,
      "end_line": 1042,
      "content_hash": "a2eb7ea9254333bbcbce3c5e712de643a0c36e85",
      "content": "        async def _bg_start() -> None:\n            try:\n                staging_collection = await asyncio.to_thread(\n                    start_staging_rebuild, collection=name, work_dir=WORK_DIR\n                )\n                logger.info(f\"[admin] Started staging rebuild for {name} -> {staging_collection}\")\n            except Exception as e:\n                logger.error(f\"[admin] Background staging start failed for {name}: {e}\")\n                # Ensure we don't leave the workspace stuck in a queued staging state.\n                try:\n                    if clear_staging_collection:\n                        clear_staging_collection(workspace_path=root, repo_name=repo_name)\n                    elif update_workspace_state:\n                        update_workspace_state(\n                            workspace_path=root,\n                            repo_name=repo_name,\n                            updates={\"staging\": None},\n                        )\n                except Exception as clear_err:\n                    logger.warning(\n                        f\"[admin] Failed to clear staging state after start failure for {name}: {clear_err}\"\n                    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_activate_staging_1057": {
      "name": "admin_activate_staging",
      "type": "function",
      "start_line": 1057,
      "end_line": 1103,
      "content_hash": "923cfa4bb8e9018d3f2a59774e847296c3e78578",
      "content": "async def admin_activate_staging(\n    request: Request,\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    if not (is_staging_enabled() if callable(is_staging_enabled) else False):\n        return render_admin_error(\n            request,\n            title=\"Activate Staging Failed\",\n            message=\"Staging is disabled (set CTXCE_STAGING_ENABLED=1 to enable)\",\n            back_href=\"/admin/acl\",\n        )\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Activate Staging Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    if activate_staging_rebuild is None:\n        return render_admin_error(\n            request,\n            title=\"Activate Staging Failed\",\n            message=\"Staging helper unavailable\",\n            back_href=\"/admin/acl\",\n        )\n\n    try:\n        async def _bg_activate() -> None:\n            try:\n                await asyncio.to_thread(activate_staging_rebuild, collection=name, work_dir=WORK_DIR)\n                logger.info(f\"[admin] Activated staging for {name}\")\n            except Exception as e:\n                logger.error(f\"[admin] Background staging activate failed for {name}: {e}\")\n\n        asyncio.create_task(_bg_activate())\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Activate Staging Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__bg_activate_1087": {
      "name": "_bg_activate",
      "type": "function",
      "start_line": 1087,
      "end_line": 1092,
      "content_hash": "b4400d607f9519ba0a74b4990f15c95a42b653e6",
      "content": "        async def _bg_activate() -> None:\n            try:\n                await asyncio.to_thread(activate_staging_rebuild, collection=name, work_dir=WORK_DIR)\n                logger.info(f\"[admin] Activated staging for {name}\")\n            except Exception as e:\n                logger.error(f\"[admin] Background staging activate failed for {name}: {e}\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_abort_staging_1107": {
      "name": "admin_abort_staging",
      "type": "function",
      "start_line": 1107,
      "end_line": 1154,
      "content_hash": "0f36de0108a5fbcb686b667a9614bced55f85dee",
      "content": "async def admin_abort_staging(\n    request: Request,\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Abort Staging Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    root, repo_name = resolve_collection_root(collection=name, work_dir=WORK_DIR)\n    if not root:\n        return render_admin_error(\n            request,\n            title=\"Abort Staging Failed\",\n            message=\"No workspace mapping found for collection\",\n            back_href=\"/admin/acl\",\n        )\n\n    try:\n        if abort_staging_rebuild is not None:\n            # Run abort to completion so we always clear staging metadata before returning.\n            await asyncio.to_thread(\n                abort_staging_rebuild,\n                collection=name,\n                work_dir=WORK_DIR,\n                delete_collection=True,\n            )\n            logger.info(f\"[admin] Aborted staging rebuild for {name}\")\n        elif clear_staging_collection:\n            # Fallback for older deployments: clear staging metadata only.\n            clear_staging_collection(workspace_path=root, repo_name=repo_name)\n            logger.info(f\"[admin] Aborted staging for {name} (metadata only)\")\n        else:\n            raise RuntimeError(\"staging abort helpers unavailable\")\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Abort Staging Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_copy_collection_1158": {
      "name": "admin_copy_collection",
      "type": "function",
      "start_line": 1158,
      "end_line": 1203,
      "content_hash": "4f7b28e82a4070e6b237c2ae63a172c4b3a86a66",
      "content": "async def admin_copy_collection(\n    request: Request,\n    collection: str = Form(...),\n    target: Optional[str] = Form(None),\n    overwrite: Optional[str] = Form(\"\"),\n):\n    _require_admin_session(request)\n    name = (collection or \"\").strip()\n    if not name:\n        return render_admin_error(\n            request,\n            title=\"Copy Collection Failed\",\n            message=\"collection is required\",\n            back_href=\"/admin/acl\",\n        )\n\n    if copy_collection_qdrant is None:\n        return render_admin_error(\n            request,\n            title=\"Copy Collection Failed\",\n            message=\"copy helper unavailable\",\n            back_href=\"/admin/acl\",\n        )\n\n    try:\n        allow_overwrite = str(overwrite or \"\").strip().lower() in {\"1\", \"true\", \"yes\", \"on\"}\n    except Exception:\n        allow_overwrite = False\n\n    try:\n        new_name = copy_collection_qdrant(\n            source=name,\n            target=(target or None),\n            qdrant_url=QDRANT_URL,\n            overwrite=allow_overwrite,\n        )\n        logger.info(f\"[admin] Copied collection {name} -> {new_name}\")\n    except Exception as e:\n        return render_admin_error(\n            request,\n            title=\"Copy Collection Failed\",\n            message=str(e),\n            back_href=\"/admin/acl\",\n        )\n\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_create_user_1207": {
      "name": "admin_create_user",
      "type": "function",
      "start_line": 1207,
      "end_line": 1220,
      "content_hash": "1f367650ee1f6397f94afb874f474f68416e0d2a",
      "content": "async def admin_create_user(\n    request: Request,\n    username: str = Form(...),\n    password: str = Form(...),\n    role: str = Form(\"user\"),\n):\n    _require_admin_session(request)\n    try:\n        create_user(username, password, role=role)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        return render_admin_error(request, title=\"Create User Failed\", message=str(e), back_href=\"/admin/acl\")\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_admin_acl_revoke_1224": {
      "name": "admin_acl_revoke",
      "type": "function",
      "start_line": 1224,
      "end_line": 1236,
      "content_hash": "27d1cab117c0335126023b520af23338c8bb0d00",
      "content": "async def admin_acl_revoke(\n    request: Request,\n    user_id: str = Form(...),\n    collection: str = Form(...),\n):\n    _require_admin_session(request)\n    try:\n        revoke_collection_access(user_id=user_id, qdrant_collection=collection)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        return render_admin_error(request, title=\"Revoke Failed\", message=str(e), back_href=\"/admin/acl\")\n    return RedirectResponse(url=\"/admin/acl\", status_code=302)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_auth_create_user_1240": {
      "name": "auth_create_user",
      "type": "function",
      "start_line": 1240,
      "end_line": 1277,
      "content_hash": "552ea17fb6f2d2e903424b588debb972c796068f",
      "content": "async def auth_create_user(payload: AuthUserCreateRequest, request: Request):\n    try:\n        first_user = not has_any_users()\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to check user state: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to inspect user state\")\n\n    admin_token = os.environ.get(\"CTXCE_AUTH_ADMIN_TOKEN\") or os.environ.get(\"CTXCE_AUTH_SHARED_TOKEN\")\n    if not first_user:\n        if not admin_token:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Admin token not configured\",\n            )\n        header = request.headers.get(\"X-Admin-Token\")\n        if not header or header != admin_token:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid admin token\",\n            )\n\n    try:\n        user = create_user(payload.username, payload.password)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to create user: {e}\")\n        msg = str(e)\n        if \"UNIQUE\" in msg or \"unique\" in msg:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"Username already exists\",\n            )\n        raise HTTPException(status_code=500, detail=\"Failed to create user\")\n\n    return AuthUserCreateResponse(user_id=user.get(\"user_id\"), username=user.get(\"username\"))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_auth_login_password_1281": {
      "name": "auth_login_password",
      "type": "function",
      "start_line": 1281,
      "end_line": 1309,
      "content_hash": "9347cdba1644ce9bc5bd53ea9f040e940ab5b7fa",
      "content": "async def auth_login_password(payload: PasswordLoginRequest):\n    try:\n        user = authenticate_user(payload.username, payload.password)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Error authenticating user: {e}\")\n        raise HTTPException(status_code=500, detail=\"Authentication error\")\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid credentials\")\n\n    meta: Optional[Dict[str, Any]] = None\n    if payload.workspace:\n        meta = {\"workspace\": payload.workspace}\n\n    try:\n        session = create_session(user_id=user.get(\"id\"), metadata=meta)\n    except AuthDisabledError:\n        raise HTTPException(status_code=404, detail=\"Auth disabled\")\n    except Exception as e:\n        logger.error(f\"[upload_service] Failed to create session for user: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create auth session\")\n\n    return AuthLoginResponse(\n        session_id=session.get(\"session_id\"),\n        user_id=session.get(\"user_id\"),\n        expires_at=session.get(\"expires_at\"),\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_health_check_1313": {
      "name": "health_check",
      "type": "function",
      "start_line": 1313,
      "end_line": 1321,
      "content_hash": "4c8200dd2a7c7759ff287a11fcf8119155cc4684",
      "content": "async def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return HealthResponse(\n        status=\"healthy\",\n        timestamp=datetime.now().isoformat(),\n        version=\"1.0.0\",\n        qdrant_url=QDRANT_URL,\n        work_dir=WORK_DIR\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_status_1324": {
      "name": "get_status",
      "type": "function",
      "start_line": 1324,
      "end_line": 1355,
      "content_hash": "75ffa7891fb114bb1d70f6756cb49d4acaeb57e8",
      "content": "async def get_status(workspace_path: str):\n    \"\"\"Get upload status for workspace.\"\"\"\n    try:\n        # Get collection name\n        if get_collection_name:\n            repo_name = _extract_repo_name_from_path(workspace_path) if _extract_repo_name_from_path else None\n            collection_name = get_collection_name(repo_name)\n        else:\n            collection_name = DEFAULT_COLLECTION\n\n        # Get last sequence\n        last_sequence = get_last_sequence(workspace_path)\n\n        last_upload = None\n\n        return StatusResponse(\n            workspace_path=workspace_path,\n            collection_name=collection_name,\n            last_sequence=last_sequence,\n            last_upload=last_upload,\n            pending_operations=0,\n            status=\"ready\",\n            server_info={\n                \"version\": \"1.0.0\",\n                \"max_bundle_size_mb\": MAX_BUNDLE_SIZE_MB,\n                \"supported_formats\": [\"tar.gz\"]\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error getting status: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_upload_delta_bundle_1358": {
      "name": "upload_delta_bundle",
      "type": "function",
      "start_line": 1358,
      "end_line": 1631,
      "content_hash": "3ff5dd0170ba33d50b20e9b15112f4ae93f11758",
      "content": "async def upload_delta_bundle(\n    request: Request,\n    bundle: UploadFile = File(...),\n    workspace_path: str = Form(...),\n    collection_name: Optional[str] = Form(None),\n    sequence_number: Optional[int] = Form(None),\n    force: Optional[bool] = Form(False),\n    source_path: Optional[str] = Form(None),\n    logical_repo_id: Optional[str] = Form(None),\n    session: Optional[str] = Form(None),\n):\n    \"\"\"Upload and process delta bundle.\"\"\"\n    start_time = datetime.now()\n    client_host = request.client.host if hasattr(request, 'client') and request.client else 'unknown'\n\n    record: Optional[Dict[str, Any]] = None\n\n    try:\n        logger.info(f\"[upload_service] Begin processing upload for workspace={workspace_path} from {client_host}\")\n\n        if AUTH_ENABLED:\n            session_value = (session or \"\").strip()\n            try:\n                record = validate_session(session_value)\n            except AuthDisabledError:\n                record = None\n            except Exception as e:\n                logger.error(f\"[upload_service] Failed to validate auth session for upload: {e}\")\n                raise HTTPException(\n                    status_code=500,\n                    detail=\"Failed to validate auth session\",\n                )\n            if record is None:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Invalid or expired session\",\n                )\n\n        # Validate workspace path\n        workspace = Path(workspace_path)\n        if not workspace.is_absolute():\n            workspace = Path(WORK_DIR) / workspace\n\n        workspace_path = str(workspace.resolve())\n\n        # Always derive repo_name from workspace_path for origin tracking\n        repo_name = _extract_repo_name_from_path(workspace_path) if _extract_repo_name_from_path else None\n        if not repo_name:\n            repo_name = Path(workspace_path).name\n\n        # Preserve any client-supplied collection name but allow server-side overrides\n        client_collection_name = collection_name\n        resolved_collection: Optional[str] = None\n\n        # Resolve collection name, preferring server-side mapping for logical_repo_id when enabled\n        if logical_repo_reuse_enabled() and logical_repo_id and find_collection_for_logical_repo:\n            try:\n                existing = find_collection_for_logical_repo(logical_repo_id, search_root=WORK_DIR)\n            except Exception:\n                existing = None\n            if existing:\n                resolved_collection = existing\n\n        # Latent migration: when no explicit mapping exists yet for this logical_repo_id, but there is a\n        # single existing collection mapping, prefer reusing it rather than creating a fresh collection.\n        if logical_repo_reuse_enabled() and logical_repo_id and resolved_collection is None and get_collection_mappings:\n            try:\n                mappings = get_collection_mappings(search_root=WORK_DIR) or []\n            except Exception:\n                mappings = []\n\n            if len(mappings) == 1:\n                canonical = mappings[0]\n                canonical_coll = canonical.get(\"collection_name\")\n                if canonical_coll:\n                    resolved_collection = canonical_coll\n                    if update_workspace_state:\n                        try:\n                            update_workspace_state(\n                                workspace_path=canonical.get(\"container_path\") or canonical.get(\"state_file\"),\n                                updates={\"logical_repo_id\": logical_repo_id},\n                                repo_name=canonical.get(\"repo_name\"),\n                            )\n                        except Exception as migrate_err:\n                            logger.debug(\n                                f\"[upload_service] Failed to migrate logical_repo_id for existing mapping: {migrate_err}\"\n                            )\n\n        # Finalize collection_name: prefer resolved server-side mapping, then client-supplied name,\n        # then standard get_collection_name/DEFAULT_COLLECTION fallbacks.\n        if resolved_collection is not None:\n            collection_name = resolved_collection\n        elif client_collection_name:\n            collection_name = client_collection_name\n        else:\n            if get_collection_name and repo_name:\n                collection_name = get_collection_name(repo_name)\n            else:\n                collection_name = DEFAULT_COLLECTION\n\n        # Enforce collection write access for uploads when auth is enabled.\n        # Semantics: \"write\" is sufficient for uploading/indexing content.\n        if AUTH_ENABLED and CTXCE_MCP_ACL_ENFORCE:\n            uid = str((record or {}).get(\"user_id\") or \"\").strip()\n            if not uid:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Invalid or expired session\",\n                )\n            try:\n                allowed = has_collection_access(uid, str(collection_name), \"write\")\n            except AuthDisabledError:\n                allowed = True\n            except Exception as e:\n                logger.error(f\"[upload_service] Failed to check collection access for upload: {e}\")\n                raise HTTPException(status_code=500, detail=\"Failed to check collection access\")\n            if not allowed:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=f\"Forbidden: write access to collection '{collection_name}' denied\",\n                )\n\n        # Persist origin metadata for remote lookups (including client source_path)\n        # Use slugged repo name (repo+16) for state so it matches ingest/watch_index usage\n        try:\n            if repo_name:\n                workspace_leaf = Path(workspace_path).name\n                if _SLUGGED_REPO_RE.match(workspace_leaf or \"\"):\n                    slug_repo_name = workspace_leaf\n                else:\n                    workspace_key = get_workspace_key(workspace_path)\n                    slug_repo_name = f\"{repo_name}-{workspace_key}\"\n                container_workspace = str(Path(WORK_DIR) / slug_repo_name)\n\n                try:\n                    marker_dir = Path(WORK_DIR) / \".codebase\" / \"repos\" / slug_repo_name\n                    marker_dir.mkdir(parents=True, exist_ok=True)\n                    (marker_dir / \".ctxce_managed_upload\").write_text(\"1\\n\")\n                except Exception:\n                    pass\n\n                # Persist logical_repo_id mapping for this slug/workspace when provided (feature-gated)\n                if logical_repo_reuse_enabled() and logical_repo_id and update_workspace_state:\n                    try:\n                        update_workspace_state(\n                            workspace_path=container_workspace,\n                            updates={\n                                \"logical_repo_id\": logical_repo_id,\n                                \"qdrant_collection\": collection_name,\n                            },\n                            repo_name=slug_repo_name,\n                        )\n                    except Exception as state_err:\n                        logger.debug(\n                            f\"[upload_service] Failed to persist logical_repo_id mapping: {state_err}\"\n                        )\n\n                if update_repo_origin:\n                    update_repo_origin(\n                        workspace_path=container_workspace,\n                        repo_name=slug_repo_name,\n                        container_path=container_workspace,\n                        source_path=source_path or workspace_path,\n                        collection_name=collection_name,\n                    )\n        except Exception as origin_err:\n            logger.debug(f\"[upload_service] Failed to persist origin info: {origin_err}\")\n\n        # Validate bundle size\n        if bundle.size and bundle.size > MAX_BUNDLE_SIZE_MB * 1024 * 1024:\n            raise HTTPException(\n                status_code=413,\n                detail=f\"Bundle too large. Max size: {MAX_BUNDLE_SIZE_MB}MB\"\n            )\n\n        # Save bundle to temporary file\n        with tempfile.NamedTemporaryFile(suffix=\".tar.gz\", delete=False) as temp_file:\n            bundle_path = Path(temp_file.name)\n\n            max_bytes = MAX_BUNDLE_SIZE_MB * 1024 * 1024\n            if bundle.size and bundle.size > max_bytes:\n                raise HTTPException(\n                    status_code=413,\n                    detail=f\"Bundle too large. Max size: {MAX_BUNDLE_SIZE_MB}MB\"\n                )\n\n            # Stream upload to file while enforcing size\n            total = 0\n            chunk_size = 1024 * 1024\n            while True:\n                chunk = await bundle.read(chunk_size)\n                if not chunk:\n                    break\n                total += len(chunk)\n                if total > max_bytes:\n                    try:\n                        temp_file.close()\n                        bundle_path.unlink(missing_ok=True)\n                    except Exception:\n                        pass\n                    raise HTTPException(\n                        status_code=413,\n                        detail=f\"Bundle too large. Max size: {MAX_BUNDLE_SIZE_MB}MB\"\n                    )\n                temp_file.write(chunk)\n\n        handed_off = False\n\n        try:\n            # Validate bundle format\n            manifest = validate_bundle_format(bundle_path)\n            bundle_id = manifest.get(\"bundle_id\")\n            manifest_sequence = manifest.get(\"sequence_number\")\n\n            # Check sequence number\n            last_sequence = get_last_sequence(workspace_path)\n            if sequence_number is None:\n                if manifest_sequence is not None:\n                    sequence_number = manifest_sequence\n                else:\n                    sequence_number = last_sequence + 1\n\n            if not force and sequence_number is not None:\n                if sequence_number != last_sequence + 1:\n                    return UploadResponse(\n                        success=False,\n                        error={\n                            \"code\": \"SEQUENCE_MISMATCH\",\n                            \"message\": f\"Expected sequence {last_sequence + 1}, got {sequence_number}\",\n                            \"expected_sequence\": last_sequence + 1,\n                            \"received_sequence\": sequence_number,\n                            \"retry_after\": 5000\n                        }\n                    )\n\n            handed_off = True\n\n            asyncio.create_task(\n                _process_bundle_background(\n                    workspace_path=workspace_path,\n                    bundle_path=bundle_path,\n                    manifest=manifest,\n                    sequence_number=sequence_number,\n                    bundle_id=bundle_id,\n                )\n            )\n\n            return UploadResponse(\n                success=True,\n                bundle_id=bundle_id,\n                sequence_number=sequence_number,\n                processed_operations=None,\n                processing_time_ms=None,\n                next_sequence=sequence_number + 1 if sequence_number else None\n            )\n\n        finally:\n            if not handed_off:\n                try:\n                    bundle_path.unlink()\n                except Exception:\n                    pass\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error processing upload: {e}\")\n        return UploadResponse(\n            success=False,\n            error={\n                \"code\": \"PROCESSING_ERROR\",\n                \"message\": f\"Error processing bundle: {str(e)}\"\n            }\n        )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_global_exception_handler_1634": {
      "name": "global_exception_handler",
      "type": "function",
      "start_line": 1634,
      "end_line": 1646,
      "content_hash": "54e7bd7ef127d29399b0099cbf717e4e8a2add7c",
      "content": "async def global_exception_handler(request: Request, exc: Exception):\n    \"\"\"Global exception handler.\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"success\": False,\n            \"error\": {\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        }\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_1648": {
      "name": "main",
      "type": "function",
      "start_line": 1648,
      "end_line": 1664,
      "content_hash": "03ffc19f4f2df96e1eea2a3712fc194fb7f72c13",
      "content": "def main():\n    \"\"\"Main entry point for the upload service.\"\"\"\n    host = os.environ.get(\"UPLOAD_SERVICE_HOST\", \"0.0.0.0\")\n    port = _int_env(\"UPLOAD_SERVICE_PORT\", 8002)\n\n    logger.info(f\"Starting upload service on {host}:{port}\")\n    logger.info(f\"Qdrant URL: {QDRANT_URL}\")\n    logger.info(f\"Work directory: {WORK_DIR}\")\n    logger.info(f\"Max bundle size: {MAX_BUNDLE_SIZE_MB}MB\")\n\n    uvicorn.run(\n        app,\n        host=host,\n        port=port,\n        log_level=\"info\",\n        access_log=True\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}