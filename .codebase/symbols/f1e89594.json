{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/traversal_tests/shortest_path_tests.rs",
  "file_hash": "3dc95121e807b4fbe157fc290ca29a5a7b17ab7d",
  "updated_at": "2025-12-26T17:34:20.426732",
  "symbols": {
    "function_setup_test_db_22": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 22,
      "end_line": 34,
      "content_hash": "08bb0f06064d2277b5cf43aecf3c82469d11003e",
      "content": "fn setup_test_db() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let storage = HelixGraphStorage::new(\n        db_path,\n        crate::helix_engine::traversal_core::config::Config::default(),\n        Default::default(),\n    )\n    .unwrap();\n    (temp_dir, Arc::new(storage))\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_shortest_path_simple_chain_35": {
      "name": "test_shortest_path_simple_chain",
      "type": "function",
      "start_line": 35,
      "end_line": 81,
      "content_hash": "112b2675c4572ade0484eaa165c537bf0ae5d961",
      "content": "fn test_shortest_path_simple_chain() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node_ids: Vec<_> = [\"A\", \"B\", \"C\", \"D\"]\n        .into_iter()\n        .map(|name| {\n            G::new_mut(&storage, &arena, &mut txn)\n                .add_n(\"person\", props_option(&arena, props!(\"name\" => name)), None)\n                .collect::<Result<Vec<_>, _>>()\n                .unwrap()[0]\n                .id()\n        })\n        .collect();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, node_ids[0], node_ids[1], false)\n        .collect_to_obj()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, node_ids[1], node_ids[2], false)\n        .collect_to_obj()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, node_ids[2], node_ids[3], false)\n        .collect_to_obj()\n        .unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&node_ids[0])\n        .shortest_path(Some(\"knows\"), None, Some(&node_ids[3]))\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert_eq!(path.len(), 1);\n    if let TraversalValue::Path((nodes, edges)) = &path[0] {\n        assert_eq!(nodes.len(), 4);\n        assert_eq!(edges.len(), 3);\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_dijkstra_shortest_path_weighted_graph_82": {
      "name": "test_dijkstra_shortest_path_weighted_graph",
      "type": "function",
      "start_line": 82,
      "end_line": 191,
      "content_hash": "b39a57e939b2c8637f8b9871a571e28e8292e736",
      "content": "fn test_dijkstra_shortest_path_weighted_graph() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\")),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid1 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"city\", props_option(&arena, props!(\"name\" => \"mid1\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"city\", props_option(&arena, props!(\"name\" => \"mid2\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"city\", props_option(&arena, props!(\"name\" => \"end\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 100.0)),\n            start,\n            end,\n            false,\n        )\n        .collect_to_obj()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 3.0)),\n            start,\n            mid1,\n            false,\n        )\n        .collect_to_obj()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 3.0)),\n            mid1,\n            mid2,\n            false,\n        )\n        .collect_to_obj()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 4.0)),\n            mid2,\n            end,\n            false,\n        )\n        .collect_to_obj()\n        .unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let bfs = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            PathAlgorithm::BFS,\n            default_weight_fn,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    if let TraversalValue::Path((nodes, _)) = &bfs[0] {\n        assert_eq!(nodes.len(), 2);\n    } else {\n        panic!(\"expected path\");\n    }\n\n    let dijkstra = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            PathAlgorithm::Dijkstra,\n            default_weight_fn,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    if let TraversalValue::Path((nodes, _)) = &dijkstra[0] {\n        assert_eq!(nodes.len(), 4);\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_dijkstra_custom_weight_function_192": {
      "name": "test_dijkstra_custom_weight_function",
      "type": "function",
      "start_line": 192,
      "end_line": 296,
      "content_hash": "c3257c41289312e900e3f273eeeca65f3271b5a9",
      "content": "fn test_dijkstra_custom_weight_function() {\n    use crate::protocol::value::Value;\n\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\")),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"city\", props_option(&arena, props!(\"name\" => \"mid\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"city\", props_option(&arena, props!(\"name\" => \"end\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    // Direct route with distance 10\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 10.0)),\n            start,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    // Route through mid with distance 3 + 3 = 6\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 3.0)),\n            start,\n            mid,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 3.0)),\n            mid,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    txn.commit().unwrap();\n\n    // Test with custom weight function using \"distance\" property\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let custom_weight = |edge: &crate::utils::items::Edge,\n                         _src: &crate::utils::items::Node,\n                         _dst: &crate::utils::items::Node| {\n        edge.properties\n            .as_ref()\n            .and_then(|props| props.get(\"distance\"))\n            .and_then(|v| match v {\n                Value::F64(f) => Some(*f),\n                Value::F32(f) => Some(*f as f64),\n                _ => None,\n            })\n            .ok_or_else(|| {\n                crate::helix_engine::types::GraphError::TraversalError(\n                    \"Missing distance property\".to_string(),\n                )\n            })\n    };\n\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            PathAlgorithm::Dijkstra,\n            custom_weight,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    if let TraversalValue::Path((nodes, edges)) = &path[0] {\n        // Should take the route through mid (3 nodes, 2 edges) because 3+3 < 10\n        assert_eq!(nodes.len(), 3, \"Expected path through mid node\");\n        assert_eq!(edges.len(), 2, \"Expected 2 edges in path\");\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_dijkstra_multi_context_weight_297": {
      "name": "test_dijkstra_multi_context_weight",
      "type": "function",
      "start_line": 297,
      "end_line": 462,
      "content_hash": "36f8e680d1835ba756584a2430aa2fee6127d791",
      "content": "fn test_dijkstra_multi_context_weight() {\n    use crate::protocol::value::Value;\n\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    // Create nodes with traffic_factor property\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\", \"traffic_factor\" => 1.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid1 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"mid1\", \"traffic_factor\" => 2.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"mid2\", \"traffic_factor\" => 1.1)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"end\", \"traffic_factor\" => 1.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    // Route through mid1: distance 5, source traffic 1.0 -> weight = 5 * 1.0 = 5\n    // Then mid1 to end: distance 5, source traffic 2.0 -> weight = 5 * 2.0 = 10\n    // Total: 15\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 5.0)),\n            start,\n            mid1,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 5.0)),\n            mid1,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    // Route through mid2: distance 6, source traffic 1.0 -> weight = 6 * 1.0 = 6\n    // Then mid2 to end: distance 6, source traffic 1.1 -> weight = 6 * 1.1 = 6.6\n    // Total: 12.6 (should be chosen)\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 6.0)),\n            start,\n            mid2,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 6.0)),\n            mid2,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    txn.commit().unwrap();\n\n    // Test with multi-context weight: distance * source_traffic_factor\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let multi_context_weight = |edge: &crate::utils::items::Edge,\n                                src: &crate::utils::items::Node,\n                                _dst: &crate::utils::items::Node| {\n        let distance = edge\n            .properties\n            .as_ref()\n            .and_then(|props| props.get(\"distance\"))\n            .and_then(|v| match v {\n                Value::F64(f) => Some(*f),\n                Value::F32(f) => Some(*f as f64),\n                _ => None,\n            })\n            .ok_or_else(|| {\n                crate::helix_engine::types::GraphError::TraversalError(\n                    \"Missing distance\".to_string(),\n                )\n            })?;\n\n        let traffic = src\n            .properties\n            .as_ref()\n            .and_then(|props| props.get(\"traffic_factor\"))\n            .and_then(|v| match v {\n                Value::F64(f) => Some(*f),\n                Value::F32(f) => Some(*f as f64),\n                _ => None,\n            })\n            .ok_or_else(|| {\n                crate::helix_engine::types::GraphError::TraversalError(\n                    \"Missing traffic_factor\".to_string(),\n                )\n            })?;\n\n        Ok(distance * traffic)\n    };\n\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            PathAlgorithm::Dijkstra,\n            multi_context_weight,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    if let TraversalValue::Path((nodes, _edges)) = &path[0] {\n        // Should take route through mid2 (lower total weight: 12.6 < 15)\n        assert_eq!(nodes.len(), 3);\n        // Verify it's mid2 by checking the middle node\n        if let Some(mid_node) = nodes.get(1) {\n            let mid_name = mid_node\n                .properties\n                .as_ref()\n                .and_then(|p| p.get(\"name\"))\n                .and_then(|v| match v {\n                    Value::String(s) => Some(s.as_str()),\n                    _ => None,\n                });\n            assert_eq!(mid_name, Some(\"mid2\"), \"Expected path through mid2 node\");\n        }\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_default_weight_fn_unit_463": {
      "name": "test_default_weight_fn_unit",
      "type": "function",
      "start_line": 463,
      "end_line": 517,
      "content_hash": "75ab740543809c1f308003b75d339617d15e1499",
      "content": "fn test_default_weight_fn_unit() {\n    use crate::{\n        protocol::value::Value,\n        utils::items::{Edge, Node},\n        utils::properties::ImmutablePropertiesMap,\n    };\n    use bumpalo::Bump;\n\n    let arena = Bump::new();\n\n    // Create edge with weight property\n    let props_data = [(\"weight\", Value::F64(5.5))];\n    let props_map = ImmutablePropertiesMap::new(props_data.len(), props_data.into_iter(), &arena);\n\n    let edge = Edge {\n        id: 1,\n        label: \"test\",\n        version: 0,\n        from_node: 1,\n        to_node: 2,\n        properties: Some(props_map),\n    };\n\n    // Create dummy nodes\n    let node1 = Node {\n        id: 1,\n        label: \"test\",\n        version: 0,\n        properties: None,\n    };\n    let node2 = Node {\n        id: 2,\n        label: \"test\",\n        version: 0,\n        properties: None,\n    };\n\n    // Test default_weight_fn returns the weight property\n    let weight = default_weight_fn(&edge, &node1, &node2).unwrap();\n    assert_eq!(weight, 5.5);\n\n    // Test default weight when property is missing\n    let edge_no_weight = Edge {\n        id: 2,\n        label: \"test\",\n        version: 0,\n        from_node: 1,\n        to_node: 2,\n        properties: None,\n    };\n    let default = default_weight_fn(&edge_no_weight, &node1, &node2).unwrap();\n    assert_eq!(default, 1.0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_shortest_path_with_constant_weight_518": {
      "name": "test_shortest_path_with_constant_weight",
      "type": "function",
      "start_line": 518,
      "end_line": 588,
      "content_hash": "bbc0acb1aebd36f08a765a8cd2f963a13be6270d",
      "content": "fn test_shortest_path_with_constant_weight() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"node\",\n            props_option(&arena, props!(\"name\" => \"start\")),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let mid = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"node\", props_option(&arena, props!(\"name\" => \"mid\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"node\", props_option(&arena, props!(\"name\" => \"end\")), None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    // Direct route\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"link\", None, start, end, false)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    // Route through mid (2 hops)\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"link\", None, start, mid, false)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"link\", None, mid, end, false)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    txn.commit().unwrap();\n\n    // Test with constant weight (equivalent to counting hops)\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let constant_weight = |_edge: &crate::utils::items::Edge,\n                           _src: &crate::utils::items::Node,\n                           _dst: &crate::utils::items::Node| { Ok(1.0) };\n\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"link\"),\n            None,\n            Some(&end),\n            PathAlgorithm::Dijkstra,\n            constant_weight,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    if let TraversalValue::Path((nodes, edges)) = &path[0] {\n        // Should take direct route (2 nodes, 1 edge)\n        assert_eq!(nodes.len(), 2);\n        assert_eq!(edges.len(), 1);\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_astar_with_property_heuristic_589": {
      "name": "test_astar_with_property_heuristic",
      "type": "function",
      "start_line": 589,
      "end_line": 723,
      "content_hash": "d2076b0b5a26c9b43714af23dd531896988f474b",
      "content": "fn test_astar_with_property_heuristic() {\n    use crate::helix_engine::traversal_core::ops::util::paths::property_heuristic;\n\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    // Create a graph where A* should find the optimal path\n    // Graph: start -> mid1 -> goal\n    //        start -> mid2 -> goal\n    // Weights: start->mid1: 5.0, mid1->goal: 5.0 (total: 10.0)\n    //          start->mid2: 1.0, mid2->goal: 15.0 (total: 16.0)\n    // Heuristics: start: h=10, mid1: h=5, mid2: h=5, goal: h=0\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\", \"h\" => 10.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let mid1 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"mid1\", \"h\" => 5.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let mid2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"mid2\", \"h\" => 5.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let goal = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"goal\", \"h\" => 0.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    // Add edges with weights\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 5.0)),\n            start,\n            mid1,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 5.0)),\n            mid1,\n            goal,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 1.0)),\n            start,\n            mid2,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 15.0)),\n            mid2,\n            goal,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    txn.commit().unwrap();\n\n    // Run A* with property-based heuristic\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    let heuristic = |node: &crate::utils::items::Node| property_heuristic(node, \"h\");\n\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_astar(\n            Some(\"road\"),\n            None,\n            Some(&goal),\n            default_weight_fn,\n            heuristic,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    assert_eq!(path.len(), 1);\n    if let TraversalValue::Path((nodes, edges)) = &path[0] {\n        // A* should find the path: start -> mid1 -> goal (total cost 10.0)\n        assert_eq!(nodes.len(), 3);\n        assert_eq!(edges.len(), 2);\n\n        // Verify the nodes in the path\n        assert_eq!(nodes[0].id, start);\n        assert_eq!(nodes[1].id, mid1);\n        assert_eq!(nodes[2].id, goal);\n    } else {\n        panic!(\"expected path\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_astar_matches_dijkstra_with_zero_heuristic_724": {
      "name": "test_astar_matches_dijkstra_with_zero_heuristic",
      "type": "function",
      "start_line": 724,
      "end_line": 829,
      "content_hash": "e37b789447e795b5ebe26f2a47fc46ca776fcfaf",
      "content": "fn test_astar_matches_dijkstra_with_zero_heuristic() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\", \"h\" => 0.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let mid = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"mid\", \"h\" => 0.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"end\", \"h\" => 0.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 5.0)),\n            start,\n            mid,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"weight\" => 3.0)),\n            mid,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    txn.commit().unwrap();\n\n    // Test that A* with zero heuristic behaves like Dijkstra\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    let zero_heuristic = |_node: &crate::utils::items::Node| Ok(0.0);\n\n    let astar_path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_astar(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            default_weight_fn,\n            zero_heuristic,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    let dijkstra_path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_with_algorithm(\n            Some(\"road\"),\n            None,\n            Some(&end),\n            PathAlgorithm::Dijkstra,\n            default_weight_fn,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    // Both should find the same path\n    assert_eq!(astar_path.len(), 1);\n    assert_eq!(dijkstra_path.len(), 1);\n\n    if let (\n        TraversalValue::Path((astar_nodes, astar_edges)),\n        TraversalValue::Path((dijkstra_nodes, dijkstra_edges)),\n    ) = (&astar_path[0], &dijkstra_path[0])\n    {\n        assert_eq!(astar_nodes.len(), dijkstra_nodes.len());\n        assert_eq!(astar_edges.len(), dijkstra_edges.len());\n    } else {\n        panic!(\"expected paths\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_astar_custom_weight_and_heuristic_830": {
      "name": "test_astar_custom_weight_and_heuristic",
      "type": "function",
      "start_line": 830,
      "end_line": 907,
      "content_hash": "1e7295130f73b8273e4793ec1ac807df0c362a95",
      "content": "fn test_astar_custom_weight_and_heuristic() {\n    use crate::helix_engine::traversal_core::ops::util::paths::property_heuristic;\n\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let start = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"start\", \"h\" => 10.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let end = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"city\",\n            props_option(&arena, props!(\"name\" => \"end\", \"h\" => 0.0)),\n            None,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"road\",\n            props_option(&arena, props!(\"distance\" => 100.0, \"traffic\" => 0.5)),\n            start,\n            end,\n            false,\n        )\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    txn.commit().unwrap();\n\n    // Test A* with custom weight function (distance * traffic) and property heuristic\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    let custom_weight = |edge: &crate::utils::items::Edge,\n                         _src: &crate::utils::items::Node,\n                         _dst: &crate::utils::items::Node| {\n        let distance = edge\n            .get_property(\"distance\")\n            .ok_or(crate::helix_engine::types::GraphError::New(\n                \"distance property not found\".to_string(),\n            ))?\n            .as_f64();\n        let traffic = edge\n            .get_property(\"traffic\")\n            .ok_or(crate::helix_engine::types::GraphError::New(\n                \"traffic property not found\".to_string(),\n            ))?\n            .as_f64();\n        Ok(distance * traffic)\n    };\n\n    let heuristic = |node: &crate::utils::items::Node| property_heuristic(node, \"h\");\n\n    let path = G::new(&storage, &txn, &arena)\n        .n_from_id(&start)\n        .shortest_path_astar(Some(\"road\"), None, Some(&end), custom_weight, heuristic)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    assert_eq!(path.len(), 1);\n    if let TraversalValue::Path((nodes, edges)) = &path[0] {\n        assert_eq!(nodes.len(), 2);\n        assert_eq!(edges.len(), 1);\n    } else {\n        panic!(\"expected path\");\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}