{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/traversal_tests/drop_tests.rs",
  "file_hash": "4ad3ddeb89d9b53509f3db0c3c0a6587192e6b0a",
  "updated_at": "2025-12-26T17:34:20.098940",
  "symbols": {
    "function_setup_test_db_35": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 35,
      "end_line": 46,
      "content_hash": "34cee3a1054f593771d88e8310cf09da65e1bcaa",
      "content": "fn setup_test_db() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let storage = HelixGraphStorage::new(\n        db_path,\n        crate::helix_engine::traversal_core::config::Config::default(),\n        Default::default(),\n    )\n    .unwrap();\n    (temp_dir, Arc::new(storage))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_to_result_iter_47": {
      "name": "to_result_iter",
      "type": "function",
      "start_line": 47,
      "end_line": 52,
      "content_hash": "e558460545818da5f2f61b501a3641d4cb458b3c",
      "content": "fn to_result_iter(\n    values: Vec<TraversalValue>,\n) -> impl Iterator<Item = Result<TraversalValue, GraphError>> {\n    values.into_iter().map(Ok)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_id_53": {
      "name": "node_id",
      "type": "function",
      "start_line": 53,
      "end_line": 59,
      "content_hash": "e9a4f25b0e9eb8b70e03dbacabf9f0c18363ed4a",
      "content": "fn node_id(value: TraversalValue) -> u128 {\n    match value {\n        TraversalValue::Node(node) => node.id,\n        _ => panic!(\"expected node\"),\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_edge_id_60": {
      "name": "edge_id",
      "type": "function",
      "start_line": 60,
      "end_line": 67,
      "content_hash": "758926cee0df20753150860ba20072b97be7fc04",
      "content": "fn edge_id(value: TraversalValue) -> u128 {\n    match value {\n        TraversalValue::Edge(edge) => edge.id,\n        _ => panic!(\"expected edge\"),\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_edge_68": {
      "name": "test_drop_edge",
      "type": "function",
      "start_line": 68,
      "end_line": 127,
      "content_hash": "31108b1dd11e974b1b3ff1d6e48dd0ef71936618",
      "content": "fn test_drop_edge() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node1_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    let node2_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    let edge_id = edge_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, node1_id, node2_id, false)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(traversal), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge_id)\n        .collect_to_obj();\n    assert!(matches!(traversal, Err(GraphError::EdgeNotFound)));\n\n    let edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&node1_id)\n        .out_e(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert!(edges.is_empty());\n\n    let edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&node2_id)\n        .in_e(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert!(edges.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_128": {
      "name": "test_drop_node",
      "type": "function",
      "start_line": 128,
      "end_line": 178,
      "content_hash": "db9653ef8bf9628e0492a7be2063031b76a057ca",
      "content": "fn test_drop_node() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node1_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", props_option(&arena, props!(\"name\" => \"n1\")), None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    let node2_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", props_option(&arena, props!(\"name\" => \"n2\")), None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, node1_id, node2_id, false)\n        .collect_to_obj()\n        .unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_id(&node1_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(traversal), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let node_val = G::new(&storage, &txn, &arena)\n        .n_from_id(&node1_id)\n        .collect_to_obj();\n    assert!(matches!(node_val, Err(GraphError::NodeNotFound)));\n\n    let edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&node2_id)\n        .in_e(\"knows\")\n        .collect::<Result<Vec<_>, _>>().unwrap();\n    println!(\"edges: {:?}\", edges);\n    assert!(edges.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_traversal_179": {
      "name": "test_drop_traversal",
      "type": "function",
      "start_line": 179,
      "end_line": 238,
      "content_hash": "a976b219fe94ab5d98065a4aa7bc564cf7cfe22e",
      "content": "fn test_drop_traversal() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let origin_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n\n    let mut neighbor_ids = Vec::new();\n    for _ in 0..10 {\n        let neighbor_id = node_id(\n            G::new_mut(&storage, &arena, &mut txn)\n                .add_n(\"person\", None, None)\n                .collect_to_obj()\n                .unwrap(),\n        );\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, origin_id, neighbor_id, false)\n            .collect_to_obj()\n            .unwrap();\n        neighbor_ids.push(neighbor_id);\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let neighbors = G::new(&storage, &txn, &arena)\n        .n_from_id(&origin_id)\n        .out_node(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    let origin = G::new(&storage, &txn, &arena)\n        .n_from_id(&origin_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(neighbors), storage.as_ref(), &mut txn).unwrap();\n    Drop::drop_traversal(to_result_iter(origin), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let remaining = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert!(remaining.is_empty());\n    drop(txn);\n\n    // sanity check: ensure ids removed\n    assert!(neighbor_ids.len() == 10);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_deletion_in_existing_graph_239": {
      "name": "test_node_deletion_in_existing_graph",
      "type": "function",
      "start_line": 239,
      "end_line": 322,
      "content_hash": "97dd1f47ceb0245f44325c680ee87aff9b51e989",
      "content": "fn test_node_deletion_in_existing_graph() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n\n    let mut others = Vec::new();\n    for _ in 0..10 {\n        let id = node_id(\n            G::new_mut(&storage, &arena, &mut txn)\n                .add_n(\"person\", None, None)\n                .collect_to_obj()\n                .unwrap(),\n        );\n        others.push(id);\n    }\n\n    for &other in &others {\n        let random = others[rand::rng().random_range(0..others.len())];\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, random, other, false)\n            .collect_to_obj()\n            .unwrap();\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, source_id, other, false)\n            .collect_to_obj()\n            .unwrap();\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, other, source_id, false)\n            .collect_to_obj()\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let source = G::new(&storage, &txn, &arena)\n        .n_from_id(&source_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(source), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let out_edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&source_id)\n        .out_node(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    let arena = Bump::new();\n    let in_edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&source_id)\n        .in_node(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert!(out_edges.is_empty());\n    assert!(in_edges.is_empty());\n\n    let arena = Bump::new();\n    let remaining_edges = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert_eq!(remaining_edges.len(), others.len());\n    assert!(remaining_edges.iter().all(|value| {\n        if let TraversalValue::Edge(edge) = value {\n            edge.from_node != source_id && edge.to_node != source_id\n        } else {\n            false\n        }\n    }));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_deletion_in_existing_graph_323": {
      "name": "test_edge_deletion_in_existing_graph",
      "type": "function",
      "start_line": 323,
      "end_line": 377,
      "content_hash": "75c814aa61c65dd40ae6941bee5422e0a5415c1d",
      "content": "fn test_edge_deletion_in_existing_graph() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node1_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    let node2_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n\n    let edge1_id = edge_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, node1_id, node2_id, false)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    let edge2_id = edge_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, node2_id, node1_id, false)\n            .collect_to_obj()\n            .unwrap(),\n    );\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edges = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge1_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(edges), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edges = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert_eq!(edges.len(), 1);\n    assert_eq!(edges[0].id(), edge2_id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_deletion_in_existing_graph_378": {
      "name": "test_vector_deletion_in_existing_graph",
      "type": "function",
      "start_line": 378,
      "end_line": 491,
      "content_hash": "2a03b6fc531e9dc29976ca354a9762e492c033ce",
      "content": "fn test_vector_deletion_in_existing_graph() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node_id = node_id(\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap(),\n    );\n\n    let mut vector_ids = Vec::new();\n    for _ in 0..10 {\n        let id = match G::new_mut(&storage, &arena, &mut txn)\n            .insert_v::<Filter>(&[1.0, 1.0, 1.0, 1.0], \"vector\", None)\n            .collect_to_obj()\n            .unwrap()\n        {\n            TraversalValue::Vector(vector) => vector.id,\n            TraversalValue::VectorNodeWithoutVectorData(vector) => *vector.id(),\n            other => panic!(\"unexpected value: {other:?}\"),\n        };\n        vector_ids.push(id);\n    }\n\n    let target_vector_id = match G::new_mut(&storage, &arena, &mut txn)\n        .insert_v::<Filter>(&[1.0, 1.0, 1.0, 1.0], \"vector\", None)\n        .collect_to_obj()\n        .unwrap()\n    {\n        TraversalValue::Vector(vector) => vector.id,\n        TraversalValue::VectorNodeWithoutVectorData(vector) => *vector.id(),\n        other => panic!(\"unexpected value: {other:?}\"),\n    };\n\n    for &other in &vector_ids {\n        let random = vector_ids[rand::rng().random_range(0..vector_ids.len())];\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, other, random, false)\n            .collect_to_obj()\n            .unwrap();\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, node_id, target_vector_id, false)\n            .collect_to_obj()\n            .unwrap();\n        G::new_mut(&storage, &arena, &mut txn)\n            .add_edge(\"knows\", None, target_vector_id, node_id, false)\n            .collect_to_obj()\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edges = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert_eq!(edges.len(), 30);\n    drop(txn);\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_id(&node_id)\n        .out_vec(\"knows\", false)\n        .filter_ref(|val, _| match val {\n            Ok(TraversalValue::Vector(vector)) => Ok(*vector.id() == target_vector_id),\n            Ok(TraversalValue::VectorNodeWithoutVectorData(vector)) => {\n                Ok(*vector.id() == target_vector_id)\n            }\n            Ok(_) => Ok(false),\n            Err(err) => Err(GraphError::from(err.to_string())),\n        })\n        .dedup()\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(to_result_iter(traversal), storage.as_ref(), &mut txn).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let out_edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&node_id)\n        .out_vec(\"knows\", false)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    let arena = Bump::new();\n    let in_edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&node_id)\n        .in_vec(\"knows\", false)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert!(out_edges.is_empty());\n    assert!(in_edges.is_empty());\n\n    let arena = Bump::new();\n    let other_edges = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    assert_eq!(other_edges.len(), vector_ids.len());\n    assert!(other_edges.iter().all(|value| {\n        if let TraversalValue::Edge(edge) = value {\n            edge.from_node != target_vector_id && edge.to_node != target_vector_id\n        } else {\n            false\n        }\n    }));\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}