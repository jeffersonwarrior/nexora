{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/schema_parse_methods.rs",
  "file_hash": "03d06ef8b6b57caab8843a0752baae61518f3b61",
  "updated_at": "2025-12-26T17:34:23.263593",
  "symbols": {
    "impl_HelixParser_15": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 15,
      "end_line": 546,
      "content_hash": "2e61de4a7baf2303ec8f93ba8597e0cbcba7c3e3",
      "content": "impl HelixParser {\n    pub(super) fn parse_node_def(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<NodeSchema, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let name = pairs.try_next()?.as_str().to_string();\n        let fields = self.parse_node_body(pairs.try_next()?, filepath.clone())?;\n        Ok(NodeSchema {\n            name: (pair.loc_with_filepath(filepath.clone()), name),\n            fields,\n            loc: pair.loc_with_filepath(filepath),\n        })\n    }\n\n    pub(super) fn parse_vector_def(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<VectorSchema, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let name = pairs.try_next()?.as_str().to_string();\n        let fields = self.parse_node_body(pairs.try_next()?, filepath.clone())?;\n        Ok(VectorSchema {\n            name,\n            fields,\n            loc: pair.loc_with_filepath(filepath),\n        })\n    }\n\n    pub(super) fn parse_node_body(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<Vec<Field>, ParserError> {\n        let field_defs = pair\n            .into_inner()\n            .find(|p| p.as_rule() == Rule::field_defs)\n            .ok_or_else(|| ParserError::from(\"Expected field_defs in properties\"))?;\n\n        // Now parse each individual field_def\n        field_defs\n            .into_inner()\n            .map(|p| self.parse_field_def(p, filepath.clone()))\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub(super) fn parse_migration_def(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<Migration, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let from_version = pairs.try_next_inner()?.try_next()?;\n        let to_version = pairs.try_next_inner()?.try_next()?;\n\n        // migration body -> [migration-item-mapping, migration-item-mapping, ...]\n        let body = pairs\n            .try_next_inner()?\n            .map(|p| self.parse_migration_item_mapping(p))\n            .collect::<Result<Vec<_>, _>>()?;\n\n        Ok(Migration {\n            from_version: (\n                from_version.loc(),\n                from_version.as_str().parse::<usize>().map_err(|e| {\n                    ParserError::from(format!(\n                        \"Invalid schema version number '{}': {e}\",\n                        from_version.as_str()\n                    ))\n                })?,\n            ),\n            to_version: (\n                to_version.loc(),\n                to_version.as_str().parse::<usize>().map_err(|e| {\n                    ParserError::from(format!(\n                        \"Invalid schema version number '{}': {e}\",\n                        to_version.as_str()\n                    ))\n                })?,\n            ),\n            body,\n            loc: pair.loc_with_filepath(filepath),\n        })\n    }\n\n    pub(super) fn parse_migration_item_mapping(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<MigrationItemMapping, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let from_item_type = match pairs.next() {\n            Some(item_def) => match item_def.into_inner().next() {\n                Some(item_decl) => match item_decl.as_rule() {\n                    Rule::node_decl => (\n                        item_decl.loc(),\n                        MigrationItem::Node(item_decl.try_inner_next()?.as_str().to_string()),\n                    ),\n                    Rule::edge_decl => (\n                        item_decl.loc(),\n                        MigrationItem::Edge(item_decl.try_inner_next()?.as_str().to_string()),\n                    ),\n                    Rule::vec_decl => (\n                        item_decl.loc(),\n                        MigrationItem::Vector(item_decl.try_inner_next()?.as_str().to_string()),\n                    ),\n                    _ => {\n                        return Err(ParserError::from(format!(\n                            \"Expected item declaration, got {:?}\",\n                            item_decl.as_rule()\n                        )));\n                    }\n                },\n                None => {\n                    return Err(ParserError::from(format!(\n                        \"Expected item declaration, got {:?}\",\n                        pair.as_rule()\n                    )));\n                }\n            },\n            _ => {\n                return Err(ParserError::from(format!(\n                    \"Expected item declaration, got {:?}\",\n                    pair.as_rule()\n                )));\n            }\n        };\n\n        let to_item_type = match pairs.next() {\n            Some(pair) => match pair.as_rule() {\n                Rule::item_def => match pair.into_inner().next() {\n                    Some(item_decl) => match item_decl.as_rule() {\n                        Rule::node_decl => (\n                            item_decl.loc(),\n                            MigrationItem::Node(item_decl.try_inner_next()?.as_str().to_string()),\n                        ),\n                        Rule::edge_decl => (\n                            item_decl.loc(),\n                            MigrationItem::Edge(item_decl.try_inner_next()?.as_str().to_string()),\n                        ),\n                        Rule::vec_decl => (\n                            item_decl.loc(),\n                            MigrationItem::Vector(item_decl.try_inner_next()?.as_str().to_string()),\n                        ),\n                        _ => {\n                            return Err(ParserError::from(format!(\n                                \"Expected item declaration, got {:?}\",\n                                item_decl.as_rule()\n                            )));\n                        }\n                    },\n                    None => {\n                        return Err(ParserError::from(format!(\n                            \"Expected item, got {:?}\",\n                            pairs.peek()\n                        )));\n                    }\n                },\n                Rule::anon_decl => from_item_type.clone(),\n                _ => {\n                    return Err(ParserError::from(format!(\n                        \"Invalid item declaration, got {:?}\",\n                        pair.as_rule()\n                    )));\n                }\n            },\n            None => {\n                return Err(ParserError::from(format!(\n                    \"Expected item_def, got {:?}\",\n                    pairs.peek()\n                )));\n            }\n        };\n        let remappings = match pairs.next() {\n            Some(p) => match p.as_rule() {\n                Rule::node_migration => p\n                    .try_inner_next()?\n                    .into_inner()\n                    .map(|p| self.parse_field_migration(p))\n                    .collect::<Result<Vec<_>, _>>()?,\n                Rule::edge_migration => p\n                    .try_inner_next()?\n                    .into_inner()\n                    .map(|p| self.parse_field_migration(p))\n                    .collect::<Result<Vec<_>, _>>()?,\n                _ => {\n                    return Err(ParserError::from(\n                        \"Expected node_migration or edge_migration\",\n                    ));\n                }\n            },\n            None => {\n                return Err(ParserError::from(\n                    \"Expected node_migration or edge_migration\",\n                ));\n            }\n        };\n\n        Ok(MigrationItemMapping {\n            from_item: from_item_type,\n            to_item: to_item_type,\n            remappings,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_default_value(\n        &self,\n        pairs: &mut Pairs<Rule>,\n        field_type: &FieldType,\n    ) -> Result<Option<DefaultValue>, ParserError> {\n        match pairs.peek() {\n            Some(pair) => {\n                if pair.as_rule() == Rule::default {\n                    pairs.next();\n                    let default_value = match pair.into_inner().next() {\n                        Some(pair) => match pair.as_rule() {\n                            Rule::string_literal => DefaultValue::String(pair.as_str().to_string()),\n                            Rule::float => {\n                                match field_type {\n                                    FieldType::F32 => DefaultValue::F32(\n                                        pair.as_str().parse::<f32>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid float value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::F64 => DefaultValue::F64(\n                                        pair.as_str().parse::<f64>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid float value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    other => return Err(ParserError::from(format!(\n                                        \"Float default value not valid for field type {:?}\",\n                                        other\n                                    ))),\n                                }\n                            }\n                            Rule::integer => {\n                                match field_type {\n                                    FieldType::I8 => DefaultValue::I8(\n                                        pair.as_str().parse::<i8>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::I16 => DefaultValue::I16(\n                                        pair.as_str().parse::<i16>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::I32 => DefaultValue::I32(\n                                        pair.as_str().parse::<i32>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::I64 => DefaultValue::I64(\n                                        pair.as_str().parse::<i64>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::U8 => DefaultValue::U8(\n                                        pair.as_str().parse::<u8>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::U16 => DefaultValue::U16(\n                                        pair.as_str().parse::<u16>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::U32 => DefaultValue::U32(\n                                        pair.as_str().parse::<u32>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::U64 => DefaultValue::U64(\n                                        pair.as_str().parse::<u64>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    FieldType::U128 => DefaultValue::U128(\n                                        pair.as_str().parse::<u128>().map_err(|e| {\n                                            ParserError::from(format!(\n                                                \"Invalid integer value '{}': {e}\",\n                                                pair.as_str()\n                                            ))\n                                        })?,\n                                    ),\n                                    other => return Err(ParserError::from(format!(\n                                        \"Integer default value not valid for field type {:?}\",\n                                        other\n                                    ))),\n                                }\n                            }\n                            Rule::now => DefaultValue::Now,\n                            Rule::boolean => DefaultValue::Boolean(\n                                pair.as_str().parse::<bool>().map_err(|e| {\n                                    ParserError::from(format!(\n                                        \"Invalid boolean value '{}': {e}\",\n                                        pair.as_str()\n                                    ))\n                                })?,\n                            ),\n                            other => return Err(ParserError::from(format!(\n                                \"Unexpected rule for default value: {:?}\",\n                                other\n                            ))),\n                        },\n                        None => DefaultValue::Empty,\n                    };\n                    Ok(Some(default_value))\n                } else {\n                    Ok(None)\n                }\n            }\n            None => Ok(None),\n        }\n    }\n\n    pub(super) fn parse_cast(&self, pair: Pair<Rule>) -> Result<Option<ValueCast>, ParserError> {\n        match pair.as_rule() {\n            Rule::cast => Ok(Some(ValueCast {\n                loc: pair.loc(),\n                cast_to: self.parse_field_type(pair.try_inner_next()?, None)?,\n            })),\n            _ => Ok(None),\n        }\n    }\n\n    pub(super) fn parse_field_migration(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<MigrationPropertyMapping, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let property_name = pairs.try_next()?;\n        let property_value = pairs.try_next()?;\n        let cast = if let Some(cast_pair) = pairs.next() {\n            self.parse_cast(cast_pair)?\n        } else {\n            None\n        };\n\n        Ok(MigrationPropertyMapping {\n            property_name: (property_name.loc(), property_name.as_str().to_string()),\n            property_value: self.parse_field_value(property_value)?,\n            default: None,\n            cast,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_field_type(\n        &self,\n        field: Pair<Rule>,\n        _schema: Option<&Source>,\n    ) -> Result<FieldType, ParserError> {\n        match field.as_rule() {\n            Rule::named_type => {\n                let type_str = field.as_str();\n                match type_str {\n                    \"String\" => Ok(FieldType::String),\n                    \"Boolean\" => Ok(FieldType::Boolean),\n                    \"F32\" => Ok(FieldType::F32),\n                    \"F64\" => Ok(FieldType::F64),\n                    \"I8\" => Ok(FieldType::I8),\n                    \"I16\" => Ok(FieldType::I16),\n                    \"I32\" => Ok(FieldType::I32),\n                    \"I64\" => Ok(FieldType::I64),\n                    \"U8\" => Ok(FieldType::U8),\n                    \"U16\" => Ok(FieldType::U16),\n                    \"U32\" => Ok(FieldType::U32),\n                    \"U64\" => Ok(FieldType::U64),\n                    \"U128\" => Ok(FieldType::U128),\n                    other => Err(ParserError::from(format!(\n                        \"Unknown named type: {}\",\n                        other\n                    ))),\n                }\n            }\n            Rule::array => {\n                Ok(FieldType::Array(Box::new(self.parse_field_type(\n                    // unwraps the array type because grammar type is\n                    // { array { param_type { array | object | named_type } } }\n                    field.try_inner_next().try_inner_next()?,\n                    _schema,\n                )?)))\n            }\n            Rule::object => {\n                let mut fields = HashMap::new();\n                for field in field.try_inner_next()?.into_inner() {\n                    let (field_name, field_type) = {\n                        let mut field_pair = field.clone().into_inner();\n                        (\n                            field_pair.try_next()?.as_str().to_string(),\n                            field_pair.try_next_inner().try_next()?,\n                        )\n                    };\n                    let field_type = self.parse_field_type(field_type, Some(&self.source))?;\n                    fields.insert(field_name, field_type);\n                }\n                Ok(FieldType::Object(fields))\n            }\n            Rule::identifier => Ok(FieldType::Identifier(field.as_str().to_string())),\n            Rule::ID_TYPE => Ok(FieldType::Uuid),\n            Rule::date_type => Ok(FieldType::Date),\n            other => Err(ParserError::from(format!(\n                \"Unexpected rule in parse_field_type: {:?}\",\n                other\n            ))),\n        }\n    }\n\n    pub(super) fn parse_field_def(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<Field, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        // structure is index? ~ identifier ~ \":\" ~ param_type\n        let prefix: FieldPrefix = match pairs.clone().try_next()?.as_rule() {\n            Rule::index => {\n                pairs.try_next()?;\n                FieldPrefix::Index\n            }\n            // Rule::optional => {\n            //     pairs.next().unwrap();\n            //     FieldPrefix::Optional\n            // }\n            _ => FieldPrefix::Empty,\n        };\n        let name = pairs.try_next()?.as_str().to_string();\n\n        let field_type =\n            self.parse_field_type(pairs.try_next_inner().try_next()?, Some(&self.source))?;\n\n        let defaults = self.parse_default_value(&mut pairs, &field_type)?;\n\n        Ok(Field {\n            prefix,\n            defaults,\n            name,\n            field_type,\n            loc: pair.loc_with_filepath(filepath),\n        })\n    }\n\n    pub(super) fn parse_edge_def(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<EdgeSchema, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let name = pairs.try_next()?.as_str().to_string();\n        let body = pairs.try_next()?;\n        let mut body_pairs = body.into_inner();\n\n        let from = {\n            let pair = body_pairs.try_next()?;\n            (pair.loc(), pair.as_str().to_string())\n        };\n        let to = {\n            let pair = body_pairs.try_next()?;\n            (pair.loc(), pair.as_str().to_string())\n        };\n        let properties = match body_pairs.next() {\n            Some(pair) => Some(self.parse_properties(pair, filepath.clone())?),\n            None => None,\n        };\n\n        Ok(EdgeSchema {\n            name: (pair.loc_with_filepath(filepath.clone()), name),\n            from,\n            to,\n            properties,\n            loc: pair.loc_with_filepath(filepath),\n        })\n    }\n    pub(super) fn parse_properties(\n        &self,\n        pair: Pair<Rule>,\n        filepath: String,\n    ) -> Result<Vec<Field>, ParserError> {\n        pair.into_inner()\n            .find(|p| p.as_rule() == Rule::field_defs)\n            .map_or(Ok(Vec::new()), |field_defs| {\n                field_defs\n                    .into_inner()\n                    .map(|p| self.parse_field_def(p, filepath.clone()))\n                    .collect::<Result<Vec<_>, _>>()\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::helixc::parser::{write_to_temp_file, HelixParser};\n\n    // ============================================================================\n    // Node Definition Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_basic_547": {
      "name": "test_parse_node_definition_basic",
      "type": "method",
      "start_line": 547,
      "end_line": 569,
      "content_hash": "d4e677786e274da063a916bc7001c584dcd1f1fc",
      "content": "    fn test_parse_node_definition_basic() {\n        let source = r#\"\n            N::Person {\n                name: String,\n                age: U32\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        assert_eq!(parsed.schema.len(), 1);\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas.len(), 1);\n        assert_eq!(schema.node_schemas[0].name.1, \"Person\");\n        assert_eq!(schema.node_schemas[0].fields.len(), 2);\n        assert_eq!(schema.node_schemas[0].fields[0].name, \"name\");\n        assert_eq!(schema.node_schemas[0].fields[1].name, \"age\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_with_index_570": {
      "name": "test_parse_node_definition_with_index",
      "type": "method",
      "start_line": 570,
      "end_line": 588,
      "content_hash": "52ca5ee5e172b5df62ac8e0b7c141bf5bc8658fc",
      "content": "    fn test_parse_node_definition_with_index() {\n        let source = r#\"\n            N::Person {\n                INDEX email: String,\n                name: String\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert!(matches!(schema.node_schemas[0].fields[0].prefix, FieldPrefix::Index));\n        assert!(matches!(schema.node_schemas[0].fields[1].prefix, FieldPrefix::Empty));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_all_types_589": {
      "name": "test_parse_node_definition_all_types",
      "type": "method",
      "start_line": 589,
      "end_line": 617,
      "content_hash": "ec2fd9e42a988ec0109adda6878b6560270a6b61",
      "content": "    fn test_parse_node_definition_all_types() {\n        let source = r#\"\n            N::AllTypes {\n                str_field: String,\n                bool_field: Boolean,\n                f32_field: F32,\n                f64_field: F64,\n                i8_field: I8,\n                i16_field: I16,\n                i32_field: I32,\n                i64_field: I64,\n                u8_field: U8,\n                u16_field: U16,\n                u32_field: U32,\n                u64_field: U64,\n                u128_field: U128\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas[0].fields.len(), 13);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_with_default_values_618": {
      "name": "test_parse_node_definition_with_default_values",
      "type": "method",
      "start_line": 618,
      "end_line": 641,
      "content_hash": "7662dde8dfdac818fd23bf23ab8055447a8c22ce",
      "content": "    fn test_parse_node_definition_with_default_values() {\n        let source = r#\"\n            N::Person {\n                name: String DEFAULT \"Unknown\",\n                age: U32 DEFAULT 0,\n                active: Boolean DEFAULT true,\n                score: F64 DEFAULT 0.0\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas[0].fields.len(), 4);\n        assert!(schema.node_schemas[0].fields[0].defaults.is_some());\n        assert!(schema.node_schemas[0].fields[1].defaults.is_some());\n        assert!(schema.node_schemas[0].fields[2].defaults.is_some());\n        assert!(schema.node_schemas[0].fields[3].defaults.is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_array_type_642": {
      "name": "test_parse_node_definition_array_type",
      "type": "method",
      "start_line": 642,
      "end_line": 661,
      "content_hash": "921e5de6103267d82f04a53a97d277eab1a5d283",
      "content": "    fn test_parse_node_definition_array_type() {\n        let source = r#\"\n            N::Person {\n                tags: [String],\n                scores: [I32]\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas[0].fields.len(), 2);\n        assert!(matches!(schema.node_schemas[0].fields[0].field_type, FieldType::Array(_)));\n        assert!(matches!(schema.node_schemas[0].fields[1].field_type, FieldType::Array(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_object_type_662": {
      "name": "test_parse_node_definition_object_type",
      "type": "method",
      "start_line": 662,
      "end_line": 679,
      "content_hash": "edc16f1d6275fc76be3756a468576c75a101c3f7",
      "content": "    fn test_parse_node_definition_object_type() {\n        let source = r#\"\n            N::Person {\n                address: { street: String, city: String, zip: U32 }\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas[0].fields.len(), 1);\n        assert!(matches!(schema.node_schemas[0].fields[0].field_type, FieldType::Object(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_empty_body_680": {
      "name": "test_parse_node_definition_empty_body",
      "type": "method",
      "start_line": 680,
      "end_line": 694,
      "content_hash": "a6f817d60531a3ac4f44cc4ea3d66bed36329b83",
      "content": "    fn test_parse_node_definition_empty_body() {\n        let source = r#\"\n            N::EmptyNode {}\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas[0].fields.len(), 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_invalid_syntax_missing_colon_695": {
      "name": "test_parse_node_definition_invalid_syntax_missing_colon",
      "type": "method",
      "start_line": 695,
      "end_line": 707,
      "content_hash": "29a92d42a24d3538fc5296b889734e86efa37d4d",
      "content": "    fn test_parse_node_definition_invalid_syntax_missing_colon() {\n        let source = r#\"\n            N::Person {\n                name String\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_invalid_syntax_missing_brace_708": {
      "name": "test_parse_node_definition_invalid_syntax_missing_brace",
      "type": "method",
      "start_line": 708,
      "end_line": 719,
      "content_hash": "31d97f595301310f88098e83069702da368aa0e2",
      "content": "    fn test_parse_node_definition_invalid_syntax_missing_brace() {\n        let source = r#\"\n            N::Person {\n                name: String\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_node_definition_invalid_type_720": {
      "name": "test_parse_node_definition_invalid_type",
      "type": "method",
      "start_line": 720,
      "end_line": 738,
      "content_hash": "77357482b1dd616cf3ce05183d5fff2fecd9ab9a",
      "content": "    fn test_parse_node_definition_invalid_type() {\n        let source = r#\"\n            N::Person {\n                name: InvalidType\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        // Note: This may succeed parsing but fail during analysis\n        // The parser allows custom types that get validated later\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Edge Definition Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_edge_definition_basic_739": {
      "name": "test_parse_edge_definition_basic",
      "type": "method",
      "start_line": 739,
      "end_line": 762,
      "content_hash": "9fb4c70d4110cf56c514002b619fdf41f89cc2aa",
      "content": "    fn test_parse_edge_definition_basic() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n\n            E::WorksAt {\n                From: Person,\n                To: Company\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.edge_schemas.len(), 1);\n        assert_eq!(schema.edge_schemas[0].name.1, \"WorksAt\");\n        assert_eq!(schema.edge_schemas[0].from.1, \"Person\");\n        assert_eq!(schema.edge_schemas[0].to.1, \"Company\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_edge_definition_with_properties_763": {
      "name": "test_parse_edge_definition_with_properties",
      "type": "method",
      "start_line": 763,
      "end_line": 789,
      "content_hash": "74b13d9e00df0439e63c58444fb99c852225e4c0",
      "content": "    fn test_parse_edge_definition_with_properties() {\n        let source = r#\"\n            N::Person { name: String }\n\n            E::Knows {\n                From: Person,\n                To: Person,\n                Properties: {\n                    since: String,\n                    strength: F64\n                }\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.edge_schemas.len(), 1);\n        assert!(schema.edge_schemas[0].properties.is_some());\n        let props = schema.edge_schemas[0].properties.as_ref().unwrap();\n        assert_eq!(props.len(), 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_edge_definition_self_referential_790": {
      "name": "test_parse_edge_definition_self_referential",
      "type": "method",
      "start_line": 790,
      "end_line": 810,
      "content_hash": "78b94bbf2cfc85eba6e8071c3918d26653433e7b",
      "content": "    fn test_parse_edge_definition_self_referential() {\n        let source = r#\"\n            N::Person { name: String }\n\n            E::Knows {\n                From: Person,\n                To: Person\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.edge_schemas[0].from.1, \"Person\");\n        assert_eq!(schema.edge_schemas[0].to.1, \"Person\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_edge_definition_invalid_missing_from_to_811": {
      "name": "test_parse_edge_definition_invalid_missing_from_to",
      "type": "method",
      "start_line": 811,
      "end_line": 829,
      "content_hash": "a6fa0ea08415c3b1ff94ad9cd4c2492739c28149",
      "content": "    fn test_parse_edge_definition_invalid_missing_from_to() {\n        let source = r#\"\n            N::Person { name: String }\n\n            E::Knows {\n                Person, Person\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // Vector Definition Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_vector_definition_830": {
      "name": "test_parse_vector_definition",
      "type": "method",
      "start_line": 830,
      "end_line": 853,
      "content_hash": "aea2292d154f7fd5fbfef00a919694fa4072b0f8",
      "content": "    fn test_parse_vector_definition() {\n        let source = r#\"\n            V::Document {\n                content: String,\n                embedding: [F32]\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.vector_schemas.len(), 1);\n        assert_eq!(schema.vector_schemas[0].name, \"Document\");\n        assert_eq!(schema.vector_schemas[0].fields.len(), 2);\n    }\n\n    // ============================================================================\n    // Multiple Schemas Test\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_multiple_nodes_854": {
      "name": "test_parse_multiple_nodes",
      "type": "method",
      "start_line": 854,
      "end_line": 870,
      "content_hash": "e8149e1fdd44aec9832692a86dcce85cba3f4e77",
      "content": "    fn test_parse_multiple_nodes() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            N::Location { city: String }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.node_schemas.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_multiple_edges_871": {
      "name": "test_parse_multiple_edges",
      "type": "method",
      "start_line": 871,
      "end_line": 893,
      "content_hash": "7571982b7f4a4cdaf81f8ff1d8ecc5b585618332",
      "content": "    fn test_parse_multiple_edges() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n\n            E::WorksAt { From: Person, To: Company }\n            E::Manages { From: Person, To: Person }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert_eq!(schema.edge_schemas.len(), 2);\n    }\n\n    // ============================================================================\n    // Schema Versioning Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_schema_with_version_894": {
      "name": "test_parse_schema_with_version",
      "type": "method",
      "start_line": 894,
      "end_line": 910,
      "content_hash": "7fd884c7176f51262dba230dc3c17f63d3075525",
      "content": "    fn test_parse_schema_with_version() {\n        let source = r#\"\n            schema::2 {\n                N::Person { name: String }\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        assert!(parsed.schema.contains_key(&2));\n        assert_eq!(parsed.schema.get(&2).unwrap().node_schemas.len(), 1);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_schema_default_version_911": {
      "name": "test_parse_schema_default_version",
      "type": "method",
      "start_line": 911,
      "end_line": 928,
      "content_hash": "d1ed973fd637d60d12876fdafff912f8a89f44b5",
      "content": "    fn test_parse_schema_default_version() {\n        let source = r#\"\n            N::Person { name: String }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        assert!(parsed.schema.contains_key(&1));\n    }\n\n    // ============================================================================\n    // Edge Cases and Whitespace Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_with_extra_whitespace_929": {
      "name": "test_parse_with_extra_whitespace",
      "type": "method",
      "start_line": 929,
      "end_line": 942,
      "content_hash": "82e0ee5b6a6c601471915db6485321135471c04e",
      "content": "    fn test_parse_with_extra_whitespace() {\n        let source = r#\"\n            N::Person    {\n                name   :   String   ,\n                age    :   U32\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_with_trailing_comma_943": {
      "name": "test_parse_with_trailing_comma",
      "type": "method",
      "start_line": 943,
      "end_line": 956,
      "content_hash": "63243fec197c89ebc76131629a9687a7c5f8898a",
      "content": "    fn test_parse_with_trailing_comma() {\n        let source = r#\"\n            N::Person {\n                name: String,\n                age: U32,\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_compact_format_957": {
      "name": "test_parse_compact_format",
      "type": "method",
      "start_line": 957,
      "end_line": 969,
      "content_hash": "3964f75d048b4352cb64c4de374faeb24f2cf028",
      "content": "    fn test_parse_compact_format() {\n        let source = r#\"N::Person{name:String,age:U32}\"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Complex Nested Structure Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_nested_arrays_970": {
      "name": "test_parse_nested_arrays",
      "type": "method",
      "start_line": 970,
      "end_line": 986,
      "content_hash": "bfefdb0a56fedeb7dd338de087cd2ff2041ab7c7",
      "content": "    fn test_parse_nested_arrays() {\n        let source = r#\"\n            N::Data {\n                matrix: [[I32]]\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert!(matches!(schema.node_schemas[0].fields[0].field_type, FieldType::Array(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_nested_objects_987": {
      "name": "test_parse_nested_objects",
      "type": "method",
      "start_line": 987,
      "end_line": 1002,
      "content_hash": "5744ed339a965e942c57206580c38870fe67015e",
      "content": "    fn test_parse_nested_objects() {\n        let source = r#\"\n            N::Person {\n                address: {\n                    home: { street: String, city: String },\n                    work: { street: String, city: String }\n                }\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_array_of_objects_1003": {
      "name": "test_parse_array_of_objects",
      "type": "method",
      "start_line": 1003,
      "end_line": 1019,
      "content_hash": "b1fef818f000f2d166a06082aa4cba66fb0d8993",
      "content": "    fn test_parse_array_of_objects() {\n        let source = r#\"\n            N::Company {\n                employees: [{ name: String, role: String }]\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Default Value Edge Cases\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_default_now_1020": {
      "name": "test_parse_default_now",
      "type": "method",
      "start_line": 1020,
      "end_line": 1039,
      "content_hash": "a70e2f42929079fe791b347208d0d50a68ff398e",
      "content": "    fn test_parse_default_now() {\n        let source = r#\"\n            N::Event {\n                created_at: String DEFAULT NOW\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        let schema = parsed.schema.get(&1).unwrap();\n        assert!(matches!(\n            schema.node_schemas[0].fields[0].defaults,\n            Some(DefaultValue::Now)\n        ));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_default_various_numeric_types_1040": {
      "name": "test_parse_default_various_numeric_types",
      "type": "method",
      "start_line": 1040,
      "end_line": 1065,
      "content_hash": "aed46bb87b41fd93b83b0fb27cec224108e49326",
      "content": "    fn test_parse_default_various_numeric_types() {\n        let source = r#\"\n            N::Config {\n                i8_val: I8 DEFAULT 127,\n                i16_val: I16 DEFAULT 32767,\n                i32_val: I32 DEFAULT 2147483647,\n                i64_val: I64 DEFAULT 9223372036854775807,\n                u8_val: U8 DEFAULT 255,\n                u16_val: U16 DEFAULT 65535,\n                u32_val: U32 DEFAULT 4294967295,\n                u64_val: U64 DEFAULT 18446744073709551615,\n                f32_val: F32 DEFAULT 3.14,\n                f64_val: F64 DEFAULT 2.718281828\n            }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Error Message Quality Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_error_message_contains_context_1066": {
      "name": "test_parse_error_message_contains_context",
      "type": "method",
      "start_line": 1066,
      "end_line": 1081,
      "content_hash": "f9d38120683a3242b8a38526ff99356461dab170",
      "content": "    fn test_parse_error_message_contains_context() {\n        let source = r#\"\n            N::Person { invalid }\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_err());\n\n        let err = result.unwrap_err();\n        let err_string = err.to_string();\n        // Error should provide helpful context\n        assert!(!err_string.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_empty_input_1082": {
      "name": "test_parse_empty_input",
      "type": "method",
      "start_line": 1082,
      "end_line": 1092,
      "content_hash": "e1618e8b868b23d112f8196feaa70154af39e547",
      "content": "    fn test_parse_empty_input() {\n        let source = \"\";\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n\n        let parsed = result.unwrap();\n        assert_eq!(parsed.schema.len(), 0);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}