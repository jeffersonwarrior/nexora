{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/tests/compile_tests.rs",
  "file_hash": "be00fc09b7e8a090477246f6998cdcc4c83522f3",
  "updated_at": "2025-12-26T17:34:20.598080",
  "symbols": {
    "function_setup_compile_project_8": {
      "name": "setup_compile_project",
      "type": "function",
      "start_line": 8,
      "end_line": 406,
      "content_hash": "8079b3df89009220c21fd80248adcdc60b4c3fca",
      "content": "fn setup_compile_project() -> (TempDir, PathBuf) {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create valid schema.hx\n    let schema_content = r#\"\nN::User {\n    name: String,\n    email: String,\n}\n\nN::Post {\n    title: String,\n    content: String,\n}\n\nE::Authored {\n    From: User,\n    To: Post,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create valid queries.hx\n    let queries_content = r#\"\nQUERY GetUser(user_id: ID) =>\n    user <- N<User>(user_id)\n    RETURN user\n\nQUERY GetUserPosts(user_id: ID) =>\n    posts <- N<User>(user_id)::Out<Authored>\n    RETURN posts\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries_content)\n        .expect(\"Failed to write queries.hx\");\n\n    (temp_dir, project_path)\n}\n\n#[tokio::test]\nasync fn test_compile_success() {\n    let (_temp_dir, project_path) = setup_compile_project();\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should succeed with valid project: {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created\n    let queries_file = project_path.join(\"queries.rs\");\n    assert!(\n        queries_file.exists(),\n        \"Compiled queries.rs should be created\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_with_custom_output_path() {\n    let (_temp_dir, project_path) = setup_compile_project();\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let output_dir = project_path.join(\"custom_output\");\n    fs::create_dir_all(&output_dir).expect(\"Failed to create custom output dir\");\n\n    let result = run(Some(output_dir.to_str().unwrap().to_string()), None).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should succeed with custom output path: {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created in custom location\n    let query_file = output_dir.join(\"queries.rs\");\n    assert!(\n        query_file.exists(),\n        \"Compiled queries.rs should be created in custom output directory\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_with_explicit_project_path() {\n    let (_temp_dir, project_path) = setup_compile_project();\n\n    let result = run(None, Some(project_path.to_str().unwrap().to_string())).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should succeed with explicit project path: {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created\n    let query_file = project_path.join(\"queries.rs\");\n    assert!(\n        query_file.exists(),\n        \"Compiled queries.rs should be created\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_fails_without_schema() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory with only queries, no schema\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    let queries_content = r#\"\nQUERY GetUser(user_id: ID) =>\n    user <- N<User>(user_id)\n    RETURN user\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries_content)\n        .expect(\"Failed to write queries.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(result.is_err(), \"Compile should fail without schema\");\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"schema\") || error_msg.contains(\"N::\") || error_msg.contains(\"E::\"),\n        \"Error should mention missing schema definitions\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_fails_with_invalid_syntax() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create schema\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create queries with invalid syntax\n    let invalid_queries = r#\"\nQUERY InvalidQuery\n    this is not valid helix syntax!!!\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), invalid_queries)\n        .expect(\"Failed to write queries.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(result.is_err(), \"Compile should fail with invalid syntax\");\n}\n\n#[tokio::test]\nasync fn test_compile_fails_without_helix_toml() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(\n        result.is_err(),\n        \"Compile should fail without helix.toml in project\"\n    );\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"not found\") || error_msg.contains(\"helix.toml\"),\n        \"Error should mention missing helix.toml\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_with_schema_only() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory with only schema\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    let schema_content = r#\"\nN::User {\n    name: String,\n    email: String,\n}\n\nE::Follows {\n    From: User,\n    To: User,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should succeed with schema only (queries are optional): {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created\n    let query_file = project_path.join(\"queries.rs\");\n    assert!(\n        query_file.exists(),\n        \"Compiled queries.rs should be created even with schema only\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_with_multiple_hx_files() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create schema in one file\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create additional schema in another file\n    let more_schema = r#\"\nN::Post {\n    title: String,\n}\n\nE::Authored {\n    From: User,\n    To: Post,\n}\n\"#;\n    fs::write(queries_dir.join(\"more_schema.hx\"), more_schema)\n        .expect(\"Failed to write more_schema.hx\");\n\n    // Create queries in yet another file\n    let queries = r#\"\nQUERY GetUser(id: ID) =>\n    user <- N<User>(id)\n    RETURN user\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries).expect(\"Failed to write queries.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should succeed with multiple .hx files: {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created\n    let query_file = project_path.join(\"queries.rs\");\n    assert!(\n        query_file.exists(),\n        \"Compiled queries.rs should be created\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_with_custom_queries_path() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml with custom queries path\n    let mut config = HelixConfig::default_config(\"test-project\");\n    config.project.queries = PathBuf::from(\"custom/helix/queries\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create custom queries directory\n    let queries_dir = project_path.join(\"custom/helix/queries\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create custom queries directory\");\n\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(\n        result.is_ok(),\n        \"Compile should work with custom queries path: {:?}\",\n        result.err()\n    );\n\n    // Check that compiled output files were created\n    let query_file = project_path.join(\"queries.rs\");\n    assert!(\n        query_file.exists(),\n        \"Compiled queries.rs should be created\"\n    );\n}\n\n#[tokio::test]\nasync fn test_compile_creates_all_required_files() {\n    let (_temp_dir, project_path) = setup_compile_project();\n    let _guard = std::env::set_current_dir(&project_path);\n\n    let result = run(None, None).await;\n    assert!(result.is_ok(), \"Compile should succeed\");\n\n    // Check for common generated files\n    let query_file = project_path.join(\"queries.rs\");\n    assert!(query_file.exists(), \"queries.rs should be created\");\n\n    // Verify the generated file has content\n    let query_content = fs::read_to_string(&query_file).expect(\"Failed to read queries.rs\");\n    assert!(\n        !query_content.is_empty(),\n        \"Generated queries.rs should not be empty\"\n    );\n    assert!(\n        query_content.contains(\"pub\") || query_content.contains(\"use\") || query_content.contains(\"impl\"),\n        \"Generated queries.rs should contain Rust code\"\n    );\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}