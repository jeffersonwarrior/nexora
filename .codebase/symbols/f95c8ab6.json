{
  "file_path": "/work/.local/tools/modelscan/cmd/demo/main.go",
  "file_hash": "3f0065177fedf66e696575d46cb8de183aec34ec",
  "updated_at": "2025-12-26T17:34:22.359542",
  "symbols": {
    "function_main_15": {
      "name": "main",
      "type": "function",
      "start_line": 15,
      "end_line": 230,
      "content_hash": "e027b8e8e2f6410300871f814e705cf16e305003",
      "content": "func main() {\n\t// Initialize database\n\tif err := storage.InitRateLimitDB(\"./rate_limits.db\"); err != nil {\n\t\tlog.Fatalf(\"Failed to initialize database: %v\", err)\n\t}\n\tdefer storage.CloseRateLimitDB()\n\n\tctx := context.Background()\n\n\tfmt.Println(\"\ud83d\ude80 ModelScan Tier 0 Demo - Rate Limiting + Routing + Streaming\")\n\tfmt.Println(\"=\" + strings.Repeat(\"=\", 70))\n\tfmt.Println()\n\n\t// Demo 1: Rate Limiting\n\tfmt.Println(\"\ud83d\udcca DEMO 1: Token Bucket Rate Limiting\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\n\tlimiter, err := ratelimit.NewRateLimiter(\"openai\", \"tier-1\")\n\tif err != nil {\n\t\tlog.Printf(\"Rate limiter error: %v\", err)\n\t} else {\n\t\tinfo := limiter.GetRateLimitInfo()\n\t\tfmt.Printf(\"OpenAI Tier 1 Limits:\\n\")\n\t\tfor limitType, details := range info {\n\t\t\tcapacity := details[\"capacity\"]\n\t\t\tavailable := details[\"available\"]\n\t\t\trefill := details[\"refill\"]\n\t\t\tinterval := details[\"interval\"]\n\t\t\tfmt.Printf(\"  \u2022 %s: %v/%v available (refills %v every %s)\\n\",\n\t\t\t\tlimitType, available, capacity, refill, interval)\n\t\t}\n\n\t\t// Simulate acquiring tokens\n\t\tif err := limiter.Acquire(ctx, \"rpm\", 1); err != nil {\n\t\t\tfmt.Printf(\"  \u274c Rate limit exceeded: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"  \u2705 Acquired 1 RPM token\\n\")\n\t\t}\n\n\t\ttokens := ratelimit.EstimateTokens(\"Write a hello world program in Go\")\n\t\tif err := limiter.Acquire(ctx, \"tpm\", tokens); err != nil {\n\t\t\tfmt.Printf(\"  \u274c Token limit exceeded: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"  \u2705 Acquired %d TPM tokens\\n\", tokens)\n\t\t}\n\t}\n\tfmt.Println()\n\n\t// Demo 2: Intelligent Routing\n\tfmt.Println(\"\ud83e\udde0 DEMO 2: Intelligent Provider Routing\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\n\t// Test each routing strategy\n\tstrategies := []struct {\n\t\tname     string\n\t\tstrategy router.RoutingStrategy\n\t}{\n\t\t{\"Cheapest\", router.StrategyCheapest},\n\t\t{\"Fastest\", router.StrategyFastest},\n\t\t{\"Balanced\", router.StrategyBalanced},\n\t}\n\n\tfor _, s := range strategies {\n\t\tr := router.NewRouter(s.strategy)\n\n\t\t// Simulate some health data\n\t\tr.RecordSuccess(\"groq\", 50)\n\t\tr.RecordSuccess(\"openai\", 200)\n\t\tr.RecordSuccess(\"deepseek\", 400)\n\n\t\tresult, err := r.Route(ctx, router.RouteRequest{\n\t\t\tCapability:      \"chat\",\n\t\t\tEstimatedTokens: 1000,\n\t\t\tMaxCost:         0.01,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"  %s Strategy: \u274c %v\\n\", s.name, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"  %s Strategy: %s at $%.6f (%s)\\n\",\n\t\t\t\ts.name,\n\t\t\t\tresult.Provider.ProviderName,\n\t\t\t\tresult.EstimatedCost,\n\t\t\t\tresult.Reason,\n\t\t\t)\n\t\t}\n\t}\n\tfmt.Println()\n\n\t// Demo 3: Streaming\n\tfmt.Println(\"\ud83d\udce1 DEMO 3: Unified Streaming API\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\n\t// Simulate SSE stream from OpenAI\n\tsseData := `data: {\"choices\":[{\"delta\":{\"content\":\"Hello\"}}]}\n\ndata: {\"choices\":[{\"delta\":{\"content\":\" from\"}}]}\n\ndata: {\"choices\":[{\"delta\":{\"content\":\" ModelScan!\"}}]}\n\ndata: [DONE]\n\n`\n\treader := strings.NewReader(sseData)\n\tstreamObj := stream.NewStream(ctx, reader, stream.StreamTypeSSE)\n\tdefer streamObj.Close()\n\n\tfmt.Println(\"  Streaming response (OpenAI SSE format):\")\n\tvar collected strings.Builder\n\tchunkCount := 0\n\tfor chunk := range streamObj.Chunks() {\n\t\tif chunk.Type == stream.ChunkTypeDone {\n\t\t\tfmt.Println(\"\\n  \u2705 Stream complete\")\n\t\t\tbreak\n\t\t}\n\t\tif chunk.Data != \"\" {\n\t\t\tfmt.Printf(\"    Chunk %d: \\\"%s\\\"\\n\", chunkCount+1, chunk.Data)\n\t\t\tcollected.WriteString(chunk.Data)\n\t\t\tchunkCount++\n\t\t}\n\t}\n\tfmt.Printf(\"  Full text: \\\"%s\\\"\\n\", collected.String())\n\tfmt.Println()\n\n\t// Demo 4: Stream Operators\n\tfmt.Println(\"\ud83d\udd27 DEMO 4: Stream Operators (Filter, Map, Tap)\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\n\tsseData2 := `data: {\"content\":\"hello\"}\n\ndata: {\"content\":\" world\"}\n\ndata: {\"content\":\"!\"}\n\ndata: [DONE]\n\n`\n\treader2 := strings.NewReader(sseData2)\n\tstreamObj2 := stream.NewStream(ctx, reader2, stream.StreamTypeSSE)\n\tdefer streamObj2.Close()\n\n\tvar tapped []string\n\tprocessed := streamObj2.\n\t\tFilter(func(c *stream.Chunk) bool {\n\t\t\t// Filter out chunks less than 2 chars\n\t\t\treturn len(c.Data) >= 2\n\t\t}).\n\t\tMap(func(c *stream.Chunk) *stream.Chunk {\n\t\t\t// Convert to uppercase\n\t\t\tif c.Type == stream.ChunkTypeData {\n\t\t\t\tc.Data = strings.ToUpper(c.Data)\n\t\t\t}\n\t\t\treturn c\n\t\t}).\n\t\tTap(func(c *stream.Chunk) {\n\t\t\t// Observe without modifying\n\t\t\tif c.Type == stream.ChunkTypeData {\n\t\t\t\ttapped = append(tapped, c.Data)\n\t\t\t}\n\t\t})\n\n\tvar result strings.Builder\n\tfor chunk := range processed.Chunks() {\n\t\tif chunk.Type == stream.ChunkTypeDone {\n\t\t\tbreak\n\t\t}\n\t\tresult.WriteString(chunk.Data)\n\t}\n\n\tfmt.Printf(\"  Original: \\\"hello world!\\\"\\n\")\n\tfmt.Printf(\"  Filtered: (removed \\\"!\\\")\\n\")\n\tfmt.Printf(\"  Mapped:   \\\"%s\\\"\\n\", result.String())\n\tfmt.Printf(\"  Tapped:   %v\\n\", tapped)\n\tfmt.Println()\n\n\t// Demo 5: Health Tracking\n\tfmt.Println(\"\ud83d\udc9a DEMO 5: Provider Health Tracking\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\n\thealthRouter := router.NewRouter(router.StrategyFallback)\n\n\t// Simulate provider behavior\n\thealthRouter.RecordSuccess(\"openai\", 150)\n\thealthRouter.RecordSuccess(\"openai\", 180)\n\thealthRouter.RecordFailure(\"anthropic\", nil)\n\thealthRouter.RecordFailure(\"anthropic\", nil)\n\thealthRouter.RecordFailure(\"anthropic\", nil) // 3 failures = unhealthy\n\n\thealthStatus := healthRouter.GetHealthStatus()\n\tfor provider, health := range healthStatus {\n\t\tstatus := \"\u2705 Healthy\"\n\t\tif !health.IsHealthy {\n\t\t\tstatus = \"\u274c Unhealthy\"\n\t\t}\n\t\tfmt.Printf(\"  %s: %s (latency: %dms, fails: %d, error rate: %.1f%%)\\n\",\n\t\t\tprovider,\n\t\t\tstatus,\n\t\t\thealth.AvgLatencyMs,\n\t\t\thealth.ConsecutiveFails,\n\t\t\thealth.ErrorRate*100,\n\t\t)\n\t}\n\tfmt.Println()\n\n\t// Summary\n\tfmt.Println(\"\u2728 SUMMARY\")\n\tfmt.Println(\"-\" + strings.Repeat(\"-\", 70))\n\tfmt.Println(\"  \u2705 Rate Limiting: Token bucket with RPM + TPM coordination\")\n\tfmt.Println(\"  \u2705 Routing: 5 strategies (cheapest, fastest, balanced, round-robin, fallback)\")\n\tfmt.Println(\"  \u2705 Streaming: Unified API for SSE, WebSocket, HTTP chunked\")\n\tfmt.Println(\"  \u2705 Operators: Filter, Map, Tap, Collect\")\n\tfmt.Println(\"  \u2705 Health: Exponential moving average + automatic failover\")\n\tfmt.Println(\"  \u2705 Providers: 15 seeded (50 rate limits, 19 pricing entries)\")\n\tfmt.Println()\n\tfmt.Println(\"\ud83d\udce6 Tier 0 Foundation: COMPLETE (52/52 tests passing)\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}