{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/tests/mcp_tests.rs",
  "file_hash": "4ecfbfe64704d8247528101ed41283aee7c1e0eb",
  "updated_at": "2025-12-26T17:34:22.069653",
  "symbols": {
    "function_setup_engine_30": {
      "name": "setup_engine",
      "type": "function",
      "start_line": 30,
      "end_line": 41,
      "content_hash": "103e890d88c7b44a1e7c02842494774dc0cb8157",
      "content": "    fn setup_engine() -> (HelixGraphEngine, TempDir) {\n        let temp_dir = TempDir::new().unwrap();\n        let opts = HelixGraphEngineOpts {\n            path: temp_dir.path().to_str().unwrap().to_string(),\n            config: Config::default(),\n            version_info: VersionInfo::default(),\n        };\n        let engine = HelixGraphEngine::new(opts).unwrap();\n        (engine, temp_dir)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_execute_query_chain_out_step_returns_neighbor_42": {
      "name": "execute_query_chain_out_step_returns_neighbor",
      "type": "function",
      "start_line": 42,
      "end_line": 109,
      "content_hash": "eeef259b9d623ff42be6b510d91544723e3fa287",
      "content": "    fn execute_query_chain_out_step_returns_neighbor() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"name\", Value::from(\"John\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::FilterItems {\n                filter: FilterTraversal {\n                    properties: Some(vec![vec![FilterProperties {\n                        key: \"name\".to_string(),\n                        value: Value::from(\"John\"),\n                        operator: Some(Operator::Eq),\n                    }]]),\n                    filter_traversals: None,\n                },\n            },\n            ToolArgs::OutStep {\n                edge_label: \"knows\".to_string(),\n                edge_type: EdgeType::Node,\n                filter: None,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n\n        assert_eq!(results.len(), 1);\n        let TraversalValue::Node(node) = &results[0] else {\n            panic!(\"expected node result\");\n        };\n        assert_eq!(node.id, person2.id());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_mcp_connection_next_advances_position_110": {
      "name": "mcp_connection_next_advances_position",
      "type": "function",
      "start_line": 110,
      "end_line": 148,
      "content_hash": "1a5fd92991dc5f85fdfeb3670a0e473d5f0e13ba",
      "content": "    fn mcp_connection_next_advances_position() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let _ = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n        let _ = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n\n        let mut connection = MCPConnection::new(\"test\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n\n        let first = connection.next_item(storage, &arena).unwrap();\n        assert!(!matches!(\n            first,\n            crate::helix_engine::traversal_core::traversal_value::TraversalValue::Empty\n        ));\n\n        let second = connection.next_item(storage, &arena).unwrap();\n        assert!(!matches!(\n            second,\n            crate::helix_engine::traversal_core::traversal_value::TraversalValue::Empty\n        ));\n\n        assert_eq!(connection.current_position, 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_collect_handler_respects_range_149": {
      "name": "collect_handler_respects_range",
      "type": "function",
      "start_line": 149,
      "end_line": 203,
      "content_hash": "5e0078cec25201956a43aa36a71437a207d8807a",
      "content": "    fn collect_handler_respects_range() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n        for _ in 0..5 {\n            let _ = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n                .add_n(\"person\", None, None)\n                .collect_to_obj()\n                .unwrap();\n        }\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn\",\"range\":{\"start\":1,\"end\":3},\"drop\":false}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"collect\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = collect(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        println!(\"{:?}\", body);\n        let id_count = body.matches(\"\\\"id\\\"\").count();\n        let label_count = body.matches(\"\\\"label\\\"\").count();\n        assert_eq!(id_count, 2);\n        assert_eq!(label_count, 2);\n    }\n\n    // ============================================================================\n    // MCP Handler Registration Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_mcp_handlers_are_registered_204": {
      "name": "test_mcp_handlers_are_registered",
      "type": "function",
      "start_line": 204,
      "end_line": 234,
      "content_hash": "a0c2505cf5d8c24dbcdb2441161036b433ebb28e",
      "content": "    fn test_mcp_handlers_are_registered() {\n        use crate::helix_gateway::mcp::mcp::MCPHandlerSubmission;\n\n        let handler_names: Vec<&str> = inventory::iter::<MCPHandlerSubmission>\n            .into_iter()\n            .map(|submission| submission.0.name)\n            .collect();\n\n        // Core handlers\n        assert!(handler_names.contains(&\"init\"));\n        assert!(handler_names.contains(&\"tool_call\"));\n        assert!(handler_names.contains(&\"next\"));\n        assert!(handler_names.contains(&\"collect\"));\n        assert!(handler_names.contains(&\"aggregate_by\"));\n        assert!(handler_names.contains(&\"group_by\"));\n        assert!(handler_names.contains(&\"reset\"));\n        assert!(handler_names.contains(&\"schema_resource\"));\n\n        // New individual tool handlers\n        assert!(handler_names.contains(&\"out_step\"));\n        assert!(handler_names.contains(&\"in_step\"));\n        assert!(handler_names.contains(&\"out_e_step\"));\n        assert!(handler_names.contains(&\"in_e_step\"));\n        assert!(handler_names.contains(&\"n_from_type\"));\n        assert!(handler_names.contains(&\"e_from_type\"));\n        assert!(handler_names.contains(&\"filter_items\"));\n        assert!(handler_names.contains(&\"order_by\"));\n        assert!(handler_names.contains(&\"search_keyword\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_all_new_tool_endpoints_registered_235": {
      "name": "test_all_new_tool_endpoints_registered",
      "type": "function",
      "start_line": 235,
      "end_line": 268,
      "content_hash": "fdb98e615e1767bb769d1ef74112fae560557ee8",
      "content": "    fn test_all_new_tool_endpoints_registered() {\n        use crate::helix_gateway::mcp::mcp::MCPHandlerSubmission;\n\n        let handler_names: Vec<&str> = inventory::iter::<MCPHandlerSubmission>\n            .into_iter()\n            .map(|submission| submission.0.name)\n            .collect();\n\n        let required_tool_endpoints = vec![\n            \"out_step\",\n            \"in_step\",\n            \"out_e_step\",\n            \"in_e_step\",\n            \"n_from_type\",\n            \"e_from_type\",\n            \"filter_items\",\n            \"order_by\",\n            \"search_keyword\",\n        ];\n\n        for endpoint in required_tool_endpoints {\n            assert!(\n                handler_names.contains(&endpoint),\n                \"MCP endpoint '{}' is not registered\",\n                endpoint\n            );\n        }\n    }\n\n    // ============================================================================\n    // Individual Tool Endpoint HTTP Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_step_handler_http_269": {
      "name": "test_out_step_handler_http",
      "type": "function",
      "start_line": 269,
      "end_line": 346,
      "content_hash": "38162169685f3ede871a47e9a1f9995e9ec4df8f",
      "content": "    fn test_out_step_handler_http() {\n        use crate::helix_gateway::mcp::mcp::out_step;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"name\", Value::from(\"Alice\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn1\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connection.add_query_step(ToolArgs::FilterItems {\n            filter: FilterTraversal {\n                properties: Some(vec![vec![FilterProperties {\n                    key: \"name\".to_string(),\n                    value: Value::from(\"Alice\"),\n                    operator: Some(Operator::Eq),\n                }]]),\n                filter_traversals: None,\n            },\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn1\",\"data\":{\"edge_label\":\"knows\",\"edge_type\":\"node\",\"filter\":null}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"out_step\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = out_step(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        assert!(body.contains(&uuid_str(person2.id(), &arena)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_step_handler_http_347": {
      "name": "test_in_step_handler_http",
      "type": "function",
      "start_line": 347,
      "end_line": 405,
      "content_hash": "4ac8ea7f0f7a40f6de9404df4c3f4096aa40cede",
      "content": "    fn test_in_step_handler_http() {\n        use crate::helix_gateway::mcp::mcp::in_step;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn2\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn2\",\"data\":{\"edge_label\":\"knows\",\"edge_type\":\"node\",\"filter\":null}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"in_step\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = in_step(&mut input).unwrap();\n        assert!(!response.body.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_e_step_handler_http_406": {
      "name": "test_out_e_step_handler_http",
      "type": "function",
      "start_line": 406,
      "end_line": 464,
      "content_hash": "7861e856c7e0597da07639d282810fc3ad9d45a0",
      "content": "    fn test_out_e_step_handler_http() {\n        use crate::helix_gateway::mcp::mcp::out_e_step;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn3\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn3\",\"data\":{\"edge_label\":\"knows\",\"filter\":null}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"out_e_step\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = out_e_step(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        assert!(body.contains(\"\\\"label\\\":\\\"knows\\\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_e_step_handler_http_465": {
      "name": "test_in_e_step_handler_http",
      "type": "function",
      "start_line": 465,
      "end_line": 522,
      "content_hash": "7bd26ca37bdf683fee2831a3ca2cc1346c396547",
      "content": "    fn test_in_e_step_handler_http() {\n        use crate::helix_gateway::mcp::mcp::in_e_step;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn4\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn4\",\"data\":{\"edge_label\":\"knows\",\"filter\":null}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"in_e_step\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = in_e_step(&mut input).unwrap();\n        assert!(!response.body.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_n_from_type_handler_http_523": {
      "name": "test_n_from_type_handler_http",
      "type": "function",
      "start_line": 523,
      "end_line": 569,
      "content_hash": "f27cb5e7aab1c2efb05b698849bdca44392ba56a",
      "content": "    fn test_n_from_type_handler_http() {\n        use crate::helix_gateway::mcp::mcp::n_from_type;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        for _ in 0..3 {\n            G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n                .add_n(\"person\", None, None)\n                .collect_to_obj()\n                .unwrap();\n        }\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn5\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body =\n            Bytes::from(r#\"{\"connection_id\":\"conn5\",\"data\":{\"node_type\":\"person\"}}\"#.to_string());\n\n        let request = Request {\n            name: \"n_from_type\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = n_from_type(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        assert!(body.contains(\"\\\"label\\\":\\\"person\\\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_type_handler_http_570": {
      "name": "test_e_from_type_handler_http",
      "type": "function",
      "start_line": 570,
      "end_line": 624,
      "content_hash": "71ed928a333a104f155279c983d3e5f11779d28c",
      "content": "    fn test_e_from_type_handler_http() {\n        use crate::helix_gateway::mcp::mcp::e_from_type;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn6\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body =\n            Bytes::from(r#\"{\"connection_id\":\"conn6\",\"data\":{\"edge_type\":\"knows\"}}\"#.to_string());\n\n        let request = Request {\n            name: \"e_from_type\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = e_from_type(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        assert!(body.contains(\"\\\"label\\\":\\\"knows\\\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_items_handler_http_625": {
      "name": "test_filter_items_handler_http",
      "type": "function",
      "start_line": 625,
      "end_line": 695,
      "content_hash": "562203237a8067adc3219e1fb6a305bb7f2d469d",
      "content": "    fn test_filter_items_handler_http() {\n        use crate::helix_gateway::mcp::mcp::filter_items;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"age\", Value::from(25))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"age\", Value::from(30))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn7\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn7\",\"data\":{\"filter\":{\"properties\":[[{\"key\":\"age\",\"value\":30,\"operator\":\"==\"}]],\"filter_traversals\":null}}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"filter_items\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = filter_items(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        assert!(body.contains(\"30\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_order_by_handler_http_696": {
      "name": "test_order_by_handler_http",
      "type": "function",
      "start_line": 696,
      "end_line": 770,
      "content_hash": "bee10b1581f02442ef49d849bea0b03919fa1ec7",
      "content": "    fn test_order_by_handler_http() {\n        use crate::helix_gateway::mcp::mcp::order_by;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"age\", Value::from(30))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"age\", Value::from(25))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let mut connection = MCPConnection::new(\"conn8\".to_string());\n        connection.add_query_step(ToolArgs::NFromType {\n            node_type: \"person\".to_string(),\n        });\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn8\",\"data\":{\"properties\":\"age\",\"order\":\"asc\"}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"order_by\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = order_by(&mut input).unwrap();\n        let body = String::from_utf8(response.body.clone()).unwrap();\n        // Verify response contains age property\n        assert!(body.contains(\"25\") || body.contains(\"30\"));\n    }\n\n    // ============================================================================\n    // Integration Tests - Tool Execution Logic\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_step_traversal_integration_771": {
      "name": "test_out_step_traversal_integration",
      "type": "function",
      "start_line": 771,
      "end_line": 865,
      "content_hash": "1f1c8241c48a51a886d5301843b7680502c37efa",
      "content": "    fn test_out_step_traversal_integration() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let alice = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"name\", Value::from(\"Alice\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        let bob = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"name\", Value::from(\"Bob\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        let charlie = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    1,\n                    [(\"name\", Value::from(\"Charlie\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, alice.id(), bob.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, bob.id(), charlie.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::FilterItems {\n                filter: FilterTraversal {\n                    properties: Some(vec![vec![FilterProperties {\n                        key: \"name\".to_string(),\n                        value: Value::from(\"Alice\"),\n                        operator: Some(Operator::Eq),\n                    }]]),\n                    filter_traversals: None,\n                },\n            },\n            ToolArgs::OutStep {\n                edge_label: \"knows\".to_string(),\n                edge_type: EdgeType::Node,\n                filter: None,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert_eq!(results.len(), 1);\n\n        let TraversalValue::Node(node) = &results[0] else {\n            panic!(\"expected node result\");\n        };\n        assert_eq!(node.id, bob.id());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_step_traversal_integration_866": {
      "name": "test_in_step_traversal_integration",
      "type": "function",
      "start_line": 866,
      "end_line": 912,
      "content_hash": "bc1fd9d33d5f268a4f8ad8bbf8539fed89da3566",
      "content": "    fn test_in_step_traversal_integration() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let alice = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let bob = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, alice.id(), bob.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        // Start from Bob and traverse back to Alice via in_step\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::InStep {\n                edge_label: \"knows\".to_string(),\n                edge_type: EdgeType::Node,\n                filter: None,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert!(results.len() > 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_with_multiple_conditions_913": {
      "name": "test_filter_with_multiple_conditions",
      "type": "function",
      "start_line": 913,
      "end_line": 981,
      "content_hash": "0a97484b3da9796d817142705e633208e8e5608d",
      "content": "    fn test_filter_with_multiple_conditions() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    2,\n                    [(\"age\", Value::from(25)), (\"name\", Value::from(\"Alice\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"person\",\n                Some(ImmutablePropertiesMap::new(\n                    2,\n                    [(\"age\", Value::from(30)), (\"name\", Value::from(\"Bob\"))].into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::FilterItems {\n                filter: FilterTraversal {\n                    properties: Some(vec![vec![\n                        FilterProperties {\n                            key: \"age\".to_string(),\n                            value: Value::from(30),\n                            operator: Some(Operator::Eq),\n                        },\n                        FilterProperties {\n                            key: \"name\".to_string(),\n                            value: Value::from(\"Bob\"),\n                            operator: Some(Operator::Eq),\n                        },\n                    ]]),\n                    filter_traversals: None,\n                },\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert_eq!(results.len(), 1);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_order_by_ascending_982": {
      "name": "test_order_by_ascending",
      "type": "function",
      "start_line": 982,
      "end_line": 1033,
      "content_hash": "2260af02c2eb0add905aae20715d4d9c5ce04d73",
      "content": "    fn test_order_by_ascending() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        for age in [30, 20, 25] {\n            G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n                .add_n(\n                    \"person\",\n                    Some(ImmutablePropertiesMap::new(\n                        1,\n                        [(\"age\", Value::from(age))].into_iter(),\n                        &arena,\n                    )),\n                    None,\n                )\n                .collect_to_obj()\n                .unwrap();\n        }\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::OrderBy {\n                properties: \"age\".to_string(),\n                order: crate::helix_gateway::mcp::tools::Order::Asc,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert_eq!(results.len(), 3);\n\n        // Verify ordering\n        let TraversalValue::Node(node1) = &results[0] else {\n            panic!(\"expected node\");\n        };\n        let age1 = node1.get_property(\"age\").unwrap();\n        assert_eq!(age1, &Value::from(20));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_order_by_descending_1034": {
      "name": "test_order_by_descending",
      "type": "function",
      "start_line": 1034,
      "end_line": 1085,
      "content_hash": "aa51ef1b8dd538278ddb54a6fe72451be5016acb",
      "content": "    fn test_order_by_descending() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        for age in [30, 20, 25] {\n            G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n                .add_n(\n                    \"person\",\n                    Some(ImmutablePropertiesMap::new(\n                        1,\n                        [(\"age\", Value::from(age))].into_iter(),\n                        &arena,\n                    )),\n                    None,\n                )\n                .collect_to_obj()\n                .unwrap();\n        }\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::OrderBy {\n                properties: \"age\".to_string(),\n                order: crate::helix_gateway::mcp::tools::Order::Desc,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert_eq!(results.len(), 3);\n\n        // Verify ordering\n        let TraversalValue::Node(node1) = &results[0] else {\n            panic!(\"expected node\");\n        };\n        let age1 = node1.get_property(\"age\").unwrap();\n        assert_eq!(age1, &Value::from(30));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_combined_out_and_in_steps_1086": {
      "name": "test_combined_out_and_in_steps",
      "type": "function",
      "start_line": 1086,
      "end_line": 1147,
      "content_hash": "4f42ca47857617d0a28d1f439b90810da4d8621b",
      "content": "    fn test_combined_out_and_in_steps() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let alice = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let bob = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let charlie = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, alice.id(), bob.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, bob.id(), charlie.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        // Navigate: Alice -> out(knows) -> Bob -> in(knows) -> Alice\n        let steps = vec![\n            ToolArgs::NFromType {\n                node_type: \"person\".to_string(),\n            },\n            ToolArgs::OutStep {\n                edge_label: \"knows\".to_string(),\n                edge_type: EdgeType::Node,\n                filter: None,\n            },\n            ToolArgs::InStep {\n                edge_label: \"knows\".to_string(),\n                edge_type: EdgeType::Node,\n                filter: None,\n            },\n        ];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert!(results.len() > 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_type_returns_edges_1148": {
      "name": "test_e_from_type_returns_edges",
      "type": "function",
      "start_line": 1148,
      "end_line": 1196,
      "content_hash": "46ec9f243883b07cd104172baea7b63e98fc1ab0",
      "content": "    fn test_e_from_type_returns_edges() {\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        let person1 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        let person2 = G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\"person\", None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"knows\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_edge(\"likes\", None, person1.id(), person2.id(), false)\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let storage = engine.storage.as_ref();\n        let arena = Bump::new();\n        let txn = storage.graph_env.read_txn().unwrap();\n\n        let steps = vec![ToolArgs::EFromType {\n            edge_type: \"knows\".to_string(),\n        }];\n\n        let stream =\n            crate::helix_gateway::mcp::tools::execute_query_chain(&steps, storage, &txn, &arena)\n                .unwrap();\n\n        let results = stream.collect().unwrap();\n        assert_eq!(results.len(), 1);\n\n        let TraversalValue::Edge(edge) = &results[0] else {\n            panic!(\"expected edge result\");\n        };\n        assert_eq!(edge.label, \"knows\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_keyword_handler_http_1197": {
      "name": "test_search_keyword_handler_http",
      "type": "function",
      "start_line": 1197,
      "end_line": 1277,
      "content_hash": "c79efba5d57833a23cc22eb73b69228e58adaafb",
      "content": "    fn test_search_keyword_handler_http() {\n        use crate::helix_gateway::mcp::mcp::search_keyword;\n\n        let (engine, _temp_dir) = setup_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = Bump::new();\n\n        // Create some test documents with searchable text\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"document\",\n                Some(ImmutablePropertiesMap::new(\n                    2,\n                    [\n                        (\"title\", Value::from(\"Introduction to Rust\")),\n                        (\n                            \"content\",\n                            Value::from(\"Rust is a systems programming language\"),\n                        ),\n                    ]\n                    .into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        G::new_mut(engine.storage.as_ref(), &arena, &mut txn)\n            .add_n(\n                \"document\",\n                Some(ImmutablePropertiesMap::new(\n                    2,\n                    [\n                        (\"title\", Value::from(\"Learning Python\")),\n                        (\"content\", Value::from(\"Python is great for beginners\")),\n                    ]\n                    .into_iter(),\n                    &arena,\n                )),\n                None,\n            )\n            .collect_to_obj()\n            .unwrap();\n\n        txn.commit().unwrap();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_search\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn_search\",\"data\":{\"query\":\"rust programming\",\"limit\":10,\"label\":\"document\"}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"search_keyword\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        // Note: search_keyword may return Empty if BM25 index is not initialized\n        // This test verifies the endpoint works without error\n        let response = search_keyword(&mut input);\n        assert!(response.is_ok() || response.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_keyword_requires_connection_1278": {
      "name": "test_search_keyword_requires_connection",
      "type": "function",
      "start_line": 1278,
      "end_line": 1319,
      "content_hash": "957e4dee7783e67daf6e3b6dffe4b10fdcbcb880",
      "content": "    fn test_search_keyword_requires_connection() {\n        use crate::helix_gateway::mcp::mcp::search_keyword;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        // Don't create a connection\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"nonexistent\",\"data\":{\"query\":\"test\",\"limit\":10,\"label\":\"document\"}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"search_keyword\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_keyword(&mut input);\n        assert!(response.is_err());\n        assert!(\n            response\n                .unwrap_err()\n                .to_string()\n                .contains(\"Connection not found\")\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_keyword_input_validation_1320": {
      "name": "test_search_keyword_input_validation",
      "type": "function",
      "start_line": 1320,
      "end_line": 1359,
      "content_hash": "ea433a2e1095432a60f6933c54b250518f523f7c",
      "content": "    fn test_search_keyword_input_validation() {\n        use crate::helix_gateway::mcp::mcp::search_keyword;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_validate\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        // Test with invalid JSON\n        let request_body =\n            Bytes::from(r#\"{\"connection_id\":\"conn_validate\",\"invalid\":true}\"#.to_string());\n\n        let request = Request {\n            name: \"search_keyword\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_keyword(&mut input);\n        assert!(response.is_err());\n    }\n\n    // ============================================================================\n    // Vector Search Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_handler_registered_1360": {
      "name": "test_search_vector_handler_registered",
      "type": "function",
      "start_line": 1360,
      "end_line": 1374,
      "content_hash": "eef043e60274d1487cadaf2eb89cab56f07d565b",
      "content": "    fn test_search_vector_handler_registered() {\n        use crate::helix_gateway::mcp::mcp::MCPHandlerSubmission;\n\n        let handler_names: Vec<&str> = inventory::iter::<MCPHandlerSubmission>\n            .into_iter()\n            .map(|submission| submission.0.name)\n            .collect();\n\n        assert!(\n            handler_names.contains(&\"search_vector\"),\n            \"search_vector handler should be registered\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_text_handler_registered_1375": {
      "name": "test_search_vector_text_handler_registered",
      "type": "function",
      "start_line": 1375,
      "end_line": 1389,
      "content_hash": "9e990a4fe5082ff4def5f696259c6f03ad06e47e",
      "content": "    fn test_search_vector_text_handler_registered() {\n        use crate::helix_gateway::mcp::mcp::MCPHandlerSubmission;\n\n        let handler_names: Vec<&str> = inventory::iter::<MCPHandlerSubmission>\n            .into_iter()\n            .map(|submission| submission.0.name)\n            .collect();\n\n        assert!(\n            handler_names.contains(&\"search_vector_text\"),\n            \"search_vector_text handler should be registered\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_handler_http_1390": {
      "name": "test_search_vector_handler_http",
      "type": "function",
      "start_line": 1390,
      "end_line": 1427,
      "content_hash": "e99f1f65481b7cebf40d33d87d9cb0a9ca757f42",
      "content": "    fn test_search_vector_handler_http() {\n        use crate::helix_gateway::mcp::mcp::search_vector;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_vec\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn_vec\",\"data\":{\"vector\":[0.1,0.2,0.3],\"k\":5,\"min_score\":0.5}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector(&mut input);\n        // May return empty if no vectors indexed, but should not error\n        assert!(response.is_ok() || response.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_requires_connection_1428": {
      "name": "test_search_vector_requires_connection",
      "type": "function",
      "start_line": 1428,
      "end_line": 1468,
      "content_hash": "c18645bdfb7ea816b026ca4560785b7a7f7f5b48",
      "content": "    fn test_search_vector_requires_connection() {\n        use crate::helix_gateway::mcp::mcp::search_vector;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        // Don't create a connection\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"nonexistent\",\"data\":{\"vector\":[0.1,0.2,0.3],\"k\":5}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector(&mut input);\n        assert!(response.is_err());\n        assert!(\n            response\n                .unwrap_err()\n                .to_string()\n                .contains(\"Connection not found\")\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_input_validation_1469": {
      "name": "test_search_vector_input_validation",
      "type": "function",
      "start_line": 1469,
      "end_line": 1505,
      "content_hash": "eae483a29d8f16fefef71a1c2bf45148fa7f25bb",
      "content": "    fn test_search_vector_input_validation() {\n        use crate::helix_gateway::mcp::mcp::search_vector;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_vec_validate\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        // Test with invalid JSON (missing required k field)\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn_vec_validate\",\"data\":{\"vector\":[0.1,0.2,0.3]}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector(&mut input);\n        assert!(response.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_text_handler_http_1506": {
      "name": "test_search_vector_text_handler_http",
      "type": "function",
      "start_line": 1506,
      "end_line": 1543,
      "content_hash": "6b2cd4fbc26779a0b0f2076020ad0d8044282228",
      "content": "    fn test_search_vector_text_handler_http() {\n        use crate::helix_gateway::mcp::mcp::search_vector_text;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_vec_text\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn_vec_text\",\"data\":{\"query\":\"test query\",\"label\":\"document\",\"k\":10}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector_text\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector_text(&mut input);\n        // May fail if embedding model is not available, but endpoint should exist\n        assert!(response.is_ok() || response.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_text_requires_connection_1544": {
      "name": "test_search_vector_text_requires_connection",
      "type": "function",
      "start_line": 1544,
      "end_line": 1585,
      "content_hash": "17bd8030ec015d454fef60b1f0242a9a289a4098",
      "content": "    fn test_search_vector_text_requires_connection() {\n        use crate::helix_gateway::mcp::mcp::search_vector_text;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        // Don't create a connection\n\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"nonexistent\",\"data\":{\"query\":\"test\",\"label\":\"document\",\"k\":5}}\"#\n                .to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector_text\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector_text(&mut input);\n        assert!(response.is_err());\n        assert!(\n            response\n                .unwrap_err()\n                .to_string()\n                .contains(\"Connection not found\")\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_vector_text_input_validation_1586": {
      "name": "test_search_vector_text_input_validation",
      "type": "function",
      "start_line": 1586,
      "end_line": 1621,
      "content_hash": "afef867da80db72c865e748f725b04eeed9e9cfb",
      "content": "    fn test_search_vector_text_input_validation() {\n        use crate::helix_gateway::mcp::mcp::search_vector_text;\n\n        let (engine, _temp_dir) = setup_engine();\n\n        let backend = Arc::new(McpBackend::new(Arc::clone(&engine.storage)));\n        let connections = Arc::new(Mutex::new(McpConnections::new()));\n\n        let connection = MCPConnection::new(\"conn_vec_text_validate\".to_string());\n        connections.lock().unwrap().add_connection(connection);\n\n        // Test with invalid JSON (missing required query field)\n        let request_body = Bytes::from(\n            r#\"{\"connection_id\":\"conn_vec_text_validate\",\"data\":{\"label\":\"document\"}}\"#.to_string(),\n        );\n\n        let request = Request {\n            name: \"search_vector_text\".to_string(),\n            req_type: RequestType::MCP,\n            body: request_body,\n            api_key: None,\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let mut input = MCPToolInput {\n            request,\n            mcp_backend: backend,\n            mcp_connections: Arc::clone(&connections),\n            schema: None,\n        };\n\n        let response = search_vector_text(&mut input);\n        assert!(response.is_err());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}