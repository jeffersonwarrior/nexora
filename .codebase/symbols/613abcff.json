{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/utils.rs",
  "file_hash": "0029dde33f61d3c91d82cbbf7e33271e8cbf7ba1",
  "updated_at": "2025-12-26T17:34:22.471483",
  "symbols": {
    "impl_Eq_20": {
      "name": "Eq",
      "type": "impl",
      "start_line": 20,
      "end_line": 21,
      "content_hash": "973412cca1c2c6828b9c4ac94a0004a3dde03dcf",
      "content": "impl Eq for Candidate {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_22": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 22,
      "end_line": 22,
      "content_hash": "2174712516c11baaac6033f275dcf15720066d33",
      "content": "impl PartialOrd for Candidate {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_23": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 23,
      "end_line": 27,
      "content_hash": "0854185509a7f9c0a486be05a054ab4c3c192e2e",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_28": {
      "name": "Ord",
      "type": "impl",
      "start_line": 28,
      "end_line": 28,
      "content_hash": "1b6c6859a0f4d0c955d0ef246b1fe7a810e23fa8",
      "content": "impl Ord for Candidate {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_29": {
      "name": "cmp",
      "type": "method",
      "start_line": 29,
      "end_line": 39,
      "content_hash": "a095b2e8a971dbaa63b2427519d57db91bb85ef6",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        other\n            .distance\n            .partial_cmp(&self.distance)\n            .unwrap_or(Ordering::Equal)\n    }\n}\n\npub(super) trait HeapOps<'a, T> {\n    /// Take the top k elements from the heap\n    /// Used because using `.iter()` does not keep the order",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_take_inord_40": {
      "name": "take_inord",
      "type": "method",
      "start_line": 40,
      "end_line": 50,
      "content_hash": "0136e8204f1fd9d4480ef7987bfae57f3956240e",
      "content": "    fn take_inord(&mut self, k: usize) -> BinaryHeap<'a, T>\n    where\n        T: Ord;\n\n    /// Get the maximum element from the heap\n    fn get_max<'q>(&'q self) -> Option<&'a T>\n    where\n        T: Ord,\n        'q: 'a;\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HeapOps_51": {
      "name": "HeapOps",
      "type": "impl",
      "start_line": 51,
      "end_line": 52,
      "content_hash": "5b0a4aa329bb2febfbf3221c5d164e5faf0d7903",
      "content": "impl<'a, T> HeapOps<'a, T> for BinaryHeap<'a, T> {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_take_inord_53": {
      "name": "take_inord",
      "type": "method",
      "start_line": 53,
      "end_line": 77,
      "content_hash": "3df539e8eaf66d7720c78b1c616275c0276c42ed",
      "content": "    fn take_inord(&mut self, k: usize) -> BinaryHeap<'a, T>\n    where\n        T: Ord,\n    {\n        let mut result = BinaryHeap::with_capacity(self.arena, k);\n        for _ in 0..k {\n            if let Some(item) = self.pop() {\n                result.push(item);\n            } else {\n                break;\n            }\n        }\n        result\n    }\n\n    #[inline(always)]\n    fn get_max<'q>(&'q self) -> Option<&'a T>\n    where\n        T: Ord,\n        'q: 'a,\n    {\n        self.iter().max()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_VectorFilter_78": {
      "name": "VectorFilter",
      "type": "trait",
      "start_line": 78,
      "end_line": 91,
      "content_hash": "612905c2a7b3ee8e1bd9d8ef8239170d96d94065",
      "content": "pub trait VectorFilter<'db, 'arena, 'txn, 'q> {\n    fn to_vec_with_filter<F, const SHOULD_CHECK_DELETED: bool>(\n        self,\n        k: usize,\n        filter: Option<&'arena [F]>,\n        label: &'arena str,\n        txn: &'txn RoTxn<'db>,\n        db: Database<U128<BE>, Bytes>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<bumpalo::collections::Vec<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &'txn RoTxn<'db>) -> bool;\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_VectorFilter_92": {
      "name": "VectorFilter",
      "type": "impl",
      "start_line": 92,
      "end_line": 145,
      "content_hash": "fec67f3dddfa88806bf421b9bb5eb03165f6355e",
      "content": "impl<'db, 'arena, 'txn, 'q> VectorFilter<'db, 'arena, 'txn, 'q>\n    for BinaryHeap<'arena, HVector<'arena>>\n{\n    #[inline(always)]\n    fn to_vec_with_filter<F, const SHOULD_CHECK_DELETED: bool>(\n        mut self,\n        k: usize,\n        filter: Option<&'arena [F]>,\n        label: &'arena str,\n        txn: &'txn RoTxn<'db>,\n        db: Database<U128<BE>, Bytes>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<bumpalo::collections::Vec<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &'txn RoTxn<'db>) -> bool,\n    {\n        let mut result = bumpalo::collections::Vec::with_capacity_in(k, arena);\n        for _ in 0..k {\n            // while pop check filters and pop until one passes\n            while let Some(mut item) = self.pop() {\n                let properties = match db.get(txn, &item.id)? {\n                    Some(bytes) => {\n                        // println!(\"decoding\");\n                        let res = Some(VectorWithoutData::from_bincode_bytes(\n                            arena, bytes, item.id,\n                        )?);\n                        // println!(\"decoded: {res:?}\");\n                        res\n                    }\n                    None => None, // TODO: maybe should be an error?\n                };\n\n                let Some(properties) = properties else {\n                    continue;\n                };\n\n                if SHOULD_CHECK_DELETED && properties.deleted {\n                    continue;\n                }\n\n                if properties.label == label\n                    && (filter.is_none() || filter.unwrap().iter().all(|f| f(&item, txn)))\n                {\n                    item.expand_from_vector_without_data(properties);\n                    result.push(item);\n                    break;\n                }\n            }\n        }\n\n        Ok(result)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_check_deleted_146": {
      "name": "check_deleted",
      "type": "method",
      "start_line": 146,
      "end_line": 175,
      "content_hash": "de835a2006f531cade1cca8f55ac4be75fc4f3a7",
      "content": "pub fn check_deleted(data: &[u8]) -> bool {\n    assert!(\n        data.len() >= LMDB_STRING_HEADER_LENGTH,\n        \"value length does not contain header which means the `label` field was missing from the node on insertion\"\n    );\n    let length_of_label_in_lmdb =\n        u64::from_le_bytes(data[..LMDB_STRING_HEADER_LENGTH].try_into().unwrap()) as usize;\n\n    let length_of_version_in_lmdb = 1;\n\n    let deleted_index =\n        LMDB_STRING_HEADER_LENGTH + length_of_label_in_lmdb + length_of_version_in_lmdb;\n\n    assert!(\n        data.len() >= deleted_index,\n        \"data length is not at least the deleted index plus the length of the deleted field meaning there has been a corruption on node insertion\"\n    );\n    data[deleted_index] == 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bumpalo::Bump;\n\n    // ============================================================================\n    // Candidate Ord/PartialOrd Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_candidate_ord_by_distance_176": {
      "name": "test_candidate_ord_by_distance",
      "type": "method",
      "start_line": 176,
      "end_line": 202,
      "content_hash": "75564eb035f5f55ad6996b54e8ffd483565b6637",
      "content": "    fn test_candidate_ord_by_distance() {\n        // Candidate uses reverse ordering (smaller distance = greater in ordering)\n        // This is for min-heap behavior in a max-heap\n        let c1 = Candidate {\n            id: 1,\n            distance: 0.5,\n        };\n        let c2 = Candidate {\n            id: 2,\n            distance: 1.0,\n        };\n        let c3 = Candidate {\n            id: 3,\n            distance: 0.2,\n        };\n\n        // c3 has smallest distance, so it should be \"greatest\" in ordering\n        assert!(c3 > c1);\n        assert!(c3 > c2);\n        assert!(c1 > c2);\n\n        // Verify the reverse: larger distance = smaller in ordering\n        assert!(c2 < c1);\n        assert!(c2 < c3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_candidate_partial_ord_consistency_203": {
      "name": "test_candidate_partial_ord_consistency",
      "type": "method",
      "start_line": 203,
      "end_line": 218,
      "content_hash": "b446756ee7432b8ee1b32f448cb7ce8b9b77364a",
      "content": "    fn test_candidate_partial_ord_consistency() {\n        let c1 = Candidate {\n            id: 1,\n            distance: 0.5,\n        };\n        let c2 = Candidate {\n            id: 2,\n            distance: 0.5,\n        };\n\n        // Same distance should be equal in ordering\n        assert_eq!(c1.cmp(&c2), Ordering::Equal);\n        assert_eq!(c1.partial_cmp(&c2), Some(Ordering::Equal));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_candidate_equality_219": {
      "name": "test_candidate_equality",
      "type": "method",
      "start_line": 219,
      "end_line": 242,
      "content_hash": "4775741ee9a019f34ba43d11f6111cf077b2a0ba",
      "content": "    fn test_candidate_equality() {\n        let c1 = Candidate {\n            id: 1,\n            distance: 0.5,\n        };\n        let c2 = Candidate {\n            id: 1,\n            distance: 0.5,\n        };\n        let c3 = Candidate {\n            id: 2,\n            distance: 0.5,\n        };\n\n        assert!(c1 == c2);\n        // Different id but same distance - not equal\n        assert!(c1 != c3);\n    }\n\n    // ============================================================================\n    // HeapOps Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_heap_ops_take_inord_243": {
      "name": "test_heap_ops_take_inord",
      "type": "method",
      "start_line": 243,
      "end_line": 264,
      "content_hash": "e1b92d44a571ec805a472b81209835e7a9eab4bb",
      "content": "    fn test_heap_ops_take_inord() {\n        let arena = Bump::new();\n        let mut heap: BinaryHeap<i32> = BinaryHeap::new(&arena);\n\n        // Push elements in random order\n        heap.push(5);\n        heap.push(1);\n        heap.push(8);\n        heap.push(3);\n        heap.push(9);\n\n        // Take top 3 elements\n        let result = heap.take_inord(3);\n\n        // Result should be a new heap with 3 elements\n        assert_eq!(result.len(), 3);\n\n        // Original heap should have remaining elements\n        assert_eq!(heap.len(), 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_heap_ops_take_inord_more_than_available_265": {
      "name": "test_heap_ops_take_inord_more_than_available",
      "type": "method",
      "start_line": 265,
      "end_line": 280,
      "content_hash": "fa24f66e0496a650fc7d85ebad75f51b00cbdefd",
      "content": "    fn test_heap_ops_take_inord_more_than_available() {\n        let arena = Bump::new();\n        let mut heap: BinaryHeap<i32> = BinaryHeap::new(&arena);\n\n        heap.push(5);\n        heap.push(1);\n\n        // Try to take more than available\n        let result = heap.take_inord(10);\n\n        // Should only take what's available\n        assert_eq!(result.len(), 2);\n        assert_eq!(heap.len(), 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_heap_ops_get_max_281": {
      "name": "test_heap_ops_get_max",
      "type": "method",
      "start_line": 281,
      "end_line": 298,
      "content_hash": "e34e28652a097d3c3a38cfba4c32ee7c01926e6a",
      "content": "    fn test_heap_ops_get_max() {\n        let arena = Bump::new();\n        let mut heap: BinaryHeap<i32> = BinaryHeap::new(&arena);\n\n        heap.push(5);\n        heap.push(1);\n        heap.push(8);\n        heap.push(3);\n\n        // Get max without removal\n        let max = heap.get_max();\n        assert_eq!(max, Some(&8));\n\n        // Heap should still have all elements\n        assert_eq!(heap.len(), 4);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_heap_ops_get_max_empty_299": {
      "name": "test_heap_ops_get_max_empty",
      "type": "method",
      "start_line": 299,
      "end_line": 311,
      "content_hash": "4b68458526f969ac3e98f9f8582aa7833b015a11",
      "content": "    fn test_heap_ops_get_max_empty() {\n        let arena = Bump::new();\n        let heap: BinaryHeap<i32> = BinaryHeap::new(&arena);\n\n        let max = heap.get_max();\n        assert_eq!(max, None);\n    }\n\n    // ============================================================================\n    // check_deleted Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_check_deleted_returns_false_312": {
      "name": "test_check_deleted_returns_false",
      "type": "method",
      "start_line": 312,
      "end_line": 330,
      "content_hash": "e57d480ca3f22f987db4c511754efebdc8d6a7dd",
      "content": "    fn test_check_deleted_returns_false() {\n        // Construct data with: 8-byte header (label length) + label + 1-byte version + deleted flag\n        let label = \"test\";\n        let label_len = label.len() as u64;\n        let mut data = Vec::new();\n\n        // 8-byte length header (little-endian)\n        data.extend_from_slice(&label_len.to_le_bytes());\n        // Label bytes\n        data.extend_from_slice(label.as_bytes());\n        // Version byte\n        data.push(0);\n        // Deleted flag (0 = not deleted)\n        data.push(0);\n\n        assert!(!check_deleted(&data));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_check_deleted_returns_true_331": {
      "name": "test_check_deleted_returns_true",
      "type": "method",
      "start_line": 331,
      "end_line": 348,
      "content_hash": "09890e62ede37b63e33ff320b6a77fb83cc0eeda",
      "content": "    fn test_check_deleted_returns_true() {\n        // Construct data with deleted flag = 1\n        let label = \"test\";\n        let label_len = label.len() as u64;\n        let mut data = Vec::new();\n\n        // 8-byte length header (little-endian)\n        data.extend_from_slice(&label_len.to_le_bytes());\n        // Label bytes\n        data.extend_from_slice(label.as_bytes());\n        // Version byte\n        data.push(0);\n        // Deleted flag (1 = deleted)\n        data.push(1);\n\n        assert!(check_deleted(&data));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}