{
  "file_path": "/work/external-deps/claude-swarm/dist/workers/confidence.js",
  "file_hash": "806e14848eb9891c13bc4ecadace793882ac2003",
  "updated_at": "2025-12-26T17:34:23.580707",
  "symbols": {
    "function_analyzeToolActivity_69": {
      "name": "analyzeToolActivity",
      "type": "function",
      "start_line": 69,
      "end_line": 124,
      "content_hash": "db31dd6f2e21a8f60f3bc44c95a2f0fbaaaf5894",
      "content": "export function analyzeToolActivity(logContent, logMtimeMs) {\n    const lines = logContent.split(\"\\n\").slice(-100); // Last 100 lines\n    const recentContent = lines.join(\"\\n\");\n    let healthyCycles = 0;\n    let stuckLoops = 0;\n    let errorRecoveries = 0;\n    // Count healthy cycles\n    for (const pattern of HEALTHY_PATTERNS) {\n        const matches = recentContent.match(pattern);\n        if (matches) {\n            healthyCycles++;\n        }\n    }\n    // Count stuck loops\n    for (const pattern of CONCERNING_PATTERNS.stuckLoop) {\n        const matches = recentContent.match(pattern);\n        if (matches) {\n            stuckLoops++;\n        }\n    }\n    // Detect error recoveries (error followed by success)\n    const errorMatches = CONCERNING_PATTERNS.errors.some((p) => p.test(recentContent));\n    const successMatches = POSITIVE_PATTERNS.success.some((p) => p.test(recentContent));\n    if (errorMatches && successMatches) {\n        errorRecoveries++;\n    }\n    // Calculate idle time\n    const now = Date.now();\n    const lastActivityAge = Math.floor((now - logMtimeMs) / 1000);\n    // Count idle periods (based on line timestamps if available)\n    let idlePeriods = 0;\n    if (lastActivityAge > 180) {\n        // More than 3 minutes\n        idlePeriods = 1;\n    }\n    // Calculate score starting from base of 70\n    let score = 70;\n    score += healthyCycles * 5; // +5 per healthy cycle\n    score -= stuckLoops * 10; // -10 per stuck loop\n    score += errorRecoveries * 3; // +3 for recovering from errors\n    // Penalize for idle time\n    if (lastActivityAge > 60) {\n        score -= Math.min(20, Math.floor(lastActivityAge / 60) * 5);\n    }\n    score = Math.max(0, Math.min(100, score));\n    return {\n        score,\n        patterns: {\n            healthyCycles,\n            stuckLoops,\n            idlePeriods,\n            errorRecoveries,\n        },\n        lastActivityAge,\n    };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_analyzeOutput_128": {
      "name": "analyzeOutput",
      "type": "function",
      "start_line": 128,
      "end_line": 186,
      "content_hash": "ced1fabfe90765375ddb45815ed5fc1647de0097",
      "content": "export function analyzeOutput(logContent) {\n    const lines = logContent.split(\"\\n\").slice(-100);\n    const recentContent = lines.join(\"\\n\");\n    let errorCount = 0;\n    let retryCount = 0;\n    let successIndicators = 0;\n    let frustrationIndicators = 0;\n    let completionIndicators = 0;\n    // Count errors\n    for (const pattern of CONCERNING_PATTERNS.errors) {\n        const matches = recentContent.match(new RegExp(pattern, \"gi\"));\n        if (matches) {\n            errorCount += matches.length;\n        }\n    }\n    // Count retries\n    for (const pattern of CONCERNING_PATTERNS.retries) {\n        const matches = recentContent.match(new RegExp(pattern, \"gi\"));\n        if (matches) {\n            retryCount += matches.length;\n        }\n    }\n    // Count frustration indicators\n    for (const pattern of CONCERNING_PATTERNS.frustration) {\n        if (pattern.test(recentContent)) {\n            frustrationIndicators++;\n        }\n    }\n    // Count success indicators\n    for (const pattern of POSITIVE_PATTERNS.success) {\n        if (pattern.test(recentContent)) {\n            successIndicators++;\n        }\n    }\n    // Count completion indicators\n    for (const pattern of POSITIVE_PATTERNS.completion) {\n        if (pattern.test(recentContent)) {\n            completionIndicators++;\n        }\n    }\n    // Calculate score starting from base of 70\n    let score = 70;\n    score += successIndicators * 5;\n    score += completionIndicators * 20;\n    score -= Math.min(30, errorCount * 5);\n    score -= retryCount * 3;\n    score -= frustrationIndicators * 15;\n    score = Math.max(0, Math.min(100, score));\n    return {\n        score,\n        indicators: {\n            errorCount: Math.min(10, errorCount), // Cap for display\n            retryCount: Math.min(10, retryCount),\n            successIndicators,\n            frustrationIndicators,\n            completionIndicators,\n        },\n    };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_readSelfReportedConfidence_190": {
      "name": "readSelfReportedConfidence",
      "type": "function",
      "start_line": 190,
      "end_line": 206,
      "content_hash": "a19883b7375466aef6ad03533182d699fa4b1ec7",
      "content": "export function readSelfReportedConfidence(workerDir, featureId) {\n    const confidenceFile = path.join(workerDir, `${featureId}.confidence`);\n    try {\n        if (!fs.existsSync(confidenceFile)) {\n            return null;\n        }\n        const content = fs.readFileSync(confidenceFile, \"utf-8\").trim();\n        const value = parseInt(content, 10);\n        if (isNaN(value) || value < 0 || value > 100) {\n            return null;\n        }\n        return value;\n    }\n    catch {\n        return null;\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_calculateAggregatedConfidence_210": {
      "name": "calculateAggregatedConfidence",
      "type": "function",
      "start_line": 210,
      "end_line": 308,
      "content_hash": "e2eebde81437435dbb7580a050b0bab0e9547bf4",
      "content": "export function calculateAggregatedConfidence(signals, previousScore) {\n    // Define weights\n    let toolWeight = 0.35;\n    let selfWeight = 0.35;\n    let outputWeight = 0.3;\n    // If no self-reported confidence, redistribute weights\n    if (signals.selfReported === null) {\n        toolWeight = 0.5;\n        selfWeight = 0;\n        outputWeight = 0.5;\n    }\n    // Calculate weighted score\n    let score = signals.toolActivity.score * toolWeight +\n        (signals.selfReported ?? 0) * selfWeight +\n        signals.outputAnalysis.score * outputWeight;\n    // Apply trend adjustment\n    let trend = \"stable\";\n    if (previousScore !== undefined) {\n        const diff = score - previousScore;\n        if (diff > 5) {\n            trend = \"improving\";\n            score += 5; // Small boost for improving trend\n        }\n        else if (diff < -5) {\n            trend = \"declining\";\n            score -= 5; // Small penalty for declining trend\n        }\n    }\n    score = Math.max(0, Math.min(100, Math.round(score)));\n    // Determine level\n    let level;\n    if (score >= 80) {\n        level = \"high\";\n    }\n    else if (score >= 50) {\n        level = \"medium\";\n    }\n    else if (score >= 25) {\n        level = \"low\";\n    }\n    else {\n        level = \"critical\";\n    }\n    // Generate alerts\n    const alerts = [];\n    const now = new Date().toISOString();\n    // Alert for idle\n    if (signals.toolActivity.lastActivityAge > 180) {\n        alerts.push({\n            type: \"idle\",\n            message: `Worker idle for ${Math.floor(signals.toolActivity.lastActivityAge / 60)} minutes`,\n            severity: signals.toolActivity.lastActivityAge > 300 ? \"critical\" : \"warning\",\n            timestamp: now,\n        });\n    }\n    // Alert for stuck loops\n    if (signals.toolActivity.patterns.stuckLoops > 0) {\n        alerts.push({\n            type: \"stuck_loop\",\n            message: `Detected ${signals.toolActivity.patterns.stuckLoops} stuck loop pattern(s)`,\n            severity: signals.toolActivity.patterns.stuckLoops > 2 ? \"critical\" : \"warning\",\n            timestamp: now,\n        });\n    }\n    // Alert for high errors\n    if (signals.outputAnalysis.indicators.errorCount > 3) {\n        alerts.push({\n            type: \"high_errors\",\n            message: `High error count: ${signals.outputAnalysis.indicators.errorCount} errors detected`,\n            severity: signals.outputAnalysis.indicators.errorCount > 5 ? \"critical\" : \"warning\",\n            timestamp: now,\n        });\n    }\n    // Alert for low self-reported confidence\n    if (signals.selfReported !== null && signals.selfReported < 30) {\n        alerts.push({\n            type: \"self_reported_low\",\n            message: `Worker self-reported low confidence: ${signals.selfReported}%`,\n            severity: signals.selfReported < 15 ? \"critical\" : \"warning\",\n            timestamp: now,\n        });\n    }\n    // Alert for declining trend\n    if (trend === \"declining\" && previousScore !== undefined) {\n        alerts.push({\n            type: \"declining_trend\",\n            message: `Confidence declining: ${previousScore} \u2192 ${score}`,\n            severity: score < 40 ? \"critical\" : \"warning\",\n            timestamp: now,\n        });\n    }\n    return {\n        score,\n        level,\n        signals,\n        trend,\n        alerts,\n    };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getWorkerConfidence_312": {
      "name": "getWorkerConfidence",
      "type": "function",
      "start_line": 312,
      "end_line": 335,
      "content_hash": "6a1ebc6e1632b7514082cd7409507ba2a1795595",
      "content": "export function getWorkerConfidence(workerDir, featureId, previousScore) {\n    const logFile = path.join(workerDir, `${featureId}.log`);\n    // Check if log file exists\n    if (!fs.existsSync(logFile)) {\n        return null;\n    }\n    try {\n        const logContent = fs.readFileSync(logFile, \"utf-8\");\n        const logStat = fs.statSync(logFile);\n        // Gather all signals\n        const toolActivity = analyzeToolActivity(logContent, logStat.mtimeMs);\n        const selfReported = readSelfReportedConfidence(workerDir, featureId);\n        const outputAnalysis = analyzeOutput(logContent);\n        const signals = {\n            toolActivity,\n            selfReported,\n            outputAnalysis,\n        };\n        return calculateAggregatedConfidence(signals, previousScore);\n    }\n    catch {\n        return null;\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatConfidenceResult_339": {
      "name": "formatConfidenceResult",
      "type": "function",
      "start_line": 339,
      "end_line": 374,
      "content_hash": "b584b7a5f2a1d0d62a439e5370751a47a1f4a476",
      "content": "export function formatConfidenceResult(confidence) {\n    const lines = [];\n    // Level emoji\n    const levelEmoji = {\n        high: \"\ud83d\udfe2\",\n        medium: \"\ud83d\udfe1\",\n        low: \"\ud83d\udfe0\",\n        critical: \"\ud83d\udd34\",\n    };\n    lines.push(`${levelEmoji[confidence.level]} Confidence: ${confidence.score}/100 (${confidence.level})`);\n    lines.push(`Trend: ${confidence.trend}`);\n    lines.push(\"\");\n    lines.push(\"Signals:\");\n    lines.push(`  Tool Activity: ${confidence.signals.toolActivity.score}/100`);\n    lines.push(`    Healthy cycles: ${confidence.signals.toolActivity.patterns.healthyCycles}`);\n    lines.push(`    Stuck loops: ${confidence.signals.toolActivity.patterns.stuckLoops}`);\n    lines.push(`    Last activity: ${formatDuration(confidence.signals.toolActivity.lastActivityAge)} ago`);\n    if (confidence.signals.selfReported !== null) {\n        lines.push(`  Self-Reported: ${confidence.signals.selfReported}/100`);\n    }\n    else {\n        lines.push(`  Self-Reported: not available`);\n    }\n    lines.push(`  Output Analysis: ${confidence.signals.outputAnalysis.score}/100`);\n    lines.push(`    Errors: ${confidence.signals.outputAnalysis.indicators.errorCount}`);\n    lines.push(`    Success indicators: ${confidence.signals.outputAnalysis.indicators.successIndicators}`);\n    if (confidence.alerts.length > 0) {\n        lines.push(\"\");\n        lines.push(\"Alerts:\");\n        for (const alert of confidence.alerts) {\n            const icon = alert.severity === \"critical\" ? \"\ud83d\udea8\" : \"\u26a0\ufe0f\";\n            lines.push(`  ${icon} ${alert.message}`);\n        }\n    }\n    return lines.join(\"\\n\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatDuration_378": {
      "name": "formatDuration",
      "type": "function",
      "start_line": 378,
      "end_line": 388,
      "content_hash": "951e96c3dfbd9fa994e67e4ed7ec8e1c65ca05e8",
      "content": "function formatDuration(seconds) {\n    if (seconds < 60) {\n        return `${seconds}s`;\n    }\n    else if (seconds < 3600) {\n        return `${Math.floor(seconds / 60)}m`;\n    }\n    else {\n        return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}