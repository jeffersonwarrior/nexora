{
  "file_path": "/work/external-deps/claude-mem/src/services/worker-wrapper.ts",
  "file_hash": "70a788cb2c3d4c7fe502e7b79cae31ddf05fc166",
  "updated_at": "2025-12-26T17:34:22.619296",
  "symbols": {
    "function_log_28": {
      "name": "log",
      "type": "function",
      "start_line": 28,
      "end_line": 31,
      "content_hash": "59b7ee1c7429cba67c3c3fdab07422199606ac36",
      "content": "function log(msg: string) {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] [wrapper] ${msg}`);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_spawnInner_33": {
      "name": "spawnInner",
      "type": "function",
      "start_line": 33,
      "end_line": 69,
      "content_hash": "23cbfab8c768bcfa95e70ed7ffd231535859aa87",
      "content": "function spawnInner() {\n  log(`Spawning inner worker: ${INNER_SCRIPT}`);\n\n  inner = spawn(process.execPath, [INNER_SCRIPT], {\n    stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n    env: { ...process.env, CLAUDE_MEM_MANAGED: 'true' },\n    cwd: path.dirname(INNER_SCRIPT),\n  });\n\n  inner.on('message', async (msg: { type: string }) => {\n    if (msg.type === 'restart' || msg.type === 'shutdown') {\n      // Both restart and shutdown: kill inner and exit wrapper\n      // The hooks will start a fresh wrapper+inner if needed\n      log(`${msg.type} requested by inner`);\n      isShuttingDown = true;\n      await killInner();\n      log('Exiting wrapper');\n      process.exit(0);\n    }\n  });\n\n  inner.on('exit', (code, signal) => {\n    log(`Inner exited with code=${code}, signal=${signal}`);\n    inner = null;\n\n    // Don't auto-restart - let hooks handle it via ensureWorkerRunning()\n    // Auto-restart causes PID file mismatches and potential infinite loops\n    if (!isShuttingDown) {\n      log('Inner exited unexpectedly, wrapper exiting (hooks will restart if needed)');\n      process.exit(code ?? 1);\n    }\n  });\n\n  inner.on('error', (err) => {\n    log(`Inner error: ${err.message}`);\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_killInner_71": {
      "name": "killInner",
      "type": "function",
      "start_line": 71,
      "end_line": 122,
      "content_hash": "a0acb382f3a0510bddc2bffca1eeace1379eab12",
      "content": "async function killInner(): Promise<void> {\n  if (!inner || !inner.pid) {\n    log('No inner process to kill');\n    return;\n  }\n\n  const pid = inner.pid;\n  log(`Killing inner process tree (pid=${pid})`);\n\n  if (isWindows) {\n    // On Windows, use taskkill /T /F to kill entire process tree\n    // This ensures all children (MCP server, ChromaSync, etc.) are killed\n    // which is necessary to properly release the socket\n    try {\n      execSync(`taskkill /PID ${pid} /T /F`, { timeout: 10000, stdio: 'ignore' });\n      log(`taskkill completed for pid=${pid}`);\n    } catch (error) {\n      // Process may already be dead\n      log(`taskkill failed (process may be dead): ${error}`);\n    }\n  } else {\n    // On Unix, SIGTERM then SIGKILL\n    inner.kill('SIGTERM');\n\n    // Wait for exit with timeout\n    const exitPromise = new Promise<void>(resolve => {\n      if (!inner) {\n        resolve();\n        return;\n      }\n      inner.on('exit', () => resolve());\n    });\n\n    const timeoutPromise = new Promise<void>(resolve =>\n      setTimeout(() => resolve(), 5000)\n    );\n\n    await Promise.race([exitPromise, timeoutPromise]);\n\n    // Force kill if still alive\n    if (inner && !inner.killed) {\n      log('Inner did not exit gracefully, force killing');\n      inner.kill('SIGKILL');\n    }\n  }\n\n  // Wait for the process to fully exit\n  await waitForProcessExit(pid, 5000);\n\n  inner = null;\n  log('Inner process terminated');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_waitForProcessExit_124": {
      "name": "waitForProcessExit",
      "type": "function",
      "start_line": 124,
      "end_line": 138,
      "content_hash": "f6a7b31ee329682d257c0830c70583deecb74825",
      "content": "async function waitForProcessExit(pid: number, timeoutMs: number): Promise<void> {\n  const start = Date.now();\n\n  while (Date.now() - start < timeoutMs) {\n    try {\n      process.kill(pid, 0); // Check if process exists\n      await new Promise(r => setTimeout(r, 100));\n    } catch {\n      // Process is dead\n      return;\n    }\n  }\n\n  log(`Timeout waiting for process ${pid} to exit`);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}