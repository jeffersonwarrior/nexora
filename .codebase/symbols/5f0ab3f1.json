{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/utils.rs",
  "file_hash": "6a60602c48261c1ea34945d6ad00abf76871f193",
  "updated_at": "2025-12-26T17:34:20.919285",
  "symbols": {
    "function_copy_dir_recursively_29": {
      "name": "copy_dir_recursively",
      "type": "function",
      "start_line": 29,
      "end_line": 53,
      "content_hash": "0882c7d0125e93a93f3c8ef5678d69798fe89dfc",
      "content": "pub fn copy_dir_recursively(src: &Path, dst: &Path) -> Result<()> {\n    if !src.is_dir() {\n        return Err(eyre::eyre!(\"Source is not a directory: {}\", src.display()));\n    }\n\n    // Create destination directory\n    fs::create_dir_all(dst)?;\n\n    // Read the source directory\n    for entry in fs::read_dir(src)? {\n        let entry = entry?;\n        let src_path = entry.path();\n        let dst_path = dst.join(entry.file_name());\n\n        if src_path.is_dir() {\n            copy_dir_recursively(&src_path, &dst_path)?;\n        } else {\n            fs::copy(&src_path, &dst_path)?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Copy a directory recursively",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_copy_dir_recursive_excluding_54": {
      "name": "copy_dir_recursive_excluding",
      "type": "function",
      "start_line": 54,
      "end_line": 88,
      "content_hash": "b7bbe97c432e2b05d1c5132304a19699beb2f879",
      "content": "pub fn copy_dir_recursive_excluding(src: &Path, dst: &Path) -> Result<()> {\n    if !src.is_dir() {\n        return Err(eyre::eyre!(\"Source is not a directory: {}\", src.display()));\n    }\n\n    // Create destination directory\n    fs::create_dir_all(dst)?;\n\n    // Read the source directory\n    for entry in fs::read_dir(src)? {\n        let entry = entry?;\n        let src_path = entry.path();\n        let dst_path = dst.join(entry.file_name());\n        if IGNORES.contains(\n            &entry\n                .file_name()\n                .into_string()\n                .map_err(|s| eyre!(\"cannot convert file name to string: {s:?}\"))?\n                .as_str(),\n        ) {\n            continue;\n        }\n\n        if src_path.is_dir() {\n            copy_dir_recursive_excluding(&src_path, &dst_path)?;\n        } else {\n            fs::copy(&src_path, &dst_path)?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a command exists in PATH\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_command_exists_89": {
      "name": "command_exists",
      "type": "function",
      "start_line": 89,
      "end_line": 97,
      "content_hash": "2c4440f0b1c1f65540beb07902dac44322148bec",
      "content": "pub fn command_exists(command: &str) -> bool {\n    std::process::Command::new(\"which\")\n        .arg(command)\n        .output()\n        .map(|output| output.status.success())\n        .unwrap_or(false)\n}\n\n/// Print a status message with a prefix",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_status_98": {
      "name": "print_status",
      "type": "function",
      "start_line": 98,
      "end_line": 102,
      "content_hash": "2d26c84f59367f8aea8441e8d0f82e720053935e",
      "content": "pub fn print_status(prefix: &str, message: &str) {\n    println!(\"{} {message}\", format!(\"[{prefix}]\").blue().bold());\n}\n\n/// Print an info message with consistent formatting",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_info_103": {
      "name": "print_info",
      "type": "function",
      "start_line": 103,
      "end_line": 108,
      "content_hash": "a709a17b4a02d7e80ad627daac150b5aa5c1b389",
      "content": "pub fn print_info(message: &str) {\n    println!(\"{} {message}\", \"[INFO]\".cyan().bold());\n}\n\n/// Print a formatted message with custom color\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_message_109": {
      "name": "print_message",
      "type": "function",
      "start_line": 109,
      "end_line": 113,
      "content_hash": "0bb7643d0a87f72328bfd0aace3f660655ebfeb7",
      "content": "pub fn print_message(prefix: &str, message: &str) {\n    println!(\"{} {message}\", format!(\"[{prefix}]\").white().bold());\n}\n\n/// Print a plain message (replaces direct println! usage)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_line_114": {
      "name": "print_line",
      "type": "function",
      "start_line": 114,
      "end_line": 118,
      "content_hash": "35997700efbd51847fc6b6485487dda877b05b98",
      "content": "pub fn print_line(message: &str) {\n    println!(\"{message}\");\n}\n\n/// Print an empty line",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_newline_119": {
      "name": "print_newline",
      "type": "function",
      "start_line": 119,
      "end_line": 123,
      "content_hash": "4f81742b3583edbf97b7fc3c4de38f89dad4466a",
      "content": "pub fn print_newline() {\n    println!();\n}\n\n/// Print multiple lines with consistent indentation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_lines_124": {
      "name": "print_lines",
      "type": "function",
      "start_line": 124,
      "end_line": 130,
      "content_hash": "21c6822b0ef109ec13b1226ae5305bec06f4440d",
      "content": "pub fn print_lines(lines: &[&str]) {\n    for line in lines {\n        println!(\"  {line}\");\n    }\n}\n\n/// Print next steps or instructions",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_instructions_131": {
      "name": "print_instructions",
      "type": "function",
      "start_line": 131,
      "end_line": 139,
      "content_hash": "1746a38f71e10bb7c7594e4c165186c5b64936da",
      "content": "pub fn print_instructions(title: &str, steps: &[&str]) {\n    print_newline();\n    println!(\"{}\", title.bold());\n    for (i, step) in steps.iter().enumerate() {\n        println!(\"  {}. {step}\", (i + 1).to_string().bright_white().bold());\n    }\n}\n\n/// Print a section header",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_header_140": {
      "name": "print_header",
      "type": "function",
      "start_line": 140,
      "end_line": 144,
      "content_hash": "2d5f91267047fd94f3aa6dfd459f89ba8f9198bd",
      "content": "pub fn print_header(title: &str) {\n    println!(\"{}\", title.bold().underline());\n}\n\n/// Print formatted key-value pairs",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_field_145": {
      "name": "print_field",
      "type": "function",
      "start_line": 145,
      "end_line": 149,
      "content_hash": "681dd08f1d1db6cc66cbbb1123ee3dcd95cbd9b1",
      "content": "pub fn print_field(key: &str, value: &str) {\n    println!(\"  {}: {value}\", key.bright_white().bold());\n}\n\n/// Print an error message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_error_150": {
      "name": "print_error",
      "type": "function",
      "start_line": 150,
      "end_line": 156,
      "content_hash": "647bfa29802c64811b4198cf680b839c3152e76e",
      "content": "pub fn print_error(message: &str) {\n    let error = CliError::new(message);\n    eprint!(\"{}\", error.render());\n}\n\n/// Print an error with context\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_error_with_context_157": {
      "name": "print_error_with_context",
      "type": "function",
      "start_line": 157,
      "end_line": 162,
      "content_hash": "b7a73eb84b0cb5d4ff914ddeebe238785e384d8f",
      "content": "pub fn print_error_with_context(message: &str, context: &str) {\n    let error = CliError::new(message).with_context(context);\n    eprint!(\"{}\", error.render());\n}\n\n/// Print an error with hint",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_error_with_hint_163": {
      "name": "print_error_with_hint",
      "type": "function",
      "start_line": 163,
      "end_line": 168,
      "content_hash": "6897d338ead831b5e0a9fbf8ba666299f8d4c8d8",
      "content": "pub fn print_error_with_hint(message: &str, hint: &str) {\n    let error = CliError::new(message).with_hint(hint);\n    eprint!(\"{}\", error.render());\n}\n\n/// Print a success message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_success_169": {
      "name": "print_success",
      "type": "function",
      "start_line": 169,
      "end_line": 174,
      "content_hash": "9a31c8a46bac9e71e4684a5472f253ad1af1d0fb",
      "content": "pub fn print_success(message: &str) {\n    println!(\"{} {message}\", \"[SUCCESS]\".green().bold());\n}\n\n/// Print a completion message with summary\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_completion_175": {
      "name": "print_completion",
      "type": "function",
      "start_line": 175,
      "end_line": 186,
      "content_hash": "846552a7d8c5c1d6d1bd27cfacc9d1439df7a73d",
      "content": "pub fn print_completion(operation: &str, details: &str) {\n    println!(\n        \"{} {} completed successfully\",\n        \"[SUCCESS]\".green().bold(),\n        operation\n    );\n    if !details.is_empty() {\n        println!(\"  {details}\");\n    }\n}\n\n/// Print a warning message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_warning_187": {
      "name": "print_warning",
      "type": "function",
      "start_line": 187,
      "end_line": 193,
      "content_hash": "7cf4403b2ddc82a90ebfd9c49761011421a7b4c9",
      "content": "pub fn print_warning(message: &str) {\n    let warning = CliError::warning(message);\n    eprint!(\"{}\", warning.render());\n}\n\n/// Print a warning with hint\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_warning_with_hint_194": {
      "name": "print_warning_with_hint",
      "type": "function",
      "start_line": 194,
      "end_line": 200,
      "content_hash": "0845dda1d39dd4e613d5a67bad0b6cffb746fa45",
      "content": "pub fn print_warning_with_hint(message: &str, hint: &str) {\n    let warning = CliError::warning(message).with_hint(hint);\n    eprint!(\"{}\", warning.render());\n}\n\n/// Print a formatted CLI error\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_cli_error_201": {
      "name": "print_cli_error",
      "type": "function",
      "start_line": 201,
      "end_line": 205,
      "content_hash": "beae94d0cdb0e41229265cf81cffd3a0553ef40a",
      "content": "pub fn print_cli_error(error: &CliError) {\n    eprint!(\"{}\", error.render());\n}\n\n/// Print a confirmation prompt and read user input",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_prompt_206": {
      "name": "print_prompt",
      "type": "function",
      "start_line": 206,
      "end_line": 215,
      "content_hash": "9cfc04bafea1e20ff9a5e15d804130c55216e776",
      "content": "pub fn print_prompt(message: &str) -> std::io::Result<String> {\n    use std::io::{self, Write};\n    print!(\"{} \", message.yellow().bold());\n    io::stdout().flush()?;\n    let mut input = String::new();\n    io::stdin().read_line(&mut input)?;\n    Ok(input.trim().to_string())\n}\n\n/// Print a yes/no confirmation prompt",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_confirm_216": {
      "name": "print_confirm",
      "type": "function",
      "start_line": 216,
      "end_line": 221,
      "content_hash": "443e33792ad9e8ae9e62b93b1afc3dfd43c83dc5",
      "content": "pub fn print_confirm(message: &str) -> std::io::Result<bool> {\n    let response = print_prompt(&format!(\"{message} (y/N):\"))?;\n    Ok(response.to_lowercase() == \"y\" || response.to_lowercase() == \"yes\")\n}\n\n/// Add or update an environment variable in a .env file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_add_env_var_to_file_222": {
      "name": "add_env_var_to_file",
      "type": "function",
      "start_line": 222,
      "end_line": 226,
      "content_hash": "2b1b46f193de2573bdba68344b8b54de2c924237",
      "content": "pub fn add_env_var_to_file(file_path: &Path, key: &str, value: &str) -> std::io::Result<()> {\n    add_env_var_with_comment(file_path, key, value, None)\n}\n\n/// Add or update an environment variable in a .env file with an optional comment",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_add_env_var_with_comment_227": {
      "name": "add_env_var_with_comment",
      "type": "function",
      "start_line": 227,
      "end_line": 271,
      "content_hash": "7d45992a93c90e6c66006145bec64e4ebb8f02ab",
      "content": "pub fn add_env_var_with_comment(\n    file_path: &Path,\n    key: &str,\n    value: &str,\n    comment: Option<&str>,\n) -> std::io::Result<()> {\n    let mut content = if file_path.exists() {\n        fs::read_to_string(file_path)?\n    } else {\n        String::new()\n    };\n\n    let key_prefix = format!(\"{}=\", key);\n    if content.lines().any(|line| line.starts_with(&key_prefix)) {\n        // Replace existing key (preserve any existing comment above it)\n        content = content\n            .lines()\n            .map(|line| {\n                if line.starts_with(&key_prefix) {\n                    format!(\"{}={}\", key, value)\n                } else {\n                    line.to_string()\n                }\n            })\n            .collect::<Vec<_>>()\n            .join(\"\\n\");\n        if !content.ends_with('\\n') {\n            content.push('\\n');\n        }\n    } else {\n        // Append new key with optional comment\n        if !content.is_empty() && !content.ends_with('\\n') {\n            content.push('\\n');\n        }\n        if let Some(cmt) = comment {\n            content.push_str(&format!(\"{}\\n\", cmt));\n        }\n        content.push_str(&format!(\"{}={}\\n\", key, value));\n    }\n\n    fs::write(file_path, content)\n}\n\n#[derive(Default)]\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Template_272": {
      "name": "Template",
      "type": "enum",
      "start_line": 272,
      "end_line": 279,
      "content_hash": "2caac957bcca327b55cd76d3d24dddca708c36e6",
      "content": "pub enum Template {\n    Typescript,\n    Python,\n    Rust,\n    Go,\n    #[default]\n    Empty,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Template_280": {
      "name": "Template",
      "type": "impl",
      "start_line": 280,
      "end_line": 281,
      "content_hash": "a745648640d31705fb6f576d314e625db917d9fe",
      "content": "impl Template {\n    #[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_282": {
      "name": "from",
      "type": "method",
      "start_line": 282,
      "end_line": 306,
      "content_hash": "757b788a876c9e816e1c0910846bcf311f564029",
      "content": "    pub fn from(value: &str) -> Result<Self> {\n        let template = match value {\n            \"ts\" | \"typescript\" => Template::Typescript,\n            \"py\" | \"python\" => Template::Python,\n            \"rs\" | \"rust\" => Template::Rust,\n            \"go\" => Template::Go,\n            _ => return Err(eyre::eyre!(\"Invalid template: {value}\")),\n        };\n        Ok(template)\n    }\n}\n\npub mod helixc_utils {\n    use eyre::Result;\n    use helix_db::helixc::{\n        analyzer::analyze,\n        generator::{Source as GeneratedSource, generate},\n        parser::{\n            HelixParser,\n            types::{Content, HxFile, Source},\n        },\n    };\n    use std::{fs, path::Path};\n\n    /// Collect all .hx files from queries directory and subdirectories",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_collect_hx_files_307": {
      "name": "collect_hx_files",
      "type": "method",
      "start_line": 307,
      "end_line": 310,
      "content_hash": "ccf1cb43358a34b2d9b11a6ca1609f45a34efc44",
      "content": "    pub fn collect_hx_files(root: &Path, queries_dir: &Path) -> Result<Vec<std::fs::DirEntry>> {\n        let mut files = Vec::new();\n        let queries_path = root.join(queries_dir);\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_collect_from_dir_311": {
      "name": "collect_from_dir",
      "type": "method",
      "start_line": 311,
      "end_line": 339,
      "content_hash": "4dd0d0ef485861c7927aeb102acf902a960f1ad5",
      "content": "        fn collect_from_dir(dir: &Path, files: &mut Vec<std::fs::DirEntry>) -> Result<()> {\n            if dir.file_name().unwrap_or_default() == \".helix\" {\n                return Ok(());\n            }\n            for entry in fs::read_dir(dir)? {\n                let entry = entry?;\n                let path = entry.path();\n                if path.is_file() && path.extension().map(|s| s == \"hx\").unwrap_or(false) {\n                    files.push(entry);\n                } else if path.is_dir() {\n                    collect_from_dir(&path, files)?;\n                }\n            }\n            Ok(())\n        }\n\n        collect_from_dir(&queries_path, &mut files)?;\n\n        if files.is_empty() {\n            return Err(eyre::eyre!(\n                \"No .hx files found in {}\",\n                queries_path.display()\n            ));\n        }\n\n        Ok(files)\n    }\n\n    /// Generate content from .hx files (similar to build.rs)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_content_340": {
      "name": "generate_content",
      "type": "method",
      "start_line": 340,
      "end_line": 364,
      "content_hash": "aba2730fdd869d10064cabfee5436b5bbf1f1f2e",
      "content": "    pub fn generate_content(files: &[std::fs::DirEntry]) -> Result<Content> {\n        let hx_files: Vec<HxFile> = files\n            .iter()\n            .map(|file| {\n                let name = file.path().to_string_lossy().into_owned();\n                let content = fs::read_to_string(file.path())\n                    .map_err(|e| eyre::eyre!(\"Failed to read file {name}: {e}\"))?;\n                Ok(HxFile { name, content })\n            })\n            .collect::<Result<Vec<_>>>()?;\n\n        let content_str = hx_files\n            .iter()\n            .map(|file| file.content.clone())\n            .collect::<Vec<String>>()\n            .join(\"\\n\");\n\n        Ok(Content {\n            content: content_str,\n            files: hx_files,\n            source: Source::default(),\n        })\n    }\n\n    /// Parse content (similar to build.rs)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_content_365": {
      "name": "parse_content",
      "type": "method",
      "start_line": 365,
      "end_line": 371,
      "content_hash": "414cbc98ff101e0c8494cf4432778f9e0ad76e39",
      "content": "    pub fn parse_content(content: &Content) -> Result<Source> {\n        let source =\n            HelixParser::parse_source(content).map_err(|e| eyre::eyre!(\"Parse error: {}\", e))?;\n        Ok(source)\n    }\n\n    /// Analyze source for validation (similar to build.rs)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_analyze_source_372": {
      "name": "analyze_source",
      "type": "method",
      "start_line": 372,
      "end_line": 390,
      "content_hash": "725146e75885474a6c0cd8ea8a1cf3f1c2ad2a10",
      "content": "    pub fn analyze_source(source: Source, files: &[HxFile]) -> Result<GeneratedSource> {\n        let (diagnostics, generated_source) =\n            analyze(&source).map_err(|e| eyre::eyre!(\"Analysis error: {}\", e))?;\n\n        if !diagnostics.is_empty() {\n            // Format diagnostics properly using the helix-db pretty printer\n            let formatted_diagnostics =\n                format_diagnostics(&diagnostics, &generated_source.src, files);\n            return Err(eyre::eyre!(\n                \"Compilation failed with {} error(s):\\n\\n{}\",\n                diagnostics.len(),\n                formatted_diagnostics\n            ));\n        }\n\n        Ok(generated_source)\n    }\n\n    /// Format diagnostics using the helix-db diagnostic renderer",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_format_diagnostics_391": {
      "name": "format_diagnostics",
      "type": "method",
      "start_line": 391,
      "end_line": 410,
      "content_hash": "ba265aa2805f913a6a70dd61a3e199e6bb071085",
      "content": "    fn format_diagnostics(\n        diagnostics: &[helix_db::helixc::analyzer::diagnostic::Diagnostic],\n        src: &str,\n        files: &[HxFile],\n    ) -> String {\n        let mut output = String::new();\n        for diagnostic in diagnostics {\n            // Use the render method with empty source for now\n            let filepath = diagnostic\n                .filepath\n                .clone()\n                .unwrap_or(\"queries.hx\".to_string());\n\n            let snippet_src = super::diagnostic_source(&filepath, files, src);\n            output.push_str(&diagnostic.render(snippet_src.as_ref(), &filepath));\n            output.push('\\n');\n        }\n        output\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_rust_code_411": {
      "name": "generate_rust_code",
      "type": "method",
      "start_line": 411,
      "end_line": 418,
      "content_hash": "feafbe1a822f31f12706c6266e6ff94f7e9e1ccb",
      "content": "    pub fn generate_rust_code(source: GeneratedSource, path: &Path) -> Result<()> {\n        generate(source, path)?;\n        Ok(())\n    }\n\n    /// Collect all .hx file contents as a single string with file path headers.\n    /// Used for GitHub issue reporting.\n    /// Filters out files that only contain comments (no actual schema or query definitions).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_collect_hx_contents_419": {
      "name": "collect_hx_contents",
      "type": "method",
      "start_line": 419,
      "end_line": 449,
      "content_hash": "7ece15098e93b346b02b08bb3f26d5353c651fc6",
      "content": "    pub fn collect_hx_contents(root: &Path, queries_dir: &Path) -> Result<String> {\n        let files = collect_hx_files(root, queries_dir)?;\n        let mut combined = String::new();\n\n        for file in files {\n            let path = file.path();\n            let content = fs::read_to_string(&path)\n                .map_err(|e| eyre::eyre!(\"Failed to read file {}: {e}\", path.display()))?;\n\n            // Skip files that only contain comments\n            if !has_actual_content(&content) {\n                continue;\n            }\n\n            // Get relative path for cleaner display\n            let relative_path = path\n                .strip_prefix(root)\n                .unwrap_or(&path)\n                .display()\n                .to_string();\n\n            combined.push_str(&format!(\"// File: {}\\n\", relative_path));\n            combined.push_str(&content);\n            combined.push_str(\"\\n\\n\");\n        }\n\n        Ok(combined.trim().to_string())\n    }\n\n    /// Check if a .hx file has actual content (not just comments and whitespace).\n    /// Returns true if the file contains any non-comment, non-whitespace content.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_has_actual_content_450": {
      "name": "has_actual_content",
      "type": "method",
      "start_line": 450,
      "end_line": 463,
      "content_hash": "3a31675b02e8c5b654dc4bceea249890a1ee2443",
      "content": "    fn has_actual_content(content: &str) -> bool {\n        for line in content.lines() {\n            let trimmed = line.trim();\n            // Skip empty lines and comment lines\n            if trimmed.is_empty() || trimmed.starts_with(\"//\") {\n                continue;\n            }\n            // Found actual content\n            return true;\n        }\n        false\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Spinner_464": {
      "name": "Spinner",
      "type": "struct",
      "start_line": 464,
      "end_line": 470,
      "content_hash": "c12be8f7551a36971b08267143cc536ce39cf74d",
      "content": "pub struct Spinner {\n    message: std::sync::Arc<std::sync::Mutex<String>>,\n    prefix: String,\n    stop_tx: Option<oneshot::Sender<()>>,\n    handle: Option<tokio::task::JoinHandle<()>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Spinner_471": {
      "name": "Spinner",
      "type": "impl",
      "start_line": 471,
      "end_line": 471,
      "content_hash": "a7965ee5e0abd29f65c1e9f93a504eb99d1b3a82",
      "content": "impl Spinner {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_472": {
      "name": "new",
      "type": "method",
      "start_line": 472,
      "end_line": 480,
      "content_hash": "d51fda1d979e4244ed7779b32469e6c70f7cf2d0",
      "content": "    pub fn new(prefix: &str, message: &str) -> Self {\n        Self {\n            message: std::sync::Arc::new(std::sync::Mutex::new(message.to_string())),\n            prefix: prefix.to_string(),\n            stop_tx: None,\n            handle: None,\n        }\n    }\n    // function that starts the spinner",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_start_481": {
      "name": "start",
      "type": "method",
      "start_line": 481,
      "end_line": 510,
      "content_hash": "2e65828c379de9cb47e23efcb8d1eae0f42185c4",
      "content": "    pub fn start(&mut self) {\n        if !std::io::stdout().is_terminal() {\n            return; // skip animation for non-interactive terminals\n        }\n        let message = self.message.clone();\n        let prefix = self.prefix.clone();\n        let (tx, mut rx) = oneshot::channel::<()>();\n\n        let handle = tokio::spawn(async move {\n            let frames = [\"\u280b\", \"\u2819\", \"\u2839\", \"\u2838\", \"\u283c\", \"\u2834\", \"\u2826\", \"\u2827\", \"\u2807\", \"\u280f\"];\n            let mut frame_idx = 0;\n            loop {\n                if rx.try_recv().is_ok() {\n                    break;\n                }\n                let frame = frames[frame_idx % frames.len()];\n                let msg = message.lock().unwrap().clone();\n                print!(\n                    \"\\r{} {frame} {msg}\",\n                    format!(\"[{prefix}]\").blue().bold()\n                );\n                std::io::Write::flush(&mut std::io::stdout()).unwrap();\n                frame_idx += 1;\n                tokio::time::sleep(Duration::from_millis(100)).await;\n            }\n        });\n        self.handle = Some(handle);\n        self.stop_tx = Some(tx);\n    }\n    // function that Stops the spinner",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stop_511": {
      "name": "stop",
      "type": "method",
      "start_line": 511,
      "end_line": 522,
      "content_hash": "7f5dafb3cf2d88239779e0c4899e1f436d697038",
      "content": "    pub fn stop(&mut self) {\n        if let Some(tx) = self.stop_tx.take() {\n            let _ = tx.send(());\n        }\n        if let Some(handle) = self.handle.take() {\n            handle.abort();\n        }\n        // Clear the line completely\n        print!(\"\\r\\x1b[K\");\n        std::io::Write::flush(&mut std::io::stdout()).unwrap();\n    }\n    /// function that updates the message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_update_523": {
      "name": "update",
      "type": "method",
      "start_line": 523,
      "end_line": 529,
      "content_hash": "081c430ec00353f839a6190398bbbc84d6bdc756",
      "content": "    pub fn update(&mut self, message: &str) {\n        if let Ok(mut msg) = self.message.lock() {\n            *msg = message.to_string();\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Drop_530": {
      "name": "Drop",
      "type": "impl",
      "start_line": 530,
      "end_line": 530,
      "content_hash": "05953d3e64c0b52c8dcdf94bfc5360af21cbd731",
      "content": "impl Drop for Spinner {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_531": {
      "name": "drop",
      "type": "method",
      "start_line": 531,
      "end_line": 542,
      "content_hash": "ecfa4965f8b32080da63ce51cf38d3d5fb6c4921",
      "content": "    fn drop(&mut self) {\n        self.stop();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_creates_new_file_543": {
      "name": "test_add_env_var_creates_new_file",
      "type": "method",
      "start_line": 543,
      "end_line": 553,
      "content_hash": "dd184b585131372b48588dc9e59286099cfe859e",
      "content": "    fn test_add_env_var_creates_new_file() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"test-key-123\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"HELIX_API_KEY=test-key-123\\n\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_appends_to_existing_file_554": {
      "name": "test_add_env_var_appends_to_existing_file",
      "type": "method",
      "start_line": 554,
      "end_line": 567,
      "content_hash": "8e3c6cb4cc11e773b709170ae26fffbed2c0ba85",
      "content": "    fn test_add_env_var_appends_to_existing_file() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create existing .env file\n        fs::write(&env_path, \"EXISTING_VAR=value\\n\").unwrap();\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"test-key-123\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"EXISTING_VAR=value\\nHELIX_API_KEY=test-key-123\\n\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_appends_newline_if_missing_568": {
      "name": "test_add_env_var_appends_newline_if_missing",
      "type": "method",
      "start_line": 568,
      "end_line": 581,
      "content_hash": "1ee182e1cceb568f9f0e38687d58d213095e0d50",
      "content": "    fn test_add_env_var_appends_newline_if_missing() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create existing .env file without trailing newline\n        fs::write(&env_path, \"EXISTING_VAR=value\").unwrap();\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"test-key-123\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"EXISTING_VAR=value\\nHELIX_API_KEY=test-key-123\\n\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_updates_existing_key_582": {
      "name": "test_add_env_var_updates_existing_key",
      "type": "method",
      "start_line": 582,
      "end_line": 595,
      "content_hash": "1a8a815e5d1432cacc4ae93d056b76bb90c1e511",
      "content": "    fn test_add_env_var_updates_existing_key() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create existing .env file with the key already present\n        fs::write(&env_path, \"OTHER_VAR=foo\\nHELIX_API_KEY=old-key\\nANOTHER_VAR=bar\\n\").unwrap();\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"new-key-456\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"OTHER_VAR=foo\\nHELIX_API_KEY=new-key-456\\nANOTHER_VAR=bar\\n\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_handles_empty_file_596": {
      "name": "test_add_env_var_handles_empty_file",
      "type": "method",
      "start_line": 596,
      "end_line": 609,
      "content_hash": "862515fb70b5f12b444da3e0caf34ad3a6e75693",
      "content": "    fn test_add_env_var_handles_empty_file() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create empty .env file\n        fs::write(&env_path, \"\").unwrap();\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"test-key-123\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"HELIX_API_KEY=test-key-123\\n\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_preserves_other_variables_610": {
      "name": "test_add_env_var_preserves_other_variables",
      "type": "method",
      "start_line": 610,
      "end_line": 626,
      "content_hash": "06c6fcf8405aa8d71a880f348ba4ac3aabf36e22",
      "content": "    fn test_add_env_var_preserves_other_variables() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create .env with multiple variables\n        fs::write(&env_path, \"VAR1=value1\\nVAR2=value2\\nVAR3=value3\\n\").unwrap();\n\n        add_env_var_to_file(&env_path, \"HELIX_API_KEY\", \"my-key\").unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert!(content.contains(\"VAR1=value1\"));\n        assert!(content.contains(\"VAR2=value2\"));\n        assert!(content.contains(\"VAR3=value3\"));\n        assert!(content.contains(\"HELIX_API_KEY=my-key\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_with_comment_creates_file_with_comment_627": {
      "name": "test_add_env_var_with_comment_creates_file_with_comment",
      "type": "method",
      "start_line": 627,
      "end_line": 646,
      "content_hash": "b9c9eb0db9080ac5afe4bd2313adb66b892a0ba3",
      "content": "    fn test_add_env_var_with_comment_creates_file_with_comment() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        add_env_var_with_comment(\n            &env_path,\n            \"HELIX_CLOUD_URL\",\n            \"https://example.com\",\n            Some(\"# HelixDB Cloud URL for instance: test\"),\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(\n            content,\n            \"# HelixDB Cloud URL for instance: test\\nHELIX_CLOUD_URL=https://example.com\\n\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_with_comment_appends_with_comment_647": {
      "name": "test_add_env_var_with_comment_appends_with_comment",
      "type": "method",
      "start_line": 647,
      "end_line": 669,
      "content_hash": "c1f51134c4efd1188349a48678bea42e29022626",
      "content": "    fn test_add_env_var_with_comment_appends_with_comment() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create existing .env file\n        fs::write(&env_path, \"EXISTING_VAR=value\\n\").unwrap();\n\n        add_env_var_with_comment(\n            &env_path,\n            \"HELIX_CLOUD_URL\",\n            \"https://example.com\",\n            Some(\"# HelixDB Cloud URL for instance: test\"),\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(\n            content,\n            \"EXISTING_VAR=value\\n# HelixDB Cloud URL for instance: test\\nHELIX_CLOUD_URL=https://example.com\\n\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_with_comment_updates_without_duplicate_comment_670": {
      "name": "test_add_env_var_with_comment_updates_without_duplicate_comment",
      "type": "method",
      "start_line": 670,
      "end_line": 697,
      "content_hash": "27760d5ab43168167430142a3a25f8cee3d745d4",
      "content": "    fn test_add_env_var_with_comment_updates_without_duplicate_comment() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        // Create existing .env file with key and comment\n        fs::write(\n            &env_path,\n            \"# HelixDB Cloud URL for instance: old\\nHELIX_CLOUD_URL=https://old.com\\n\",\n        )\n        .unwrap();\n\n        add_env_var_with_comment(\n            &env_path,\n            \"HELIX_CLOUD_URL\",\n            \"https://new.com\",\n            Some(\"# HelixDB Cloud URL for instance: new\"),\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        // Should update value but preserve existing comment (not add duplicate)\n        assert_eq!(\n            content,\n            \"# HelixDB Cloud URL for instance: old\\nHELIX_CLOUD_URL=https://new.com\\n\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_env_var_with_no_comment_698": {
      "name": "test_add_env_var_with_no_comment",
      "type": "method",
      "start_line": 698,
      "end_line": 707,
      "content_hash": "33972feb5d0fee30d7e8d7828ab1e678fe8bb98c",
      "content": "    fn test_add_env_var_with_no_comment() {\n        let dir = tempdir().unwrap();\n        let env_path = dir.path().join(\".env\");\n\n        add_env_var_with_comment(&env_path, \"HELIX_API_KEY\", \"test-key\", None).unwrap();\n\n        let content = fs::read_to_string(&env_path).unwrap();\n        assert_eq!(content, \"HELIX_API_KEY=test-key\\n\");\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}