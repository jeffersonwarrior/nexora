{
  "file_path": "/work/external-deps/helix-db/helix-container/src/main.rs",
  "file_hash": "94990a0e1eaa98f4724235ce10189cb71dc242ff",
  "updated_at": "2025-12-26T17:34:20.369146",
  "symbols": {
    "function_main_18": {
      "name": "main",
      "type": "function",
      "start_line": 18,
      "end_line": 173,
      "content_hash": "02ecdafabe49bc241b7a12af8b773b14c20badaa",
      "content": "fn main() {\n    let env_res = dotenvy::dotenv();\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::fmt::layer().with_filter(tracing_subscriber::filter::filter_fn(\n                |metadata| {\n                    let target = metadata.target();\n                    !target.starts_with(\"axum\")\n                        && !target.starts_with(\"hyper\")\n                        && !target.starts_with(\"tower\")\n                        && !target.starts_with(\"h2\")\n                },\n            )),\n        )\n        .init();\n\n    match env_res {\n        Ok(_) => info!(\"Loaded .env file\"),\n        Err(e) => info!(?e, \"Didn't load .env file\"),\n    }\n\n    let config = queries::config().unwrap_or_default();\n\n    let path = match std::env::var(\"HELIX_DATA_DIR\") {\n        Ok(val) => std::path::PathBuf::from(val).join(\"user\"),\n        Err(_) => {\n            println!(\"HELIX_DATA_DIR not set, using default\");\n            let home = dirs::home_dir().expect(\"Could not retrieve home directory\");\n            home.join(\".helix/user\")\n        }\n    };\n\n    let port = match std::env::var(\"HELIX_PORT\") {\n        Ok(val) => val\n            .parse::<u16>()\n            .expect(\"HELIX_PORT must be a valid port number\"),\n        Err(_) => 6969,\n    };\n\n    println!(\"Running with the following setup:\");\n    println!(\"\\tconfig: {config:?}\");\n    println!(\"\\tpath: {}\", path.display());\n    println!(\"\\tport: {port}\");\n\n    let transition_fns: HashMap<&'static str, ItemInfo> =\n        inventory::iter::<TransitionSubmission>.into_iter().fold(\n            HashMap::new(),\n            |mut acc,\n             TransitionSubmission(Transition {\n                 item_label,\n                 func,\n                 from_version,\n                 to_version,\n             })| {\n                acc.entry(item_label)\n                    .and_modify(|item_info: &mut ItemInfo| {\n                        item_info.latest = item_info.latest.max(*to_version);\n\n                        // asserts for versions\n                        assert!(\n                            *from_version < *to_version,\n                            \"from_version must be less than to_version\"\n                        );\n                        assert!(*from_version > 0, \"from_version must be greater than 0\");\n                        assert!(*to_version > 0, \"to_version must be greater than 0\");\n                        assert!(\n                            *to_version - *from_version == 1,\n                            \"to_version must be exactly 1 greater than from_version\"\n                        );\n\n                        item_info.transition_fns.push(TransitionFn {\n                            from_version: *from_version,\n                            to_version: *to_version,\n                            func: *func,\n                        });\n                        item_info.transition_fns.sort_by_key(|f| f.from_version);\n                    });\n                acc\n            },\n        );\n\n    let path_str = path.to_str().expect(\"Could not convert path to string\");\n    let opts = HelixGraphEngineOpts {\n        path: path_str.to_string(),\n        config,\n        version_info: VersionInfo(transition_fns),\n    };\n\n    let graph = Arc::new(\n        HelixGraphEngine::new(opts.clone())\n            .unwrap_or_else(|e| panic!(\"Failed to create graph engine: {e}\")),\n    );\n\n    // generates routes from handler proc macro\n    let submissions: Vec<_> = inventory::iter::<HandlerSubmission>.into_iter().collect();\n    println!(\"Found {} route submissions\", submissions.len());\n\n    let (query_routes, write_routes): (HashMap<String, HandlerFn>, std::collections::HashSet<String>) =\n        inventory::iter::<HandlerSubmission>\n            .into_iter()\n            .fold((HashMap::new(), std::collections::HashSet::new()), |(mut routes, mut writes), submission| {\n                println!(\n                    \"Processing POST submission for handler: {} (is_write: {})\",\n                    submission.0.name,\n                    submission.0.is_write\n                );\n                let handler = &submission.0;\n                let func: HandlerFn = Arc::new(handler.func);\n                routes.insert(handler.name.to_string(), func);\n                if handler.is_write {\n                    writes.insert(handler.name.to_string());\n                }\n                (routes, writes)\n            });\n\n    // collect GET routes\n    // let get_routes: HashMap<(String, String), HandlerFn> = inventory::iter::<HandlerSubmission>\n    //     .into_iter()\n    //     .map(|submission| {\n    //         println!(\"Processing GET submission for handler: {}\", submission.0.name);\n    //         let handler = &submission.0;\n    //         let func: HandlerFn = Arc::new(move |input, response| (handler.func)(input, response));\n    //         (\n    //             (\n    //                 \"GET\".to_string(),\n    //                 format!(\"/get/{}\", handler.name.to_string()),\n    //             ),\n    //             func,\n    //         )\n    //     })\n    // .collect();\n\n    let mcp_routes = inventory::iter::<MCPHandlerSubmission>\n        .into_iter()\n        .map(|submission| {\n            println!(\"Processing submission for handler: {}\", submission.0.name);\n            let handler = &submission.0;\n            let func: MCPHandlerFn = Arc::new(handler.func);\n            (handler.name.to_string(), func)\n        })\n        .collect::<HashMap<String, MCPHandlerFn>>();\n\n    println!(\"Routes: {:?}\", query_routes.keys());\n    println!(\"Write routes: {:?}\", write_routes);\n    let gateway = HelixGateway::new(\n        &format!(\"0.0.0.0:{port}\"),\n        graph,\n        GatewayOpts::DEFAULT_WORKERS_PER_CORE,\n        Some(query_routes),\n        Some(mcp_routes),\n        Some(write_routes),\n        Some(opts),\n    );\n\n    gateway.run().expect(\"Failed to run gateway\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}