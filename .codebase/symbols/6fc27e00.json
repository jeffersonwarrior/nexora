{
  "file_path": "/work/external-deps/claude-swarm/src/utils/complexity-detector.ts",
  "file_hash": "1f607c4be24ce9d59f5d6fe6c9aee9311a2ff2d1",
  "updated_at": "2025-12-26T17:34:22.604564",
  "symbols": {
    "function_analyzeComplexity_102": {
      "name": "analyzeComplexity",
      "type": "function",
      "start_line": 102,
      "end_line": 204,
      "content_hash": "530340e54a0ff4ca819c27948b5adaa454b25eb6",
      "content": "export function analyzeComplexity(\n  feature: Feature,\n  threshold: number = 60\n): ComplexityResult {\n  const description = feature.description;\n  const signals: ComplexitySignals = {\n    descriptionLength: description.length,\n    keywordMatches: [],\n    scopeIndicators: [],\n    architecturalTerms: [],\n    uncertaintyIndicators: [],\n    dependencyCount: feature.dependsOn?.length || 0,\n    estimatedTouchPoints: 0,\n  };\n\n  // 1. Score based on description length (0-20 pts)\n  // Short descriptions (< 50 chars) = 0, Long descriptions (> 200 chars) = 20\n  const lengthScore = Math.min(20, Math.floor(description.length / 10));\n\n  // 2. Score based on complexity keywords (0-30 pts, capped)\n  let keywordScore = 0;\n  for (const { pattern, weight } of COMPLEXITY_KEYWORDS) {\n    const match = description.match(pattern);\n    if (match) {\n      signals.keywordMatches.push(match[0]);\n      keywordScore += weight;\n    }\n  }\n  keywordScore = Math.min(30, keywordScore);\n\n  // 3. Score based on scope indicators (0-20 pts, capped)\n  let scopeScore = 0;\n  for (const { pattern, weight } of SCOPE_INDICATORS) {\n    const match = description.match(pattern);\n    if (match) {\n      signals.scopeIndicators.push(match[0]);\n      scopeScore += weight;\n    }\n  }\n\n  // Add architectural terms to scope\n  for (const { pattern, weight } of ARCHITECTURAL_TERMS) {\n    const match = description.match(pattern);\n    if (match) {\n      signals.architecturalTerms.push(match[0]);\n      scopeScore += Math.floor(weight / 2); // Half weight for architectural terms\n    }\n  }\n  scopeScore = Math.min(20, scopeScore);\n\n  // Track uncertainty indicators (informational, doesn't add to score directly)\n  for (const { pattern } of UNCERTAINTY_INDICATORS) {\n    const match = description.match(pattern);\n    if (match) {\n      signals.uncertaintyIndicators.push(match[0]);\n    }\n  }\n\n  // 4. Score based on dependency count (0-15 pts)\n  // 3 points per dependency, capped at 15\n  const dependencyScore = Math.min(15, signals.dependencyCount * 3);\n\n  // 5. Score based on estimated touch points (0-15 pts)\n  const touchPoints = new Set<string>();\n  for (const pattern of TOUCH_POINT_PATTERNS) {\n    const matches = description.match(pattern) || [];\n    for (const match of matches) {\n      touchPoints.add(match.toLowerCase());\n    }\n  }\n  signals.estimatedTouchPoints = touchPoints.size;\n  // 3 points per touch point, capped at 15\n  const touchPointScore = Math.min(15, touchPoints.size * 3);\n\n  // Calculate total score\n  const score =\n    lengthScore + keywordScore + scopeScore + dependencyScore + touchPointScore;\n\n  // Determine recommendation\n  let recommendation: ComplexityResult[\"recommendation\"];\n  if (score >= threshold) {\n    recommendation = \"competitive_planning\";\n  } else if (score >= threshold * 0.7) {\n    // 70% of threshold suggests manual review might be beneficial\n    recommendation = \"manual_review\";\n  } else {\n    recommendation = \"simple\";\n  }\n\n  return {\n    score,\n    isComplex: score >= threshold,\n    signals,\n    recommendation,\n    breakdown: {\n      lengthScore,\n      keywordScore,\n      scopeScore,\n      dependencyScore,\n      touchPointScore,\n    },\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatComplexityResult_209": {
      "name": "formatComplexityResult",
      "type": "function",
      "start_line": 209,
      "end_line": 244,
      "content_hash": "987f6ab3023a2def7975d41ab66f98f8d2d633e5",
      "content": "export function formatComplexityResult(result: ComplexityResult): string {\n  const lines: string[] = [];\n\n  lines.push(`Complexity Score: ${result.score}/100`);\n  lines.push(`Recommendation: ${result.recommendation.replace(/_/g, \" \")}`);\n  lines.push(\"\");\n  lines.push(\"Breakdown:\");\n  lines.push(`  Description length: ${result.breakdown.lengthScore}/20`);\n  lines.push(`  Keywords: ${result.breakdown.keywordScore}/30`);\n  lines.push(`  Scope: ${result.breakdown.scopeScore}/20`);\n  lines.push(`  Dependencies: ${result.breakdown.dependencyScore}/15`);\n  lines.push(`  Touch points: ${result.breakdown.touchPointScore}/15`);\n\n  if (result.signals.keywordMatches.length > 0) {\n    lines.push(\"\");\n    lines.push(`Keywords found: ${result.signals.keywordMatches.join(\", \")}`);\n  }\n\n  if (result.signals.scopeIndicators.length > 0) {\n    lines.push(`Scope indicators: ${result.signals.scopeIndicators.join(\", \")}`);\n  }\n\n  if (result.signals.architecturalTerms.length > 0) {\n    lines.push(\n      `Architectural terms: ${result.signals.architecturalTerms.join(\", \")}`\n    );\n  }\n\n  if (result.signals.uncertaintyIndicators.length > 0) {\n    lines.push(\n      `Uncertainty indicators: ${result.signals.uncertaintyIndicators.join(\", \")}`\n    );\n  }\n\n  return lines.join(\"\\n\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}