{
  "file_path": "/work/internal/agent/tools/grep_test.go",
  "file_hash": "8ff6759c1c26195c7c447e22f0362c90833279d4",
  "updated_at": "2025-12-26T17:34:22.610294",
  "symbols": {
    "function_TestRegexCache_12": {
      "name": "TestRegexCache",
      "type": "function",
      "start_line": 12,
      "end_line": 37,
      "content_hash": "a3dd1bdc08435c983384ef9b5ebbbedb82d74c84",
      "content": "func TestRegexCache(t *testing.T) {\n\tcache := newRegexCache()\n\n\t// Test basic caching\n\tpattern := \"test.*pattern\"\n\tregex1, err := cache.get(pattern)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to compile regex: %v\", err)\n\t}\n\n\tregex2, err := cache.get(pattern)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get cached regex: %v\", err)\n\t}\n\n\t// Should be the same instance (cached)\n\tif regex1 != regex2 {\n\t\tt.Error(\"Expected cached regex to be the same instance\")\n\t}\n\n\t// Test that it actually works\n\tif !regex1.MatchString(\"test123pattern\") {\n\t\tt.Error(\"Regex should match test string\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGlobToRegexCaching_38": {
      "name": "TestGlobToRegexCaching",
      "type": "function",
      "start_line": 38,
      "end_line": 58,
      "content_hash": "11b3fb5760673845a45150c68b6068fe154bedda",
      "content": "func TestGlobToRegexCaching(t *testing.T) {\n\t// Test that globToRegex uses pre-compiled regex\n\tpattern1 := globToRegex(\"*.{js,ts}\")\n\n\t// Should not panic and should work correctly\n\tregex1, err := regexp.Compile(pattern1)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to compile glob regex: %v\", err)\n\t}\n\n\tif !regex1.MatchString(\"test.js\") {\n\t\tt.Error(\"Glob regex should match .js files\")\n\t}\n\tif !regex1.MatchString(\"test.ts\") {\n\t\tt.Error(\"Glob regex should match .ts files\")\n\t}\n\tif regex1.MatchString(\"test.go\") {\n\t\tt.Error(\"Glob regex should not match .go files\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGrepWithIgnoreFiles_59": {
      "name": "TestGrepWithIgnoreFiles",
      "type": "function",
      "start_line": 59,
      "end_line": 125,
      "content_hash": "3ecbaa9f385109a3e464ebae0d1a8598c954de93",
      "content": "func TestGrepWithIgnoreFiles(t *testing.T) {\n\tt.Parallel()\n\ttempDir := t.TempDir()\n\n\t// Create test files\n\ttestFiles := map[string]string{\n\t\t\"file1.txt\":           \"hello world\",\n\t\t\"file2.txt\":           \"hello world\",\n\t\t\"ignored/file3.txt\":   \"hello world\",\n\t\t\"node_modules/lib.js\": \"hello world\",\n\t\t\"secret.key\":          \"hello world\",\n\t}\n\n\tfor path, content := range testFiles {\n\t\tfullPath := filepath.Join(tempDir, path)\n\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(fullPath), 0o755))\n\t\trequire.NoError(t, os.WriteFile(fullPath, []byte(content), 0o644))\n\t}\n\n\t// Create .gitignore file\n\tgitignoreContent := \"ignored/\\n*.key\\n\"\n\trequire.NoError(t, os.WriteFile(filepath.Join(tempDir, \".gitignore\"), []byte(gitignoreContent), 0o644))\n\n\t// Create .nexoraignore file\n\tnexoraignoreContent := \"node_modules/\\n\"\n\trequire.NoError(t, os.WriteFile(filepath.Join(tempDir, \".nexoraignore\"), []byte(nexoraignoreContent), 0o644))\n\n\t// Test both implementations\n\tfor name, fn := range map[string]func(pattern, path, include string) ([]grepMatch, error){\n\t\t\"regex\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchFilesWithRegex(pattern, path, include)\n\t\t},\n\t\t\"rg\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchWithRipgrep(t.Context(), pattern, path, include)\n\t\t},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif name == \"rg\" && getRg() == \"\" {\n\t\t\t\tt.Skip(\"rg is not in $PATH\")\n\t\t\t}\n\n\t\t\tmatches, err := fn(\"hello world\", tempDir, \"\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Convert matches to a set of file paths for easier testing\n\t\t\tfoundFiles := make(map[string]bool)\n\t\t\tfor _, match := range matches {\n\t\t\t\tfoundFiles[filepath.Base(match.path)] = true\n\t\t\t}\n\n\t\t\t// Should find file1.txt and file2.txt\n\t\t\trequire.True(t, foundFiles[\"file1.txt\"], \"Should find file1.txt\")\n\t\t\trequire.True(t, foundFiles[\"file2.txt\"], \"Should find file2.txt\")\n\n\t\t\t// Should NOT find ignored files\n\t\t\trequire.False(t, foundFiles[\"file3.txt\"], \"Should not find file3.txt (ignored by .gitignore)\")\n\t\t\trequire.False(t, foundFiles[\"lib.js\"], \"Should not find lib.js (ignored by .nexoraignore)\")\n\t\t\trequire.False(t, foundFiles[\"secret.key\"], \"Should not find secret.key (ignored by .gitignore)\")\n\n\t\t\t// Should find exactly 2 matches\n\t\t\trequire.Equal(t, 2, len(matches), \"Should find exactly 2 matches\")\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSearchImplementations_126": {
      "name": "TestSearchImplementations",
      "type": "function",
      "start_line": 126,
      "end_line": 182,
      "content_hash": "060c4326d5756af4440ebeb285311f31ee132f3b",
      "content": "func TestSearchImplementations(t *testing.T) {\n\tt.Parallel()\n\ttempDir := t.TempDir()\n\n\tfor path, content := range map[string]string{\n\t\t\"file1.go\":         \"package main\\nfunc main() {\\n\\tfmt.Println(\\\"hello world\\\")\\n}\",\n\t\t\"file2.js\":         \"console.log('hello world');\",\n\t\t\"file3.txt\":        \"hello world from text file\",\n\t\t\"binary.exe\":       \"\\x00\\x01\\x02\\x03\",\n\t\t\"empty.txt\":        \"\",\n\t\t\"subdir/nested.go\": \"package nested\\n// hello world comment\",\n\t\t\".hidden.txt\":      \"hello world in hidden file\",\n\t\t\"file4.txt\":        \"hello world from a banana\",\n\t\t\"file5.txt\":        \"hello world from a grape\",\n\t} {\n\t\tfullPath := filepath.Join(tempDir, path)\n\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(fullPath), 0o755))\n\t\trequire.NoError(t, os.WriteFile(fullPath, []byte(content), 0o644))\n\t}\n\n\trequire.NoError(t, os.WriteFile(filepath.Join(tempDir, \".gitignore\"), []byte(\"file4.txt\\n\"), 0o644))\n\trequire.NoError(t, os.WriteFile(filepath.Join(tempDir, \".nexoraignore\"), []byte(\"file5.txt\\n\"), 0o644))\n\n\tfor name, fn := range map[string]func(pattern, path, include string) ([]grepMatch, error){\n\t\t\"regex\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchFilesWithRegex(pattern, path, include)\n\t\t},\n\t\t\"rg\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchWithRipgrep(t.Context(), pattern, path, include)\n\t\t},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif name == \"rg\" && getRg() == \"\" {\n\t\t\t\tt.Skip(\"rg is not in $PATH\")\n\t\t\t}\n\n\t\t\tmatches, err := fn(\"hello world\", tempDir, \"\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, len(matches), 4)\n\t\t\tfor _, match := range matches {\n\t\t\t\trequire.NotEmpty(t, match.path)\n\t\t\t\trequire.NotZero(t, match.lineNum)\n\t\t\t\trequire.NotEmpty(t, match.lineText)\n\t\t\t\trequire.NotZero(t, match.modTime)\n\t\t\t\trequire.NotContains(t, match.path, \".hidden.txt\")\n\t\t\t\trequire.NotContains(t, match.path, \"file4.txt\")\n\t\t\t\trequire.NotContains(t, match.path, \"file5.txt\")\n\t\t\t\trequire.NotContains(t, match.path, \"binary.exe\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Benchmark to show performance improvement",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkRegexCacheVsCompile_183": {
      "name": "BenchmarkRegexCacheVsCompile",
      "type": "function",
      "start_line": 183,
      "end_line": 205,
      "content_hash": "5dd0e154f6371840b7791d8067f4256db49ba691",
      "content": "func BenchmarkRegexCacheVsCompile(b *testing.B) {\n\tcache := newRegexCache()\n\tpattern := \"test.*pattern.*[0-9]+\"\n\n\tb.Run(\"WithCache\", func(b *testing.B) {\n\t\tfor b.Loop() {\n\t\t\t_, err := cache.get(pattern)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"WithoutCache\", func(b *testing.B) {\n\t\tfor b.Loop() {\n\t\t\t_, err := regexp.Compile(pattern)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestIsTextFile_206": {
      "name": "TestIsTextFile",
      "type": "function",
      "start_line": 206,
      "end_line": 397,
      "content_hash": "d7f81894262e5303731c3dc75cfea0712e3a67e3",
      "content": "func TestIsTextFile(t *testing.T) {\n\tt.Parallel()\n\ttempDir := t.TempDir()\n\n\ttests := []struct {\n\t\tname     string\n\t\tfilename string\n\t\tcontent  []byte\n\t\twantText bool\n\t}{\n\t\t{\n\t\t\tname:     \"go file\",\n\t\t\tfilename: \"test.go\",\n\t\t\tcontent:  []byte(\"package main\\n\\nfunc main() {}\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"yaml file\",\n\t\t\tfilename: \"config.yaml\",\n\t\t\tcontent:  []byte(\"key: value\\nlist:\\n  - item1\\n  - item2\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"yml file\",\n\t\t\tfilename: \"config.yml\",\n\t\t\tcontent:  []byte(\"key: value\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"json file\",\n\t\t\tfilename: \"data.json\",\n\t\t\tcontent:  []byte(`{\"key\": \"value\"}`),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"javascript file\",\n\t\t\tfilename: \"script.js\",\n\t\t\tcontent:  []byte(\"console.log('hello');\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"typescript file\",\n\t\t\tfilename: \"script.ts\",\n\t\t\tcontent:  []byte(\"const x: string = 'hello';\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"markdown file\",\n\t\t\tfilename: \"README.md\",\n\t\t\tcontent:  []byte(\"# Title\\n\\nSome content\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"shell script\",\n\t\t\tfilename: \"script.sh\",\n\t\t\tcontent:  []byte(\"#!/bin/bash\\necho 'hello'\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"python file\",\n\t\t\tfilename: \"script.py\",\n\t\t\tcontent:  []byte(\"print('hello')\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"xml file\",\n\t\t\tfilename: \"data.xml\",\n\t\t\tcontent:  []byte(\"<?xml version=\\\"1.0\\\"?>\\n<root></root>\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"plain text\",\n\t\t\tfilename: \"file.txt\",\n\t\t\tcontent:  []byte(\"plain text content\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"css file\",\n\t\t\tfilename: \"style.css\",\n\t\t\tcontent:  []byte(\"body { color: red; }\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"scss file\",\n\t\t\tfilename: \"style.scss\",\n\t\t\tcontent:  []byte(\"$primary: blue;\\nbody { color: $primary; }\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"sass file\",\n\t\t\tfilename: \"style.sass\",\n\t\t\tcontent:  []byte(\"$primary: blue\\nbody\\n  color: $primary\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"rust file\",\n\t\t\tfilename: \"main.rs\",\n\t\t\tcontent:  []byte(\"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"zig file\",\n\t\t\tfilename: \"main.zig\",\n\t\t\tcontent:  []byte(\"const std = @import(\\\"std\\\");\\npub fn main() void {}\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"java file\",\n\t\t\tfilename: \"Main.java\",\n\t\t\tcontent:  []byte(\"public class Main {\\n    public static void main(String[] args) {}\\n}\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"c file\",\n\t\t\tfilename: \"main.c\",\n\t\t\tcontent:  []byte(\"#include <stdio.h>\\nint main() { return 0; }\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"cpp file\",\n\t\t\tfilename: \"main.cpp\",\n\t\t\tcontent:  []byte(\"#include <iostream>\\nint main() { return 0; }\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"fish shell\",\n\t\t\tfilename: \"script.fish\",\n\t\t\tcontent:  []byte(\"#!/usr/bin/env fish\\necho 'hello'\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"powershell file\",\n\t\t\tfilename: \"script.ps1\",\n\t\t\tcontent:  []byte(\"Write-Host 'Hello, World!'\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd batch file\",\n\t\t\tfilename: \"script.bat\",\n\t\t\tcontent:  []byte(\"@echo off\\necho Hello, World!\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd file\",\n\t\t\tfilename: \"script.cmd\",\n\t\t\tcontent:  []byte(\"@echo off\\necho Hello, World!\\n\"),\n\t\t\twantText: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"binary exe\",\n\t\t\tfilename: \"binary.exe\",\n\t\t\tcontent:  []byte{0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00},\n\t\t\twantText: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"png image\",\n\t\t\tfilename: \"image.png\",\n\t\t\tcontent:  []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A},\n\t\t\twantText: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"jpeg image\",\n\t\t\tfilename: \"image.jpg\",\n\t\t\tcontent:  []byte{0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46},\n\t\t\twantText: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"zip archive\",\n\t\t\tfilename: \"archive.zip\",\n\t\t\tcontent:  []byte{0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00},\n\t\t\twantText: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"pdf file\",\n\t\t\tfilename: \"document.pdf\",\n\t\t\tcontent:  []byte(\"%PDF-1.4\\n%\u00e2\u00e3\u00cf\u00d3\\n\"),\n\t\t\twantText: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfilePath := filepath.Join(tempDir, tt.filename)\n\t\t\trequire.NoError(t, os.WriteFile(filePath, tt.content, 0o644))\n\n\t\t\tgot := isTextFile(filePath)\n\t\t\trequire.Equal(t, tt.wantText, got, \"isTextFile(%s) = %v, want %v\", tt.filename, got, tt.wantText)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestColumnMatch_398": {
      "name": "TestColumnMatch",
      "type": "function",
      "start_line": 398,
      "end_line": 427,
      "content_hash": "40afb1b3b4775e26b42366fc2b59bcafe54adc7e",
      "content": "func TestColumnMatch(t *testing.T) {\n\tt.Parallel()\n\n\t// Test both implementations\n\tfor name, fn := range map[string]func(pattern, path, include string) ([]grepMatch, error){\n\t\t\"regex\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchFilesWithRegex(pattern, path, include)\n\t\t},\n\t\t\"rg\": func(pattern, path, include string) ([]grepMatch, error) {\n\t\t\treturn searchWithRipgrep(t.Context(), pattern, path, include)\n\t\t},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif name == \"rg\" && getRg() == \"\" {\n\t\t\t\tt.Skip(\"rg is not in $PATH\")\n\t\t\t}\n\n\t\t\tmatches, err := fn(\"THIS\", \"./testdata/\", \"\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, matches, 1)\n\t\t\tmatch := matches[0]\n\t\t\trequire.Equal(t, 2, match.lineNum)\n\t\t\trequire.Equal(t, 14, match.charNum)\n\t\t\trequire.Equal(t, \"I wanna grep THIS particular word\", match.lineText)\n\t\t\trequire.Equal(t, \"testdata/grep.txt\", filepath.ToSlash(filepath.Clean(match.path)))\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}