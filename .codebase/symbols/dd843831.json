{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/concurrency_tests/traversal_concurrent_tests.rs",
  "file_hash": "4c21f3d60481c3251ab735b22e7fe0a3f6815d5c",
  "updated_at": "2025-12-26T17:34:19.715627",
  "symbols": {
    "function_setup_concurrent_storage_35": {
      "name": "setup_concurrent_storage",
      "type": "function",
      "start_line": 35,
      "end_line": 47,
      "content_hash": "e3238e8ca7e06042da38ef4e09c63c9e1d7013c9",
      "content": "fn setup_concurrent_storage() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = tempfile::tempdir().unwrap();\n    let path = temp_dir.path().to_str().unwrap();\n\n    let mut config = Config::default();\n    config.db_max_size_gb = Some(10);\n\n    let storage = HelixGraphStorage::new(path, config, Default::default()).unwrap();\n    (temp_dir, Arc::new(storage))\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_node_additions_48": {
      "name": "test_concurrent_node_additions",
      "type": "function",
      "start_line": 48,
      "end_line": 100,
      "content_hash": "3c9946cd713ab1a9647977e6902cf5d91688491f",
      "content": "fn test_concurrent_node_additions() {\n    // Tests multiple threads adding nodes concurrently\n    //\n    // EXPECTED: All nodes created successfully, no ID collisions\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    let num_threads = 4;\n    let nodes_per_thread = 25;\n    let barrier = Arc::new(Barrier::new(num_threads));\n\n    let handles: Vec<_> = (0..num_threads)\n        .map(|thread_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                for i in 0..nodes_per_thread {\n                    let arena = Bump::new();\n                    let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                    let label = format!(\"person_t{}_n{}\", thread_id, i);\n                    G::new_mut(&storage, &arena, &mut wtxn)\n                        .add_n(&label, None, None)\n                        .collect::<Result<Vec<_>,_>>().unwrap();\n\n                    wtxn.commit().unwrap();\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify: All nodes created\n    let _arena = Bump::new();\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let count = storage.nodes_db.len(&rtxn).unwrap();\n    assert_eq!(\n        count,\n        (num_threads * nodes_per_thread) as u64,\n        \"Expected {} nodes, found {}\",\n        num_threads * nodes_per_thread,\n        count\n    );\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_edge_additions_101": {
      "name": "test_concurrent_edge_additions",
      "type": "function",
      "start_line": 101,
      "end_line": 176,
      "content_hash": "d5fcc2628355f4bcca382f011c214d1e5ba3bb39",
      "content": "fn test_concurrent_edge_additions() {\n    // Tests multiple threads adding edges between nodes\n    //\n    // EXPECTED: All edges created, proper serialization\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create nodes first\n    let node_ids: Vec<u128> = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let ids: Vec<u128> = (0..10)\n            .map(|i| {\n                let label = format!(\"node_{}\", i);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id()\n            })\n            .collect();\n\n        wtxn.commit().unwrap();\n        ids\n    };\n\n    let num_threads = 4;\n    let edges_per_thread = 10;\n    let barrier = Arc::new(Barrier::new(num_threads));\n    let node_ids = Arc::new(node_ids);\n\n    let handles: Vec<_> = (0..num_threads)\n        .map(|thread_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n            let node_ids = Arc::clone(&node_ids);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                for i in 0..edges_per_thread {\n                    let arena = Bump::new();\n                    let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                    let source_idx = (thread_id * 2) % node_ids.len();\n                    let target_idx = (thread_id * 2 + 1) % node_ids.len();\n\n                    let label = format!(\"knows_t{}_e{}\", thread_id, i);\n                    G::new_mut(&storage, &arena, &mut wtxn)\n                        .add_edge(&label, None, node_ids[source_idx], node_ids[target_idx], false)\n                        .collect_to_obj().unwrap();\n\n                    wtxn.commit().unwrap();\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify: All edges created\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let count = storage.edges_db.len(&rtxn).unwrap();\n    assert_eq!(\n        count,\n        (num_threads * edges_per_thread) as u64,\n        \"Expected {} edges, found {}\",\n        num_threads * edges_per_thread,\n        count\n    );\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_reads_during_writes_177": {
      "name": "test_concurrent_reads_during_writes",
      "type": "function",
      "start_line": 177,
      "end_line": 306,
      "content_hash": "dd1d72ea29335585afc6acd3fa6ceb42729b985c",
      "content": "fn test_concurrent_reads_during_writes() {\n    // Tests concurrent traversals while writes are happening\n    //\n    // EXPECTED: Readers see consistent snapshots (MVCC)\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create initial graph structure\n    let root_id = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let root = G::new_mut(&storage, &arena, &mut wtxn)\n            .add_n(\"root\", None, None)\n            .collect::<Result<Vec<_>,_>>().unwrap()[0]\n            .id();\n\n        // Add initial neighbors\n        for i in 0..5 {\n            let label = format!(\"initial_{}\", i);\n            let neighbor_id = G::new_mut(&storage, &arena, &mut wtxn)\n                .add_n(&label, None, None)\n                .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                .id();\n\n            G::new_mut(&storage, &arena, &mut wtxn)\n                .add_edge(\"connects\", None, root, neighbor_id, false)\n                .collect_to_obj().unwrap();\n        }\n\n        wtxn.commit().unwrap();\n        root\n    };\n\n    let num_readers = 4;\n    let num_writers = 2;\n    let barrier = Arc::new(Barrier::new(num_readers + num_writers));\n\n    let mut handles = vec![];\n\n    // Spawn readers - traverse graph repeatedly\n    for reader_id in 0..num_readers {\n        let storage = Arc::clone(&storage);\n        let barrier = Arc::clone(&barrier);\n\n        handles.push(thread::spawn(move || {\n            barrier.wait();\n\n            let mut total_reads = 0;\n\n            for _ in 0..20 {\n                let arena = Bump::new();\n                let rtxn = storage.graph_env.read_txn().unwrap();\n\n                // Traverse from root\n                let neighbors = G::new(&storage, &rtxn, &arena)\n                    .n_from_id(&root_id)\n                    .out_node(\"connects\")\n                    .collect::<Result<Vec<_>,_>>().unwrap();\n\n                // Should see at least initial neighbors\n                assert!(\n                    neighbors.len() >= 5,\n                    \"Reader {} saw only {} neighbors\",\n                    reader_id,\n                    neighbors.len()\n                );\n\n                total_reads += 1;\n                thread::sleep(std::time::Duration::from_millis(1));\n            }\n\n            total_reads\n        }));\n    }\n\n    // Spawn writers - add more neighbors\n    for writer_id in 0..num_writers {\n        let storage = Arc::clone(&storage);\n        let barrier = Arc::clone(&barrier);\n\n        handles.push(thread::spawn(move || {\n            barrier.wait();\n\n            for i in 0..10 {\n                let arena = Bump::new();\n                let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                let label = format!(\"writer_{}_node_{}\", writer_id, i);\n                let new_node_id = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id();\n\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"connects\", None, root_id, new_node_id, false)\n                    .collect_to_obj().unwrap();\n\n                wtxn.commit().unwrap();\n\n                thread::sleep(std::time::Duration::from_millis(2));\n            }\n            0 // Return value to match reader threads\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Final verification - should see all neighbors\n    let arena = Bump::new();\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let final_neighbors = G::new(&storage, &rtxn, &arena)\n        .n_from_id(&root_id)\n        .out_node(\"connects\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    let expected_count = 5 + (num_writers * 10);\n    assert_eq!(\n        final_neighbors.len(),\n        expected_count,\n        \"Expected {} neighbors, found {}\",\n        expected_count,\n        final_neighbors.len()\n    );\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_traversal_snapshot_isolation_307": {
      "name": "test_traversal_snapshot_isolation",
      "type": "function",
      "start_line": 307,
      "end_line": 401,
      "content_hash": "85aa485263ebe7e3e18f8b6042ecbb82d1c3fc33",
      "content": "fn test_traversal_snapshot_isolation() {\n    // Tests that long-lived read transaction sees consistent snapshot\n    //\n    // EXPECTED: Traversal results don't change during transaction lifetime\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create initial graph\n    let root_id = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let root = G::new_mut(&storage, &arena, &mut wtxn)\n            .add_n(\"root\", None, None)\n            .collect::<Result<Vec<_>,_>>().unwrap()[0]\n            .id();\n\n        for i in 0..5 {\n            let label = format!(\"node_{}\", i);\n            let node_id = G::new_mut(&storage, &arena, &mut wtxn)\n                .add_n(&label, None, None)\n                .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                .id();\n\n            G::new_mut(&storage, &arena, &mut wtxn)\n                .add_edge(\"links\", None, root, node_id, false)\n                .collect_to_obj().unwrap();\n        }\n\n        wtxn.commit().unwrap();\n        root\n    };\n\n    // Start long-lived read transaction\n    let arena = Bump::new();\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let initial_neighbors = G::new(&storage, &rtxn, &arena)\n        .n_from_id(&root_id)\n        .out_node(\"links\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let initial_count = initial_neighbors.len();\n    assert_eq!(initial_count, 5);\n\n    // In another thread, add more neighbors\n    let storage_clone = Arc::clone(&storage);\n    let handle = thread::spawn(move || {\n        for i in 0..10 {\n            let arena = Bump::new();\n            let mut wtxn = storage_clone.graph_env.write_txn().unwrap();\n\n            let label = format!(\"new_node_{}\", i);\n            let new_id = G::new_mut(&storage_clone, &arena, &mut wtxn)\n                .add_n(&label, None, None)\n                .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                .id();\n\n            G::new_mut(&storage_clone, &arena, &mut wtxn)\n                .add_edge(\"links\", None, root_id, new_id, false)\n                .collect_to_obj().unwrap();\n\n            wtxn.commit().unwrap();\n        }\n    });\n\n    handle.join().unwrap();\n\n    // Original transaction should still see same count (snapshot isolation)\n    let arena2 = Bump::new();\n    let current_neighbors = G::new(&storage, &rtxn, &arena2)\n        .n_from_id(&root_id)\n        .out_node(\"links\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    assert_eq!(\n        current_neighbors.len(),\n        initial_count,\n        \"Snapshot isolation violated: count changed from {} to {}\",\n        initial_count,\n        current_neighbors.len()\n    );\n\n    drop(rtxn);\n\n    // New transaction should see all neighbors\n    let arena3 = Bump::new();\n    let rtxn_new = storage.graph_env.read_txn().unwrap();\n    let final_neighbors = G::new(&storage, &rtxn_new, &arena3)\n        .n_from_id(&root_id)\n        .out_node(\"links\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(final_neighbors.len(), 15);\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_bidirectional_traversals_402": {
      "name": "test_concurrent_bidirectional_traversals",
      "type": "function",
      "start_line": 402,
      "end_line": 498,
      "content_hash": "872c01f1a50f0c13be3d774239e2401a01b03b23",
      "content": "fn test_concurrent_bidirectional_traversals() {\n    // Tests concurrent out() and in() traversals\n    //\n    // EXPECTED: Both directions remain consistent\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create bidirectional graph structure\n    let (source_ids, target_ids) = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let sources: Vec<u128> = (0..5)\n            .map(|i| {\n                let label = format!(\"source_{}\", i);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id()\n            })\n            .collect();\n\n        let targets: Vec<u128> = (0..5)\n            .map(|i| {\n                let label = format!(\"target_{}\", i);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id()\n            })\n            .collect();\n\n        // Create edges: each source -> all targets\n        for source_id in &sources {\n            for target_id in &targets {\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"points_to\", None, *source_id, *target_id, false)\n                    .collect_to_obj().unwrap();\n            }\n        }\n\n        wtxn.commit().unwrap();\n        (sources, targets)\n    };\n\n    let num_threads = 4;\n    let barrier = Arc::new(Barrier::new(num_threads));\n    let source_ids = Arc::new(source_ids);\n    let target_ids = Arc::new(target_ids);\n\n    let handles: Vec<_> = (0..num_threads)\n        .map(|thread_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n            let source_ids = Arc::clone(&source_ids);\n            let target_ids = Arc::clone(&target_ids);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                for _ in 0..20 {\n                    let arena = Bump::new();\n                    let rtxn = storage.graph_env.read_txn().unwrap();\n\n                    if thread_id % 2 == 0 {\n                        // Test out() traversals\n                        for source_id in source_ids.iter() {\n                            let neighbors = G::new(&storage, &rtxn, &arena)\n                                .n_from_id(source_id)\n                                .out_node(\"points_to\")\n                                .collect::<Result<Vec<_>,_>>().unwrap();\n                            assert_eq!(neighbors.len(), 5, \"Source should have 5 outgoing edges\");\n                        }\n                    } else {\n                        // Test in() traversals\n                        for target_id in target_ids.iter() {\n                            let neighbors = G::new(&storage, &rtxn, &arena)\n                                .n_from_id(target_id)\n                                .in_node(\"points_to\")\n                                .collect::<Result<Vec<_>,_>>().unwrap();\n                            assert_eq!(neighbors.len(), 5, \"Target should have 5 incoming edges\");\n                        }\n                    }\n\n                    thread::sleep(std::time::Duration::from_micros(100));\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_multi_hop_traversals_499": {
      "name": "test_concurrent_multi_hop_traversals",
      "type": "function",
      "start_line": 499,
      "end_line": 596,
      "content_hash": "5aa0ea07cd21bf57ec22fae87d1d5dd7d38414ec",
      "content": "fn test_concurrent_multi_hop_traversals() {\n    // Tests concurrent traversals across multiple hops\n    //\n    // EXPECTED: Multi-hop paths remain consistent\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create chain: root -> level1 nodes -> level2 nodes\n    let root_id = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let root = G::new_mut(&storage, &arena, &mut wtxn)\n            .add_n(\"root\", None, None)\n            .collect::<Result<Vec<_>,_>>().unwrap()[0]\n            .id();\n\n        // Create level 1 nodes\n        let level1_ids: Vec<u128> = (0..3)\n            .map(|i| {\n                let label = format!(\"level1_{}\", i);\n                let id = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id();\n\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"to_l1\", None, root, id, false)\n                    .collect_to_obj().unwrap();\n\n                id\n            })\n            .collect();\n\n        // Create level 2 nodes\n        for l1_id in level1_ids {\n            for i in 0..2 {\n                let label = format!(\"level2_{}\", i);\n                let l2_id = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id();\n\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"to_l2\", None, l1_id, l2_id, false)\n                    .collect_to_obj().unwrap();\n            }\n        }\n\n        wtxn.commit().unwrap();\n        root\n    };\n\n    let num_threads = 4;\n    let barrier = Arc::new(Barrier::new(num_threads));\n\n    let handles: Vec<_> = (0..num_threads)\n        .map(|_thread_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                for _ in 0..15 {\n                    let arena = Bump::new();\n                    let rtxn = storage.graph_env.read_txn().unwrap();\n\n                    // Traverse: root -> level1\n                    let level1 = G::new(&storage, &rtxn, &arena)\n                        .n_from_id(&root_id)\n                        .out_node(\"to_l1\")\n                        .collect::<Result<Vec<_>,_>>().unwrap();\n                    assert_eq!(level1.len(), 3, \"Should have 3 level1 nodes\");\n\n                    // For each level1, traverse to level2\n                    for l1_node in level1 {\n                        let arena2 = Bump::new();\n                        let level2 = G::new(&storage, &rtxn, &arena2)\n                            .n_from_id(&l1_node.id())\n                            .out_node(\"to_l2\")\n                            .collect::<Result<Vec<_>,_>>().unwrap();\n                        assert_eq!(level2.len(), 2, \"Each level1 should have 2 level2 nodes\");\n                    }\n\n                    thread::sleep(std::time::Duration::from_micros(200));\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_concurrent_graph_topology_consistency_597": {
      "name": "test_concurrent_graph_topology_consistency",
      "type": "function",
      "start_line": 597,
      "end_line": 682,
      "content_hash": "d9643dcf846aecbf30fd277f84bea40594e5d159",
      "content": "fn test_concurrent_graph_topology_consistency() {\n    // Tests that graph topology remains valid under concurrent operations\n    //\n    // EXPECTED: No broken edges, all edges point to valid nodes\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    let num_writers = 4;\n    let nodes_per_writer = 10;\n    let barrier = Arc::new(Barrier::new(num_writers));\n\n    let handles: Vec<_> = (0..num_writers)\n        .map(|writer_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                // Each writer creates nodes and edges\n                for i in 0..nodes_per_writer {\n                    let arena = Bump::new();\n                    let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                    let label1 = format!(\"w{}_n{}_a\", writer_id, i);\n                    let label2 = format!(\"w{}_n{}_b\", writer_id, i);\n\n                    let node1_id = G::new_mut(&storage, &arena, &mut wtxn)\n                        .add_n(&label1, None, None)\n                        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                        .id();\n\n                    let node2_id = G::new_mut(&storage, &arena, &mut wtxn)\n                        .add_n(&label2, None, None)\n                        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                        .id();\n\n                    G::new_mut(&storage, &arena, &mut wtxn)\n                        .add_edge(\"connects\", None, node1_id, node2_id, false)\n                        .collect_to_obj().unwrap();\n\n                    wtxn.commit().unwrap();\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify topology: all edges should be valid\n    let arena = Bump::new();\n    let rtxn = storage.graph_env.read_txn().unwrap();\n\n    // Count nodes and edges\n    let node_count = storage.nodes_db.len(&rtxn).unwrap();\n    let edge_count = storage.edges_db.len(&rtxn).unwrap();\n\n    let expected_nodes = (num_writers * nodes_per_writer * 2) as u64; // 2 nodes per iteration\n    let expected_edges = (num_writers * nodes_per_writer) as u64;\n\n    assert_eq!(node_count, expected_nodes, \"Node count mismatch\");\n    assert_eq!(edge_count, expected_edges, \"Edge count mismatch\");\n\n    // Verify all edges point to valid nodes\n    for result in storage.edges_db.iter(&rtxn).unwrap() {\n        let (edge_id, edge_bytes) = result.unwrap();\n        let edge = crate::utils::items::Edge::from_bincode_bytes(edge_id, &edge_bytes, &arena).unwrap();\n\n        // Verify source exists\n        assert!(\n            storage.nodes_db.get(&rtxn, &edge.from_node).unwrap().is_some(),\n            \"Edge source node not found\"\n        );\n\n        // Verify target exists\n        assert!(\n            storage.nodes_db.get(&rtxn, &edge.to_node).unwrap().is_some(),\n            \"Edge target node not found\"\n        );\n    }\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_concurrent_mixed_operations_683": {
      "name": "test_stress_concurrent_mixed_operations",
      "type": "function",
      "start_line": 683,
      "end_line": 787,
      "content_hash": "b096762b291bd8e4cf835be653e918b42fe5135d",
      "content": "fn test_stress_concurrent_mixed_operations() {\n    // Stress test: sustained mixed read/write operations\n    //\n    // EXPECTED: No panics, deadlocks, or corruption\n\n    let (_temp_dir, storage) = setup_concurrent_storage();\n\n    // Create initial graph\n    let root_ids: Vec<u128> = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let ids = (0..3)\n            .map(|i| {\n                let label = format!(\"root_{}\", i);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id()\n            })\n            .collect();\n\n        wtxn.commit().unwrap();\n        ids\n    };\n\n    let duration = std::time::Duration::from_secs(2);\n    let start = std::time::Instant::now();\n    let root_ids = Arc::new(root_ids);\n\n    let mut handles = vec![];\n\n    // Spawn writers\n    for writer_id in 0..2 {\n        let storage = Arc::clone(&storage);\n        let root_ids = Arc::clone(&root_ids);\n\n        handles.push(thread::spawn(move || {\n            let mut write_count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                let label = format!(\"w{}_n{}\", writer_id, write_count);\n                let new_id = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>,_>>().unwrap()[0]\n                    .id();\n\n                let root_idx = write_count % root_ids.len();\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"links\", None, root_ids[root_idx], new_id, false)\n                    .collect_to_obj().unwrap();\n\n                wtxn.commit().unwrap();\n                write_count += 1;\n            }\n            write_count\n        }));\n    }\n\n    // Spawn readers\n    for _reader_id in 0..4 {\n        let storage = Arc::clone(&storage);\n        let root_ids = Arc::clone(&root_ids);\n\n        handles.push(thread::spawn(move || {\n            let mut read_count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let rtxn = storage.graph_env.read_txn().unwrap();\n\n                for root_id in root_ids.iter() {\n                    let _neighbors = G::new(&storage, &rtxn, &arena)\n                        .n_from_id(root_id)\n                        .out_node(\"links\")\n                        .collect::<Result<Vec<_>,_>>().unwrap();\n                    read_count += 1;\n                }\n            }\n            read_count\n        }));\n    }\n\n    let mut write_counts = vec![];\n    let mut read_counts = vec![];\n\n    for (idx, handle) in handles.into_iter().enumerate() {\n        let count = handle.join().unwrap();\n        if idx < 2 {\n            write_counts.push(count);\n        } else {\n            read_counts.push(count);\n        }\n    }\n\n    let total_writes: usize = write_counts.iter().sum();\n    let total_reads: usize = read_counts.iter().sum();\n\n    println!(\"Stress test: {} writes, {} reads in {:?}\", total_writes, total_reads, duration);\n\n    // Should process many operations\n    assert!(total_writes > 50, \"Should perform many writes, got {}\", total_writes);\n    assert!(total_reads > 100, \"Should perform many reads, got {}\", total_reads);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}