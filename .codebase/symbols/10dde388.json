{
  "file_path": "/work/internal/shell/shell.go",
  "file_hash": "ed82835a7ebf9520db0d7bebd3afa6e116e973b0",
  "updated_at": "2025-12-26T17:34:21.550203",
  "symbols": {
    "interface_Logger_40": {
      "name": "Logger",
      "type": "interface",
      "start_line": 40,
      "end_line": 44,
      "content_hash": "b26f6a43a6cb5c282930a3570be9c414d1da259d",
      "content": "type Logger interface {\n\tInfoPersist(msg string, keysAndValues ...any)\n}\n\n// noopLogger is a logger that does nothing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_noopLogger_45": {
      "name": "noopLogger",
      "type": "struct",
      "start_line": 45,
      "end_line": 52,
      "content_hash": "8af5d216ff1fd9e53095dde89951eadbd3a03c26",
      "content": "type noopLogger struct{}\n\nfunc (noopLogger) InfoPersist(msg string, keysAndValues ...any) {}\n\n// BlockFunc is a function that determines if a command should be blocked\ntype BlockFunc func(args []string) bool\n\n// Shell provides cross-platform shell execution with optional state persistence",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Shell_53": {
      "name": "Shell",
      "type": "struct",
      "start_line": 53,
      "end_line": 61,
      "content_hash": "cd951c164ea306c7b25754499c19d117203cf8dc",
      "content": "type Shell struct {\n\tenv        []string\n\tcwd        string\n\tmu         sync.Mutex\n\tlogger     Logger\n\tblockFuncs []BlockFunc\n}\n\n// Options for creating a new shell",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Options_62": {
      "name": "Options",
      "type": "struct",
      "start_line": 62,
      "end_line": 69,
      "content_hash": "80dcdcb9090cf518d6cd80fb4c09c4fe1b49aa3e",
      "content": "type Options struct {\n\tWorkingDir string\n\tEnv        []string\n\tLogger     Logger\n\tBlockFuncs []BlockFunc\n}\n\n// NewShell creates a new shell instance with the given options",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewShell_70": {
      "name": "NewShell",
      "type": "function",
      "start_line": 70,
      "end_line": 98,
      "content_hash": "9dbc3853b676ea1c40b52ac7cac6d33702ee3b76",
      "content": "func NewShell(opts *Options) *Shell {\n\tif opts == nil {\n\t\topts = &Options{}\n\t}\n\n\tcwd := opts.WorkingDir\n\tif cwd == \"\" {\n\t\tcwd, _ = os.Getwd()\n\t}\n\n\tenv := opts.Env\n\tif env == nil {\n\t\tenv = os.Environ()\n\t}\n\n\tlogger := opts.Logger\n\tif logger == nil {\n\t\tlogger = noopLogger{}\n\t}\n\n\treturn &Shell{\n\t\tcwd:        cwd,\n\t\tenv:        env,\n\t\tlogger:     logger,\n\t\tblockFuncs: opts.BlockFuncs,\n\t}\n}\n\n// Exec executes a command in the shell",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Exec_99": {
      "name": "Exec",
      "type": "method",
      "start_line": 99,
      "end_line": 106,
      "content_hash": "6430c0173dc50b9716ffa103177a4a61d6ab159b",
      "content": "func (s *Shell) Exec(ctx context.Context, command string) (string, string, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\treturn s.exec(ctx, command)\n}\n\n// ExecStream executes a command in the shell with streaming output to provided writers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ExecStream_107": {
      "name": "ExecStream",
      "type": "method",
      "start_line": 107,
      "end_line": 114,
      "content_hash": "71a7fe7a055626ccbec3a5209b56cb4d12982ed8",
      "content": "func (s *Shell) ExecStream(ctx context.Context, command string, stdout, stderr io.Writer) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\treturn s.execStream(ctx, command, stdout, stderr)\n}\n\n// GetWorkingDir returns the current working directory",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetWorkingDir_115": {
      "name": "GetWorkingDir",
      "type": "method",
      "start_line": 115,
      "end_line": 121,
      "content_hash": "49bb2893fc6dbcbb50e6a9e306356fa56b46a8b2",
      "content": "func (s *Shell) GetWorkingDir() string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.cwd\n}\n\n// SetWorkingDir sets the working directory",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetWorkingDir_122": {
      "name": "SetWorkingDir",
      "type": "method",
      "start_line": 122,
      "end_line": 135,
      "content_hash": "a5e20da94bec6a50f345e5a3cac9d0260356d4fe",
      "content": "func (s *Shell) SetWorkingDir(dir string) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\t// Verify the directory exists\n\tif _, err := os.Stat(dir); err != nil {\n\t\treturn fmt.Errorf(\"directory does not exist: %w\", err)\n\t}\n\n\ts.cwd = dir\n\treturn nil\n}\n\n// GetEnv returns a copy of the environment variables",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetEnv_136": {
      "name": "GetEnv",
      "type": "method",
      "start_line": 136,
      "end_line": 145,
      "content_hash": "1d44f292b76cb97a60a0cd7ede9eaec432f614fa",
      "content": "func (s *Shell) GetEnv() []string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tenv := make([]string, len(s.env))\n\tcopy(env, s.env)\n\treturn env\n}\n\n// SetEnv sets an environment variable",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetEnv_146": {
      "name": "SetEnv",
      "type": "method",
      "start_line": 146,
      "end_line": 161,
      "content_hash": "6fda7ed1cd75182ace53d73305e52b9e4db39e71",
      "content": "func (s *Shell) SetEnv(key, value string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\t// Update or add the environment variable\n\tkeyPrefix := key + \"=\"\n\tfor i, env := range s.env {\n\t\tif strings.HasPrefix(env, keyPrefix) {\n\t\t\ts.env[i] = keyPrefix + value\n\t\t\treturn\n\t\t}\n\t}\n\ts.env = append(s.env, keyPrefix+value)\n}\n\n// SetBlockFuncs sets the command block functions for the shell",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetBlockFuncs_162": {
      "name": "SetBlockFuncs",
      "type": "method",
      "start_line": 162,
      "end_line": 168,
      "content_hash": "517e0aa394514840fc70412cdb08f71b8e9a309a",
      "content": "func (s *Shell) SetBlockFuncs(blockFuncs []BlockFunc) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.blockFuncs = blockFuncs\n}\n\n// CommandsBlocker creates a BlockFunc that blocks exact command matches",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_CommandsBlocker_169": {
      "name": "CommandsBlocker",
      "type": "function",
      "start_line": 169,
      "end_line": 184,
      "content_hash": "86e4e4f8eba49a49998c803ef2200ff548734ed2",
      "content": "func CommandsBlocker(cmds []string) BlockFunc {\n\tbannedSet := make(map[string]struct{})\n\tfor _, cmd := range cmds {\n\t\tbannedSet[cmd] = struct{}{}\n\t}\n\n\treturn func(args []string) bool {\n\t\tif len(args) == 0 {\n\t\t\treturn false\n\t\t}\n\t\t_, ok := bannedSet[args[0]]\n\t\treturn ok\n\t}\n}\n\n// ArgumentsBlocker creates a BlockFunc that blocks specific subcommand",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ArgumentsBlocker_185": {
      "name": "ArgumentsBlocker",
      "type": "function",
      "start_line": 185,
      "end_line": 202,
      "content_hash": "2cb5e497aeb3e27db20174a2a02e15f58e53dabc",
      "content": "func ArgumentsBlocker(cmd string, args []string, flags []string) BlockFunc {\n\treturn func(parts []string) bool {\n\t\tif len(parts) == 0 || parts[0] != cmd {\n\t\t\treturn false\n\t\t}\n\n\t\targParts, flagParts := splitArgsFlags(parts[1:])\n\t\tif len(argParts) < len(args) || len(flagParts) < len(flags) {\n\t\t\treturn false\n\t\t}\n\n\t\targsMatch := slices.Equal(argParts[:len(args)], args)\n\t\tflagsMatch := slice.IsSubset(flags, flagParts)\n\n\t\treturn argsMatch && flagsMatch\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_splitArgsFlags_203": {
      "name": "splitArgsFlags",
      "type": "function",
      "start_line": 203,
      "end_line": 220,
      "content_hash": "6df5237fe7e0ac5d00a4cb9dc270a8f2a9dddd30",
      "content": "func splitArgsFlags(parts []string) (args []string, flags []string) {\n\targs = make([]string, 0, len(parts))\n\tflags = make([]string, 0, len(parts))\n\tfor _, part := range parts {\n\t\tif strings.HasPrefix(part, \"-\") {\n\t\t\t// Extract flag name before '=' if present\n\t\t\tflag := part\n\t\t\tif idx := strings.IndexByte(part, '='); idx != -1 {\n\t\t\t\tflag = part[:idx]\n\t\t\t}\n\t\t\tflags = append(flags, flag)\n\t\t} else {\n\t\t\targs = append(args, part)\n\t\t}\n\t}\n\treturn args, flags\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_blockHandler_221": {
      "name": "blockHandler",
      "type": "method",
      "start_line": 221,
      "end_line": 239,
      "content_hash": "a8db65a2d1c404550280976f9e034a238febbf41",
      "content": "func (s *Shell) blockHandler() func(next interp.ExecHandlerFunc) interp.ExecHandlerFunc {\n\treturn func(next interp.ExecHandlerFunc) interp.ExecHandlerFunc {\n\t\treturn func(ctx context.Context, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn next(ctx, args)\n\t\t\t}\n\n\t\t\tfor _, blockFunc := range s.blockFuncs {\n\t\t\t\tif blockFunc(args) {\n\t\t\t\t\treturn fmt.Errorf(\"command is not allowed for security reasons: %s\", strings.Join(args, \" \"))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn next(ctx, args)\n\t\t}\n\t}\n}\n\n// newInterp creates a new interpreter with the current shell state",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_newInterp_240": {
      "name": "newInterp",
      "type": "method",
      "start_line": 240,
      "end_line": 250,
      "content_hash": "0977d446b56bcae66d780a5abfc7d03857442206",
      "content": "func (s *Shell) newInterp(stdout, stderr io.Writer) (*interp.Runner, error) {\n\treturn interp.New(\n\t\tinterp.StdIO(nil, stdout, stderr),\n\t\tinterp.Interactive(false),\n\t\tinterp.Env(expand.ListEnviron(s.env...)),\n\t\tinterp.Dir(s.cwd),\n\t\tinterp.ExecHandlers(s.execHandlers()...),\n\t)\n}\n\n// updateShellFromRunner updates the shell from the interpreter after execution",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateShellFromRunner_251": {
      "name": "updateShellFromRunner",
      "type": "method",
      "start_line": 251,
      "end_line": 259,
      "content_hash": "00ff90fb6521193905a48599913f0a7d170d9347",
      "content": "func (s *Shell) updateShellFromRunner(runner *interp.Runner) {\n\ts.cwd = runner.Dir\n\ts.env = nil\n\tfor name, vr := range runner.Vars {\n\t\ts.env = append(s.env, fmt.Sprintf(\"%s=%s\", name, vr.Str))\n\t}\n}\n\n// execCommon is the shared implementation for executing commands",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_execCommon_260": {
      "name": "execCommon",
      "type": "method",
      "start_line": 260,
      "end_line": 277,
      "content_hash": "b2776991942ef6d911f646bef3930be6435976ee",
      "content": "func (s *Shell) execCommon(ctx context.Context, command string, stdout, stderr io.Writer) error {\n\tline, err := syntax.NewParser().Parse(strings.NewReader(command), \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not parse command: %w\", err)\n\t}\n\n\trunner, err := s.newInterp(stdout, stderr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not run command: %w\", err)\n\t}\n\n\terr = runner.Run(ctx, line)\n\ts.updateShellFromRunner(runner)\n\ts.logger.InfoPersist(\"command finished\", \"command\", command, \"err\", err)\n\treturn err\n}\n\n// exec executes commands using a cross-platform shell interpreter.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_exec_278": {
      "name": "exec",
      "type": "method",
      "start_line": 278,
      "end_line": 284,
      "content_hash": "c96a5e7e78d933520f28de8eea84a74cfa2ab8fb",
      "content": "func (s *Shell) exec(ctx context.Context, command string) (string, string, error) {\n\tvar stdout, stderr bytes.Buffer\n\terr := s.execCommon(ctx, command, &stdout, &stderr)\n\treturn stdout.String(), stderr.String(), err\n}\n\n// execStream executes commands using POSIX shell emulation with streaming output",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_execStream_285": {
      "name": "execStream",
      "type": "method",
      "start_line": 285,
      "end_line": 288,
      "content_hash": "985e1c57809b30a9cd73bf8f6b9896aa7fc9a568",
      "content": "func (s *Shell) execStream(ctx context.Context, command string, stdout, stderr io.Writer) error {\n\treturn s.execCommon(ctx, command, stdout, stderr)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_execHandlers_289": {
      "name": "execHandlers",
      "type": "method",
      "start_line": 289,
      "end_line": 299,
      "content_hash": "9ed7056d49d97b21b161b960940912e7bf3afb3f",
      "content": "func (s *Shell) execHandlers() []func(next interp.ExecHandlerFunc) interp.ExecHandlerFunc {\n\thandlers := []func(next interp.ExecHandlerFunc) interp.ExecHandlerFunc{\n\t\ts.blockHandler(),\n\t}\n\tif useGoCoreUtils {\n\t\thandlers = append(handlers, coreutils.ExecHandler)\n\t}\n\treturn handlers\n}\n\n// IsInterrupt checks if an error is due to interruption",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_IsInterrupt_300": {
      "name": "IsInterrupt",
      "type": "function",
      "start_line": 300,
      "end_line": 305,
      "content_hash": "cf2cb7b6e16bdefbbd6cba51af798bd10e009c8d",
      "content": "func IsInterrupt(err error) bool {\n\treturn errors.Is(err, context.Canceled) ||\n\t\terrors.Is(err, context.DeadlineExceeded)\n}\n\n// ExitCode extracts the exit code from an error",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ExitCode_306": {
      "name": "ExitCode",
      "type": "function",
      "start_line": 306,
      "end_line": 315,
      "content_hash": "2ee99ad171a108254b34126c3b76f42dff31b7de",
      "content": "func ExitCode(err error) int {\n\tif err == nil {\n\t\treturn 0\n\t}\n\tvar exitErr interp.ExitStatus\n\tif errors.As(err, &exitErr) {\n\t\treturn int(exitErr)\n\t}\n\treturn 1\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}