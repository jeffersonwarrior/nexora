{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/storage_tests.rs",
  "file_hash": "c69d1b3429da9921603bd2fcd0941fda389c86af",
  "updated_at": "2025-12-26T17:34:24.265952",
  "symbols": {
    "function_setup_test_storage_8": {
      "name": "setup_test_storage",
      "type": "function",
      "start_line": 8,
      "end_line": 23,
      "content_hash": "d435321a873a08fc4c634f48794ed7db2031bffd",
      "content": "fn setup_test_storage() -> (HelixGraphStorage, TempDir) {\n    let temp_dir = TempDir::new().unwrap();\n    let config = Config::default();\n    let version_info = VersionInfo::default();\n\n    let storage =\n        HelixGraphStorage::new(temp_dir.path().to_str().unwrap(), config, version_info).unwrap();\n\n    (storage, temp_dir)\n}\n\n// ============================================================================\n// Key Packing/Unpacking Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_key_24": {
      "name": "test_node_key",
      "type": "function",
      "start_line": 24,
      "end_line": 30,
      "content_hash": "1db222f93b4d00f6596a761b2bc9c9d424a68553",
      "content": "fn test_node_key() {\n    let id = 12345u128;\n    let key = HelixGraphStorage::node_key(&id);\n    assert_eq!(*key, id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_key_31": {
      "name": "test_edge_key",
      "type": "function",
      "start_line": 31,
      "end_line": 37,
      "content_hash": "bded424e83ba7b71cdb8c1f2fbf9155e6502ef24",
      "content": "fn test_edge_key() {\n    let id = 67890u128;\n    let key = HelixGraphStorage::edge_key(&id);\n    assert_eq!(*key, id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_38": {
      "name": "test_out_edge_key",
      "type": "function",
      "start_line": 38,
      "end_line": 59,
      "content_hash": "cad7f673f48d560eeb11f7f680671dbdf13bceda",
      "content": "fn test_out_edge_key() {\n    let from_node_id = 100u128;\n    let label = [1, 2, 3, 4];\n\n    let key = HelixGraphStorage::out_edge_key(&from_node_id, &label);\n\n    // Verify key structure\n    assert_eq!(key.len(), 20);\n\n    // Verify node ID is in first 16 bytes\n    let node_id_bytes = &key[0..16];\n    assert_eq!(\n        u128::from_be_bytes(node_id_bytes.try_into().unwrap()),\n        from_node_id\n    );\n\n    // Verify label is in last 4 bytes\n    let label_bytes = &key[16..20];\n    assert_eq!(label_bytes, &label);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_edge_key_60": {
      "name": "test_in_edge_key",
      "type": "function",
      "start_line": 60,
      "end_line": 81,
      "content_hash": "dc10932273e3f7a962c97fca607cde76e00c06d5",
      "content": "fn test_in_edge_key() {\n    let to_node_id = 200u128;\n    let label = [5, 6, 7, 8];\n\n    let key = HelixGraphStorage::in_edge_key(&to_node_id, &label);\n\n    // Verify key structure\n    assert_eq!(key.len(), 20);\n\n    // Verify node ID is in first 16 bytes\n    let node_id_bytes = &key[0..16];\n    assert_eq!(\n        u128::from_be_bytes(node_id_bytes.try_into().unwrap()),\n        to_node_id\n    );\n\n    // Verify label is in last 4 bytes\n    let label_bytes = &key[16..20];\n    assert_eq!(label_bytes, &label);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_deterministic_82": {
      "name": "test_out_edge_key_deterministic",
      "type": "function",
      "start_line": 82,
      "end_line": 92,
      "content_hash": "8cca357b2bca3244f313df8dee498199c60c7a4a",
      "content": "fn test_out_edge_key_deterministic() {\n    let from_node_id = 42u128;\n    let label = [9, 8, 7, 6];\n\n    let key1 = HelixGraphStorage::out_edge_key(&from_node_id, &label);\n    let key2 = HelixGraphStorage::out_edge_key(&from_node_id, &label);\n\n    assert_eq!(key1, key2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_edge_key_deterministic_93": {
      "name": "test_in_edge_key_deterministic",
      "type": "function",
      "start_line": 93,
      "end_line": 103,
      "content_hash": "d4f32cc8ce58e178d4b236cc21f96178afd8dbf1",
      "content": "fn test_in_edge_key_deterministic() {\n    let to_node_id = 84u128;\n    let label = [1, 1, 1, 1];\n\n    let key1 = HelixGraphStorage::in_edge_key(&to_node_id, &label);\n    let key2 = HelixGraphStorage::in_edge_key(&to_node_id, &label);\n\n    assert_eq!(key1, key2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_edge_data_104": {
      "name": "test_pack_edge_data",
      "type": "function",
      "start_line": 104,
      "end_line": 128,
      "content_hash": "49eed9cd70dfaad2796c9fc1a22385552dbcf59b",
      "content": "fn test_pack_edge_data() {\n    let edge_id = 123u128;\n    let node_id = 456u128;\n\n    let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n\n    // Verify packed data structure\n    assert_eq!(packed.len(), 32);\n\n    // Verify edge ID is in first 16 bytes\n    let edge_id_bytes = &packed[0..16];\n    assert_eq!(\n        u128::from_be_bytes(edge_id_bytes.try_into().unwrap()),\n        edge_id\n    );\n\n    // Verify node ID is in last 16 bytes\n    let node_id_bytes = &packed[16..32];\n    assert_eq!(\n        u128::from_be_bytes(node_id_bytes.try_into().unwrap()),\n        node_id\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unpack_adj_edge_data_129": {
      "name": "test_unpack_adj_edge_data",
      "type": "function",
      "start_line": 129,
      "end_line": 141,
      "content_hash": "90a4856c6eae1b8f9eba7bf1d325e0e4003ae6af",
      "content": "fn test_unpack_adj_edge_data() {\n    let edge_id = 789u128;\n    let node_id = 1011u128;\n\n    let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n    let (unpacked_edge_id, unpacked_node_id) =\n        HelixGraphStorage::unpack_adj_edge_data(&packed).unwrap();\n\n    assert_eq!(unpacked_edge_id, edge_id);\n    assert_eq!(unpacked_node_id, node_id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_unpack_edge_data_roundtrip_142": {
      "name": "test_pack_unpack_edge_data_roundtrip",
      "type": "function",
      "start_line": 142,
      "end_line": 170,
      "content_hash": "cd59d40381538645559465caa910d839bed668cb",
      "content": "fn test_pack_unpack_edge_data_roundtrip() {\n    let test_cases = vec![\n        (0u128, 0u128),\n        (1u128, 1u128),\n        (u128::MAX, u128::MAX),\n        (12345u128, 67890u128),\n        (u128::MAX / 2, u128::MAX / 3),\n    ];\n\n    for (edge_id, node_id) in test_cases {\n        let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n        let (unpacked_edge, unpacked_node) =\n            HelixGraphStorage::unpack_adj_edge_data(&packed).unwrap();\n\n        assert_eq!(\n            unpacked_edge, edge_id,\n            \"Edge ID mismatch for ({}, {})\",\n            edge_id, node_id\n        );\n        assert_eq!(\n            unpacked_node, node_id,\n            \"Node ID mismatch for ({}, {})\",\n            edge_id, node_id\n        );\n    }\n}\n\n#[test]\n#[should_panic]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unpack_adj_edge_data_invalid_length_171": {
      "name": "test_unpack_adj_edge_data_invalid_length",
      "type": "function",
      "start_line": 171,
      "end_line": 182,
      "content_hash": "2dc55d63cc5517ab774dcb8a1836f461014b2a2f",
      "content": "fn test_unpack_adj_edge_data_invalid_length() {\n    let invalid_data = vec![1u8, 2, 3, 4, 5]; // Too short\n\n    // This will panic when trying to slice the data\n    let _ = HelixGraphStorage::unpack_adj_edge_data(&invalid_data);\n}\n\n// ============================================================================\n// Secondary Index Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_create_secondary_index_183": {
      "name": "test_create_secondary_index",
      "type": "function",
      "start_line": 183,
      "end_line": 193,
      "content_hash": "76158e0a1bb8732fc2f404c3c6ffe85469ad17b9",
      "content": "fn test_create_secondary_index() {\n    let (mut storage, _temp_dir) = setup_test_storage();\n\n    let result = storage.create_secondary_index(\"test_index\");\n    assert!(result.is_ok());\n\n    // Verify index was added to secondary_indices map\n    assert!(storage.secondary_indices.contains_key(\"test_index\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_secondary_index_194": {
      "name": "test_drop_secondary_index",
      "type": "function",
      "start_line": 194,
      "end_line": 209,
      "content_hash": "e35a604d0f8c3bb2c86d8b13597bd449e84ab0b0",
      "content": "fn test_drop_secondary_index() {\n    let (mut storage, _temp_dir) = setup_test_storage();\n\n    // Create an index first\n    storage.create_secondary_index(\"test_index\").unwrap();\n    assert!(storage.secondary_indices.contains_key(\"test_index\"));\n\n    // Drop the index\n    let result = storage.drop_secondary_index(\"test_index\");\n    assert!(result.is_ok());\n\n    // Verify index was removed\n    assert!(!storage.secondary_indices.contains_key(\"test_index\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_nonexistent_secondary_index_210": {
      "name": "test_drop_nonexistent_secondary_index",
      "type": "function",
      "start_line": 210,
      "end_line": 217,
      "content_hash": "d69148f337291f9290308c9e4f19832d0d09254e",
      "content": "fn test_drop_nonexistent_secondary_index() {\n    let (mut storage, _temp_dir) = setup_test_storage();\n\n    let result = storage.drop_secondary_index(\"nonexistent_index\");\n    assert!(result.is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_multiple_secondary_indices_218": {
      "name": "test_multiple_secondary_indices",
      "type": "function",
      "start_line": 218,
      "end_line": 235,
      "content_hash": "f6106114696345cecdd1a5ea1db81bdfc97db4e4",
      "content": "fn test_multiple_secondary_indices() {\n    let (mut storage, _temp_dir) = setup_test_storage();\n\n    storage.create_secondary_index(\"index1\").unwrap();\n    storage.create_secondary_index(\"index2\").unwrap();\n    storage.create_secondary_index(\"index3\").unwrap();\n\n    assert_eq!(storage.secondary_indices.len(), 3);\n    assert!(storage.secondary_indices.contains_key(\"index1\"));\n    assert!(storage.secondary_indices.contains_key(\"index2\"));\n    assert!(storage.secondary_indices.contains_key(\"index3\"));\n}\n\n// ============================================================================\n// Storage Creation and Configuration Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_storage_creation_236": {
      "name": "test_storage_creation",
      "type": "function",
      "start_line": 236,
      "end_line": 250,
      "content_hash": "579ecd66365de4312e370dc81dac67374843d9f2",
      "content": "fn test_storage_creation() {\n    let temp_dir = TempDir::new().unwrap();\n    let config = Config::default();\n    let version_info = VersionInfo::default();\n\n    let result = HelixGraphStorage::new(temp_dir.path().to_str().unwrap(), config, version_info);\n\n    assert!(result.is_ok());\n    let _ = result.unwrap();\n\n    // Verify databases were created\n    assert!(temp_dir.path().join(\"data.mdb\").exists());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_storage_config_251": {
      "name": "test_storage_config",
      "type": "function",
      "start_line": 251,
      "end_line": 263,
      "content_hash": "ca38fc228c4131dc54950dc9fddcf17de8addb04",
      "content": "fn test_storage_config() {\n    let schema = Some(\"test_schema\".to_string());\n    let graphvis = Some(\"name\".to_string());\n    let embedding = Some(\"openai\".to_string());\n\n    let config = StorageConfig::new(schema.clone(), graphvis.clone(), embedding.clone());\n\n    assert_eq!(config.schema, schema);\n    assert_eq!(config.graphvis_node_label, graphvis);\n    assert_eq!(config.embedding_model, embedding);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_storage_with_large_db_size_264": {
      "name": "test_storage_with_large_db_size",
      "type": "function",
      "start_line": 264,
      "end_line": 280,
      "content_hash": "4e8f5c5d6569bc68f28b73b3dcc33281f5101d1d",
      "content": "fn test_storage_with_large_db_size() {\n    let temp_dir = TempDir::new().unwrap();\n    let mut config = Config::default();\n    config.db_max_size_gb = Some(10000); // Should cap at 9998\n\n    let version_info = VersionInfo::default();\n\n    let result = HelixGraphStorage::new(temp_dir.path().to_str().unwrap(), config, version_info);\n\n    assert!(result.is_ok());\n}\n\n// ============================================================================\n// Edge Cases and Boundary Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_key_with_zero_id_281": {
      "name": "test_edge_key_with_zero_id",
      "type": "function",
      "start_line": 281,
      "end_line": 287,
      "content_hash": "0725121f442e10c5dc6f280fab228d9489be4e84",
      "content": "fn test_edge_key_with_zero_id() {\n    let id = 0u128;\n    let key = HelixGraphStorage::edge_key(&id);\n    assert_eq!(*key, 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_key_with_max_id_288": {
      "name": "test_edge_key_with_max_id",
      "type": "function",
      "start_line": 288,
      "end_line": 294,
      "content_hash": "9ec411a9b15cbff6ab0df6bd61c1a7a7e65797b2",
      "content": "fn test_edge_key_with_max_id() {\n    let id = u128::MAX;\n    let key = HelixGraphStorage::edge_key(&id);\n    assert_eq!(*key, u128::MAX);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_with_zero_values_295": {
      "name": "test_out_edge_key_with_zero_values",
      "type": "function",
      "start_line": 295,
      "end_line": 303,
      "content_hash": "fc0918c58b6ed4bec301769ba0f7f559d8e9bcc0",
      "content": "fn test_out_edge_key_with_zero_values() {\n    let from_node_id = 0u128;\n    let label = [0, 0, 0, 0];\n\n    let key = HelixGraphStorage::out_edge_key(&from_node_id, &label);\n    assert_eq!(key, [0u8; 20]);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_with_max_values_304": {
      "name": "test_out_edge_key_with_max_values",
      "type": "function",
      "start_line": 304,
      "end_line": 314,
      "content_hash": "c3b47d3aaf197ec50a16771b373777febed83ef8",
      "content": "fn test_out_edge_key_with_max_values() {\n    let from_node_id = u128::MAX;\n    let label = [255, 255, 255, 255];\n\n    let key = HelixGraphStorage::out_edge_key(&from_node_id, &label);\n\n    // All bytes should be 255\n    assert!(key.iter().all(|&b| b == 255));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_edge_data_with_zero_values_315": {
      "name": "test_pack_edge_data_with_zero_values",
      "type": "function",
      "start_line": 315,
      "end_line": 323,
      "content_hash": "b8ca3fbc0080e430b127dbff13be690e04b110a0",
      "content": "fn test_pack_edge_data_with_zero_values() {\n    let edge_id = 0u128;\n    let node_id = 0u128;\n\n    let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n    assert_eq!(packed, [0u8; 32]);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_edge_data_with_max_values_324": {
      "name": "test_pack_edge_data_with_max_values",
      "type": "function",
      "start_line": 324,
      "end_line": 336,
      "content_hash": "43eb9e41c39153b0b7d04add02553694e0c2adc0",
      "content": "fn test_pack_edge_data_with_max_values() {\n    let edge_id = u128::MAX;\n    let node_id = u128::MAX;\n\n    let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n    assert!(packed.iter().all(|&b| b == 255));\n}\n\n// ============================================================================\n// Additional Key Packing/Unpacking Edge Case Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_different_labels_produce_different_keys_337": {
      "name": "test_out_edge_key_different_labels_produce_different_keys",
      "type": "function",
      "start_line": 337,
      "end_line": 348,
      "content_hash": "ab35737de6b0df25f0f20fcfd2a5aa3359c833d6",
      "content": "fn test_out_edge_key_different_labels_produce_different_keys() {\n    let node_id = 100u128;\n    let label1 = [1, 2, 3, 4];\n    let label2 = [5, 6, 7, 8];\n\n    let key1 = HelixGraphStorage::out_edge_key(&node_id, &label1);\n    let key2 = HelixGraphStorage::out_edge_key(&node_id, &label2);\n\n    assert_ne!(key1, key2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_different_nodes_produce_different_keys_349": {
      "name": "test_out_edge_key_different_nodes_produce_different_keys",
      "type": "function",
      "start_line": 349,
      "end_line": 360,
      "content_hash": "c7a8b8615cb18401cbb19be80d7260c0d1ea4f11",
      "content": "fn test_out_edge_key_different_nodes_produce_different_keys() {\n    let node1 = 100u128;\n    let node2 = 200u128;\n    let label = [1, 2, 3, 4];\n\n    let key1 = HelixGraphStorage::out_edge_key(&node1, &label);\n    let key2 = HelixGraphStorage::out_edge_key(&node2, &label);\n\n    assert_ne!(key1, key2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_edge_key_different_labels_produce_different_keys_361": {
      "name": "test_in_edge_key_different_labels_produce_different_keys",
      "type": "function",
      "start_line": 361,
      "end_line": 372,
      "content_hash": "56d413f68603f1f0d55b210190534d07b2adb777",
      "content": "fn test_in_edge_key_different_labels_produce_different_keys() {\n    let node_id = 100u128;\n    let label1 = [1, 2, 3, 4];\n    let label2 = [5, 6, 7, 8];\n\n    let key1 = HelixGraphStorage::in_edge_key(&node_id, &label1);\n    let key2 = HelixGraphStorage::in_edge_key(&node_id, &label2);\n\n    assert_ne!(key1, key2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_and_in_edge_keys_same_for_same_node_and_label_373": {
      "name": "test_out_and_in_edge_keys_same_for_same_node_and_label",
      "type": "function",
      "start_line": 373,
      "end_line": 385,
      "content_hash": "4839fd150b699a5d50a2559073a59854106e3174",
      "content": "fn test_out_and_in_edge_keys_same_for_same_node_and_label() {\n    // This verifies that out_edge_key and in_edge_key produce the same key format\n    let node_id = 12345u128;\n    let label = [9, 8, 7, 6];\n\n    let out_key = HelixGraphStorage::out_edge_key(&node_id, &label);\n    let in_key = HelixGraphStorage::in_edge_key(&node_id, &label);\n\n    // They should be equal since they use the same structure\n    assert_eq!(out_key, in_key);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_edge_data_different_edge_ids_produce_different_data_386": {
      "name": "test_pack_edge_data_different_edge_ids_produce_different_data",
      "type": "function",
      "start_line": 386,
      "end_line": 397,
      "content_hash": "48c7cdd0735d1ccccc1bb03609d9e23844a83a3a",
      "content": "fn test_pack_edge_data_different_edge_ids_produce_different_data() {\n    let edge1 = 100u128;\n    let edge2 = 200u128;\n    let node_id = 500u128;\n\n    let packed1 = HelixGraphStorage::pack_edge_data(&edge1, &node_id);\n    let packed2 = HelixGraphStorage::pack_edge_data(&edge2, &node_id);\n\n    assert_ne!(packed1, packed2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_edge_data_different_node_ids_produce_different_data_398": {
      "name": "test_pack_edge_data_different_node_ids_produce_different_data",
      "type": "function",
      "start_line": 398,
      "end_line": 410,
      "content_hash": "90021dc7b47b8423bced4b15072b660b1451cbff",
      "content": "fn test_pack_edge_data_different_node_ids_produce_different_data() {\n    let edge_id = 100u128;\n    let node1 = 500u128;\n    let node2 = 600u128;\n\n    let packed1 = HelixGraphStorage::pack_edge_data(&edge_id, &node1);\n    let packed2 = HelixGraphStorage::pack_edge_data(&edge_id, &node2);\n\n    assert_ne!(packed1, packed2);\n}\n\n#[test]\n#[should_panic(expected = \"range end index\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unpack_adj_edge_data_short_slice_panics_411": {
      "name": "test_unpack_adj_edge_data_short_slice_panics",
      "type": "function",
      "start_line": 411,
      "end_line": 419,
      "content_hash": "5327d9b504116752561b48c24e1ac229c3a1b1c6",
      "content": "fn test_unpack_adj_edge_data_short_slice_panics() {\n    // 31 bytes - just one byte short\n    // Note: Current implementation panics on short slices during slice indexing\n    let short_data = vec![0u8; 31];\n    let _ = HelixGraphStorage::unpack_adj_edge_data(&short_data);\n}\n\n#[test]\n#[should_panic(expected = \"range end index\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unpack_adj_edge_data_empty_slice_panics_420": {
      "name": "test_unpack_adj_edge_data_empty_slice_panics",
      "type": "function",
      "start_line": 420,
      "end_line": 427,
      "content_hash": "ec6e68c12625fbadb34d2e0c7436e2275fd25026",
      "content": "fn test_unpack_adj_edge_data_empty_slice_panics() {\n    // Note: Current implementation panics on empty slices during slice indexing\n    let empty_data: Vec<u8> = vec![];\n    let _ = HelixGraphStorage::unpack_adj_edge_data(&empty_data);\n}\n\n#[test]\n#[should_panic(expected = \"range end index\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unpack_adj_edge_data_16_bytes_panics_428": {
      "name": "test_unpack_adj_edge_data_16_bytes_panics",
      "type": "function",
      "start_line": 428,
      "end_line": 435,
      "content_hash": "15ed82204a842faa24f4fc5362d0c68a42eb25dc",
      "content": "fn test_unpack_adj_edge_data_16_bytes_panics() {\n    // Only edge_id portion, missing node_id\n    // Note: Current implementation panics on partial slices during slice indexing\n    let partial_data = vec![0u8; 16];\n    let _ = HelixGraphStorage::unpack_adj_edge_data(&partial_data);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_pack_unpack_preserves_byte_order_436": {
      "name": "test_pack_unpack_preserves_byte_order",
      "type": "function",
      "start_line": 436,
      "end_line": 448,
      "content_hash": "ded50bb8f053f04779648ce0898f53a7b775d7ff",
      "content": "fn test_pack_unpack_preserves_byte_order() {\n    // Test with a value that has different high and low bytes\n    let edge_id = 0x0102030405060708090A0B0C0D0E0F10u128;\n    let node_id = 0x1112131415161718191A1B1C1D1E1F20u128;\n\n    let packed = HelixGraphStorage::pack_edge_data(&edge_id, &node_id);\n    let (unpacked_edge, unpacked_node) = HelixGraphStorage::unpack_adj_edge_data(&packed).unwrap();\n\n    assert_eq!(unpacked_edge, edge_id);\n    assert_eq!(unpacked_node, node_id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_key_preserves_node_id_byte_order_449": {
      "name": "test_out_edge_key_preserves_node_id_byte_order",
      "type": "function",
      "start_line": 449,
      "end_line": 496,
      "content_hash": "662d0fc9e3d2964b324e3caad3b6bd5527e7fe87",
      "content": "fn test_out_edge_key_preserves_node_id_byte_order() {\n    let node_id = 0x0102030405060708090A0B0C0D0E0F10u128;\n    let label = [0xAA, 0xBB, 0xCC, 0xDD];\n\n    let key = HelixGraphStorage::out_edge_key(&node_id, &label);\n\n    // Extract node_id from key and verify\n    let extracted_node_id = u128::from_be_bytes(key[0..16].try_into().unwrap());\n    assert_eq!(extracted_node_id, node_id);\n\n    // Verify label\n    assert_eq!(&key[16..20], &label);\n}\n\n// ============================================================================\n// Drop Operation Tests (Direct StorageMethods)\n// ============================================================================\n\nuse crate::helix_engine::storage_core::storage_methods::StorageMethods;\nuse crate::utils::{items::{Node, Edge}, label_hash::hash_label};\nuse bumpalo::Bump;\n\nfn create_test_node<'a>(arena: &'a Bump, id: u128, label: &str) -> Node<'a> {\n    Node {\n        id,\n        label: arena.alloc_str(label),\n        version: 1,\n        properties: None,\n    }\n}\n\nfn create_test_edge<'a>(\n    arena: &'a Bump,\n    id: u128,\n    label: &str,\n    from_node: u128,\n    to_node: u128,\n) -> Edge<'a> {\n    Edge {\n        id,\n        label: arena.alloc_str(label),\n        version: 1,\n        from_node,\n        to_node,\n        properties: None,\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_insert_node_497": {
      "name": "insert_node",
      "type": "function",
      "start_line": 497,
      "end_line": 506,
      "content_hash": "dbcc113a98de0eadd0aed19c1c2349c46f30eaeb",
      "content": "fn insert_node(storage: &HelixGraphStorage, node: &Node) {\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let bytes = node.to_bincode_bytes().unwrap();\n    storage\n        .nodes_db\n        .put(&mut txn, HelixGraphStorage::node_key(&node.id), &bytes)\n        .unwrap();\n    txn.commit().unwrap();\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_insert_edge_507": {
      "name": "insert_edge",
      "type": "function",
      "start_line": 507,
      "end_line": 529,
      "content_hash": "6a301f8098966522f89e99e241aa8ab95d59513f",
      "content": "fn insert_edge(storage: &HelixGraphStorage, edge: &Edge) {\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let bytes = edge.to_bincode_bytes().unwrap();\n    storage\n        .edges_db\n        .put(&mut txn, HelixGraphStorage::edge_key(&edge.id), &bytes)\n        .unwrap();\n\n    // Insert into out_edges_db\n    let label_hash = hash_label(edge.label, None);\n    let out_key = HelixGraphStorage::out_edge_key(&edge.from_node, &label_hash);\n    let edge_data = HelixGraphStorage::pack_edge_data(&edge.id, &edge.to_node);\n    storage.out_edges_db.put(&mut txn, &out_key, &edge_data).unwrap();\n\n    // Insert into in_edges_db\n    let in_key = HelixGraphStorage::in_edge_key(&edge.to_node, &label_hash);\n    let in_edge_data = HelixGraphStorage::pack_edge_data(&edge.id, &edge.from_node);\n    storage.in_edges_db.put(&mut txn, &in_key, &in_edge_data).unwrap();\n\n    txn.commit().unwrap();\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_no_edges_530": {
      "name": "test_drop_node_with_no_edges",
      "type": "function",
      "start_line": 530,
      "end_line": 556,
      "content_hash": "07b4e28acbc26fe77b3fd22e755880edf9c92ab3",
      "content": "fn test_drop_node_with_no_edges() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node = create_test_node(&arena, 1001, \"TestNode\");\n    insert_node(&storage, &node);\n\n    // Verify node exists\n    let txn = storage.graph_env.read_txn().unwrap();\n    let result = storage.get_node(&txn, &node.id, &arena);\n    assert!(result.is_ok());\n    drop(txn);\n\n    // Drop the node\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &node.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify node is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let result = storage.get_node(&txn, &node.id, &arena);\n    assert!(result.is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_outgoing_edges_only_557": {
      "name": "test_drop_node_with_outgoing_edges_only",
      "type": "function",
      "start_line": 557,
      "end_line": 593,
      "content_hash": "7bc4f76b9fe49f3c0b52f1a206a106404e235b29",
      "content": "fn test_drop_node_with_outgoing_edges_only() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 2001, \"Node1\");\n    let node2 = create_test_node(&arena, 2002, \"Node2\");\n    let edge = create_test_edge(&arena, 3001, \"CONNECTS\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge);\n\n    // Verify edge exists\n    let txn = storage.graph_env.read_txn().unwrap();\n    let result = storage.get_edge(&txn, &edge.id, &arena);\n    assert!(result.is_ok());\n    drop(txn);\n\n    // Drop node1 (has outgoing edge)\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &node1.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify node1 is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_node(&txn, &node1.id, &arena).is_err());\n\n    // Verify node2 still exists\n    assert!(storage.get_node(&txn, &node2.id, &arena).is_ok());\n\n    // Verify edge is gone (cascading delete)\n    assert!(storage.get_edge(&txn, &edge.id, &arena).is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_incoming_edges_only_594": {
      "name": "test_drop_node_with_incoming_edges_only",
      "type": "function",
      "start_line": 594,
      "end_line": 624,
      "content_hash": "b4a582581ab7309d4f0270e82c4372fcf24114ca",
      "content": "fn test_drop_node_with_incoming_edges_only() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 4001, \"Node1\");\n    let node2 = create_test_node(&arena, 4002, \"Node2\");\n    let edge = create_test_edge(&arena, 5001, \"CONNECTS\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge);\n\n    // Drop node2 (has incoming edge)\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &node2.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify node2 is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_node(&txn, &node2.id, &arena).is_err());\n\n    // Verify node1 still exists\n    assert!(storage.get_node(&txn, &node1.id, &arena).is_ok());\n\n    // Verify edge is gone (cascading delete)\n    assert!(storage.get_edge(&txn, &edge.id, &arena).is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_both_incoming_and_outgoing_edges_625": {
      "name": "test_drop_node_with_both_incoming_and_outgoing_edges",
      "type": "function",
      "start_line": 625,
      "end_line": 661,
      "content_hash": "050a1632b4f2c167cd35c16e9570ab7d02fa49fb",
      "content": "fn test_drop_node_with_both_incoming_and_outgoing_edges() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 6001, \"Node1\");\n    let node2 = create_test_node(&arena, 6002, \"Node2\");\n    let node3 = create_test_node(&arena, 6003, \"Node3\");\n    let edge1 = create_test_edge(&arena, 7001, \"OUTGOING\", node2.id, node3.id); // node2 -> node3\n    let edge2 = create_test_edge(&arena, 7002, \"INCOMING\", node1.id, node2.id); // node1 -> node2\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_node(&storage, &node3);\n    insert_edge(&storage, &edge1);\n    insert_edge(&storage, &edge2);\n\n    // Drop node2 (has both incoming and outgoing edges)\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &node2.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify node2 is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_node(&txn, &node2.id, &arena).is_err());\n\n    // Verify node1 and node3 still exist\n    assert!(storage.get_node(&txn, &node1.id, &arena).is_ok());\n    assert!(storage.get_node(&txn, &node3.id, &arena).is_ok());\n\n    // Verify both edges are gone\n    assert!(storage.get_edge(&txn, &edge1.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge2.id, &arena).is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_multiple_edges_same_label_662": {
      "name": "test_drop_node_with_multiple_edges_same_label",
      "type": "function",
      "start_line": 662,
      "end_line": 705,
      "content_hash": "c035ecf1d448764eea90e81618a8912c30f2833b",
      "content": "fn test_drop_node_with_multiple_edges_same_label() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let center = create_test_node(&arena, 8001, \"Center\");\n    let neighbor1 = create_test_node(&arena, 8002, \"Neighbor1\");\n    let neighbor2 = create_test_node(&arena, 8003, \"Neighbor2\");\n    let neighbor3 = create_test_node(&arena, 8004, \"Neighbor3\");\n\n    let edge1 = create_test_edge(&arena, 9001, \"KNOWS\", center.id, neighbor1.id);\n    let edge2 = create_test_edge(&arena, 9002, \"KNOWS\", center.id, neighbor2.id);\n    let edge3 = create_test_edge(&arena, 9003, \"KNOWS\", center.id, neighbor3.id);\n\n    insert_node(&storage, &center);\n    insert_node(&storage, &neighbor1);\n    insert_node(&storage, &neighbor2);\n    insert_node(&storage, &neighbor3);\n    insert_edge(&storage, &edge1);\n    insert_edge(&storage, &edge2);\n    insert_edge(&storage, &edge3);\n\n    // Drop center node\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &center.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify center is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_node(&txn, &center.id, &arena).is_err());\n\n    // Verify all neighbors still exist\n    assert!(storage.get_node(&txn, &neighbor1.id, &arena).is_ok());\n    assert!(storage.get_node(&txn, &neighbor2.id, &arena).is_ok());\n    assert!(storage.get_node(&txn, &neighbor3.id, &arena).is_ok());\n\n    // Verify all edges are gone\n    assert!(storage.get_edge(&txn, &edge1.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge2.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge3.id, &arena).is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_node_with_multiple_edge_labels_706": {
      "name": "test_drop_node_with_multiple_edge_labels",
      "type": "function",
      "start_line": 706,
      "end_line": 737,
      "content_hash": "4c4479d18767d8a05f94e860326b998cc8e012b1",
      "content": "fn test_drop_node_with_multiple_edge_labels() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 10001, \"Node1\");\n    let node2 = create_test_node(&arena, 10002, \"Node2\");\n\n    let edge1 = create_test_edge(&arena, 11001, \"KNOWS\", node1.id, node2.id);\n    let edge2 = create_test_edge(&arena, 11002, \"LIKES\", node1.id, node2.id);\n    let edge3 = create_test_edge(&arena, 11003, \"FOLLOWS\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge1);\n    insert_edge(&storage, &edge2);\n    insert_edge(&storage, &edge3);\n\n    // Drop node1\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_node(&mut txn, &node1.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify all edges with different labels are gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_edge(&txn, &edge1.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge2.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge3.id, &arena).is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_edge_exists_738": {
      "name": "test_drop_edge_exists",
      "type": "function",
      "start_line": 738,
      "end_line": 771,
      "content_hash": "0821fb3da54d5127b43b34b87aea938a55dad9b8",
      "content": "fn test_drop_edge_exists() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 12001, \"Node1\");\n    let node2 = create_test_node(&arena, 12002, \"Node2\");\n    let edge = create_test_edge(&arena, 13001, \"CONNECTS\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge);\n\n    // Verify edge exists\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_edge(&txn, &edge.id, &arena).is_ok());\n    drop(txn);\n\n    // Drop the edge\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_edge(&mut txn, &edge.id);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify edge is gone\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_edge(&txn, &edge.id, &arena).is_err());\n\n    // Verify nodes still exist\n    assert!(storage.get_node(&txn, &node1.id, &arena).is_ok());\n    assert!(storage.get_node(&txn, &node2.id, &arena).is_ok());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_edge_nonexistent_772": {
      "name": "test_drop_edge_nonexistent",
      "type": "function",
      "start_line": 772,
      "end_line": 782,
      "content_hash": "f41a62f65f66107efde764587694c691f2123fbb",
      "content": "fn test_drop_edge_nonexistent() {\n    let (storage, _temp_dir) = setup_test_storage();\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let result = storage.drop_edge(&mut txn, &99999);\n\n    // Should return EdgeNotFound error\n    assert!(result.is_err());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_edge_verifies_out_edges_db_cleanup_783": {
      "name": "test_drop_edge_verifies_out_edges_db_cleanup",
      "type": "function",
      "start_line": 783,
      "end_line": 814,
      "content_hash": "e84dabaa7b08c93e1e026d86df6592e72cd2eb44",
      "content": "fn test_drop_edge_verifies_out_edges_db_cleanup() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 14001, \"Node1\");\n    let node2 = create_test_node(&arena, 14002, \"Node2\");\n    let edge = create_test_edge(&arena, 15001, \"LINK\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge);\n\n    // Verify out_edges_db has the entry\n    let txn = storage.graph_env.read_txn().unwrap();\n    let label_hash = hash_label(\"LINK\", None);\n    let out_key = HelixGraphStorage::out_edge_key(&node1.id, &label_hash);\n    let out_entry = storage.out_edges_db.get(&txn, &out_key).unwrap();\n    assert!(out_entry.is_some());\n    drop(txn);\n\n    // Drop the edge\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    storage.drop_edge(&mut txn, &edge.id).unwrap();\n    txn.commit().unwrap();\n\n    // Verify out_edges_db entry is gone\n    let txn = storage.graph_env.read_txn().unwrap();\n    let out_entry = storage.out_edges_db.get(&txn, &out_key).unwrap();\n    assert!(out_entry.is_none());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_edge_verifies_in_edges_db_cleanup_815": {
      "name": "test_drop_edge_verifies_in_edges_db_cleanup",
      "type": "function",
      "start_line": 815,
      "end_line": 846,
      "content_hash": "74518b938283702bd1d9331c78cfb60795e280df",
      "content": "fn test_drop_edge_verifies_in_edges_db_cleanup() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 16001, \"Node1\");\n    let node2 = create_test_node(&arena, 16002, \"Node2\");\n    let edge = create_test_edge(&arena, 17001, \"LINK\", node1.id, node2.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_edge(&storage, &edge);\n\n    // Verify in_edges_db has the entry\n    let txn = storage.graph_env.read_txn().unwrap();\n    let label_hash = hash_label(\"LINK\", None);\n    let in_key = HelixGraphStorage::in_edge_key(&node2.id, &label_hash);\n    let in_entry = storage.in_edges_db.get(&txn, &in_key).unwrap();\n    assert!(in_entry.is_some());\n    drop(txn);\n\n    // Drop the edge\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    storage.drop_edge(&mut txn, &edge.id).unwrap();\n    txn.commit().unwrap();\n\n    // Verify in_edges_db entry is gone\n    let txn = storage.graph_env.read_txn().unwrap();\n    let in_entry = storage.in_edges_db.get(&txn, &in_key).unwrap();\n    assert!(in_entry.is_none());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_one_edge_preserves_other_edges_847": {
      "name": "test_drop_one_edge_preserves_other_edges",
      "type": "function",
      "start_line": 847,
      "end_line": 874,
      "content_hash": "ce3ef82f2c73cd24e4038c9a53897a16de946bae",
      "content": "fn test_drop_one_edge_preserves_other_edges() {\n    let (storage, _temp_dir) = setup_test_storage();\n    let arena = Bump::new();\n\n    let node1 = create_test_node(&arena, 18001, \"Node1\");\n    let node2 = create_test_node(&arena, 18002, \"Node2\");\n    let node3 = create_test_node(&arena, 18003, \"Node3\");\n\n    let edge1 = create_test_edge(&arena, 19001, \"LINK\", node1.id, node2.id);\n    let edge2 = create_test_edge(&arena, 19002, \"LINK\", node1.id, node3.id);\n\n    insert_node(&storage, &node1);\n    insert_node(&storage, &node2);\n    insert_node(&storage, &node3);\n    insert_edge(&storage, &edge1);\n    insert_edge(&storage, &edge2);\n\n    // Drop only edge1\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    storage.drop_edge(&mut txn, &edge1.id).unwrap();\n    txn.commit().unwrap();\n\n    // Verify edge1 is gone but edge2 remains\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    assert!(storage.get_edge(&txn, &edge1.id, &arena).is_err());\n    assert!(storage.get_edge(&txn, &edge2.id, &arena).is_ok());\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}