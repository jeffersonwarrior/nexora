{
  "file_path": "/work/external-deps/claude-swarm/src/index.ts",
  "file_hash": "c524c2bc547d03a448578a585979afc0c329991d",
  "updated_at": "2025-12-26T17:34:23.103785",
  "symbols": {
    "function_ensureInitialized_70": {
      "name": "ensureInitialized",
      "type": "function",
      "start_line": 70,
      "end_line": 121,
      "content_hash": "9c7afa51433ebebc73c791ce66aec5472e1cdd97",
      "content": "async function ensureInitialized(projectDir: string): Promise<{ state: StateManager; workers: WorkerManager }> {\n  // Validate project directory (throws on invalid path)\n  const validatedDir = validateProjectDir(projectDir);\n\n  if (!stateManager || stateManager.projectDir !== validatedDir) {\n    stateManager = new StateManager(validatedDir);\n    workerManager = new WorkerManager(validatedDir, stateManager);\n\n    // Register completion callback to log when workers complete/crash\n    workerManager.onWorkerCompletion((featureId, status, output) => {\n      const currentState = stateManager?.load();\n      if (currentState) {\n        const feature = currentState.features.find((f) => f.id === featureId);\n        const shortOutput = output ? output.slice(0, 100).replace(/\\n/g, \" \") : \"\";\n        const logMessage =\n          status === \"completed\"\n            ? `[${new Date().toISOString()}] \ud83d\udd14 Worker completed: ${featureId} - use mark_complete to update status`\n            : `[${new Date().toISOString()}] \u26a0\ufe0f Worker crashed: ${featureId}${shortOutput ? ` - ${shortOutput}...` : \"\"} - use mark_complete to update status`;\n        currentState.progressLog.push(logMessage);\n        currentState.lastUpdated = new Date().toISOString();\n        stateManager?.save(currentState);\n        // Also log to stderr for immediate visibility\n        console.error(logMessage);\n      }\n    });\n\n    // Start the completion monitor\n    workerManager.startCompletionMonitor();\n\n    // Start dashboard server if enabled and not already running\n    if (ENABLE_DASHBOARD && !dashboardServer) {\n      try {\n        // Pass a getter function so dashboard always has current stateManager\n        dashboardServer = await startDashboardServer(() => stateManager, {\n          port: DASHBOARD_PORT,\n          host: \"127.0.0.1\",\n        });\n        console.error(`\ud83d\udcca Dashboard available at http://127.0.0.1:${DASHBOARD_PORT}`);\n      } catch (err: any) {\n        // Log error but don't fail - dashboard is optional\n        console.error(`\u26a0\ufe0f Failed to start dashboard server: ${err.message}`);\n      }\n    }\n  }\n\n  // TypeScript safety: workerManager is always set when stateManager is set\n  if (!workerManager) {\n    throw new Error(\"WorkerManager not initialized\");\n  }\n\n  return { state: stateManager, workers: workerManager };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_calculatePriority_2618": {
      "name": "calculatePriority",
      "type": "function",
      "start_line": 2618,
      "end_line": 2650,
      "content_hash": "dc031ae5e2278f073646f74a0ddd852bc3f2145d",
      "content": "    function calculatePriority(feature: Feature, allFeatures: Feature[]): number {\n      let score = 0;\n\n      // +50 points per feature this blocks\n      const blockedCount = allFeatures.filter(f =>\n        f.dependsOn?.includes(feature.id) && f.status === \"pending\"\n      ).length;\n      score += blockedCount * 50;\n\n      // +40 points if no dependencies (can start immediately)\n      if (!feature.dependsOn || feature.dependsOn.length === 0) {\n        score += 40;\n      }\n\n      // +30 points for low complexity (if available)\n      if (feature.complexity && feature.complexity.score < 40) {\n        score += 30;\n      }\n\n      // -20 points per previous attempt (struggling)\n      score -= (feature.attempts || 0) * 20;\n\n      // Strategy-specific adjustments\n      if (strategy === \"breadth-first\") {\n        // Prefer features with no dependencies\n        if (!feature.dependsOn || feature.dependsOn.length === 0) score += 20;\n      } else if (strategy === \"depth-first\") {\n        // Prefer features that unblock others\n        score += blockedCount * 30;\n      }\n\n      return Math.max(0, score);\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getReadyFeatures_2653": {
      "name": "getReadyFeatures",
      "type": "function",
      "start_line": 2653,
      "end_line": 2668,
      "content_hash": "d4537b1c0f4fa46e3d843782a71ea51f28a99c47",
      "content": "    function getReadyFeatures(): Feature[] {\n      return current!.features.filter(f => {\n        if (f.status !== \"pending\") return false;\n\n        // Check dependencies are met\n        if (f.dependsOn && f.dependsOn.length > 0) {\n          const unmetDeps = f.dependsOn.filter(depId => {\n            const dep = current!.features.find(df => df.id === depId);\n            return !dep || dep.status !== \"completed\";\n          });\n          if (unmetDeps.length > 0) return false;\n        }\n\n        return true;\n      });\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_2727": {
      "name": "main",
      "type": "function",
      "start_line": 2727,
      "end_line": 2731,
      "content_hash": "66aa4a56a1fefa3c53ffc38b04406bbb6412f255",
      "content": "async function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"Claude Orchestrator MCP Server running\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}