{
  "file_path": "/work/external-deps/claude-swarm/src/state/manager.ts",
  "file_hash": "278fabd856e476fdca8545865e0d6b55dad45a5b",
  "updated_at": "2025-12-26T17:34:23.376591",
  "symbols": {
    "class_StateManager_130": {
      "name": "StateManager",
      "type": "class",
      "start_line": 130,
      "end_line": 430,
      "content_hash": "e9e79a06424755da4878917805cdb1cc46875206",
      "content": "export class StateManager {\n  public readonly projectDir: string;\n  private stateFile: string;\n  private progressFile: string;\n  private initScriptFile: string;\n  private featureListFile: string;\n\n  constructor(projectDir: string) {\n    this.projectDir = projectDir;\n\n    // Ensure .claude directory exists\n    const claudeDir = path.join(projectDir, \".claude\", \"orchestrator\");\n    if (!fs.existsSync(claudeDir)) {\n      fs.mkdirSync(claudeDir, { recursive: true });\n    }\n\n    this.stateFile = path.join(claudeDir, \"state.json\");\n    this.progressFile = path.join(projectDir, \"claude-progress.txt\");\n    this.initScriptFile = path.join(projectDir, \"init.sh\");\n    this.featureListFile = path.join(claudeDir, \"feature_list.json\");\n  }\n\n  /**\n   * Load state from disk with validation\n   */\n  load(): OrchestratorState | null {\n    if (!fs.existsSync(this.stateFile)) {\n      return null;\n    }\n\n    try {\n      const data = fs.readFileSync(this.stateFile, \"utf-8\");\n      const parsed = JSON.parse(data);\n\n      // Validate against schema\n      const validated = OrchestratorStateSchema.parse(parsed);\n      return validated as OrchestratorState;\n    } catch (error) {\n      // If validation fails, the file is corrupted or tampered with\n      console.error(\"Error loading state (file may be corrupted):\", error);\n      throw new Error(\n        \"State file is corrupted or invalid. Use orchestrator_reset to start fresh.\"\n      );\n    }\n  }\n\n  /**\n   * Save state to disk using atomic write\n   */\n  save(state: OrchestratorState): void {\n    state.lastUpdated = new Date().toISOString();\n\n    // Rotate log if too large\n    if (state.progressLog.length > MAX_LOG_ENTRIES) {\n      state.progressLog = state.progressLog.slice(-MAX_LOG_ENTRIES);\n    }\n\n    // Atomic write: write to temp file, then rename\n    const tempFile = `${this.stateFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, JSON.stringify(state, null, 2));\n      fs.renameSync(tempFile, this.stateFile);\n    } catch (error) {\n      // Clean up temp file if rename failed\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n\n    this.writeFeatureList(state);\n  }\n\n  /**\n   * Clear all state\n   */\n  clear(): void {\n    const filesToRemove = [\n      this.stateFile,\n      this.progressFile,\n      this.featureListFile,\n    ];\n\n    for (const file of filesToRemove) {\n      if (fs.existsSync(file)) {\n        try {\n          fs.unlinkSync(file);\n        } catch {\n          // Ignore errors during cleanup\n        }\n      }\n    }\n  }\n\n  /**\n   * Write the human-readable progress file (notebook pattern)\n   * This file is designed to be easily readable by Claude after compaction\n   */\n  writeProgressFile(): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (!state) return;\n\n    const completed = state.features.filter((f) => f.status === \"completed\");\n    const failed = state.features.filter((f) => f.status === \"failed\");\n    const inProgress = state.features.filter((f) => f.status === \"in_progress\");\n    const pending = state.features.filter((f) => f.status === \"pending\");\n\n    let content = `# Claude Orchestrator Progress Log\n# ===============================\n# Project: ${sanitizeOutput(state.projectDir, 200)}\n# Started: ${state.startTime}\n# Last Updated: ${state.lastUpdated}\n# Status: ${state.status}\n\n## Summary\n- Total Features: ${state.features.length}\n- Completed: ${completed.length}\n- In Progress: ${inProgress.length}\n- Pending: ${pending.length}\n- Failed: ${failed.length}\n\n## Task Description\n${sanitizeOutput(state.taskDescription, 2000)}\n\n## Feature Status\n`;\n\n    for (const feature of state.features) {\n      const statusIcon =\n        feature.status === \"completed\"\n          ? \"\u2705\"\n          : feature.status === \"failed\"\n            ? \"\u274c\"\n            : feature.status === \"in_progress\"\n              ? \"\ud83d\udd04\"\n              : \"\u23f3\";\n      content += `${statusIcon} [${feature.status.toUpperCase()}] ${feature.id}: ${sanitizeOutput(feature.description, 200)}\\n`;\n      if (feature.lastError) {\n        content += `   Error: ${sanitizeOutput(feature.lastError, 200)}\\n`;\n      }\n      if (feature.notes) {\n        content += `   Notes: ${sanitizeOutput(feature.notes, 200)}\\n`;\n      }\n    }\n\n    content += `\\n## Progress Log (last ${Math.min(state.progressLog.length, 100)} entries)\\n`;\n    const recentLogs = state.progressLog.slice(-100);\n    for (const log of recentLogs) {\n      content += `${sanitizeOutput(log, 500)}\\n`;\n    }\n\n    // Atomic write for progress file too\n    const tempFile = `${this.progressFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, content);\n      fs.renameSync(tempFile, this.progressFile);\n    } catch (error) {\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Write the feature list JSON file (for structured access)\n   */\n  writeFeatureList(state: OrchestratorState): void {\n    const featureList = {\n      projectDir: state.projectDir,\n      taskDescription: state.taskDescription,\n      lastUpdated: state.lastUpdated,\n      features: state.features.map((f) => ({\n        id: f.id,\n        description: f.description,\n        status: f.status,\n        passes: f.status === \"completed\",\n      })),\n    };\n\n    // Atomic write\n    const tempFile = `${this.featureListFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, JSON.stringify(featureList, null, 2));\n      fs.renameSync(tempFile, this.featureListFile);\n    } catch (error) {\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Write init.sh script for environment setup\n   * Following Anthropic's pattern from \"Effective harnesses for long-running agents\"\n   * Security: Uses shell quoting to prevent injection\n   */\n  writeInitScript(): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (!state) return;\n\n    // Use shell quoting for the project directory\n    const quotedProjectDir = shellQuote(state.projectDir);\n\n    const script = `#!/bin/bash\n# Claude Orchestrator - Init Script\n# Generated: ${new Date().toISOString()}\n#\n# This script sets up the environment for the orchestration session.\n# Run this at the start of each session to ensure proper setup.\n\nset -e\n\necho \"\ud83d\ude80 Initializing Claude Orchestrator environment...\"\n\n# Navigate to project (safely quoted)\ncd ${quotedProjectDir}\n\n# Check git status\nif git rev-parse --git-dir > /dev/null 2>&1; then\n    echo \"\ud83d\udce6 Git repository detected\"\n    git status --short\nelse\n    echo \"\u26a0\ufe0f  Not a git repository\"\nfi\n\n# Check for common project files and run setup if found\nif [ -f \"package.json\" ]; then\n    echo \"\ud83d\udce6 Node.js project detected\"\n    if [ ! -d \"node_modules\" ]; then\n        echo \"   Installing dependencies...\"\n        npm install\n    fi\nfi\n\nif [ -f \"requirements.txt\" ]; then\n    echo \"\ud83d\udc0d Python project detected\"\n    if [ -d \"venv\" ]; then\n        source venv/bin/activate\n    fi\nfi\n\nif [ -f \"Cargo.toml\" ]; then\n    echo \"\ud83e\udd80 Rust project detected\"\nfi\n\nif [ -f \"go.mod\" ]; then\n    echo \"\ud83d\udc39 Go project detected\"\nfi\n\n# Show orchestrator status\necho \"\"\necho \"\ud83d\udcca Orchestrator Status:\"\nif [ -f \".claude/orchestrator/state.json\" ]; then\n    head -20 .claude/orchestrator/state.json\nelse\n    echo \"   No active session\"\nfi\n\necho \"\"\necho \"\u2705 Environment ready!\"\necho \"   Use 'orchestrator_status' to check current progress\"\n`;\n\n    fs.writeFileSync(this.initScriptFile, script, { mode: 0o700 }); // Owner-only execution\n  }\n\n  /**\n   * Append to progress log\n   */\n  appendLog(message: string): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (state) {\n      state.progressLog.push(`[${new Date().toISOString()}] ${message}`);\n      this.save(state);\n      this.writeProgressFile();\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_137": {
      "name": "constructor",
      "type": "method",
      "start_line": 137,
      "end_line": 150,
      "content_hash": "433a5f248e67e26941415df5a7a21e351dbe531c",
      "content": "  constructor(projectDir: string) {\n    this.projectDir = projectDir;\n\n    // Ensure .claude directory exists\n    const claudeDir = path.join(projectDir, \".claude\", \"orchestrator\");\n    if (!fs.existsSync(claudeDir)) {\n      fs.mkdirSync(claudeDir, { recursive: true });\n    }\n\n    this.stateFile = path.join(claudeDir, \"state.json\");\n    this.progressFile = path.join(projectDir, \"claude-progress.txt\");\n    this.initScriptFile = path.join(projectDir, \"init.sh\");\n    this.featureListFile = path.join(claudeDir, \"feature_list.json\");\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_load_155": {
      "name": "load",
      "type": "method",
      "start_line": 155,
      "end_line": 174,
      "content_hash": "4c6e1ddb385cf4edb14168cbe4d386d98cc6c0af",
      "content": "  load(): OrchestratorState | null {\n    if (!fs.existsSync(this.stateFile)) {\n      return null;\n    }\n\n    try {\n      const data = fs.readFileSync(this.stateFile, \"utf-8\");\n      const parsed = JSON.parse(data);\n\n      // Validate against schema\n      const validated = OrchestratorStateSchema.parse(parsed);\n      return validated as OrchestratorState;\n    } catch (error) {\n      // If validation fails, the file is corrupted or tampered with\n      console.error(\"Error loading state (file may be corrupted):\", error);\n      throw new Error(\n        \"State file is corrupted or invalid. Use orchestrator_reset to start fresh.\"\n      );\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_save_179": {
      "name": "save",
      "type": "method",
      "start_line": 179,
      "end_line": 203,
      "content_hash": "2dc093bb540a64c0fbac4b2c477296b9f830aa6a",
      "content": "  save(state: OrchestratorState): void {\n    state.lastUpdated = new Date().toISOString();\n\n    // Rotate log if too large\n    if (state.progressLog.length > MAX_LOG_ENTRIES) {\n      state.progressLog = state.progressLog.slice(-MAX_LOG_ENTRIES);\n    }\n\n    // Atomic write: write to temp file, then rename\n    const tempFile = `${this.stateFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, JSON.stringify(state, null, 2));\n      fs.renameSync(tempFile, this.stateFile);\n    } catch (error) {\n      // Clean up temp file if rename failed\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n\n    this.writeFeatureList(state);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_clear_208": {
      "name": "clear",
      "type": "method",
      "start_line": 208,
      "end_line": 224,
      "content_hash": "548503a72f089c72e8769d405ad84744427d7c84",
      "content": "  clear(): void {\n    const filesToRemove = [\n      this.stateFile,\n      this.progressFile,\n      this.featureListFile,\n    ];\n\n    for (const file of filesToRemove) {\n      if (fs.existsSync(file)) {\n        try {\n          fs.unlinkSync(file);\n        } catch {\n          // Ignore errors during cleanup\n        }\n      }\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeProgressFile_230": {
      "name": "writeProgressFile",
      "type": "method",
      "start_line": 230,
      "end_line": 301,
      "content_hash": "177f72208865972061dc41c3313952f042ded1c5",
      "content": "  writeProgressFile(): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (!state) return;\n\n    const completed = state.features.filter((f) => f.status === \"completed\");\n    const failed = state.features.filter((f) => f.status === \"failed\");\n    const inProgress = state.features.filter((f) => f.status === \"in_progress\");\n    const pending = state.features.filter((f) => f.status === \"pending\");\n\n    let content = `# Claude Orchestrator Progress Log\n# ===============================\n# Project: ${sanitizeOutput(state.projectDir, 200)}\n# Started: ${state.startTime}\n# Last Updated: ${state.lastUpdated}\n# Status: ${state.status}\n\n## Summary\n- Total Features: ${state.features.length}\n- Completed: ${completed.length}\n- In Progress: ${inProgress.length}\n- Pending: ${pending.length}\n- Failed: ${failed.length}\n\n## Task Description\n${sanitizeOutput(state.taskDescription, 2000)}\n\n## Feature Status\n`;\n\n    for (const feature of state.features) {\n      const statusIcon =\n        feature.status === \"completed\"\n          ? \"\u2705\"\n          : feature.status === \"failed\"\n            ? \"\u274c\"\n            : feature.status === \"in_progress\"\n              ? \"\ud83d\udd04\"\n              : \"\u23f3\";\n      content += `${statusIcon} [${feature.status.toUpperCase()}] ${feature.id}: ${sanitizeOutput(feature.description, 200)}\\n`;\n      if (feature.lastError) {\n        content += `   Error: ${sanitizeOutput(feature.lastError, 200)}\\n`;\n      }\n      if (feature.notes) {\n        content += `   Notes: ${sanitizeOutput(feature.notes, 200)}\\n`;\n      }\n    }\n\n    content += `\\n## Progress Log (last ${Math.min(state.progressLog.length, 100)} entries)\\n`;\n    const recentLogs = state.progressLog.slice(-100);\n    for (const log of recentLogs) {\n      content += `${sanitizeOutput(log, 500)}\\n`;\n    }\n\n    // Atomic write for progress file too\n    const tempFile = `${this.progressFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, content);\n      fs.renameSync(tempFile, this.progressFile);\n    } catch (error) {\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeFeatureList_306": {
      "name": "writeFeatureList",
      "type": "method",
      "start_line": 306,
      "end_line": 332,
      "content_hash": "cf222698953fe74ff5a24045124c85ad2b57f965",
      "content": "  writeFeatureList(state: OrchestratorState): void {\n    const featureList = {\n      projectDir: state.projectDir,\n      taskDescription: state.taskDescription,\n      lastUpdated: state.lastUpdated,\n      features: state.features.map((f) => ({\n        id: f.id,\n        description: f.description,\n        status: f.status,\n        passes: f.status === \"completed\",\n      })),\n    };\n\n    // Atomic write\n    const tempFile = `${this.featureListFile}.tmp.${Date.now()}`;\n    try {\n      fs.writeFileSync(tempFile, JSON.stringify(featureList, null, 2));\n      fs.renameSync(tempFile, this.featureListFile);\n    } catch (error) {\n      try {\n        fs.unlinkSync(tempFile);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeInitScript_339": {
      "name": "writeInitScript",
      "type": "method",
      "start_line": 339,
      "end_line": 412,
      "content_hash": "500a3f8753a20cb713c143b141b5dde0d8e798c7",
      "content": "  writeInitScript(): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (!state) return;\n\n    // Use shell quoting for the project directory\n    const quotedProjectDir = shellQuote(state.projectDir);\n\n    const script = `#!/bin/bash\n# Claude Orchestrator - Init Script\n# Generated: ${new Date().toISOString()}\n#\n# This script sets up the environment for the orchestration session.\n# Run this at the start of each session to ensure proper setup.\n\nset -e\n\necho \"\ud83d\ude80 Initializing Claude Orchestrator environment...\"\n\n# Navigate to project (safely quoted)\ncd ${quotedProjectDir}\n\n# Check git status\nif git rev-parse --git-dir > /dev/null 2>&1; then\n    echo \"\ud83d\udce6 Git repository detected\"\n    git status --short\nelse\n    echo \"\u26a0\ufe0f  Not a git repository\"\nfi\n\n# Check for common project files and run setup if found\nif [ -f \"package.json\" ]; then\n    echo \"\ud83d\udce6 Node.js project detected\"\n    if [ ! -d \"node_modules\" ]; then\n        echo \"   Installing dependencies...\"\n        npm install\n    fi\nfi\n\nif [ -f \"requirements.txt\" ]; then\n    echo \"\ud83d\udc0d Python project detected\"\n    if [ -d \"venv\" ]; then\n        source venv/bin/activate\n    fi\nfi\n\nif [ -f \"Cargo.toml\" ]; then\n    echo \"\ud83e\udd80 Rust project detected\"\nfi\n\nif [ -f \"go.mod\" ]; then\n    echo \"\ud83d\udc39 Go project detected\"\nfi\n\n# Show orchestrator status\necho \"\"\necho \"\ud83d\udcca Orchestrator Status:\"\nif [ -f \".claude/orchestrator/state.json\" ]; then\n    head -20 .claude/orchestrator/state.json\nelse\n    echo \"   No active session\"\nfi\n\necho \"\"\necho \"\u2705 Environment ready!\"\necho \"   Use 'orchestrator_status' to check current progress\"\n`;\n\n    fs.writeFileSync(this.initScriptFile, script, { mode: 0o700 }); // Owner-only execution\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_appendLog_417": {
      "name": "appendLog",
      "type": "method",
      "start_line": 417,
      "end_line": 429,
      "content_hash": "068bc5241d674ea2d2b056b86bb3c8fd0803da08",
      "content": "  appendLog(message: string): void {\n    let state: OrchestratorState | null;\n    try {\n      state = this.load();\n    } catch {\n      return;\n    }\n    if (state) {\n      state.progressLog.push(`[${new Date().toISOString()}] ${message}`);\n      this.save(state);\n      this.writeProgressFile();\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}