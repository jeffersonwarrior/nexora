{
  "file_path": "/work/internal/agent/task_coordinator.go",
  "file_hash": "adbd0785819e4702ef05dd9c1684370ca8bbffb1",
  "updated_at": "2025-12-26T17:34:20.856287",
  "symbols": {
    "function_min_19": {
      "name": "min",
      "type": "function",
      "start_line": 19,
      "end_line": 26,
      "content_hash": "d63060876f862087aa0008d071e1acc0d6b434bd",
      "content": "func min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// TaskExecutionContext holds context for task execution",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TaskExecutionContext_27": {
      "name": "TaskExecutionContext",
      "type": "struct",
      "start_line": 27,
      "end_line": 36,
      "content_hash": "c24bac5dd8a8b88d8cbfe5b285bf1057eb619999",
      "content": "type TaskExecutionContext struct {\n\tID             string\n\tDirectory      string\n\tInstructions   string\n\tProgress       string\n\tStartTime      time.Time\n\t_TEMP_DIR_PATH string // For temporary files\n}\n\n// TaskExecutionCoordinator manages task execution with simplified approach",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TaskExecutionCoordinator_37": {
      "name": "TaskExecutionCoordinator",
      "type": "struct",
      "start_line": 37,
      "end_line": 42,
      "content_hash": "c66c7336336fcea3ff3d982fe23bef79dc5e6645",
      "content": "type TaskExecutionCoordinator struct {\n\ttempDir *tools.TempDir\n\ttasks   map[string]*TaskExecutionContext\n}\n\n// NewTaskExecutionCoordinator creates a new task coordinator",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewTaskExecutionCoordinator_43": {
      "name": "NewTaskExecutionCoordinator",
      "type": "function",
      "start_line": 43,
      "end_line": 50,
      "content_hash": "4c7aad565afc3ff47d54643b69575e4399463823",
      "content": "func NewTaskExecutionCoordinator() *TaskExecutionCoordinator {\n\treturn &TaskExecutionCoordinator{\n\t\ttempDir: tools.NewTempDir(),\n\t\ttasks:   make(map[string]*TaskExecutionContext),\n\t}\n}\n\n// ExecuteTask executes a task with the given instructions",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ExecuteTask_51": {
      "name": "ExecuteTask",
      "type": "method",
      "start_line": 51,
      "end_line": 99,
      "content_hash": "eefca1870c5d93649017f26d94ceb6f05cd2032c",
      "content": "func (tec *TaskExecutionCoordinator) ExecuteTask(ctx context.Context, directory, instructions string) (*TaskExecutionContext, error) {\n\tslog.Info(\"\ud83c\udfaf Executing task\", \"directory\", directory, \"instructions\", instructions[:min(len(instructions), 100)])\n\ttaskID := fmt.Sprintf(\"task_%d\", time.Now().UnixNano())\n\ttaskCtx := &TaskExecutionContext{\n\t\tID:           taskID,\n\t\tDirectory:    directory,\n\t\tInstructions: instructions,\n\t\tStartTime:    time.Now(),\n\t\tProgress:     \"\ud83d\udccd Starting task execution...\",\n\t}\n\n\t// Create temporary directory for this task\n\ttempDir, err := tec.tempDir.CreateTempDir(taskID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create temp directory: %w\", err)\n\t}\n\ttaskCtx._TEMP_DIR_PATH = tempDir\n\n\t// Store task\n\ttec.tasks[taskID] = taskCtx\n\n\t// Execute the task\n\tdefer func() {\n\t\tif err := tec.tempDir.CleanUp(tempDir); err != nil {\n\t\t\tslog.Error(\"Failed to cleanup temp directory\", \"error\", err)\n\t\t}\n\t\tdelete(tec.tasks, taskID)\n\t}()\n\n\t// Create a simple execution plan\n\ttaskCtx.Progress = \"\ud83d\udccb Creating execution plan...\"\n\tplan, err := tec.createSimpleExecutionPlan(instructions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create execution plan: %w\", err)\n\t}\n\n\ttaskCtx.Progress = \"\ud83d\ude80 Executing plan steps...\"\n\tresult, err := tec.executeSimplePlan(ctx, taskCtx, plan)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"task execution failed: %w\", err)\n\t}\n\n\ttaskCtx.Progress = \"\u2705 Task completed successfully\"\n\tslog.Info(\"\ud83c\udf89 Task execution completed\", \"duration\", time.Since(taskCtx.StartTime))\n\n\treturn taskCtx, result\n}\n\n// createSimpleExecutionPlan creates a simple execution plan",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createSimpleExecutionPlan_100": {
      "name": "createSimpleExecutionPlan",
      "type": "method",
      "start_line": 100,
      "end_line": 107,
      "content_hash": "02514859633bc10514418228e358aef02ddea3e7",
      "content": "func (tec *TaskExecutionCoordinator) createSimpleExecutionPlan(instructions string) (*prompt.Prompt, error) {\n\treturn prompt.NewPrompt(\n\t\t\"task-execution\",\n\t\t\"system: You are executing a specific task. Follow the instructions precisely and report the results.\\n\\nuser: \"+instructions,\n\t)\n}\n\n// executeSimplePlan executes a simple plan",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_executeSimplePlan_108": {
      "name": "executeSimplePlan",
      "type": "method",
      "start_line": 108,
      "end_line": 136,
      "content_hash": "9bbea111e7206826f906b09ea0c7ea114b4629cc",
      "content": "func (tec *TaskExecutionCoordinator) executeSimplePlan(ctx context.Context, taskCtx *TaskExecutionContext, plan *prompt.Prompt) (error, error) {\n\t// Extract files mentioned in instructions\n\tfiles := tec.extractFilesFromInstructions(taskCtx.Instructions)\n\n\tslog.Info(\"\ud83d\udcc4 Found relevant files\", \"count\", len(files))\n\n\t// For each file, create a simple task\n\tfor _, file := range files {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn fmt.Errorf(\"task execution cancelled\"), nil\n\t\tdefault:\n\t\t\ttaskCtx.Progress = fmt.Sprintf(\"\ud83d\udd27 Processing %s...\", filepath.Base(file))\n\n\t\t\t// Simple file processing - just read it\n\t\t\tcontent, err := tec.readSimpleFile(file)\n\t\t\tif err != nil {\n\t\t\t\tslog.Warn(\"Failed to read file\", \"file\", file, \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tslog.Info(\"\ud83d\udcd6 Read file\", \"file\", file, \"size\", len(content))\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\n// extractFilesFromInstructions extracts file paths from instructions",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractFilesFromInstructions_137": {
      "name": "extractFilesFromInstructions",
      "type": "method",
      "start_line": 137,
      "end_line": 169,
      "content_hash": "17b577a3c1975620df1d701c203c57b73ea71716",
      "content": "func (tec *TaskExecutionCoordinator) extractFilesFromInstructions(instructions string) []string {\n\tvar files []string\n\n\t// Simple extraction - look for common patterns in working directory\n\tscanner := bufio.NewScanner(strings.NewReader(instructions))\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tfor _, ext := range []string{\".go\", \".md\", \".txt\", \".json\", \".yaml\", \".yml\"} {\n\t\t\tif strings.Contains(line, ext) {\n\t\t\t\t// Try to find files in current directory\n\t\t\t\tmatches, _ := filepath.Glob(\"*\" + ext)\n\t\t\t\tfiles = append(files, matches...)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove duplicates and limit\n\tseen := make(map[string]bool)\n\tunique := []string{}\n\tfor _, file := range files {\n\t\tif !seen[file] {\n\t\t\tseen[file] = true\n\t\t\tunique = append(unique, file)\n\t\t\tif len(unique) >= 10 { // Limit to 10 files\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn unique\n}\n\n// readSimpleFile reads a file simply",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_readSimpleFile_170": {
      "name": "readSimpleFile",
      "type": "method",
      "start_line": 170,
      "end_line": 176,
      "content_hash": "428f7bc23e5cd88f53f5d0b6994af51d7ff22b49",
      "content": "func (tec *TaskExecutionCoordinator) readSimpleFile(path string) (string, error) {\n\tcontent, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(content), nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}