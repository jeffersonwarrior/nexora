{
  "file_path": "/work/context-engine/tests/test_micro_span_budget.py",
  "file_hash": "4d5fc65b2fe8860efbdd5859487129039e6c54cd",
  "updated_at": "2025-12-26T17:34:22.614686",
  "symbols": {
    "function__mk_item_4": {
      "name": "_mk_item",
      "type": "function",
      "start_line": 4,
      "end_line": 11,
      "content_hash": "fa7af28e7214e76d6931a36ba812f05dada5c314",
      "content": "def _mk_item(path, start, end, score):\n    # Simulate the shape produced mid-pipeline: {\"pt\": {payload: {metadata: {...}}}, \"s\": score}\n    class _Pt:\n        def __init__(self, payload):\n            self.payload = payload\n\n    md = {\"path\": path, \"start_line\": start, \"end_line\": end}\n    return {\"pt\": _Pt({\"metadata\": md}), \"s\": score}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class__Pt_6": {
      "name": "_Pt",
      "type": "class",
      "start_line": 6,
      "end_line": 8,
      "content_hash": "62d65e368e3ca3e42b3e26e94915daa3e740590e",
      "content": "    class _Pt:\n        def __init__(self, payload):\n            self.payload = payload",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___7": {
      "name": "__init__",
      "type": "method",
      "start_line": 7,
      "end_line": 8,
      "content_hash": "286f8e00be2c4eb54c7826b6ce9195d7436e714b",
      "content": "        def __init__(self, payload):\n            self.payload = payload",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_merge_and_budget_spans_merges_and_respects_budget_14": {
      "name": "test_merge_and_budget_spans_merges_and_respects_budget",
      "type": "function",
      "start_line": 14,
      "end_line": 38,
      "content_hash": "73e46106412f3e00fa5057ece841575ba1ea4bcd",
      "content": "def test_merge_and_budget_spans_merges_and_respects_budget(monkeypatch):\n    # Make tokens-per-line small to trigger budget easily\n    monkeypatch.setenv(\"MICRO_TOKENS_PER_LINE\", \"10\")\n    monkeypatch.setenv(\"MICRO_BUDGET_TOKENS\", \"60\")  # ~6 lines total\n    monkeypatch.setenv(\"MICRO_MERGE_LINES\", \"2\")\n    monkeypatch.setenv(\"MICRO_OUT_MAX_SPANS\", \"2\")\n\n    # Two overlaps in same file should merge; a third far span should compete for budget\n    items = [\n        _mk_item(\"a.py\", 10, 11, 1.0),  # 2 lines\n        _mk_item(\"a.py\", 12, 12, 0.9),  # adjacent -> merge to 10..12 (3 lines)\n        _mk_item(\"a.py\", 30, 33, 0.8),  # 4 lines; may fit depending on budget\n        _mk_item(\"b.py\", 5, 6, 0.7),  # 2 lines other file\n    ]\n\n    merged = _merge_and_budget_spans(items)\n\n    # After merging, first cluster a.py should be 10..12 (3 lines -> 30 tokens)\n    # Budget=60 means we can include either (10..12) + (30..33) OR (10..12) + b.py (depending on order/score)\n    # Since a.py spans have higher scores, expect both from a.py until per-path cap hits 2\n    assert len(merged) >= 1\n    # Spans carry _merged_* annotations\n    assert merged[0][\"_merged_start\"] <= merged[0][\"_merged_end\"]\n    # Budget tokens used are attached\n    assert isinstance(merged[0][\"_budget_tokens\"], int)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_merge_and_budget_respects_per_path_cap_41": {
      "name": "test_merge_and_budget_respects_per_path_cap",
      "type": "function",
      "start_line": 41,
      "end_line": 58,
      "content_hash": "bdfc723ba589ffb4f0099015972de37bea933221",
      "content": "def test_merge_and_budget_respects_per_path_cap(monkeypatch):\n    monkeypatch.setenv(\"MICRO_TOKENS_PER_LINE\", \"10\")\n    monkeypatch.setenv(\"MICRO_BUDGET_TOKENS\", \"200\")  # ample\n    monkeypatch.setenv(\"MICRO_MERGE_LINES\", \"1\")\n    monkeypatch.setenv(\"MICRO_OUT_MAX_SPANS\", \"1\")\n\n    items = [\n        _mk_item(\"x.py\", 1, 2, 1.0),\n        _mk_item(\"x.py\", 10, 11, 0.9),\n        _mk_item(\"y.py\", 3, 4, 0.8),\n    ]\n    merged = _merge_and_budget_spans(items)\n    # Only 1 from x.py should be included due to per-path cap\n    from collections import Counter\n\n    paths = [(m.get(\"pt\").payload[\"metadata\"][\"path\"]) for m in merged]\n    c = Counter(paths)\n    assert c.get(\"x.py\", 0) <= 1",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_merge_and_budget_spans_works_without_explicit_budget_61": {
      "name": "test_merge_and_budget_spans_works_without_explicit_budget",
      "type": "function",
      "start_line": 61,
      "end_line": 87,
      "content_hash": "b195a7a1f21968d0320d543326dc32f3b603c912",
      "content": "def test_merge_and_budget_spans_works_without_explicit_budget(monkeypatch):\n    \"\"\"Ensure budgeting works when no MICRO_BUDGET_TOKENS is provided.\n\n    This simulates the default case where callers don't set an explicit budget\n    and rely on the library's internal default value.\n    \"\"\"\n\n    # Do not set MICRO_BUDGET_TOKENS at all; rely on default inside the helper\n    monkeypatch.delenv(\"MICRO_BUDGET_TOKENS\", raising=False)\n\n    # Keep other knobs small so we still trigger budgeting logic deterministically\n    monkeypatch.setenv(\"MICRO_TOKENS_PER_LINE\", \"10\")\n    monkeypatch.setenv(\"MICRO_MERGE_LINES\", \"2\")\n    monkeypatch.setenv(\"MICRO_OUT_MAX_SPANS\", \"3\")\n\n    items = [\n        _mk_item(\"a.py\", 1, 3, 1.0),\n        _mk_item(\"a.py\", 4, 6, 0.9),\n        _mk_item(\"b.py\", 10, 12, 0.8),\n    ]\n\n    merged = _merge_and_budget_spans(items)\n\n    # We should still get at least one merged span with budgeting metadata\n    assert len(merged) >= 1\n    assert merged[0][\"_merged_start\"] <= merged[0][\"_merged_end\"]\n    assert isinstance(merged[0][\"_budget_tokens\"], int)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}