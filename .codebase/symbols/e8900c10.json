{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/concurrency_tests/hnsw_loom_tests.rs",
  "file_hash": "c9e699b5420522c1f0d4ddb8d5c03bf2076afff6",
  "updated_at": "2025-12-26T17:34:19.924674",
  "symbols": {
    "function_loom_entry_point_race_25": {
      "name": "loom_entry_point_race",
      "type": "function",
      "start_line": 25,
      "end_line": 73,
      "content_hash": "79aca5a47664fa3a4a1cbcbe3e1041b0c26ac3b7",
      "content": "fn loom_entry_point_race() {\n    loom::model(|| {\n        // Simulated entry point - None means no entry point set yet\n        let entry_point = Arc::new(AtomicU64::new(0));\n        let insert_count = Arc::new(AtomicU64::new(0));\n\n        let mut handles = vec![];\n\n        // Two threads both trying to insert and potentially set entry point\n        for thread_id in 1..=2 {\n            let entry_point = Arc::clone(&entry_point);\n            let insert_count = Arc::clone(&insert_count);\n\n            handles.push(thread::spawn(move || {\n                // Simulate: Check if entry point exists\n                let current_entry = entry_point.load(Ordering::SeqCst);\n\n                // Simulate: Insert a new vector (always succeeds)\n                let my_id = insert_count.fetch_add(1, Ordering::SeqCst) + 1;\n\n                // Simulate: If no entry point, try to set it\n                // RACE CONDITION: Both threads could see 0 and both try to set\n                if current_entry == 0 {\n                    // This is the problematic code pattern - non-atomic check-then-set\n                    entry_point.store(thread_id * 100 + my_id, Ordering::SeqCst);\n                }\n\n                my_id\n            }));\n        }\n\n        let results: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();\n\n        // Verify: Both inserts succeeded\n        assert_eq!(results.len(), 2);\n\n        // Entry point should be set to one of the inserted IDs\n        let final_entry = entry_point.load(Ordering::SeqCst);\n        assert!(final_entry > 0, \"Entry point should be set\");\n\n        // Total inserts should be 2\n        assert_eq!(insert_count.load(Ordering::SeqCst), 2);\n    });\n}\n\n/// Model of concurrent entry point reads and writes\n///\n/// Tests the pattern where one thread writes entry point while another reads it\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_entry_point_read_write_race_74": {
      "name": "loom_entry_point_read_write_race",
      "type": "function",
      "start_line": 74,
      "end_line": 107,
      "content_hash": "806598528c2579b4c42fdd6c2a83082176bc95d8",
      "content": "fn loom_entry_point_read_write_race() {\n    loom::model(|| {\n        let entry_point = Arc::new(AtomicU64::new(0));\n\n        let writer_entry = Arc::clone(&entry_point);\n        let reader_entry = Arc::clone(&entry_point);\n\n        // Writer thread: Sets entry point\n        let writer = thread::spawn(move || {\n            writer_entry.store(12345, Ordering::SeqCst);\n        });\n\n        // Reader thread: Reads entry point (might see 0 or 12345)\n        let reader = thread::spawn(move || {\n            reader_entry.load(Ordering::SeqCst)\n        });\n\n        writer.join().unwrap();\n        let read_value = reader.join().unwrap();\n\n        // Should see either 0 (old value) or 12345 (new value), but not garbage\n        assert!(\n            read_value == 0 || read_value == 12345,\n            \"Should see valid value, got {}\",\n            read_value\n        );\n\n        // Final value should be 12345\n        assert_eq!(entry_point.load(Ordering::SeqCst), 12345);\n    });\n}\n\n/// Model of concurrent updates to a counter (simulates neighbor count updates)\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_neighbor_count_race_108": {
      "name": "loom_neighbor_count_race",
      "type": "function",
      "start_line": 108,
      "end_line": 150,
      "content_hash": "8c233b322acde251f6c08686d7546f9790d17284",
      "content": "fn loom_neighbor_count_race() {\n    loom::model(|| {\n        let neighbor_count = Arc::new(AtomicU64::new(0));\n\n        let mut handles = vec![];\n\n        // Two threads both adding neighbors\n        for _ in 0..2 {\n            let count = Arc::clone(&neighbor_count);\n            handles.push(thread::spawn(move || {\n                // Read current count\n                let current = count.load(Ordering::Acquire);\n\n                // Simulate: Check if we can add more neighbors (max 10)\n                if current < 10 {\n                    // RACE: Another thread could increment between load and store\n                    count.store(current + 1, Ordering::Release);\n                }\n            }));\n        }\n\n        for handle in handles {\n            handle.join().unwrap();\n        }\n\n        // With fetch_add, we'd always get 2\n        // With load/store, we might get 1 (lost update)\n        let final_count = neighbor_count.load(Ordering::SeqCst);\n\n        // This test demonstrates the lost update problem\n        // In real code, this should use fetch_add\n        assert!(\n            final_count >= 1 && final_count <= 2,\n            \"Expected 1 or 2, got {}\",\n            final_count\n        );\n    });\n}\n\n/// Model of level generation race\n///\n/// Simulates the race where two threads generate levels and update max level\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_max_level_update_race_151": {
      "name": "loom_max_level_update_race",
      "type": "function",
      "start_line": 151,
      "end_line": 190,
      "content_hash": "ac062d681cddd403519a3331f26fb028a8a41f8a",
      "content": "fn loom_max_level_update_race() {\n    loom::model(|| {\n        let max_level = Arc::new(AtomicU64::new(0));\n\n        let mut handles = vec![];\n\n        // Two threads inserting vectors with potentially new max levels\n        for thread_level in [2, 3] {\n            let max_level = Arc::clone(&max_level);\n            handles.push(thread::spawn(move || {\n                // Read current max level\n                let current_max = max_level.load(Ordering::Acquire);\n\n                // If my level is higher, update max level\n                if thread_level > current_max {\n                    // RACE: Another thread could update between load and store\n                    max_level.store(thread_level, Ordering::Release);\n                }\n            }));\n        }\n\n        for handle in handles {\n            handle.join().unwrap();\n        }\n\n        // Should end up with max level of 3\n        let final_max = max_level.load(Ordering::SeqCst);\n        assert!(\n            final_max >= 2 && final_max <= 3,\n            \"Expected 2 or 3, got {}\",\n            final_max\n        );\n\n        // In a correct implementation with compare_exchange, it should always be 3\n        // With load/store, it could be 2 (lost update)\n    });\n}\n\n/// Model of compare-and-swap for entry point (correct implementation)\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_entry_point_cas_correct_191": {
      "name": "loom_entry_point_cas_correct",
      "type": "function",
      "start_line": 191,
      "end_line": 235,
      "content_hash": "44b71f8080db3d0e75fb4ae55839329b04c3a081",
      "content": "fn loom_entry_point_cas_correct() {\n    loom::model(|| {\n        let entry_point = Arc::new(AtomicU64::new(0));\n\n        let mut handles = vec![];\n\n        // Two threads both trying to set entry point using CAS\n        for thread_id in 1..=2 {\n            let entry_point = Arc::clone(&entry_point);\n            handles.push(thread::spawn(move || {\n                // Try to set entry point if it's 0 (using CAS - atomic check-then-set)\n                let result = entry_point.compare_exchange(\n                    0,\n                    thread_id * 100,\n                    Ordering::SeqCst,\n                    Ordering::SeqCst,\n                );\n\n                result.is_ok() // Returns true if this thread won the race\n            }));\n        }\n\n        let results: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();\n\n        // Exactly one thread should have successfully set the entry point\n        let num_successful = results.iter().filter(|&&success| success).count();\n        assert_eq!(\n            num_successful, 1,\n            \"Exactly one thread should set entry point\"\n        );\n\n        // Entry point should be set\n        let final_entry = entry_point.load(Ordering::SeqCst);\n        assert!(final_entry > 0, \"Entry point should be set\");\n        assert!(\n            final_entry == 100 || final_entry == 200,\n            \"Entry point should be one of the thread IDs\"\n        );\n    });\n}\n\n/// Model of sequential consistency for graph operations\n///\n/// Tests that operations appear in a consistent order to all observers\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_graph_operation_ordering_236": {
      "name": "loom_graph_operation_ordering",
      "type": "function",
      "start_line": 236,
      "end_line": 274,
      "content_hash": "0a2f3222922732dce1f20972eabbf3938abba291",
      "content": "fn loom_graph_operation_ordering() {\n    loom::model(|| {\n        // Simulate: node inserted flag, edges added flag\n        let node_inserted = Arc::new(AtomicU64::new(0));\n        let edges_added = Arc::new(AtomicU64::new(0));\n\n        let writer_node = Arc::clone(&node_inserted);\n        let writer_edges = Arc::clone(&edges_added);\n        let reader_node = Arc::clone(&node_inserted);\n        let reader_edges = Arc::clone(&edges_added);\n\n        // Writer: Insert node, then add edges\n        let writer = thread::spawn(move || {\n            writer_node.store(1, Ordering::SeqCst);\n            writer_edges.store(1, Ordering::SeqCst);\n        });\n\n        // Reader: Check if edges are added, then check if node is inserted\n        let reader = thread::spawn(move || {\n            let edges = reader_edges.load(Ordering::SeqCst);\n            let node = reader_node.load(Ordering::SeqCst);\n            (node, edges)\n        });\n\n        writer.join().unwrap();\n        let (node_seen, edges_seen) = reader.join().unwrap();\n\n        // If edges are added (1), node must be inserted (1)\n        // Can't have edges without node (SeqCst guarantees this)\n        if edges_seen == 1 {\n            assert_eq!(\n                node_seen, 1,\n                \"If edges added, node must be inserted (sequential consistency)\"\n            );\n        }\n    });\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loom_two_writers_one_reader_275": {
      "name": "loom_two_writers_one_reader",
      "type": "function",
      "start_line": 275,
      "end_line": 316,
      "content_hash": "d45be0b3b7044237dde6d767c72047486e168cc1",
      "content": "fn loom_two_writers_one_reader() {\n    // Model of two writers and one reader accessing shared counter\n    //\n    // Tests MVCC-like behavior where reader should see consistent state\n\n    loom::model(|| {\n        let value = Arc::new(AtomicU64::new(0));\n\n        let w1_value = Arc::clone(&value);\n        let w2_value = Arc::clone(&value);\n        let r_value = Arc::clone(&value);\n\n        // Writer 1: Increment value\n        let w1 = thread::spawn(move || {\n            w1_value.fetch_add(1, Ordering::SeqCst);\n        });\n\n        // Writer 2: Increment value\n        let w2 = thread::spawn(move || {\n            w2_value.fetch_add(1, Ordering::SeqCst);\n        });\n\n        // Reader: Read value (should see 0, 1, or 2)\n        let reader = thread::spawn(move || {\n            r_value.load(Ordering::SeqCst)\n        });\n\n        w1.join().unwrap();\n        w2.join().unwrap();\n        let read_value = reader.join().unwrap();\n\n        // Reader should see 0 (before writes), 1 (after one write), or 2 (after both)\n        assert!(\n            read_value <= 2,\n            \"Reader should see valid value, got {}\",\n            read_value\n        );\n\n        // Final value should always be 2\n        assert_eq!(value.load(Ordering::SeqCst), 2);\n    });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}