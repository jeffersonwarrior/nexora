{
  "file_path": "/work/external-deps/claude-mem/src/services/context-generator.ts",
  "file_hash": "2377c40ec6564e0dc539c4dee17187b612ebf9a6",
  "updated_at": "2025-12-26T17:34:21.533206",
  "symbols": {
    "function_loadContextConfig_54": {
      "name": "loadContextConfig",
      "type": "function",
      "start_line": 54,
      "end_line": 94,
      "content_hash": "0aead3845d2943e77ee9c55b1e57c07d4570f04f",
      "content": "function loadContextConfig(): ContextConfig {\n  const settingsPath = path.join(homedir(), '.claude-mem', 'settings.json');\n  const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n\n  // For non-code modes, use all types/concepts from active mode instead of settings\n  const modeId = settings.CLAUDE_MEM_MODE;\n  const isCodeMode = modeId === 'code' || modeId.startsWith('code--');\n\n  let observationTypes: Set<string>;\n  let observationConcepts: Set<string>;\n\n  if (isCodeMode) {\n    // Code mode: use settings-based filtering\n    observationTypes = new Set(\n      settings.CLAUDE_MEM_CONTEXT_OBSERVATION_TYPES.split(',').map((t: string) => t.trim()).filter(Boolean)\n    );\n    observationConcepts = new Set(\n      settings.CLAUDE_MEM_CONTEXT_OBSERVATION_CONCEPTS.split(',').map((c: string) => c.trim()).filter(Boolean)\n    );\n  } else {\n    // Non-code modes: use all types/concepts from active mode\n    const mode = ModeManager.getInstance().getActiveMode();\n    observationTypes = new Set(mode.observation_types.map(t => t.id));\n    observationConcepts = new Set(mode.observation_concepts.map(c => c.id));\n  }\n\n  return {\n    totalObservationCount: parseInt(settings.CLAUDE_MEM_CONTEXT_OBSERVATIONS, 10),\n    fullObservationCount: parseInt(settings.CLAUDE_MEM_CONTEXT_FULL_COUNT, 10),\n    sessionCount: parseInt(settings.CLAUDE_MEM_CONTEXT_SESSION_COUNT, 10),\n    showReadTokens: settings.CLAUDE_MEM_CONTEXT_SHOW_READ_TOKENS === 'true',\n    showWorkTokens: settings.CLAUDE_MEM_CONTEXT_SHOW_WORK_TOKENS === 'true',\n    showSavingsAmount: settings.CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_AMOUNT === 'true',\n    showSavingsPercent: settings.CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_PERCENT === 'true',\n    observationTypes,\n    observationConcepts,\n    fullObservationField: settings.CLAUDE_MEM_CONTEXT_FULL_FIELD as 'narrative' | 'facts',\n    showLastSummary: settings.CLAUDE_MEM_CONTEXT_SHOW_LAST_SUMMARY === 'true',\n    showLastMessage: settings.CLAUDE_MEM_CONTEXT_SHOW_LAST_MESSAGE === 'true',\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_renderSummaryField_152": {
      "name": "renderSummaryField",
      "type": "function",
      "start_line": 152,
      "end_line": 159,
      "content_hash": "637ee64e2d5f915e3e128a77c907247523d7b16c",
      "content": "function renderSummaryField(label: string, value: string | null, color: string, useColors: boolean): string[] {\n  if (!value) return [];\n\n  if (useColors) {\n    return [`${color}${label}:${colors.reset} ${value}`, ''];\n  }\n  return [`**${label}**: ${value}`, ''];\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_cwdToDashed_162": {
      "name": "cwdToDashed",
      "type": "function",
      "start_line": 162,
      "end_line": 164,
      "content_hash": "f159aeedb0e6e4152c4b37db44bca2855e91f91c",
      "content": "function cwdToDashed(cwd: string): string {\n  return cwd.replace(/\\//g, '-');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractPriorMessages_167": {
      "name": "extractPriorMessages",
      "type": "function",
      "start_line": 167,
      "end_line": 212,
      "content_hash": "0635768cd9620e043342a55b68a36266dfcbb0e0",
      "content": "function extractPriorMessages(transcriptPath: string): { userMessage: string; assistantMessage: string } {\n  try {\n    if (!existsSync(transcriptPath)) {\n      return { userMessage: '', assistantMessage: '' };\n    }\n\n    const content = readFileSync(transcriptPath, 'utf-8').trim();\n    if (!content) {\n      return { userMessage: '', assistantMessage: '' };\n    }\n\n    const lines = content.split('\\n').filter(line => line.trim());\n    let lastAssistantMessage = '';\n\n    for (let i = lines.length - 1; i >= 0; i--) {\n      try {\n        const line = lines[i];\n        if (!line.includes('\"type\":\"assistant\"')) {\n          continue;\n        }\n\n        const entry = JSON.parse(line);\n        if (entry.type === 'assistant' && entry.message?.content && Array.isArray(entry.message.content)) {\n          let text = '';\n          for (const block of entry.message.content) {\n            if (block.type === 'text') {\n              text += block.text;\n            }\n          }\n          text = text.replace(/<system-reminder>[\\s\\S]*?<\\/system-reminder>/g, '').trim();\n          if (text) {\n            lastAssistantMessage = text;\n            break;\n          }\n        }\n      } catch (parseError) {\n        continue;\n      }\n    }\n\n    return { userMessage: '', assistantMessage: lastAssistantMessage };\n  } catch (error) {\n    logger.failure('WORKER', `Failed to extract prior messages from transcript`, { transcriptPath }, error as Error);\n    return { userMessage: '', assistantMessage: '' };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateContext_217": {
      "name": "generateContext",
      "type": "function",
      "start_line": 217,
      "end_line": 658,
      "content_hash": "f0e5bfdc0d36afed3ec670bed8b45364dbb4e385",
      "content": "export async function generateContext(input?: ContextInput, useColors: boolean = false): Promise<string> {\n  const config = loadContextConfig();\n  const cwd = input?.cwd ?? process.cwd();\n  const project = getProjectName(cwd);\n\n  let db: SessionStore | null = null;\n  try {\n    db = new SessionStore();\n  } catch (error: any) {\n    if (error.code === 'ERR_DLOPEN_FAILED') {\n      try {\n        unlinkSync(VERSION_MARKER_PATH);\n      } catch (unlinkError) {\n        // Marker might not exist\n      }\n      console.error('Native module rebuild needed - restart Claude Code to auto-fix');\n      return '';\n    }\n    throw error;\n  }\n\n  // Build SQL WHERE clause for observation types\n  const typeArray = Array.from(config.observationTypes);\n  const typePlaceholders = typeArray.map(() => '?').join(',');\n\n  // Build SQL WHERE clause for concepts\n  const conceptArray = Array.from(config.observationConcepts);\n  const conceptPlaceholders = conceptArray.map(() => '?').join(',');\n\n  // Get recent observations\n  const observations = db.db.prepare(`\n    SELECT\n      id, sdk_session_id, type, title, subtitle, narrative,\n      facts, concepts, files_read, files_modified, discovery_tokens,\n      created_at, created_at_epoch\n    FROM observations\n    WHERE project = ?\n      AND type IN (${typePlaceholders})\n      AND EXISTS (\n        SELECT 1 FROM json_each(concepts)\n        WHERE value IN (${conceptPlaceholders})\n      )\n    ORDER BY created_at_epoch DESC\n    LIMIT ?\n  `).all(project, ...typeArray, ...conceptArray, config.totalObservationCount) as Observation[];\n\n  // Get recent summaries\n  const recentSummaries = db.db.prepare(`\n    SELECT id, sdk_session_id, request, investigated, learned, completed, next_steps, created_at, created_at_epoch\n    FROM session_summaries\n    WHERE project = ?\n    ORDER BY created_at_epoch DESC\n    LIMIT ?\n  `).all(project, config.sessionCount + SUMMARY_LOOKAHEAD) as SessionSummary[];\n\n  // Retrieve prior session messages if enabled\n  let priorUserMessage = '';\n  let priorAssistantMessage = '';\n\n  if (config.showLastMessage && observations.length > 0) {\n    const currentSessionId = input?.session_id;\n    const priorSessionObs = observations.find(obs => obs.sdk_session_id !== currentSessionId);\n\n    if (priorSessionObs) {\n      const priorSessionId = priorSessionObs.sdk_session_id;\n      const dashedCwd = cwdToDashed(cwd);\n      const transcriptPath = path.join(homedir(), '.claude', 'projects', dashedCwd, `${priorSessionId}.jsonl`);\n      const messages = extractPriorMessages(transcriptPath);\n      priorUserMessage = messages.userMessage;\n      priorAssistantMessage = messages.assistantMessage;\n    }\n  }\n\n  // If we have neither observations nor summaries, show empty state\n  if (observations.length === 0 && recentSummaries.length === 0) {\n    db?.close();\n    if (useColors) {\n      return `\\n${colors.bright}${colors.cyan}[${project}] recent context${colors.reset}\\n${colors.gray}${'\u2500'.repeat(60)}${colors.reset}\\n\\n${colors.dim}No previous sessions found for this project yet.${colors.reset}\\n`;\n    }\n    return `# [${project}] recent context\\n\\nNo previous sessions found for this project yet.`;\n  }\n\n  const displaySummaries = recentSummaries.slice(0, config.sessionCount);\n  const timelineObs = observations;\n\n  // Build output\n  const output: string[] = [];\n\n  // Header\n  if (useColors) {\n    output.push('');\n    output.push(`${colors.bright}${colors.cyan}[${project}] recent context${colors.reset}`);\n    output.push(`${colors.gray}${'\u2500'.repeat(60)}${colors.reset}`);\n    output.push('');\n  } else {\n    output.push(`# [${project}] recent context`);\n    output.push('');\n  }\n\n  // Chronological Timeline\n  if (timelineObs.length > 0) {\n    // Legend - generate dynamically from active mode\n    const mode = ModeManager.getInstance().getActiveMode();\n    const typeLegendItems = mode.observation_types.map(t => `${t.emoji} ${t.id}`).join(' | ');\n    if (useColors) {\n      output.push(`${colors.dim}Legend: \ud83c\udfaf session-request | ${typeLegendItems}${colors.reset}`);\n    } else {\n      output.push(`**Legend:** \ud83c\udfaf session-request | ${typeLegendItems}`);\n    }\n    output.push('');\n\n    // Column Key\n    if (useColors) {\n      output.push(`${colors.bright}\ud83d\udca1 Column Key${colors.reset}`);\n      output.push(`${colors.dim}  Read: Tokens to read this observation (cost to learn it now)${colors.reset}`);\n      output.push(`${colors.dim}  Work: Tokens spent on work that produced this record (\ud83d\udd0d research, \ud83d\udee0\ufe0f building, \u2696\ufe0f  deciding)${colors.reset}`);\n    } else {\n      output.push(`\ud83d\udca1 **Column Key**:`);\n      output.push(`- **Read**: Tokens to read this observation (cost to learn it now)`);\n      output.push(`- **Work**: Tokens spent on work that produced this record (\ud83d\udd0d research, \ud83d\udee0\ufe0f building, \u2696\ufe0f  deciding)`);\n    }\n    output.push('');\n\n    // Context Index Instructions\n    if (useColors) {\n      output.push(`${colors.dim}\ud83d\udca1 Context Index: This semantic index (titles, types, files, tokens) is usually sufficient to understand past work.${colors.reset}`);\n      output.push('');\n      output.push(`${colors.dim}When you need implementation details, rationale, or debugging context:${colors.reset}`);\n      output.push(`${colors.dim}  - Use the mem-search skill to fetch full observations on-demand${colors.reset}`);\n      output.push(`${colors.dim}  - Critical types (\ud83d\udd34 bugfix, \u2696\ufe0f decision) often need detailed fetching${colors.reset}`);\n      output.push(`${colors.dim}  - Trust this index over re-reading code for past decisions and learnings${colors.reset}`);\n    } else {\n      output.push(`\ud83d\udca1 **Context Index:** This semantic index (titles, types, files, tokens) is usually sufficient to understand past work.`);\n      output.push('');\n      output.push(`When you need implementation details, rationale, or debugging context:`);\n      output.push(`- Use the mem-search skill to fetch full observations on-demand`);\n      output.push(`- Critical types (\ud83d\udd34 bugfix, \u2696\ufe0f decision) often need detailed fetching`);\n      output.push(`- Trust this index over re-reading code for past decisions and learnings`);\n    }\n    output.push('');\n\n    // Context Economics\n    const totalObservations = observations.length;\n    const totalReadTokens = observations.reduce((sum, obs) => {\n      const obsSize = (obs.title?.length || 0) +\n                      (obs.subtitle?.length || 0) +\n                      (obs.narrative?.length || 0) +\n                      JSON.stringify(obs.facts || []).length;\n      return sum + Math.ceil(obsSize / CHARS_PER_TOKEN_ESTIMATE);\n    }, 0);\n    const totalDiscoveryTokens = observations.reduce((sum, obs) => sum + (obs.discovery_tokens || 0), 0);\n    const savings = totalDiscoveryTokens - totalReadTokens;\n    const savingsPercent = totalDiscoveryTokens > 0\n      ? Math.round((savings / totalDiscoveryTokens) * 100)\n      : 0;\n\n    const showContextEconomics = config.showReadTokens || config.showWorkTokens ||\n                                   config.showSavingsAmount || config.showSavingsPercent;\n\n    if (showContextEconomics) {\n      if (useColors) {\n        output.push(`${colors.bright}${colors.cyan}\ud83d\udcca Context Economics${colors.reset}`);\n        output.push(`${colors.dim}  Loading: ${totalObservations} observations (${totalReadTokens.toLocaleString()} tokens to read)${colors.reset}`);\n        output.push(`${colors.dim}  Work investment: ${totalDiscoveryTokens.toLocaleString()} tokens spent on research, building, and decisions${colors.reset}`);\n        if (totalDiscoveryTokens > 0 && (config.showSavingsAmount || config.showSavingsPercent)) {\n          let savingsLine = '  Your savings: ';\n          if (config.showSavingsAmount && config.showSavingsPercent) {\n            savingsLine += `${savings.toLocaleString()} tokens (${savingsPercent}% reduction from reuse)`;\n          } else if (config.showSavingsAmount) {\n            savingsLine += `${savings.toLocaleString()} tokens`;\n          } else {\n            savingsLine += `${savingsPercent}% reduction from reuse`;\n          }\n          output.push(`${colors.green}${savingsLine}${colors.reset}`);\n        }\n        output.push('');\n      } else {\n        output.push(`\ud83d\udcca **Context Economics**:`);\n        output.push(`- Loading: ${totalObservations} observations (${totalReadTokens.toLocaleString()} tokens to read)`);\n        output.push(`- Work investment: ${totalDiscoveryTokens.toLocaleString()} tokens spent on research, building, and decisions`);\n        if (totalDiscoveryTokens > 0 && (config.showSavingsAmount || config.showSavingsPercent)) {\n          let savingsLine = '- Your savings: ';\n          if (config.showSavingsAmount && config.showSavingsPercent) {\n            savingsLine += `${savings.toLocaleString()} tokens (${savingsPercent}% reduction from reuse)`;\n          } else if (config.showSavingsAmount) {\n            savingsLine += `${savings.toLocaleString()} tokens`;\n          } else {\n            savingsLine += `${savingsPercent}% reduction from reuse`;\n          }\n          output.push(savingsLine);\n        }\n        output.push('');\n      }\n    }\n\n    // Prepare summaries for timeline display\n    const mostRecentSummaryId = recentSummaries[0]?.id;\n\n    interface SummaryTimelineItem extends SessionSummary {\n      displayEpoch: number;\n      displayTime: string;\n      shouldShowLink: boolean;\n    }\n\n    const summariesForTimeline: SummaryTimelineItem[] = displaySummaries.map((summary, i) => {\n      const olderSummary = i === 0 ? null : recentSummaries[i + 1];\n      return {\n        ...summary,\n        displayEpoch: olderSummary ? olderSummary.created_at_epoch : summary.created_at_epoch,\n        displayTime: olderSummary ? olderSummary.created_at : summary.created_at,\n        shouldShowLink: summary.id !== mostRecentSummaryId\n      };\n    });\n\n    // Identify which observations should show full details\n    const fullObservationIds = new Set(\n      observations\n        .slice(0, config.fullObservationCount)\n        .map(obs => obs.id)\n    );\n\n    type TimelineItem =\n      | { type: 'observation'; data: Observation }\n      | { type: 'summary'; data: SummaryTimelineItem };\n\n    const timeline: TimelineItem[] = [\n      ...timelineObs.map(obs => ({ type: 'observation' as const, data: obs })),\n      ...summariesForTimeline.map(summary => ({ type: 'summary' as const, data: summary }))\n    ];\n\n    // Sort chronologically\n    timeline.sort((a, b) => {\n      const aEpoch = a.type === 'observation' ? a.data.created_at_epoch : a.data.displayEpoch;\n      const bEpoch = b.type === 'observation' ? b.data.created_at_epoch : b.data.displayEpoch;\n      return aEpoch - bEpoch;\n    });\n\n    // Group by day\n    const itemsByDay = new Map<string, TimelineItem[]>();\n    for (const item of timeline) {\n      const itemDate = item.type === 'observation' ? item.data.created_at : item.data.displayTime;\n      const day = formatDate(itemDate);\n      if (!itemsByDay.has(day)) {\n        itemsByDay.set(day, []);\n      }\n      itemsByDay.get(day)!.push(item);\n    }\n\n    // Sort days chronologically\n    const sortedDays = Array.from(itemsByDay.entries()).sort((a, b) => {\n      const aDate = new Date(a[0]).getTime();\n      const bDate = new Date(b[0]).getTime();\n      return aDate - bDate;\n    });\n\n    // Render each day's timeline\n    for (const [day, dayItems] of sortedDays) {\n      if (useColors) {\n        output.push(`${colors.bright}${colors.cyan}${day}${colors.reset}`);\n        output.push('');\n      } else {\n        output.push(`### ${day}`);\n        output.push('');\n      }\n\n      let currentFile: string | null = null;\n      let lastTime = '';\n      let tableOpen = false;\n\n      for (const item of dayItems) {\n        if (item.type === 'summary') {\n          if (tableOpen) {\n            output.push('');\n            tableOpen = false;\n            currentFile = null;\n            lastTime = '';\n          }\n\n          const summary = item.data;\n          const summaryTitle = `${summary.request || 'Session started'} (${formatDateTime(summary.displayTime)})`;\n\n          if (useColors) {\n            output.push(`\ud83c\udfaf ${colors.yellow}#S${summary.id}${colors.reset} ${summaryTitle}`);\n          } else {\n            output.push(`**\ud83c\udfaf #S${summary.id}** ${summaryTitle}`);\n          }\n          output.push('');\n        } else {\n          const obs = item.data;\n          const file = extractFirstFile(obs.files_modified, cwd);\n\n          if (file !== currentFile) {\n            if (tableOpen) {\n              output.push('');\n            }\n\n            if (useColors) {\n              output.push(`${colors.dim}${file}${colors.reset}`);\n            } else {\n              output.push(`**${file}**`);\n            }\n\n            if (!useColors) {\n              output.push(`| ID | Time | T | Title | Read | Work |`);\n              output.push(`|----|------|---|-------|------|------|`);\n            }\n\n            currentFile = file;\n            tableOpen = true;\n            lastTime = '';\n          }\n\n          const time = formatTime(obs.created_at);\n          const title = obs.title || 'Untitled';\n          const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n          const obsSize = (obs.title?.length || 0) +\n                          (obs.subtitle?.length || 0) +\n                          (obs.narrative?.length || 0) +\n                          JSON.stringify(obs.facts || []).length;\n          const readTokens = Math.ceil(obsSize / CHARS_PER_TOKEN_ESTIMATE);\n          const discoveryTokens = obs.discovery_tokens || 0;\n          const workEmoji = ModeManager.getInstance().getWorkEmoji(obs.type);\n          const discoveryDisplay = discoveryTokens > 0 ? `${workEmoji} ${discoveryTokens.toLocaleString()}` : '-';\n\n          const showTime = time !== lastTime;\n          const timeDisplay = showTime ? time : '';\n          lastTime = time;\n\n          const shouldShowFull = fullObservationIds.has(obs.id);\n\n          if (shouldShowFull) {\n            const detailField = config.fullObservationField === 'narrative'\n              ? obs.narrative\n              : (obs.facts ? parseJsonArray(obs.facts).join('\\n') : null);\n\n            if (useColors) {\n              const timePart = showTime ? `${colors.dim}${time}${colors.reset}` : ' '.repeat(time.length);\n              const readPart = (config.showReadTokens && readTokens > 0) ? `${colors.dim}(~${readTokens}t)${colors.reset}` : '';\n              const discoveryPart = (config.showWorkTokens && discoveryTokens > 0) ? `${colors.dim}(${workEmoji} ${discoveryTokens.toLocaleString()}t)${colors.reset}` : '';\n\n              output.push(`  ${colors.dim}#${obs.id}${colors.reset}  ${timePart}  ${icon}  ${colors.bright}${title}${colors.reset}`);\n              if (detailField) {\n                output.push(`    ${colors.dim}${detailField}${colors.reset}`);\n              }\n              if (readPart || discoveryPart) {\n                output.push(`    ${readPart} ${discoveryPart}`);\n              }\n              output.push('');\n            } else {\n              if (tableOpen) {\n                output.push('');\n                tableOpen = false;\n              }\n\n              output.push(`**#${obs.id}** ${timeDisplay || '\u2033'} ${icon} **${title}**`);\n              if (detailField) {\n                output.push('');\n                output.push(detailField);\n                output.push('');\n              }\n              const tokenParts: string[] = [];\n              if (config.showReadTokens) {\n                tokenParts.push(`Read: ~${readTokens}`);\n              }\n              if (config.showWorkTokens) {\n                tokenParts.push(`Work: ${discoveryDisplay}`);\n              }\n              if (tokenParts.length > 0) {\n                output.push(tokenParts.join(', '));\n              }\n              output.push('');\n              currentFile = null;\n            }\n          } else {\n            if (useColors) {\n              const timePart = showTime ? `${colors.dim}${time}${colors.reset}` : ' '.repeat(time.length);\n              const readPart = (config.showReadTokens && readTokens > 0) ? `${colors.dim}(~${readTokens}t)${colors.reset}` : '';\n              const discoveryPart = (config.showWorkTokens && discoveryTokens > 0) ? `${colors.dim}(${workEmoji} ${discoveryTokens.toLocaleString()}t)${colors.reset}` : '';\n              output.push(`  ${colors.dim}#${obs.id}${colors.reset}  ${timePart}  ${icon}  ${title} ${readPart} ${discoveryPart}`);\n            } else {\n              const readCol = config.showReadTokens ? `~${readTokens}` : '';\n              const workCol = config.showWorkTokens ? discoveryDisplay : '';\n              output.push(`| #${obs.id} | ${timeDisplay || '\u2033'} | ${icon} | ${title} | ${readCol} | ${workCol} |`);\n            }\n          }\n        }\n      }\n\n      if (tableOpen) {\n        output.push('');\n      }\n    }\n\n    // Add full summary details for most recent session\n    const mostRecentSummary = recentSummaries[0];\n    const mostRecentObservation = observations[0];\n\n    const shouldShowSummary = config.showLastSummary &&\n      mostRecentSummary &&\n      (mostRecentSummary.investigated || mostRecentSummary.learned || mostRecentSummary.completed || mostRecentSummary.next_steps) &&\n      (!mostRecentObservation || mostRecentSummary.created_at_epoch > mostRecentObservation.created_at_epoch);\n\n    if (shouldShowSummary) {\n      output.push(...renderSummaryField('Investigated', mostRecentSummary.investigated, colors.blue, useColors));\n      output.push(...renderSummaryField('Learned', mostRecentSummary.learned, colors.yellow, useColors));\n      output.push(...renderSummaryField('Completed', mostRecentSummary.completed, colors.green, useColors));\n      output.push(...renderSummaryField('Next Steps', mostRecentSummary.next_steps, colors.magenta, useColors));\n    }\n\n    // Previously section\n    if (priorAssistantMessage) {\n      output.push('');\n      output.push('---');\n      output.push('');\n      if (useColors) {\n        output.push(`${colors.bright}${colors.magenta}\ud83d\udccb Previously${colors.reset}`);\n        output.push('');\n        output.push(`${colors.dim}A: ${priorAssistantMessage}${colors.reset}`);\n      } else {\n        output.push(`**\ud83d\udccb Previously**`);\n        output.push('');\n        output.push(`A: ${priorAssistantMessage}`);\n      }\n      output.push('');\n    }\n\n    // Footer\n    if (showContextEconomics && totalDiscoveryTokens > 0 && savings > 0) {\n      const workTokensK = Math.round(totalDiscoveryTokens / 1000);\n      output.push('');\n      if (useColors) {\n        output.push(`${colors.dim}\ud83d\udcb0 Access ${workTokensK}k tokens of past research & decisions for just ${totalReadTokens.toLocaleString()}t. Use the mem-search skill to access memories by ID instead of re-reading files.${colors.reset}`);\n      } else {\n        output.push(`\ud83d\udcb0 Access ${workTokensK}k tokens of past research & decisions for just ${totalReadTokens.toLocaleString()}t. Use the mem-search skill to access memories by ID instead of re-reading files.`);\n      }\n    }\n  }\n\n  db?.close();\n  return output.join('\\n').trimEnd();\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}