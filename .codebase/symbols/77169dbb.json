{
  "file_path": "/work/context-engine/scripts/ingest/cli.py",
  "file_hash": "f89fc65dc27373cbc5e6d00dbc6cd3206d9a4cce",
  "updated_at": "2025-12-26T17:34:19.703003",
  "symbols": {
    "function_parse_args_22": {
      "name": "parse_args",
      "type": "function",
      "start_line": 22,
      "end_line": 100,
      "content_hash": "8448e6c5edf4a06dbd43a73980619e540e2a6f0e",
      "content": "def parse_args():\n    \"\"\"Parse command-line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Index code into Qdrant with metadata for MCP code search.\"\n    )\n    parser.add_argument(\"--root\", type=str, default=\".\", help=\"Root directory to index\")\n    parser.add_argument(\n        \"--recreate\",\n        action=\"store_true\",\n        help=\"Recreate the collection before indexing\",\n    )\n    parser.add_argument(\n        \"--no-dedupe\",\n        action=\"store_true\",\n        help=\"Do not delete existing points for each file before inserting\",\n    )\n    parser.add_argument(\n        \"--no-skip-unchanged\",\n        action=\"store_true\",\n        help=\"Do not skip files whose content hash matches existing index\",\n    )\n    # Exclusion controls\n    parser.add_argument(\n        \"--ignore-file\",\n        type=str,\n        default=None,\n        help=\"Path to a .qdrantignore-style file of patterns to exclude\",\n    )\n    parser.add_argument(\n        \"--no-default-excludes\",\n        action=\"store_true\",\n        help=\"Disable default exclusions (models, node_modules, build, venv, .git, etc.)\",\n    )\n    parser.add_argument(\n        \"--exclude\",\n        action=\"append\",\n        default=None,\n        help=\"Additional exclude pattern(s); can be used multiple times or comma-separated\",\n    )\n    # Scaling controls\n    parser.add_argument(\n        \"--batch-size\",\n        type=int,\n        default=None,\n        help=\"Embedding/upsert batch size (default 64)\",\n    )\n    parser.add_argument(\n        \"--chunk-lines\",\n        type=int,\n        default=None,\n        help=\"Max lines per chunk (default 120)\",\n    )\n    parser.add_argument(\n        \"--chunk-overlap\",\n        type=int,\n        default=None,\n        help=\"Overlap lines between chunks (default 20)\",\n    )\n    parser.add_argument(\n        \"--progress-every\",\n        type=int,\n        default=None,\n        help=\"Print progress every N files (default 200; 0 disables)\",\n    )\n    # GLM pseudo tag test\n    parser.add_argument(\n        \"--test-pseudo\",\n        type=str,\n        default=None,\n        help=\"Test generate_pseudo_tags on the given code snippet and print result, then exit\",\n    )\n    parser.add_argument(\n        \"--test-pseudo-file\",\n        type=str,\n        default=None,\n        help=\"Test generate_pseudo_tags on the contents of the given file and print result, then exit\",\n    )\n\n    return parser.parse_args()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_103": {
      "name": "main",
      "type": "function",
      "start_line": 103,
      "end_line": 208,
      "content_hash": "2601f2ff71af25ac009ea5b909c17e9ab3ad195a",
      "content": "def main():\n    \"\"\"Main entry point for the CLI.\"\"\"\n    args = parse_args()\n\n    # Map CLI overrides to env so downstream helpers pick them up\n    if args.ignore_file:\n        os.environ[\"QDRANT_IGNORE_FILE\"] = args.ignore_file\n    if args.no_default_excludes:\n        os.environ[\"QDRANT_DEFAULT_EXCLUDES\"] = \"0\"\n    if args.exclude:\n        parts = []\n        for e in args.exclude:\n            parts.extend([p.strip() for p in str(e).split(\",\") if p.strip()])\n        if parts:\n            os.environ[\"QDRANT_EXCLUDES\"] = \",\".join(parts)\n    if args.batch_size is not None:\n        os.environ[\"INDEX_BATCH_SIZE\"] = str(args.batch_size)\n    if args.chunk_lines is not None:\n        os.environ[\"INDEX_CHUNK_LINES\"] = str(args.chunk_lines)\n    if args.chunk_overlap is not None:\n        os.environ[\"INDEX_CHUNK_OVERLAP\"] = str(args.chunk_overlap)\n    if args.progress_every is not None:\n        os.environ[\"INDEX_PROGRESS_EVERY\"] = str(args.progress_every)\n\n    # Optional test mode: exercise generate_pseudo_tags and exit\n    if args.test_pseudo or args.test_pseudo_file:\n        import json as _json\n\n        code_text = \"\"\n        if args.test_pseudo:\n            code_text = args.test_pseudo\n        if args.test_pseudo_file:\n            try:\n                code_text = Path(args.test_pseudo_file).read_text(\n                    encoding=\"utf-8\", errors=\"ignore\"\n                )\n            except Exception as e:\n                print(f\"[TEST_PSEUDO] Failed to read file {args.test_pseudo_file}: {e}\")\n                return\n\n        if not code_text.strip():\n            print(\"[TEST_PSEUDO] No code text provided\")\n            return\n\n        try:\n            from scripts.refrag_llamacpp import get_runtime_kind\n            runtime = get_runtime_kind()\n        except Exception:\n            runtime = \"unknown\"\n\n        pseudo, tags = \"\", []\n        try:\n            pseudo, tags = generate_pseudo_tags(code_text)\n        except Exception as e:\n            print(f\"[TEST_PSEUDO] Error while generating pseudo tags: {e}\")\n\n        print(\n            _json.dumps(\n                {\n                    \"runtime\": runtime,\n                    \"pseudo\": pseudo,\n                    \"tags\": tags,\n                },\n                ensure_ascii=False,\n                indent=2,\n            )\n        )\n        return\n\n    qdrant_url = os.environ.get(\"QDRANT_URL\", \"http://localhost:6333\")\n    api_key = os.environ.get(\"QDRANT_API_KEY\")\n    collection = os.environ.get(\"COLLECTION_NAME\") or os.environ.get(\"DEFAULT_COLLECTION\") or \"codebase\"\n    model_name = os.environ.get(\"EMBEDDING_MODEL\", \"BAAI/bge-base-en-v1.5\")\n\n    # Resolve collection name based on multi-repo mode\n    multi_repo = bool(is_multi_repo_mode and is_multi_repo_mode())\n    if multi_repo:\n        collection = None\n        print(\"[multi_repo] Multi-repo mode enabled - will create separate collections per repository\")\n    else:\n        if get_collection_name:\n            try:\n                resolved = get_collection_name(str(Path(args.root).resolve()))\n                placeholders = {\"\", \"default-collection\", \"my-collection\", \"codebase\"}\n                if resolved and collection in placeholders:\n                    collection = resolved\n            except Exception:\n                pass\n        if not collection:\n            collection = os.environ.get(\"COLLECTION_NAME\", \"codebase\")\n        print(f\"[single_repo] Single-repo mode enabled - using collection: {collection}\")\n\n    flag = (os.environ.get(\"PSEUDO_BACKFILL_ENABLED\") or \"\").strip().lower()\n    pseudo_mode = \"off\" if flag in {\"1\", \"true\", \"yes\", \"on\"} else \"full\"\n\n    index_repo(\n        Path(args.root).resolve(),\n        qdrant_url,\n        api_key,\n        collection,\n        model_name,\n        args.recreate,\n        dedupe=(not args.no_dedupe),\n        skip_unchanged=(not args.no_skip_unchanged),\n        pseudo_mode=pseudo_mode,\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}