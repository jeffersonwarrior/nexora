{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/response.rs",
  "file_hash": "a123b1b635b2dec842a7db6a3aa1f64c5213547a",
  "updated_at": "2025-12-26T17:34:22.466987",
  "symbols": {
    "struct_Response_6": {
      "name": "Response",
      "type": "struct",
      "start_line": 6,
      "end_line": 10,
      "content_hash": "802f89e84347dc64acc9dd879086e414cb4e9906",
      "content": "pub struct Response {\n    pub body: Vec<u8>,\n    pub fmt: Format,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoResponse_11": {
      "name": "IntoResponse",
      "type": "impl",
      "start_line": 11,
      "end_line": 11,
      "content_hash": "d10ca012ea120c92edc94ccfcbf6046a831314d1",
      "content": "impl IntoResponse for Response {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_response_12": {
      "name": "into_response",
      "type": "method",
      "start_line": 12,
      "end_line": 28,
      "content_hash": "bcfd7c23b545886d3a1228c1c4f9f3ea7764a8a6",
      "content": "    fn into_response(self) -> axum::response::Response {\n        axum::response::Response::builder()\n            .header(CONTENT_TYPE, self.fmt.to_string())\n            .body(axum::body::Body::from(self.body))\n            .expect(\"Should be able to construct response\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // Response Construction Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_construction_29": {
      "name": "test_response_construction",
      "type": "method",
      "start_line": 29,
      "end_line": 40,
      "content_hash": "b87b6d16f1bf55a803b4ee33c5416f3e1770bc74",
      "content": "    fn test_response_construction() {\n        let body = vec![1, 2, 3, 4, 5];\n        let response = Response {\n            body: body.clone(),\n            fmt: Format::Json,\n        };\n\n        assert_eq!(response.body, body);\n        assert!(matches!(response.fmt, Format::Json));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_empty_body_41": {
      "name": "test_response_empty_body",
      "type": "method",
      "start_line": 41,
      "end_line": 50,
      "content_hash": "27f8aae47269d477906a7df17eadbc71844f71e1",
      "content": "    fn test_response_empty_body() {\n        let response = Response {\n            body: vec![],\n            fmt: Format::Json,\n        };\n\n        assert!(response.body.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_large_body_51": {
      "name": "test_response_large_body",
      "type": "method",
      "start_line": 51,
      "end_line": 61,
      "content_hash": "2f1f2f9bef60ba5fea236239f111447e232e280e",
      "content": "    fn test_response_large_body() {\n        let large_body = vec![0u8; 50_000];\n        let response = Response {\n            body: large_body.clone(),\n            fmt: Format::Json,\n        };\n\n        assert_eq!(response.body.len(), 50_000);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_debug_62": {
      "name": "test_response_debug",
      "type": "method",
      "start_line": 62,
      "end_line": 77,
      "content_hash": "eab661db3d4e528ee5817ae8543d43d34af8e702",
      "content": "    fn test_response_debug() {\n        let response = Response {\n            body: vec![1, 2, 3],\n            fmt: Format::Json,\n        };\n\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"Response\"));\n        assert!(debug_str.contains(\"Json\"));\n    }\n\n    // ============================================================================\n    // IntoResponse Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_into_response_78": {
      "name": "test_response_into_response",
      "type": "method",
      "start_line": 78,
      "end_line": 93,
      "content_hash": "9a94892009273c500f69c6b375cd9b92a1fb090d",
      "content": "    fn test_response_into_response() {\n        let body = b\"test response body\".to_vec();\n        let response = Response {\n            body: body.clone(),\n            fmt: Format::Json,\n        };\n\n        let axum_response = response.into_response();\n\n        // Check that the response has the correct content-type header\n        let content_type = axum_response.headers().get(CONTENT_TYPE);\n        assert!(content_type.is_some());\n        assert_eq!(content_type.unwrap().to_str().unwrap(), \"application/json\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_into_response_preserves_body_94": {
      "name": "test_response_into_response_preserves_body",
      "type": "method",
      "start_line": 94,
      "end_line": 109,
      "content_hash": "3dde8c31fefa96bf3290f0b950a968735b30a725",
      "content": "    fn test_response_into_response_preserves_body() {\n        let body = b\"important data\".to_vec();\n        let response = Response {\n            body: body.clone(),\n            fmt: Format::Json,\n        };\n\n        let _ = response.into_response();\n        // If this compiles and runs, the body was successfully moved into the response\n    }\n\n    // ============================================================================\n    // UTF-8 and Edge Cases\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_utf8_body_110": {
      "name": "test_response_utf8_body",
      "type": "method",
      "start_line": 110,
      "end_line": 120,
      "content_hash": "eddba0e3ea0492711dc165bf5e35de0e984b9bff",
      "content": "    fn test_response_utf8_body() {\n        let utf8_text = \"Hello \u4e16\u754c \ud83d\ude80\".as_bytes().to_vec();\n        let response = Response {\n            body: utf8_text.clone(),\n            fmt: Format::Json,\n        };\n\n        assert_eq!(response.body, utf8_text);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_response_binary_body_121": {
      "name": "test_response_binary_body",
      "type": "method",
      "start_line": 121,
      "end_line": 130,
      "content_hash": "569cfcf5f0dbb0c42650301b9716114ec9fbb1b6",
      "content": "    fn test_response_binary_body() {\n        let binary_data = vec![0xFF, 0xFE, 0xFD, 0xFC];\n        let response = Response {\n            body: binary_data.clone(),\n            fmt: Format::Json,\n        };\n\n        assert_eq!(response.body, binary_data);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}