{
  "file_path": "/work/context-engine/scripts/ingest/pseudo.py",
  "file_hash": "d12fdf361a2355e6f4c7485fcb60f42148e29e40",
  "updated_at": "2025-12-26T17:34:24.971915",
  "symbols": {
    "function__pseudo_describe_enabled_20": {
      "name": "_pseudo_describe_enabled",
      "type": "function",
      "start_line": 20,
      "end_line": 30,
      "content_hash": "5590f2b319ea573163cc7e2756788ce31b6f281f",
      "content": "def _pseudo_describe_enabled() -> bool:\n    \"\"\"Check if pseudo description generation is enabled.\"\"\"\n    try:\n        return str(os.environ.get(\"REFRAG_PSEUDO_DESCRIBE\", \"0\")).strip().lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n            \"on\",\n        }\n    except Exception:\n        return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__smart_symbol_reindexing_enabled_33": {
      "name": "_smart_symbol_reindexing_enabled",
      "type": "function",
      "start_line": 33,
      "end_line": 43,
      "content_hash": "e49964338c13519bbd97c9cd8fc802ef125b80b8",
      "content": "def _smart_symbol_reindexing_enabled() -> bool:\n    \"\"\"Check if symbol-aware reindexing is enabled.\"\"\"\n    try:\n        return str(os.environ.get(\"SMART_SYMBOL_REINDEXING\", \"0\")).strip().lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n            \"on\",\n        }\n    except Exception:\n        return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generate_pseudo_tags_46": {
      "name": "generate_pseudo_tags",
      "type": "function",
      "start_line": 46,
      "end_line": 111,
      "content_hash": "b398b8282d24ca762556d4101bbbc26e313e2b9b",
      "content": "def generate_pseudo_tags(text: str) -> Tuple[str, List[str]]:\n    \"\"\"Best-effort: ask local decoder to produce a short label and 3-6 tags.\n    \n    Returns (pseudo, tags). On failure returns (\"\", []).\n    \"\"\"\n    pseudo: str = \"\"\n    tags: list[str] = []\n    if not _pseudo_describe_enabled() or not text.strip():\n        return pseudo, tags\n    try:\n        from scripts.refrag_llamacpp import (\n            LlamaCppRefragClient,\n            is_decoder_enabled,\n            get_runtime_kind,\n        )\n        if not is_decoder_enabled():\n            return \"\", []\n        runtime = get_runtime_kind()\n        # Keep decoding tight/fast \u2013 this is only enrichment for retrieval.\n        if runtime == \"glm\":\n            prompt = (\n                \"You are a JSON-only function that labels code spans for search enrichment.\\n\"\n                \"Respond with a single JSON object and nothing else (no prose, no markdown).\\n\"\n                \"Exact format: {\\\"pseudo\\\": string (<=20 tokens), \\\"tags\\\": [3-6 short strings]}.\\n\"\n                \"Code:\\n\" + text[:2000]\n            )\n            from scripts.refrag_glm import GLMRefragClient\n            client = GLMRefragClient()\n            out = client.generate_with_soft_embeddings(\n                prompt=prompt,\n                max_tokens=int(os.environ.get(\"PSEUDO_MAX_TOKENS\", \"96\") or 96),\n                temperature=float(os.environ.get(\"PSEUDO_TEMPERATURE\", \"0.10\") or 0.10),\n                top_p=float(os.environ.get(\"PSEUDO_TOP_P\", \"0.9\") or 0.9),\n                stop=[\"\\n\\n\"],\n                force_json=True,\n            )\n        else:\n            prompt = (\n                \"You label code spans for search enrichment.\\n\"\n                \"Return strictly JSON: {\\\"pseudo\\\": string (<=20 tokens), \\\"tags\\\": [3-6 short strings]}.\\n\"\n                \"Code:\\n\" + text[:2000]\n            )\n            client = LlamaCppRefragClient()\n            out = client.generate_with_soft_embeddings(\n                prompt=prompt,\n                max_tokens=int(os.environ.get(\"PSEUDO_MAX_TOKENS\", \"96\") or 96),\n                temperature=float(os.environ.get(\"PSEUDO_TEMPERATURE\", \"0.10\") or 0.10),\n                top_k=int(os.environ.get(\"PSEUDO_TOP_K\", \"30\") or 30),\n                top_p=float(os.environ.get(\"PSEUDO_TOP_P\", \"0.9\") or 0.9),\n                stop=[\"\\n\\n\"],\n            )\n        import json as _json\n        try:\n            obj = _json.loads(out)\n            if isinstance(obj, dict):\n                p = obj.get(\"pseudo\")\n                t = obj.get(\"tags\")\n                if isinstance(p, str):\n                    pseudo = p.strip()[:256]\n                if isinstance(t, list):\n                    tags = [str(x).strip() for x in t if str(x).strip()][:6]\n        except Exception:\n            pass\n    except Exception:\n        return \"\", []\n    return pseudo, tags",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_should_process_pseudo_for_chunk_114": {
      "name": "should_process_pseudo_for_chunk",
      "type": "function",
      "start_line": 114,
      "end_line": 162,
      "content_hash": "092942ecf22e5cc1b94bcbfba15465bbc2100a21",
      "content": "def should_process_pseudo_for_chunk(\n    file_path: str, chunk: dict, changed_symbols: set\n) -> Tuple[bool, str, List[str]]:\n    \"\"\"Determine if a chunk needs pseudo processing based on symbol changes AND pseudo cache.\n\n    Uses existing symbol change detection and pseudo cache lookup for optimal performance.\n\n    Args:\n        file_path: Path to the file containing this chunk\n        chunk: Chunk dict with symbol information\n        changed_symbols: Set of symbol IDs that changed (from compare_symbol_changes)\n\n    Returns:\n        (needs_processing, cached_pseudo, cached_tags)\n    \"\"\"\n    # For chunks without symbol info, process them (fallback - no symbol to reuse from)\n    symbol_name = chunk.get(\"symbol\", \"\")\n    if not symbol_name:\n        return True, \"\", []\n\n    # Create symbol ID matching the format used in symbol cache\n    kind = chunk.get(\"kind\", \"unknown\")\n    start_line = chunk.get(\"start\", 0)\n    symbol_id = f\"{kind}_{symbol_name}_{start_line}\"\n\n    # If we don't have any change information, best effort: try reusing cached pseudo when present\n    if not changed_symbols and get_cached_pseudo:\n        try:\n            cached_pseudo, cached_tags = get_cached_pseudo(file_path, symbol_id)\n            if cached_pseudo or cached_tags:\n                return False, cached_pseudo, cached_tags\n        except Exception:\n            pass\n        return True, \"\", []\n\n    # Unchanged symbol: prefer reuse when cached pseudo/tags exist\n    if symbol_id not in changed_symbols:\n        if get_cached_pseudo:\n            try:\n                cached_pseudo, cached_tags = get_cached_pseudo(file_path, symbol_id)\n                if cached_pseudo or cached_tags:\n                    return False, cached_pseudo, cached_tags\n            except Exception:\n                pass\n        # Unchanged but no cached data yet \u2013 process once\n        return True, \"\", []\n\n    # Symbol content changed: always re-run pseudo; do not reuse stale cached values\n    return True, \"\", []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_should_use_smart_reindexing_165": {
      "name": "should_use_smart_reindexing",
      "type": "function",
      "start_line": 165,
      "end_line": 202,
      "content_hash": "78f8a21e5000aacde4d15a15a3aaf09655e73766",
      "content": "def should_use_smart_reindexing(file_path: str, file_hash: str) -> Tuple[bool, str]:\n    \"\"\"Determine if smart reindexing should be used for a file.\n\n    Returns:\n        (use_smart, reason)\n    \"\"\"\n    from scripts.ingest.config import get_cached_symbols, compare_symbol_changes\n    from scripts.ingest.symbols import extract_symbols_with_tree_sitter\n    \n    if not _smart_symbol_reindexing_enabled():\n        return False, \"smart_reindexing_disabled\"\n\n    if not get_cached_symbols:\n        return False, \"symbol_cache_unavailable\"\n\n    # Load cached symbols\n    cached_symbols = get_cached_symbols(file_path)\n    if not cached_symbols:\n        return False, \"no_cached_symbols\"\n\n    # Extract current symbols\n    current_symbols = extract_symbols_with_tree_sitter(file_path)\n    if not current_symbols:\n        return False, \"no_current_symbols\"\n\n    # Compare symbols\n    unchanged_symbols, changed_symbols = compare_symbol_changes(cached_symbols, current_symbols)\n\n    total_symbols = len(current_symbols)\n    changed_ratio = len(changed_symbols) / max(total_symbols, 1)\n\n    # Use thresholds to decide strategy\n    max_changed_ratio = float(os.environ.get(\"MAX_CHANGED_SYMBOLS_RATIO\", \"0.3\"))\n    if changed_ratio > max_changed_ratio:\n        return False, f\"too_many_changes_{changed_ratio:.2f}\"\n\n    print(f\"[SMART_REINDEX] {file_path}: {len(unchanged_symbols)} unchanged, {len(changed_symbols)} changed\")\n    return True, f\"smart_reindex_{len(changed_symbols)}/{total_symbols}\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}