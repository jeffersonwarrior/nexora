{
  "file_path": "/work/external-deps/claude-swarm/src/workers/manager.ts",
  "file_hash": "295e5863f2e95e54aad420f2908f99b3ae76f03c",
  "updated_at": "2025-12-26T17:34:21.657999",
  "symbols": {
    "function_getWorkerFlags_51": {
      "name": "getWorkerFlags",
      "type": "function",
      "start_line": 51,
      "end_line": 77,
      "content_hash": "23a3a7f30574ecb2c7fcc0db7fefa78b7da99978",
      "content": "function getWorkerFlags(): string {\n  const allowedTools = process.env.CLAUDE_SWARM_ALLOWED_TOOLS || DEFAULT_WORKER_TOOLS;\n  const permissionMode = process.env.CLAUDE_SWARM_PERMISSION_MODE || \"bypassPermissions\";\n  const mcpServersJson = process.env.CLAUDE_SWARM_MCP_SERVERS || \"{}\";\n\n  // Parse MCP servers (validate JSON)\n  let mcpServers = {};\n  try {\n    mcpServers = JSON.parse(mcpServersJson);\n  } catch {\n    // Invalid JSON, use empty\n  }\n\n  const flags: string[] = [];\n\n  // Explicitly allow specific tools (bypasses permission prompts for these)\n  flags.push(`--allowedTools \"${allowedTools}\"`);\n\n  // Set permission mode (bypassPermissions for headless workers)\n  flags.push(`--permission-mode ${permissionMode}`);\n\n  // Use inline MCP config with specified servers (empty by default)\n  const mcpConfig = JSON.stringify({ mcpServers });\n  flags.push(`--mcp-config '${mcpConfig}'`);\n\n  return flags.join(\" \");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_WorkerManager_107": {
      "name": "WorkerManager",
      "type": "class",
      "start_line": 107,
      "end_line": 1193,
      "content_hash": "aa4806eac8f3a9fbae7e7bfa8c2fdf838a02c3d2",
      "content": "export class WorkerManager {\n  private projectDir: string;\n  private stateManager: StateManager;\n  private workerDir: string;\n  private monitorInterval: NodeJS.Timeout | null = null;\n  private completionCallbacks: CompletionCallback[] = [];\n  private lastKnownStatus: Map<string, string> = new Map();\n\n  constructor(projectDir: string, stateManager: StateManager) {\n    this.projectDir = projectDir;\n    this.stateManager = stateManager;\n\n    // Directory for worker status files\n    this.workerDir = path.join(\n      projectDir,\n      \".claude\",\n      \"orchestrator\",\n      \"workers\"\n    );\n    if (!fs.existsSync(this.workerDir)) {\n      fs.mkdirSync(this.workerDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Generate a unique session name for a worker\n   */\n  private generateSessionName(featureId: string): string {\n    // Validate feature ID first\n    validateFeatureId(featureId);\n    const timestamp = Date.now().toString(36);\n    return `cc-worker-${featureId}-${timestamp}`;\n  }\n\n  /**\n   * Extract feature ID from session name\n   */\n  private extractFeatureId(sessionName: string): string | null {\n    const match = sessionName.match(/^cc-worker-(.+?)-[a-z0-9]+$/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Read project context files (CLAUDE.md, .clauderc, etc.)\n   * Returns combined content or empty string if none found\n   */\n  private readProjectContext(): string {\n    const contextFiles = [\n      \"CLAUDE.md\",\n      \".claude/CLAUDE.md\",\n      \".clauderc\",\n      \".claude/settings.json\",\n    ];\n\n    const contents: string[] = [];\n\n    for (const file of contextFiles) {\n      const filePath = path.join(this.projectDir, file);\n      if (fs.existsSync(filePath)) {\n        try {\n          const content = fs.readFileSync(filePath, \"utf-8\");\n          // Limit each file to 4000 chars to prevent prompt bloat\n          const truncated =\n            content.length > 4000\n              ? content.substring(0, 4000) + \"\\n... (truncated)\"\n              : content;\n          contents.push(`### From ${file}:\\n${truncated}`);\n        } catch {\n          // Skip unreadable files silently\n        }\n      }\n    }\n\n    return contents.length > 0\n      ? `\\n## Project Context Files\\n${contents.join(\"\\n\\n\")}\\n`\n      : \"\";\n  }\n\n  /**\n   * Build the prompt for a worker\n   */\n  private buildWorkerPrompt(feature: Feature, customPrompt?: string): string {\n    const state = this.stateManager.load();\n    const taskContext = state?.taskDescription || \"\";\n    const projectContext = this.readProjectContext();\n\n    // Build structured prompt with validation criteria if enabled\n    let prompt = \"\";\n\n    if (feature.validation?.enabled) {\n      // Use structured prompt template with success criteria\n      const structuredPrompt = buildStructuredPrompt(feature, customPrompt);\n      prompt = `You are a worker agent focused on implementing a single feature with validation criteria.\n\n${structuredPrompt}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt && !feature.validation?.enabled ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n    } else {\n      // Legacy prompt without validation\n      prompt = `You are a worker agent focused on implementing a single feature.\n\n## Your Task\n${feature.description}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n    }\n\n    return prompt;\n  }\n\n  /**\n   * Build a specialized prompt for planning mode workers\n   * These workers create implementation plans without writing code\n   */\n  private buildPlannerPrompt(\n    feature: Feature,\n    role: \"A\" | \"B\",\n    customPrompt?: string\n  ): string {\n    const state = this.stateManager.load();\n    const taskContext = state?.taskDescription || \"\";\n    const projectContext = this.readProjectContext();\n\n    // Different perspectives based on role\n    const roleGuidance =\n      role === \"A\"\n        ? \"Consider a straightforward, incremental approach. Focus on minimizing risk and using established patterns.\"\n        : \"Consider an alternative or more elegant approach. Look for opportunities to simplify or improve the architecture.\";\n\n    const prompt = `You are a planning agent focused on creating an implementation plan for a feature.\nYour role is to analyze the codebase and create a detailed plan - DO NOT implement any code.\n\n## Your Task\nCreate an implementation plan for: ${feature.description}\n\n## Planning Approach\n${roleGuidance}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Instructions\n1. Explore the codebase to understand the current architecture\n2. Identify the files that need to be created or modified\n3. Create a step-by-step implementation plan\n4. Identify potential risks and how to mitigate them\n5. Output your plan as a JSON file\n\n## Output Format\nCreate a file at: .claude/orchestrator/workers/${feature.id}.plan.json\n\nThe JSON must follow this structure:\n{\n  \"summary\": \"One paragraph overview of the approach\",\n  \"steps\": [\n    {\n      \"order\": 1,\n      \"description\": \"What to do in this step\",\n      \"files\": [\"src/file1.ts\", \"src/file2.ts\"],\n      \"validation\": \"How to verify this step is complete\"\n    }\n  ],\n  \"filesToCreate\": [\"src/newfile.ts\"],\n  \"filesToModify\": [\"src/existing.ts\"],\n  \"testStrategy\": \"How to test the implementation\",\n  \"risks\": [\"Risk 1: description and mitigation\", \"Risk 2: ...\"],\n  \"estimatedComplexity\": \"low\" | \"medium\" | \"high\"\n}\n\n## Important\n- You are in PLANNING mode - do NOT write any implementation code\n- Use Read, Glob, and Grep tools to explore the codebase\n- Focus on understanding existing patterns and conventions\n- Your plan will be evaluated against another planner's approach\n- The winning plan will be used for implementation\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin exploring and planning now.`;\n\n    return prompt;\n  }\n\n  /**\n   * Start a worker in planning mode\n   * Returns a unique session name for tracking\n   */\n  async startPlannerWorker(\n    feature: Feature,\n    role: \"A\" | \"B\",\n    customPrompt?: string\n  ): Promise<StartWorkerResult> {\n    // Validate feature ID\n    try {\n      validateFeatureId(feature.id);\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `Invalid feature ID: ${error.message}`,\n      };\n    }\n\n    // Use role suffix in session name to distinguish planners\n    const timestamp = Date.now().toString(36);\n    const sessionName = `cc-planner-${feature.id}-${role.toLowerCase()}-${timestamp}`;\n    const prompt = this.buildPlannerPrompt(feature, role, customPrompt);\n\n    // Check if tmux is available\n    try {\n      await execFileAsync(\"which\", [\"tmux\"]);\n    } catch {\n      return {\n        success: false,\n        error: \"tmux is not installed. Please install tmux first.\",\n      };\n    }\n\n    try {\n      // Write prompt to a file\n      const promptFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.prompt`\n      );\n      fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n\n      const logFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.log`\n      );\n\n      // Create wrapper script with read-only tools only\n      const wrapperScript = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.sh`\n      );\n\n      // Get worker flags (tools, permissions, MCP config)\n      const workerFlags = getWorkerFlags();\n\n      const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Planner: allowed tools and MCP servers configured via env vars\nclaude ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'PLANNER_EXITED' >> ${shellQuote(logFile)}\n`;\n      fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n\n      // Start tmux session\n      await execFileAsync(\"tmux\", [\n        \"new-session\",\n        \"-d\",\n        \"-s\",\n        sessionName,\n        \"-c\",\n        this.projectDir,\n        \"bash\",\n        wrapperScript,\n      ]);\n\n      // Create status file\n      const statusFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.status`\n      );\n      fs.writeFileSync(\n        statusFile,\n        JSON.stringify({\n          sessionName,\n          featureId: feature.id,\n          role,\n          startedAt: new Date().toISOString(),\n          status: \"running\",\n          mode: \"planning\",\n        })\n      );\n\n      return {\n        success: true,\n        sessionName,\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: sanitizeOutput(error.message),\n      };\n    }\n  }\n\n  /**\n   * Check if a plan file exists for a feature/role\n   */\n  planExists(featureId: string, role: \"A\" | \"B\"): boolean {\n    const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n    // Also check role-specific plan file\n    const rolePlanFile = path.join(\n      this.workerDir,\n      `${featureId}.planner-${role.toLowerCase()}.plan.json`\n    );\n    return fs.existsSync(planFile) || fs.existsSync(rolePlanFile);\n  }\n\n  /**\n   * Read a plan file for a feature\n   */\n  readPlanFile(featureId: string): any | null {\n    const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n    try {\n      if (fs.existsSync(planFile)) {\n        const content = fs.readFileSync(planFile, \"utf-8\");\n        return JSON.parse(content);\n      }\n    } catch {\n      // Return null if parsing fails\n    }\n    return null;\n  }\n\n  /**\n   * Start a worker in a tmux session\n   * Security: Uses file-based prompt passing to avoid shell injection\n   */\n  async startWorker(\n    feature: Feature,\n    customPrompt?: string,\n    model?: \"haiku\" | \"sonnet\" | \"opus\"\n  ): Promise<StartWorkerResult> {\n    // Validate feature ID\n    try {\n      validateFeatureId(feature.id);\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `Invalid feature ID: ${error.message}`,\n      };\n    }\n\n    const sessionName = this.generateSessionName(feature.id);\n    const prompt = this.buildWorkerPrompt(feature, customPrompt);\n\n    // Check if tmux is available\n    try {\n      await execFileAsync(\"which\", [\"tmux\"]);\n    } catch {\n      return {\n        success: false,\n        error: \"tmux is not installed. Please install tmux first.\",\n      };\n    }\n\n    try {\n      // Write prompt to a file instead of passing via shell (prevents injection)\n      const promptFile = path.join(this.workerDir, `${feature.id}.prompt`);\n      fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n\n      const logFile = path.join(this.workerDir, `${feature.id}.log`);\n\n      // Create a wrapper script that reads the prompt from file\n      // This avoids any shell escaping issues\n      const wrapperScript = path.join(this.workerDir, `${feature.id}.sh`);\n\n      // Get worker flags (tools, permissions, MCP config)\n      const workerFlags = getWorkerFlags();\n\n      const modelFlag = model ? `--model claude-${model}-4-5` : \"\";\n      const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Worker: allowed tools and MCP servers configured via env vars\nclaude ${modelFlag} ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'WORKER_EXITED' >> ${shellQuote(logFile)}\n`;\n      fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n\n      // Start tmux session with the wrapper script\n      // Using execFile with explicit arguments avoids shell interpretation\n      await execFileAsync(\"tmux\", [\n        \"new-session\",\n        \"-d\",\n        \"-s\",\n        sessionName,\n        \"-c\",\n        this.projectDir,\n        \"bash\",\n        wrapperScript,\n      ]);\n\n      // Create status file\n      const statusFile = path.join(this.workerDir, `${feature.id}.status`);\n      fs.writeFileSync(\n        statusFile,\n        JSON.stringify({\n          sessionName,\n          featureId: feature.id,\n          startedAt: new Date().toISOString(),\n          status: \"running\",\n        })\n      );\n\n      return {\n        success: true,\n        sessionName,\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: sanitizeOutput(error.message),\n      };\n    }\n  }\n\n  /**\n   * Check the status and output of a worker\n   */\n  async checkWorker(\n    sessionName: string,\n    lines: number = 50\n  ): Promise<CheckWorkerResult> {\n    // Validate session name format\n    if (!validateSessionName(sessionName)) {\n      return {\n        status: \"not_found\",\n        output: \"Invalid session name format\",\n      };\n    }\n\n    try {\n      // Check if session exists using execFile\n      let sessions = \"\";\n      try {\n        const result = await execFileAsync(\"tmux\", [\n          \"list-sessions\",\n          \"-F\",\n          \"#{session_name}\",\n        ]);\n        sessions = result.stdout;\n      } catch {\n        // tmux might not be running, treat as no sessions\n        sessions = \"\";\n      }\n\n      const sessionExists = sessions.includes(sessionName);\n\n      if (!sessionExists) {\n        // Session ended - check for completion file\n        const featureId = this.extractFeatureId(sessionName);\n        if (!featureId) {\n          return {\n            status: \"not_found\",\n            output: \"Could not extract feature ID from session name\",\n          };\n        }\n\n        const doneFile = path.join(this.workerDir, `${featureId}.done`);\n\n        if (fs.existsSync(doneFile)) {\n          const summary = fs.readFileSync(doneFile, \"utf-8\");\n          return {\n            status: \"completed\",\n            output: `Worker completed.\\n\\nSummary:\\n${sanitizeOutput(summary)}`,\n          };\n        }\n\n        // Check log file for crash info\n        const logFile = path.join(this.workerDir, `${featureId}.log`);\n        if (fs.existsSync(logFile)) {\n          const log = fs.readFileSync(logFile, \"utf-8\");\n          const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n          return {\n            status: \"crashed\",\n            output: `Worker session ended unexpectedly.\\n\\nLast output:\\n${sanitizeOutput(lastLines)}`,\n          };\n        }\n\n        return {\n          status: \"not_found\",\n          output: \"Worker session not found and no logs available.\",\n        };\n      }\n\n      // Session is running - capture output using execFile\n      const { stdout: output } = await execFileAsync(\"tmux\", [\n        \"capture-pane\",\n        \"-t\",\n        sessionName,\n        \"-p\",\n        \"-S\",\n        `-${Math.min(lines, 500)}`, // Limit lines to prevent abuse\n      ]);\n\n      // If tmux capture is empty, try reading from log file as fallback\n      if (!output || output.trim() === \"\") {\n        const featureId = this.extractFeatureId(sessionName);\n        if (featureId) {\n          const logFile = path.join(this.workerDir, `${featureId}.log`);\n          if (fs.existsSync(logFile)) {\n            const log = fs.readFileSync(logFile, \"utf-8\");\n            if (log.length > 0) {\n              const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n              return {\n                status: \"running\",\n                output: `(from log file)\\n${sanitizeOutput(lastLines)}`,\n              };\n            }\n          }\n        }\n        // Still empty - worker is initializing\n        return {\n          status: \"running\",\n          output:\n            \"\u23f3 Worker is initializing... (output will appear in 30-60 seconds)\",\n        };\n      }\n\n      return {\n        status: \"running\",\n        output: sanitizeOutput(output),\n      };\n    } catch (error: any) {\n      return {\n        status: \"not_found\",\n        output: sanitizeOutput(error.message),\n      };\n    }\n  }\n\n  /**\n   * Check all workers and return their statuses\n   */\n  async checkAllWorkers(): Promise<WorkerStatus[]> {\n    const state = this.stateManager.load();\n    if (!state) return [];\n\n    const statuses: WorkerStatus[] = [];\n\n    for (const feature of state.features) {\n      if (feature.workerId && validateSessionName(feature.workerId)) {\n        const result = await this.checkWorker(feature.workerId);\n        statuses.push({\n          sessionName: feature.workerId,\n          featureId: feature.id,\n          status:\n            result.status === \"running\"\n              ? \"running\"\n              : result.status === \"completed\"\n                ? \"completed\"\n                : result.status === \"crashed\"\n                  ? \"crashed\"\n                  : \"unknown\",\n          startedAt: feature.startedAt || \"\",\n          lastChecked: new Date().toISOString(),\n        });\n      }\n    }\n\n    return statuses;\n  }\n\n  /**\n   * Get lightweight heartbeat info for a worker (no full output)\n   * Parses log file to extract tool usage, file modifications, and activity\n   */\n  async getHeartbeatInfo(\n    sessionName: string,\n    startedAt?: string\n  ): Promise<HeartbeatInfo> {\n    // First check the basic status\n    const basicResult = await this.checkWorker(sessionName, 10);\n\n    const featureId = this.extractFeatureId(sessionName);\n    if (!featureId) {\n      return {\n        status: basicResult.status,\n        linesWritten: 0,\n        filesModified: [],\n      };\n    }\n\n    const logFile = path.join(this.workerDir, `${featureId}.log`);\n    let linesWritten = 0;\n    let lastToolUsed: string | undefined;\n    let lastFile: string | undefined;\n    const filesModified = new Set<string>();\n\n    if (fs.existsSync(logFile)) {\n      try {\n        const log = fs.readFileSync(logFile, \"utf-8\");\n        const lines = log.split(\"\\n\");\n        linesWritten = lines.length;\n\n        // Parse log for tool usage patterns (scan last 100 lines for efficiency)\n        const recentLines = lines.slice(-100);\n        for (const line of recentLines) {\n          // Match tool usage patterns like \"Read tool\", \"Edit tool\", \"Bash tool\"\n          const toolMatch = line.match(\n            /\\b(Read|Write|Edit|Bash|Glob|Grep)\\b.*?(?:tool|file|command)/i\n          );\n          if (toolMatch) {\n            lastToolUsed = toolMatch[1];\n          }\n\n          // Match file paths in tool output\n          const fileMatch = line.match(\n            /(?:Reading|Writing|Editing|Created|Modified|file_path['\":\\s]+)([^\\s'\"]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html))/i\n          );\n          if (fileMatch) {\n            lastFile = fileMatch[1];\n            filesModified.add(fileMatch[1]);\n          }\n\n          // Also match paths like /src/foo.ts\n          const pathMatch = line.match(\n            /\\/[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html)\\b/\n          );\n          if (pathMatch) {\n            lastFile = pathMatch[0];\n            filesModified.add(pathMatch[0]);\n          }\n        }\n      } catch {\n        // Ignore read errors\n      }\n    }\n\n    // Calculate last activity (use file mtime)\n    let lastActivity: string | undefined;\n    if (fs.existsSync(logFile)) {\n      try {\n        const stat = fs.statSync(logFile);\n        const mtime = stat.mtime;\n        const now = new Date();\n        const diffMs = now.getTime() - mtime.getTime();\n        const diffSec = Math.floor(diffMs / 1000);\n\n        if (diffSec < 60) {\n          lastActivity = `${diffSec}s ago`;\n        } else if (diffSec < 3600) {\n          lastActivity = `${Math.floor(diffSec / 60)}m ago`;\n        } else {\n          lastActivity = `${Math.floor(diffSec / 3600)}h ago`;\n        }\n      } catch {\n        // Ignore stat errors\n      }\n    }\n\n    // Calculate running time\n    let runningFor: string | undefined;\n    if (startedAt) {\n      const startTime = new Date(startedAt);\n      const now = new Date();\n      const diffMs = now.getTime() - startTime.getTime();\n      const diffSec = Math.floor(diffMs / 1000);\n      const mins = Math.floor(diffSec / 60);\n      const secs = diffSec % 60;\n      runningFor = `${mins}m ${secs}s`;\n    }\n\n    // Get confidence score\n    let confidence: AggregatedConfidence | undefined;\n    if (basicResult.status === \"running\") {\n      const confidenceResult = getWorkerConfidence(this.workerDir, featureId);\n      if (confidenceResult) {\n        confidence = confidenceResult;\n      }\n    }\n\n    return {\n      status: basicResult.status,\n      lastToolUsed,\n      lastFile,\n      lastActivity,\n      linesWritten,\n      filesModified: Array.from(filesModified).slice(0, 10), // Limit to 10 files\n      runningFor,\n      confidence,\n    };\n  }\n\n  /**\n   * Register a callback to be notified when workers complete or crash\n   */\n  onWorkerCompletion(callback: CompletionCallback): void {\n    this.completionCallbacks.push(callback);\n  }\n\n  /**\n   * Start monitoring workers for completion\n   * Polls every 10 seconds to detect session exits\n   */\n  startCompletionMonitor(): void {\n    if (this.monitorInterval) {\n      return; // Already monitoring\n    }\n\n    this.monitorInterval = setInterval(async () => {\n      try {\n        await this.checkForCompletions();\n      } catch (error) {\n        console.error(\"Error checking for completions:\", error);\n      }\n    }, 10000); // Check every 10 seconds\n  }\n\n  /**\n   * Stop the completion monitor\n   */\n  stopCompletionMonitor(): void {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }\n\n  /**\n   * Check all tracked workers for completion and notify callbacks\n   */\n  private async checkForCompletions(): Promise<void> {\n    const state = this.stateManager.load();\n    if (!state) return;\n\n    // Get list of in-progress features with workers\n    const activeWorkers = state.features.filter(\n      (f) => f.status === \"in_progress\" && f.workerId\n    );\n\n    for (const feature of activeWorkers) {\n      if (!feature.workerId) continue;\n\n      const currentStatus = await this.checkWorker(feature.workerId, 20);\n      const lastStatus = this.lastKnownStatus.get(feature.id);\n\n      // Track status changes\n      if (lastStatus !== currentStatus.status) {\n        this.lastKnownStatus.set(feature.id, currentStatus.status);\n\n        // Notify on completion or crash (but not initial running status)\n        if (\n          lastStatus === \"running\" &&\n          (currentStatus.status === \"completed\" ||\n            currentStatus.status === \"crashed\")\n        ) {\n          // Notify all registered callbacks\n          for (const callback of this.completionCallbacks) {\n            try {\n              callback(\n                feature.id,\n                currentStatus.status,\n                currentStatus.output\n              );\n            } catch (error) {\n              console.error(\"Error in completion callback:\", error);\n            }\n          }\n        }\n      }\n\n      // Initialize tracking for new workers\n      if (!lastStatus && currentStatus.status === \"running\") {\n        this.lastKnownStatus.set(feature.id, \"running\");\n      }\n    }\n\n    // Clean up tracking for completed features\n    for (const [featureId] of this.lastKnownStatus) {\n      const feature = state.features.find((f) => f.id === featureId);\n      if (!feature || feature.status !== \"in_progress\") {\n        this.lastKnownStatus.delete(featureId);\n      }\n    }\n  }\n\n  /**\n   * Analyze potential conflicts between features for parallel execution\n   * Extracts file/component hints from descriptions and detects overlaps\n   */\n  analyzeFeatureConflicts(\n    features: Feature[]\n  ): Array<{ feature1: string; feature2: string; reason: string }> {\n    const conflicts: Array<{\n      feature1: string;\n      feature2: string;\n      reason: string;\n    }> = [];\n\n    // Extract file/component hints from each feature description\n    const featureHints = features.map((feature) => {\n      const desc = feature.description.toLowerCase();\n\n      // Extract potential file paths\n      const fileMatches = desc.match(\n        /(?:[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html|vue|svelte))/gi\n      ) || [];\n\n      // Extract component/module names\n      const componentMatches = desc.match(\n        /(?:component|module|service|controller|handler|model|route|api|endpoint|hook|context|store|page|layout)\\s*['\":]?\\s*(\\w+)/gi\n      ) || [];\n\n      // Extract folder/directory hints\n      const folderMatches = desc.match(\n        /(?:in|under|to|from|inside)\\s+(?:the\\s+)?['\"\\/]?(src|lib|app|components|pages|routes|api|services|utils|hooks|stores|models|controllers|handlers|config)(?:\\/[\\w\\-]+)*/gi\n      ) || [];\n\n      // Extract action keywords that may conflict\n      const actionMatches = desc.match(\n        /(?:refactor|rewrite|restructure|redesign|overhaul|migrate)\\s+(?:the\\s+)?(\\w+)/gi\n      ) || [];\n\n      return {\n        id: feature.id,\n        description: feature.description,\n        files: fileMatches.map((f) => f.toLowerCase()),\n        components: componentMatches.map((c) => c.toLowerCase()),\n        folders: folderMatches.map((f) => f.toLowerCase()),\n        actions: actionMatches.map((a) => a.toLowerCase()),\n      };\n    });\n\n    // Compare each pair of features for potential conflicts\n    for (let i = 0; i < featureHints.length; i++) {\n      for (let j = i + 1; j < featureHints.length; j++) {\n        const hint1 = featureHints[i];\n        const hint2 = featureHints[j];\n\n        // Check for overlapping files\n        const fileOverlap = hint1.files.filter((f) => hint2.files.includes(f));\n        if (fileOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify file(s): ${fileOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for overlapping components\n        const componentOverlap = hint1.components.filter((c) =>\n          hint2.components.includes(c)\n        );\n        if (componentOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify component(s): ${componentOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for overlapping folders\n        const folderOverlap = hint1.folders.filter((f) =>\n          hint2.folders.includes(f)\n        );\n        if (folderOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify folder(s): ${folderOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for dangerous action combinations\n        if (hint1.actions.length > 0 && hint2.actions.length > 0) {\n          const actionOverlap = hint1.actions.filter((a) =>\n            hint2.actions.some((a2) => a.includes(a2) || a2.includes(a))\n          );\n          if (actionOverlap.length > 0) {\n            conflicts.push({\n              feature1: hint1.id,\n              feature2: hint2.id,\n              reason: `Both involve major changes: ${hint1.actions[0]}, ${hint2.actions[0]}`,\n            });\n          }\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Kill a specific worker session\n   */\n  async killWorker(sessionName: string): Promise<void> {\n    // Validate session name\n    if (!validateSessionName(sessionName)) {\n      return;\n    }\n\n    try {\n      await execFileAsync(\"tmux\", [\"kill-session\", \"-t\", sessionName]);\n    } catch {\n      // Session might already be dead, that's fine\n    }\n  }\n\n  /**\n   * Kill all worker sessions for this project\n   */\n  async killAllWorkers(): Promise<void> {\n    try {\n      // List all sessions\n      let sessions = \"\";\n      try {\n        const result = await execFileAsync(\"tmux\", [\n          \"list-sessions\",\n          \"-F\",\n          \"#{session_name}\",\n        ]);\n        sessions = result.stdout;\n      } catch {\n        sessions = \"\";\n      }\n\n      const workerSessions = sessions\n        .split(\"\\n\")\n        .filter((s) => s.startsWith(\"cc-worker-\") && validateSessionName(s));\n\n      for (const session of workerSessions) {\n        if (session) {\n          await this.killWorker(session);\n        }\n      }\n\n      // Clean up worker files\n      if (fs.existsSync(this.workerDir)) {\n        const files = fs.readdirSync(this.workerDir);\n        for (const file of files) {\n          const filePath = path.join(this.workerDir, file);\n          try {\n            fs.unlinkSync(filePath);\n          } catch {\n            // Ignore errors during cleanup\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error killing workers:\", error);\n    }\n  }\n\n  /**\n   * Wait for a worker to complete (blocking)\n   */\n  async waitForWorker(\n    sessionName: string,\n    timeoutMs: number = 3600000\n  ): Promise<CheckWorkerResult> {\n    if (!validateSessionName(sessionName)) {\n      return {\n        status: \"not_found\",\n        output: \"Invalid session name\",\n      };\n    }\n\n    const startTime = Date.now();\n    const pollInterval = 5000; // Check every 5 seconds\n\n    while (Date.now() - startTime < timeoutMs) {\n      const result = await this.checkWorker(sessionName);\n\n      if (result.status !== \"running\") {\n        return result;\n      }\n\n      // Wait before checking again\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n\n    return {\n      status: \"crashed\",\n      output: \"Worker timed out\",\n    };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_115": {
      "name": "constructor",
      "type": "method",
      "start_line": 115,
      "end_line": 129,
      "content_hash": "fb377d6584f33a28fb98d33c0a9a05bccaafa43a",
      "content": "  constructor(projectDir: string, stateManager: StateManager) {\n    this.projectDir = projectDir;\n    this.stateManager = stateManager;\n\n    // Directory for worker status files\n    this.workerDir = path.join(\n      projectDir,\n      \".claude\",\n      \"orchestrator\",\n      \"workers\"\n    );\n    if (!fs.existsSync(this.workerDir)) {\n      fs.mkdirSync(this.workerDir, { recursive: true });\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generateSessionName_134": {
      "name": "generateSessionName",
      "type": "method",
      "start_line": 134,
      "end_line": 139,
      "content_hash": "f29b335aa2029752e0916770fcc155e398476145",
      "content": "  private generateSessionName(featureId: string): string {\n    // Validate feature ID first\n    validateFeatureId(featureId);\n    const timestamp = Date.now().toString(36);\n    return `cc-worker-${featureId}-${timestamp}`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractFeatureId_144": {
      "name": "extractFeatureId",
      "type": "method",
      "start_line": 144,
      "end_line": 147,
      "content_hash": "2929d4e0d5b9b2b9b98c292d1f1b4f6f07dcae31",
      "content": "  private extractFeatureId(sessionName: string): string | null {\n    const match = sessionName.match(/^cc-worker-(.+?)-[a-z0-9]+$/);\n    return match ? match[1] : null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_readProjectContext_153": {
      "name": "readProjectContext",
      "type": "method",
      "start_line": 153,
      "end_line": 183,
      "content_hash": "9f32601ca60cfc485f3d71457bfa3a6df94f51d3",
      "content": "  private readProjectContext(): string {\n    const contextFiles = [\n      \"CLAUDE.md\",\n      \".claude/CLAUDE.md\",\n      \".clauderc\",\n      \".claude/settings.json\",\n    ];\n\n    const contents: string[] = [];\n\n    for (const file of contextFiles) {\n      const filePath = path.join(this.projectDir, file);\n      if (fs.existsSync(filePath)) {\n        try {\n          const content = fs.readFileSync(filePath, \"utf-8\");\n          // Limit each file to 4000 chars to prevent prompt bloat\n          const truncated =\n            content.length > 4000\n              ? content.substring(0, 4000) + \"\\n... (truncated)\"\n              : content;\n          contents.push(`### From ${file}:\\n${truncated}`);\n        } catch {\n          // Skip unreadable files silently\n        }\n      }\n    }\n\n    return contents.length > 0\n      ? `\\n## Project Context Files\\n${contents.join(\"\\n\\n\")}\\n`\n      : \"\";\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildWorkerPrompt_188": {
      "name": "buildWorkerPrompt",
      "type": "method",
      "start_line": 188,
      "end_line": 323,
      "content_hash": "2c7e606aafce010e53c84eff675e7b380023cfe2",
      "content": "  private buildWorkerPrompt(feature: Feature, customPrompt?: string): string {\n    const state = this.stateManager.load();\n    const taskContext = state?.taskDescription || \"\";\n    const projectContext = this.readProjectContext();\n\n    // Build structured prompt with validation criteria if enabled\n    let prompt = \"\";\n\n    if (feature.validation?.enabled) {\n      // Use structured prompt template with success criteria\n      const structuredPrompt = buildStructuredPrompt(feature, customPrompt);\n      prompt = `You are a worker agent focused on implementing a single feature with validation criteria.\n\n${structuredPrompt}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt && !feature.validation?.enabled ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n    } else {\n      // Legacy prompt without validation\n      prompt = `You are a worker agent focused on implementing a single feature.\n\n## Your Task\n${feature.description}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n    }\n\n    return prompt;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildPlannerPrompt_329": {
      "name": "buildPlannerPrompt",
      "type": "method",
      "start_line": 329,
      "end_line": 397,
      "content_hash": "392d53b000a1d675be1341e0e152c26a1468165d",
      "content": "  private buildPlannerPrompt(\n    feature: Feature,\n    role: \"A\" | \"B\",\n    customPrompt?: string\n  ): string {\n    const state = this.stateManager.load();\n    const taskContext = state?.taskDescription || \"\";\n    const projectContext = this.readProjectContext();\n\n    // Different perspectives based on role\n    const roleGuidance =\n      role === \"A\"\n        ? \"Consider a straightforward, incremental approach. Focus on minimizing risk and using established patterns.\"\n        : \"Consider an alternative or more elegant approach. Look for opportunities to simplify or improve the architecture.\";\n\n    const prompt = `You are a planning agent focused on creating an implementation plan for a feature.\nYour role is to analyze the codebase and create a detailed plan - DO NOT implement any code.\n\n## Your Task\nCreate an implementation plan for: ${feature.description}\n\n## Planning Approach\n${roleGuidance}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Instructions\n1. Explore the codebase to understand the current architecture\n2. Identify the files that need to be created or modified\n3. Create a step-by-step implementation plan\n4. Identify potential risks and how to mitigate them\n5. Output your plan as a JSON file\n\n## Output Format\nCreate a file at: .claude/orchestrator/workers/${feature.id}.plan.json\n\nThe JSON must follow this structure:\n{\n  \"summary\": \"One paragraph overview of the approach\",\n  \"steps\": [\n    {\n      \"order\": 1,\n      \"description\": \"What to do in this step\",\n      \"files\": [\"src/file1.ts\", \"src/file2.ts\"],\n      \"validation\": \"How to verify this step is complete\"\n    }\n  ],\n  \"filesToCreate\": [\"src/newfile.ts\"],\n  \"filesToModify\": [\"src/existing.ts\"],\n  \"testStrategy\": \"How to test the implementation\",\n  \"risks\": [\"Risk 1: description and mitigation\", \"Risk 2: ...\"],\n  \"estimatedComplexity\": \"low\" | \"medium\" | \"high\"\n}\n\n## Important\n- You are in PLANNING mode - do NOT write any implementation code\n- Use Read, Glob, and Grep tools to explore the codebase\n- Focus on understanding existing patterns and conventions\n- Your plan will be evaluated against another planner's approach\n- The winning plan will be used for implementation\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin exploring and planning now.`;\n\n    return prompt;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startPlannerWorker_403": {
      "name": "startPlannerWorker",
      "type": "method",
      "start_line": 403,
      "end_line": 504,
      "content_hash": "0ae71125608fc11272e52c5f7e752204dcf13e99",
      "content": "  async startPlannerWorker(\n    feature: Feature,\n    role: \"A\" | \"B\",\n    customPrompt?: string\n  ): Promise<StartWorkerResult> {\n    // Validate feature ID\n    try {\n      validateFeatureId(feature.id);\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `Invalid feature ID: ${error.message}`,\n      };\n    }\n\n    // Use role suffix in session name to distinguish planners\n    const timestamp = Date.now().toString(36);\n    const sessionName = `cc-planner-${feature.id}-${role.toLowerCase()}-${timestamp}`;\n    const prompt = this.buildPlannerPrompt(feature, role, customPrompt);\n\n    // Check if tmux is available\n    try {\n      await execFileAsync(\"which\", [\"tmux\"]);\n    } catch {\n      return {\n        success: false,\n        error: \"tmux is not installed. Please install tmux first.\",\n      };\n    }\n\n    try {\n      // Write prompt to a file\n      const promptFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.prompt`\n      );\n      fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n\n      const logFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.log`\n      );\n\n      // Create wrapper script with read-only tools only\n      const wrapperScript = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.sh`\n      );\n\n      // Get worker flags (tools, permissions, MCP config)\n      const workerFlags = getWorkerFlags();\n\n      const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Planner: allowed tools and MCP servers configured via env vars\nclaude ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'PLANNER_EXITED' >> ${shellQuote(logFile)}\n`;\n      fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n\n      // Start tmux session\n      await execFileAsync(\"tmux\", [\n        \"new-session\",\n        \"-d\",\n        \"-s\",\n        sessionName,\n        \"-c\",\n        this.projectDir,\n        \"bash\",\n        wrapperScript,\n      ]);\n\n      // Create status file\n      const statusFile = path.join(\n        this.workerDir,\n        `${feature.id}.planner-${role.toLowerCase()}.status`\n      );\n      fs.writeFileSync(\n        statusFile,\n        JSON.stringify({\n          sessionName,\n          featureId: feature.id,\n          role,\n          startedAt: new Date().toISOString(),\n          status: \"running\",\n          mode: \"planning\",\n        })\n      );\n\n      return {\n        success: true,\n        sessionName,\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: sanitizeOutput(error.message),\n      };\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_planExists_509": {
      "name": "planExists",
      "type": "method",
      "start_line": 509,
      "end_line": 517,
      "content_hash": "cc089699f8c3b22aae0f2a4a5a68b630f1eb7c84",
      "content": "  planExists(featureId: string, role: \"A\" | \"B\"): boolean {\n    const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n    // Also check role-specific plan file\n    const rolePlanFile = path.join(\n      this.workerDir,\n      `${featureId}.planner-${role.toLowerCase()}.plan.json`\n    );\n    return fs.existsSync(planFile) || fs.existsSync(rolePlanFile);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_readPlanFile_522": {
      "name": "readPlanFile",
      "type": "method",
      "start_line": 522,
      "end_line": 533,
      "content_hash": "ef31e3d351b5ed2ac10daa470e338a8de1de7940",
      "content": "  readPlanFile(featureId: string): any | null {\n    const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n    try {\n      if (fs.existsSync(planFile)) {\n        const content = fs.readFileSync(planFile, \"utf-8\");\n        return JSON.parse(content);\n      }\n    } catch {\n      // Return null if parsing fails\n    }\n    return null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startWorker_539": {
      "name": "startWorker",
      "type": "method",
      "start_line": 539,
      "end_line": 627,
      "content_hash": "04c5e06d8e3ab91a07133179612a095bd4e14864",
      "content": "  async startWorker(\n    feature: Feature,\n    customPrompt?: string,\n    model?: \"haiku\" | \"sonnet\" | \"opus\"\n  ): Promise<StartWorkerResult> {\n    // Validate feature ID\n    try {\n      validateFeatureId(feature.id);\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `Invalid feature ID: ${error.message}`,\n      };\n    }\n\n    const sessionName = this.generateSessionName(feature.id);\n    const prompt = this.buildWorkerPrompt(feature, customPrompt);\n\n    // Check if tmux is available\n    try {\n      await execFileAsync(\"which\", [\"tmux\"]);\n    } catch {\n      return {\n        success: false,\n        error: \"tmux is not installed. Please install tmux first.\",\n      };\n    }\n\n    try {\n      // Write prompt to a file instead of passing via shell (prevents injection)\n      const promptFile = path.join(this.workerDir, `${feature.id}.prompt`);\n      fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n\n      const logFile = path.join(this.workerDir, `${feature.id}.log`);\n\n      // Create a wrapper script that reads the prompt from file\n      // This avoids any shell escaping issues\n      const wrapperScript = path.join(this.workerDir, `${feature.id}.sh`);\n\n      // Get worker flags (tools, permissions, MCP config)\n      const workerFlags = getWorkerFlags();\n\n      const modelFlag = model ? `--model claude-${model}-4-5` : \"\";\n      const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Worker: allowed tools and MCP servers configured via env vars\nclaude ${modelFlag} ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'WORKER_EXITED' >> ${shellQuote(logFile)}\n`;\n      fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n\n      // Start tmux session with the wrapper script\n      // Using execFile with explicit arguments avoids shell interpretation\n      await execFileAsync(\"tmux\", [\n        \"new-session\",\n        \"-d\",\n        \"-s\",\n        sessionName,\n        \"-c\",\n        this.projectDir,\n        \"bash\",\n        wrapperScript,\n      ]);\n\n      // Create status file\n      const statusFile = path.join(this.workerDir, `${feature.id}.status`);\n      fs.writeFileSync(\n        statusFile,\n        JSON.stringify({\n          sessionName,\n          featureId: feature.id,\n          startedAt: new Date().toISOString(),\n          status: \"running\",\n        })\n      );\n\n      return {\n        success: true,\n        sessionName,\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: sanitizeOutput(error.message),\n      };\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkWorker_632": {
      "name": "checkWorker",
      "type": "method",
      "start_line": 632,
      "end_line": 742,
      "content_hash": "e5ac70a436acdfe8da2552a01f4f1d9813afa869",
      "content": "  async checkWorker(\n    sessionName: string,\n    lines: number = 50\n  ): Promise<CheckWorkerResult> {\n    // Validate session name format\n    if (!validateSessionName(sessionName)) {\n      return {\n        status: \"not_found\",\n        output: \"Invalid session name format\",\n      };\n    }\n\n    try {\n      // Check if session exists using execFile\n      let sessions = \"\";\n      try {\n        const result = await execFileAsync(\"tmux\", [\n          \"list-sessions\",\n          \"-F\",\n          \"#{session_name}\",\n        ]);\n        sessions = result.stdout;\n      } catch {\n        // tmux might not be running, treat as no sessions\n        sessions = \"\";\n      }\n\n      const sessionExists = sessions.includes(sessionName);\n\n      if (!sessionExists) {\n        // Session ended - check for completion file\n        const featureId = this.extractFeatureId(sessionName);\n        if (!featureId) {\n          return {\n            status: \"not_found\",\n            output: \"Could not extract feature ID from session name\",\n          };\n        }\n\n        const doneFile = path.join(this.workerDir, `${featureId}.done`);\n\n        if (fs.existsSync(doneFile)) {\n          const summary = fs.readFileSync(doneFile, \"utf-8\");\n          return {\n            status: \"completed\",\n            output: `Worker completed.\\n\\nSummary:\\n${sanitizeOutput(summary)}`,\n          };\n        }\n\n        // Check log file for crash info\n        const logFile = path.join(this.workerDir, `${featureId}.log`);\n        if (fs.existsSync(logFile)) {\n          const log = fs.readFileSync(logFile, \"utf-8\");\n          const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n          return {\n            status: \"crashed\",\n            output: `Worker session ended unexpectedly.\\n\\nLast output:\\n${sanitizeOutput(lastLines)}`,\n          };\n        }\n\n        return {\n          status: \"not_found\",\n          output: \"Worker session not found and no logs available.\",\n        };\n      }\n\n      // Session is running - capture output using execFile\n      const { stdout: output } = await execFileAsync(\"tmux\", [\n        \"capture-pane\",\n        \"-t\",\n        sessionName,\n        \"-p\",\n        \"-S\",\n        `-${Math.min(lines, 500)}`, // Limit lines to prevent abuse\n      ]);\n\n      // If tmux capture is empty, try reading from log file as fallback\n      if (!output || output.trim() === \"\") {\n        const featureId = this.extractFeatureId(sessionName);\n        if (featureId) {\n          const logFile = path.join(this.workerDir, `${featureId}.log`);\n          if (fs.existsSync(logFile)) {\n            const log = fs.readFileSync(logFile, \"utf-8\");\n            if (log.length > 0) {\n              const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n              return {\n                status: \"running\",\n                output: `(from log file)\\n${sanitizeOutput(lastLines)}`,\n              };\n            }\n          }\n        }\n        // Still empty - worker is initializing\n        return {\n          status: \"running\",\n          output:\n            \"\u23f3 Worker is initializing... (output will appear in 30-60 seconds)\",\n        };\n      }\n\n      return {\n        status: \"running\",\n        output: sanitizeOutput(output),\n      };\n    } catch (error: any) {\n      return {\n        status: \"not_found\",\n        output: sanitizeOutput(error.message),\n      };\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkAllWorkers_747": {
      "name": "checkAllWorkers",
      "type": "method",
      "start_line": 747,
      "end_line": 774,
      "content_hash": "ef0405507cc292f5e7090600dba2fbc855eff72a",
      "content": "  async checkAllWorkers(): Promise<WorkerStatus[]> {\n    const state = this.stateManager.load();\n    if (!state) return [];\n\n    const statuses: WorkerStatus[] = [];\n\n    for (const feature of state.features) {\n      if (feature.workerId && validateSessionName(feature.workerId)) {\n        const result = await this.checkWorker(feature.workerId);\n        statuses.push({\n          sessionName: feature.workerId,\n          featureId: feature.id,\n          status:\n            result.status === \"running\"\n              ? \"running\"\n              : result.status === \"completed\"\n                ? \"completed\"\n                : result.status === \"crashed\"\n                  ? \"crashed\"\n                  : \"unknown\",\n          startedAt: feature.startedAt || \"\",\n          lastChecked: new Date().toISOString(),\n        });\n      }\n    }\n\n    return statuses;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getHeartbeatInfo_780": {
      "name": "getHeartbeatInfo",
      "type": "method",
      "start_line": 780,
      "end_line": 895,
      "content_hash": "087c1032277171a6f1ab83a106692a87e9eb5caf",
      "content": "  async getHeartbeatInfo(\n    sessionName: string,\n    startedAt?: string\n  ): Promise<HeartbeatInfo> {\n    // First check the basic status\n    const basicResult = await this.checkWorker(sessionName, 10);\n\n    const featureId = this.extractFeatureId(sessionName);\n    if (!featureId) {\n      return {\n        status: basicResult.status,\n        linesWritten: 0,\n        filesModified: [],\n      };\n    }\n\n    const logFile = path.join(this.workerDir, `${featureId}.log`);\n    let linesWritten = 0;\n    let lastToolUsed: string | undefined;\n    let lastFile: string | undefined;\n    const filesModified = new Set<string>();\n\n    if (fs.existsSync(logFile)) {\n      try {\n        const log = fs.readFileSync(logFile, \"utf-8\");\n        const lines = log.split(\"\\n\");\n        linesWritten = lines.length;\n\n        // Parse log for tool usage patterns (scan last 100 lines for efficiency)\n        const recentLines = lines.slice(-100);\n        for (const line of recentLines) {\n          // Match tool usage patterns like \"Read tool\", \"Edit tool\", \"Bash tool\"\n          const toolMatch = line.match(\n            /\\b(Read|Write|Edit|Bash|Glob|Grep)\\b.*?(?:tool|file|command)/i\n          );\n          if (toolMatch) {\n            lastToolUsed = toolMatch[1];\n          }\n\n          // Match file paths in tool output\n          const fileMatch = line.match(\n            /(?:Reading|Writing|Editing|Created|Modified|file_path['\":\\s]+)([^\\s'\"]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html))/i\n          );\n          if (fileMatch) {\n            lastFile = fileMatch[1];\n            filesModified.add(fileMatch[1]);\n          }\n\n          // Also match paths like /src/foo.ts\n          const pathMatch = line.match(\n            /\\/[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html)\\b/\n          );\n          if (pathMatch) {\n            lastFile = pathMatch[0];\n            filesModified.add(pathMatch[0]);\n          }\n        }\n      } catch {\n        // Ignore read errors\n      }\n    }\n\n    // Calculate last activity (use file mtime)\n    let lastActivity: string | undefined;\n    if (fs.existsSync(logFile)) {\n      try {\n        const stat = fs.statSync(logFile);\n        const mtime = stat.mtime;\n        const now = new Date();\n        const diffMs = now.getTime() - mtime.getTime();\n        const diffSec = Math.floor(diffMs / 1000);\n\n        if (diffSec < 60) {\n          lastActivity = `${diffSec}s ago`;\n        } else if (diffSec < 3600) {\n          lastActivity = `${Math.floor(diffSec / 60)}m ago`;\n        } else {\n          lastActivity = `${Math.floor(diffSec / 3600)}h ago`;\n        }\n      } catch {\n        // Ignore stat errors\n      }\n    }\n\n    // Calculate running time\n    let runningFor: string | undefined;\n    if (startedAt) {\n      const startTime = new Date(startedAt);\n      const now = new Date();\n      const diffMs = now.getTime() - startTime.getTime();\n      const diffSec = Math.floor(diffMs / 1000);\n      const mins = Math.floor(diffSec / 60);\n      const secs = diffSec % 60;\n      runningFor = `${mins}m ${secs}s`;\n    }\n\n    // Get confidence score\n    let confidence: AggregatedConfidence | undefined;\n    if (basicResult.status === \"running\") {\n      const confidenceResult = getWorkerConfidence(this.workerDir, featureId);\n      if (confidenceResult) {\n        confidence = confidenceResult;\n      }\n    }\n\n    return {\n      status: basicResult.status,\n      lastToolUsed,\n      lastFile,\n      lastActivity,\n      linesWritten,\n      filesModified: Array.from(filesModified).slice(0, 10), // Limit to 10 files\n      runningFor,\n      confidence,\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_onWorkerCompletion_900": {
      "name": "onWorkerCompletion",
      "type": "method",
      "start_line": 900,
      "end_line": 902,
      "content_hash": "91c1255b144c5be9a4517fb6f773c162137a1fe1",
      "content": "  onWorkerCompletion(callback: CompletionCallback): void {\n    this.completionCallbacks.push(callback);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startCompletionMonitor_908": {
      "name": "startCompletionMonitor",
      "type": "method",
      "start_line": 908,
      "end_line": 920,
      "content_hash": "3e09404bc8add56997a07caf7f95be71cf5c0b5a",
      "content": "  startCompletionMonitor(): void {\n    if (this.monitorInterval) {\n      return; // Already monitoring\n    }\n\n    this.monitorInterval = setInterval(async () => {\n      try {\n        await this.checkForCompletions();\n      } catch (error) {\n        console.error(\"Error checking for completions:\", error);\n      }\n    }, 10000); // Check every 10 seconds\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stopCompletionMonitor_925": {
      "name": "stopCompletionMonitor",
      "type": "method",
      "start_line": 925,
      "end_line": 930,
      "content_hash": "f6f78cbc257bc38f72dc6e5346c3c4b4fee191d8",
      "content": "  stopCompletionMonitor(): void {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkForCompletions_935": {
      "name": "checkForCompletions",
      "type": "method",
      "start_line": 935,
      "end_line": 988,
      "content_hash": "e2cb5efd7baf646e0b42363a3ce5058157739234",
      "content": "  private async checkForCompletions(): Promise<void> {\n    const state = this.stateManager.load();\n    if (!state) return;\n\n    // Get list of in-progress features with workers\n    const activeWorkers = state.features.filter(\n      (f) => f.status === \"in_progress\" && f.workerId\n    );\n\n    for (const feature of activeWorkers) {\n      if (!feature.workerId) continue;\n\n      const currentStatus = await this.checkWorker(feature.workerId, 20);\n      const lastStatus = this.lastKnownStatus.get(feature.id);\n\n      // Track status changes\n      if (lastStatus !== currentStatus.status) {\n        this.lastKnownStatus.set(feature.id, currentStatus.status);\n\n        // Notify on completion or crash (but not initial running status)\n        if (\n          lastStatus === \"running\" &&\n          (currentStatus.status === \"completed\" ||\n            currentStatus.status === \"crashed\")\n        ) {\n          // Notify all registered callbacks\n          for (const callback of this.completionCallbacks) {\n            try {\n              callback(\n                feature.id,\n                currentStatus.status,\n                currentStatus.output\n              );\n            } catch (error) {\n              console.error(\"Error in completion callback:\", error);\n            }\n          }\n        }\n      }\n\n      // Initialize tracking for new workers\n      if (!lastStatus && currentStatus.status === \"running\") {\n        this.lastKnownStatus.set(feature.id, \"running\");\n      }\n    }\n\n    // Clean up tracking for completed features\n    for (const [featureId] of this.lastKnownStatus) {\n      const feature = state.features.find((f) => f.id === featureId);\n      if (!feature || feature.status !== \"in_progress\") {\n        this.lastKnownStatus.delete(featureId);\n      }\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_analyzeFeatureConflicts_994": {
      "name": "analyzeFeatureConflicts",
      "type": "method",
      "start_line": 994,
      "end_line": 1097,
      "content_hash": "7947338b3ddcf60d9d528e85133661f7cb2631cf",
      "content": "  analyzeFeatureConflicts(\n    features: Feature[]\n  ): Array<{ feature1: string; feature2: string; reason: string }> {\n    const conflicts: Array<{\n      feature1: string;\n      feature2: string;\n      reason: string;\n    }> = [];\n\n    // Extract file/component hints from each feature description\n    const featureHints = features.map((feature) => {\n      const desc = feature.description.toLowerCase();\n\n      // Extract potential file paths\n      const fileMatches = desc.match(\n        /(?:[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html|vue|svelte))/gi\n      ) || [];\n\n      // Extract component/module names\n      const componentMatches = desc.match(\n        /(?:component|module|service|controller|handler|model|route|api|endpoint|hook|context|store|page|layout)\\s*['\":]?\\s*(\\w+)/gi\n      ) || [];\n\n      // Extract folder/directory hints\n      const folderMatches = desc.match(\n        /(?:in|under|to|from|inside)\\s+(?:the\\s+)?['\"\\/]?(src|lib|app|components|pages|routes|api|services|utils|hooks|stores|models|controllers|handlers|config)(?:\\/[\\w\\-]+)*/gi\n      ) || [];\n\n      // Extract action keywords that may conflict\n      const actionMatches = desc.match(\n        /(?:refactor|rewrite|restructure|redesign|overhaul|migrate)\\s+(?:the\\s+)?(\\w+)/gi\n      ) || [];\n\n      return {\n        id: feature.id,\n        description: feature.description,\n        files: fileMatches.map((f) => f.toLowerCase()),\n        components: componentMatches.map((c) => c.toLowerCase()),\n        folders: folderMatches.map((f) => f.toLowerCase()),\n        actions: actionMatches.map((a) => a.toLowerCase()),\n      };\n    });\n\n    // Compare each pair of features for potential conflicts\n    for (let i = 0; i < featureHints.length; i++) {\n      for (let j = i + 1; j < featureHints.length; j++) {\n        const hint1 = featureHints[i];\n        const hint2 = featureHints[j];\n\n        // Check for overlapping files\n        const fileOverlap = hint1.files.filter((f) => hint2.files.includes(f));\n        if (fileOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify file(s): ${fileOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for overlapping components\n        const componentOverlap = hint1.components.filter((c) =>\n          hint2.components.includes(c)\n        );\n        if (componentOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify component(s): ${componentOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for overlapping folders\n        const folderOverlap = hint1.folders.filter((f) =>\n          hint2.folders.includes(f)\n        );\n        if (folderOverlap.length > 0) {\n          conflicts.push({\n            feature1: hint1.id,\n            feature2: hint2.id,\n            reason: `Both may modify folder(s): ${folderOverlap.join(\", \")}`,\n          });\n          continue;\n        }\n\n        // Check for dangerous action combinations\n        if (hint1.actions.length > 0 && hint2.actions.length > 0) {\n          const actionOverlap = hint1.actions.filter((a) =>\n            hint2.actions.some((a2) => a.includes(a2) || a2.includes(a))\n          );\n          if (actionOverlap.length > 0) {\n            conflicts.push({\n              feature1: hint1.id,\n              feature2: hint2.id,\n              reason: `Both involve major changes: ${hint1.actions[0]}, ${hint2.actions[0]}`,\n            });\n          }\n        }\n      }\n    }\n\n    return conflicts;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_killWorker_1102": {
      "name": "killWorker",
      "type": "method",
      "start_line": 1102,
      "end_line": 1113,
      "content_hash": "8d2d33b1ada8f1550c7aea18e1b744cf8c8cca8e",
      "content": "  async killWorker(sessionName: string): Promise<void> {\n    // Validate session name\n    if (!validateSessionName(sessionName)) {\n      return;\n    }\n\n    try {\n      await execFileAsync(\"tmux\", [\"kill-session\", \"-t\", sessionName]);\n    } catch {\n      // Session might already be dead, that's fine\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_killAllWorkers_1118": {
      "name": "killAllWorkers",
      "type": "method",
      "start_line": 1118,
      "end_line": 1158,
      "content_hash": "f2fe1b199da4d06552b80d8dc4f62c51dd96ed6b",
      "content": "  async killAllWorkers(): Promise<void> {\n    try {\n      // List all sessions\n      let sessions = \"\";\n      try {\n        const result = await execFileAsync(\"tmux\", [\n          \"list-sessions\",\n          \"-F\",\n          \"#{session_name}\",\n        ]);\n        sessions = result.stdout;\n      } catch {\n        sessions = \"\";\n      }\n\n      const workerSessions = sessions\n        .split(\"\\n\")\n        .filter((s) => s.startsWith(\"cc-worker-\") && validateSessionName(s));\n\n      for (const session of workerSessions) {\n        if (session) {\n          await this.killWorker(session);\n        }\n      }\n\n      // Clean up worker files\n      if (fs.existsSync(this.workerDir)) {\n        const files = fs.readdirSync(this.workerDir);\n        for (const file of files) {\n          const filePath = path.join(this.workerDir, file);\n          try {\n            fs.unlinkSync(filePath);\n          } catch {\n            // Ignore errors during cleanup\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error killing workers:\", error);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForWorker_1163": {
      "name": "waitForWorker",
      "type": "method",
      "start_line": 1163,
      "end_line": 1192,
      "content_hash": "fb96fddbf5b5d7ca24209e360f2bebb6648fad3a",
      "content": "  async waitForWorker(\n    sessionName: string,\n    timeoutMs: number = 3600000\n  ): Promise<CheckWorkerResult> {\n    if (!validateSessionName(sessionName)) {\n      return {\n        status: \"not_found\",\n        output: \"Invalid session name\",\n      };\n    }\n\n    const startTime = Date.now();\n    const pollInterval = 5000; // Check every 5 seconds\n\n    while (Date.now() - startTime < timeoutMs) {\n      const result = await this.checkWorker(sessionName);\n\n      if (result.status !== \"running\") {\n        return result;\n      }\n\n      // Wait before checking again\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n\n    return {\n      status: \"crashed\",\n      output: \"Worker timed out\",\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}