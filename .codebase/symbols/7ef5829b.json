{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/traversal_parse_methods.rs",
  "file_hash": "4bbc34784c42da08150980d88cfdc0adf4a2ebc6",
  "updated_at": "2025-12-26T17:34:20.096996",
  "symbols": {
    "impl_HelixParser_12": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 12,
      "end_line": 315,
      "content_hash": "732d8fdd2d7ad899f53fe2daff185116f95fa59d",
      "content": "impl HelixParser {\n    pub(super) fn parse_traversal(&self, pair: Pair<Rule>) -> Result<Traversal, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let start = self.parse_start_node(\n            pairs\n                .next()\n                .ok_or_else(|| ParserError::from(format!(\"Expected start node, got {pair:?}\")))?,\n        )?;\n        let steps = pairs\n            .map(|p| self.parse_step(p))\n            .collect::<Result<Vec<_>, _>>()?;\n\n        Ok(Traversal {\n            start,\n            steps,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_anon_traversal(&self, pair: Pair<Rule>) -> Result<Traversal, ParserError> {\n        let pairs = pair.clone().into_inner();\n        let start = StartNode::Anonymous;\n        let steps = pairs\n            .map(|p| self.parse_step(p))\n            .collect::<Result<Vec<_>, _>>()?;\n\n        Ok(Traversal {\n            start,\n            steps,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_start_node(&self, pair: Pair<Rule>) -> Result<StartNode, ParserError> {\n        match pair.as_rule() {\n            Rule::start_node => {\n                let pairs = pair.into_inner();\n                let mut node_type = String::new();\n                let mut ids = None;\n                for p in pairs {\n                    match p.as_rule() {\n                        Rule::type_args => {\n                            node_type = p.try_inner_next()?.as_str().to_string();\n                            // WATCH\n                        }\n                        Rule::id_args => {\n                            let mut new_ids = Vec::new();\n                            for id in p.into_inner() {\n                                let loc = id.loc();\n                                let id = id.try_inner_next()?;\n                                let id_to_add = match id.as_rule() {\n                                    Rule::identifier => IdType::Identifier {\n                                        value: id.as_str().to_string(),\n                                        loc: loc.clone(),\n                                    },\n                                    Rule::string_literal => IdType::Literal {\n                                        value: id.as_str().to_string(),\n                                        loc: loc.clone(),\n                                    },\n                                    _ => {\n                                        return Err(ParserError::from(\n                                            \"Should be identifier or string literal\",\n                                        ));\n                                    }\n                                };\n                                new_ids.push(id_to_add);\n                            }\n                            ids = Some(new_ids);\n                        }\n                        Rule::by_index => {\n                            ids = Some({\n                                let mut pairs: Pairs<'_, Rule> = p.clone().into_inner();\n                                let index = pairs.try_next_inner().try_next()?;\n                                let index = match index.as_rule() {\n                                    Rule::identifier => IdType::Identifier {\n                                        value: index.as_str().to_string(),\n                                        loc: index.loc(),\n                                    },\n                                    Rule::string_literal => IdType::Literal {\n                                        value: index.as_str().to_string(),\n                                        loc: index.loc(),\n                                    },\n                                    other => {\n                                        return Err(ParserError::from(format!(\n                                            \"Should be identifier or string literal: {other:?}\"\n                                        )));\n                                    }\n                                };\n                                let value = match pairs.try_next_inner()?.next() {\n                                    Some(val) => match val.as_rule() {\n                                        Rule::identifier => ValueType::Identifier {\n                                            value: val.as_str().to_string(),\n                                            loc: val.loc(),\n                                        },\n                                        Rule::string_literal => ValueType::Literal {\n                                            value: Value::from(val.as_str()),\n                                            loc: val.loc(),\n                                        },\n                                        Rule::integer => ValueType::Literal {\n                                            value: Value::from(\n                                                val.as_str().parse::<i64>().map_err(|_| {\n                                                    ParserError::from(\"Invalid integer value\")\n                                                })?,\n                                            ),\n                                            loc: val.loc(),\n                                        },\n                                        Rule::float => ValueType::Literal {\n                                            value: Value::from(\n                                                val.as_str().parse::<f64>().map_err(|_| {\n                                                    ParserError::from(\"Invalid float value\")\n                                                })?,\n                                            ),\n                                            loc: val.loc(),\n                                        },\n                                        Rule::boolean => ValueType::Literal {\n                                            value: Value::from(\n                                                val.as_str().parse::<bool>().map_err(|_| {\n                                                    ParserError::from(\"Invalid boolean value\")\n                                                })?,\n                                            ),\n                                            loc: val.loc(),\n                                        },\n                                        _ => {\n                                            return Err(ParserError::from(\n                                                \"Should be identifier or string literal\",\n                                            ));\n                                        }\n                                    },\n                                    other => return Err(ParserError::from(format!(\n                                        \"Unexpected rule in start_node by_index: {:?}\",\n                                        other\n                                    ))),\n                                };\n                                vec![IdType::ByIndex {\n                                    index: Box::new(index),\n                                    value: Box::new(value),\n                                    loc: p.loc(),\n                                }]\n                            })\n                        }\n                        other => return Err(ParserError::from(format!(\n                            \"Unexpected rule in start_node: {:?}\",\n                            other\n                        ))),\n                    }\n                }\n                Ok(StartNode::Node { node_type, ids })\n            }\n            Rule::start_edge => {\n                let pairs = pair.into_inner();\n                let mut edge_type = String::new();\n                let mut ids = None;\n\n                for p in pairs {\n                    match p.as_rule() {\n                        Rule::type_args => {\n                            edge_type = p.try_inner_next()?.as_str().to_string();\n                        }\n                        Rule::id_args => {\n                            let mut new_ids = Vec::new();\n                            for id in p.into_inner() {\n                                let loc = id.loc();\n                                let id = id.try_inner_next()?;\n                                let id_to_add = match id.as_rule() {\n                                    Rule::identifier => IdType::Identifier {\n                                        value: id.as_str().to_string(),\n                                        loc: loc.clone(),\n                                    },\n                                    Rule::string_literal => IdType::Literal {\n                                        value: id.as_str().to_string(),\n                                        loc: loc.clone(),\n                                    },\n                                    _ => {\n                                        return Err(ParserError::from(\n                                            \"Should be identifier or string literal\",\n                                        ));\n                                    }\n                                };\n                                new_ids.push(id_to_add);\n                            }\n                            ids = Some(new_ids);\n                        }\n                        other => return Err(ParserError::from(format!(\n                            \"Unexpected rule in start_edge: {:?}\",\n                            other\n                        ))),\n                    }\n                }\n                Ok(StartNode::Edge { edge_type, ids })\n            }\n            Rule::identifier => Ok(StartNode::Identifier(pair.as_str().to_string())),\n            Rule::search_vector => Ok(StartNode::SearchVector(self.parse_search_vector(pair)?)),\n            Rule::start_vector => {\n                let pairs = pair.into_inner();\n                let mut vector_type = String::new();\n                let mut ids = None;\n                for p in pairs {\n                    match p.as_rule() {\n                        Rule::type_args => {\n                            vector_type = p.try_inner_next()?.as_str().to_string();\n                        }\n                        Rule::id_args => {\n                            let mut new_ids = Vec::new();\n                            for id in p.into_inner() {\n                                let id = id.try_inner_next()?;\n                                let id_to_add = match id.as_rule() {\n                                    Rule::identifier => IdType::Identifier {\n                                        value: id.as_str().to_string(),\n                                        loc: id.loc(),\n                                    },\n                                    Rule::string_literal => IdType::Literal {\n                                        value: id.as_str().to_string(),\n                                        loc: id.loc(),\n                                    },\n                                    _ => {\n                                        return Err(ParserError::from(\n                                            \"Should be identifier or string literal\",\n                                        ));\n                                    }\n                                };\n                                new_ids.push(id_to_add);\n                            }\n                            ids = Some(new_ids);\n                        }\n                        Rule::by_index => {\n                            let mut new_ids = Vec::new();\n                            for p in p.into_inner() {\n                                let mut pairs = p.clone().into_inner();\n                                let index_inner = pairs.try_next_inner()?.try_next()?;\n                                let index = match index_inner.as_rule() {\n                                    Rule::identifier => IdType::Identifier {\n                                        value: index_inner.as_str().to_string(),\n                                        loc: index_inner.loc(),\n                                    },\n                                    Rule::string_literal => IdType::Literal {\n                                        value: index_inner.as_str().to_string(),\n                                        loc: index_inner.loc(),\n                                    },\n                                    _ => {\n                                        return Err(ParserError::from(\n                                            \"Should be identifier or string literal\",\n                                        ));\n                                    }\n                                };\n                                let value_inner = pairs.try_next_inner()?.try_next()?;\n                                let value = match value_inner.as_rule() {\n                                    Rule::identifier => ValueType::Identifier {\n                                        value: value_inner.as_str().to_string(),\n                                        loc: value_inner.loc(),\n                                    },\n                                    Rule::string_literal => ValueType::Literal {\n                                        value: Value::from(value_inner.as_str()),\n                                        loc: value_inner.loc(),\n                                    },\n                                    Rule::integer => ValueType::Literal {\n                                        value: Value::from(\n                                            value_inner.as_str().parse::<i64>().map_err(|_| {\n                                                ParserError::from(\"Invalid integer value\")\n                                            })?,\n                                        ),\n                                        loc: value_inner.loc(),\n                                    },\n                                    Rule::float => ValueType::Literal {\n                                        value: Value::from(\n                                            value_inner.as_str().parse::<f64>().map_err(|_| {\n                                                ParserError::from(\"Invalid float value\")\n                                            })?,\n                                        ),\n                                        loc: value_inner.loc(),\n                                    },\n                                    Rule::boolean => ValueType::Literal {\n                                        value: Value::from(\n                                            value_inner.as_str().parse::<bool>().map_err(|_| {\n                                                ParserError::from(\"Invalid boolean value\")\n                                            })?,\n                                        ),\n                                        loc: value_inner.loc(),\n                                    },\n                                    _ => {\n                                        return Err(ParserError::from(\n                                            \"Should be identifier or literal\",\n                                        ));\n                                    }\n                                };\n                                new_ids.push(IdType::ByIndex {\n                                    index: Box::new(index),\n                                    value: Box::new(value),\n                                    loc: p.loc(),\n                                });\n                            }\n                            ids = Some(new_ids);\n                        }\n                        other => return Err(ParserError::from(format!(\n                            \"Unexpected rule in start_vector: {:?}\",\n                            other\n                        ))),\n                    }\n                }\n                Ok(StartNode::Vector { vector_type, ids })\n            }\n            _ => Ok(StartNode::Anonymous),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}