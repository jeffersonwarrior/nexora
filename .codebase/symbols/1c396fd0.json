{
  "file_path": "/work/external-deps/claude-mem/src/services/process/ProcessManager.ts",
  "file_hash": "d7d856de361664e60ea3807641f1e720786393e0",
  "updated_at": "2025-12-26T17:34:22.426628",
  "symbols": {
    "class_ProcessManager_21": {
      "name": "ProcessManager",
      "type": "class",
      "start_line": 21,
      "end_line": 433,
      "content_hash": "99247d47ad05fb5afc27e3e21153dbb98c76443a",
      "content": "export class ProcessManager {\n  static async start(port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    // Validate port range\n    if (isNaN(port) || port < 1024 || port > 65535) {\n      return {\n        success: false,\n        error: `Invalid port ${port}. Must be between 1024 and 65535`\n      };\n    }\n\n    // Check if already running\n    if (await this.isRunning()) {\n      const info = this.getPidInfo();\n      return { success: true, pid: info?.pid };\n    }\n\n    // Ensure log directory exists\n    mkdirSync(LOG_DIR, { recursive: true });\n\n    // On Windows, use the wrapper script to solve zombie port problem\n    // On Unix, use the worker directly\n    const scriptName = process.platform === 'win32' ? 'worker-wrapper.cjs' : 'worker-service.cjs';\n    const workerScript = join(MARKETPLACE_ROOT, 'plugin', 'scripts', scriptName);\n\n    if (!existsSync(workerScript)) {\n      return { success: false, error: `Worker script not found at ${workerScript}` };\n    }\n\n    const logFile = this.getLogFilePath();\n\n    // Use Bun on all platforms with PowerShell workaround for Windows console popups\n    return this.startWithBun(workerScript, logFile, port);\n  }\n\n  private static isBunAvailable(): boolean {\n    return isBunAvailable();\n  }\n\n  /**\n   * Escapes a string for safe use in PowerShell single-quoted strings.\n   * In PowerShell single quotes, the only special character is the single quote itself,\n   * which must be doubled to escape it.\n   */\n  private static escapePowerShellString(str: string): string {\n    return str.replace(/'/g, \"''\");\n  }\n\n  private static async startWithBun(script: string, logFile: string, port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    const bunPath = getBunPath();\n    if (!bunPath) {\n      return {\n        success: false,\n        error: 'Bun is required but not found in PATH or common installation paths. Install from https://bun.sh'\n      };\n    }\n    try {\n      const isWindows = process.platform === 'win32';\n\n      if (isWindows) {\n        // Windows: Use PowerShell Start-Process with -WindowStyle Hidden\n        // This properly hides the console window (affects both Bun and Node.js)\n        // Note: windowsHide: true doesn't work with detached: true (Bun inherits Node.js process spawning semantics)\n        // See: https://github.com/nodejs/node/issues/21825 and PR #315 for detailed testing\n        //\n        // On Windows, we start worker-wrapper.cjs which manages the actual worker-service.cjs.\n        // This solves the zombie port problem: the wrapper has no sockets, so when it kills\n        // and respawns the inner worker, the socket is properly released.\n        //\n        // Security: All paths (bunPath, script, MARKETPLACE_ROOT) are application-controlled system paths,\n        // not user input. If an attacker could modify these paths, they would already have full filesystem\n        // access including direct access to ~/.claude-mem/claude-mem.db. Nevertheless, we properly escape\n        // all values for PowerShell to follow security best practices.\n        const escapedBunPath = this.escapePowerShellString(bunPath);\n        const escapedScript = this.escapePowerShellString(script);\n        const escapedWorkDir = this.escapePowerShellString(MARKETPLACE_ROOT);\n        const escapedLogFile = this.escapePowerShellString(logFile);\n        const envVars = `$env:CLAUDE_MEM_WORKER_PORT='${port}'`;\n        const psCommand = `${envVars}; Start-Process -FilePath '${escapedBunPath}' -ArgumentList '${escapedScript}' -WorkingDirectory '${escapedWorkDir}' -WindowStyle Hidden -RedirectStandardOutput '${escapedLogFile}' -RedirectStandardError '${escapedLogFile}.err' -PassThru | Select-Object -ExpandProperty Id`;\n\n        const result = spawnSync('powershell', ['-Command', psCommand], {\n          stdio: 'pipe',\n          timeout: 10000,\n          windowsHide: true\n        });\n\n        if (result.status !== 0) {\n          return {\n            success: false,\n            error: `PowerShell spawn failed: ${result.stderr?.toString() || 'unknown error'}`\n          };\n        }\n\n        const pid = parseInt(result.stdout.toString().trim(), 10);\n        if (isNaN(pid)) {\n          return { success: false, error: 'Failed to get PID from PowerShell' };\n        }\n\n        // Write PID file\n        this.writePidFile({\n          pid,\n          port,\n          startedAt: new Date().toISOString(),\n          version: process.env.npm_package_version || 'unknown'\n        });\n\n        // Wait for health\n        return this.waitForHealth(pid, port);\n      } else {\n        // Unix: Use standard spawn with detached\n        const child = spawn(bunPath, [script], {\n          detached: true,\n          stdio: ['ignore', 'pipe', 'pipe'],\n          env: { ...process.env, CLAUDE_MEM_WORKER_PORT: String(port) },\n          cwd: MARKETPLACE_ROOT\n        });\n\n        // Write logs\n        const logStream = createWriteStream(logFile, { flags: 'a' });\n        child.stdout?.pipe(logStream);\n        child.stderr?.pipe(logStream);\n\n        child.unref();\n\n        if (!child.pid) {\n          return { success: false, error: 'Failed to get PID from spawned process' };\n        }\n\n        // Write PID file\n        this.writePidFile({\n          pid: child.pid,\n          port,\n          startedAt: new Date().toISOString(),\n          version: process.env.npm_package_version || 'unknown'\n        });\n\n        // Wait for health\n        return this.waitForHealth(child.pid, port);\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  static async stop(timeout: number = 5000): Promise<boolean> {\n    const info = this.getPidInfo();\n\n    if (process.platform === 'win32') {\n      // Windows: Try graceful HTTP shutdown first - this works regardless of PID file state\n      // because the worker shuts itself down from the inside (via wrapper IPC)\n      const port = info?.port ?? this.getPortFromSettings();\n      const httpShutdownSucceeded = await this.tryHttpShutdown(port);\n\n      if (httpShutdownSucceeded) {\n        // HTTP shutdown succeeded - worker confirmed down, safe to remove PID file\n        this.removePidFile();\n        return true;\n      }\n\n      // HTTP shutdown failed (worker not responding), fall back to taskkill\n      if (!info) {\n        // No PID file and HTTP failed - nothing more we can do\n        return true;\n      }\n\n      const { execSync } = await import('child_process');\n      try {\n        // Use taskkill /T /F to kill entire process tree\n        // This ensures the wrapper AND all its children (inner worker, MCP, ChromaSync) are killed\n        // which is necessary to properly release the socket and avoid zombie ports\n        execSync(`taskkill /PID ${info.pid} /T /F`, { timeout: 10000, stdio: 'ignore' });\n      } catch {\n        // Process may already be dead\n      }\n\n      // Wait for process to actually exit before removing PID file\n      try {\n        await this.waitForExit(info.pid, timeout);\n      } catch {\n        // Timeout waiting - process may still be alive\n      }\n\n      // Only remove PID file if process is confirmed dead\n      if (!this.isProcessAlive(info.pid)) {\n        this.removePidFile();\n      }\n      return true;\n    } else {\n      // Unix: Use signals (unchanged behavior)\n      if (!info) return true;\n\n      try {\n        process.kill(info.pid, 'SIGTERM');\n        await this.waitForExit(info.pid, timeout);\n      } catch {\n        try {\n          process.kill(info.pid, 'SIGKILL');\n        } catch {\n          // Process already dead\n        }\n      }\n\n      this.removePidFile();\n      return true;\n    }\n  }\n\n  static async restart(port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    await this.stop();\n    return this.start(port);\n  }\n\n  static async status(): Promise<{ running: boolean; pid?: number; port?: number; uptime?: string }> {\n    const info = this.getPidInfo();\n    if (!info) return { running: false };\n\n    const running = this.isProcessAlive(info.pid);\n    return {\n      running,\n      pid: running ? info.pid : undefined,\n      port: running ? info.port : undefined,\n      uptime: running ? this.formatUptime(info.startedAt) : undefined\n    };\n  }\n\n  static async isRunning(): Promise<boolean> {\n    const info = this.getPidInfo();\n    if (!info) return false;\n    const alive = this.isProcessAlive(info.pid);\n    if (!alive) {\n      this.removePidFile(); // Clean up stale PID file\n    }\n    return alive;\n  }\n\n  /**\n   * Get worker port from settings file\n   */\n  private static getPortFromSettings(): number {\n    try {\n      const settingsPath = join(DATA_DIR, 'settings.json');\n      const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n      return parseInt(settings.CLAUDE_MEM_WORKER_PORT, 10);\n    } catch {\n      return parseInt(SettingsDefaultsManager.get('CLAUDE_MEM_WORKER_PORT'), 10);\n    }\n  }\n\n  /**\n   * Try to shut down the worker via HTTP endpoint\n   * Returns true if shutdown succeeded, false if worker not responding\n   */\n  private static async tryHttpShutdown(port: number): Promise<boolean> {\n    try {\n      // Send shutdown request\n      const response = await fetch(`http://127.0.0.1:${port}/api/admin/shutdown`, {\n        method: 'POST',\n        signal: AbortSignal.timeout(2000)\n      });\n\n      if (!response.ok) {\n        return false;\n      }\n\n      // Wait for worker to actually stop responding\n      return await this.waitForWorkerDown(port, 5000);\n    } catch {\n      // Worker not responding to HTTP - it may be dead or hung\n      return false;\n    }\n  }\n\n  /**\n   * Wait for worker to stop responding on the given port\n   */\n  private static async waitForWorkerDown(port: number, timeout: number): Promise<boolean> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      try {\n        await fetch(`http://127.0.0.1:${port}/api/health`, {\n          signal: AbortSignal.timeout(500)\n        });\n        // Still responding, wait and retry\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } catch {\n        // Worker stopped responding - success\n        return true;\n      }\n    }\n\n    // Timeout - worker still responding\n    return false;\n  }\n\n  // Helper methods\n  private static getPidInfo(): PidInfo | null {\n    try {\n      if (!existsSync(PID_FILE)) return null;\n      const content = readFileSync(PID_FILE, 'utf-8');\n      const parsed = JSON.parse(content);\n      // Validate required fields have correct types\n      if (typeof parsed.pid !== 'number' || typeof parsed.port !== 'number') {\n        logger.warn('PROCESS', 'Malformed PID file: missing or invalid pid/port fields', {}, { parsed });\n        return null;\n      }\n      return parsed as PidInfo;\n    } catch (error) {\n      logger.warn('PROCESS', 'Failed to read PID file', {}, {\n        error: error instanceof Error ? error.message : String(error),\n        path: PID_FILE\n      });\n      return null;\n    }\n  }\n\n  private static writePidFile(info: PidInfo): void {\n    mkdirSync(DATA_DIR, { recursive: true });\n    writeFileSync(PID_FILE, JSON.stringify(info, null, 2));\n  }\n\n  private static removePidFile(): void {\n    try {\n      if (existsSync(PID_FILE)) {\n        unlinkSync(PID_FILE);\n      }\n    } catch {\n      // Ignore errors\n    }\n  }\n\n  private static isProcessAlive(pid: number): boolean {\n    try {\n      process.kill(pid, 0);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private static async waitForHealth(pid: number, port: number, timeoutMs: number = 10000): Promise<{ success: boolean; pid?: number; error?: string }> {\n    const startTime = Date.now();\n    const isWindows = process.platform === 'win32';\n    // Increase timeout on Windows to account for slower process startup\n    const adjustedTimeout = isWindows ? timeoutMs * 2 : timeoutMs;\n\n    while (Date.now() - startTime < adjustedTimeout) {\n      // Check if process is still alive\n      if (!this.isProcessAlive(pid)) {\n        const errorMsg = isWindows\n          ? `Process died during startup\\n\\nTroubleshooting:\\n1. Check Task Manager for zombie 'bun.exe' or 'node.exe' processes\\n2. Verify port ${port} is not in use: netstat -ano | findstr ${port}\\n3. Check worker logs in ~/.claude-mem/logs/\\n4. See GitHub issues: #363, #367, #371, #373\\n5. Docs: https://docs.claude-mem.ai/troubleshooting/windows-issues`\n          : 'Process died during startup';\n        return { success: false, error: errorMsg };\n      }\n\n      // Try readiness check (changed from /health to /api/readiness)\n      try {\n        const response = await fetch(`http://127.0.0.1:${port}/api/readiness`, {\n          signal: AbortSignal.timeout(1000)\n        });\n        if (response.ok) {\n          return { success: true, pid };\n        }\n      } catch {\n        // Not ready yet, continue polling\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 200));\n    }\n\n    const timeoutMsg = isWindows\n      ? `Worker failed to start on Windows (readiness check timed out after ${adjustedTimeout}ms)\\n\\nTroubleshooting:\\n1. Check Task Manager for zombie 'bun.exe' or 'node.exe' processes\\n2. Verify port ${port} is not in use: netstat -ano | findstr ${port}\\n3. Check worker logs in ~/.claude-mem/logs/\\n4. See GitHub issues: #363, #367, #371, #373\\n5. Docs: https://docs.claude-mem.ai/troubleshooting/windows-issues`\n      : `Readiness check timed out after ${adjustedTimeout}ms`;\n\n    return { success: false, error: timeoutMsg };\n  }\n\n  private static async waitForExit(pid: number, timeout: number): Promise<void> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      if (!this.isProcessAlive(pid)) {\n        return;\n      }\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    throw new Error('Process did not exit within timeout');\n  }\n\n  private static getLogFilePath(): string {\n    const date = new Date().toISOString().slice(0, 10);\n    return join(LOG_DIR, `worker-${date}.log`);\n  }\n\n  private static formatUptime(startedAt: string): string {\n    const startTime = new Date(startedAt).getTime();\n    const now = Date.now();\n    const diffMs = now - startTime;\n\n    const seconds = Math.floor(diffMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${days}d ${hours % 24}h`;\n    if (hours > 0) return `${hours}h ${minutes % 60}m`;\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n    return `${seconds}s`;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_start_22": {
      "name": "start",
      "type": "method",
      "start_line": 22,
      "end_line": 53,
      "content_hash": "f7cc831d32ac655b25af1b7115cbf7200e2f61e9",
      "content": "  static async start(port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    // Validate port range\n    if (isNaN(port) || port < 1024 || port > 65535) {\n      return {\n        success: false,\n        error: `Invalid port ${port}. Must be between 1024 and 65535`\n      };\n    }\n\n    // Check if already running\n    if (await this.isRunning()) {\n      const info = this.getPidInfo();\n      return { success: true, pid: info?.pid };\n    }\n\n    // Ensure log directory exists\n    mkdirSync(LOG_DIR, { recursive: true });\n\n    // On Windows, use the wrapper script to solve zombie port problem\n    // On Unix, use the worker directly\n    const scriptName = process.platform === 'win32' ? 'worker-wrapper.cjs' : 'worker-service.cjs';\n    const workerScript = join(MARKETPLACE_ROOT, 'plugin', 'scripts', scriptName);\n\n    if (!existsSync(workerScript)) {\n      return { success: false, error: `Worker script not found at ${workerScript}` };\n    }\n\n    const logFile = this.getLogFilePath();\n\n    // Use Bun on all platforms with PowerShell workaround for Windows console popups\n    return this.startWithBun(workerScript, logFile, port);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isBunAvailable_55": {
      "name": "isBunAvailable",
      "type": "method",
      "start_line": 55,
      "end_line": 57,
      "content_hash": "b317ecee3ee143e4f05bbf9bc8c815552c9bb0dd",
      "content": "  private static isBunAvailable(): boolean {\n    return isBunAvailable();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_escapePowerShellString_64": {
      "name": "escapePowerShellString",
      "type": "method",
      "start_line": 64,
      "end_line": 66,
      "content_hash": "fc2d6a2e726b2d1ba36ad0e574254c44ce2dd094",
      "content": "  private static escapePowerShellString(str: string): string {\n    return str.replace(/'/g, \"''\");\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startWithBun_68": {
      "name": "startWithBun",
      "type": "method",
      "start_line": 68,
      "end_line": 165,
      "content_hash": "51061aa470130cda214c44ab1e1c151436da9439",
      "content": "  private static async startWithBun(script: string, logFile: string, port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    const bunPath = getBunPath();\n    if (!bunPath) {\n      return {\n        success: false,\n        error: 'Bun is required but not found in PATH or common installation paths. Install from https://bun.sh'\n      };\n    }\n    try {\n      const isWindows = process.platform === 'win32';\n\n      if (isWindows) {\n        // Windows: Use PowerShell Start-Process with -WindowStyle Hidden\n        // This properly hides the console window (affects both Bun and Node.js)\n        // Note: windowsHide: true doesn't work with detached: true (Bun inherits Node.js process spawning semantics)\n        // See: https://github.com/nodejs/node/issues/21825 and PR #315 for detailed testing\n        //\n        // On Windows, we start worker-wrapper.cjs which manages the actual worker-service.cjs.\n        // This solves the zombie port problem: the wrapper has no sockets, so when it kills\n        // and respawns the inner worker, the socket is properly released.\n        //\n        // Security: All paths (bunPath, script, MARKETPLACE_ROOT) are application-controlled system paths,\n        // not user input. If an attacker could modify these paths, they would already have full filesystem\n        // access including direct access to ~/.claude-mem/claude-mem.db. Nevertheless, we properly escape\n        // all values for PowerShell to follow security best practices.\n        const escapedBunPath = this.escapePowerShellString(bunPath);\n        const escapedScript = this.escapePowerShellString(script);\n        const escapedWorkDir = this.escapePowerShellString(MARKETPLACE_ROOT);\n        const escapedLogFile = this.escapePowerShellString(logFile);\n        const envVars = `$env:CLAUDE_MEM_WORKER_PORT='${port}'`;\n        const psCommand = `${envVars}; Start-Process -FilePath '${escapedBunPath}' -ArgumentList '${escapedScript}' -WorkingDirectory '${escapedWorkDir}' -WindowStyle Hidden -RedirectStandardOutput '${escapedLogFile}' -RedirectStandardError '${escapedLogFile}.err' -PassThru | Select-Object -ExpandProperty Id`;\n\n        const result = spawnSync('powershell', ['-Command', psCommand], {\n          stdio: 'pipe',\n          timeout: 10000,\n          windowsHide: true\n        });\n\n        if (result.status !== 0) {\n          return {\n            success: false,\n            error: `PowerShell spawn failed: ${result.stderr?.toString() || 'unknown error'}`\n          };\n        }\n\n        const pid = parseInt(result.stdout.toString().trim(), 10);\n        if (isNaN(pid)) {\n          return { success: false, error: 'Failed to get PID from PowerShell' };\n        }\n\n        // Write PID file\n        this.writePidFile({\n          pid,\n          port,\n          startedAt: new Date().toISOString(),\n          version: process.env.npm_package_version || 'unknown'\n        });\n\n        // Wait for health\n        return this.waitForHealth(pid, port);\n      } else {\n        // Unix: Use standard spawn with detached\n        const child = spawn(bunPath, [script], {\n          detached: true,\n          stdio: ['ignore', 'pipe', 'pipe'],\n          env: { ...process.env, CLAUDE_MEM_WORKER_PORT: String(port) },\n          cwd: MARKETPLACE_ROOT\n        });\n\n        // Write logs\n        const logStream = createWriteStream(logFile, { flags: 'a' });\n        child.stdout?.pipe(logStream);\n        child.stderr?.pipe(logStream);\n\n        child.unref();\n\n        if (!child.pid) {\n          return { success: false, error: 'Failed to get PID from spawned process' };\n        }\n\n        // Write PID file\n        this.writePidFile({\n          pid: child.pid,\n          port,\n          startedAt: new Date().toISOString(),\n          version: process.env.npm_package_version || 'unknown'\n        });\n\n        // Wait for health\n        return this.waitForHealth(child.pid, port);\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stop_167": {
      "name": "stop",
      "type": "method",
      "start_line": 167,
      "end_line": 228,
      "content_hash": "311dc61a29a981bb699207de026671bf308b8268",
      "content": "  static async stop(timeout: number = 5000): Promise<boolean> {\n    const info = this.getPidInfo();\n\n    if (process.platform === 'win32') {\n      // Windows: Try graceful HTTP shutdown first - this works regardless of PID file state\n      // because the worker shuts itself down from the inside (via wrapper IPC)\n      const port = info?.port ?? this.getPortFromSettings();\n      const httpShutdownSucceeded = await this.tryHttpShutdown(port);\n\n      if (httpShutdownSucceeded) {\n        // HTTP shutdown succeeded - worker confirmed down, safe to remove PID file\n        this.removePidFile();\n        return true;\n      }\n\n      // HTTP shutdown failed (worker not responding), fall back to taskkill\n      if (!info) {\n        // No PID file and HTTP failed - nothing more we can do\n        return true;\n      }\n\n      const { execSync } = await import('child_process');\n      try {\n        // Use taskkill /T /F to kill entire process tree\n        // This ensures the wrapper AND all its children (inner worker, MCP, ChromaSync) are killed\n        // which is necessary to properly release the socket and avoid zombie ports\n        execSync(`taskkill /PID ${info.pid} /T /F`, { timeout: 10000, stdio: 'ignore' });\n      } catch {\n        // Process may already be dead\n      }\n\n      // Wait for process to actually exit before removing PID file\n      try {\n        await this.waitForExit(info.pid, timeout);\n      } catch {\n        // Timeout waiting - process may still be alive\n      }\n\n      // Only remove PID file if process is confirmed dead\n      if (!this.isProcessAlive(info.pid)) {\n        this.removePidFile();\n      }\n      return true;\n    } else {\n      // Unix: Use signals (unchanged behavior)\n      if (!info) return true;\n\n      try {\n        process.kill(info.pid, 'SIGTERM');\n        await this.waitForExit(info.pid, timeout);\n      } catch {\n        try {\n          process.kill(info.pid, 'SIGKILL');\n        } catch {\n          // Process already dead\n        }\n      }\n\n      this.removePidFile();\n      return true;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_restart_230": {
      "name": "restart",
      "type": "method",
      "start_line": 230,
      "end_line": 233,
      "content_hash": "33aea6fb4a1f3b5e5d501625cef4c56dcc447825",
      "content": "  static async restart(port: number): Promise<{ success: boolean; pid?: number; error?: string }> {\n    await this.stop();\n    return this.start(port);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_status_235": {
      "name": "status",
      "type": "method",
      "start_line": 235,
      "end_line": 246,
      "content_hash": "549b8afb4d50fc76f85340c367abde09eb2c91a9",
      "content": "  static async status(): Promise<{ running: boolean; pid?: number; port?: number; uptime?: string }> {\n    const info = this.getPidInfo();\n    if (!info) return { running: false };\n\n    const running = this.isProcessAlive(info.pid);\n    return {\n      running,\n      pid: running ? info.pid : undefined,\n      port: running ? info.port : undefined,\n      uptime: running ? this.formatUptime(info.startedAt) : undefined\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isRunning_248": {
      "name": "isRunning",
      "type": "method",
      "start_line": 248,
      "end_line": 256,
      "content_hash": "7870b9a0e8afc85771858072b7aa6e0b6ca761f6",
      "content": "  static async isRunning(): Promise<boolean> {\n    const info = this.getPidInfo();\n    if (!info) return false;\n    const alive = this.isProcessAlive(info.pid);\n    if (!alive) {\n      this.removePidFile(); // Clean up stale PID file\n    }\n    return alive;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPortFromSettings_261": {
      "name": "getPortFromSettings",
      "type": "method",
      "start_line": 261,
      "end_line": 269,
      "content_hash": "781114668b8a61277037fd13ed82c10d5a2fc511",
      "content": "  private static getPortFromSettings(): number {\n    try {\n      const settingsPath = join(DATA_DIR, 'settings.json');\n      const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n      return parseInt(settings.CLAUDE_MEM_WORKER_PORT, 10);\n    } catch {\n      return parseInt(SettingsDefaultsManager.get('CLAUDE_MEM_WORKER_PORT'), 10);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tryHttpShutdown_275": {
      "name": "tryHttpShutdown",
      "type": "method",
      "start_line": 275,
      "end_line": 293,
      "content_hash": "73dabd5bad9dfb1875b260b06bee6991c8da238d",
      "content": "  private static async tryHttpShutdown(port: number): Promise<boolean> {\n    try {\n      // Send shutdown request\n      const response = await fetch(`http://127.0.0.1:${port}/api/admin/shutdown`, {\n        method: 'POST',\n        signal: AbortSignal.timeout(2000)\n      });\n\n      if (!response.ok) {\n        return false;\n      }\n\n      // Wait for worker to actually stop responding\n      return await this.waitForWorkerDown(port, 5000);\n    } catch {\n      // Worker not responding to HTTP - it may be dead or hung\n      return false;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForWorkerDown_298": {
      "name": "waitForWorkerDown",
      "type": "method",
      "start_line": 298,
      "end_line": 316,
      "content_hash": "ee9ddf27d02e09e25ce9288a83144820d73c7a9a",
      "content": "  private static async waitForWorkerDown(port: number, timeout: number): Promise<boolean> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      try {\n        await fetch(`http://127.0.0.1:${port}/api/health`, {\n          signal: AbortSignal.timeout(500)\n        });\n        // Still responding, wait and retry\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } catch {\n        // Worker stopped responding - success\n        return true;\n      }\n    }\n\n    // Timeout - worker still responding\n    return false;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPidInfo_319": {
      "name": "getPidInfo",
      "type": "method",
      "start_line": 319,
      "end_line": 337,
      "content_hash": "791aacbac3ff5378f59ffc7d665d83cfa219d3f6",
      "content": "  private static getPidInfo(): PidInfo | null {\n    try {\n      if (!existsSync(PID_FILE)) return null;\n      const content = readFileSync(PID_FILE, 'utf-8');\n      const parsed = JSON.parse(content);\n      // Validate required fields have correct types\n      if (typeof parsed.pid !== 'number' || typeof parsed.port !== 'number') {\n        logger.warn('PROCESS', 'Malformed PID file: missing or invalid pid/port fields', {}, { parsed });\n        return null;\n      }\n      return parsed as PidInfo;\n    } catch (error) {\n      logger.warn('PROCESS', 'Failed to read PID file', {}, {\n        error: error instanceof Error ? error.message : String(error),\n        path: PID_FILE\n      });\n      return null;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writePidFile_339": {
      "name": "writePidFile",
      "type": "method",
      "start_line": 339,
      "end_line": 342,
      "content_hash": "3381501db995207404af2ad6f2974a879d55e11a",
      "content": "  private static writePidFile(info: PidInfo): void {\n    mkdirSync(DATA_DIR, { recursive: true });\n    writeFileSync(PID_FILE, JSON.stringify(info, null, 2));\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_removePidFile_344": {
      "name": "removePidFile",
      "type": "method",
      "start_line": 344,
      "end_line": 352,
      "content_hash": "bec76109ea5041f4c75907e52e4b9ced44e6094a",
      "content": "  private static removePidFile(): void {\n    try {\n      if (existsSync(PID_FILE)) {\n        unlinkSync(PID_FILE);\n      }\n    } catch {\n      // Ignore errors\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isProcessAlive_354": {
      "name": "isProcessAlive",
      "type": "method",
      "start_line": 354,
      "end_line": 361,
      "content_hash": "ad7c029b371bd0acc7ee3ecac6ae12fa686daea9",
      "content": "  private static isProcessAlive(pid: number): boolean {\n    try {\n      process.kill(pid, 0);\n      return true;\n    } catch {\n      return false;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForHealth_363": {
      "name": "waitForHealth",
      "type": "method",
      "start_line": 363,
      "end_line": 398,
      "content_hash": "146aa7455c5b1894974247d3d5f862f5324d6d9b",
      "content": "  private static async waitForHealth(pid: number, port: number, timeoutMs: number = 10000): Promise<{ success: boolean; pid?: number; error?: string }> {\n    const startTime = Date.now();\n    const isWindows = process.platform === 'win32';\n    // Increase timeout on Windows to account for slower process startup\n    const adjustedTimeout = isWindows ? timeoutMs * 2 : timeoutMs;\n\n    while (Date.now() - startTime < adjustedTimeout) {\n      // Check if process is still alive\n      if (!this.isProcessAlive(pid)) {\n        const errorMsg = isWindows\n          ? `Process died during startup\\n\\nTroubleshooting:\\n1. Check Task Manager for zombie 'bun.exe' or 'node.exe' processes\\n2. Verify port ${port} is not in use: netstat -ano | findstr ${port}\\n3. Check worker logs in ~/.claude-mem/logs/\\n4. See GitHub issues: #363, #367, #371, #373\\n5. Docs: https://docs.claude-mem.ai/troubleshooting/windows-issues`\n          : 'Process died during startup';\n        return { success: false, error: errorMsg };\n      }\n\n      // Try readiness check (changed from /health to /api/readiness)\n      try {\n        const response = await fetch(`http://127.0.0.1:${port}/api/readiness`, {\n          signal: AbortSignal.timeout(1000)\n        });\n        if (response.ok) {\n          return { success: true, pid };\n        }\n      } catch {\n        // Not ready yet, continue polling\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 200));\n    }\n\n    const timeoutMsg = isWindows\n      ? `Worker failed to start on Windows (readiness check timed out after ${adjustedTimeout}ms)\\n\\nTroubleshooting:\\n1. Check Task Manager for zombie 'bun.exe' or 'node.exe' processes\\n2. Verify port ${port} is not in use: netstat -ano | findstr ${port}\\n3. Check worker logs in ~/.claude-mem/logs/\\n4. See GitHub issues: #363, #367, #371, #373\\n5. Docs: https://docs.claude-mem.ai/troubleshooting/windows-issues`\n      : `Readiness check timed out after ${adjustedTimeout}ms`;\n\n    return { success: false, error: timeoutMsg };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForExit_400": {
      "name": "waitForExit",
      "type": "method",
      "start_line": 400,
      "end_line": 411,
      "content_hash": "72f51eb1f19924ddcb340ea5a074dfc4bb22657b",
      "content": "  private static async waitForExit(pid: number, timeout: number): Promise<void> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      if (!this.isProcessAlive(pid)) {\n        return;\n      }\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    throw new Error('Process did not exit within timeout');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getLogFilePath_413": {
      "name": "getLogFilePath",
      "type": "method",
      "start_line": 413,
      "end_line": 416,
      "content_hash": "66c00dedce4d393bd9c78c05190ee5589d97942f",
      "content": "  private static getLogFilePath(): string {\n    const date = new Date().toISOString().slice(0, 10);\n    return join(LOG_DIR, `worker-${date}.log`);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatUptime_418": {
      "name": "formatUptime",
      "type": "method",
      "start_line": 418,
      "end_line": 432,
      "content_hash": "4c1dcf0b9bfbc49e2ac20e66922d53967a687fc3",
      "content": "  private static formatUptime(startedAt: string): string {\n    const startTime = new Date(startedAt).getTime();\n    const now = Date.now();\n    const diffMs = now - startTime;\n\n    const seconds = Math.floor(diffMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${days}d ${hours % 24}h`;\n    if (hours > 0) return `${hours}h ${minutes % 60}m`;\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n    return `${seconds}s`;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}