{
  "file_path": "/work/external-deps/claude-mem/src/services/sqlite/PendingMessageStore.ts",
  "file_hash": "558d1a4b81a380c31fa341b3b91658f04b0a1a96",
  "updated_at": "2025-12-26T17:34:24.987014",
  "symbols": {
    "class_PendingMessageStore_42": {
      "name": "PendingMessageStore",
      "type": "class",
      "start_line": 42,
      "end_line": 377,
      "content_hash": "e00f06344f7108c06a642606de6f5a4e329af4c8",
      "content": "export class PendingMessageStore {\n  private db: Database;\n  private maxRetries: number;\n\n  constructor(db: Database, maxRetries: number = 3) {\n    this.db = db;\n    this.maxRetries = maxRetries;\n  }\n\n  /**\n   * Enqueue a new message (persist before processing)\n   * @returns The database ID of the persisted message\n   */\n  enqueue(sessionDbId: number, claudeSessionId: string, message: PendingMessage): number {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      INSERT INTO pending_messages (\n        session_db_id, claude_session_id, message_type,\n        tool_name, tool_input, tool_response, cwd,\n        last_user_message, last_assistant_message,\n        prompt_number, status, retry_count, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 0, ?)\n    `);\n\n    const result = stmt.run(\n      sessionDbId,\n      claudeSessionId,\n      message.type,\n      message.tool_name || null,\n      message.tool_input ? JSON.stringify(message.tool_input) : null,\n      message.tool_response ? JSON.stringify(message.tool_response) : null,\n      message.cwd || null,\n      message.last_user_message || null,\n      message.last_assistant_message || null,\n      message.prompt_number || null,\n      now\n    );\n\n    return result.lastInsertRowid as number;\n  }\n\n  /**\n   * Peek at oldest pending message for session (does NOT change status)\n   * @returns The oldest pending message or null if none\n   */\n  peekPending(sessionDbId: number): PersistentPendingMessage | null {\n    const stmt = this.db.prepare(`\n      SELECT * FROM pending_messages\n      WHERE session_db_id = ? AND status = 'pending'\n      ORDER BY id ASC\n      LIMIT 1\n    `);\n    return stmt.get(sessionDbId) as PersistentPendingMessage | null;\n  }\n\n  /**\n   * Get all pending messages for session (ordered by creation time)\n   */\n  getAllPending(sessionDbId: number): PersistentPendingMessage[] {\n    const stmt = this.db.prepare(`\n      SELECT * FROM pending_messages\n      WHERE session_db_id = ? AND status = 'pending'\n      ORDER BY id ASC\n    `);\n    return stmt.all(sessionDbId) as PersistentPendingMessage[];\n  }\n\n  /**\n   * Get all queue messages (for UI display)\n   * Returns pending, processing, and failed messages (not processed - they're deleted)\n   * Joins with sdk_sessions to get project name\n   */\n  getQueueMessages(): (PersistentPendingMessage & { project: string | null })[] {\n    const stmt = this.db.prepare(`\n      SELECT pm.*, ss.project\n      FROM pending_messages pm\n      LEFT JOIN sdk_sessions ss ON pm.claude_session_id = ss.claude_session_id\n      WHERE pm.status IN ('pending', 'processing', 'failed')\n      ORDER BY\n        CASE pm.status\n          WHEN 'failed' THEN 0\n          WHEN 'processing' THEN 1\n          WHEN 'pending' THEN 2\n        END,\n        pm.created_at_epoch ASC\n    `);\n    return stmt.all() as (PersistentPendingMessage & { project: string | null })[];\n  }\n\n  /**\n   * Get count of stuck messages (processing longer than threshold)\n   */\n  getStuckCount(thresholdMs: number): number {\n    const cutoff = Date.now() - thresholdMs;\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n    const result = stmt.get(cutoff) as { count: number };\n    return result.count;\n  }\n\n  /**\n   * Retry a specific message (reset to pending)\n   * Works for pending (re-queue), processing (reset stuck), and failed messages\n   */\n  retryMessage(messageId: number): boolean {\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE id = ? AND status IN ('pending', 'processing', 'failed')\n    `);\n    const result = stmt.run(messageId);\n    return result.changes > 0;\n  }\n\n  /**\n   * Reset all processing messages for a session to pending\n   * Used when force-restarting a stuck session\n   */\n  resetProcessingToPending(sessionDbId: number): number {\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE session_db_id = ? AND status = 'processing'\n    `);\n    const result = stmt.run(sessionDbId);\n    return result.changes;\n  }\n\n  /**\n   * Abort a specific message (delete from queue)\n   */\n  abortMessage(messageId: number): boolean {\n    const stmt = this.db.prepare('DELETE FROM pending_messages WHERE id = ?');\n    const result = stmt.run(messageId);\n    return result.changes > 0;\n  }\n\n  /**\n   * Retry all stuck messages at once\n   */\n  retryAllStuck(thresholdMs: number): number {\n    const cutoff = Date.now() - thresholdMs;\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n    const result = stmt.run(cutoff);\n    return result.changes;\n  }\n\n  /**\n   * Get recently processed messages (for UI feedback)\n   * Shows messages completed in the last N minutes so users can see their stuck items were processed\n   */\n  getRecentlyProcessed(limit: number = 10, withinMinutes: number = 30): (PersistentPendingMessage & { project: string | null })[] {\n    const cutoff = Date.now() - (withinMinutes * 60 * 1000);\n    const stmt = this.db.prepare(`\n      SELECT pm.*, ss.project\n      FROM pending_messages pm\n      LEFT JOIN sdk_sessions ss ON pm.claude_session_id = ss.claude_session_id\n      WHERE pm.status = 'processed' AND pm.completed_at_epoch > ?\n      ORDER BY pm.completed_at_epoch DESC\n      LIMIT ?\n    `);\n    return stmt.all(cutoff, limit) as (PersistentPendingMessage & { project: string | null })[];\n  }\n\n  /**\n   * Mark message as being processed (status: pending -> processing)\n   */\n  markProcessing(messageId: number): void {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'processing', started_processing_at_epoch = ?\n      WHERE id = ? AND status = 'pending'\n    `);\n    stmt.run(now, messageId);\n  }\n\n  /**\n   * Mark message as successfully processed (status: processing -> processed)\n   * Clears tool_input and tool_response to save space (observations are already saved)\n   */\n  markProcessed(messageId: number): void {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET\n        status = 'processed',\n        completed_at_epoch = ?,\n        tool_input = NULL,\n        tool_response = NULL\n      WHERE id = ? AND status = 'processing'\n    `);\n    stmt.run(now, messageId);\n  }\n\n  /**\n   * Mark message as failed (status: processing -> failed or back to pending for retry)\n   * If retry_count < maxRetries, moves back to 'pending' for retry\n   * Otherwise marks as 'failed' permanently\n   */\n  markFailed(messageId: number): void {\n    const now = Date.now();\n\n    // Get current retry count\n    const msg = this.db.prepare('SELECT retry_count FROM pending_messages WHERE id = ?').get(messageId) as { retry_count: number } | undefined;\n\n    if (!msg) return;\n\n    if (msg.retry_count < this.maxRetries) {\n      // Move back to pending for retry\n      const stmt = this.db.prepare(`\n        UPDATE pending_messages\n        SET status = 'pending', retry_count = retry_count + 1, started_processing_at_epoch = NULL\n        WHERE id = ?\n      `);\n      stmt.run(messageId);\n    } else {\n      // Max retries exceeded, mark as permanently failed\n      const stmt = this.db.prepare(`\n        UPDATE pending_messages\n        SET status = 'failed', completed_at_epoch = ?\n        WHERE id = ?\n      `);\n      stmt.run(now, messageId);\n    }\n  }\n\n  /**\n   * Reset stuck messages (processing -> pending if stuck longer than threshold)\n   * @param thresholdMs Messages processing longer than this are considered stuck (0 = reset all)\n   * @returns Number of messages reset\n   */\n  resetStuckMessages(thresholdMs: number): number {\n    const cutoff = thresholdMs === 0 ? Date.now() : Date.now() - thresholdMs;\n\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n\n    const result = stmt.run(cutoff);\n    return result.changes;\n  }\n\n  /**\n   * Get count of pending messages for a session\n   */\n  getPendingCount(sessionDbId: number): number {\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE session_db_id = ? AND status IN ('pending', 'processing')\n    `);\n    const result = stmt.get(sessionDbId) as { count: number };\n    return result.count;\n  }\n\n  /**\n   * Check if any session has pending work\n   */\n  hasAnyPendingWork(): boolean {\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE status IN ('pending', 'processing')\n    `);\n    const result = stmt.get() as { count: number };\n    return result.count > 0;\n  }\n\n  /**\n   * Get all session IDs that have pending messages (for recovery on startup)\n   */\n  getSessionsWithPendingMessages(): number[] {\n    const stmt = this.db.prepare(`\n      SELECT DISTINCT session_db_id FROM pending_messages\n      WHERE status IN ('pending', 'processing')\n    `);\n    const results = stmt.all() as { session_db_id: number }[];\n    return results.map(r => r.session_db_id);\n  }\n\n  /**\n   * Get session info for a pending message (for recovery)\n   */\n  getSessionInfoForMessage(messageId: number): { sessionDbId: number; claudeSessionId: string } | null {\n    const stmt = this.db.prepare(`\n      SELECT session_db_id, claude_session_id FROM pending_messages WHERE id = ?\n    `);\n    const result = stmt.get(messageId) as { session_db_id: number; claude_session_id: string } | undefined;\n    return result ? { sessionDbId: result.session_db_id, claudeSessionId: result.claude_session_id } : null;\n  }\n\n  /**\n   * Cleanup old processed messages (retention policy)\n   * Keeps the most recent N processed messages, deletes the rest\n   * @param retentionCount Number of processed messages to keep (default: 100)\n   * @returns Number of messages deleted\n   */\n  cleanupProcessed(retentionCount: number = 100): number {\n    const stmt = this.db.prepare(`\n      DELETE FROM pending_messages\n      WHERE status = 'processed'\n      AND id NOT IN (\n        SELECT id FROM pending_messages\n        WHERE status = 'processed'\n        ORDER BY completed_at_epoch DESC\n        LIMIT ?\n      )\n    `);\n\n    const result = stmt.run(retentionCount);\n    return result.changes;\n  }\n\n  /**\n   * Convert a PersistentPendingMessage back to PendingMessage format\n   */\n  toPendingMessage(persistent: PersistentPendingMessage): PendingMessage {\n    return {\n      type: persistent.message_type,\n      tool_name: persistent.tool_name || undefined,\n      tool_input: persistent.tool_input ? JSON.parse(persistent.tool_input) : undefined,\n      tool_response: persistent.tool_response ? JSON.parse(persistent.tool_response) : undefined,\n      prompt_number: persistent.prompt_number || undefined,\n      cwd: persistent.cwd || undefined,\n      last_user_message: persistent.last_user_message || undefined,\n      last_assistant_message: persistent.last_assistant_message || undefined\n    };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_46": {
      "name": "constructor",
      "type": "method",
      "start_line": 46,
      "end_line": 49,
      "content_hash": "72e916db61fb33ba322903691485dea218322e3b",
      "content": "  constructor(db: Database, maxRetries: number = 3) {\n    this.db = db;\n    this.maxRetries = maxRetries;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_enqueue_55": {
      "name": "enqueue",
      "type": "method",
      "start_line": 55,
      "end_line": 81,
      "content_hash": "9af4332814ffb9fefac8542efd10804287efbd77",
      "content": "  enqueue(sessionDbId: number, claudeSessionId: string, message: PendingMessage): number {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      INSERT INTO pending_messages (\n        session_db_id, claude_session_id, message_type,\n        tool_name, tool_input, tool_response, cwd,\n        last_user_message, last_assistant_message,\n        prompt_number, status, retry_count, created_at_epoch\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 0, ?)\n    `);\n\n    const result = stmt.run(\n      sessionDbId,\n      claudeSessionId,\n      message.type,\n      message.tool_name || null,\n      message.tool_input ? JSON.stringify(message.tool_input) : null,\n      message.tool_response ? JSON.stringify(message.tool_response) : null,\n      message.cwd || null,\n      message.last_user_message || null,\n      message.last_assistant_message || null,\n      message.prompt_number || null,\n      now\n    );\n\n    return result.lastInsertRowid as number;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_peekPending_87": {
      "name": "peekPending",
      "type": "method",
      "start_line": 87,
      "end_line": 95,
      "content_hash": "c9defe976a76b15df1fc24b6734d794d54425d90",
      "content": "  peekPending(sessionDbId: number): PersistentPendingMessage | null {\n    const stmt = this.db.prepare(`\n      SELECT * FROM pending_messages\n      WHERE session_db_id = ? AND status = 'pending'\n      ORDER BY id ASC\n      LIMIT 1\n    `);\n    return stmt.get(sessionDbId) as PersistentPendingMessage | null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllPending_100": {
      "name": "getAllPending",
      "type": "method",
      "start_line": 100,
      "end_line": 107,
      "content_hash": "27d204b5ae55c6e9c2dccc93d0d5ff271d5ac77e",
      "content": "  getAllPending(sessionDbId: number): PersistentPendingMessage[] {\n    const stmt = this.db.prepare(`\n      SELECT * FROM pending_messages\n      WHERE session_db_id = ? AND status = 'pending'\n      ORDER BY id ASC\n    `);\n    return stmt.all(sessionDbId) as PersistentPendingMessage[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getQueueMessages_114": {
      "name": "getQueueMessages",
      "type": "method",
      "start_line": 114,
      "end_line": 129,
      "content_hash": "9ba1d14d8d8054315c7a396bca4f3be2d00cdc75",
      "content": "  getQueueMessages(): (PersistentPendingMessage & { project: string | null })[] {\n    const stmt = this.db.prepare(`\n      SELECT pm.*, ss.project\n      FROM pending_messages pm\n      LEFT JOIN sdk_sessions ss ON pm.claude_session_id = ss.claude_session_id\n      WHERE pm.status IN ('pending', 'processing', 'failed')\n      ORDER BY\n        CASE pm.status\n          WHEN 'failed' THEN 0\n          WHEN 'processing' THEN 1\n          WHEN 'pending' THEN 2\n        END,\n        pm.created_at_epoch ASC\n    `);\n    return stmt.all() as (PersistentPendingMessage & { project: string | null })[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getStuckCount_134": {
      "name": "getStuckCount",
      "type": "method",
      "start_line": 134,
      "end_line": 142,
      "content_hash": "f5b849a51978721f536b458f06c71a552ae90ad6",
      "content": "  getStuckCount(thresholdMs: number): number {\n    const cutoff = Date.now() - thresholdMs;\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n    const result = stmt.get(cutoff) as { count: number };\n    return result.count;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_retryMessage_148": {
      "name": "retryMessage",
      "type": "method",
      "start_line": 148,
      "end_line": 156,
      "content_hash": "df57e130e2e964016303263be1b12ec08c798785",
      "content": "  retryMessage(messageId: number): boolean {\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE id = ? AND status IN ('pending', 'processing', 'failed')\n    `);\n    const result = stmt.run(messageId);\n    return result.changes > 0;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_resetProcessingToPending_162": {
      "name": "resetProcessingToPending",
      "type": "method",
      "start_line": 162,
      "end_line": 170,
      "content_hash": "44980b5a09b402b8c38dfb11f6e430968cca49a4",
      "content": "  resetProcessingToPending(sessionDbId: number): number {\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE session_db_id = ? AND status = 'processing'\n    `);\n    const result = stmt.run(sessionDbId);\n    return result.changes;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_abortMessage_175": {
      "name": "abortMessage",
      "type": "method",
      "start_line": 175,
      "end_line": 179,
      "content_hash": "6477e2f37e3a7fa25b2800cb67b0fd8cf47d4b55",
      "content": "  abortMessage(messageId: number): boolean {\n    const stmt = this.db.prepare('DELETE FROM pending_messages WHERE id = ?');\n    const result = stmt.run(messageId);\n    return result.changes > 0;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_retryAllStuck_184": {
      "name": "retryAllStuck",
      "type": "method",
      "start_line": 184,
      "end_line": 193,
      "content_hash": "5f5c2aa3791c2a3988c0a3e305c6ccf7499b24d0",
      "content": "  retryAllStuck(thresholdMs: number): number {\n    const cutoff = Date.now() - thresholdMs;\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n    const result = stmt.run(cutoff);\n    return result.changes;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentlyProcessed_199": {
      "name": "getRecentlyProcessed",
      "type": "method",
      "start_line": 199,
      "end_line": 210,
      "content_hash": "387a74492fc1bd21217d4869762ea34ef96ef5e7",
      "content": "  getRecentlyProcessed(limit: number = 10, withinMinutes: number = 30): (PersistentPendingMessage & { project: string | null })[] {\n    const cutoff = Date.now() - (withinMinutes * 60 * 1000);\n    const stmt = this.db.prepare(`\n      SELECT pm.*, ss.project\n      FROM pending_messages pm\n      LEFT JOIN sdk_sessions ss ON pm.claude_session_id = ss.claude_session_id\n      WHERE pm.status = 'processed' AND pm.completed_at_epoch > ?\n      ORDER BY pm.completed_at_epoch DESC\n      LIMIT ?\n    `);\n    return stmt.all(cutoff, limit) as (PersistentPendingMessage & { project: string | null })[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markProcessing_215": {
      "name": "markProcessing",
      "type": "method",
      "start_line": 215,
      "end_line": 223,
      "content_hash": "a49386e93ff533cdd14a19ca5ff0e7aea35f30a9",
      "content": "  markProcessing(messageId: number): void {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'processing', started_processing_at_epoch = ?\n      WHERE id = ? AND status = 'pending'\n    `);\n    stmt.run(now, messageId);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markProcessed_229": {
      "name": "markProcessed",
      "type": "method",
      "start_line": 229,
      "end_line": 241,
      "content_hash": "bad00118580d457f24752afa9c84662fcb22b95c",
      "content": "  markProcessed(messageId: number): void {\n    const now = Date.now();\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET\n        status = 'processed',\n        completed_at_epoch = ?,\n        tool_input = NULL,\n        tool_response = NULL\n      WHERE id = ? AND status = 'processing'\n    `);\n    stmt.run(now, messageId);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markFailed_248": {
      "name": "markFailed",
      "type": "method",
      "start_line": 248,
      "end_line": 273,
      "content_hash": "6fbad2d8409d555fab7347cc6b1fca73b2f955fb",
      "content": "  markFailed(messageId: number): void {\n    const now = Date.now();\n\n    // Get current retry count\n    const msg = this.db.prepare('SELECT retry_count FROM pending_messages WHERE id = ?').get(messageId) as { retry_count: number } | undefined;\n\n    if (!msg) return;\n\n    if (msg.retry_count < this.maxRetries) {\n      // Move back to pending for retry\n      const stmt = this.db.prepare(`\n        UPDATE pending_messages\n        SET status = 'pending', retry_count = retry_count + 1, started_processing_at_epoch = NULL\n        WHERE id = ?\n      `);\n      stmt.run(messageId);\n    } else {\n      // Max retries exceeded, mark as permanently failed\n      const stmt = this.db.prepare(`\n        UPDATE pending_messages\n        SET status = 'failed', completed_at_epoch = ?\n        WHERE id = ?\n      `);\n      stmt.run(now, messageId);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_resetStuckMessages_280": {
      "name": "resetStuckMessages",
      "type": "method",
      "start_line": 280,
      "end_line": 291,
      "content_hash": "af54767ebebf8a7e036048906cd2f2fd1dbcf976",
      "content": "  resetStuckMessages(thresholdMs: number): number {\n    const cutoff = thresholdMs === 0 ? Date.now() : Date.now() - thresholdMs;\n\n    const stmt = this.db.prepare(`\n      UPDATE pending_messages\n      SET status = 'pending', started_processing_at_epoch = NULL\n      WHERE status = 'processing' AND started_processing_at_epoch < ?\n    `);\n\n    const result = stmt.run(cutoff);\n    return result.changes;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getPendingCount_296": {
      "name": "getPendingCount",
      "type": "method",
      "start_line": 296,
      "end_line": 303,
      "content_hash": "1c4a994f627aa8043d76afef578f8c4034b65519",
      "content": "  getPendingCount(sessionDbId: number): number {\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE session_db_id = ? AND status IN ('pending', 'processing')\n    `);\n    const result = stmt.get(sessionDbId) as { count: number };\n    return result.count;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_hasAnyPendingWork_308": {
      "name": "hasAnyPendingWork",
      "type": "method",
      "start_line": 308,
      "end_line": 315,
      "content_hash": "84460f96e63b9a3e9b032ffd19ade59fafdfb7a9",
      "content": "  hasAnyPendingWork(): boolean {\n    const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM pending_messages\n      WHERE status IN ('pending', 'processing')\n    `);\n    const result = stmt.get() as { count: number };\n    return result.count > 0;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionsWithPendingMessages_320": {
      "name": "getSessionsWithPendingMessages",
      "type": "method",
      "start_line": 320,
      "end_line": 327,
      "content_hash": "3ed0c71abb521ecd8a6fecd4d19a841535c82998",
      "content": "  getSessionsWithPendingMessages(): number[] {\n    const stmt = this.db.prepare(`\n      SELECT DISTINCT session_db_id FROM pending_messages\n      WHERE status IN ('pending', 'processing')\n    `);\n    const results = stmt.all() as { session_db_id: number }[];\n    return results.map(r => r.session_db_id);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionInfoForMessage_332": {
      "name": "getSessionInfoForMessage",
      "type": "method",
      "start_line": 332,
      "end_line": 338,
      "content_hash": "1db89848a096d2305c36b4c8fe8e106ec0d9bb6c",
      "content": "  getSessionInfoForMessage(messageId: number): { sessionDbId: number; claudeSessionId: string } | null {\n    const stmt = this.db.prepare(`\n      SELECT session_db_id, claude_session_id FROM pending_messages WHERE id = ?\n    `);\n    const result = stmt.get(messageId) as { session_db_id: number; claude_session_id: string } | undefined;\n    return result ? { sessionDbId: result.session_db_id, claudeSessionId: result.claude_session_id } : null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cleanupProcessed_346": {
      "name": "cleanupProcessed",
      "type": "method",
      "start_line": 346,
      "end_line": 360,
      "content_hash": "421c71ea0d5bd24f34138f59797dc67a1e7db495",
      "content": "  cleanupProcessed(retentionCount: number = 100): number {\n    const stmt = this.db.prepare(`\n      DELETE FROM pending_messages\n      WHERE status = 'processed'\n      AND id NOT IN (\n        SELECT id FROM pending_messages\n        WHERE status = 'processed'\n        ORDER BY completed_at_epoch DESC\n        LIMIT ?\n      )\n    `);\n\n    const result = stmt.run(retentionCount);\n    return result.changes;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_toPendingMessage_365": {
      "name": "toPendingMessage",
      "type": "method",
      "start_line": 365,
      "end_line": 376,
      "content_hash": "1ecf68c15613925c6740be0498dfc9774a691ec4",
      "content": "  toPendingMessage(persistent: PersistentPendingMessage): PendingMessage {\n    return {\n      type: persistent.message_type,\n      tool_name: persistent.tool_name || undefined,\n      tool_input: persistent.tool_input ? JSON.parse(persistent.tool_input) : undefined,\n      tool_response: persistent.tool_response ? JSON.parse(persistent.tool_response) : undefined,\n      prompt_number: persistent.prompt_number || undefined,\n      cwd: persistent.cwd || undefined,\n      last_user_message: persistent.last_user_message || undefined,\n      last_assistant_message: persistent.last_assistant_message || undefined\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}