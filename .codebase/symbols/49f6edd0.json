{
  "file_path": "/work/external-deps/claude-mem/src/services/worker-service.ts",
  "file_hash": "c25c29c5ccdb724897f737d0ddfd7ef28adef86a",
  "updated_at": "2025-12-26T17:34:23.721478",
  "symbols": {
    "class_WorkerService_42": {
      "name": "WorkerService",
      "type": "class",
      "start_line": 42,
      "end_line": 649,
      "content_hash": "4a7301af77405c4f51d1b4901e22ac1e388956ad",
      "content": "export class WorkerService {\n  private app: express.Application;\n  private server: http.Server | null = null;\n  private startTime: number = Date.now();\n  private mcpClient: Client;\n\n  // Initialization flags for MCP/SDK readiness tracking\n  private mcpReady: boolean = false;\n  private initializationCompleteFlag: boolean = false;\n\n  // Service layer\n  private dbManager: DatabaseManager;\n  private sessionManager: SessionManager;\n  private sseBroadcaster: SSEBroadcaster;\n  private sdkAgent: SDKAgent;\n  private paginationHelper: PaginationHelper;\n  private settingsManager: SettingsManager;\n  private sessionEventBroadcaster: SessionEventBroadcaster;\n\n  // Route handlers\n  private viewerRoutes: ViewerRoutes;\n  private sessionRoutes: SessionRoutes;\n  private dataRoutes: DataRoutes;\n  private searchRoutes: SearchRoutes | null;\n  private settingsRoutes: SettingsRoutes;\n\n  // Initialization tracking\n  private initializationComplete: Promise<void>;\n  private resolveInitialization!: () => void;\n\n  constructor() {\n    this.app = express();\n\n    // Initialize the promise that will resolve when background initialization completes\n    this.initializationComplete = new Promise((resolve) => {\n      this.resolveInitialization = resolve;\n    });\n\n    // Initialize service layer\n    this.dbManager = new DatabaseManager();\n    this.sessionManager = new SessionManager(this.dbManager);\n    this.sseBroadcaster = new SSEBroadcaster();\n    this.sdkAgent = new SDKAgent(this.dbManager, this.sessionManager);\n    this.paginationHelper = new PaginationHelper(this.dbManager);\n    this.settingsManager = new SettingsManager(this.dbManager);\n    this.sessionEventBroadcaster = new SessionEventBroadcaster(this.sseBroadcaster, this);\n\n    // Set callback for when sessions are deleted (to update activity indicator)\n    this.sessionManager.setOnSessionDeleted(() => {\n      this.broadcastProcessingStatus();\n    });\n\n    // Initialize MCP client\n    this.mcpClient = new Client({\n      name: 'worker-search-proxy',\n      version: '1.0.0'\n    }, { capabilities: {} });\n\n    // Initialize route handlers (SearchRoutes will use MCP client initially, then switch to SearchManager after DB init)\n    this.viewerRoutes = new ViewerRoutes(this.sseBroadcaster, this.dbManager, this.sessionManager);\n    this.sessionRoutes = new SessionRoutes(this.sessionManager, this.dbManager, this.sdkAgent, this.sessionEventBroadcaster, this);\n    this.dataRoutes = new DataRoutes(this.paginationHelper, this.dbManager, this.sessionManager, this.sseBroadcaster, this, this.startTime);\n    // SearchRoutes needs SearchManager which requires initialized DB - will be created in initializeBackground()\n    this.searchRoutes = null;\n    this.settingsRoutes = new SettingsRoutes(this.settingsManager);\n\n    this.setupMiddleware();\n    this.setupRoutes();\n  }\n\n  /**\n   * Setup Express middleware\n   */\n  private setupMiddleware(): void {\n    const middlewares = createMiddleware(this.summarizeRequestBody.bind(this));\n    middlewares.forEach(mw => this.app.use(mw));\n  }\n\n  /**\n   * Setup HTTP routes (delegate to route classes)\n   */\n  private setupRoutes(): void {\n    // Health check endpoint\n    // TEST_BUILD_ID helps verify which build is running during debugging\n    const TEST_BUILD_ID = 'TEST-008-wrapper-ipc';\n    this.app.get('/api/health', (_req, res) => {\n      res.status(200).json({\n        status: 'ok',\n        build: TEST_BUILD_ID,\n        managed: process.env.CLAUDE_MEM_MANAGED === 'true',\n        hasIpc: typeof process.send === 'function',\n        platform: process.platform,\n        pid: process.pid,\n        initialized: this.initializationCompleteFlag,\n        mcpReady: this.mcpReady,\n      });\n    });\n\n    // Readiness check endpoint - returns 503 until full initialization completes\n    // Used by ProcessManager and worker-utils to ensure worker is fully ready before routing requests\n    this.app.get('/api/readiness', (_req, res) => {\n      if (this.initializationCompleteFlag) {\n        res.status(200).json({\n          status: 'ready',\n          mcpReady: this.mcpReady,\n        });\n      } else {\n        res.status(503).json({\n          status: 'initializing',\n          message: 'Worker is still initializing, please retry',\n        });\n      }\n    });\n\n    // Version endpoint - returns the worker's current version\n    this.app.get('/api/version', (_req, res) => {\n      const { homedir } = require('os');\n      const { readFileSync } = require('fs');\n      const marketplaceRoot = path.join(homedir(), '.claude', 'plugins', 'marketplaces', 'thedotmack');\n      const packageJsonPath = path.join(marketplaceRoot, 'package.json');\n\n      // Read version from marketplace package.json\n      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));\n      res.status(200).json({ version: packageJson.version });\n    });\n\n    // Instructions endpoint - loads SKILL.md sections on-demand for progressive instruction loading\n    this.app.get('/api/instructions', async (req, res) => {\n      const topic = (req.query.topic as string) || 'all';\n      const operation = req.query.operation as string | undefined;\n\n      // Path resolution: __dirname is build output directory (plugin/scripts/)\n      // SKILL.md is at plugin/skills/mem-search/SKILL.md\n      // Operations are at plugin/skills/mem-search/operations/*.md\n\n      try {\n        let content: string;\n\n        if (operation) {\n          // Load specific operation file\n          const operationPath = path.join(__dirname, '../skills/mem-search/operations', `${operation}.md`);\n          content = await fs.promises.readFile(operationPath, 'utf-8');\n        } else {\n          // Load SKILL.md and extract section based on topic (backward compatibility)\n          const skillPath = path.join(__dirname, '../skills/mem-search/SKILL.md');\n          const fullContent = await fs.promises.readFile(skillPath, 'utf-8');\n          content = this.extractInstructionSection(fullContent, topic);\n        }\n\n        // Return in MCP format\n        res.json({\n          content: [{\n            type: 'text',\n            text: content\n          }]\n        });\n      } catch (error) {\n        logger.error('WORKER', 'Failed to load instructions', { topic, operation }, error as Error);\n        res.status(500).json({\n          content: [{\n            type: 'text',\n            text: `Error loading instructions: ${error instanceof Error ? error.message : 'Unknown error'}`\n          }],\n          isError: true\n        });\n      }\n    });\n\n    // Admin endpoints for process management (localhost-only)\n    this.app.post('/api/admin/restart', requireLocalhost, async (_req, res) => {\n      res.json({ status: 'restarting' });\n\n      // On Windows, if managed by wrapper, send message to parent to handle restart\n      // This solves the Windows zombie port problem where sockets aren't properly released\n      const isWindowsManaged = process.platform === 'win32' &&\n        process.env.CLAUDE_MEM_MANAGED === 'true' &&\n        process.send;\n\n      if (isWindowsManaged) {\n        logger.info('SYSTEM', 'Sending restart request to wrapper');\n        process.send!({ type: 'restart' });\n      } else {\n        // Unix or standalone Windows - handle restart ourselves\n        setTimeout(async () => {\n          await this.shutdown();\n          process.exit(0);\n        }, 100);\n      }\n    });\n\n    this.app.post('/api/admin/shutdown', requireLocalhost, async (_req, res) => {\n      res.json({ status: 'shutting_down' });\n\n      // On Windows, if managed by wrapper, send message to parent to handle shutdown\n      const isWindowsManaged = process.platform === 'win32' &&\n        process.env.CLAUDE_MEM_MANAGED === 'true' &&\n        process.send;\n\n      if (isWindowsManaged) {\n        logger.info('SYSTEM', 'Sending shutdown request to wrapper');\n        process.send!({ type: 'shutdown' });\n      } else {\n        // Unix or standalone Windows - handle shutdown ourselves\n        setTimeout(async () => {\n          await this.shutdown();\n          process.exit(0);\n        }, 100);\n      }\n    });\n\n    this.viewerRoutes.setupRoutes(this.app);\n    this.sessionRoutes.setupRoutes(this.app);\n    this.dataRoutes.setupRoutes(this.app);\n    // searchRoutes is set up after database initialization in initializeBackground()\n    this.settingsRoutes.setupRoutes(this.app);\n\n    // Register early handler for /api/context/inject to avoid 404 during startup\n    // This handler waits for initialization to complete before delegating to SearchRoutes\n    // NOTE: This duplicates logic from SearchRoutes.handleContextInject by design,\n    // as we need the route available immediately before SearchRoutes is initialized\n    this.app.get('/api/context/inject', async (req, res, next) => {\n      try {\n        // Wait for initialization to complete (with timeout)\n        const timeoutMs = 30000; // 30 second timeout\n        const timeoutPromise = new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Initialization timeout')), timeoutMs)\n        );\n        \n        await Promise.race([this.initializationComplete, timeoutPromise]);\n\n        // If searchRoutes is still null after initialization, something went wrong\n        if (!this.searchRoutes) {\n          res.status(503).json({ error: 'Search routes not initialized' });\n          return;\n        }\n\n        // Delegate to the proper handler by re-processing the request\n        // Since we're already in the middleware chain, we need to call the handler directly\n        const projectName = req.query.project as string;\n        const useColors = req.query.colors === 'true';\n\n        if (!projectName) {\n          res.status(400).json({ error: 'Project parameter is required' });\n          return;\n        }\n\n        // Import context generator (runs in worker, has access to database)\n        const { generateContext } = await import('./context-generator.js');\n\n        // Use project name as CWD (generateContext uses path.basename to get project)\n        const cwd = `/context/${projectName}`;\n\n        // Generate context\n        const contextText = await generateContext(\n          {\n            session_id: 'context-inject-' + Date.now(),\n            cwd: cwd\n          },\n          useColors\n        );\n\n        // Return as plain text\n        res.setHeader('Content-Type', 'text/plain; charset=utf-8');\n        res.send(contextText);\n      } catch (error) {\n        logger.error('WORKER', 'Context inject handler failed', {}, error as Error);\n        res.status(500).json({ error: error instanceof Error ? error.message : 'Internal server error' });\n      }\n    });\n  }\n\n\n  /**\n   * Clean up orphaned chroma-mcp processes from previous worker sessions\n   * Prevents process accumulation and memory leaks\n   */\n  private async cleanupOrphanedProcesses(): Promise<void> {\n    const isWindows = process.platform === 'win32';\n    const pids: number[] = [];\n\n    if (isWindows) {\n      // Windows: Use PowerShell Get-CimInstance to find chroma-mcp processes\n      const cmd = `powershell -Command \"Get-CimInstance Win32_Process | Where-Object { $_.Name -like '*python*' -and $_.CommandLine -like '*chroma-mcp*' } | Select-Object -ExpandProperty ProcessId\"`;\n      const { stdout } = await execAsync(cmd, { timeout: 5000 });\n\n      if (!stdout.trim()) {\n        logger.debug('SYSTEM', 'No orphaned chroma-mcp processes found (Windows)');\n        return;\n      }\n\n      const pidStrings = stdout.trim().split('\\n');\n      for (const pidStr of pidStrings) {\n        const pid = parseInt(pidStr.trim(), 10);\n        // SECURITY: Validate PID is positive integer before adding to list\n        if (!isNaN(pid) && Number.isInteger(pid) && pid > 0) {\n          pids.push(pid);\n        }\n      }\n    } else {\n      // Unix: Use ps aux | grep\n      const { stdout } = await execAsync('ps aux | grep \"chroma-mcp\" | grep -v grep || true');\n\n      if (!stdout.trim()) {\n        logger.debug('SYSTEM', 'No orphaned chroma-mcp processes found (Unix)');\n        return;\n      }\n\n      const lines = stdout.trim().split('\\n');\n      for (const line of lines) {\n        const parts = line.trim().split(/\\s+/);\n        if (parts.length > 1) {\n          const pid = parseInt(parts[1], 10);\n          // SECURITY: Validate PID is positive integer before adding to list\n          if (!isNaN(pid) && Number.isInteger(pid) && pid > 0) {\n            pids.push(pid);\n          }\n        }\n      }\n    }\n\n    if (pids.length === 0) {\n      return;\n    }\n\n    logger.info('SYSTEM', 'Cleaning up orphaned chroma-mcp processes', {\n      platform: isWindows ? 'Windows' : 'Unix',\n      count: pids.length,\n      pids\n    });\n\n    // Kill all found processes\n    if (isWindows) {\n      for (const pid of pids) {\n        // SECURITY: Double-check PID validation before using in taskkill command\n        if (!Number.isInteger(pid) || pid <= 0) {\n          logger.warn('SYSTEM', 'Skipping invalid PID', { pid });\n          continue;\n        }\n        execSync(`taskkill /PID ${pid} /T /F`, { timeout: 5000, stdio: 'ignore' });\n      }\n    } else {\n      await execAsync(`kill ${pids.join(' ')}`);\n    }\n\n    logger.info('SYSTEM', 'Orphaned processes cleaned up', { count: pids.length });\n  }\n\n  /**\n   * Start the worker service\n   */\n  async start(): Promise<void> {\n    // Start HTTP server FIRST - make port available immediately\n    const port = getWorkerPort();\n    const host = getWorkerHost();\n    this.server = await new Promise<http.Server>((resolve, reject) => {\n      const srv = this.app.listen(port, host, () => resolve(srv));\n      srv.on('error', reject);\n    });\n\n    logger.info('SYSTEM', 'Worker started', { host, port, pid: process.pid });\n\n    // Do slow initialization in background (non-blocking)\n    this.initializeBackground().catch((error) => {\n      logger.error('SYSTEM', 'Background initialization failed', {}, error as Error);\n    });\n  }\n\n  /**\n   * Background initialization - runs after HTTP server is listening\n   */\n  private async initializeBackground(): Promise<void> {\n    try {\n      // Clean up any orphaned chroma-mcp processes BEFORE starting our own\n      await this.cleanupOrphanedProcesses();\n\n      // Load mode configuration (must happen before database to set observation types)\n      const { ModeManager } = await import('./domain/ModeManager.js');\n      const { SettingsDefaultsManager } = await import('../shared/SettingsDefaultsManager.js');\n      const { USER_SETTINGS_PATH } = await import('../shared/paths.js');\n\n      const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n      const modeId = settings.CLAUDE_MEM_MODE;\n      ModeManager.getInstance().loadMode(modeId);\n      logger.info('SYSTEM', `Mode loaded: ${modeId}`);\n\n      // Initialize database (once, stays open)\n      await this.dbManager.initialize();\n\n      // Initialize search services (requires initialized database)\n      const formattingService = new FormattingService();\n      const timelineService = new TimelineService();\n      const searchManager = new SearchManager(\n        this.dbManager.getSessionSearch(),\n        this.dbManager.getSessionStore(),\n        this.dbManager.getChromaSync(),\n        formattingService,\n        timelineService\n      );\n      this.searchRoutes = new SearchRoutes(searchManager);\n      this.searchRoutes.setupRoutes(this.app); // Setup search routes now that SearchManager is ready\n      logger.info('WORKER', 'SearchManager initialized and search routes registered');\n\n      // Connect to MCP server with timeout guard\n      const mcpServerPath = path.join(__dirname, 'mcp-server.cjs');\n      const transport = new StdioClientTransport({\n        command: 'node',\n        args: [mcpServerPath],\n        env: process.env\n      });\n\n      // Add timeout guard to prevent hanging on MCP connection (15 seconds)\n      const MCP_INIT_TIMEOUT_MS = 15000;\n      const mcpConnectionPromise = this.mcpClient.connect(transport);\n      const timeoutPromise = new Promise<never>((_, reject) =>\n        setTimeout(() => reject(new Error('MCP connection timeout after 15s')), MCP_INIT_TIMEOUT_MS)\n      );\n\n      await Promise.race([mcpConnectionPromise, timeoutPromise]);\n      this.mcpReady = true;\n      logger.success('WORKER', 'Connected to MCP server');\n\n      // Signal that initialization is complete\n      this.initializationCompleteFlag = true;\n      this.resolveInitialization();\n      logger.info('SYSTEM', 'Background initialization complete');\n    } catch (error) {\n      logger.error('SYSTEM', 'Background initialization failed', {}, error as Error);\n      // Don't resolve - let the promise remain pending so readiness check continues to fail\n      throw error;\n    }\n  }\n\n  /**\n   * Extract a specific section from instruction content\n   * Used by /api/instructions endpoint for progressive instruction loading\n   */\n  private extractInstructionSection(content: string, topic: string): string {\n    const sections: Record<string, string> = {\n      'workflow': this.extractBetween(content, '## The Workflow', '## Search Parameters'),\n      'search_params': this.extractBetween(content, '## Search Parameters', '## Examples'),\n      'examples': this.extractBetween(content, '## Examples', '## Why This Workflow'),\n      'all': content\n    };\n\n    return sections[topic] || sections['all'];\n  }\n\n  /**\n   * Extract text between two markers\n   * Helper for extractInstructionSection\n   */\n  private extractBetween(content: string, startMarker: string, endMarker: string): string {\n    const startIdx = content.indexOf(startMarker);\n    const endIdx = content.indexOf(endMarker);\n\n    if (startIdx === -1) return content;\n    if (endIdx === -1) return content.substring(startIdx);\n\n    return content.substring(startIdx, endIdx).trim();\n  }\n\n  /**\n   * Shutdown the worker service\n   *\n   * IMPORTANT: On Windows, we must kill all child processes before exiting\n   * to prevent zombie ports. The socket handle can be inherited by children,\n   * and if not properly closed, the port stays bound after process death.\n   */\n  async shutdown(): Promise<void> {\n    logger.info('SYSTEM', 'Shutdown initiated');\n\n    // STEP 1: Enumerate all child processes BEFORE we start closing things\n    const childPids = await this.getChildProcesses(process.pid);\n    logger.info('SYSTEM', 'Found child processes', { count: childPids.length, pids: childPids });\n\n    // STEP 2: Close HTTP server first\n    if (this.server) {\n      this.server.closeAllConnections();\n      await new Promise<void>((resolve, reject) => {\n        this.server!.close(err => err ? reject(err) : resolve());\n      });\n      this.server = null;\n      logger.info('SYSTEM', 'HTTP server closed');\n    }\n\n    // STEP 3: Shutdown active sessions\n    await this.sessionManager.shutdownAll();\n\n    // STEP 4: Close MCP client connection (signals child to exit gracefully)\n    if (this.mcpClient) {\n      await this.mcpClient.close();\n      logger.info('SYSTEM', 'MCP client closed');\n    }\n\n    // STEP 5: Close database connection (includes ChromaSync cleanup)\n    await this.dbManager.close();\n\n    // STEP 6: Force kill any remaining child processes (Windows zombie port fix)\n    if (childPids.length > 0) {\n      logger.info('SYSTEM', 'Force killing remaining children');\n      for (const pid of childPids) {\n        await this.forceKillProcess(pid);\n      }\n      // Wait for children to fully exit\n      await this.waitForProcessesExit(childPids, 5000);\n    }\n\n    logger.info('SYSTEM', 'Worker shutdown complete');\n  }\n\n  /**\n   * Get all child process PIDs (Windows-specific)\n   */\n  private async getChildProcesses(parentPid: number): Promise<number[]> {\n    if (process.platform !== 'win32') {\n      return [];\n    }\n\n    // SECURITY: Validate PID is a positive integer to prevent command injection\n    if (!Number.isInteger(parentPid) || parentPid <= 0) {\n      logger.warn('SYSTEM', 'Invalid parent PID for child process enumeration', { parentPid });\n      return [];\n    }\n\n    const cmd = `powershell -Command \"Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq ${parentPid} } | Select-Object -ExpandProperty ProcessId\"`;\n    const { stdout } = await execAsync(cmd, { timeout: 5000 });\n    return stdout\n      .trim()\n      .split('\\n')\n      .map(s => parseInt(s.trim(), 10))\n      .filter(n => !isNaN(n) && Number.isInteger(n) && n > 0); // SECURITY: Validate each PID\n  }\n\n  /**\n   * Force kill a process by PID (Windows: uses taskkill /F /T)\n   */\n  private async forceKillProcess(pid: number): Promise<void> {\n    // SECURITY: Validate PID is a positive integer to prevent command injection\n    if (!Number.isInteger(pid) || pid <= 0) {\n      logger.warn('SYSTEM', 'Invalid PID for force kill', { pid });\n      return;\n    }\n\n    if (process.platform === 'win32') {\n      // /T kills entire process tree, /F forces termination\n      await execAsync(`taskkill /PID ${pid} /T /F`, { timeout: 5000 });\n      logger.info('SYSTEM', 'Killed process', { pid });\n    } else {\n      process.kill(pid, 'SIGKILL');\n    }\n  }\n\n  /**\n   * Wait for processes to fully exit\n   */\n  private async waitForProcessesExit(pids: number[], timeoutMs: number): Promise<void> {\n    const start = Date.now();\n\n    while (Date.now() - start < timeoutMs) {\n      const stillAlive = pids.filter(pid => {\n        process.kill(pid, 0); // Signal 0 checks if process exists - throws if dead\n        return true;\n      });\n\n      if (stillAlive.length === 0) {\n        logger.info('SYSTEM', 'All child processes exited');\n        return;\n      }\n\n      logger.debug('SYSTEM', 'Waiting for processes to exit', { stillAlive });\n      await new Promise(r => setTimeout(r, 100));\n    }\n\n    logger.warn('SYSTEM', 'Timeout waiting for child processes to exit');\n  }\n\n  /**\n   * Summarize request body for logging\n   * Used to avoid logging sensitive data or large payloads\n   */\n  private summarizeRequestBody(method: string, path: string, body: any): string {\n    return summarizeBody(method, path, body);\n  }\n\n  /**\n   * Broadcast processing status change to SSE clients\n   * Checks both queue depth and active generators to prevent premature spinner stop\n   *\n   * PUBLIC: Called by route handlers (SessionRoutes, DataRoutes)\n   */\n  broadcastProcessingStatus(): void {\n    const isProcessing = this.sessionManager.isAnySessionProcessing();\n    const queueDepth = this.sessionManager.getTotalActiveWork(); // Includes queued + actively processing\n    const activeSessions = this.sessionManager.getActiveSessionCount();\n\n    logger.info('WORKER', 'Broadcasting processing status', {\n      isProcessing,\n      queueDepth,\n      activeSessions\n    });\n\n    this.sseBroadcaster.broadcast({\n      type: 'processing_status',\n      isProcessing,\n      queueDepth\n    });\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_72": {
      "name": "constructor",
      "type": "method",
      "start_line": 72,
      "end_line": 110,
      "content_hash": "47a9b5a1a7b605e055d8015ec52d07156e582447",
      "content": "  constructor() {\n    this.app = express();\n\n    // Initialize the promise that will resolve when background initialization completes\n    this.initializationComplete = new Promise((resolve) => {\n      this.resolveInitialization = resolve;\n    });\n\n    // Initialize service layer\n    this.dbManager = new DatabaseManager();\n    this.sessionManager = new SessionManager(this.dbManager);\n    this.sseBroadcaster = new SSEBroadcaster();\n    this.sdkAgent = new SDKAgent(this.dbManager, this.sessionManager);\n    this.paginationHelper = new PaginationHelper(this.dbManager);\n    this.settingsManager = new SettingsManager(this.dbManager);\n    this.sessionEventBroadcaster = new SessionEventBroadcaster(this.sseBroadcaster, this);\n\n    // Set callback for when sessions are deleted (to update activity indicator)\n    this.sessionManager.setOnSessionDeleted(() => {\n      this.broadcastProcessingStatus();\n    });\n\n    // Initialize MCP client\n    this.mcpClient = new Client({\n      name: 'worker-search-proxy',\n      version: '1.0.0'\n    }, { capabilities: {} });\n\n    // Initialize route handlers (SearchRoutes will use MCP client initially, then switch to SearchManager after DB init)\n    this.viewerRoutes = new ViewerRoutes(this.sseBroadcaster, this.dbManager, this.sessionManager);\n    this.sessionRoutes = new SessionRoutes(this.sessionManager, this.dbManager, this.sdkAgent, this.sessionEventBroadcaster, this);\n    this.dataRoutes = new DataRoutes(this.paginationHelper, this.dbManager, this.sessionManager, this.sseBroadcaster, this, this.startTime);\n    // SearchRoutes needs SearchManager which requires initialized DB - will be created in initializeBackground()\n    this.searchRoutes = null;\n    this.settingsRoutes = new SettingsRoutes(this.settingsManager);\n\n    this.setupMiddleware();\n    this.setupRoutes();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupMiddleware_115": {
      "name": "setupMiddleware",
      "type": "method",
      "start_line": 115,
      "end_line": 118,
      "content_hash": "359d031d881ea262a93b84280af83f6ff84470f0",
      "content": "  private setupMiddleware(): void {\n    const middlewares = createMiddleware(this.summarizeRequestBody.bind(this));\n    middlewares.forEach(mw => this.app.use(mw));\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupRoutes_123": {
      "name": "setupRoutes",
      "type": "method",
      "start_line": 123,
      "end_line": 311,
      "content_hash": "1974ccbe27773658513575cba63dffe40de761d3",
      "content": "  private setupRoutes(): void {\n    // Health check endpoint\n    // TEST_BUILD_ID helps verify which build is running during debugging\n    const TEST_BUILD_ID = 'TEST-008-wrapper-ipc';\n    this.app.get('/api/health', (_req, res) => {\n      res.status(200).json({\n        status: 'ok',\n        build: TEST_BUILD_ID,\n        managed: process.env.CLAUDE_MEM_MANAGED === 'true',\n        hasIpc: typeof process.send === 'function',\n        platform: process.platform,\n        pid: process.pid,\n        initialized: this.initializationCompleteFlag,\n        mcpReady: this.mcpReady,\n      });\n    });\n\n    // Readiness check endpoint - returns 503 until full initialization completes\n    // Used by ProcessManager and worker-utils to ensure worker is fully ready before routing requests\n    this.app.get('/api/readiness', (_req, res) => {\n      if (this.initializationCompleteFlag) {\n        res.status(200).json({\n          status: 'ready',\n          mcpReady: this.mcpReady,\n        });\n      } else {\n        res.status(503).json({\n          status: 'initializing',\n          message: 'Worker is still initializing, please retry',\n        });\n      }\n    });\n\n    // Version endpoint - returns the worker's current version\n    this.app.get('/api/version', (_req, res) => {\n      const { homedir } = require('os');\n      const { readFileSync } = require('fs');\n      const marketplaceRoot = path.join(homedir(), '.claude', 'plugins', 'marketplaces', 'thedotmack');\n      const packageJsonPath = path.join(marketplaceRoot, 'package.json');\n\n      // Read version from marketplace package.json\n      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));\n      res.status(200).json({ version: packageJson.version });\n    });\n\n    // Instructions endpoint - loads SKILL.md sections on-demand for progressive instruction loading\n    this.app.get('/api/instructions', async (req, res) => {\n      const topic = (req.query.topic as string) || 'all';\n      const operation = req.query.operation as string | undefined;\n\n      // Path resolution: __dirname is build output directory (plugin/scripts/)\n      // SKILL.md is at plugin/skills/mem-search/SKILL.md\n      // Operations are at plugin/skills/mem-search/operations/*.md\n\n      try {\n        let content: string;\n\n        if (operation) {\n          // Load specific operation file\n          const operationPath = path.join(__dirname, '../skills/mem-search/operations', `${operation}.md`);\n          content = await fs.promises.readFile(operationPath, 'utf-8');\n        } else {\n          // Load SKILL.md and extract section based on topic (backward compatibility)\n          const skillPath = path.join(__dirname, '../skills/mem-search/SKILL.md');\n          const fullContent = await fs.promises.readFile(skillPath, 'utf-8');\n          content = this.extractInstructionSection(fullContent, topic);\n        }\n\n        // Return in MCP format\n        res.json({\n          content: [{\n            type: 'text',\n            text: content\n          }]\n        });\n      } catch (error) {\n        logger.error('WORKER', 'Failed to load instructions', { topic, operation }, error as Error);\n        res.status(500).json({\n          content: [{\n            type: 'text',\n            text: `Error loading instructions: ${error instanceof Error ? error.message : 'Unknown error'}`\n          }],\n          isError: true\n        });\n      }\n    });\n\n    // Admin endpoints for process management (localhost-only)\n    this.app.post('/api/admin/restart', requireLocalhost, async (_req, res) => {\n      res.json({ status: 'restarting' });\n\n      // On Windows, if managed by wrapper, send message to parent to handle restart\n      // This solves the Windows zombie port problem where sockets aren't properly released\n      const isWindowsManaged = process.platform === 'win32' &&\n        process.env.CLAUDE_MEM_MANAGED === 'true' &&\n        process.send;\n\n      if (isWindowsManaged) {\n        logger.info('SYSTEM', 'Sending restart request to wrapper');\n        process.send!({ type: 'restart' });\n      } else {\n        // Unix or standalone Windows - handle restart ourselves\n        setTimeout(async () => {\n          await this.shutdown();\n          process.exit(0);\n        }, 100);\n      }\n    });\n\n    this.app.post('/api/admin/shutdown', requireLocalhost, async (_req, res) => {\n      res.json({ status: 'shutting_down' });\n\n      // On Windows, if managed by wrapper, send message to parent to handle shutdown\n      const isWindowsManaged = process.platform === 'win32' &&\n        process.env.CLAUDE_MEM_MANAGED === 'true' &&\n        process.send;\n\n      if (isWindowsManaged) {\n        logger.info('SYSTEM', 'Sending shutdown request to wrapper');\n        process.send!({ type: 'shutdown' });\n      } else {\n        // Unix or standalone Windows - handle shutdown ourselves\n        setTimeout(async () => {\n          await this.shutdown();\n          process.exit(0);\n        }, 100);\n      }\n    });\n\n    this.viewerRoutes.setupRoutes(this.app);\n    this.sessionRoutes.setupRoutes(this.app);\n    this.dataRoutes.setupRoutes(this.app);\n    // searchRoutes is set up after database initialization in initializeBackground()\n    this.settingsRoutes.setupRoutes(this.app);\n\n    // Register early handler for /api/context/inject to avoid 404 during startup\n    // This handler waits for initialization to complete before delegating to SearchRoutes\n    // NOTE: This duplicates logic from SearchRoutes.handleContextInject by design,\n    // as we need the route available immediately before SearchRoutes is initialized\n    this.app.get('/api/context/inject', async (req, res, next) => {\n      try {\n        // Wait for initialization to complete (with timeout)\n        const timeoutMs = 30000; // 30 second timeout\n        const timeoutPromise = new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Initialization timeout')), timeoutMs)\n        );\n        \n        await Promise.race([this.initializationComplete, timeoutPromise]);\n\n        // If searchRoutes is still null after initialization, something went wrong\n        if (!this.searchRoutes) {\n          res.status(503).json({ error: 'Search routes not initialized' });\n          return;\n        }\n\n        // Delegate to the proper handler by re-processing the request\n        // Since we're already in the middleware chain, we need to call the handler directly\n        const projectName = req.query.project as string;\n        const useColors = req.query.colors === 'true';\n\n        if (!projectName) {\n          res.status(400).json({ error: 'Project parameter is required' });\n          return;\n        }\n\n        // Import context generator (runs in worker, has access to database)\n        const { generateContext } = await import('./context-generator.js');\n\n        // Use project name as CWD (generateContext uses path.basename to get project)\n        const cwd = `/context/${projectName}`;\n\n        // Generate context\n        const contextText = await generateContext(\n          {\n            session_id: 'context-inject-' + Date.now(),\n            cwd: cwd\n          },\n          useColors\n        );\n\n        // Return as plain text\n        res.setHeader('Content-Type', 'text/plain; charset=utf-8');\n        res.send(contextText);\n      } catch (error) {\n        logger.error('WORKER', 'Context inject handler failed', {}, error as Error);\n        res.status(500).json({ error: error instanceof Error ? error.message : 'Internal server error' });\n      }\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cleanupOrphanedProcesses_318": {
      "name": "cleanupOrphanedProcesses",
      "type": "method",
      "start_line": 318,
      "end_line": 387,
      "content_hash": "8bede0060c25004b021141c494686094f6253f91",
      "content": "  private async cleanupOrphanedProcesses(): Promise<void> {\n    const isWindows = process.platform === 'win32';\n    const pids: number[] = [];\n\n    if (isWindows) {\n      // Windows: Use PowerShell Get-CimInstance to find chroma-mcp processes\n      const cmd = `powershell -Command \"Get-CimInstance Win32_Process | Where-Object { $_.Name -like '*python*' -and $_.CommandLine -like '*chroma-mcp*' } | Select-Object -ExpandProperty ProcessId\"`;\n      const { stdout } = await execAsync(cmd, { timeout: 5000 });\n\n      if (!stdout.trim()) {\n        logger.debug('SYSTEM', 'No orphaned chroma-mcp processes found (Windows)');\n        return;\n      }\n\n      const pidStrings = stdout.trim().split('\\n');\n      for (const pidStr of pidStrings) {\n        const pid = parseInt(pidStr.trim(), 10);\n        // SECURITY: Validate PID is positive integer before adding to list\n        if (!isNaN(pid) && Number.isInteger(pid) && pid > 0) {\n          pids.push(pid);\n        }\n      }\n    } else {\n      // Unix: Use ps aux | grep\n      const { stdout } = await execAsync('ps aux | grep \"chroma-mcp\" | grep -v grep || true');\n\n      if (!stdout.trim()) {\n        logger.debug('SYSTEM', 'No orphaned chroma-mcp processes found (Unix)');\n        return;\n      }\n\n      const lines = stdout.trim().split('\\n');\n      for (const line of lines) {\n        const parts = line.trim().split(/\\s+/);\n        if (parts.length > 1) {\n          const pid = parseInt(parts[1], 10);\n          // SECURITY: Validate PID is positive integer before adding to list\n          if (!isNaN(pid) && Number.isInteger(pid) && pid > 0) {\n            pids.push(pid);\n          }\n        }\n      }\n    }\n\n    if (pids.length === 0) {\n      return;\n    }\n\n    logger.info('SYSTEM', 'Cleaning up orphaned chroma-mcp processes', {\n      platform: isWindows ? 'Windows' : 'Unix',\n      count: pids.length,\n      pids\n    });\n\n    // Kill all found processes\n    if (isWindows) {\n      for (const pid of pids) {\n        // SECURITY: Double-check PID validation before using in taskkill command\n        if (!Number.isInteger(pid) || pid <= 0) {\n          logger.warn('SYSTEM', 'Skipping invalid PID', { pid });\n          continue;\n        }\n        execSync(`taskkill /PID ${pid} /T /F`, { timeout: 5000, stdio: 'ignore' });\n      }\n    } else {\n      await execAsync(`kill ${pids.join(' ')}`);\n    }\n\n    logger.info('SYSTEM', 'Orphaned processes cleaned up', { count: pids.length });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_start_392": {
      "name": "start",
      "type": "method",
      "start_line": 392,
      "end_line": 407,
      "content_hash": "edd280a29ea25412e7ec712ae8a5ca5151738781",
      "content": "  async start(): Promise<void> {\n    // Start HTTP server FIRST - make port available immediately\n    const port = getWorkerPort();\n    const host = getWorkerHost();\n    this.server = await new Promise<http.Server>((resolve, reject) => {\n      const srv = this.app.listen(port, host, () => resolve(srv));\n      srv.on('error', reject);\n    });\n\n    logger.info('SYSTEM', 'Worker started', { host, port, pid: process.pid });\n\n    // Do slow initialization in background (non-blocking)\n    this.initializeBackground().catch((error) => {\n      logger.error('SYSTEM', 'Background initialization failed', {}, error as Error);\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initializeBackground_412": {
      "name": "initializeBackground",
      "type": "method",
      "start_line": 412,
      "end_line": 472,
      "content_hash": "44937e260b520a63b3defcd63b1440aebb1cf0e1",
      "content": "  private async initializeBackground(): Promise<void> {\n    try {\n      // Clean up any orphaned chroma-mcp processes BEFORE starting our own\n      await this.cleanupOrphanedProcesses();\n\n      // Load mode configuration (must happen before database to set observation types)\n      const { ModeManager } = await import('./domain/ModeManager.js');\n      const { SettingsDefaultsManager } = await import('../shared/SettingsDefaultsManager.js');\n      const { USER_SETTINGS_PATH } = await import('../shared/paths.js');\n\n      const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n      const modeId = settings.CLAUDE_MEM_MODE;\n      ModeManager.getInstance().loadMode(modeId);\n      logger.info('SYSTEM', `Mode loaded: ${modeId}`);\n\n      // Initialize database (once, stays open)\n      await this.dbManager.initialize();\n\n      // Initialize search services (requires initialized database)\n      const formattingService = new FormattingService();\n      const timelineService = new TimelineService();\n      const searchManager = new SearchManager(\n        this.dbManager.getSessionSearch(),\n        this.dbManager.getSessionStore(),\n        this.dbManager.getChromaSync(),\n        formattingService,\n        timelineService\n      );\n      this.searchRoutes = new SearchRoutes(searchManager);\n      this.searchRoutes.setupRoutes(this.app); // Setup search routes now that SearchManager is ready\n      logger.info('WORKER', 'SearchManager initialized and search routes registered');\n\n      // Connect to MCP server with timeout guard\n      const mcpServerPath = path.join(__dirname, 'mcp-server.cjs');\n      const transport = new StdioClientTransport({\n        command: 'node',\n        args: [mcpServerPath],\n        env: process.env\n      });\n\n      // Add timeout guard to prevent hanging on MCP connection (15 seconds)\n      const MCP_INIT_TIMEOUT_MS = 15000;\n      const mcpConnectionPromise = this.mcpClient.connect(transport);\n      const timeoutPromise = new Promise<never>((_, reject) =>\n        setTimeout(() => reject(new Error('MCP connection timeout after 15s')), MCP_INIT_TIMEOUT_MS)\n      );\n\n      await Promise.race([mcpConnectionPromise, timeoutPromise]);\n      this.mcpReady = true;\n      logger.success('WORKER', 'Connected to MCP server');\n\n      // Signal that initialization is complete\n      this.initializationCompleteFlag = true;\n      this.resolveInitialization();\n      logger.info('SYSTEM', 'Background initialization complete');\n    } catch (error) {\n      logger.error('SYSTEM', 'Background initialization failed', {}, error as Error);\n      // Don't resolve - let the promise remain pending so readiness check continues to fail\n      throw error;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractInstructionSection_478": {
      "name": "extractInstructionSection",
      "type": "method",
      "start_line": 478,
      "end_line": 487,
      "content_hash": "f0616616c0f3e50f8709704891e6d0985b762cbb",
      "content": "  private extractInstructionSection(content: string, topic: string): string {\n    const sections: Record<string, string> = {\n      'workflow': this.extractBetween(content, '## The Workflow', '## Search Parameters'),\n      'search_params': this.extractBetween(content, '## Search Parameters', '## Examples'),\n      'examples': this.extractBetween(content, '## Examples', '## Why This Workflow'),\n      'all': content\n    };\n\n    return sections[topic] || sections['all'];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractBetween_493": {
      "name": "extractBetween",
      "type": "method",
      "start_line": 493,
      "end_line": 501,
      "content_hash": "af76647fc66f161b1cf26df7a86acc8bdcd33321",
      "content": "  private extractBetween(content: string, startMarker: string, endMarker: string): string {\n    const startIdx = content.indexOf(startMarker);\n    const endIdx = content.indexOf(endMarker);\n\n    if (startIdx === -1) return content;\n    if (endIdx === -1) return content.substring(startIdx);\n\n    return content.substring(startIdx, endIdx).trim();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shutdown_510": {
      "name": "shutdown",
      "type": "method",
      "start_line": 510,
      "end_line": 550,
      "content_hash": "b571641a4bf463e8cc384e8c97ec10096cf0b536",
      "content": "  async shutdown(): Promise<void> {\n    logger.info('SYSTEM', 'Shutdown initiated');\n\n    // STEP 1: Enumerate all child processes BEFORE we start closing things\n    const childPids = await this.getChildProcesses(process.pid);\n    logger.info('SYSTEM', 'Found child processes', { count: childPids.length, pids: childPids });\n\n    // STEP 2: Close HTTP server first\n    if (this.server) {\n      this.server.closeAllConnections();\n      await new Promise<void>((resolve, reject) => {\n        this.server!.close(err => err ? reject(err) : resolve());\n      });\n      this.server = null;\n      logger.info('SYSTEM', 'HTTP server closed');\n    }\n\n    // STEP 3: Shutdown active sessions\n    await this.sessionManager.shutdownAll();\n\n    // STEP 4: Close MCP client connection (signals child to exit gracefully)\n    if (this.mcpClient) {\n      await this.mcpClient.close();\n      logger.info('SYSTEM', 'MCP client closed');\n    }\n\n    // STEP 5: Close database connection (includes ChromaSync cleanup)\n    await this.dbManager.close();\n\n    // STEP 6: Force kill any remaining child processes (Windows zombie port fix)\n    if (childPids.length > 0) {\n      logger.info('SYSTEM', 'Force killing remaining children');\n      for (const pid of childPids) {\n        await this.forceKillProcess(pid);\n      }\n      // Wait for children to fully exit\n      await this.waitForProcessesExit(childPids, 5000);\n    }\n\n    logger.info('SYSTEM', 'Worker shutdown complete');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getChildProcesses_555": {
      "name": "getChildProcesses",
      "type": "method",
      "start_line": 555,
      "end_line": 573,
      "content_hash": "31bcee46dabd1920be5f090103871440719ca575",
      "content": "  private async getChildProcesses(parentPid: number): Promise<number[]> {\n    if (process.platform !== 'win32') {\n      return [];\n    }\n\n    // SECURITY: Validate PID is a positive integer to prevent command injection\n    if (!Number.isInteger(parentPid) || parentPid <= 0) {\n      logger.warn('SYSTEM', 'Invalid parent PID for child process enumeration', { parentPid });\n      return [];\n    }\n\n    const cmd = `powershell -Command \"Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq ${parentPid} } | Select-Object -ExpandProperty ProcessId\"`;\n    const { stdout } = await execAsync(cmd, { timeout: 5000 });\n    return stdout\n      .trim()\n      .split('\\n')\n      .map(s => parseInt(s.trim(), 10))\n      .filter(n => !isNaN(n) && Number.isInteger(n) && n > 0); // SECURITY: Validate each PID\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_forceKillProcess_578": {
      "name": "forceKillProcess",
      "type": "method",
      "start_line": 578,
      "end_line": 592,
      "content_hash": "82dd1720983850ab8db919a6b602487c4fae41cf",
      "content": "  private async forceKillProcess(pid: number): Promise<void> {\n    // SECURITY: Validate PID is a positive integer to prevent command injection\n    if (!Number.isInteger(pid) || pid <= 0) {\n      logger.warn('SYSTEM', 'Invalid PID for force kill', { pid });\n      return;\n    }\n\n    if (process.platform === 'win32') {\n      // /T kills entire process tree, /F forces termination\n      await execAsync(`taskkill /PID ${pid} /T /F`, { timeout: 5000 });\n      logger.info('SYSTEM', 'Killed process', { pid });\n    } else {\n      process.kill(pid, 'SIGKILL');\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForProcessesExit_597": {
      "name": "waitForProcessesExit",
      "type": "method",
      "start_line": 597,
      "end_line": 616,
      "content_hash": "d5543406a479c6b944ff7b74484bf744ced20a88",
      "content": "  private async waitForProcessesExit(pids: number[], timeoutMs: number): Promise<void> {\n    const start = Date.now();\n\n    while (Date.now() - start < timeoutMs) {\n      const stillAlive = pids.filter(pid => {\n        process.kill(pid, 0); // Signal 0 checks if process exists - throws if dead\n        return true;\n      });\n\n      if (stillAlive.length === 0) {\n        logger.info('SYSTEM', 'All child processes exited');\n        return;\n      }\n\n      logger.debug('SYSTEM', 'Waiting for processes to exit', { stillAlive });\n      await new Promise(r => setTimeout(r, 100));\n    }\n\n    logger.warn('SYSTEM', 'Timeout waiting for child processes to exit');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_summarizeRequestBody_622": {
      "name": "summarizeRequestBody",
      "type": "method",
      "start_line": 622,
      "end_line": 624,
      "content_hash": "f5293ca324d87887fccaa76a095ddfd355e0b048",
      "content": "  private summarizeRequestBody(method: string, path: string, body: any): string {\n    return summarizeBody(method, path, body);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_broadcastProcessingStatus_632": {
      "name": "broadcastProcessingStatus",
      "type": "method",
      "start_line": 632,
      "end_line": 648,
      "content_hash": "7ec71b694a6b6998fb6f1c8e611fc276077c93c6",
      "content": "  broadcastProcessingStatus(): void {\n    const isProcessing = this.sessionManager.isAnySessionProcessing();\n    const queueDepth = this.sessionManager.getTotalActiveWork(); // Includes queued + actively processing\n    const activeSessions = this.sessionManager.getActiveSessionCount();\n\n    logger.info('WORKER', 'Broadcasting processing status', {\n      isProcessing,\n      queueDepth,\n      activeSessions\n    });\n\n    this.sseBroadcaster.broadcast({\n      type: 'processing_status',\n      isProcessing,\n      queueDepth\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}