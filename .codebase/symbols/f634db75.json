{
  "file_path": "/work/context-engine/scripts/mcp_router/client.py",
  "file_hash": "abe9aa1c73786c0d10f6767b2a5fe1583e2acd7e",
  "updated_at": "2025-12-26T17:34:23.889986",
  "symbols": {
    "function__post_raw_27": {
      "name": "_post_raw",
      "type": "function",
      "start_line": 27,
      "end_line": 35,
      "content_hash": "84f348d7ba7394ef4d4fb166967d922ec4489f56",
      "content": "def _post_raw(url: str, payload: Dict[str, Any], headers: Dict[str, str], timeout: float = 60.0) -> Tuple[Dict[str, str], bytes]:\n    req = request.Request(url, method=\"POST\")\n    for k, v in headers.items():\n        req.add_header(k, v)\n    data = json.dumps(payload).encode(\"utf-8\")\n    with request.urlopen(req, data=data, timeout=timeout) as resp:\n        body = resp.read()\n        hdrs = {k.lower(): v for k, v in resp.headers.items()}\n    return hdrs, body",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__post_raw_retry_38": {
      "name": "_post_raw_retry",
      "type": "function",
      "start_line": 38,
      "end_line": 52,
      "content_hash": "1181c378e248ef8f760287b1da69eea67e017344",
      "content": "def _post_raw_retry(url: str, payload: Dict[str, Any], headers: Dict[str, str],\n                    timeout: float = 60.0, retries: int = 2, backoff: float = 0.5) -> Tuple[Dict[str, str], bytes]:\n    last_exc: Exception | None = None\n    for i in range(max(0, retries) + 1):\n        try:\n            return _post_raw(url, payload, headers, timeout=timeout)\n        except Exception as e:\n            last_exc = e\n            if i < retries:\n                try:\n                    time.sleep(backoff * (2 ** i))\n                except Exception:\n                    pass\n            else:\n                raise last_exc",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__parse_stream_or_json_55": {
      "name": "_parse_stream_or_json",
      "type": "function",
      "start_line": 55,
      "end_line": 67,
      "content_hash": "4464f849e8ef6783974620354e4d998ca67c32fd",
      "content": "def _parse_stream_or_json(body: bytes) -> Dict[str, Any]:\n    txt = body.decode(\"utf-8\", errors=\"ignore\")\n    if \"data:\" in txt and (\"event:\" in txt or txt.strip().startswith(\"data:\")):\n        last = None\n        for line in txt.splitlines():\n            if line.startswith(\"data:\"):\n                last = line[len(\"data:\"):].strip()\n        if last:\n            try:\n                return json.loads(last)\n            except Exception:\n                pass\n    return json.loads(txt)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__filter_args_70": {
      "name": "_filter_args",
      "type": "function",
      "start_line": 70,
      "end_line": 72,
      "content_hash": "d4a7b7365d84bacaebd56247ceb3684873f3aa36",
      "content": "def _filter_args(d: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Remove None/empty values from args dict.\"\"\"\n    return {k: v for k, v in d.items() if v not in (None, \"\")}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__mcp_handshake_75": {
      "name": "_mcp_handshake",
      "type": "function",
      "start_line": 75,
      "end_line": 105,
      "content_hash": "1aab4e3342e8aa02c9ae1af4e51c979f9d794d76",
      "content": "def _mcp_handshake(base_url: str, timeout: float = 30.0) -> Dict[str, str]:\n    \"\"\"Perform MCP handshake and return headers with session ID.\"\"\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json, text/event-stream\",\n    }\n    init_payload = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": \"initialize\",\n        \"params\": {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {},\n            \"clientInfo\": {\"name\": \"router\", \"version\": \"0.1.0\"},\n        },\n        \"id\": 1,\n    }\n    hdrs, body = _post_raw_retry(base_url, init_payload, headers, timeout=timeout)\n    sid = hdrs.get(\"mcp-session-id\") or hdrs.get(\"Mcp-Session-Id\")\n    if not sid:\n        try:\n            j = _parse_stream_or_json(body)\n            sid = j.get(\"sessionId\")\n        except Exception:\n            sid = None\n    if sid:\n        headers[\"Mcp-Session-Id\"] = sid\n    try:\n        _post_raw_retry(base_url, {\"jsonrpc\": \"2.0\", \"method\": \"notifications/initialized\"}, headers, timeout=timeout)\n    except Exception:\n        pass\n    return headers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_iserror_text_108": {
      "name": "_extract_iserror_text",
      "type": "function",
      "start_line": 108,
      "end_line": 118,
      "content_hash": "7ce0cfcd220fa77387edbc6bde32e25910125532",
      "content": "def _extract_iserror_text(resp: Dict[str, Any]) -> str | None:\n    try:\n        r = resp.get(\"result\") or {}\n        if isinstance(r, dict) and r.get(\"isError\"):\n            content = r.get(\"content\")\n            if isinstance(content, list) and content and isinstance(content[0], dict):\n                if content[0].get(\"type\") == \"text\":\n                    return content[0].get(\"text\")\n    except Exception:\n        pass\n    return None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_call_tool_http_121": {
      "name": "call_tool_http",
      "type": "function",
      "start_line": 121,
      "end_line": 174,
      "content_hash": "c41b3dd17ad3414c01870fb772563d9c2b596854",
      "content": "def call_tool_http(base_url: str, tool_name: str, args: Dict[str, Any], timeout: float = 120.0) -> Dict[str, Any]:\n    \"\"\"Call an MCP tool over HTTP.\"\"\"\n    headers = _mcp_handshake(base_url, timeout=min(timeout, 30.0))\n\n    def _do_call(arguments: Dict[str, Any]) -> Dict[str, Any]:\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"id\": \"router-1\",\n            \"method\": \"tools/call\",\n            \"params\": {\n                \"name\": tool_name,\n                \"arguments\": arguments,\n            },\n        }\n        _, body = _post_raw_retry(base_url, payload, headers, timeout=timeout)\n        return _parse_stream_or_json(body)\n\n    args1 = _filter_args(args)\n    if tool_name.endswith(\"_compat\"):\n        resp = _do_call({\"arguments\": args1})\n    else:\n        resp = _do_call(args1)\n\n    def _get_structured_error(r: Dict[str, Any]) -> str | None:\n        try:\n            rr = r.get(\"result\") or {}\n            sc = rr.get(\"structuredContent\") or {}\n            rs = sc.get(\"result\") or {}\n            err = rs.get(\"error\")\n            if isinstance(err, str):\n                return err\n        except Exception:\n            pass\n        return None\n\n    msg = _extract_iserror_text(resp)\n    serr = _get_structured_error(resp)\n    if msg:\n        low = msg.lower()\n        if (\"kwargs\" in low) and (\"field required\" in low or \"missing\" in low):\n            return _do_call({\"kwargs\": args1})\n        if (\"arguments\" in low) and (\"field required\" in low or \"missing\" in low):\n            return _do_call({\"arguments\": args1})\n    if (serr and serr.strip().lower() == \"query required\") and (\"query\" in args1 or \"queries\" in args1):\n        resp4 = _do_call({\"kwargs\": args1})\n        serr2 = _get_structured_error(resp4)\n        if not (serr2 and serr2.strip().lower() == \"query required\"):\n            return resp4\n        resp5 = _do_call({\"arguments\": {\"kwargs\": args1}})\n        serr3 = _get_structured_error(resp5)\n        if not (serr3 and serr3.strip().lower() == \"query required\"):\n            return resp5\n        return _do_call({\"arguments\": args1})\n    return resp",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__do_call_125": {
      "name": "_do_call",
      "type": "function",
      "start_line": 125,
      "end_line": 136,
      "content_hash": "4942a89dc73119fec2ad845eced28ad65b8a06ca",
      "content": "    def _do_call(arguments: Dict[str, Any]) -> Dict[str, Any]:\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"id\": \"router-1\",\n            \"method\": \"tools/call\",\n            \"params\": {\n                \"name\": tool_name,\n                \"arguments\": arguments,\n            },\n        }\n        _, body = _post_raw_retry(base_url, payload, headers, timeout=timeout)\n        return _parse_stream_or_json(body)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__get_structured_error_144": {
      "name": "_get_structured_error",
      "type": "function",
      "start_line": 144,
      "end_line": 154,
      "content_hash": "526a510300cf60e647e9038269904e306e472366",
      "content": "    def _get_structured_error(r: Dict[str, Any]) -> str | None:\n        try:\n            rr = r.get(\"result\") or {}\n            sc = rr.get(\"structuredContent\") or {}\n            rs = sc.get(\"result\") or {}\n            err = rs.get(\"error\")\n            if isinstance(err, str):\n                return err\n        except Exception:\n            pass\n        return None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_is_failure_response_177": {
      "name": "is_failure_response",
      "type": "function",
      "start_line": 177,
      "end_line": 189,
      "content_hash": "082258308326bf7311743a3e0e65afc4e66414f3",
      "content": "def is_failure_response(resp: Dict[str, Any]) -> bool:\n    \"\"\"Check if response indicates a failure.\"\"\"\n    try:\n        r = resp.get(\"result\") or {}\n        if r.get(\"isError\") is True:\n            return True\n        sc = r.get(\"structuredContent\") or {}\n        rs = sc.get(\"result\") or {}\n        if isinstance(rs, dict) and isinstance(rs.get(\"error\"), str):\n            return True\n    except Exception:\n        return False\n    return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__tools_describe_from_health_192": {
      "name": "_tools_describe_from_health",
      "type": "function",
      "start_line": 192,
      "end_line": 218,
      "content_hash": "348a5ede465272d61c36a296d57660916b6cfa66",
      "content": "def _tools_describe_from_health(base_url: str, timeout: float = 3.0) -> list[dict]:\n    \"\"\"Fetch tool descriptors from health /tools endpoint.\"\"\"\n    try:\n        import urllib.request\n        if base_url == HTTP_URL_INDEXER:\n            url = f\"http://localhost:{HEALTH_PORT_INDEXER}/tools\"\n        elif base_url == HTTP_URL_MEMORY:\n            url = f\"http://localhost:{HEALTH_PORT_MEMORY}/tools\"\n        else:\n            return []\n        with urllib.request.urlopen(url, timeout=timeout) as r:\n            if getattr(r, \"status\", 200) != 200:\n                return []\n            body = r.read()\n            j = _parse_stream_or_json(body)\n            tools = (j.get(\"tools\") if isinstance(j, dict) else None) or []\n            out = []\n            for t in tools:\n                if not isinstance(t, dict):\n                    continue\n                nm = t.get(\"name\")\n                if not nm:\n                    continue\n                out.append({\"name\": nm, \"description\": (t.get(\"description\") or \"\").strip()})\n            return out\n    except Exception:\n        return []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__mcp_tools_list_221": {
      "name": "_mcp_tools_list",
      "type": "function",
      "start_line": 221,
      "end_line": 239,
      "content_hash": "b368a21ea322d7f196c696b5b93552e03af53e91",
      "content": "def _mcp_tools_list(base_url: str, timeout: float = 30.0) -> List[str]:\n    \"\"\"Get list of tool names from MCP server.\"\"\"\n    try:\n        headers = _mcp_handshake(base_url, timeout=min(timeout, 15.0))\n        payload = {\"jsonrpc\": \"2.0\", \"id\": \"router-list\", \"method\": \"tools/list\"}\n        _, body = _post_raw_retry(base_url, payload, headers, timeout=timeout)\n        j = _parse_stream_or_json(body)\n        tools = ((j.get(\"result\") or {}).get(\"tools\") or [])\n        names: List[str] = []\n        for t in tools:\n            try:\n                n = t.get(\"name\") if isinstance(t, dict) else None\n                if isinstance(n, str) and n:\n                    names.append(n)\n            except Exception:\n                continue\n        return names\n    except Exception:\n        return []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__mcp_tools_describe_242": {
      "name": "_mcp_tools_describe",
      "type": "function",
      "start_line": 242,
      "end_line": 260,
      "content_hash": "be97e0aa00575094c8b3265db0b05136d8f065bb",
      "content": "def _mcp_tools_describe(base_url: str, timeout: float = 20.0) -> list[dict]:\n    \"\"\"Return tool dicts from tools/list.\"\"\"\n    try:\n        headers = _mcp_handshake(base_url, timeout=min(timeout, 10.0))\n        payload = {\"jsonrpc\": \"2.0\", \"id\": \"router-list2\", \"method\": \"tools/list\"}\n        _, body = _post_raw_retry(base_url, payload, headers, timeout=timeout)\n        j = _parse_stream_or_json(body)\n        tools = ((j.get(\"result\") or {}).get(\"tools\") or [])\n        out = []\n        for t in tools:\n            if not isinstance(t, dict):\n                continue\n            name = (t.get(\"name\") or \"\").strip()\n            if not name:\n                continue\n            out.append(t)\n        return out\n    except Exception:\n        return []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_tools_describe_cached_263": {
      "name": "tools_describe_cached",
      "type": "function",
      "start_line": 263,
      "end_line": 274,
      "content_hash": "e6edae5ddaaa83ceeab9d29fb7417b7c0b097fa7",
      "content": "def tools_describe_cached(base_url: str, allow_network: bool = True, timeout: float = 20.0) -> list[dict]:\n    \"\"\"Get tool descriptions with caching.\"\"\"\n    now = time.time()\n    ts = _TOOLS_DESCR_TS.get(base_url, 0.0)\n    if base_url in _TOOLS_DESCR_CACHE and (now - ts) <= cache_ttl_sec():\n        return _TOOLS_DESCR_CACHE[base_url]\n    if not allow_network:\n        return _TOOLS_DESCR_CACHE.get(base_url, [])\n    desc = _tools_describe_from_health(base_url, timeout=min(timeout, 3.0)) or _mcp_tools_describe(base_url, timeout=timeout)\n    _TOOLS_DESCR_CACHE[base_url] = desc\n    _TOOLS_DESCR_TS[base_url] = now\n    return desc",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_default_tool_endpoints_277": {
      "name": "default_tool_endpoints",
      "type": "function",
      "start_line": 277,
      "end_line": 291,
      "content_hash": "e0f09a16581605ed06e86b97dc7b766f8dfcb21d",
      "content": "def default_tool_endpoints() -> Dict[str, str]:\n    \"\"\"Return default tool -> endpoint mapping.\"\"\"\n    idx = HTTP_URL_INDEXER\n    mem = HTTP_URL_MEMORY\n    mapping: Dict[str, str] = {}\n    for n in [\n        \"repo_search\", \"context_answer\", \"context_answer_compat\", \"expand_query\",\n        \"search_tests_for\", \"search_config_for\", \"search_callers_for\", \"search_importers_for\",\n        \"qdrant_index_root\", \"qdrant_prune\", \"qdrant_status\", \"qdrant_list\",\n        \"workspace_info\", \"list_workspaces\", \"change_history_for_path\", \"code_search\", \"context_search\",\n    ]:\n        mapping[n] = idx\n    mapping[\"store\"] = mem\n    mapping[\"find\"] = mem\n    return mapping",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_discover_tool_endpoints_294": {
      "name": "discover_tool_endpoints",
      "type": "function",
      "start_line": 294,
      "end_line": 318,
      "content_hash": "06158eaed92259a2b4589ad148d0bdebb24c7c73",
      "content": "def discover_tool_endpoints(force: bool = False, allow_network: bool = True) -> Dict[str, str]:\n    \"\"\"Discover tool -> endpoint mapping from servers.\"\"\"\n    global _TOOL_ENDPOINTS_CACHE_TS, _TOOL_ENDPOINTS_CACHE_MAP\n    now = time.time()\n    ttl = cache_ttl_sec()\n    if not force and _TOOL_ENDPOINTS_CACHE_MAP and (now - _TOOL_ENDPOINTS_CACHE_TS) <= ttl:\n        return _TOOL_ENDPOINTS_CACHE_MAP\n    if not allow_network:\n        return _TOOL_ENDPOINTS_CACHE_MAP or default_tool_endpoints()\n    mapping: Dict[str, str] = {}\n    idx_desc = tools_describe_cached(HTTP_URL_INDEXER, allow_network=allow_network)\n    for t in idx_desc:\n        n = t.get(\"name\") if isinstance(t, dict) else None\n        if n:\n            mapping[n] = HTTP_URL_INDEXER\n    mem_desc = tools_describe_cached(HTTP_URL_MEMORY, allow_network=allow_network)\n    for t in mem_desc:\n        n = t.get(\"name\") if isinstance(t, dict) else None\n        if n and n not in mapping:\n            mapping[n] = HTTP_URL_MEMORY\n    if mapping:\n        _TOOL_ENDPOINTS_CACHE_MAP.clear()\n        _TOOL_ENDPOINTS_CACHE_MAP.update(mapping)\n        _TOOL_ENDPOINTS_CACHE_TS = now\n    return mapping or (_TOOL_ENDPOINTS_CACHE_MAP or default_tool_endpoints())",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}