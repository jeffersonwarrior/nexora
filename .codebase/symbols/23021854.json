{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/generator/traversal_steps.rs",
  "file_hash": "12b3950b43d5699616d3f0ea8947f392cc4da9fe",
  "updated_at": "2025-12-26T17:34:23.065158",
  "symbols": {
    "struct_NestedTraversalInfo_16": {
      "name": "NestedTraversalInfo",
      "type": "struct",
      "start_line": 16,
      "end_line": 26,
      "content_hash": "c96ef2a2ec87c541b1a265dbb9641a4a781748b8",
      "content": "pub struct NestedTraversalInfo {\n    pub traversal: Box<Traversal>, // The generated traversal after validation\n    pub return_type: Option<Type>, // The type this traversal returns\n    pub field_name: String,        // The field name in the parent object\n    pub parsed_traversal: Option<Box<crate::helixc::parser::types::Traversal>>, // Original parsed traversal for validation\n    pub closure_param_name: Option<String>, // The closure parameter name if in closure context (e.g., \"usr\")\n    pub closure_source_var: Option<String>, // The actual source variable for the closure parameter (e.g., \"user\")\n    pub own_closure_param: Option<String>, // This traversal's own closure parameter if it ends with a Closure step (e.g., \"cluster\")\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_TraversalType_27": {
      "name": "TraversalType",
      "type": "enum",
      "start_line": 27,
      "end_line": 36,
      "content_hash": "1546485fcb7ebc4e4913a43492163f296d225f3e",
      "content": "pub enum TraversalType {\n    FromSingle(GenRef<String>),\n    FromIter(GenRef<String>),\n    Ref,\n    Mut,\n    Empty,\n    Update(Option<Vec<(String, GeneratedValue)>>),\n    /// Standalone - no G::new wrapper, just the source step (used for plural AddE)\n    Standalone,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Debug_37": {
      "name": "Debug",
      "type": "impl",
      "start_line": 37,
      "end_line": 37,
      "content_hash": "23370d7efd717d88e2852ad79cc244e1da383c71",
      "content": "impl Debug for TraversalType {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_38": {
      "name": "fmt",
      "type": "method",
      "start_line": 38,
      "end_line": 65,
      "content_hash": "07529b5954f9eef80f1f5f828f9512b06fe77f5c",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            TraversalType::FromSingle(_) => write!(f, \"FromSingle\"),\n            TraversalType::FromIter(_) => write!(f, \"FromIter\"),\n            TraversalType::Ref => write!(f, \"Ref\"),\n            TraversalType::Standalone => write!(f, \"Standalone\"),\n            _ => write!(f, \"other\"),\n        }\n    }\n}\n// impl Display for TraversalType {\n//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n//         match self {\n//             TraversalType::FromVar => write!(f, \"\"),\n//             TraversalType::Ref => write!(f, \"G::new(Arc::clone(&db), &txn)\"),\n\n//             TraversalType::Mut => write!(f, \"G::new_mut(Arc::clone(&db), &mut txn)\"),\n//             TraversalType::Nested(nested) => {\n//                 assert!(nested.inner().len() > 0, \"Empty nested traversal name\");\n//                 write!(f, \"G::new_from(Arc::clone(&db), &txn, {})\", nested)\n//             }\n//             TraversalType::Update => write!(f, \"\"),\n//             // TraversalType::FromVar(var) => write!(f, \"G::new_from(Arc::clone(&db), &txn, {})\", var),\n//             TraversalType::Empty => panic!(\"Should not be empty\"),\n//         }\n//     }\n// }\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ShouldCollect_66": {
      "name": "ShouldCollect",
      "type": "enum",
      "start_line": 66,
      "end_line": 72,
      "content_hash": "df8502580b5b0d30e0e4e51e6b52168584cd4cbc",
      "content": "pub enum ShouldCollect {\n    ToVec,\n    ToObj,\n    No,\n    Try,\n    ToValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_73": {
      "name": "Display",
      "type": "impl",
      "start_line": 73,
      "end_line": 73,
      "content_hash": "7e69998c1384df71cc94be64b7dc209911390c09",
      "content": "impl Display for ShouldCollect {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_74": {
      "name": "fmt",
      "type": "method",
      "start_line": 74,
      "end_line": 85,
      "content_hash": "40f68c245c5dbbe743e836e01ad3bff8518a24eb",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ShouldCollect::ToVec => write!(f, \".collect::<Result<Vec<_>, _>>()?\"),\n            ShouldCollect::ToObj => write!(f, \".collect_to_obj()?\"),\n            ShouldCollect::Try => write!(f, \"?\"),\n            ShouldCollect::No => write!(f, \"\"),\n            ShouldCollect::ToValue => write!(f, \".collect_to_value()\"),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Traversal_86": {
      "name": "Traversal",
      "type": "struct",
      "start_line": 86,
      "end_line": 99,
      "content_hash": "8404b6195b8a4e528ffa25bb562f3cd8ee723615",
      "content": "pub struct Traversal {\n    pub traversal_type: TraversalType,\n    pub source_step: Separator<SourceStep>,\n    pub steps: Vec<Separator<Step>>,\n    pub should_collect: ShouldCollect,\n    // Projection tracking\n    pub has_object_step: bool,\n    pub object_fields: Vec<String>,\n    pub has_spread: bool,\n    pub excluded_fields: Vec<String>,\n    pub nested_traversals: std::collections::HashMap<String, NestedTraversalInfo>,\n    pub is_reused_variable: bool,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_100": {
      "name": "Display",
      "type": "impl",
      "start_line": 100,
      "end_line": 100,
      "content_hash": "0d84205046d524c1ccdbecb45eef2372a7c3dbfa",
      "content": "impl Display for Traversal {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_101": {
      "name": "fmt",
      "type": "method",
      "start_line": 101,
      "end_line": 166,
      "content_hash": "be674b97b3eedaf659587e5e12b1adfd8092b692",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match &self.traversal_type {\n            TraversalType::FromSingle(var) => {\n                write!(\n                    f,\n                    \"G::from_iter(&db, &txn, std::iter::once({var}.clone()), &arena)\"\n                )?;\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n            }\n            TraversalType::FromIter(var) => {\n                write!(f, \"G::from_iter(&db, &txn, {var}.iter().cloned(), &arena)\")?;\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n            }\n            TraversalType::Ref => {\n                write!(f, \"G::new(&db, &txn, &arena)\")?;\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n            }\n\n            TraversalType::Mut => {\n                write!(f, \"G::new_mut(&db, &arena, &mut txn)\")?;\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n            }\n\n            TraversalType::Standalone => {\n                // No wrapper - just output the source step directly\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n            }\n\n            TraversalType::Empty => panic!(\"Should not be empty\"),\n            TraversalType::Update(properties) => {\n                write!(f, \"{{\")?;\n                write!(f, \"let update_tr = G::new(&db, &txn, &arena)\")?;\n                write!(f, \"{}\", self.source_step)?;\n                for step in &self.steps {\n                    write!(f, \"\\n{step}\")?;\n                }\n                write!(f, \"\\n    .collect::<Result<Vec<_>, _>>()?;\")?;\n                write!(\n                    f,\n                    \"G::new_mut_from_iter(&db, &mut txn, update_tr.iter().cloned(), &arena)\",\n                )?;\n                write!(f, \"\\n    .update({})\", write_properties_slice(properties))?;\n                write!(f, \"\\n    .collect_to_obj()?\")?;\n                write!(f, \"}}\")?;\n            }\n        }\n\n        // Just collect the results - no mapping injected here\n        write!(f, \"{}\", self.should_collect)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_167": {
      "name": "Default",
      "type": "impl",
      "start_line": 167,
      "end_line": 167,
      "content_hash": "d86487f86a6edb45d4a9724e1e9cc7bfe89672fe",
      "content": "impl Default for Traversal {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_168": {
      "name": "default",
      "type": "method",
      "start_line": 168,
      "end_line": 183,
      "content_hash": "8aeb79eec65ebad695a316b843ba51dcb05f4a2d",
      "content": "    fn default() -> Self {\n        Self {\n            traversal_type: TraversalType::Ref,\n            source_step: Separator::Empty(SourceStep::Empty),\n            steps: vec![],\n            should_collect: ShouldCollect::ToVec,\n            has_object_step: false,\n            object_fields: vec![],\n            has_spread: false,\n            excluded_fields: vec![],\n            nested_traversals: std::collections::HashMap::new(),\n            is_reused_variable: false,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Traversal_184": {
      "name": "Traversal",
      "type": "impl",
      "start_line": 184,
      "end_line": 186,
      "content_hash": "3b881e48b25b05cb95579eaf976444b186c187d8",
      "content": "impl Traversal {\n    /// Format only the steps (source_step + steps), without the G::from_iter/G::new prefix and without should_collect\n    /// This is used for nested traversals where we want to map before collecting",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_format_steps_only_187": {
      "name": "format_steps_only",
      "type": "method",
      "start_line": 187,
      "end_line": 198,
      "content_hash": "0b2c73735e9ba0b34653e2bc278c34b622baa88a",
      "content": "    pub fn format_steps_only(&self) -> String {\n        let mut result = String::new();\n        result.push_str(&format!(\"{}\", self.source_step));\n        for step in &self.steps {\n            result.push_str(&format!(\"\\n{}\", step));\n        }\n        result\n    }\n}\n\n/// Reserved properties that are accessed directly from struct fields\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ReservedProp_199": {
      "name": "ReservedProp",
      "type": "enum",
      "start_line": 199,
      "end_line": 211,
      "content_hash": "4db6c08fb6f0a525a00ffc362920eaefb3c21667",
      "content": "pub enum ReservedProp {\n    Id,\n    Label,\n    // Version,\n    // FromNode,\n    // ToNode,\n    // Deleted,\n    // Level,\n    // Distance,\n    // Data,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Step_212": {
      "name": "Step",
      "type": "enum",
      "start_line": 212,
      "end_line": 257,
      "content_hash": "d1b4a9eaaed797684008409c99479094a48d7e6a",
      "content": "pub enum Step {\n    // graph steps\n    Out(Out),\n    In(In),\n    OutE(OutE),\n    InE(InE),\n    FromN,\n    ToN,\n    FromV(FromV),\n    ToV(ToV),\n\n    // utils\n    Count,\n\n    Where(Where),\n    Range(Range),\n    OrderBy(OrderBy),\n    Dedup,\n\n    // bool ops\n    BoolOp(BoolOp),\n\n    // property\n    PropertyFetch(GenRef<String>),\n    ReservedPropertyAccess(ReservedProp),\n\n    // closure\n    // Closure(ClosureRemapping),\n\n    // shortest path\n    ShortestPath(ShortestPath),\n    ShortestPathDijkstras(ShortestPathDijkstras),\n    ShortestPathBFS(ShortestPathBFS),\n    ShortestPathAStar(ShortestPathAStar),\n\n    // search vector\n    SearchVector(SearchVectorStep),\n\n    GroupBy(GroupBy),\n\n    AggregateBy(AggregateBy),\n\n    // rerankers\n    RerankRRF(RerankRRF),\n    RerankMMR(RerankMMR),\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_258": {
      "name": "Display",
      "type": "impl",
      "start_line": 258,
      "end_line": 258,
      "content_hash": "0f2c481530c5b531b2120c8c17c581e0fc70488a",
      "content": "impl Display for Step {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_259": {
      "name": "fmt",
      "type": "method",
      "start_line": 259,
      "end_line": 301,
      "content_hash": "3e72caa6cc52a1e580cb8566c5aa60934bb0bff6",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Step::Count => write!(f, \"count_to_val()\"),\n            Step::Dedup => write!(f, \"dedup()\"),\n            Step::FromN => write!(f, \"from_n()\"),\n            Step::FromV(from_v) => write!(f, \"{from_v}\"),\n            Step::ToN => write!(f, \"to_n()\"),\n            Step::ToV(to_v) => write!(f, \"{to_v}\"),\n            Step::PropertyFetch(property) => write!(f, \"get_property({property})\"),\n            Step::ReservedPropertyAccess(prop) => match prop {\n                ReservedProp::Id => write!(f, \"map(|item| Ok(Value::from(uuid_str(item.id, &arena))))\"),\n                ReservedProp::Label => write!(f, \"map(|item| Ok(Value::from(item.label())))\"),\n                // ReservedProp::Version => write!(f, \"map(|item| Ok(Value::from(item.version)))\"),\n                // ReservedProp::FromNode => write!(f, \"map(|item| Ok(Value::from(uuid_str(item.from_node, &arena))))\"),\n                // ReservedProp::ToNode => write!(f, \"map(|item| Ok(Value::from(uuid_str(item.to_node, &arena))))\"),\n                // ReservedProp::Deleted => write!(f, \"map(|item| Ok(Value::from(item.deleted)))\"),\n                // ReservedProp::Level => write!(f, \"map(|item| Ok(Value::from(item.level)))\"),\n                // ReservedProp::Distance => write!(f, \"map(|item| Ok(item.distance.map(Value::from).unwrap_or(Value::Empty)))\"),\n                // ReservedProp::Data => write!(f, \"map(|item| Ok(Value::from(item.data)))\"),\n            },\n\n            Step::Out(out) => write!(f, \"{out}\"),\n            Step::In(in_) => write!(f, \"{in_}\"),\n            Step::OutE(out_e) => write!(f, \"{out_e}\"),\n            Step::InE(in_e) => write!(f, \"{in_e}\"),\n            Step::Where(where_) => write!(f, \"{where_}\"),\n            Step::Range(range) => write!(f, \"{range}\"),\n            Step::OrderBy(order_by) => write!(f, \"{order_by}\"),\n            Step::BoolOp(bool_op) => write!(f, \"{bool_op}\"),\n            Step::ShortestPath(shortest_path) => write!(f, \"{shortest_path}\"),\n            Step::ShortestPathDijkstras(shortest_path_dijkstras) => {\n                write!(f, \"{shortest_path_dijkstras}\")\n            }\n            Step::ShortestPathBFS(shortest_path_bfs) => write!(f, \"{shortest_path_bfs}\"),\n            Step::ShortestPathAStar(shortest_path_astar) => write!(f, \"{shortest_path_astar}\"),\n            Step::SearchVector(search_vector) => write!(f, \"{search_vector}\"),\n            Step::GroupBy(group_by) => write!(f, \"{group_by}\"),\n            Step::AggregateBy(aggregate_by) => write!(f, \"{aggregate_by}\"),\n            Step::RerankRRF(rerank_rrf) => write!(f, \"{rerank_rrf}\"),\n            Step::RerankMMR(rerank_mmr) => write!(f, \"{rerank_mmr}\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Debug_302": {
      "name": "Debug",
      "type": "impl",
      "start_line": 302,
      "end_line": 302,
      "content_hash": "0efd53eb31daeff9e9c3d41d9b747dea3b1cc181",
      "content": "impl Debug for Step {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_303": {
      "name": "fmt",
      "type": "method",
      "start_line": 303,
      "end_line": 334,
      "content_hash": "3e56e75bbb0fffec729afb51a974b6b33afa1b2d",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Step::Count => write!(f, \"Count\"),\n            Step::Dedup => write!(f, \"Dedup\"),\n            Step::FromN => write!(f, \"FromN\"),\n            Step::ToN => write!(f, \"ToN\"),\n            Step::PropertyFetch(property) => write!(f, \"get_property({property})\"),\n            Step::ReservedPropertyAccess(prop) => write!(f, \"ReservedProperty({:?})\", prop),\n            Step::FromV(_) => write!(f, \"FromV\"),\n            Step::ToV(_) => write!(f, \"ToV\"),\n            Step::Out(_) => write!(f, \"Out\"),\n            Step::In(_) => write!(f, \"In\"),\n            Step::OutE(_) => write!(f, \"OutE\"),\n            Step::InE(_) => write!(f, \"InE\"),\n            Step::Where(_) => write!(f, \"Where\"),\n            Step::Range(_) => write!(f, \"Range\"),\n            Step::OrderBy(_) => write!(f, \"OrderBy\"),\n            Step::BoolOp(_) => write!(f, \"Bool\"),\n            Step::ShortestPath(_) => write!(f, \"ShortestPath\"),\n            Step::ShortestPathDijkstras(_) => write!(f, \"ShortestPathDijkstras\"),\n            Step::ShortestPathBFS(_) => write!(f, \"ShortestPathBFS\"),\n            Step::ShortestPathAStar(_) => write!(f, \"ShortestPathAStar\"),\n            Step::SearchVector(_) => write!(f, \"SearchVector\"),\n            Step::GroupBy(_) => write!(f, \"GroupBy\"),\n            Step::AggregateBy(_) => write!(f, \"AggregateBy\"),\n            Step::RerankRRF(_) => write!(f, \"RerankRRF\"),\n            Step::RerankMMR(_) => write!(f, \"RerankMMR\"),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FromV_335": {
      "name": "FromV",
      "type": "struct",
      "start_line": 335,
      "end_line": 337,
      "content_hash": "e0ed8612cbb207b3d7329177bf13c2960c5019b7",
      "content": "pub struct FromV {\n    pub get_vector_data: bool,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_338": {
      "name": "Display",
      "type": "impl",
      "start_line": 338,
      "end_line": 338,
      "content_hash": "de7199daa512926708fdfc77b852987310c10261",
      "content": "impl Display for FromV {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_339": {
      "name": "fmt",
      "type": "method",
      "start_line": 339,
      "end_line": 344,
      "content_hash": "dc45c59bfe78a4a23fa08ad34f4242448aee4405",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"from_v({})\", self.get_vector_data)\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ToV_345": {
      "name": "ToV",
      "type": "struct",
      "start_line": 345,
      "end_line": 347,
      "content_hash": "b9104da385db72486c2cb24af3eef769711a3423",
      "content": "pub struct ToV {\n    pub get_vector_data: bool,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_348": {
      "name": "Display",
      "type": "impl",
      "start_line": 348,
      "end_line": 348,
      "content_hash": "6ed5bdb6d69d389c7ec23a649540c8c9bc0cf94e",
      "content": "impl Display for ToV {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_349": {
      "name": "fmt",
      "type": "method",
      "start_line": 349,
      "end_line": 354,
      "content_hash": "37a633294dd131d6e6d9e3dcb5deb4feb04c17aa",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"to_v({})\", self.get_vector_data)\n    }\n}\n\n#[derive(Clone, PartialEq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_EdgeType_355": {
      "name": "EdgeType",
      "type": "enum",
      "start_line": 355,
      "end_line": 359,
      "content_hash": "e3bd518523960d1199ebfff110094fda2784fecd",
      "content": "pub enum EdgeType {\n    Node,\n    Vec,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_360": {
      "name": "Display",
      "type": "impl",
      "start_line": 360,
      "end_line": 360,
      "content_hash": "4d7447164bd90213cf8ef2b97df73cf7007fecb0",
      "content": "impl Display for EdgeType {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_361": {
      "name": "fmt",
      "type": "method",
      "start_line": 361,
      "end_line": 369,
      "content_hash": "813b3765e3c45bdf1e4bce1ee9ee2fbb7bdaf488",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EdgeType::Node => write!(f, \"node\"),\n            EdgeType::Vec => write!(f, \"vec\"),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Out_370": {
      "name": "Out",
      "type": "struct",
      "start_line": 370,
      "end_line": 374,
      "content_hash": "69857b2a3970e752ecc93b4feb17cfac6246d577",
      "content": "pub struct Out {\n    pub label: GenRef<String>,\n    pub edge_type: EdgeType,\n    pub get_vector_data: bool,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_375": {
      "name": "Display",
      "type": "impl",
      "start_line": 375,
      "end_line": 375,
      "content_hash": "3a32796ae458e417ce17d9c963b0e6e51a4b6e01",
      "content": "impl Display for Out {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_376": {
      "name": "fmt",
      "type": "method",
      "start_line": 376,
      "end_line": 384,
      "content_hash": "a9b4a8c1ece29e5d155856494e235439438006ff",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.edge_type {\n            EdgeType::Node => write!(f, \"out_node({})\", self.label),\n            EdgeType::Vec => write!(f, \"out_vec({}, {})\", self.label, self.get_vector_data),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_In_385": {
      "name": "In",
      "type": "struct",
      "start_line": 385,
      "end_line": 389,
      "content_hash": "e09e884659e134a67dea98d16b759f4224f1ab11",
      "content": "pub struct In {\n    pub label: GenRef<String>,\n    pub edge_type: EdgeType,\n    pub get_vector_data: bool,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_390": {
      "name": "Display",
      "type": "impl",
      "start_line": 390,
      "end_line": 390,
      "content_hash": "aa10262635c21974c1a79780acba08c4500b2970",
      "content": "impl Display for In {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_391": {
      "name": "fmt",
      "type": "method",
      "start_line": 391,
      "end_line": 399,
      "content_hash": "d82e3a42f80a18209b4b4bcecd9f1feafc7d3337",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.edge_type {\n            EdgeType::Node => write!(f, \"in_node({})\", self.label),\n            EdgeType::Vec => write!(f, \"in_vec({}, {})\", self.label, self.get_vector_data),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OutE_400": {
      "name": "OutE",
      "type": "struct",
      "start_line": 400,
      "end_line": 402,
      "content_hash": "3cd95aded74b2c9301ba409df9c03db61f26dcf4",
      "content": "pub struct OutE {\n    pub label: GenRef<String>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_403": {
      "name": "Display",
      "type": "impl",
      "start_line": 403,
      "end_line": 403,
      "content_hash": "03dc0cd9c4ce795c84fe8cda8f550ca9e4969366",
      "content": "impl Display for OutE {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_404": {
      "name": "fmt",
      "type": "method",
      "start_line": 404,
      "end_line": 409,
      "content_hash": "aff5d8fd8eab66b1700d86a81e922fda00c189b4",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"out_e({})\", self.label)\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InE_410": {
      "name": "InE",
      "type": "struct",
      "start_line": 410,
      "end_line": 412,
      "content_hash": "1d181e66a34d6996df732af87bb2226360044fd9",
      "content": "pub struct InE {\n    pub label: GenRef<String>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_413": {
      "name": "Display",
      "type": "impl",
      "start_line": 413,
      "end_line": 413,
      "content_hash": "f34753cfdb3205ad1d29be9885a93b3eb47b9254",
      "content": "impl Display for InE {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_414": {
      "name": "fmt",
      "type": "method",
      "start_line": 414,
      "end_line": 419,
      "content_hash": "899b34560f054fd7debc7a495c3daeef594af242",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"in_e({})\", self.label)\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Where_420": {
      "name": "Where",
      "type": "enum",
      "start_line": 420,
      "end_line": 422,
      "content_hash": "7cb122c92ce8c96d70f5cc1f3720e051ae817c4c",
      "content": "pub enum Where {\n    Ref(WhereRef),\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_423": {
      "name": "Display",
      "type": "impl",
      "start_line": 423,
      "end_line": 423,
      "content_hash": "57914169bebae870e9741682967c257a605f99b8",
      "content": "impl Display for Where {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_424": {
      "name": "fmt",
      "type": "method",
      "start_line": 424,
      "end_line": 430,
      "content_hash": "c2d1967d906f70a01b333976df51052ae6a97fcb",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let Where::Ref(wr) = self;\n        write!(f, \"{wr}\")\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_WhereRef_431": {
      "name": "WhereRef",
      "type": "struct",
      "start_line": 431,
      "end_line": 433,
      "content_hash": "adeba7f2b37f9f722410768ea935481b37412e9e",
      "content": "pub struct WhereRef {\n    pub expr: BoExp,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_434": {
      "name": "Display",
      "type": "impl",
      "start_line": 434,
      "end_line": 434,
      "content_hash": "b1d186a159a12cfdb9e892e35413ed0c04c4b608",
      "content": "impl Display for WhereRef {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_435": {
      "name": "fmt",
      "type": "method",
      "start_line": 435,
      "end_line": 542,
      "content_hash": "b55f6f79773d1c36d941e73f85989b16eda5c84c",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Check if this is a simple property check that can be optimized\n        if let BoExp::Expr(traversal) = &self.expr\n            && let TraversalType::FromSingle(var) = &traversal.traversal_type\n        {\n            // Check if the variable is \"val\"\n            let is_val = matches!(var, GenRef::Std(s) | GenRef::Literal(s) if s == \"val\");\n\n            if is_val && traversal.steps.len() == 2 {\n                // Check if we have PropertyFetch or ReservedPropertyAccess followed by BoolOp\n                let mut prop: Option<&GenRef<String>> = None;\n                let mut reserved_prop: Option<&ReservedProp> = None;\n                let mut bool_op: Option<&BoolOp> = None;\n\n                for step in &traversal.steps {\n                    match step {\n                        Separator::Period(Step::PropertyFetch(p))\n                        | Separator::Newline(Step::PropertyFetch(p))\n                        | Separator::Empty(Step::PropertyFetch(p)) => prop = Some(p),\n                        Separator::Period(Step::ReservedPropertyAccess(rp))\n                        | Separator::Newline(Step::ReservedPropertyAccess(rp))\n                        | Separator::Empty(Step::ReservedPropertyAccess(rp)) => reserved_prop = Some(rp),\n                        Separator::Period(Step::BoolOp(op))\n                        | Separator::Newline(Step::BoolOp(op))\n                        | Separator::Empty(Step::BoolOp(op)) => bool_op = Some(op),\n                        _ => {}\n                    }\n                }\n\n                // Handle ReservedPropertyAccess with BoolOp - generate direct field access\n                if let (Some(reserved_prop), Some(bool_op)) = (reserved_prop, bool_op) {\n                    let value_expr = match reserved_prop {\n                        ReservedProp::Id => \"Value::Id(ID::from(val.id()))\".to_string(),\n                        ReservedProp::Label => \"Value::from(val.label())\".to_string(),\n                    };\n                    let bool_expr = match bool_op {\n                        BoolOp::Gt(gt) => format!(\"{} > {}\", value_expr, gt.right),\n                        BoolOp::Gte(gte) => format!(\"{} >= {}\", value_expr, gte.right),\n                        BoolOp::Lt(lt) => format!(\"{} < {}\", value_expr, lt.right),\n                        BoolOp::Lte(lte) => format!(\"{} <= {}\", value_expr, lte.right),\n                        BoolOp::Eq(eq) => format!(\"{} == {}\", value_expr, eq.right),\n                        BoolOp::Neq(neq) => format!(\"{} != {}\", value_expr, neq.right),\n                        BoolOp::Contains(contains) => format!(\"{}{}\", value_expr, contains),\n                        BoolOp::IsIn(is_in) => format!(\"{}{}\", value_expr, is_in),\n                        BoolOp::PropertyEq(_) | BoolOp::PropertyNeq(_) => {\n                            unreachable!(\"PropertyEq/PropertyNeq should not be used with reserved properties\")\n                        }\n                    };\n                    return write!(\n                        f,\n                        \"filter_ref(|val, txn|{{\n                if let Ok(val) = val {{\n                    Ok({})\n                }} else {{\n                    Ok(false)\n                }}\n            }})\",\n                        bool_expr\n                    );\n                }\n\n                // Handle PropertyFetch with BoolOp - use get_property\n                if let (Some(prop), Some(bool_op)) = (prop, bool_op) {\n                    let bool_expr = match bool_op {\n                        BoolOp::Gt(gt) => format!(\"{gt}\"),\n                        BoolOp::Gte(gte) => format!(\"{gte}\"),\n                        BoolOp::Lt(lt) => format!(\"{lt}\"),\n                        BoolOp::Lte(lte) => format!(\"{lte}\"),\n                        BoolOp::Eq(eq) => format!(\"{eq}\"),\n                        BoolOp::Neq(neq) => format!(\"{neq}\"),\n                        BoolOp::Contains(contains) => format!(\"v{contains}\"),\n                        BoolOp::IsIn(is_in) => format!(\"v{is_in}\"),\n                        BoolOp::PropertyEq(prop_eq) => format!(\"{prop_eq}\"),\n                        BoolOp::PropertyNeq(prop_neq) => format!(\"{prop_neq}\"),\n                    };\n                    return write!(\n                        f,\n                        \"filter_ref(|val, txn|{{\n                if let Ok(val) = val {{\n                    Ok(val\n                    .get_property({})\n                    .map_or(false, |v| {}))\n                }} else {{\n                    Ok(false)\n                }}\n            }})\",\n                        prop, bool_expr\n                    );\n                }\n            }\n        }\n\n        // Fall back to default (unoptimized) code generation\n        write!(\n            f,\n            \"filter_ref(|val, txn|{{\n                if let Ok(val) = val {{\n                    Ok({})\n                }} else {{\n                    Ok(false)\n                }}\n            }})\",\n            self.expr\n        )\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Range_543": {
      "name": "Range",
      "type": "struct",
      "start_line": 543,
      "end_line": 546,
      "content_hash": "83c0a7d53289537a299d0f9afe4b67d3741fa0a5",
      "content": "pub struct Range {\n    pub start: GeneratedValue,\n    pub end: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_547": {
      "name": "Display",
      "type": "impl",
      "start_line": 547,
      "end_line": 547,
      "content_hash": "17118237c1d718d7417bc516a89290721ee51c68",
      "content": "impl Display for Range {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_548": {
      "name": "fmt",
      "type": "method",
      "start_line": 548,
      "end_line": 553,
      "content_hash": "6729f866c62ac830b47ef78f012a9f4a8fd24bc2",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"range({}, {})\", self.start, self.end)\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OrderBy_554": {
      "name": "OrderBy",
      "type": "struct",
      "start_line": 554,
      "end_line": 557,
      "content_hash": "55c91b2a3617a1c5b757339e99a384d6dae21c7e",
      "content": "pub struct OrderBy {\n    pub property: GenRef<String>,\n    pub order: Order,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_558": {
      "name": "Display",
      "type": "impl",
      "start_line": 558,
      "end_line": 558,
      "content_hash": "eb74a56330399e611e93b4b923cc9519364269d4",
      "content": "impl Display for OrderBy {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_559": {
      "name": "fmt",
      "type": "method",
      "start_line": 559,
      "end_line": 567,
      "content_hash": "b3448baecd45ae7fd6b53d22cd4e1a6f461ef12a",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.order {\n            Order::Asc => write!(f, \"order_by_asc({})\", self.property),\n            Order::Desc => write!(f, \"order_by_desc({})\", self.property),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GroupBy_568": {
      "name": "GroupBy",
      "type": "struct",
      "start_line": 568,
      "end_line": 571,
      "content_hash": "570fc020fe8e7fde4314cc9969840e40e88cd6d9",
      "content": "pub struct GroupBy {\n    pub should_count: bool,\n    pub properties: Vec<GenRef<String>>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_572": {
      "name": "Display",
      "type": "impl",
      "start_line": 572,
      "end_line": 572,
      "content_hash": "1995d159dfbf09b01a1c467bf9e426140c713b57",
      "content": "impl Display for GroupBy {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_573": {
      "name": "fmt",
      "type": "method",
      "start_line": 573,
      "end_line": 587,
      "content_hash": "3567057d9ad1ff13c634673a183f54fc518b6299",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"group_by(&[{}], {})\",\n            self.properties\n                .iter()\n                .map(|s| s.to_string())\n                .collect::<Vec<_>>()\n                .join(\",\"),\n            self.should_count\n        )\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AggregateBy_588": {
      "name": "AggregateBy",
      "type": "struct",
      "start_line": 588,
      "end_line": 591,
      "content_hash": "5218cf9c45d49e283bb70b889ffca04dd8415668",
      "content": "pub struct AggregateBy {\n    pub should_count: bool,\n    pub properties: Vec<GenRef<String>>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_592": {
      "name": "Display",
      "type": "impl",
      "start_line": 592,
      "end_line": 592,
      "content_hash": "e00159730cd769c912291bcc75e27e1e42669b7d",
      "content": "impl Display for AggregateBy {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_593": {
      "name": "fmt",
      "type": "method",
      "start_line": 593,
      "end_line": 607,
      "content_hash": "9ac40c61e36d32abf4f9dea039eb028bf80d6e02",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"aggregate_by(&[{}], {})\",\n            self.properties\n                .iter()\n                .map(|s| s.to_string())\n                .collect::<Vec<_>>()\n                .join(\",\"),\n            self.should_count\n        )\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ShortestPath_608": {
      "name": "ShortestPath",
      "type": "struct",
      "start_line": 608,
      "end_line": 615,
      "content_hash": "973fc4e7f42614b4d041aa8aaf59faa61d5b8d2b",
      "content": "pub struct ShortestPath {\n    pub label: Option<GenRef<String>>,\n    pub from: Option<GenRef<String>>,\n    pub to: Option<GenRef<String>>,\n    pub algorithm: Option<PathAlgorithm>,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_WeightCalculation_616": {
      "name": "WeightCalculation",
      "type": "enum",
      "start_line": 616,
      "end_line": 625,
      "content_hash": "7335db9af35511378304582305c341110fdf1690",
      "content": "pub enum WeightCalculation {\n    /// Simple property access: edge.get_property(\"weight\")\n    Property(GenRef<String>),\n    /// Mathematical expression: calculated from edge/source/dest properties\n    Expression(String),\n    /// Default weight of 1.0\n    Default,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ShortestPathDijkstras_626": {
      "name": "ShortestPathDijkstras",
      "type": "struct",
      "start_line": 626,
      "end_line": 633,
      "content_hash": "6c84ed3177b37dedbbf4bdbaf16c278f9a9efe07",
      "content": "pub struct ShortestPathDijkstras {\n    pub label: Option<GenRef<String>>,\n    pub from: Option<GenRef<String>>,\n    pub to: Option<GenRef<String>>,\n    pub weight_calculation: WeightCalculation,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ShortestPathBFS_634": {
      "name": "ShortestPathBFS",
      "type": "struct",
      "start_line": 634,
      "end_line": 640,
      "content_hash": "2b616c6e764e7717e5b8f841fad38b92d6e27c70",
      "content": "pub struct ShortestPathBFS {\n    pub label: Option<GenRef<String>>,\n    pub from: Option<GenRef<String>>,\n    pub to: Option<GenRef<String>>,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ShortestPathAStar_641": {
      "name": "ShortestPathAStar",
      "type": "struct",
      "start_line": 641,
      "end_line": 649,
      "content_hash": "824755c6f78ff0e879eab99be9d4b0201f1f0e80",
      "content": "pub struct ShortestPathAStar {\n    pub label: Option<GenRef<String>>,\n    pub from: Option<GenRef<String>>,\n    pub to: Option<GenRef<String>>,\n    pub weight_calculation: WeightCalculation,\n    pub heuristic_property: GenRef<String>,\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_PathAlgorithm_650": {
      "name": "PathAlgorithm",
      "type": "enum",
      "start_line": 650,
      "end_line": 653,
      "content_hash": "77ea03837285ff7c04b1f1b65b3759b5042c0ddf",
      "content": "pub enum PathAlgorithm {\n    BFS,\n    Dijkstra,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_654": {
      "name": "Display",
      "type": "impl",
      "start_line": 654,
      "end_line": 654,
      "content_hash": "f7f9fa2e68496f4bd53889dbdab2fc155e982400",
      "content": "impl Display for ShortestPath {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_655": {
      "name": "fmt",
      "type": "method",
      "start_line": 655,
      "end_line": 706,
      "content_hash": "0ef72612708655cd07c77ed43abc6d61da1ba88e",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match &self.algorithm {\n            Some(PathAlgorithm::Dijkstra) => {\n                write!(\n                    f,\n                    \"shortest_path_with_algorithm({}, {}, {}, PathAlgorithm::Dijkstra)\",\n                    self.label\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n                    self.from\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n                    self.to\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n                )\n            }\n            Some(PathAlgorithm::BFS) => {\n                write!(\n                    f,\n                    \"shortest_path_with_algorithm({}, {}, {}, PathAlgorithm::BFS)\",\n                    self.label\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n                    self.from\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n                    self.to\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n                )\n            }\n            None => {\n                // Default to BFS for backward compatibility\n                write!(\n                    f,\n                    \"shortest_path({}, {}, {})\",\n                    self.label\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n                    self.from\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n                    self.to\n                        .as_ref()\n                        .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n                )\n            }\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_707": {
      "name": "Display",
      "type": "impl",
      "start_line": 707,
      "end_line": 707,
      "content_hash": "705961a70a1ea15556535ab03e8db600337ef83b",
      "content": "impl Display for ShortestPathDijkstras {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_708": {
      "name": "fmt",
      "type": "method",
      "start_line": 708,
      "end_line": 747,
      "content_hash": "b3574660a2ef7eaf46db3f0ace5a9217fd8872a5",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"shortest_path_with_algorithm({}, {}, {}, PathAlgorithm::Dijkstra, \",\n            self.label\n                .as_ref()\n                .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n            self.from\n                .as_ref()\n                .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n            self.to\n                .as_ref()\n                .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n        )?;\n\n        // Generate the weight calculation closure\n        match &self.weight_calculation {\n            WeightCalculation::Property(prop) => {\n                write!(\n                    f,\n                    \"|edge, _src_node, _dst_node| -> Result<f64, GraphError> {{ Ok(edge.get_property({})?.as_f64()?) }}\",\n                    prop\n                )?;\n            }\n            WeightCalculation::Expression(expr) => {\n                write!(\n                    f,\n                    \"|edge, src_node, dst_node| -> Result<f64, GraphError> {{ Ok({}) }}\",\n                    expr\n                )?;\n            }\n            WeightCalculation::Default => {\n                write!(f, \"helix_db::helix_engine::traversal_core::ops::util::paths::default_weight_fn\")?;\n            }\n        }\n\n        write!(f, \")\")\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_748": {
      "name": "Display",
      "type": "impl",
      "start_line": 748,
      "end_line": 748,
      "content_hash": "cced2b79673f19fd5601458aa0cc49f491e73b8a",
      "content": "impl Display for ShortestPathBFS {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_749": {
      "name": "fmt",
      "type": "method",
      "start_line": 749,
      "end_line": 765,
      "content_hash": "9e1de7b30d17e563cc3fac9fa6630072080b7b7e",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"shortest_path_with_algorithm({}, {}, {}, PathAlgorithm::BFS, helix_db::helix_engine::traversal_core::ops::util::paths::default_weight_fn)\",\n            self.label\n                .as_ref()\n                .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n            self.from\n                .as_ref()\n                .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n            self.to\n                .as_ref()\n                .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n        )\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_766": {
      "name": "Display",
      "type": "impl",
      "start_line": 766,
      "end_line": 766,
      "content_hash": "bbb51a3ad84acb8718425907b8a0ff719dc20fd4",
      "content": "impl Display for ShortestPathAStar {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_767": {
      "name": "fmt",
      "type": "method",
      "start_line": 767,
      "end_line": 814,
      "content_hash": "18a68d7c3dea2e9e7c12165480b4127816e0be64",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"shortest_path_astar({}, {}, {}, \",\n            self.label\n                .as_ref()\n                .map_or(\"None\".to_string(), |label| format!(\"Some({label})\")),\n            self.from\n                .as_ref()\n                .map_or(\"None\".to_string(), |from| format!(\"Some(&{from})\")),\n            self.to\n                .as_ref()\n                .map_or(\"None\".to_string(), |to| format!(\"Some(&{to})\"))\n        )?;\n\n        // Generate the weight calculation closure\n        match &self.weight_calculation {\n            WeightCalculation::Property(prop) => {\n                write!(\n                    f,\n                    \"|edge, _src_node, _dst_node| -> Result<f64, GraphError> {{ Ok(edge.get_property({})?.as_f64()?) }}, \",\n                    prop\n                )?;\n            }\n            WeightCalculation::Expression(expr) => {\n                write!(\n                    f,\n                    \"|edge, src_node, dst_node| -> Result<f64, GraphError> {{ Ok({}) }}, \",\n                    expr\n                )?;\n            }\n            WeightCalculation::Default => {\n                write!(f, \"helix_db::helix_engine::traversal_core::ops::util::paths::default_weight_fn, \")?;\n            }\n        }\n\n        // Generate the heuristic function closure\n        write!(\n            f,\n            \"|node| helix_db::helix_engine::traversal_core::ops::util::paths::property_heuristic(node, {})\",\n            self.heuristic_property\n        )?;\n\n        write!(f, \")\")\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchVectorStep_815": {
      "name": "SearchVectorStep",
      "type": "struct",
      "start_line": 815,
      "end_line": 818,
      "content_hash": "b07e893aa28d0b7cb00295e165497848a03e9120",
      "content": "pub struct SearchVectorStep {\n    pub vec: VecData,\n    pub k: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_819": {
      "name": "Display",
      "type": "impl",
      "start_line": 819,
      "end_line": 819,
      "content_hash": "aeffe4fc2b820eb4ba3da1113ed8d960b41b0bb1",
      "content": "impl Display for SearchVectorStep {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_820": {
      "name": "fmt",
      "type": "method",
      "start_line": 820,
      "end_line": 825,
      "content_hash": "56eaf8f0350cce0285cbc1afe44ff7610aaed77b",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"brute_force_search_v({}, {})\", self.vec, self.k)\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_RerankRRF_826": {
      "name": "RerankRRF",
      "type": "struct",
      "start_line": 826,
      "end_line": 828,
      "content_hash": "60de623805f483fb26f5e5f56d9098feba1fd9ad",
      "content": "pub struct RerankRRF {\n    pub k: Option<GeneratedValue>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_829": {
      "name": "Display",
      "type": "impl",
      "start_line": 829,
      "end_line": 829,
      "content_hash": "59eb2672b72781bcda9e8a3f379b05fe1a86ba1c",
      "content": "impl Display for RerankRRF {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_830": {
      "name": "fmt",
      "type": "method",
      "start_line": 830,
      "end_line": 838,
      "content_hash": "c91efee3d6259b742cc1f289d355eb4fec3a9271",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match &self.k {\n            Some(k) => write!(f, \"rerank(RRFReranker::with_k({k} as f64).unwrap(), None)\"),\n            None => write!(f, \"rerank(RRFReranker::new(), None)\"),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_MMRDistanceMethod_839": {
      "name": "MMRDistanceMethod",
      "type": "enum",
      "start_line": 839,
      "end_line": 844,
      "content_hash": "fbe851ee5da218cde8d0dc23e69fd925580cf0ea",
      "content": "pub enum MMRDistanceMethod {\n    Cosine,\n    Euclidean,\n    DotProduct,\n    Identifier(String),\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_845": {
      "name": "Display",
      "type": "impl",
      "start_line": 845,
      "end_line": 845,
      "content_hash": "d608073281ebe90fabc933f63aa1be24c9b97b2c",
      "content": "impl Display for MMRDistanceMethod {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_846": {
      "name": "fmt",
      "type": "method",
      "start_line": 846,
      "end_line": 856,
      "content_hash": "6e041ade4b39cc8b6489a43b12085b0f2bb8dc3b",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            MMRDistanceMethod::Cosine => write!(f, \"DistanceMethod::Cosine\"),\n            MMRDistanceMethod::Euclidean => write!(f, \"DistanceMethod::Euclidean\"),\n            MMRDistanceMethod::DotProduct => write!(f, \"DistanceMethod::DotProduct\"),\n            MMRDistanceMethod::Identifier(id) => write!(f, \"match {id}.as_str() {{ \\\"cosine\\\" => DistanceMethod::Cosine, \\\"euclidean\\\" => DistanceMethod::Euclidean, \\\"dotproduct\\\" => DistanceMethod::DotProduct, _ => DistanceMethod::Cosine }}\"),\n        }\n    }\n}\n\n#[derive(Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_RerankMMR_857": {
      "name": "RerankMMR",
      "type": "struct",
      "start_line": 857,
      "end_line": 860,
      "content_hash": "09219e82471607f75b139870102d76c90b79841b",
      "content": "pub struct RerankMMR {\n    pub lambda: Option<GeneratedValue>,\n    pub distance: Option<MMRDistanceMethod>,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_861": {
      "name": "Display",
      "type": "impl",
      "start_line": 861,
      "end_line": 861,
      "content_hash": "0a7a63900f86c41afe128979fb2c709ad220cfef",
      "content": "impl Display for RerankMMR {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_862": {
      "name": "fmt",
      "type": "method",
      "start_line": 862,
      "end_line": 869,
      "content_hash": "d7e84d8a5e551ef93b3f2222cae531e9eb92557a",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let lambda = self.lambda.as_ref().map_or_else(|| \"0.7\".to_string(), |l| l.to_string());\n        match &self.distance {\n            Some(dist) => write!(f, \"rerank(MMRReranker::with_distance({lambda}, {dist}).unwrap(), None)\"),\n            None => write!(f, \"rerank(MMRReranker::new({lambda}).unwrap(), None)\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}