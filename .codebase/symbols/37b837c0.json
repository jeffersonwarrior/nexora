{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/tests/project_tests.rs",
  "file_hash": "af195f556e8fd74d201c826076f9420e49980852",
  "updated_at": "2025-12-26T17:34:24.292266",
  "symbols": {
    "function_setup_test_project_8": {
      "name": "setup_test_project",
      "type": "function",
      "start_line": 8,
      "end_line": 25,
      "content_hash": "77f98fa25de1cf2aae627862addbaa3680a553bf",
      "content": "fn setup_test_project() -> (TempDir, PathBuf) {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    (temp_dir, project_path)\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_in_root_directory_26": {
      "name": "test_find_project_root_in_root_directory",
      "type": "function",
      "start_line": 26,
      "end_line": 34,
      "content_hash": "15c2d6be5aefd800c21d832ff2a950a3d5f2275d",
      "content": "fn test_find_project_root_in_root_directory() {\n    let (_temp_dir, project_path) = setup_test_project();\n\n    let result = ProjectContext::find_and_load(Some(&project_path));\n    assert!(result.is_ok(), \"Should find project root\");\n    assert_eq!(result.unwrap().root, project_path);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_in_subdirectory_35": {
      "name": "test_find_project_root_in_subdirectory",
      "type": "function",
      "start_line": 35,
      "end_line": 47,
      "content_hash": "048413a933ef5f3981d49089e0f3ccc7d54acbde",
      "content": "fn test_find_project_root_in_subdirectory() {\n    let (_temp_dir, project_path) = setup_test_project();\n\n    // Create a subdirectory\n    let sub_dir = project_path.join(\"src/queries\");\n    fs::create_dir_all(&sub_dir).expect(\"Failed to create subdirectory\");\n\n    let result = ProjectContext::find_and_load(Some(&sub_dir));\n    assert!(result.is_ok(), \"Should find project root from subdirectory\");\n    assert_eq!(result.unwrap().root, project_path);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_in_nested_subdirectory_48": {
      "name": "test_find_project_root_in_nested_subdirectory",
      "type": "function",
      "start_line": 48,
      "end_line": 63,
      "content_hash": "a0cfdeefd2c1edc984cf0b695a85b7ae399712a8",
      "content": "fn test_find_project_root_in_nested_subdirectory() {\n    let (_temp_dir, project_path) = setup_test_project();\n\n    // Create deeply nested directory\n    let nested_dir = project_path.join(\"a/b/c/d/e\");\n    fs::create_dir_all(&nested_dir).expect(\"Failed to create nested directory\");\n\n    let result = ProjectContext::find_and_load(Some(&nested_dir));\n    assert!(\n        result.is_ok(),\n        \"Should find project root from deeply nested directory\"\n    );\n    assert_eq!(result.unwrap().root, project_path);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_fails_without_config_64": {
      "name": "test_find_project_root_fails_without_config",
      "type": "function",
      "start_line": 64,
      "end_line": 77,
      "content_hash": "81fb7531b43d581d2468628a1d43b9f91747a370",
      "content": "fn test_find_project_root_fails_without_config() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = ProjectContext::find_and_load(Some(&project_path));\n    assert!(result.is_err(), \"Should fail when no helix.toml exists\");\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"not found\"),\n        \"Error should mention config not found\"\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_detects_v1_config_78": {
      "name": "test_find_project_root_detects_v1_config",
      "type": "function",
      "start_line": 78,
      "end_line": 99,
      "content_hash": "70ad6979c6d42f2a2336e9794603996b1484893f",
      "content": "fn test_find_project_root_detects_v1_config() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create v1 config file\n    let v1_config_path = project_path.join(\"config.hx.json\");\n    fs::write(&v1_config_path, \"{}\").expect(\"Failed to create v1 config\");\n\n    let result = ProjectContext::find_and_load(Some(&project_path));\n    assert!(result.is_err(), \"Should fail on v1 config\");\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"v1\"),\n        \"Error should mention v1 configuration\"\n    );\n    assert!(\n        error_msg.contains(\"migrate\"),\n        \"Error should suggest migration\"\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_find_and_load_100": {
      "name": "test_project_context_find_and_load",
      "type": "function",
      "start_line": 100,
      "end_line": 111,
      "content_hash": "bb36dcf0824fd68e58798c31e470ab723dfdc878",
      "content": "fn test_project_context_find_and_load() {\n    let (_temp_dir, project_path) = setup_test_project();\n\n    let result = ProjectContext::find_and_load(Some(&project_path));\n    assert!(result.is_ok(), \"Should load project context\");\n\n    let context = result.unwrap();\n    assert_eq!(context.root, project_path);\n    assert_eq!(context.helix_dir, project_path.join(\".helix\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_instance_workspace_112": {
      "name": "test_project_context_instance_workspace",
      "type": "function",
      "start_line": 112,
      "end_line": 120,
      "content_hash": "5f53168d47b0486caf299f4d8e2bcd2f1c784379",
      "content": "fn test_project_context_instance_workspace() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let workspace = context.instance_workspace(\"dev\");\n    assert_eq!(workspace, project_path.join(\".helix/dev\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_volumes_dir_121": {
      "name": "test_project_context_volumes_dir",
      "type": "function",
      "start_line": 121,
      "end_line": 129,
      "content_hash": "3c3fbfd3fd8e561d1707c8bbe8ded428b2a4f5eb",
      "content": "fn test_project_context_volumes_dir() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let volumes_dir = context.volumes_dir();\n    assert_eq!(volumes_dir, project_path.join(\".helix/.volumes\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_instance_volume_130": {
      "name": "test_project_context_instance_volume",
      "type": "function",
      "start_line": 130,
      "end_line": 138,
      "content_hash": "7c552bfe375c8763708f7e761df070f7e5a7388b",
      "content": "fn test_project_context_instance_volume() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let volume = context.instance_volume(\"production\");\n    assert_eq!(volume, project_path.join(\".helix/.volumes/production\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_docker_compose_path_139": {
      "name": "test_project_context_docker_compose_path",
      "type": "function",
      "start_line": 139,
      "end_line": 150,
      "content_hash": "3791b0d9802d2bd9e3bf8a2a8d762192d1217f5c",
      "content": "fn test_project_context_docker_compose_path() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let compose_path = context.docker_compose_path(\"staging\");\n    assert_eq!(\n        compose_path,\n        project_path.join(\".helix/staging/docker-compose.yml\")\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_dockerfile_path_151": {
      "name": "test_project_context_dockerfile_path",
      "type": "function",
      "start_line": 151,
      "end_line": 159,
      "content_hash": "bece7e779eb39bfb0383aa0c034cd8150e8f8722",
      "content": "fn test_project_context_dockerfile_path() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let dockerfile_path = context.dockerfile_path(\"dev\");\n    assert_eq!(dockerfile_path, project_path.join(\".helix/dev/Dockerfile\"));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_container_dir_160": {
      "name": "test_project_context_container_dir",
      "type": "function",
      "start_line": 160,
      "end_line": 171,
      "content_hash": "69ebb43e87c144d4da21edad0fac2476239989c7",
      "content": "fn test_project_context_container_dir() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    let container_dir = context.container_dir(\"dev\");\n    assert_eq!(\n        container_dir,\n        project_path.join(\".helix/dev/helix-container\")\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_ensure_instance_dirs_172": {
      "name": "test_project_context_ensure_instance_dirs",
      "type": "function",
      "start_line": 172,
      "end_line": 197,
      "content_hash": "cf2f7bac52af025f57cec6fb27a369eb94f8c28b",
      "content": "fn test_project_context_ensure_instance_dirs() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    // Directories should not exist initially\n    let workspace = context.instance_workspace(\"test-instance\");\n    let volume = context.instance_volume(\"test-instance\");\n    let container = context.container_dir(\"test-instance\");\n\n    assert!(!workspace.exists(), \"Workspace should not exist initially\");\n    assert!(!volume.exists(), \"Volume should not exist initially\");\n    assert!(!container.exists(), \"Container dir should not exist initially\");\n\n    let result = context.ensure_instance_dirs(\"test-instance\");\n    assert!(result.is_ok(), \"Should create instance directories\");\n\n    // Directories should now exist\n    assert!(workspace.exists(), \"Workspace should be created\");\n    assert!(workspace.is_dir(), \"Workspace should be a directory\");\n    assert!(volume.exists(), \"Volume should be created\");\n    assert!(volume.is_dir(), \"Volume should be a directory\");\n    assert!(container.exists(), \"Container dir should be created\");\n    assert!(container.is_dir(), \"Container dir should be a directory\");\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_ensure_instance_dirs_idempotent_198": {
      "name": "test_project_context_ensure_instance_dirs_idempotent",
      "type": "function",
      "start_line": 198,
      "end_line": 211,
      "content_hash": "7a1660eca3a0b85934425a500e598ec3865c50fc",
      "content": "fn test_project_context_ensure_instance_dirs_idempotent() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    // Create directories first time\n    let result1 = context.ensure_instance_dirs(\"test-instance\");\n    assert!(result1.is_ok(), \"First call should succeed\");\n\n    // Create directories second time (should not fail)\n    let result2 = context.ensure_instance_dirs(\"test-instance\");\n    assert!(result2.is_ok(), \"Second call should be idempotent\");\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_helix_cache_dir_creates_directory_212": {
      "name": "test_get_helix_cache_dir_creates_directory",
      "type": "function",
      "start_line": 212,
      "end_line": 229,
      "content_hash": "a89bb7dd84dcdc6f9d7b41d55b15495ddc4d5e8d",
      "content": "fn test_get_helix_cache_dir_creates_directory() {\n    // This test might affect the user's actual home directory,\n    // so we'll just verify it doesn't error and returns a path\n    let result = get_helix_cache_dir();\n    assert!(result.is_ok(), \"Should get helix cache directory\");\n\n    let cache_dir = result.unwrap();\n    assert!(\n        cache_dir.exists(),\n        \"Cache directory should exist after calling get_helix_cache_dir\"\n    );\n    assert!(\n        cache_dir.ends_with(\".helix\"),\n        \"Cache directory should end with .helix\"\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_with_custom_queries_path_230": {
      "name": "test_project_context_with_custom_queries_path",
      "type": "function",
      "start_line": 230,
      "end_line": 254,
      "content_hash": "8070332b80441f5fda1ed49c5fa254766cf0de58",
      "content": "fn test_project_context_with_custom_queries_path() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create config with custom queries path\n    let mut config = HelixConfig::default_config(\"test-project\");\n    config.project.queries = PathBuf::from(\"custom/queries\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    let result = ProjectContext::find_and_load(Some(&project_path));\n    assert!(result.is_ok(), \"Should load project with custom queries path\");\n\n    let context = result.unwrap();\n    assert_eq!(\n        context.config.project.queries,\n        PathBuf::from(\"custom/queries\")\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_project_context_multiple_instances_255": {
      "name": "test_project_context_multiple_instances",
      "type": "function",
      "start_line": 255,
      "end_line": 291,
      "content_hash": "79bcc58e7123a9251a06208feb52e4203e6498fc",
      "content": "fn test_project_context_multiple_instances() {\n    let (_temp_dir, project_path) = setup_test_project();\n    let context = ProjectContext::find_and_load(Some(&project_path)).unwrap();\n\n    // Create multiple instances\n    let instances = vec![\"dev\", \"staging\", \"production\"];\n    for instance in &instances {\n        let result = context.ensure_instance_dirs(instance);\n        assert!(\n            result.is_ok(),\n            \"Should create directories for instance {}\",\n            instance\n        );\n    }\n\n    // Verify all instances have their own directories\n    for instance in &instances {\n        let workspace = context.instance_workspace(instance);\n        assert!(\n            workspace.exists(),\n            \"Workspace for {} should exist\",\n            instance\n        );\n\n        let volume = context.instance_volume(instance);\n        assert!(volume.exists(), \"Volume for {} should exist\", instance);\n\n        let container = context.container_dir(instance);\n        assert!(\n            container.exists(),\n            \"Container dir for {} should exist\",\n            instance\n        );\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_find_project_root_stops_at_filesystem_root_292": {
      "name": "test_find_project_root_stops_at_filesystem_root",
      "type": "function",
      "start_line": 292,
      "end_line": 301,
      "content_hash": "4dc9b7dad6394f8ba00952950f07df76bd4f090d",
      "content": "fn test_find_project_root_stops_at_filesystem_root() {\n    // This test verifies we don't search infinitely\n    // Start from a directory that definitely won't have helix.toml\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let deep_path = temp_dir.path().join(\"a/b/c/d/e/f/g/h/i/j\");\n    fs::create_dir_all(&deep_path).expect(\"Failed to create deep path\");\n\n    let result = ProjectContext::find_and_load(Some(&deep_path));\n    assert!(result.is_err(), \"Should fail after reaching filesystem root\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}