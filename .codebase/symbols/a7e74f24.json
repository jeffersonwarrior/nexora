{
  "file_path": "/work/external-deps/claude-swarm/dist/state/manager.js",
  "file_hash": "8d878e81c14a8d106e2218b3a430894238d794bf",
  "updated_at": "2025-12-26T17:34:20.462436",
  "symbols": {
    "class_StateManager_21": {
      "name": "StateManager",
      "type": "class",
      "start_line": 21,
      "end_line": 306,
      "content_hash": "b9b5c8eab19a05f733a76b9184b8fb21a7a6f9f6",
      "content": "export class StateManager {\n    projectDir;\n    stateFile;\n    progressFile;\n    initScriptFile;\n    featureListFile;\n    constructor(projectDir) {\n        this.projectDir = projectDir;\n        // Ensure .claude directory exists\n        const claudeDir = path.join(projectDir, \".claude\", \"orchestrator\");\n        if (!fs.existsSync(claudeDir)) {\n            fs.mkdirSync(claudeDir, { recursive: true });\n        }\n        this.stateFile = path.join(claudeDir, \"state.json\");\n        this.progressFile = path.join(projectDir, \"claude-progress.txt\");\n        this.initScriptFile = path.join(projectDir, \"init.sh\");\n        this.featureListFile = path.join(claudeDir, \"feature_list.json\");\n    }\n    /**\n     * Load state from disk with validation\n     */\n    load() {\n        if (!fs.existsSync(this.stateFile)) {\n            return null;\n        }\n        try {\n            const data = fs.readFileSync(this.stateFile, \"utf-8\");\n            const parsed = JSON.parse(data);\n            // Validate against schema\n            const validated = OrchestratorStateSchema.parse(parsed);\n            return validated;\n        }\n        catch (error) {\n            // If validation fails, the file is corrupted or tampered with\n            console.error(\"Error loading state (file may be corrupted):\", error);\n            throw new Error(\"State file is corrupted or invalid. Use orchestrator_reset to start fresh.\");\n        }\n    }\n    /**\n     * Save state to disk using atomic write\n     */\n    save(state) {\n        state.lastUpdated = new Date().toISOString();\n        // Rotate log if too large\n        if (state.progressLog.length > MAX_LOG_ENTRIES) {\n            state.progressLog = state.progressLog.slice(-MAX_LOG_ENTRIES);\n        }\n        // Atomic write: write to temp file, then rename\n        const tempFile = `${this.stateFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, JSON.stringify(state, null, 2));\n            fs.renameSync(tempFile, this.stateFile);\n        }\n        catch (error) {\n            // Clean up temp file if rename failed\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n        this.writeFeatureList(state);\n    }\n    /**\n     * Clear all state\n     */\n    clear() {\n        const filesToRemove = [\n            this.stateFile,\n            this.progressFile,\n            this.featureListFile,\n        ];\n        for (const file of filesToRemove) {\n            if (fs.existsSync(file)) {\n                try {\n                    fs.unlinkSync(file);\n                }\n                catch {\n                    // Ignore errors during cleanup\n                }\n            }\n        }\n    }\n    /**\n     * Write the human-readable progress file (notebook pattern)\n     * This file is designed to be easily readable by Claude after compaction\n     */\n    writeProgressFile() {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (!state)\n            return;\n        const completed = state.features.filter((f) => f.status === \"completed\");\n        const failed = state.features.filter((f) => f.status === \"failed\");\n        const inProgress = state.features.filter((f) => f.status === \"in_progress\");\n        const pending = state.features.filter((f) => f.status === \"pending\");\n        let content = `# Claude Orchestrator Progress Log\n# ===============================\n# Project: ${sanitizeOutput(state.projectDir, 200)}\n# Started: ${state.startTime}\n# Last Updated: ${state.lastUpdated}\n# Status: ${state.status}\n\n## Summary\n- Total Features: ${state.features.length}\n- Completed: ${completed.length}\n- In Progress: ${inProgress.length}\n- Pending: ${pending.length}\n- Failed: ${failed.length}\n\n## Task Description\n${sanitizeOutput(state.taskDescription, 2000)}\n\n## Feature Status\n`;\n        for (const feature of state.features) {\n            const statusIcon = feature.status === \"completed\"\n                ? \"\u2705\"\n                : feature.status === \"failed\"\n                    ? \"\u274c\"\n                    : feature.status === \"in_progress\"\n                        ? \"\ud83d\udd04\"\n                        : \"\u23f3\";\n            content += `${statusIcon} [${feature.status.toUpperCase()}] ${feature.id}: ${sanitizeOutput(feature.description, 200)}\\n`;\n            if (feature.lastError) {\n                content += `   Error: ${sanitizeOutput(feature.lastError, 200)}\\n`;\n            }\n            if (feature.notes) {\n                content += `   Notes: ${sanitizeOutput(feature.notes, 200)}\\n`;\n            }\n        }\n        content += `\\n## Progress Log (last ${Math.min(state.progressLog.length, 100)} entries)\\n`;\n        const recentLogs = state.progressLog.slice(-100);\n        for (const log of recentLogs) {\n            content += `${sanitizeOutput(log, 500)}\\n`;\n        }\n        // Atomic write for progress file too\n        const tempFile = `${this.progressFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, content);\n            fs.renameSync(tempFile, this.progressFile);\n        }\n        catch (error) {\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n    }\n    /**\n     * Write the feature list JSON file (for structured access)\n     */\n    writeFeatureList(state) {\n        const featureList = {\n            projectDir: state.projectDir,\n            taskDescription: state.taskDescription,\n            lastUpdated: state.lastUpdated,\n            features: state.features.map((f) => ({\n                id: f.id,\n                description: f.description,\n                status: f.status,\n                passes: f.status === \"completed\",\n            })),\n        };\n        // Atomic write\n        const tempFile = `${this.featureListFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, JSON.stringify(featureList, null, 2));\n            fs.renameSync(tempFile, this.featureListFile);\n        }\n        catch (error) {\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n    }\n    /**\n     * Write init.sh script for environment setup\n     * Following Anthropic's pattern from \"Effective harnesses for long-running agents\"\n     * Security: Uses shell quoting to prevent injection\n     */\n    writeInitScript() {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (!state)\n            return;\n        // Use shell quoting for the project directory\n        const quotedProjectDir = shellQuote(state.projectDir);\n        const script = `#!/bin/bash\n# Claude Orchestrator - Init Script\n# Generated: ${new Date().toISOString()}\n#\n# This script sets up the environment for the orchestration session.\n# Run this at the start of each session to ensure proper setup.\n\nset -e\n\necho \"\ud83d\ude80 Initializing Claude Orchestrator environment...\"\n\n# Navigate to project (safely quoted)\ncd ${quotedProjectDir}\n\n# Check git status\nif git rev-parse --git-dir > /dev/null 2>&1; then\n    echo \"\ud83d\udce6 Git repository detected\"\n    git status --short\nelse\n    echo \"\u26a0\ufe0f  Not a git repository\"\nfi\n\n# Check for common project files and run setup if found\nif [ -f \"package.json\" ]; then\n    echo \"\ud83d\udce6 Node.js project detected\"\n    if [ ! -d \"node_modules\" ]; then\n        echo \"   Installing dependencies...\"\n        npm install\n    fi\nfi\n\nif [ -f \"requirements.txt\" ]; then\n    echo \"\ud83d\udc0d Python project detected\"\n    if [ -d \"venv\" ]; then\n        source venv/bin/activate\n    fi\nfi\n\nif [ -f \"Cargo.toml\" ]; then\n    echo \"\ud83e\udd80 Rust project detected\"\nfi\n\nif [ -f \"go.mod\" ]; then\n    echo \"\ud83d\udc39 Go project detected\"\nfi\n\n# Show orchestrator status\necho \"\"\necho \"\ud83d\udcca Orchestrator Status:\"\nif [ -f \".claude/orchestrator/state.json\" ]; then\n    head -20 .claude/orchestrator/state.json\nelse\n    echo \"   No active session\"\nfi\n\necho \"\"\necho \"\u2705 Environment ready!\"\necho \"   Use 'orchestrator_status' to check current progress\"\n`;\n        fs.writeFileSync(this.initScriptFile, script, { mode: 0o700 }); // Owner-only execution\n    }\n    /**\n     * Append to progress log\n     */\n    appendLog(message) {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (state) {\n            state.progressLog.push(`[${new Date().toISOString()}] ${message}`);\n            this.save(state);\n            this.writeProgressFile();\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_27": {
      "name": "constructor",
      "type": "method",
      "start_line": 27,
      "end_line": 38,
      "content_hash": "8b8098482fe8816e74783156d2f501ea7d01cd07",
      "content": "    constructor(projectDir) {\n        this.projectDir = projectDir;\n        // Ensure .claude directory exists\n        const claudeDir = path.join(projectDir, \".claude\", \"orchestrator\");\n        if (!fs.existsSync(claudeDir)) {\n            fs.mkdirSync(claudeDir, { recursive: true });\n        }\n        this.stateFile = path.join(claudeDir, \"state.json\");\n        this.progressFile = path.join(projectDir, \"claude-progress.txt\");\n        this.initScriptFile = path.join(projectDir, \"init.sh\");\n        this.featureListFile = path.join(claudeDir, \"feature_list.json\");\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_load_42": {
      "name": "load",
      "type": "method",
      "start_line": 42,
      "end_line": 58,
      "content_hash": "98857c218cde00e9a73d46a6518ba2447e70233e",
      "content": "    load() {\n        if (!fs.existsSync(this.stateFile)) {\n            return null;\n        }\n        try {\n            const data = fs.readFileSync(this.stateFile, \"utf-8\");\n            const parsed = JSON.parse(data);\n            // Validate against schema\n            const validated = OrchestratorStateSchema.parse(parsed);\n            return validated;\n        }\n        catch (error) {\n            // If validation fails, the file is corrupted or tampered with\n            console.error(\"Error loading state (file may be corrupted):\", error);\n            throw new Error(\"State file is corrupted or invalid. Use orchestrator_reset to start fresh.\");\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_save_62": {
      "name": "save",
      "type": "method",
      "start_line": 62,
      "end_line": 85,
      "content_hash": "c3b85fcba02ef105fa93f92b2e7da99c5cce4d55",
      "content": "    save(state) {\n        state.lastUpdated = new Date().toISOString();\n        // Rotate log if too large\n        if (state.progressLog.length > MAX_LOG_ENTRIES) {\n            state.progressLog = state.progressLog.slice(-MAX_LOG_ENTRIES);\n        }\n        // Atomic write: write to temp file, then rename\n        const tempFile = `${this.stateFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, JSON.stringify(state, null, 2));\n            fs.renameSync(tempFile, this.stateFile);\n        }\n        catch (error) {\n            // Clean up temp file if rename failed\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n        this.writeFeatureList(state);\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_clear_89": {
      "name": "clear",
      "type": "method",
      "start_line": 89,
      "end_line": 105,
      "content_hash": "803debebdd233635a2453248ddd136244dd7a852",
      "content": "    clear() {\n        const filesToRemove = [\n            this.stateFile,\n            this.progressFile,\n            this.featureListFile,\n        ];\n        for (const file of filesToRemove) {\n            if (fs.existsSync(file)) {\n                try {\n                    fs.unlinkSync(file);\n                }\n                catch {\n                    // Ignore errors during cleanup\n                }\n            }\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeProgressFile_110": {
      "name": "writeProgressFile",
      "type": "method",
      "start_line": 110,
      "end_line": 179,
      "content_hash": "99135acc6ceafdf3734cdc312d28c7ed6ffe4a72",
      "content": "    writeProgressFile() {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (!state)\n            return;\n        const completed = state.features.filter((f) => f.status === \"completed\");\n        const failed = state.features.filter((f) => f.status === \"failed\");\n        const inProgress = state.features.filter((f) => f.status === \"in_progress\");\n        const pending = state.features.filter((f) => f.status === \"pending\");\n        let content = `# Claude Orchestrator Progress Log\n# ===============================\n# Project: ${sanitizeOutput(state.projectDir, 200)}\n# Started: ${state.startTime}\n# Last Updated: ${state.lastUpdated}\n# Status: ${state.status}\n\n## Summary\n- Total Features: ${state.features.length}\n- Completed: ${completed.length}\n- In Progress: ${inProgress.length}\n- Pending: ${pending.length}\n- Failed: ${failed.length}\n\n## Task Description\n${sanitizeOutput(state.taskDescription, 2000)}\n\n## Feature Status\n`;\n        for (const feature of state.features) {\n            const statusIcon = feature.status === \"completed\"\n                ? \"\u2705\"\n                : feature.status === \"failed\"\n                    ? \"\u274c\"\n                    : feature.status === \"in_progress\"\n                        ? \"\ud83d\udd04\"\n                        : \"\u23f3\";\n            content += `${statusIcon} [${feature.status.toUpperCase()}] ${feature.id}: ${sanitizeOutput(feature.description, 200)}\\n`;\n            if (feature.lastError) {\n                content += `   Error: ${sanitizeOutput(feature.lastError, 200)}\\n`;\n            }\n            if (feature.notes) {\n                content += `   Notes: ${sanitizeOutput(feature.notes, 200)}\\n`;\n            }\n        }\n        content += `\\n## Progress Log (last ${Math.min(state.progressLog.length, 100)} entries)\\n`;\n        const recentLogs = state.progressLog.slice(-100);\n        for (const log of recentLogs) {\n            content += `${sanitizeOutput(log, 500)}\\n`;\n        }\n        // Atomic write for progress file too\n        const tempFile = `${this.progressFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, content);\n            fs.renameSync(tempFile, this.progressFile);\n        }\n        catch (error) {\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeFeatureList_183": {
      "name": "writeFeatureList",
      "type": "method",
      "start_line": 183,
      "end_line": 210,
      "content_hash": "70228782c9fc6aa7aef610fd3673f0d65bc70c49",
      "content": "    writeFeatureList(state) {\n        const featureList = {\n            projectDir: state.projectDir,\n            taskDescription: state.taskDescription,\n            lastUpdated: state.lastUpdated,\n            features: state.features.map((f) => ({\n                id: f.id,\n                description: f.description,\n                status: f.status,\n                passes: f.status === \"completed\",\n            })),\n        };\n        // Atomic write\n        const tempFile = `${this.featureListFile}.tmp.${Date.now()}`;\n        try {\n            fs.writeFileSync(tempFile, JSON.stringify(featureList, null, 2));\n            fs.renameSync(tempFile, this.featureListFile);\n        }\n        catch (error) {\n            try {\n                fs.unlinkSync(tempFile);\n            }\n            catch {\n                // Ignore cleanup errors\n            }\n            throw error;\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_writeInitScript_216": {
      "name": "writeInitScript",
      "type": "method",
      "start_line": 216,
      "end_line": 288,
      "content_hash": "3a467647e7ab0e45a8b41ae46da50db9a3d240ab",
      "content": "    writeInitScript() {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (!state)\n            return;\n        // Use shell quoting for the project directory\n        const quotedProjectDir = shellQuote(state.projectDir);\n        const script = `#!/bin/bash\n# Claude Orchestrator - Init Script\n# Generated: ${new Date().toISOString()}\n#\n# This script sets up the environment for the orchestration session.\n# Run this at the start of each session to ensure proper setup.\n\nset -e\n\necho \"\ud83d\ude80 Initializing Claude Orchestrator environment...\"\n\n# Navigate to project (safely quoted)\ncd ${quotedProjectDir}\n\n# Check git status\nif git rev-parse --git-dir > /dev/null 2>&1; then\n    echo \"\ud83d\udce6 Git repository detected\"\n    git status --short\nelse\n    echo \"\u26a0\ufe0f  Not a git repository\"\nfi\n\n# Check for common project files and run setup if found\nif [ -f \"package.json\" ]; then\n    echo \"\ud83d\udce6 Node.js project detected\"\n    if [ ! -d \"node_modules\" ]; then\n        echo \"   Installing dependencies...\"\n        npm install\n    fi\nfi\n\nif [ -f \"requirements.txt\" ]; then\n    echo \"\ud83d\udc0d Python project detected\"\n    if [ -d \"venv\" ]; then\n        source venv/bin/activate\n    fi\nfi\n\nif [ -f \"Cargo.toml\" ]; then\n    echo \"\ud83e\udd80 Rust project detected\"\nfi\n\nif [ -f \"go.mod\" ]; then\n    echo \"\ud83d\udc39 Go project detected\"\nfi\n\n# Show orchestrator status\necho \"\"\necho \"\ud83d\udcca Orchestrator Status:\"\nif [ -f \".claude/orchestrator/state.json\" ]; then\n    head -20 .claude/orchestrator/state.json\nelse\n    echo \"   No active session\"\nfi\n\necho \"\"\necho \"\u2705 Environment ready!\"\necho \"   Use 'orchestrator_status' to check current progress\"\n`;\n        fs.writeFileSync(this.initScriptFile, script, { mode: 0o700 }); // Owner-only execution\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_appendLog_292": {
      "name": "appendLog",
      "type": "method",
      "start_line": 292,
      "end_line": 305,
      "content_hash": "17bcd4165e8ecf08b67430ce93f04474df984f18",
      "content": "    appendLog(message) {\n        let state;\n        try {\n            state = this.load();\n        }\n        catch {\n            return;\n        }\n        if (state) {\n            state.progressLog.push(`[${new Date().toISOString()}] ${message}`);\n            this.save(state);\n            this.writeProgressFile();\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}