{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/tests/init_tests.rs",
  "file_hash": "1c9051f6e9527a5c2962aceff15642bff947acc1",
  "updated_at": "2025-12-26T17:34:22.790134",
  "symbols": {
    "function_setup_test_dir_7": {
      "name": "setup_test_dir",
      "type": "function",
      "start_line": 7,
      "end_line": 11,
      "content_hash": "b1fcdf41fd8f1034496f9d58355deda47951711f",
      "content": "fn setup_test_dir() -> TempDir {\n    TempDir::new().expect(\"Failed to create temp dir\")\n}\n\n/// Helper function to check if helix.toml exists and is valid",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_assert_helix_config_exists_12": {
      "name": "assert_helix_config_exists",
      "type": "function",
      "start_line": 12,
      "end_line": 27,
      "content_hash": "9014585bda39fb647fcdf9af8d22a056f3c8977f",
      "content": "fn assert_helix_config_exists(project_dir: &PathBuf) {\n    let config_path = project_dir.join(\"helix.toml\");\n    assert!(\n        config_path.exists(),\n        \"helix.toml should exist at {:?}\",\n        config_path\n    );\n\n    let content = fs::read_to_string(&config_path).expect(\"Failed to read helix.toml\");\n    assert!(\n        content.contains(\"[project]\"),\n        \"helix.toml should contain [project] section\"\n    );\n}\n\n/// Helper function to check project structure",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_assert_project_structure_28": {
      "name": "assert_project_structure",
      "type": "function",
      "start_line": 28,
      "end_line": 426,
      "content_hash": "81aade80bf5c2618b8b14a20447cf59fa56a1c64",
      "content": "fn assert_project_structure(project_dir: &PathBuf, queries_path: &str) {\n    // Check .helix directory\n    let helix_dir = project_dir.join(\".helix\");\n    assert!(helix_dir.exists(), \".helix directory should exist\");\n    assert!(helix_dir.is_dir(), \".helix should be a directory\");\n\n    // Check queries directory\n    let queries_dir = project_dir.join(queries_path);\n    assert!(\n        queries_dir.exists(),\n        \"Queries directory should exist at {:?}\",\n        queries_dir\n    );\n    assert!(queries_dir.is_dir(), \"Queries path should be a directory\");\n\n    // Check schema.hx\n    let schema_file = queries_dir.join(\"schema.hx\");\n    assert!(schema_file.exists(), \"schema.hx should exist\");\n    let schema_content = fs::read_to_string(&schema_file).expect(\"Failed to read schema.hx\");\n    assert!(\n        schema_content.contains(\"N::\"),\n        \"schema.hx should contain Node type example\"\n    );\n    assert!(\n        schema_content.contains(\"E::\"),\n        \"schema.hx should contain Edge type example\"\n    );\n\n    // Check queries.hx\n    let queries_file = queries_dir.join(\"queries.hx\");\n    assert!(queries_file.exists(), \"queries.hx should exist\");\n    let queries_content = fs::read_to_string(&queries_file).expect(\"Failed to read queries.hx\");\n    assert!(\n        queries_content.contains(\"QUERY\"),\n        \"queries.hx should contain QUERY example\"\n    );\n\n    // Check .gitignore\n    let gitignore = project_dir.join(\".gitignore\");\n    assert!(gitignore.exists(), \".gitignore should exist\");\n    let gitignore_content = fs::read_to_string(&gitignore).expect(\"Failed to read .gitignore\");\n    assert!(\n        gitignore_content.contains(\".helix/\"),\n        \".gitignore should contain .helix/\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_creates_project_structure() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed: {:?}\", result.err());\n    assert_helix_config_exists(&project_path);\n    assert_project_structure(&project_path, \"queries\");\n}\n\n#[tokio::test]\nasync fn test_init_with_default_path() {\n    let temp_dir = setup_test_dir();\n    let _guard = std::env::set_current_dir(temp_dir.path());\n\n    let result = run(\n        None, // Use current directory\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init with default path should succeed\");\n    assert_helix_config_exists(&temp_dir.path().to_path_buf());\n}\n\n#[tokio::test]\nasync fn test_init_with_custom_queries_path() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let custom_path = \"custom/helix/queries\";\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        custom_path.to_string(),\n        None,\n    )\n    .await;\n\n    assert!(\n        result.is_ok(),\n        \"Init with custom queries path should succeed\"\n    );\n    assert_project_structure(&project_path, custom_path);\n\n    // Verify config contains custom path\n    let config_content =\n        fs::read_to_string(project_path.join(\"helix.toml\")).expect(\"Failed to read config\");\n    assert!(\n        config_content.contains(custom_path),\n        \"Config should contain custom queries path\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_fails_if_helix_toml_exists() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml first\n    fs::write(project_path.join(\"helix.toml\"), \"[project]\").expect(\"Failed to create helix.toml\");\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_err(), \"Init should fail if helix.toml exists\");\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"already exists\"),\n        \"Error should mention file already exists\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_creates_directory_if_not_exists() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().join(\"new_project_dir\");\n\n    // Directory should not exist yet\n    assert!(!project_path.exists(), \"Project directory should not exist initially\");\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should create directory\");\n    assert!(project_path.exists(), \"Project directory should be created\");\n    assert!(project_path.is_dir(), \"Project path should be a directory\");\n}\n\n#[tokio::test]\nasync fn test_init_project_name_from_directory() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().join(\"my-awesome-project\");\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let config_content =\n        fs::read_to_string(project_path.join(\"helix.toml\")).expect(\"Failed to read config\");\n    assert!(\n        config_content.contains(\"my-awesome-project\"),\n        \"Project name should be derived from directory name\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_gitignore_content() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let gitignore_path = project_path.join(\".gitignore\");\n    let gitignore_content = fs::read_to_string(&gitignore_path).expect(\"Failed to read .gitignore\");\n\n    assert!(\n        gitignore_content.contains(\".helix/\"),\n        \".gitignore should ignore .helix/\"\n    );\n    assert!(\n        gitignore_content.contains(\"target/\"),\n        \".gitignore should ignore target/\"\n    );\n    assert!(\n        gitignore_content.contains(\"*.log\"),\n        \".gitignore should ignore log files\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_schema_hx_contains_examples() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let schema_path = project_path.join(\"queries/schema.hx\");\n    let schema_content = fs::read_to_string(&schema_path).expect(\"Failed to read schema.hx\");\n\n    // Check for Node type example\n    assert!(\n        schema_content.contains(\"N::User\"),\n        \"schema.hx should contain N::User example\"\n    );\n    assert!(\n        schema_content.contains(\"Name: String\"),\n        \"schema.hx should contain field examples\"\n    );\n\n    // Check for Edge type example\n    assert!(\n        schema_content.contains(\"E::Knows\"),\n        \"schema.hx should contain E::Knows example\"\n    );\n    assert!(\n        schema_content.contains(\"From: User\"),\n        \"schema.hx should contain From field\"\n    );\n    assert!(\n        schema_content.contains(\"To: User\"),\n        \"schema.hx should contain To field\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_queries_hx_contains_examples() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let queries_path = project_path.join(\"queries/queries.hx\");\n    let queries_content = fs::read_to_string(&queries_path).expect(\"Failed to read queries.hx\");\n\n    assert!(\n        queries_content.contains(\"QUERY\"),\n        \"queries.hx should contain QUERY keyword\"\n    );\n    assert!(\n        queries_content.contains(\"GetUserFriends\"),\n        \"queries.hx should contain example query name\"\n    );\n    assert!(\n        queries_content.contains(\"RETURN\"),\n        \"queries.hx should contain RETURN keyword\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_with_nested_queries_path() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n    let nested_path = \"src/helix/queries\";\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        nested_path.to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init with nested path should succeed\");\n    assert_project_structure(&project_path, nested_path);\n\n    // Verify nested directories are created\n    let nested_dir = project_path.join(nested_path);\n    assert!(nested_dir.exists(), \"Nested directory should exist\");\n    assert!(\n        nested_dir.join(\"schema.hx\").exists(),\n        \"schema.hx should be in nested directory\"\n    );\n}\n\n#[tokio::test]\nasync fn test_init_helix_dir_is_created() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let helix_dir = project_path.join(\".helix\");\n    assert!(helix_dir.exists(), \".helix directory should exist\");\n    assert!(helix_dir.is_dir(), \".helix should be a directory\");\n}\n\n#[tokio::test]\nasync fn test_init_config_has_valid_structure() {\n    let temp_dir = setup_test_dir();\n    let project_path = temp_dir.path().to_path_buf();\n\n    let result = run(\n        Some(project_path.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n\n    assert!(result.is_ok(), \"Init should succeed\");\n\n    let config_path = project_path.join(\"helix.toml\");\n    let config_content = fs::read_to_string(&config_path).expect(\"Failed to read helix.toml\");\n\n    // Check TOML structure\n    assert!(\n        config_content.contains(\"[project]\"),\n        \"Config should have [project] section\"\n    );\n    assert!(\n        config_content.contains(\"name =\"),\n        \"Config should have name field\"\n    );\n    assert!(\n        config_content.contains(\"queries =\"),\n        \"Config should have queries field\"\n    );\n\n    // Verify it's valid TOML\n    let parsed: Result<toml::Value, _> = toml::from_str(&config_content);\n    assert!(parsed.is_ok(), \"Config should be valid TOML\");\n}\n\n#[tokio::test]\nasync fn test_init_multiple_times_in_different_dirs() {\n    let temp_dir = setup_test_dir();\n\n    // Create first project\n    let project1 = temp_dir.path().join(\"project1\");\n    let result1 = run(\n        Some(project1.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n    assert!(result1.is_ok(), \"First init should succeed\");\n\n    // Create second project\n    let project2 = temp_dir.path().join(\"project2\");\n    let result2 = run(\n        Some(project2.to_str().unwrap().to_string()),\n        \"default\".to_string(),\n        \"queries\".to_string(),\n        None,\n    )\n    .await;\n    assert!(result2.is_ok(), \"Second init should succeed\");\n\n    // Both should have independent configs\n    assert!(project1.join(\"helix.toml\").exists());\n    assert!(project2.join(\"helix.toml\").exists());\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}