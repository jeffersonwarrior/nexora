{
  "file_path": "/work/internal/agent/tools/mcp/tools.go",
  "file_hash": "ce6ce502f8857b54b910b61703f29a8a79ea2410",
  "updated_at": "2025-12-26T17:34:21.347619",
  "symbols": {
    "struct_ToolResult_18": {
      "name": "ToolResult",
      "type": "struct",
      "start_line": 18,
      "end_line": 27,
      "content_hash": "bc1d5e993714e4278cac59ddb046571040c4aca8",
      "content": "type ToolResult struct {\n\tType      string\n\tContent   string\n\tData      []byte\n\tMediaType string\n}\n\nvar allTools = csync.NewMap[string, []*Tool]()\n\n// Tools returns all available MCP tools.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Tools_28": {
      "name": "Tools",
      "type": "function",
      "start_line": 28,
      "end_line": 32,
      "content_hash": "07cae6688dbe7f283e3e2cdd1934f827e9497f28",
      "content": "func Tools() iter.Seq2[string, []*Tool] {\n\treturn allTools.Seq2()\n}\n\n// RunTool runs an MCP tool with the given input parameters.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_RunTool_33": {
      "name": "RunTool",
      "type": "function",
      "start_line": 33,
      "end_line": 112,
      "content_hash": "13292943d376089ecd576b3abd54f601b30d61a7",
      "content": "func RunTool(ctx context.Context, name, toolName string, input string) (ToolResult, error) {\n\t// Check if this is a Z.ai vision tool\n\tif IsZAITool(toolName) {\n\t\treturn runZAITool(ctx, toolName, input)\n\t}\n\n\tvar args map[string]any\n\tif err := json.Unmarshal([]byte(input), &args); err != nil {\n\t\treturn ToolResult{}, fmt.Errorf(\"error parsing parameters: %s\", err)\n\t}\n\n\tc, err := getOrRenewClient(ctx, name)\n\tif err != nil {\n\t\treturn ToolResult{}, err\n\t}\n\tresult, err := c.CallTool(ctx, &mcp.CallToolParams{\n\t\tName:      toolName,\n\t\tArguments: args,\n\t})\n\tif err != nil {\n\t\treturn ToolResult{}, err\n\t}\n\n\tif len(result.Content) == 0 {\n\t\treturn ToolResult{Type: \"text\", Content: \"\"}, nil\n\t}\n\n\tvar textParts []string\n\tvar imageData []byte\n\tvar imageMimeType string\n\tvar audioData []byte\n\tvar audioMimeType string\n\n\tfor _, v := range result.Content {\n\t\tswitch content := v.(type) {\n\t\tcase *mcp.TextContent:\n\t\t\ttextParts = append(textParts, content.Text)\n\t\tcase *mcp.ImageContent:\n\t\t\tif imageData == nil {\n\t\t\t\timageData = content.Data\n\t\t\t\timageMimeType = content.MIMEType\n\t\t\t}\n\t\tcase *mcp.AudioContent:\n\t\t\tif audioData == nil {\n\t\t\t\taudioData = content.Data\n\t\t\t\taudioMimeType = content.MIMEType\n\t\t\t}\n\t\tdefault:\n\t\t\ttextParts = append(textParts, fmt.Sprintf(\"%v\", v))\n\t\t}\n\t}\n\n\ttextContent := strings.Join(textParts, \"\\n\")\n\n\t// MCP SDK returns Data as already base64-encoded, so we use it directly.\n\tif imageData != nil {\n\t\treturn ToolResult{\n\t\t\tType:      \"image\",\n\t\t\tContent:   textContent,\n\t\t\tData:      imageData,\n\t\t\tMediaType: imageMimeType,\n\t\t}, nil\n\t}\n\n\tif audioData != nil {\n\t\treturn ToolResult{\n\t\t\tType:      \"media\",\n\t\t\tContent:   textContent,\n\t\t\tData:      audioData,\n\t\t\tMediaType: audioMimeType,\n\t\t}, nil\n\t}\n\n\treturn ToolResult{\n\t\tType:    \"text\",\n\t\tContent: textContent,\n\t}, nil\n}\n\n// runZAITool specifically handles Z.ai vision tools",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runZAITool_113": {
      "name": "runZAITool",
      "type": "function",
      "start_line": 113,
      "end_line": 164,
      "content_hash": "4c3134088266f3ef2c7edb2368f54eec65f7e773",
      "content": "func runZAITool(ctx context.Context, toolName string, input string) (ToolResult, error) {\n\tvar args map[string]any\n\tif err := json.Unmarshal([]byte(input), &args); err != nil {\n\t\treturn ToolResult{}, fmt.Errorf(\"error parsing Z.ai tool parameters: %s\", err)\n\t}\n\n\tresult, err := RunZAITool(ctx, toolName, args)\n\tif err != nil {\n\t\treturn ToolResult{}, err\n\t}\n\n\tif len(result.Content) == 0 {\n\t\treturn ToolResult{Type: \"text\", Content: \"\"}, nil\n\t}\n\n\tvar textParts []string\n\tvar imageData []byte\n\tvar imageMimeType string\n\n\tfor _, v := range result.Content {\n\t\tswitch content := v.(type) {\n\t\tcase *mcp.TextContent:\n\t\t\ttextParts = append(textParts, content.Text)\n\t\tcase *mcp.ImageContent:\n\t\t\tif imageData == nil {\n\t\t\t\timageData = content.Data\n\t\t\t\timageMimeType = content.MIMEType\n\t\t\t}\n\t\tdefault:\n\t\t\ttextParts = append(textParts, fmt.Sprintf(\"%v\", v))\n\t\t}\n\t}\n\n\ttextContent := strings.Join(textParts, \"\\n\")\n\n\tif imageData != nil {\n\t\treturn ToolResult{\n\t\t\tType:      \"image\",\n\t\t\tContent:   textContent,\n\t\t\tData:      imageData,\n\t\t\tMediaType: imageMimeType,\n\t\t}, nil\n\t}\n\n\treturn ToolResult{\n\t\tType:    \"text\",\n\t\tContent: textContent,\n\t}, nil\n}\n\n// RefreshTools gets the updated list of tools from the MCP and updates the\n// global state.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_RefreshTools_165": {
      "name": "RefreshTools",
      "type": "function",
      "start_line": 165,
      "end_line": 184,
      "content_hash": "c3bcfd4d9b047e1d65220476f00803284942ec8a",
      "content": "func RefreshTools(ctx context.Context, name string) {\n\tsession, ok := sessions.Get(name)\n\tif !ok {\n\t\tslog.Warn(\"refresh tools: no session\", \"name\", name)\n\t\treturn\n\t}\n\n\ttools, err := getTools(ctx, session)\n\tif err != nil {\n\t\tupdateState(name, StateError, err, nil, Counts{})\n\t\treturn\n\t}\n\n\tupdateTools(name, tools)\n\n\tprev, _ := states.Get(name)\n\tprev.Counts.Tools = len(tools)\n\tupdateState(name, StateConnected, nil, session, prev.Counts)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getTools_185": {
      "name": "getTools",
      "type": "function",
      "start_line": 185,
      "end_line": 195,
      "content_hash": "2f11998375132f16e4bb08e5f2a45f266c3ed052",
      "content": "func getTools(ctx context.Context, session *mcp.ClientSession) ([]*Tool, error) {\n\t// Always call ListTools to get the actual available tools.\n\t// The InitializeResult Capabilities.Tools field may be an empty object {},\n\t// which is valid per MCP spec, but we still need to call ListTools to discover tools.\n\tresult, err := session.ListTools(ctx, &mcp.ListToolsParams{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Tools, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_updateTools_196": {
      "name": "updateTools",
      "type": "function",
      "start_line": 196,
      "end_line": 202,
      "content_hash": "b584c8e8017b86ca8c4faf6ddf4c001f7a8f0ce2",
      "content": "func updateTools(name string, tools []*Tool) {\n\tif len(tools) == 0 {\n\t\tallTools.Del(name)\n\t\treturn\n\t}\n\tallTools.Set(name, tools)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}