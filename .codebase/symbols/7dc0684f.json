{
  "file_path": "/work/internal/tui/components/chat/chat.go",
  "file_hash": "960df7198a2a1c247827cd0a81fa016f2e6eac14",
  "updated_at": "2025-12-26T17:34:23.549449",
  "symbols": {
    "struct_SendMsg_26": {
      "name": "SendMsg",
      "type": "struct",
      "start_line": 26,
      "end_line": 32,
      "content_hash": "f3ee31f8c3f98da79179595865ed33537d8b39cc",
      "content": "type SendMsg struct {\n\tText        string\n\tAttachments []message.Attachment\n}\n\ntype SessionSelectedMsg = session.Session\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SessionClearedMsg_33": {
      "name": "SessionClearedMsg",
      "type": "struct",
      "start_line": 33,
      "end_line": 34,
      "content_hash": "a6f6251497d928fd5d872a9a0d5d23a828db22d2",
      "content": "type SessionClearedMsg struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SelectionCopyMsg_35": {
      "name": "SelectionCopyMsg",
      "type": "struct",
      "start_line": 35,
      "end_line": 40,
      "content_hash": "5974bed3563880911839101978e34e6bbd4b8419",
      "content": "type SelectionCopyMsg struct {\n\tclickCount   int\n\tendSelection bool\n\tx, y         int\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ContinueClickedMsg_41": {
      "name": "ContinueClickedMsg",
      "type": "struct",
      "start_line": 41,
      "end_line": 50,
      "content_hash": "bb08162f2d838ff1dad4510eb56953ad08960b4f",
      "content": "type ContinueClickedMsg struct {\n\tSessionID string\n}\n\nconst (\n\tNotFound = -1\n)\n\n// MessageListCmp represents a component that displays a list of chat messages\n// with support for real-time updates and session management.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_MessageListCmp_51": {
      "name": "MessageListCmp",
      "type": "interface",
      "start_line": 51,
      "end_line": 65,
      "content_hash": "ab47c89cf3abff6e81115fcd8f423c13d0dd0a09",
      "content": "type MessageListCmp interface {\n\tutil.Model\n\tcore.Sizeable\n\tcore.Focusable\n\tlayout.Help\n\n\tSetSession(session.Session) tea.Cmd\n\tGoToBottom() tea.Cmd\n\tGetSelectedText() string\n\tCopySelectedText(bool) tea.Cmd\n}\n\n// messageListCmp implements MessageListCmp, providing a virtualized list\n// of chat messages with support for tool calls, real-time updates, and\n// session switching.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_messageListCmp_66": {
      "name": "messageListCmp",
      "type": "struct",
      "start_line": 66,
      "end_line": 89,
      "content_hash": "ba2c112c9efa58f871db4ba432d652e63cc637cc",
      "content": "type messageListCmp struct {\n\tapp              *app.App\n\twidth, height    int\n\tsession          session.Session\n\tlistCmp          list.List[list.Item]\n\tpreviousSelected string // Last selected item index for restoring focus\n\n\tlastUserMessageTime int64\n\tdefaultListKeyMap   list.KeyMap\n\n\t// Click tracking for double/triple click detection\n\tlastClickTime time.Time\n\tlastClickX    int\n\tlastClickY    int\n\tclickCount    int\n\tpromptQueue   int\n\n\t// Continue button state\n\tshowContinueButton bool\n\tcontinueButtonY    int // Y position of the continue button\n}\n\n// New creates a new message list component with custom keybindings\n// and reverse ordering (newest messages at bottom).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_90": {
      "name": "New",
      "type": "function",
      "start_line": 90,
      "end_line": 108,
      "content_hash": "8699f408bc3e5324638f5c27c40b5a2e8d20ede9",
      "content": "func New(app *app.App) MessageListCmp {\n\tdefaultListKeyMap := list.DefaultKeyMap()\n\tlistCmp := list.New(\n\t\t[]list.Item{},\n\t\tlist.WithGap(1),\n\t\tlist.WithDirectionBackward(),\n\t\tlist.WithFocus(false),\n\t\tlist.WithKeyMap(defaultListKeyMap),\n\t\tlist.WithEnableMouse(),\n\t)\n\treturn &messageListCmp{\n\t\tapp:               app,\n\t\tlistCmp:           listCmp,\n\t\tpreviousSelected:  \"\",\n\t\tdefaultListKeyMap: defaultListKeyMap,\n\t}\n}\n\n// Init initializes the component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_109": {
      "name": "Init",
      "type": "method",
      "start_line": 109,
      "end_line": 113,
      "content_hash": "215337296d7b33dc3a5977b8a36a9b2d3184a076",
      "content": "func (m *messageListCmp) Init() tea.Cmd {\n\treturn m.listCmp.Init()\n}\n\n// Update handles incoming messages and updates the component state.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_114": {
      "name": "Update",
      "type": "method",
      "start_line": 114,
      "end_line": 242,
      "content_hash": "76e95469f086cce0da49d0ab3782c9f297334867",
      "content": "func (m *messageListCmp) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\tif m.session.ID != \"\" && m.app.AgentCoordinator != nil {\n\t\tqueueSize := m.app.AgentCoordinator.QueuedPrompts(m.session.ID)\n\t\tif queueSize != m.promptQueue {\n\t\t\tm.promptQueue = queueSize\n\t\t\tcmds = append(cmds, m.SetSize(m.width, m.height))\n\t\t}\n\t}\n\tswitch msg := msg.(type) {\n\tcase tea.KeyPressMsg:\n\t\tif m.listCmp.IsFocused() && m.listCmp.HasSelection() {\n\t\t\tswitch {\n\t\t\tcase key.Matches(msg, messages.CopyKey):\n\t\t\t\tcmds = append(cmds, m.CopySelectedText(true))\n\t\t\t\treturn m, tea.Batch(cmds...)\n\t\t\tcase key.Matches(msg, messages.ClearSelectionKey):\n\t\t\t\tcmds = append(cmds, m.SelectionClear())\n\t\t\t\treturn m, tea.Batch(cmds...)\n\t\t\t}\n\t\t}\n\tcase tea.MouseClickMsg:\n\t\tx := msg.X - 1 // Adjust for padding\n\t\ty := msg.Y - 1 // Adjust for padding\n\t\tif x < 0 || y < 0 || x >= m.width-2 || y >= m.height-1 {\n\t\t\treturn m, nil // Ignore clicks outside the component\n\t\t}\n\t\tif msg.Button == tea.MouseLeft {\n\t\t\tcmds = append(cmds, m.handleMouseClick(x, y))\n\t\t\treturn m, tea.Batch(cmds...)\n\t\t}\n\t\treturn m, tea.Batch(cmds...)\n\tcase tea.MouseMotionMsg:\n\t\tx := msg.X - 1 // Adjust for padding\n\t\ty := msg.Y - 1 // Adjust for padding\n\t\tif x < 0 || y < 0 || x >= m.width-2 || y >= m.height-1 {\n\t\t\tif y < 0 {\n\t\t\t\tcmds = append(cmds, m.listCmp.MoveUp(1))\n\t\t\t\treturn m, tea.Batch(cmds...)\n\t\t\t}\n\t\t\tif y >= m.height-1 {\n\t\t\t\tcmds = append(cmds, m.listCmp.MoveDown(1))\n\t\t\t\treturn m, tea.Batch(cmds...)\n\t\t\t}\n\t\t\treturn m, nil // Ignore clicks outside the component\n\t\t}\n\t\tif msg.Button == tea.MouseLeft {\n\t\t\tm.listCmp.EndSelection(x, y)\n\t\t}\n\t\treturn m, tea.Batch(cmds...)\n\tcase tea.MouseReleaseMsg:\n\t\tx := msg.X - 1 // Adjust for padding\n\t\ty := msg.Y - 1 // Adjust for padding\n\t\tif msg.Button == tea.MouseLeft {\n\t\t\tclickCount := m.clickCount\n\t\t\tif x < 0 || y < 0 || x >= m.width-2 || y >= m.height-1 {\n\t\t\t\ttick := tea.Tick(doubleClickThreshold, func(time.Time) tea.Msg {\n\t\t\t\t\treturn SelectionCopyMsg{\n\t\t\t\t\t\tclickCount:   clickCount,\n\t\t\t\t\t\tendSelection: false,\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tcmds = append(cmds, tick)\n\t\t\t\treturn m, tea.Batch(cmds...)\n\t\t\t}\n\t\t\ttick := tea.Tick(doubleClickThreshold, func(time.Time) tea.Msg {\n\t\t\t\treturn SelectionCopyMsg{\n\t\t\t\t\tclickCount:   clickCount,\n\t\t\t\t\tendSelection: true,\n\t\t\t\t\tx:            x,\n\t\t\t\t\ty:            y,\n\t\t\t\t}\n\t\t\t})\n\t\t\tcmds = append(cmds, tick)\n\t\t\treturn m, tea.Batch(cmds...)\n\t\t}\n\t\treturn m, nil\n\tcase SelectionCopyMsg:\n\t\tif msg.clickCount == m.clickCount && time.Since(m.lastClickTime) >= doubleClickThreshold {\n\t\t\t// If the click count matches and within threshold, copy selected text\n\t\t\tif msg.endSelection {\n\t\t\t\tm.listCmp.EndSelection(msg.x, msg.y)\n\t\t\t}\n\t\t\tm.listCmp.SelectionStop()\n\t\t\tcmds = append(cmds, m.CopySelectedText(true))\n\t\t\treturn m, tea.Batch(cmds...)\n\t\t}\n\tcase pubsub.Event[permission.PermissionNotification]:\n\t\tcmds = append(cmds, m.handlePermissionRequest(msg.Payload))\n\t\treturn m, tea.Batch(cmds...)\n\tcase ContinueClickedMsg:\n\t\tif msg.SessionID == m.session.ID {\n\t\t\t// Send a continue message\n\t\t\treturn m, func() tea.Msg {\n\t\t\t\treturn SendMsg{\n\t\t\t\t\tText: \"continue\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m, nil\n\tcase SessionSelectedMsg:\n\t\tif msg.ID != m.session.ID {\n\t\t\tcmds = append(cmds, m.SetSession(msg))\n\t\t}\n\t\treturn m, tea.Batch(cmds...)\n\tcase SessionClearedMsg:\n\t\tm.session = session.Session{}\n\t\tcmds = append(cmds, m.listCmp.SetItems([]list.Item{}))\n\t\treturn m, tea.Batch(cmds...)\n\n\tcase pubsub.Event[message.Message]:\n\t\tcmds = append(cmds, m.handleMessageEvent(msg))\n\t\treturn m, tea.Batch(cmds...)\n\n\tcase tea.MouseWheelMsg:\n\t\tu, cmd := m.listCmp.Update(msg)\n\t\tm.listCmp = u.(list.List[list.Item])\n\t\tcmds = append(cmds, cmd)\n\t\treturn m, tea.Batch(cmds...)\n\t}\n\n\tu, cmd := m.listCmp.Update(msg)\n\tm.listCmp = u.(list.List[list.Item])\n\tcmds = append(cmds, cmd)\n\treturn m, tea.Batch(cmds...)\n}\n\n// View renders the message list or an initial screen if empty.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_243": {
      "name": "View",
      "type": "method",
      "start_line": 243,
      "end_line": 284,
      "content_hash": "4eb23327c97576eef3988b13f1ea0563ab70e712",
      "content": "func (m *messageListCmp) View() string {\n\tt := styles.CurrentTheme()\n\t// Constants for UI layout calculations\n\tconst pillHeightAndPadding = 4\n\n\theight := m.height\n\tif m.promptQueue > 0 {\n\t\theight -= pillHeightAndPadding // Space for pill UI and padding\n\t}\n\n\t// Prepare the main view with messages\n\tmainView := t.S().Base.\n\t\tPadding(1, 1, 0, 1).\n\t\tWidth(m.width).\n\t\tHeight(height).\n\t\tRender(\n\t\t\tm.listCmp.View(),\n\t\t)\n\n\tview := []string{mainView}\n\n\t// Add continue button if needed\n\tif m.showContinueButton {\n\t\tcontinueButton := t.S().Success.\n\t\t\tBackground(t.BgOverlay).\n\t\t\tForeground(t.White).\n\t\t\tPadding(0, 2).\n\t\t\tWidth(12).\n\t\t\tRender(\"\u25b6 Continue\")\n\t\tbuttonRow := t.S().Base.PaddingLeft(2).Render(continueButton)\n\t\tview = append(view, buttonRow)\n\t}\n\n\t// Add queue pill if needed\n\tif m.app.AgentCoordinator != nil && m.promptQueue > 0 {\n\t\tqueuePill := queuePill(m.promptQueue, t)\n\t\tview = append(view, t.S().Base.PaddingLeft(4).PaddingTop(1).Render(queuePill))\n\t}\n\n\treturn strings.Join(view, \"\\n\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handlePermissionRequest_285": {
      "name": "handlePermissionRequest",
      "type": "method",
      "start_line": 285,
      "end_line": 298,
      "content_hash": "a6d2883d6af9e3da10f178b068bd531b93cf7e9a",
      "content": "func (m *messageListCmp) handlePermissionRequest(permission permission.PermissionNotification) tea.Cmd {\n\titems := m.listCmp.Items()\n\tif toolCallIndex := m.findToolCallByID(items, permission.ToolCallID); toolCallIndex != NotFound {\n\t\ttoolCall := items[toolCallIndex].(messages.ToolCallCmp)\n\t\ttoolCall.SetPermissionRequested()\n\t\tif permission.Granted {\n\t\t\ttoolCall.SetPermissionGranted()\n\t\t}\n\t\tm.listCmp.UpdateItem(toolCall.ID(), toolCall)\n\t}\n\treturn nil\n}\n\n// handleChildSession handles messages from child sessions (agent tools).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleChildSession_299": {
      "name": "handleChildSession",
      "type": "method",
      "start_line": 299,
      "end_line": 366,
      "content_hash": "adb43c227d7f2506f3768c0ee521fa24ed4b7285",
      "content": "func (m *messageListCmp) handleChildSession(event pubsub.Event[message.Message]) tea.Cmd {\n\tvar cmds []tea.Cmd\n\tif len(event.Payload.ToolCalls()) == 0 && len(event.Payload.ToolResults()) == 0 {\n\t\treturn nil\n\t}\n\n\t// Check if this is an agent tool session and parse it\n\tchildSessionID := event.Payload.SessionID\n\tparentMessageID, toolCallID, ok := m.app.Sessions.ParseAgentToolSessionID(childSessionID)\n\tif !ok {\n\t\treturn nil\n\t}\n\titems := m.listCmp.Items()\n\ttoolCallInx := NotFound\n\tvar toolCall messages.ToolCallCmp\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tif msg, ok := items[i].(messages.ToolCallCmp); ok {\n\t\t\tif msg.ParentMessageID() == parentMessageID && msg.GetToolCall().ID == toolCallID {\n\t\t\t\ttoolCallInx = i\n\t\t\t\ttoolCall = msg\n\t\t\t}\n\t\t}\n\t}\n\tif toolCallInx == NotFound {\n\t\treturn nil\n\t}\n\tnestedToolCalls := toolCall.GetNestedToolCalls()\n\tfor _, tc := range event.Payload.ToolCalls() {\n\t\tfound := false\n\t\tfor existingInx, existingTC := range nestedToolCalls {\n\t\t\tif existingTC.GetToolCall().ID == tc.ID {\n\t\t\t\tnestedToolCalls[existingInx].SetToolCall(tc)\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tnestedCall := messages.NewToolCallCmp(\n\t\t\t\tevent.Payload.ID,\n\t\t\t\ttc,\n\t\t\t\tm.app.Permissions,\n\t\t\t\tmessages.WithToolCallNested(true),\n\t\t\t)\n\t\t\tcmds = append(cmds, nestedCall.Init())\n\t\t\tnestedToolCalls = append(\n\t\t\t\tnestedToolCalls,\n\t\t\t\tnestedCall,\n\t\t\t)\n\t\t}\n\t}\n\tfor _, tr := range event.Payload.ToolResults() {\n\t\tfor nestedInx, nestedTC := range nestedToolCalls {\n\t\t\tif nestedTC.GetToolCall().ID == tr.ToolCallID {\n\t\t\t\tnestedToolCalls[nestedInx].SetToolResult(tr)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\ttoolCall.SetNestedToolCalls(nestedToolCalls)\n\tm.listCmp.UpdateItem(\n\t\ttoolCall.ID(),\n\t\ttoolCall,\n\t)\n\treturn tea.Batch(cmds...)\n}\n\n// handleMessageEvent processes different types of message events (created/updated).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleMessageEvent_367": {
      "name": "handleMessageEvent",
      "type": "method",
      "start_line": 367,
      "end_line": 396,
      "content_hash": "730b5459dadd8c1923ecdba1628b254b3d54a17f",
      "content": "func (m *messageListCmp) handleMessageEvent(event pubsub.Event[message.Message]) tea.Cmd {\n\tswitch event.Type {\n\tcase pubsub.CreatedEvent:\n\t\tif event.Payload.SessionID != m.session.ID {\n\t\t\treturn m.handleChildSession(event)\n\t\t}\n\t\tif m.messageExists(event.Payload.ID) {\n\t\t\treturn nil\n\t\t}\n\t\treturn m.handleNewMessage(event.Payload)\n\tcase pubsub.DeletedEvent:\n\t\tif event.Payload.SessionID != m.session.ID {\n\t\t\treturn nil\n\t\t}\n\t\treturn m.handleDeleteMessage(event.Payload)\n\tcase pubsub.UpdatedEvent:\n\t\tif event.Payload.SessionID != m.session.ID {\n\t\t\treturn m.handleChildSession(event)\n\t\t}\n\t\tswitch event.Payload.Role {\n\t\tcase message.Assistant:\n\t\t\treturn m.handleUpdateAssistantMessage(event.Payload)\n\t\tcase message.Tool:\n\t\t\treturn m.handleToolMessage(event.Payload)\n\t\t}\n\t}\n\treturn nil\n}\n\n// messageExists checks if a message with the given ID already exists in the list.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_messageExists_397": {
      "name": "messageExists",
      "type": "method",
      "start_line": 397,
      "end_line": 408,
      "content_hash": "5e57749a1515557d4a6294a606b6f297cbd87bd2",
      "content": "func (m *messageListCmp) messageExists(messageID string) bool {\n\titems := m.listCmp.Items()\n\t// Search backwards as new messages are more likely to be at the end\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tif msg, ok := items[i].(messages.MessageCmp); ok && msg.GetMessage().ID == messageID {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// handleDeleteMessage removes a message from the list.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleDeleteMessage_409": {
      "name": "handleDeleteMessage",
      "type": "method",
      "start_line": 409,
      "end_line": 420,
      "content_hash": "3e3f5b637570a1026bb999cd057cc33e97979fb8",
      "content": "func (m *messageListCmp) handleDeleteMessage(msg message.Message) tea.Cmd {\n\titems := m.listCmp.Items()\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tif msgCmp, ok := items[i].(messages.MessageCmp); ok && msgCmp.GetMessage().ID == msg.ID {\n\t\t\tm.listCmp.DeleteItem(items[i].ID())\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// handleNewMessage routes new messages to appropriate handlers based on role.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleNewMessage_421": {
      "name": "handleNewMessage",
      "type": "method",
      "start_line": 421,
      "end_line": 436,
      "content_hash": "46ff9f933539e425bac56893fb766adade674cb6",
      "content": "func (m *messageListCmp) handleNewMessage(msg message.Message) tea.Cmd {\n\t// Hide continue button when any new message is sent\n\tm.showContinueButton = false\n\n\tswitch msg.Role {\n\tcase message.User:\n\t\treturn m.handleNewUserMessage(msg)\n\tcase message.Assistant:\n\t\treturn m.handleNewAssistantMessage(msg)\n\tcase message.Tool:\n\t\treturn m.handleToolMessage(msg)\n\t}\n\treturn nil\n}\n\n// handleNewUserMessage adds a new user message to the list and updates the timestamp.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleNewUserMessage_437": {
      "name": "handleNewUserMessage",
      "type": "method",
      "start_line": 437,
      "end_line": 442,
      "content_hash": "95ae2025d78f0a7685c3ab912cb58f76f36eec3b",
      "content": "func (m *messageListCmp) handleNewUserMessage(msg message.Message) tea.Cmd {\n\tm.lastUserMessageTime = msg.CreatedAt\n\treturn m.listCmp.AppendItem(messages.NewMessageCmp(msg))\n}\n\n// handleToolMessage updates existing tool calls with their results.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleToolMessage_443": {
      "name": "handleToolMessage",
      "type": "method",
      "start_line": 443,
      "end_line": 456,
      "content_hash": "cd8409aa59deba19f25f3663ce5daf2e4a31bc56",
      "content": "func (m *messageListCmp) handleToolMessage(msg message.Message) tea.Cmd {\n\titems := m.listCmp.Items()\n\tfor _, tr := range msg.ToolResults() {\n\t\tif toolCallIndex := m.findToolCallByID(items, tr.ToolCallID); toolCallIndex != NotFound {\n\t\t\ttoolCall := items[toolCallIndex].(messages.ToolCallCmp)\n\t\t\ttoolCall.SetToolResult(tr)\n\t\t\tm.listCmp.UpdateItem(toolCall.ID(), toolCall)\n\t\t}\n\t}\n\treturn nil\n}\n\n// findToolCallByID searches for a tool call with the specified ID.\n// Returns the index if found, NotFound otherwise.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findToolCallByID_457": {
      "name": "findToolCallByID",
      "type": "method",
      "start_line": 457,
      "end_line": 468,
      "content_hash": "01ee9306f2f459c57ed17567a2c5da0fbd42a3c9",
      "content": "func (m *messageListCmp) findToolCallByID(items []list.Item, toolCallID string) int {\n\t// Search backwards as tool calls are more likely to be recent\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tif toolCall, ok := items[i].(messages.ToolCallCmp); ok && toolCall.GetToolCall().ID == toolCallID {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn NotFound\n}\n\n// handleUpdateAssistantMessage processes updates to assistant messages,\n// managing both message content and associated tool calls.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleUpdateAssistantMessage_469": {
      "name": "handleUpdateAssistantMessage",
      "type": "method",
      "start_line": 469,
      "end_line": 489,
      "content_hash": "9be1f61c2b65b00be0f5c47cfc0a45b551d7b059",
      "content": "func (m *messageListCmp) handleUpdateAssistantMessage(msg message.Message) tea.Cmd {\n\tvar cmds []tea.Cmd\n\titems := m.listCmp.Items()\n\n\t// Find existing assistant message and tool calls for this message\n\tassistantIndex, existingToolCalls := m.findAssistantMessageAndToolCalls(items, msg.ID)\n\n\t// Handle assistant message content\n\tif cmd := m.updateAssistantMessageContent(msg, assistantIndex); cmd != nil {\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\t// Handle tool calls\n\tif cmd := m.updateToolCalls(msg, existingToolCalls); cmd != nil {\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// shouldShowContinueButton determines if a continue button should be shown based on the message content",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldShowContinueButton_490": {
      "name": "shouldShowContinueButton",
      "type": "method",
      "start_line": 490,
      "end_line": 526,
      "content_hash": "21c7dbd38e594b62520ae47d5e0de3da1e163dd9",
      "content": "func (m *messageListCmp) shouldShowContinueButton(msg message.Message) {\n\tcontent := strings.ToLower(msg.Content().Text)\n\n\t// Continuation indicators - phrases that suggest more work could be done\n\tcontinuationSignals := []string{\n\t\t\"now let me\", \"next, i'll\", \"let me create\", \"i'll now\",\n\t\t\"let's\", \"let me check\", \"let me examine\", \"let me review\",\n\t\t\"let me implement\", \"now i'll\", \"moving on to\", \"i will now\",\n\t\t\"i need to\", \"i should\", \"we should\", \"we need to\",\n\t\t\"let me also\", \"additionally\", \"furthermore\", \"next step\",\n\t\t\"let me update\", \"let me modify\", \"let me add\", \"let me fix\",\n\t\t\"let me test\", \"let me verify\", \"let me validate\",\n\t\t\"let me now\", \"i can\", \"let me show\", \"i'll help\",\n\t}\n\n\tfor _, signal := range continuationSignals {\n\t\tif strings.Contains(content, signal) {\n\t\t\tm.showContinueButton = true\n\t\t\t// Position the button at the end of the current viewport\n\t\t\titems := m.listCmp.Items()\n\t\t\tm.continueButtonY = len(items) + 2 // Add some padding\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Check if we have tool results but no clear completion\n\tif len(msg.ToolCalls()) > 0 && msg.FinishPart().Reason == message.FinishReasonEndTurn {\n\t\tm.showContinueButton = true\n\t\titems := m.listCmp.Items()\n\t\tm.continueButtonY = len(items) + 2\n\t\treturn\n\t}\n\n\tm.showContinueButton = false\n}\n\n// findAssistantMessageAndToolCalls locates the assistant message and its tool calls.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findAssistantMessageAndToolCalls_527": {
      "name": "findAssistantMessageAndToolCalls",
      "type": "method",
      "start_line": 527,
      "end_line": 548,
      "content_hash": "eae72ef3237d295634914c15107b879ad636e67b",
      "content": "func (m *messageListCmp) findAssistantMessageAndToolCalls(items []list.Item, messageID string) (int, map[int]messages.ToolCallCmp) {\n\tassistantIndex := NotFound\n\ttoolCalls := make(map[int]messages.ToolCallCmp)\n\n\t// Search backwards as messages are more likely to be at the end\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\titem := items[i]\n\t\tif asMsg, ok := item.(messages.MessageCmp); ok {\n\t\t\tif asMsg.GetMessage().ID == messageID {\n\t\t\t\tassistantIndex = i\n\t\t\t}\n\t\t} else if tc, ok := item.(messages.ToolCallCmp); ok {\n\t\t\tif tc.ParentMessageID() == messageID {\n\t\t\t\ttoolCalls[i] = tc\n\t\t\t}\n\t\t}\n\t}\n\n\treturn assistantIndex, toolCalls\n}\n\n// updateAssistantMessageContent updates or removes the assistant message based on content.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateAssistantMessageContent_549": {
      "name": "updateAssistantMessageContent",
      "type": "method",
      "start_line": 549,
      "end_line": 587,
      "content_hash": "82a09174967caa302d1c95e1cddeab31a35ad6c5",
      "content": "func (m *messageListCmp) updateAssistantMessageContent(msg message.Message, assistantIndex int) tea.Cmd {\n\tif assistantIndex == NotFound {\n\t\treturn nil\n\t}\n\n\tshouldShowMessage := m.shouldShowAssistantMessage(msg)\n\thasToolCallsOnly := len(msg.ToolCalls()) > 0 && msg.Content().Text == \"\"\n\n\tvar cmd tea.Cmd\n\tif shouldShowMessage {\n\t\titems := m.listCmp.Items()\n\t\tuiMsg := items[assistantIndex].(messages.MessageCmp)\n\t\tuiMsg.SetMessage(msg)\n\t\tm.listCmp.UpdateItem(\n\t\t\titems[assistantIndex].ID(),\n\t\t\tuiMsg,\n\t\t)\n\t\tif msg.FinishPart() != nil && msg.FinishPart().Reason == message.FinishReasonEndTurn {\n\t\t\tm.listCmp.AppendItem(\n\t\t\t\tmessages.NewAssistantSection(\n\t\t\t\t\tmsg,\n\t\t\t\t\ttime.Unix(m.lastUserMessageTime, 0),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// Check if we should show the continue button when assistant message is finished\n\t\tif msg.FinishPart() != nil {\n\t\t\tm.shouldShowContinueButton(msg)\n\t\t}\n\t} else if hasToolCallsOnly {\n\t\titems := m.listCmp.Items()\n\t\tm.listCmp.DeleteItem(items[assistantIndex].ID())\n\t}\n\n\treturn cmd\n}\n\n// shouldShowAssistantMessage determines if an assistant message should be displayed.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldShowAssistantMessage_588": {
      "name": "shouldShowAssistantMessage",
      "type": "method",
      "start_line": 588,
      "end_line": 592,
      "content_hash": "234e0b6d1c2df27dbefd19ba0a9e4f6feaef9d60",
      "content": "func (m *messageListCmp) shouldShowAssistantMessage(msg message.Message) bool {\n\treturn len(msg.ToolCalls()) == 0 || msg.Content().Text != \"\" || msg.ReasoningContent().Thinking != \"\" || msg.IsThinking()\n}\n\n// updateToolCalls handles updates to tool calls, updating existing ones and adding new ones.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateToolCalls_593": {
      "name": "updateToolCalls",
      "type": "method",
      "start_line": 593,
      "end_line": 605,
      "content_hash": "d9b0e99c5148032cdfbb4214c7ef101491d7adfd",
      "content": "func (m *messageListCmp) updateToolCalls(msg message.Message, existingToolCalls map[int]messages.ToolCallCmp) tea.Cmd {\n\tvar cmds []tea.Cmd\n\n\tfor _, tc := range msg.ToolCalls() {\n\t\tif cmd := m.updateOrAddToolCall(msg, tc, existingToolCalls); cmd != nil {\n\t\t\tcmds = append(cmds, cmd)\n\t\t}\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// updateOrAddToolCall updates an existing tool call or adds a new one.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateOrAddToolCall_606": {
      "name": "updateOrAddToolCall",
      "type": "method",
      "start_line": 606,
      "end_line": 623,
      "content_hash": "be06514b87561c4531e94369e5dca681dd4e2e09",
      "content": "func (m *messageListCmp) updateOrAddToolCall(msg message.Message, tc message.ToolCall, existingToolCalls map[int]messages.ToolCallCmp) tea.Cmd {\n\t// Try to find existing tool call\n\tfor _, existingTC := range existingToolCalls {\n\t\tif tc.ID == existingTC.GetToolCall().ID {\n\t\t\texistingTC.SetToolCall(tc)\n\t\t\tif msg.FinishPart() != nil && msg.FinishPart().Reason == message.FinishReasonCanceled {\n\t\t\t\texistingTC.SetCancelled()\n\t\t\t}\n\t\t\tm.listCmp.UpdateItem(tc.ID, existingTC)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Add new tool call if not found\n\treturn m.listCmp.AppendItem(messages.NewToolCallCmp(msg.ID, tc, m.app.Permissions))\n}\n\n// handleNewAssistantMessage processes new assistant messages and their tool calls.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleNewAssistantMessage_624": {
      "name": "handleNewAssistantMessage",
      "type": "method",
      "start_line": 624,
      "end_line": 646,
      "content_hash": "fd23acde007a22d4db7aa5c1ede874dd7eeaa86d",
      "content": "func (m *messageListCmp) handleNewAssistantMessage(msg message.Message) tea.Cmd {\n\tvar cmds []tea.Cmd\n\n\t// Add assistant message if it should be displayed\n\tif m.shouldShowAssistantMessage(msg) {\n\t\tcmd := m.listCmp.AppendItem(\n\t\t\tmessages.NewMessageCmp(\n\t\t\t\tmsg,\n\t\t\t),\n\t\t)\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\t// Add tool calls\n\tfor _, tc := range msg.ToolCalls() {\n\t\tcmd := m.listCmp.AppendItem(messages.NewToolCallCmp(msg.ID, tc, m.app.Permissions))\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// SetSession loads and displays messages for a new session.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSession_647": {
      "name": "SetSession",
      "type": "method",
      "start_line": 647,
      "end_line": 674,
      "content_hash": "73812a6a09d9a040f4288bd8e2311ac0218a06af",
      "content": "func (m *messageListCmp) SetSession(session session.Session) tea.Cmd {\n\tif m.session.ID == session.ID {\n\t\treturn nil\n\t}\n\n\tm.session = session\n\tsessionMessages, err := m.app.Messages.List(context.Background(), session.ID)\n\tif err != nil {\n\t\treturn util.ReportError(err)\n\t}\n\n\tif len(sessionMessages) == 0 {\n\t\treturn m.listCmp.SetItems([]list.Item{})\n\t}\n\n\t// Initialize with first message timestamp\n\tm.lastUserMessageTime = sessionMessages[0].CreatedAt\n\n\t// Build tool result map for efficient lookup\n\ttoolResultMap := m.buildToolResultMap(sessionMessages)\n\n\t// Convert messages to UI components\n\tuiMessages := m.convertMessagesToUI(sessionMessages, toolResultMap)\n\n\treturn m.listCmp.SetItems(uiMessages)\n}\n\n// buildToolResultMap creates a map of tool call ID to tool result for efficient lookup.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildToolResultMap_675": {
      "name": "buildToolResultMap",
      "type": "method",
      "start_line": 675,
      "end_line": 685,
      "content_hash": "bb0f88041231824b2de9d805ef98032d26e17cd9",
      "content": "func (m *messageListCmp) buildToolResultMap(messages []message.Message) map[string]message.ToolResult {\n\ttoolResultMap := make(map[string]message.ToolResult)\n\tfor _, msg := range messages {\n\t\tfor _, tr := range msg.ToolResults() {\n\t\t\ttoolResultMap[tr.ToolCallID] = tr\n\t\t}\n\t}\n\treturn toolResultMap\n}\n\n// convertMessagesToUI converts database messages to UI components.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_convertMessagesToUI_686": {
      "name": "convertMessagesToUI",
      "type": "method",
      "start_line": 686,
      "end_line": 705,
      "content_hash": "a948536369b0ea589a86851aa30c44c11eff5a62",
      "content": "func (m *messageListCmp) convertMessagesToUI(sessionMessages []message.Message, toolResultMap map[string]message.ToolResult) []list.Item {\n\tuiMessages := make([]list.Item, 0)\n\n\tfor _, msg := range sessionMessages {\n\t\tswitch msg.Role {\n\t\tcase message.User:\n\t\t\tm.lastUserMessageTime = msg.CreatedAt\n\t\t\tuiMessages = append(uiMessages, messages.NewMessageCmp(msg))\n\t\tcase message.Assistant:\n\t\t\tuiMessages = append(uiMessages, m.convertAssistantMessage(msg, toolResultMap)...)\n\t\t\tif msg.FinishPart() != nil && msg.FinishPart().Reason == message.FinishReasonEndTurn {\n\t\t\t\tuiMessages = append(uiMessages, messages.NewAssistantSection(msg, time.Unix(m.lastUserMessageTime, 0)))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn uiMessages\n}\n\n// convertAssistantMessage converts an assistant message and its tool calls to UI components.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_convertAssistantMessage_706": {
      "name": "convertAssistantMessage",
      "type": "method",
      "start_line": 706,
      "end_line": 743,
      "content_hash": "974aaa185781df2e1c7c3d935783c5791a110246",
      "content": "func (m *messageListCmp) convertAssistantMessage(msg message.Message, toolResultMap map[string]message.ToolResult) []list.Item {\n\tvar uiMessages []list.Item\n\n\t// Add assistant message if it should be displayed\n\tif m.shouldShowAssistantMessage(msg) {\n\t\tuiMessages = append(\n\t\t\tuiMessages,\n\t\t\tmessages.NewMessageCmp(\n\t\t\t\tmsg,\n\t\t\t),\n\t\t)\n\t}\n\n\t// Add tool calls with their results and status\n\tfor _, tc := range msg.ToolCalls() {\n\t\toptions := m.buildToolCallOptions(tc, msg, toolResultMap)\n\t\tuiMessages = append(uiMessages, messages.NewToolCallCmp(msg.ID, tc, m.app.Permissions, options...))\n\t\t// If this tool call is the agent tool or agentic fetch, fetch nested tool calls\n\t\tif tc.Name == agent.AgentToolName || tc.Name == tools.AgenticFetchToolName {\n\t\t\tagentToolSessionID := m.app.Sessions.CreateAgentToolSessionID(msg.ID, tc.ID)\n\t\t\tnestedMessages, _ := m.app.Messages.List(context.Background(), agentToolSessionID)\n\t\t\tnestedToolResultMap := m.buildToolResultMap(nestedMessages)\n\t\t\tnestedUIMessages := m.convertMessagesToUI(nestedMessages, nestedToolResultMap)\n\t\t\tnestedToolCalls := make([]messages.ToolCallCmp, 0, len(nestedUIMessages))\n\t\t\tfor _, nestedMsg := range nestedUIMessages {\n\t\t\t\tif toolCall, ok := nestedMsg.(messages.ToolCallCmp); ok {\n\t\t\t\t\ttoolCall.SetIsNested(true)\n\t\t\t\t\tnestedToolCalls = append(nestedToolCalls, toolCall)\n\t\t\t\t}\n\t\t\t}\n\t\t\tuiMessages[len(uiMessages)-1].(messages.ToolCallCmp).SetNestedToolCalls(nestedToolCalls)\n\t\t}\n\t}\n\n\treturn uiMessages\n}\n\n// buildToolCallOptions creates options for tool call components based on results and status.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildToolCallOptions_744": {
      "name": "buildToolCallOptions",
      "type": "method",
      "start_line": 744,
      "end_line": 760,
      "content_hash": "701322fc6ac9f702e0fffc99b837fdfb0be05a81",
      "content": "func (m *messageListCmp) buildToolCallOptions(tc message.ToolCall, msg message.Message, toolResultMap map[string]message.ToolResult) []messages.ToolCallOption {\n\tvar options []messages.ToolCallOption\n\n\t// Add tool result if available\n\tif tr, ok := toolResultMap[tc.ID]; ok {\n\t\toptions = append(options, messages.WithToolCallResult(tr))\n\t}\n\n\t// Add cancelled status if applicable\n\tif msg.FinishPart() != nil && msg.FinishPart().Reason == message.FinishReasonCanceled {\n\t\toptions = append(options, messages.WithToolCallCancelled())\n\t}\n\n\treturn options\n}\n\n// GetSize returns the current width and height of the component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_761": {
      "name": "GetSize",
      "type": "method",
      "start_line": 761,
      "end_line": 765,
      "content_hash": "22f391787f36bef0f6032f78fe771fabc9356923",
      "content": "func (m *messageListCmp) GetSize() (int, int) {\n\treturn m.width, m.height\n}\n\n// SetSize updates the component dimensions and propagates to the list component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_766": {
      "name": "SetSize",
      "type": "method",
      "start_line": 766,
      "end_line": 777,
      "content_hash": "e2e87a434616c50e400ce610d573ccccabb3b5c3",
      "content": "func (m *messageListCmp) SetSize(width int, height int) tea.Cmd {\n\tm.width = width\n\tm.height = height\n\tif m.promptQueue > 0 {\n\t\tqueueHeight := 3 + 1 // 1 for padding top\n\t\tlHight := max(0, height-(1+queueHeight))\n\t\treturn m.listCmp.SetSize(width-2, lHight)\n\t}\n\treturn m.listCmp.SetSize(width-2, max(0, height-1)) // for padding\n}\n\n// Blur implements MessageListCmp.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Blur_778": {
      "name": "Blur",
      "type": "method",
      "start_line": 778,
      "end_line": 782,
      "content_hash": "81de61cd661148e68768abc5cb90518600e3cbf9",
      "content": "func (m *messageListCmp) Blur() tea.Cmd {\n\treturn m.listCmp.Blur()\n}\n\n// Focus implements MessageListCmp.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Focus_783": {
      "name": "Focus",
      "type": "method",
      "start_line": 783,
      "end_line": 787,
      "content_hash": "1af16b58adf7213e2320021dde4b11b6637f29fa",
      "content": "func (m *messageListCmp) Focus() tea.Cmd {\n\treturn m.listCmp.Focus()\n}\n\n// IsFocused implements MessageListCmp.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsFocused_788": {
      "name": "IsFocused",
      "type": "method",
      "start_line": 788,
      "end_line": 791,
      "content_hash": "38ef29b4a8ce659af556228b17502421d296befc",
      "content": "func (m *messageListCmp) IsFocused() bool {\n\treturn m.listCmp.IsFocused()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Bindings_792": {
      "name": "Bindings",
      "type": "method",
      "start_line": 792,
      "end_line": 795,
      "content_hash": "a3eaef67e93374011735ad372472409ec69311c1",
      "content": "func (m *messageListCmp) Bindings() []key.Binding {\n\treturn m.defaultListKeyMap.KeyBindings()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GoToBottom_796": {
      "name": "GoToBottom",
      "type": "method",
      "start_line": 796,
      "end_line": 805,
      "content_hash": "9f96f039fc21ed4f775fa6be31b7988bfe520b37",
      "content": "func (m *messageListCmp) GoToBottom() tea.Cmd {\n\treturn m.listCmp.GoToBottom()\n}\n\nconst (\n\tdoubleClickThreshold = 500 * time.Millisecond\n\tclickTolerance       = 2 // pixels\n)\n\n// handleMouseClick handles mouse click events and detects double/triple clicks.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleMouseClick_806": {
      "name": "handleMouseClick",
      "type": "method",
      "start_line": 806,
      "end_line": 850,
      "content_hash": "feac7820b1cdff0a7141f97ea4d0a3bb2fe26045",
      "content": "func (m *messageListCmp) handleMouseClick(x, y int) tea.Cmd {\n\tnow := time.Now()\n\n\t// Check if this is a click on the continue button\n\tif m.showContinueButton && y == m.continueButtonY {\n\t\t// Check if click is within the button area (left side of the screen)\n\t\tif x >= 2 && x <= 12 { // Button occupies rough area from column 2-12\n\t\t\treturn func() tea.Msg {\n\t\t\t\treturn ContinueClickedMsg{\n\t\t\t\t\tSessionID: m.session.ID,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if this is a potential multi-click\n\tif now.Sub(m.lastClickTime) <= doubleClickThreshold &&\n\t\tabs(x-m.lastClickX) <= clickTolerance &&\n\t\tabs(y-m.lastClickY) <= clickTolerance {\n\t\tm.clickCount++\n\t} else {\n\t\tm.clickCount = 1\n\t}\n\n\tm.lastClickTime = now\n\tm.lastClickX = x\n\tm.lastClickY = y\n\n\tswitch m.clickCount {\n\tcase 1:\n\t\t// Single click - start selection\n\t\tm.listCmp.StartSelection(x, y)\n\tcase 2:\n\t\t// Double click - select word\n\t\tm.listCmp.SelectWord(x, y)\n\tcase 3:\n\t\t// Triple click - select paragraph\n\t\tm.listCmp.SelectParagraph(x, y)\n\t\tm.clickCount = 0 // Reset after triple click\n\t}\n\n\treturn nil\n}\n\n// SelectionClear clears the current selection in the list component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SelectionClear_851": {
      "name": "SelectionClear",
      "type": "method",
      "start_line": 851,
      "end_line": 860,
      "content_hash": "4545a5cf3e2b3cf985e6b1a85fb9e8c5da239d39",
      "content": "func (m *messageListCmp) SelectionClear() tea.Cmd {\n\tm.listCmp.SelectionClear()\n\tm.previousSelected = \"\"\n\tm.lastClickX, m.lastClickY = 0, 0\n\tm.lastClickTime = time.Time{}\n\tm.clickCount = 0\n\treturn nil\n}\n\n// HasSelection checks if there is a selection in the list component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HasSelection_861": {
      "name": "HasSelection",
      "type": "method",
      "start_line": 861,
      "end_line": 865,
      "content_hash": "dfed6ad2c1377b0a22a2355f27d1a4bf89c76190",
      "content": "func (m *messageListCmp) HasSelection() bool {\n\treturn m.listCmp.HasSelection()\n}\n\n// GetSelectedText returns the currently selected text from the list component.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSelectedText_866": {
      "name": "GetSelectedText",
      "type": "method",
      "start_line": 866,
      "end_line": 871,
      "content_hash": "5b8518d6d75e8cc18899e852f7edb2d6f15f1318",
      "content": "func (m *messageListCmp) GetSelectedText() string {\n\treturn m.listCmp.GetSelectedText(3) // 3 padding for the left border/padding\n}\n\n// CopySelectedText copies the currently selected text to the clipboard. When\n// clear is true, it clears the selection after copying.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CopySelectedText_872": {
      "name": "CopySelectedText",
      "type": "method",
      "start_line": 872,
      "end_line": 898,
      "content_hash": "6f30d52376785a24b3ed78621d8c8f5cb7af0288",
      "content": "func (m *messageListCmp) CopySelectedText(clear bool) tea.Cmd {\n\tif !m.listCmp.HasSelection() {\n\t\treturn nil\n\t}\n\n\tselectedText := m.GetSelectedText()\n\tif selectedText == \"\" {\n\t\treturn util.ReportInfo(\"No text selected\")\n\t}\n\n\tif clear {\n\t\tdefer func() { m.SelectionClear() }()\n\t}\n\n\treturn tea.Sequence(\n\t\t// We use both OSC 52 and native clipboard for compatibility with different\n\t\t// terminal emulators and environments.\n\t\ttea.SetClipboard(selectedText),\n\t\tfunc() tea.Msg {\n\t\t\t_ = clipboard.WriteAll(selectedText)\n\t\t\treturn nil\n\t\t},\n\t\tutil.ReportInfo(\"Selected text copied to clipboard\"),\n\t)\n}\n\n// abs returns the absolute value of an integer.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_abs_899": {
      "name": "abs",
      "type": "function",
      "start_line": 899,
      "end_line": 904,
      "content_hash": "c2045b40d087d73371326989562485b7453f8ab6",
      "content": "func abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}