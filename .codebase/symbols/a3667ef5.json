{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/traversal_tests/filter_tests.rs",
  "file_hash": "3f01198f940bd1705736c75a3d00a3c5921a5052",
  "updated_at": "2025-12-26T17:34:21.623599",
  "symbols": {
    "function_setup_test_db_21": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 21,
      "end_line": 33,
      "content_hash": "08bb0f06064d2277b5cf43aecf3c82469d11003e",
      "content": "fn setup_test_db() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let storage = HelixGraphStorage::new(\n        db_path,\n        crate::helix_engine::traversal_core::config::Config::default(),\n        Default::default(),\n    )\n    .unwrap();\n    (temp_dir, Arc::new(storage))\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_nodes_34": {
      "name": "test_filter_nodes",
      "type": "function",
      "start_line": 34,
      "end_line": 75,
      "content_hash": "8960119dad77c887f68ae83cf9e02c7bae214c10",
      "content": "fn test_filter_nodes() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    // Create nodes with different properties\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 25 }), None)\n        .collect_to_obj().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 30 }), None)\n        .collect_to_obj().unwrap();\n    let person3 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 35 }), None)\n        .collect_to_obj().unwrap();\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .filter_ref(|val, _| {\n            if let Ok(TraversalValue::Node(node)) = val {\n                if let Some(value) = node.get_property(\"age\") {\n                    match value {\n                        Value::F64(age) => Ok(*age > 30.0),\n                        Value::I32(age) => Ok(*age > 30),\n                        _ => Ok(false),\n                    }\n                } else {\n                    Ok(false)\n                }\n            } else {\n                Ok(false)\n            }\n        })\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(traversal.len(), 1);\n    assert_eq!(traversal[0].id(), person3.id());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_macro_single_argument_76": {
      "name": "test_filter_macro_single_argument",
      "type": "function",
      "start_line": 76,
      "end_line": 95,
      "content_hash": "8daeb967e791ac925eb8bac5d966714588b4f654",
      "content": "fn test_filter_macro_single_argument() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"person\",\n            props_option(&arena, props! { \"name\" => \"Alice\" }),\n            None,\n        )\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"person\",\n            props_option(&arena, props! { \"name\" => \"Bob\" }),\n            None,\n        )\n        .collect::<Result<Vec<_>,_>>().unwrap();\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_has_name_96": {
      "name": "has_name",
      "type": "function",
      "start_line": 96,
      "end_line": 126,
      "content_hash": "829486a26219425e465e4a52d267c1c8088d2f93",
      "content": "    fn has_name(val: &Result<TraversalValue, GraphError>) -> Result<bool, GraphError> {\n        if let Ok(TraversalValue::Node(node)) = val {\n            Ok(node.get_property(\"name\").is_some())\n        } else {\n            Ok(false)\n        }\n    }\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .filter_ref(|val, _| has_name(val))\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(traversal.len(), 2);\n    assert!(\n        traversal\n            .iter()\n            .any(|val| if let TraversalValue::Node(node) = val {\n                let name = node.get_property(\"name\").unwrap();\n                match name {\n                    Value::String(name) => name == \"Alice\" || name == \"Bob\",\n                    _ => false,\n                }\n            } else {\n                false\n            })\n    );\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_macro_multiple_arguments_127": {
      "name": "test_filter_macro_multiple_arguments",
      "type": "function",
      "start_line": 127,
      "end_line": 139,
      "content_hash": "725c3cbf010e9f8f2d8c995323ca71c8c3a54e1f",
      "content": "fn test_filter_macro_multiple_arguments() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 25 }), None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let person2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 30 }), None)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_age_greater_than_140": {
      "name": "age_greater_than",
      "type": "function",
      "start_line": 140,
      "end_line": 169,
      "content_hash": "c4e3a3609558ddea599132ca737fc200794f3e28",
      "content": "    fn age_greater_than(\n        val: &Result<TraversalValue, GraphError>,\n        min_age: i32,\n    ) -> Result<bool, GraphError> {\n        if let Ok(TraversalValue::Node(node)) = val {\n            if let Some(value) = node.get_property(\"age\") {\n                match value {\n                    Value::F64(age) => Ok(*age > min_age as f64),\n                    Value::I32(age) => Ok(*age > min_age),\n                    _ => Ok(false),\n                }\n            } else {\n                Ok(false)\n            }\n        } else {\n            Ok(false)\n        }\n    }\n\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .filter_ref(|val, _| age_greater_than(val, 27))\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    assert_eq!(traversal.len(), 1);\n    assert_eq!(traversal[0].id(), person2.id());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_edges_170": {
      "name": "test_filter_edges",
      "type": "function",
      "start_line": 170,
      "end_line": 203,
      "content_hash": "56fa07d7b34c9ea0bc23bd98de81b8930c149469",
      "content": "fn test_filter_edges() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let person1 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect_to_obj().unwrap();\n    let person2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect_to_obj().unwrap();\n\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"knows\",\n            props_option(&arena, props! { \"since\" => 2020 }),\n            person1.id(),\n            person2.id(),\n            false,\n        )\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let edge2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"knows\",\n            props_option(&arena, props! { \"since\" => 2022 }),\n            person2.id(),\n            person1.id(),\n            false,\n        )\n        .collect_to_obj().unwrap();\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_recent_edge_204": {
      "name": "recent_edge",
      "type": "function",
      "start_line": 204,
      "end_line": 232,
      "content_hash": "5ee343f2ac9a07ace8763b3f99e713e31cc40211",
      "content": "    fn recent_edge(\n        val: &Result<TraversalValue, GraphError>,\n        year: i32,\n    ) -> Result<bool, GraphError> {\n        if let Ok(TraversalValue::Edge(edge)) = val {\n            if let Some(value) = edge.get_property(\"since\") {\n                match value {\n                    Value::I32(since) => Ok(*since > year),\n                    Value::F64(since) => Ok(*since > year as f64),\n                    _ => Ok(false),\n                }\n            } else {\n                Ok(false)\n            }\n        } else {\n            Ok(false)\n        }\n    }\n\n    let traversal = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .filter_ref(|val, _| recent_edge(val, 2021))\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    assert_eq!(traversal.len(), 1);\n    assert_eq!(traversal[0].id(), edge2.id());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_empty_result_233": {
      "name": "test_filter_empty_result",
      "type": "function",
      "start_line": 233,
      "end_line": 265,
      "content_hash": "0646a625a91441385b22100cbad1db5084f8c212",
      "content": "fn test_filter_empty_result() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 25 }), None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .filter_ref(|val, _| {\n            if let Ok(TraversalValue::Node(node)) = val {\n                if let Some(value) = node.get_property(\"age\") {\n                    match value {\n                        Value::I32(age) => Ok(*age > 100),\n                        Value::F64(age) => Ok(*age > 100.0),\n                        _ => Ok(false),\n                    }\n                } else {\n                    Ok(false)\n                }\n            } else {\n                Ok(false)\n            }\n        })\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert!(traversal.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filter_chain_266": {
      "name": "test_filter_chain",
      "type": "function",
      "start_line": 266,
      "end_line": 291,
      "content_hash": "ed1d8d240d61754d1a0c2d0cff98711e1c102535",
      "content": "fn test_filter_chain() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"person\",\n            props_option(&arena, props! { \"age\" => 25, \"name\" => \"Alice\" }),\n            None,\n        )\n        .collect_to_obj().unwrap();\n    let person2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\n            \"person\",\n            props_option(&arena, props! { \"age\" => 30, \"name\" => \"Bob\" }),\n            None,\n        )\n        .collect_to_obj().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", props_option(&arena, props! { \"age\" => 35 }), None)\n        .collect_to_obj().unwrap();\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_has_name_292": {
      "name": "has_name",
      "type": "function",
      "start_line": 292,
      "end_line": 299,
      "content_hash": "4d2245ac466630c4c8d8530eb7590ea39ef50a91",
      "content": "    fn has_name(val: &Result<TraversalValue, GraphError>) -> Result<bool, GraphError> {\n        if let Ok(TraversalValue::Node(node)) = val {\n            node.get_property(\"name\").map_or(Ok(false), |_| Ok(true))\n        } else {\n            Ok(false)\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_age_greater_than_300": {
      "name": "age_greater_than",
      "type": "function",
      "start_line": 300,
      "end_line": 327,
      "content_hash": "b8b6c477e4d5fd31ada1e7ca37e5da4959470d84",
      "content": "    fn age_greater_than(\n        val: &Result<TraversalValue, GraphError>,\n        min_age: i32,\n    ) -> Result<bool, GraphError> {\n        if let Ok(TraversalValue::Node(node)) = val {\n            if let Some(value) = node.get_property(\"age\") {\n                match value {\n                    Value::F64(age) => Ok(*age > min_age as f64),\n                    Value::I32(age) => Ok(*age > min_age),\n                    _ => Ok(false),\n                }\n            } else {\n                Ok(false)\n            }\n        } else {\n            Ok(false)\n        }\n    }\n\n    let traversal = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\")\n        .filter_ref(|val, _| has_name(val))\n        .filter_ref(|val, _| age_greater_than(val, 27))\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    assert_eq!(traversal.len(), 1);\n    assert_eq!(traversal[0].id(), person2.id());\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}