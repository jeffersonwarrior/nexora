{
  "file_path": "/work/external-deps/helix-db/helix-db/benches/capacity_optimization_benches.rs",
  "file_hash": "2eec96e78fb76bc55d65a6be820b37811ce2e92b",
  "updated_at": "2025-12-26T17:34:21.169423",
  "symbols": {
    "function_search_without_arena_31": {
      "name": "search_without_arena",
      "type": "function",
      "start_line": 31,
      "end_line": 40,
      "content_hash": "652080ce5bd18405fe5de5c0921848b06cb0771e",
      "content": "    fn search_without_arena(\n        bm25: &HBM25Config,\n        txn: &RoTxn,\n        query: &str,\n        limit: usize,\n    ) -> Result<Vec<(u128, f32)>, GraphError> {\n        let arena = Bump::new();\n        bm25.search(txn, query, limit, &arena)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_search_with_arena_41": {
      "name": "search_with_arena",
      "type": "function",
      "start_line": 41,
      "end_line": 50,
      "content_hash": "e57325282a0d07dd77cc0f13b29bead8fd166e4a",
      "content": "    fn search_with_arena(\n        bm25: &HBM25Config,\n        txn: &RoTxn,\n        query: &str,\n        limit: usize,\n        arena: &Bump,\n    ) -> Result<Vec<(u128, f32)>, GraphError> {\n        bm25.search(txn, query, limit, arena)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_test_db_51": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 51,
      "end_line": 91,
      "content_hash": "46f7062241a7a65cbe3b4e748a7d9c154752cb25",
      "content": "    fn setup_test_db() -> (Arc<HelixGraphStorage>, TempDir) {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().to_str().unwrap();\n\n        let mut config = Config::default();\n        config.bm25 = Some(true);\n\n        let storage = HelixGraphStorage::new(db_path, config, Default::default()).unwrap();\n        (Arc::new(storage), temp_dir)\n    }\n\n    // fn setup_db_with_nodes(count: usize) -> (Arc<HelixGraphStorage>, TempDir) {\n    //     let (storage, temp_dir) = setup_test_db();\n    //     let mut txn = storage.graph_env.write_txn().unwrap();\n    //     let arena = Bump::new();\n\n    //     for i in 0..count {\n    //         let props_vec = props! {\n    //             \"name\" => format!(\"User{}\", i),\n    //             \"age\" => (20 + (i % 50)) as i64,\n    //             \"department\" => format!(\"Dept{}\", i % 5),\n    //             \"city\" => format!(\"City{}\", i % 10),\n    //             \"role\" => format!(\"Role{}\", i % 3),\n    //             \"score\" => (i % 100) as i64,\n    //         };\n    //         let props_map = ImmutablePropertiesMap::new(\n    //             props_vec.len(),\n    //             props_vec\n    //                 .iter()\n    //                 .map(|(k, v): &(String, Value)| (arena.alloc_str(k) as &str, v.clone())),\n    //             &arena,\n    //         );\n    //         let _ = G::new_mut(&storage, &arena, &mut txn)\n    //             .add_n(arena.alloc_str(\"User\"), Some(props_map), None)\n    //             .collect_to_obj();\n    //     }\n\n    //     txn.commit().unwrap();\n    //     (storage, temp_dir)\n    // }\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bench_node_connections_arena_vs_capacity_92": {
      "name": "bench_node_connections_arena_vs_capacity",
      "type": "function",
      "start_line": 92,
      "end_line": 293,
      "content_hash": "fa29d51804c7fbe93ee2d9154d6055ed68318e91",
      "content": "    fn bench_node_connections_arena_vs_capacity() {\n        let (storage, _temp_dir) = setup_test_db();\n        let mut txn = storage.graph_env.write_txn().unwrap();\n        let arena_setup = bumpalo::Bump::new();\n\n        let hub_node = G::new_mut(&storage, &arena_setup, &mut txn)\n            .add_n(arena_setup.alloc_str(\"hub\"), None, None)\n            .collect_to_obj()\n            .unwrap();\n\n        // Create 50 connected nodes\n        let mut connected_node_ids = Vec::new();\n        for _i in 0..50 {\n            let node = G::new_mut(&storage, &arena_setup, &mut txn)\n                .add_n(arena_setup.alloc_str(\"person\"), None, None)\n                .collect_to_obj()\n                .unwrap();\n\n            G::new_mut(&storage, &arena_setup, &mut txn)\n                .add_edge(\n                    arena_setup.alloc_str(\"knows\"),\n                    None,\n                    hub_node.id(),\n                    node.id(),\n                    false,\n                )\n                .collect_to_obj()\n                .unwrap();\n\n            connected_node_ids.push(node.id());\n        }\n\n        txn.commit().unwrap();\n\n        // arena without with_capacity\n\n        for _ in 0..20 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n            let mut connected_node_ids = HashSet::new();\n            let mut connected_nodes = Vec::new();\n\n            let _ = storage\n                .out_edges_db\n                .prefix_iter(&rtxn, &hub_node.id().to_be_bytes())\n                .unwrap()\n                .filter_map(|result| match result {\n                    Ok((_, value)) => match HelixGraphStorage::unpack_adj_edge_data(value) {\n                        Ok((edge_id, to_node)) => {\n                            if connected_node_ids.insert(to_node) {\n                                if let Ok(node) = storage.get_node(&rtxn, &to_node, &arena) {\n                                    connected_nodes.push(TraversalValue::Node(node));\n                                }\n                            }\n                            match storage.get_edge(&rtxn, &edge_id, &arena) {\n                                Ok(edge) => Some(TraversalValue::Edge(edge)),\n                                Err(_) => None,\n                            }\n                        }\n                        Err(_) => None,\n                    },\n                    Err(_) => None,\n                })\n                .collect::<Vec<_>>();\n        }\n\n        // arena without with_capacity\n        let mut times_arena_no_capacity = Vec::new();\n        for _ in 0..100 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n\n            let start = Instant::now();\n\n            let mut connected_node_ids = HashSet::new();\n            let mut connected_nodes = Vec::new();\n\n            let _edges = storage\n                .out_edges_db\n                .prefix_iter(&rtxn, &hub_node.id().to_be_bytes())\n                .unwrap()\n                .filter_map(|result| match result {\n                    Ok((_, value)) => match HelixGraphStorage::unpack_adj_edge_data(value) {\n                        Ok((edge_id, to_node)) => {\n                            if connected_node_ids.insert(to_node) {\n                                if let Ok(node) = storage.get_node(&rtxn, &to_node, &arena) {\n                                    connected_nodes.push(TraversalValue::Node(node));\n                                }\n                            }\n                            match storage.get_edge(&rtxn, &edge_id, &arena) {\n                                Ok(edge) => Some(TraversalValue::Edge(edge)),\n                                Err(_) => None,\n                            }\n                        }\n                        Err(_) => None,\n                    },\n                    Err(_) => None,\n                })\n                .collect::<Vec<_>>();\n\n            times_arena_no_capacity.push(start.elapsed().as_micros());\n        }\n\n        // arena with capacity\n        for _ in 0..20 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n            let mut connected_node_ids = HashSet::with_capacity(32);\n            let mut connected_nodes = Vec::with_capacity(32);\n\n            let _ = storage\n                .out_edges_db\n                .prefix_iter(&rtxn, &hub_node.id().to_be_bytes())\n                .unwrap()\n                .filter_map(|result| match result {\n                    Ok((_, value)) => match HelixGraphStorage::unpack_adj_edge_data(value) {\n                        Ok((edge_id, to_node)) => {\n                            if connected_node_ids.insert(to_node) {\n                                if let Ok(node) = storage.get_node(&rtxn, &to_node, &arena) {\n                                    connected_nodes.push(TraversalValue::Node(node));\n                                }\n                            }\n                            match storage.get_edge(&rtxn, &edge_id, &arena) {\n                                Ok(edge) => Some(TraversalValue::Edge(edge)),\n                                Err(_) => None,\n                            }\n                        }\n                        Err(_) => None,\n                    },\n                    Err(_) => None,\n                })\n                .collect::<Vec<_>>();\n        }\n\n        // arena with with_capacity\n        let mut times_arena_with_capacity = Vec::new();\n        for _ in 0..100 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n\n            let start = Instant::now();\n\n            let mut connected_node_ids = HashSet::with_capacity(32);\n            let mut connected_nodes = Vec::with_capacity(32);\n\n            let _edges = storage\n                .out_edges_db\n                .prefix_iter(&rtxn, &hub_node.id().to_be_bytes())\n                .unwrap()\n                .filter_map(|result| match result {\n                    Ok((_, value)) => match HelixGraphStorage::unpack_adj_edge_data(value) {\n                        Ok((edge_id, to_node)) => {\n                            if connected_node_ids.insert(to_node) {\n                                if let Ok(node) = storage.get_node(&rtxn, &to_node, &arena) {\n                                    connected_nodes.push(TraversalValue::Node(node));\n                                }\n                            }\n                            match storage.get_edge(&rtxn, &edge_id, &arena) {\n                                Ok(edge) => Some(TraversalValue::Edge(edge)),\n                                Err(_) => None,\n                            }\n                        }\n                        Err(_) => None,\n                    },\n                    Err(_) => None,\n                })\n                .collect::<Vec<_>>();\n\n            times_arena_with_capacity.push(start.elapsed().as_micros());\n        }\n\n        times_arena_no_capacity.sort_unstable();\n        times_arena_with_capacity.sort_unstable();\n\n        let no_capacity_median = times_arena_no_capacity[times_arena_no_capacity.len() / 2];\n        let with_capacity_median = times_arena_with_capacity[times_arena_with_capacity.len() / 2];\n\n        let no_capacity_avg: u128 =\n            times_arena_no_capacity.iter().sum::<u128>() / times_arena_no_capacity.len() as u128;\n        let with_capacity_avg: u128 = times_arena_with_capacity.iter().sum::<u128>()\n            / times_arena_with_capacity.len() as u128;\n\n        let improvement_median = ((no_capacity_median as f64 - with_capacity_median as f64)\n            / no_capacity_median as f64)\n            * 100.0;\n        let improvement_avg =\n            ((no_capacity_avg as f64 - with_capacity_avg as f64) / no_capacity_avg as f64) * 100.0;\n\n        println!(\"   Arena WITHOUT with_capacity:\");\n        println!(\"     \u2022 Average: {}\u03bcs\", no_capacity_avg);\n        println!(\"     \u2022 Median:  {}\u03bcs\\n\", no_capacity_median);\n\n        println!(\"   Arena WITH with_capacity(32):\");\n        println!(\"     \u2022 Average: {}\u03bcs\", with_capacity_avg);\n        println!(\"     \u2022 Median:  {}\u03bcs\\n\", with_capacity_median);\n\n        println!(\"    Improvement:\");\n        println!(\"     \u2022 Average: {:.1}% faster\", improvement_avg);\n        println!(\"     \u2022 Median:  {:.1}% faster\\n\", improvement_median);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bench_nodes_by_label_with_excessive_limit_294": {
      "name": "bench_nodes_by_label_with_excessive_limit",
      "type": "function",
      "start_line": 294,
      "end_line": 377,
      "content_hash": "10f023e75529544ecd7510ed344b1021df58c494",
      "content": "    fn bench_nodes_by_label_with_excessive_limit() {\n        use helix_db::utils::items::Node;\n\n        let (storage, _temp_dir) = setup_test_db();\n        let mut txn = storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        // Insert only 100 nodes\n        println!(\"\\nInserting 100 person nodes...\");\n        for _i in 0..100 {\n            let _node = G::new_mut(&storage, &arena, &mut txn)\n                .add_n(arena.alloc_str(\"person\"), None, None)\n                .collect_to_obj()\n                .unwrap();\n        }\n        txn.commit().unwrap();\n\n        println!(\"test capacity optimization with excessive limit (10M) on 100 nodes...\");\n\n        const MAX_PREALLOCATE_CAPACITY: usize = 100_000;\n\n        // Test without capacity optimization\n        let mut times_no_capacity = Vec::new();\n        for _ in 0..50 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n            let start = Instant::now();\n\n            let mut nodes = Vec::new();\n            for result in storage.nodes_db.iter(&rtxn).unwrap() {\n                let (id, node_data) = result.unwrap();\n                if let Ok(node) = Node::from_bincode_bytes(id, node_data, &arena) {\n                    if node.label == \"person\" {\n                        nodes.push(node);\n                    }\n                }\n            }\n            times_no_capacity.push(start.elapsed().as_micros());\n        }\n\n        // test with capacity optimization\n        let mut times_with_capacity = Vec::new();\n        for _ in 0..50 {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n            let arena = bumpalo::Bump::new();\n            let start = Instant::now();\n\n            let limit = 10_000_000;\n            let initial_capacity = if limit <= MAX_PREALLOCATE_CAPACITY {\n                limit\n            } else {\n                MAX_PREALLOCATE_CAPACITY\n            };\n\n            let mut nodes = Vec::with_capacity(initial_capacity);\n            for result in storage.nodes_db.iter(&rtxn).unwrap() {\n                let (id, node_data) = result.unwrap();\n                if let Ok(node) = Node::from_bincode_bytes(id, node_data, &arena) {\n                    if node.label == \"person\" {\n                        nodes.push(node);\n                    }\n                }\n            }\n            times_with_capacity.push(start.elapsed().as_micros());\n        }\n\n        times_no_capacity.sort_unstable();\n        times_with_capacity.sort_unstable();\n\n        let no_cap_median = times_no_capacity[times_no_capacity.len() / 2];\n        let with_cap_median = times_with_capacity[times_with_capacity.len() / 2];\n\n        let improvement =\n            ((no_cap_median as f64 - with_cap_median as f64) / no_cap_median as f64) * 100.0;\n\n        println!(\"   Without capacity: {}\u03bcs (median)\", no_cap_median);\n        println!(\n            \"   With capacity({}): {}\u03bcs (median)\",\n            MAX_PREALLOCATE_CAPACITY, with_cap_median\n        );\n        println!(\"   Improvement: {:.1}% faster\\n\", improvement);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bench_bm25_search_before_and_after_378": {
      "name": "bench_bm25_search_before_and_after",
      "type": "function",
      "start_line": 378,
      "end_line": 513,
      "content_hash": "324f88145cd01f7f5d12a9c2f212d701181350fd",
      "content": "    fn bench_bm25_search_before_and_after() {\n        let (storage, _temp_dir) = setup_test_db();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n        let bm25 = storage.bm25.as_ref().unwrap();\n\n        // insert 10,000 documents\n        for i in 0..10_000 {\n            let doc = format!(\n                \"Document {} database search optimization performance query index benchmark test {}\",\n                i,\n                i % 100\n            );\n            bm25.insert_doc(&mut wtxn, v6_uuid(), &doc).unwrap();\n        }\n        wtxn.commit().unwrap();\n\n        let test_case = vec![\n            (\"Simple (1 term)\", \"database\", 100),\n            (\"Medium (3 terms)\", \"database search optimization\", 100),\n            (\n                \"Complex (5 terms)\",\n                \"database search optimization performance benchmark\",\n                100,\n            ),\n        ];\n\n        println!(\"\\n Running benchmarks (100 iterations each)...\\n\");\n\n        for (name, query, limit) in test_case {\n            let rtxn = storage.graph_env.read_txn().unwrap();\n\n            // without arena implementation\n            for _ in 0..50 {\n                let _results = search_without_arena(bm25, &rtxn, query, limit).unwrap();\n            }\n\n            //  without arena implementation\n            let mut before_times = Vec::new();\n            for _ in 0..500 {\n                let start = Instant::now();\n                let _results = search_without_arena(bm25, &rtxn, query, limit).unwrap();\n                before_times.push(start.elapsed().as_micros());\n            }\n\n            for _ in 0..50 {\n                let arena = Bump::new();\n                let _ = bm25.search(&rtxn, query, limit, &arena).unwrap();\n            }\n\n            //  with arena implementation\n            let mut after_times = Vec::new();\n            for _ in 0..500 {\n                let arena = Bump::new();\n                let start = Instant::now();\n                let _results = search_with_arena(bm25, &rtxn, query, limit, &arena).unwrap();\n                after_times.push(start.elapsed().as_micros());\n            }\n\n            let before_avg = before_times.iter().sum::<u128>() / before_times.len() as u128;\n            let after_avg = after_times.iter().sum::<u128>() / after_times.len() as u128;\n\n            before_times.sort_unstable();\n            after_times.sort_unstable();\n            let before_median = before_times[before_times.len() / 2];\n            let after_median = after_times[after_times.len() / 2];\n\n            let before_stddev = calculate_stddev(&before_times, before_avg);\n            let after_stddev = calculate_stddev(&after_times, after_avg);\n\n            let improvement_avg =\n                ((before_avg as f64 - after_avg as f64) / before_avg as f64) * 100.0;\n            let improvement_median =\n                ((before_median as f64 - after_median as f64) / before_median as f64) * 100.0;\n\n            println!(\" {}\", name);\n            println!(\n                \"   Before: {}\u03bcs avg (\u00b1{}\u03bcs) | {}\u03bcs median\",\n                before_avg, before_stddev, before_median\n            );\n            println!(\n                \"   After:  {}\u03bcs avg (\u00b1{}\u03bcs) | {}\u03bcs median\",\n                after_avg, after_stddev, after_median\n            );\n            println!(\n                \"   Improvement: {:.1}% (avg) | {:.1}% (median)\\n\",\n                improvement_avg, improvement_median\n            );\n        }\n\n        println!(\"Impact of Result Limit: \");\n        let rtxn = storage.graph_env.read_txn().unwrap();\n\n        for limit in [10, 100, 1000] {\n            // Warmup\n            for _ in 0..50 {\n                let _ = search_without_arena(bm25, &rtxn, \"database optimization\", limit).unwrap();\n                let arena = Bump::new();\n                let _ = bm25\n                    .search(&rtxn, \"database optimization\", limit, &arena)\n                    .unwrap();\n            }\n\n            let mut before_times = Vec::new();\n            for _ in 0..500 {\n                let start = Instant::now();\n                let _ = search_without_arena(bm25, &rtxn, \"database optimization\", limit).unwrap();\n                before_times.push(start.elapsed().as_micros());\n            }\n            let before_median = {\n                before_times.sort_unstable();\n                before_times[before_times.len() / 2]\n            };\n\n            let mut after_times = Vec::new();\n            for _ in 0..500 {\n                let arena = Bump::new();\n                let start = Instant::now();\n                let _ = bm25\n                    .search(&rtxn, \"database optimization\", limit, &arena)\n                    .unwrap();\n                after_times.push(start.elapsed().as_micros());\n            }\n            let after_median = {\n                after_times.sort_unstable();\n                after_times[after_times.len() / 2]\n            };\n\n            let improvement =\n                ((before_median as f64 - after_median as f64) / before_median as f64) * 100.0;\n\n            println!(\n                \"   limit={:4} \u2192 Before: {}\u03bcs, After: {}\u03bcs ({:.1}% faster)\",\n                limit, before_median, after_median, improvement\n            );\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_calculate_stddev_514": {
      "name": "calculate_stddev",
      "type": "function",
      "start_line": 514,
      "end_line": 525,
      "content_hash": "4089ad207c038984aedcb542958601a0dcfae722",
      "content": "    fn calculate_stddev(times: &[u128], mean: u128) -> u128 {\n        let variance = times\n            .iter()\n            .map(|&t| {\n                let diff = if t > mean { t - mean } else { mean - t };\n                diff * diff\n            })\n            .sum::<u128>()\n            / times.len() as u128;\n        (variance as f64).sqrt() as u128\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}