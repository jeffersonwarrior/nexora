{
  "file_path": "/work/internal/tui/exp/list/list.go",
  "file_hash": "71b98ad70bad818d9240cc6823e00c5558ed919f",
  "updated_at": "2025-12-26T17:34:20.558026",
  "symbols": {
    "function_getSpecialCharsMap_29": {
      "name": "getSpecialCharsMap",
      "type": "function",
      "start_line": 29,
      "end_line": 38,
      "content_hash": "1a299d30e1c6b5cdb6b78279e12d014df037b2d7",
      "content": "func getSpecialCharsMap() map[string]struct{} {\n\tspecialCharsOnce.Do(func() {\n\t\tspecialCharsMap = make(map[string]struct{}, len(styles.SelectionIgnoreIcons))\n\t\tfor _, icon := range styles.SelectionIgnoreIcons {\n\t\t\tspecialCharsMap[icon] = struct{}{}\n\t\t}\n\t})\n\treturn specialCharsMap\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_Item_39": {
      "name": "Item",
      "type": "interface",
      "start_line": 39,
      "end_line": 44,
      "content_hash": "7a53dac4f5a5f56a0a7443c3ffd4132b9c77a209",
      "content": "type Item interface {\n\tutil.Model\n\tcore.Sizeable\n\tID() string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_HasAnim_45": {
      "name": "HasAnim",
      "type": "interface",
      "start_line": 45,
      "end_line": 90,
      "content_hash": "5828ebc3ceabe2ebea865b4252c5ebc0935dab0a",
      "content": "type HasAnim interface {\n\tItem\n\tSpinning() bool\n}\n\ntype List[T Item] interface {\n\tutil.Model\n\tcore.Sizeable\n\tcore.Focusable\n\n\tMoveUp(int) tea.Cmd\n\tMoveDown(int) tea.Cmd\n\tGoToTop() tea.Cmd\n\tGoToBottom() tea.Cmd\n\tSelectItemAbove() tea.Cmd\n\tSelectItemBelow() tea.Cmd\n\tSetItems([]T) tea.Cmd\n\tSetSelected(string) tea.Cmd\n\tSelectedItem() *T\n\tItems() []T\n\tUpdateItem(string, T) tea.Cmd\n\tDeleteItem(string) tea.Cmd\n\tPrependItem(T) tea.Cmd\n\tAppendItem(T) tea.Cmd\n\tStartSelection(col, line int)\n\tEndSelection(col, line int)\n\tSelectionStop()\n\tSelectionClear()\n\tSelectWord(col, line int)\n\tSelectParagraph(col, line int)\n\tGetSelectedText(paddingLeft int) string\n\tHasSelection() bool\n}\n\ntype direction int\n\nconst (\n\tDirectionForward direction = iota\n\tDirectionBackward\n)\n\nconst (\n\tItemNotFound              = -1\n\tViewportDefaultScrollSize = 5\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_renderedItem_91": {
      "name": "renderedItem",
      "type": "struct",
      "start_line": 91,
      "end_line": 97,
      "content_hash": "8fe26b2e72f70a2fa820bfce05071af61a13b0eb",
      "content": "type renderedItem struct {\n\tview   string\n\theight int\n\tstart  int\n\tend    int\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_confOptions_98": {
      "name": "confOptions",
      "type": "struct",
      "start_line": 98,
      "end_line": 140,
      "content_hash": "fe871504c7ee2c47105613a3a33df6ae7b2aea50",
      "content": "type confOptions struct {\n\twidth, height   int\n\tgap             int\n\twrap            bool\n\tkeyMap          KeyMap\n\tdirection       direction\n\tselectedItemIdx int    // Index of selected item (-1 if none)\n\tselectedItemID  string // Temporary storage for WithSelectedItem (resolved in New())\n\tfocused         bool\n\tresize          bool\n\tenableMouse     bool\n}\n\ntype list[T Item] struct {\n\t*confOptions\n\n\toffset int\n\n\tindexMap      map[string]int\n\titems         []T\n\trenderedItems map[string]renderedItem\n\n\trendered       string\n\trenderedHeight int   // cached height of rendered content\n\tlineOffsets    []int // cached byte offsets for each line (for fast slicing)\n\n\tcachedView       string\n\tcachedViewOffset int\n\tcachedViewDirty  bool\n\n\tmovingByItem        bool\n\tprevSelectedItemIdx int // Index of previously selected item (-1 if none)\n\tselectionStartCol   int\n\tselectionStartLine  int\n\tselectionEndCol     int\n\tselectionEndLine    int\n\n\tselectionActive bool\n}\n\ntype ListOption func(*confOptions)\n\n// WithSize sets the size of the list.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithSize_141": {
      "name": "WithSize",
      "type": "function",
      "start_line": 141,
      "end_line": 148,
      "content_hash": "55b88a8db3b3eeb518454bb668eb537682c7b39a",
      "content": "func WithSize(width, height int) ListOption {\n\treturn func(l *confOptions) {\n\t\tl.width = width\n\t\tl.height = height\n\t}\n}\n\n// WithGap sets the gap between items in the list.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithGap_149": {
      "name": "WithGap",
      "type": "function",
      "start_line": 149,
      "end_line": 155,
      "content_hash": "c179843baec45507d444d9793d042219f565fcc0",
      "content": "func WithGap(gap int) ListOption {\n\treturn func(l *confOptions) {\n\t\tl.gap = gap\n\t}\n}\n\n// WithDirectionForward sets the direction to forward",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithDirectionForward_156": {
      "name": "WithDirectionForward",
      "type": "function",
      "start_line": 156,
      "end_line": 162,
      "content_hash": "e3686fc733bba886769adf204236b2be49d19509",
      "content": "func WithDirectionForward() ListOption {\n\treturn func(l *confOptions) {\n\t\tl.direction = DirectionForward\n\t}\n}\n\n// WithDirectionBackward sets the direction to forward",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithDirectionBackward_163": {
      "name": "WithDirectionBackward",
      "type": "function",
      "start_line": 163,
      "end_line": 169,
      "content_hash": "d854d85946943d31b93e2c685a3b431c10579409",
      "content": "func WithDirectionBackward() ListOption {\n\treturn func(l *confOptions) {\n\t\tl.direction = DirectionBackward\n\t}\n}\n\n// WithSelectedItem sets the initially selected item in the list.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithSelectedItem_170": {
      "name": "WithSelectedItem",
      "type": "function",
      "start_line": 170,
      "end_line": 175,
      "content_hash": "8b9ddfab8cbc1562955962ed4c7b1c7cded3b8ac",
      "content": "func WithSelectedItem(id string) ListOption {\n\treturn func(l *confOptions) {\n\t\tl.selectedItemID = id // Will be resolved to index in New()\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithKeyMap_176": {
      "name": "WithKeyMap",
      "type": "function",
      "start_line": 176,
      "end_line": 181,
      "content_hash": "e306390ac74252970cd21c63ee331f4cd0f834c6",
      "content": "func WithKeyMap(keyMap KeyMap) ListOption {\n\treturn func(l *confOptions) {\n\t\tl.keyMap = keyMap\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithWrapNavigation_182": {
      "name": "WithWrapNavigation",
      "type": "function",
      "start_line": 182,
      "end_line": 187,
      "content_hash": "80979f51e8c5f2b337e5f0f31d3345bae6fbdc64",
      "content": "func WithWrapNavigation() ListOption {\n\treturn func(l *confOptions) {\n\t\tl.wrap = true\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithFocus_188": {
      "name": "WithFocus",
      "type": "function",
      "start_line": 188,
      "end_line": 193,
      "content_hash": "bd8b65bf55a85170723c651a735115c57ef834e5",
      "content": "func WithFocus(focus bool) ListOption {\n\treturn func(l *confOptions) {\n\t\tl.focused = focus\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithResizeByList_194": {
      "name": "WithResizeByList",
      "type": "function",
      "start_line": 194,
      "end_line": 199,
      "content_hash": "11ae8297f401e2d0cb92ceb2c08cd3dd58e5a7b3",
      "content": "func WithResizeByList() ListOption {\n\treturn func(l *confOptions) {\n\t\tl.resize = true\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithEnableMouse_200": {
      "name": "WithEnableMouse",
      "type": "function",
      "start_line": 200,
      "end_line": 364,
      "content_hash": "c88337daa0db325d6e6407a6bbf17a90a67705e5",
      "content": "func WithEnableMouse() ListOption {\n\treturn func(l *confOptions) {\n\t\tl.enableMouse = true\n\t}\n}\n\nfunc New[T Item](items []T, opts ...ListOption) List[T] {\n\tlist := &list[T]{\n\t\tconfOptions: &confOptions{\n\t\t\tdirection:       DirectionForward,\n\t\t\tkeyMap:          DefaultKeyMap(),\n\t\t\tfocused:         true,\n\t\t\tselectedItemIdx: -1,\n\t\t},\n\t\titems:               items,\n\t\tindexMap:            make(map[string]int, len(items)),\n\t\trenderedItems:       make(map[string]renderedItem),\n\t\tprevSelectedItemIdx: -1,\n\t\tselectionStartCol:   -1,\n\t\tselectionStartLine:  -1,\n\t\tselectionEndLine:    -1,\n\t\tselectionEndCol:     -1,\n\t}\n\tfor _, opt := range opts {\n\t\topt(list.confOptions)\n\t}\n\n\tfor inx, item := range items {\n\t\tif i, ok := any(item).(Indexable); ok {\n\t\t\ti.SetIndex(inx)\n\t\t}\n\t\tlist.indexMap[item.ID()] = inx\n\t}\n\n\t// Resolve selectedItemID to selectedItemIdx if specified\n\tif list.selectedItemID != \"\" {\n\t\tif idx, ok := list.indexMap[list.selectedItemID]; ok {\n\t\t\tlist.selectedItemIdx = idx\n\t\t}\n\t\tlist.selectedItemID = \"\" // Clear temporary storage\n\t}\n\n\treturn list\n}\n\n// Init implements List.\nfunc (l *list[T]) Init() tea.Cmd {\n\treturn l.render()\n}\n\n// Update implements List.\nfunc (l *list[T]) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.MouseWheelMsg:\n\t\tif l.enableMouse {\n\t\t\treturn l.handleMouseWheel(msg)\n\t\t}\n\t\treturn l, nil\n\tcase anim.StepMsg:\n\t\t// Fast path: if no items, skip processing\n\t\tif len(l.items) == 0 {\n\t\t\treturn l, nil\n\t\t}\n\n\t\t// Fast path: check if ANY items are actually spinning before processing\n\t\tif !l.hasSpinningItems() {\n\t\t\treturn l, nil\n\t\t}\n\n\t\tvar cmds []tea.Cmd\n\t\titemsLen := len(l.items)\n\t\tfor i := range itemsLen {\n\t\t\tif i >= len(l.items) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\titem := l.items[i]\n\t\t\tif animItem, ok := any(item).(HasAnim); ok && animItem.Spinning() {\n\t\t\t\tupdated, cmd := animItem.Update(msg)\n\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t\tif u, ok := updated.(T); ok {\n\t\t\t\t\tcmds = append(cmds, l.UpdateItem(u.ID(), u))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn l, tea.Batch(cmds...)\n\tcase tea.KeyPressMsg:\n\t\tif l.focused {\n\t\t\tswitch {\n\t\t\tcase key.Matches(msg, l.keyMap.Down):\n\t\t\t\treturn l, l.MoveDown(ViewportDefaultScrollSize)\n\t\t\tcase key.Matches(msg, l.keyMap.Up):\n\t\t\t\treturn l, l.MoveUp(ViewportDefaultScrollSize)\n\t\t\tcase key.Matches(msg, l.keyMap.DownOneItem):\n\t\t\t\treturn l, l.SelectItemBelow()\n\t\t\tcase key.Matches(msg, l.keyMap.UpOneItem):\n\t\t\t\treturn l, l.SelectItemAbove()\n\t\t\tcase key.Matches(msg, l.keyMap.HalfPageDown):\n\t\t\t\treturn l, l.MoveDown(l.height / 2)\n\t\t\tcase key.Matches(msg, l.keyMap.HalfPageUp):\n\t\t\t\treturn l, l.MoveUp(l.height / 2)\n\t\t\tcase key.Matches(msg, l.keyMap.PageDown):\n\t\t\t\treturn l, l.MoveDown(l.height)\n\t\t\tcase key.Matches(msg, l.keyMap.PageUp):\n\t\t\t\treturn l, l.MoveUp(l.height)\n\t\t\tcase key.Matches(msg, l.keyMap.End):\n\t\t\t\treturn l, l.GoToBottom()\n\t\t\tcase key.Matches(msg, l.keyMap.Home):\n\t\t\t\treturn l, l.GoToTop()\n\t\t\t}\n\t\t\ts := l.SelectedItem()\n\t\t\tif s == nil {\n\t\t\t\treturn l, nil\n\t\t\t}\n\t\t\titem := *s\n\t\t\tvar cmds []tea.Cmd\n\t\t\tupdated, cmd := item.Update(msg)\n\t\t\tcmds = append(cmds, cmd)\n\t\t\tif u, ok := updated.(T); ok {\n\t\t\t\tcmds = append(cmds, l.UpdateItem(u.ID(), u))\n\t\t\t}\n\t\t\treturn l, tea.Batch(cmds...)\n\t\t}\n\t}\n\treturn l, nil\n}\n\nfunc (l *list[T]) handleMouseWheel(msg tea.MouseWheelMsg) (util.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tswitch msg.Button {\n\tcase tea.MouseWheelDown:\n\t\tcmd = l.MoveDown(ViewportDefaultScrollSize)\n\tcase tea.MouseWheelUp:\n\t\tcmd = l.MoveUp(ViewportDefaultScrollSize)\n\t}\n\treturn l, cmd\n}\n\nfunc (l *list[T]) hasSpinningItems() bool {\n\tfor i := range l.items {\n\t\titem := l.items[i]\n\t\tif animItem, ok := any(item).(HasAnim); ok && animItem.Spinning() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (l *list[T]) selectionView(view string, textOnly bool) string {\n\tt := styles.CurrentTheme()\n\tarea := uv.Rect(0, 0, l.width, l.height)\n\tscr := uv.NewScreenBuffer(area.Dx(), area.Dy())\n\tuv.NewStyledString(view).Draw(scr, area)\n\n\tselArea := uv.Rectangle{\n\t\tMin: uv.Pos(l.selectionStartCol, l.selectionStartLine),\n\t\tMax: uv.Pos(l.selectionEndCol, l.selectionEndLine),\n\t}\n\tselArea = selArea.Canon()\n\n\tspecialChars := getSpecialCharsMap()\n\n\tisNonWhitespace := func(r rune) bool {\n\t\treturn r != ' ' && r != '\\t' && r != 0 && r != '\\n' && r != '\\r'\n\t}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_selectionBounds_365": {
      "name": "selectionBounds",
      "type": "struct",
      "start_line": 365,
      "end_line": 396,
      "content_hash": "ccf1187539b20363784dace861d54dd808153cd4",
      "content": "\ttype selectionBounds struct {\n\t\tstartX, endX int\n\t\tinSelection  bool\n\t}\n\tlineSelections := make([]selectionBounds, scr.Height())\n\n\tfor y := range scr.Height() {\n\t\tbounds := selectionBounds{startX: -1, endX: -1, inSelection: false}\n\n\t\tif y >= selArea.Min.Y && y <= selArea.Max.Y {\n\t\t\tbounds.inSelection = true\n\t\t\tif selArea.Min.Y == selArea.Max.Y {\n\t\t\t\t// Single line selection\n\t\t\t\tbounds.startX = selArea.Min.X\n\t\t\t\tbounds.endX = selArea.Max.X\n\t\t\t} else if y == selArea.Min.Y {\n\t\t\t\t// First line of multi-line selection\n\t\t\t\tbounds.startX = selArea.Min.X\n\t\t\t\tbounds.endX = scr.Width()\n\t\t\t} else if y == selArea.Max.Y {\n\t\t\t\t// Last line of multi-line selection\n\t\t\t\tbounds.startX = 0\n\t\t\t\tbounds.endX = selArea.Max.X\n\t\t\t} else {\n\t\t\t\t// Middle lines\n\t\t\t\tbounds.startX = 0\n\t\t\t\tbounds.endX = scr.Width()\n\t\t\t}\n\t\t}\n\t\tlineSelections[y] = bounds\n\t}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_lineBounds_397": {
      "name": "lineBounds",
      "type": "struct",
      "start_line": 397,
      "end_line": 950,
      "content_hash": "716a558b64609619fa84330e8de72995321c6f65",
      "content": "\ttype lineBounds struct {\n\t\tstart, end int\n\t}\n\tlineTextBounds := make([]lineBounds, scr.Height())\n\n\t// First pass: find text bounds for lines that have selections\n\tfor y := range scr.Height() {\n\t\tbounds := lineBounds{start: -1, end: -1}\n\n\t\t// Only process lines that might have selections\n\t\tif lineSelections[y].inSelection {\n\t\t\tfor x := range scr.Width() {\n\t\t\t\tcell := scr.CellAt(x, y)\n\t\t\t\tif cell == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tcellStr := cell.String()\n\t\t\t\tif len(cellStr) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tchar := rune(cellStr[0])\n\t\t\t\t_, isSpecial := specialChars[cellStr]\n\n\t\t\t\tif (isNonWhitespace(char) && !isSpecial) || cell.Style.Bg != nil {\n\t\t\t\t\tif bounds.start == -1 {\n\t\t\t\t\t\tbounds.start = x\n\t\t\t\t\t}\n\t\t\t\t\tbounds.end = x + 1 // Position after last character\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlineTextBounds[y] = bounds\n\t}\n\n\tvar selectedText strings.Builder\n\n\t// Second pass: apply selection highlighting\n\tfor y := range scr.Height() {\n\t\tselBounds := lineSelections[y]\n\t\tif !selBounds.inSelection {\n\t\t\tcontinue\n\t\t}\n\n\t\ttextBounds := lineTextBounds[y]\n\t\tif textBounds.start < 0 {\n\t\t\tif textOnly {\n\t\t\t\t// We don't want to get rid of all empty lines in text-only mode\n\t\t\t\tselectedText.WriteByte('\\n')\n\t\t\t}\n\n\t\t\tcontinue // No text on this line\n\t\t}\n\n\t\t// Only scan within the intersection of text bounds and selection bounds\n\t\tscanStart := max(textBounds.start, selBounds.startX)\n\t\tscanEnd := min(textBounds.end, selBounds.endX)\n\n\t\tfor x := scanStart; x < scanEnd; x++ {\n\t\t\tcell := scr.CellAt(x, y)\n\t\t\tif cell == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcellStr := cell.String()\n\t\t\tif len(cellStr) > 0 {\n\t\t\t\tif _, isSpecial := specialChars[cellStr]; isSpecial {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif textOnly {\n\t\t\t\t\t// Collect selected text without styles\n\t\t\t\t\tselectedText.WriteString(cell.String())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Text selection styling, which is a Lip Gloss style. We must\n\t\t\t\t// extract the values to use in a UV style, below.\n\t\t\t\tts := t.TextSelection\n\n\t\t\t\tcell = cell.Clone()\n\t\t\t\tcell.Style.Bg = ts.GetBackground()\n\t\t\t\tcell.Style.Fg = ts.GetForeground()\n\t\t\t\tscr.SetCell(x, y, cell)\n\t\t\t}\n\t\t}\n\n\t\tif textOnly {\n\t\t\t// Make sure we add a newline after each line of selected text\n\t\t\tselectedText.WriteByte('\\n')\n\t\t}\n\t}\n\n\tif textOnly {\n\t\treturn strings.TrimSpace(selectedText.String())\n\t}\n\n\treturn scr.Render()\n}\n\nfunc (l *list[T]) View() string {\n\tif l.height <= 0 || l.width <= 0 {\n\t\treturn \"\"\n\t}\n\n\tif !l.cachedViewDirty && l.cachedViewOffset == l.offset && !l.hasSelection() && l.cachedView != \"\" {\n\t\treturn l.cachedView\n\t}\n\n\tt := styles.CurrentTheme()\n\n\tstart, end := l.viewPosition()\n\tviewStart := max(0, start)\n\tviewEnd := end\n\n\tif viewStart > viewEnd {\n\t\treturn \"\"\n\t}\n\n\tview := l.getLines(viewStart, viewEnd)\n\n\tif l.resize {\n\t\treturn view\n\t}\n\n\tview = t.S().Base.\n\t\tHeight(l.height).\n\t\tWidth(l.width).\n\t\tRender(view)\n\n\tif !l.hasSelection() {\n\t\tl.cachedView = view\n\t\tl.cachedViewOffset = l.offset\n\t\tl.cachedViewDirty = false\n\t\treturn view\n\t}\n\n\treturn l.selectionView(view, false)\n}\n\nfunc (l *list[T]) viewPosition() (int, int) {\n\tstart, end := 0, 0\n\trenderedLines := l.renderedHeight - 1\n\tif l.direction == DirectionForward {\n\t\tstart = max(0, l.offset)\n\t\tend = min(l.offset+l.height-1, renderedLines)\n\t} else {\n\t\tstart = max(0, renderedLines-l.offset-l.height+1)\n\t\tend = max(0, renderedLines-l.offset)\n\t}\n\tstart = min(start, end)\n\treturn start, end\n}\n\nfunc (l *list[T]) setRendered(rendered string) {\n\tl.rendered = rendered\n\tl.renderedHeight = lipgloss.Height(rendered)\n\tl.cachedViewDirty = true // Mark view cache as dirty\n\n\tif len(rendered) > 0 {\n\t\tl.lineOffsets = make([]int, 0, l.renderedHeight)\n\t\tl.lineOffsets = append(l.lineOffsets, 0)\n\n\t\toffset := 0\n\t\tfor {\n\t\t\tidx := strings.IndexByte(rendered[offset:], '\\n')\n\t\t\tif idx == -1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toffset += idx + 1\n\t\t\tl.lineOffsets = append(l.lineOffsets, offset)\n\t\t}\n\t} else {\n\t\tl.lineOffsets = nil\n\t}\n}\n\nfunc (l *list[T]) getLines(start, end int) string {\n\tif len(l.lineOffsets) == 0 || start >= len(l.lineOffsets) {\n\t\treturn \"\"\n\t}\n\n\tif end >= len(l.lineOffsets) {\n\t\tend = len(l.lineOffsets) - 1\n\t}\n\tif start > end {\n\t\treturn \"\"\n\t}\n\n\tstartOffset := l.lineOffsets[start]\n\tvar endOffset int\n\tif end+1 < len(l.lineOffsets) {\n\t\tendOffset = l.lineOffsets[end+1] - 1\n\t} else {\n\t\tendOffset = len(l.rendered)\n\t}\n\n\tif startOffset >= len(l.rendered) {\n\t\treturn \"\"\n\t}\n\tendOffset = min(endOffset, len(l.rendered))\n\n\treturn l.rendered[startOffset:endOffset]\n}\n\n// getLine returns a single line from the rendered content using lineOffsets.\n// This avoids allocating a new string for each line like strings.Split does.\nfunc (l *list[T]) getLine(index int) string {\n\tif len(l.lineOffsets) == 0 || index < 0 || index >= len(l.lineOffsets) {\n\t\treturn \"\"\n\t}\n\n\tstartOffset := l.lineOffsets[index]\n\tvar endOffset int\n\tif index+1 < len(l.lineOffsets) {\n\t\tendOffset = l.lineOffsets[index+1] - 1 // -1 to exclude the newline\n\t} else {\n\t\tendOffset = len(l.rendered)\n\t}\n\n\tif startOffset >= len(l.rendered) {\n\t\treturn \"\"\n\t}\n\tendOffset = min(endOffset, len(l.rendered))\n\n\treturn l.rendered[startOffset:endOffset]\n}\n\n// lineCount returns the number of lines in the rendered content.\nfunc (l *list[T]) lineCount() int {\n\treturn len(l.lineOffsets)\n}\n\nfunc (l *list[T]) recalculateItemPositions() {\n\tl.recalculateItemPositionsFrom(0)\n}\n\nfunc (l *list[T]) recalculateItemPositionsFrom(startIdx int) {\n\tvar currentContentHeight int\n\n\tif startIdx > 0 && startIdx <= len(l.items) {\n\t\tprevItem := l.items[startIdx-1]\n\t\tif rItem, ok := l.renderedItems[prevItem.ID()]; ok {\n\t\t\tcurrentContentHeight = rItem.end + 1 + l.gap\n\t\t}\n\t}\n\n\tfor i := startIdx; i < len(l.items); i++ {\n\t\titem := l.items[i]\n\t\trItem, ok := l.renderedItems[item.ID()]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\trItem.start = currentContentHeight\n\t\trItem.end = currentContentHeight + rItem.height - 1\n\t\tl.renderedItems[item.ID()] = rItem\n\t\tcurrentContentHeight = rItem.end + 1 + l.gap\n\t}\n}\n\nfunc (l *list[T]) render() tea.Cmd {\n\tif l.width <= 0 || l.height <= 0 || len(l.items) == 0 {\n\t\treturn nil\n\t}\n\tl.setDefaultSelected()\n\n\tvar focusChangeCmd tea.Cmd\n\tif l.focused {\n\t\tfocusChangeCmd = l.focusSelectedItem()\n\t} else {\n\t\tfocusChangeCmd = l.blurSelectedItem()\n\t}\n\tif l.rendered != \"\" {\n\t\trendered, _ := l.renderIterator(0, false, \"\")\n\t\tl.setRendered(rendered)\n\t\tif l.direction == DirectionBackward {\n\t\t\tl.recalculateItemPositions()\n\t\t}\n\t\tif l.focused {\n\t\t\tl.scrollToSelection()\n\t\t}\n\t\treturn focusChangeCmd\n\t}\n\trendered, finishIndex := l.renderIterator(0, true, \"\")\n\tl.setRendered(rendered)\n\tif l.direction == DirectionBackward {\n\t\tl.recalculateItemPositions()\n\t}\n\n\tl.offset = 0\n\trendered, _ = l.renderIterator(finishIndex, false, l.rendered)\n\tl.setRendered(rendered)\n\tif l.direction == DirectionBackward {\n\t\tl.recalculateItemPositions()\n\t}\n\tif l.focused {\n\t\tl.scrollToSelection()\n\t}\n\n\treturn focusChangeCmd\n}\n\nfunc (l *list[T]) setDefaultSelected() {\n\tif l.selectedItemIdx < 0 {\n\t\tif l.direction == DirectionForward {\n\t\t\tl.selectFirstItem()\n\t\t} else {\n\t\t\tl.selectLastItem()\n\t\t}\n\t}\n}\n\nfunc (l *list[T]) scrollToSelection() {\n\tif l.selectedItemIdx < 0 || l.selectedItemIdx >= len(l.items) {\n\t\tl.selectedItemIdx = -1\n\t\tl.setDefaultSelected()\n\t\treturn\n\t}\n\titem := l.items[l.selectedItemIdx]\n\trItem, ok := l.renderedItems[item.ID()]\n\tif !ok {\n\t\tl.selectedItemIdx = -1\n\t\tl.setDefaultSelected()\n\t\treturn\n\t}\n\n\tstart, end := l.viewPosition()\n\tif rItem.start <= start && rItem.end >= end {\n\t\treturn\n\t}\n\tif l.movingByItem {\n\t\tif rItem.start >= start && rItem.end <= end {\n\t\t\treturn\n\t\t}\n\t\tdefer func() { l.movingByItem = false }()\n\t} else {\n\t\tif rItem.start >= start && rItem.start <= end {\n\t\t\treturn\n\t\t}\n\t\tif rItem.end >= start && rItem.end <= end {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif rItem.height >= l.height {\n\t\tif l.direction == DirectionForward {\n\t\t\tl.offset = rItem.start\n\t\t} else {\n\t\t\tl.offset = max(0, l.renderedHeight-(rItem.start+l.height))\n\t\t}\n\t\treturn\n\t}\n\n\trenderedLines := l.renderedHeight - 1\n\n\tif rItem.start < start {\n\t\tif l.direction == DirectionForward {\n\t\t\tl.offset = rItem.start\n\t\t} else {\n\t\t\tl.offset = max(0, renderedLines-rItem.start-l.height+1)\n\t\t}\n\t} else if rItem.end > end {\n\t\tif l.direction == DirectionForward {\n\t\t\tl.offset = max(0, rItem.end-l.height+1)\n\t\t} else {\n\t\t\tl.offset = max(0, renderedLines-rItem.end)\n\t\t}\n\t}\n}\n\nfunc (l *list[T]) changeSelectionWhenScrolling() tea.Cmd {\n\tif l.selectedItemIdx < 0 || l.selectedItemIdx >= len(l.items) {\n\t\treturn nil\n\t}\n\titem := l.items[l.selectedItemIdx]\n\trItem, ok := l.renderedItems[item.ID()]\n\tif !ok {\n\t\treturn nil\n\t}\n\tstart, end := l.viewPosition()\n\t// item bigger than the viewport do nothing\n\tif rItem.start <= start && rItem.end >= end {\n\t\treturn nil\n\t}\n\t// item already in view do nothing\n\tif rItem.start >= start && rItem.end <= end {\n\t\treturn nil\n\t}\n\n\titemMiddle := rItem.start + rItem.height/2\n\n\tif itemMiddle < start {\n\t\t// select the first item in the viewport\n\t\t// the item is most likely an item coming after this item\n\t\tinx := l.selectedItemIdx\n\t\tfor {\n\t\t\tinx = l.firstSelectableItemBelow(inx)\n\t\t\tif inx == ItemNotFound {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif inx < 0 || inx >= len(l.items) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\titem := l.items[inx]\n\t\t\trenderedItem, ok := l.renderedItems[item.ID()]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the item is bigger than the viewport, select it\n\t\t\tif renderedItem.start <= start && renderedItem.end >= end {\n\t\t\t\tl.selectedItemIdx = inx\n\t\t\t\treturn l.render()\n\t\t\t}\n\t\t\t// item is in the view\n\t\t\tif renderedItem.start >= start && renderedItem.start <= end {\n\t\t\t\tl.selectedItemIdx = inx\n\t\t\t\treturn l.render()\n\t\t\t}\n\t\t}\n\t} else if itemMiddle > end {\n\t\t// select the first item in the viewport\n\t\t// the item is most likely an item coming after this item\n\t\tinx := l.selectedItemIdx\n\t\tfor {\n\t\t\tinx = l.firstSelectableItemAbove(inx)\n\t\t\tif inx == ItemNotFound {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif inx < 0 || inx >= len(l.items) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\titem := l.items[inx]\n\t\t\trenderedItem, ok := l.renderedItems[item.ID()]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the item is bigger than the viewport, select it\n\t\t\tif renderedItem.start <= start && renderedItem.end >= end {\n\t\t\t\tl.selectedItemIdx = inx\n\t\t\t\treturn l.render()\n\t\t\t}\n\t\t\t// item is in the view\n\t\t\tif renderedItem.end >= start && renderedItem.end <= end {\n\t\t\t\tl.selectedItemIdx = inx\n\t\t\t\treturn l.render()\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (l *list[T]) selectFirstItem() {\n\tinx := l.firstSelectableItemBelow(-1)\n\tif inx != ItemNotFound {\n\t\tl.selectedItemIdx = inx\n\t}\n}\n\nfunc (l *list[T]) selectLastItem() {\n\tinx := l.firstSelectableItemAbove(len(l.items))\n\tif inx != ItemNotFound {\n\t\tl.selectedItemIdx = inx\n\t}\n}\n\nfunc (l *list[T]) firstSelectableItemAbove(inx int) int {\n\tfor i := inx - 1; i >= 0; i-- {\n\t\tif i < 0 || i >= len(l.items) {\n\t\t\tcontinue\n\t\t}\n\n\t\titem := l.items[i]\n\t\tif _, ok := any(item).(core.Focusable); ok {\n\t\t\treturn i\n\t\t}\n\t}\n\tif inx == 0 && l.wrap {\n\t\treturn l.firstSelectableItemAbove(len(l.items))\n\t}\n\treturn ItemNotFound\n}\n\nfunc (l *list[T]) firstSelectableItemBelow(inx int) int {\n\titemsLen := len(l.items)\n\tfor i := inx + 1; i < itemsLen; i++ {\n\t\tif i < 0 || i >= len(l.items) {\n\t\t\tcontinue\n\t\t}\n\n\t\titem := l.items[i]\n\t\tif _, ok := any(item).(core.Focusable); ok {\n\t\t\treturn i\n\t\t}\n\t}\n\tif inx == itemsLen-1 && l.wrap {\n\t\treturn l.firstSelectableItemBelow(-1)\n\t}\n\treturn ItemNotFound\n}\n\nfunc (l *list[T]) focusSelectedItem() tea.Cmd {\n\tif l.selectedItemIdx < 0 || !l.focused {\n\t\treturn nil\n\t}\n\t// Pre-allocate with expected capacity\n\tcmds := make([]tea.Cmd, 0, 2)\n\n\t// Blur the previously selected item if it's different\n\tif l.prevSelectedItemIdx >= 0 && l.prevSelectedItemIdx != l.selectedItemIdx && l.prevSelectedItemIdx < len(l.items) {\n\t\tprevItem := l.items[l.prevSelectedItemIdx]\n\t\tif f, ok := any(prevItem).(core.Focusable); ok && f.IsFocused() {\n\t\t\tcmds = append(cmds, f.Blur())\n\t\t\t// Mark cache as needing update, but don't delete yet\n\t\t\t// This allows the render to potentially reuse it\n\t\t\tdelete(l.renderedItems, prevItem.ID())\n\t\t}\n\t}\n\n\t// Focus the currently selected item\n\tif l.selectedItemIdx >= 0 && l.selectedItemIdx < len(l.items) {\n\t\titem := l.items[l.selectedItemIdx]\n\t\tif f, ok := any(item).(core.Focusable); ok && !f.IsFocused() {\n\t\t\tcmds = append(cmds, f.Focus())\n\t\t\t// Mark for re-render\n\t\t\tdelete(l.renderedItems, item.ID())\n\t\t}\n\t}\n\n\tl.prevSelectedItemIdx = l.selectedItemIdx\n\treturn tea.Batch(cmds...)\n}\n\nfunc (l *list[T]) blurSelectedItem() tea.Cmd {\n\tif l.selectedItemIdx < 0 || l.focused {\n\t\treturn nil\n\t}\n\n\t// Blur the currently selected item\n\tif l.selectedItemIdx >= 0 && l.selectedItemIdx < len(l.items) {\n\t\titem := l.items[l.selectedItemIdx]\n\t\tif f, ok := any(item).(core.Focusable); ok && f.IsFocused() {\n\t\t\tdelete(l.renderedItems, item.ID())\n\t\t\treturn f.Blur()\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// renderFragment holds updated rendered view fragments",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_renderFragment_951": {
      "name": "renderFragment",
      "type": "struct",
      "start_line": 951,
      "end_line": 1695,
      "content_hash": "d76f975d0cc317275dc3dff33d5bd2a081481004",
      "content": "type renderFragment struct {\n\tview string\n\tgap  int\n}\n\n// renderIterator renders items starting from the specific index and limits height if limitHeight != -1\n// returns the last index and the rendered content so far\n// we pass the rendered content around and don't use l.rendered to prevent jumping of the content\nfunc (l *list[T]) renderIterator(startInx int, limitHeight bool, rendered string) (string, int) {\n\t// Pre-allocate fragments with expected capacity\n\titemsLen := len(l.items)\n\texpectedFragments := itemsLen - startInx\n\tif limitHeight && l.height > 0 {\n\t\texpectedFragments = min(expectedFragments, l.height)\n\t}\n\tfragments := make([]renderFragment, 0, expectedFragments)\n\n\tcurrentContentHeight := lipgloss.Height(rendered) - 1\n\tfinalIndex := itemsLen\n\n\t// first pass: accumulate all fragments to render until the height limit is\n\t// reached\n\tfor i := startInx; i < itemsLen; i++ {\n\t\tif limitHeight && currentContentHeight >= l.height {\n\t\t\tfinalIndex = i\n\t\t\tbreak\n\t\t}\n\t\t// cool way to go through the list in both directions\n\t\tinx := i\n\n\t\tif l.direction != DirectionForward {\n\t\t\tinx = (itemsLen - 1) - i\n\t\t}\n\n\t\tif inx < 0 || inx >= len(l.items) {\n\t\t\tcontinue\n\t\t}\n\n\t\titem := l.items[inx]\n\n\t\tvar rItem renderedItem\n\t\tif cache, ok := l.renderedItems[item.ID()]; ok {\n\t\t\trItem = cache\n\t\t} else {\n\t\t\trItem = l.renderItem(item)\n\t\t\trItem.start = currentContentHeight\n\t\t\trItem.end = currentContentHeight + rItem.height - 1\n\t\t\tl.renderedItems[item.ID()] = rItem\n\t\t}\n\n\t\tgap := l.gap + 1\n\t\tif inx == itemsLen-1 {\n\t\t\tgap = 0\n\t\t}\n\n\t\tfragments = append(fragments, renderFragment{view: rItem.view, gap: gap})\n\n\t\tcurrentContentHeight = rItem.end + 1 + l.gap\n\t}\n\n\t// second pass: build rendered string efficiently\n\tvar b strings.Builder\n\n\t// Pre-size the builder to reduce allocations\n\testimatedSize := len(rendered)\n\tfor _, f := range fragments {\n\t\testimatedSize += len(f.view) + f.gap\n\t}\n\tb.Grow(estimatedSize)\n\n\tif l.direction == DirectionForward {\n\t\tb.WriteString(rendered)\n\t\tfor i := range fragments {\n\t\t\tf := &fragments[i]\n\t\t\tb.WriteString(f.view)\n\t\t\t// Optimized gap writing using pre-allocated buffer\n\t\t\tif f.gap > 0 {\n\t\t\t\tif f.gap <= maxGapSize {\n\t\t\t\t\tb.WriteString(newlineBuffer[:f.gap])\n\t\t\t\t} else {\n\t\t\t\t\tb.WriteString(strings.Repeat(\"\\n\", f.gap))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn b.String(), finalIndex\n\t}\n\n\t// iterate backwards as fragments are in reversed order\n\tfor i := len(fragments) - 1; i >= 0; i-- {\n\t\tf := &fragments[i]\n\t\tb.WriteString(f.view)\n\t\t// Optimized gap writing using pre-allocated buffer\n\t\tif f.gap > 0 {\n\t\t\tif f.gap <= maxGapSize {\n\t\t\t\tb.WriteString(newlineBuffer[:f.gap])\n\t\t\t} else {\n\t\t\t\tb.WriteString(strings.Repeat(\"\\n\", f.gap))\n\t\t\t}\n\t\t}\n\t}\n\tb.WriteString(rendered)\n\n\treturn b.String(), finalIndex\n}\n\nfunc (l *list[T]) renderItem(item Item) renderedItem {\n\tview := item.View()\n\treturn renderedItem{\n\t\tview:   view,\n\t\theight: lipgloss.Height(view),\n\t}\n}\n\n// AppendItem implements List.\nfunc (l *list[T]) AppendItem(item T) tea.Cmd {\n\t// Pre-allocate with expected capacity\n\tcmds := make([]tea.Cmd, 0, 4)\n\tcmd := item.Init()\n\tif cmd != nil {\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\tnewIndex := len(l.items)\n\tl.items = append(l.items, item)\n\tl.indexMap[item.ID()] = newIndex\n\n\tif l.width > 0 && l.height > 0 {\n\t\tcmd = item.SetSize(l.width, l.height)\n\t\tif cmd != nil {\n\t\t\tcmds = append(cmds, cmd)\n\t\t}\n\t}\n\tcmd = l.render()\n\tif cmd != nil {\n\t\tcmds = append(cmds, cmd)\n\t}\n\tif l.direction == DirectionBackward {\n\t\tif l.offset == 0 {\n\t\t\tcmd = l.GoToBottom()\n\t\t\tif cmd != nil {\n\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t}\n\t\t} else {\n\t\t\tnewItem, ok := l.renderedItems[item.ID()]\n\t\t\tif ok {\n\t\t\t\tnewLines := newItem.height\n\t\t\t\tif len(l.items) > 1 {\n\t\t\t\t\tnewLines += l.gap\n\t\t\t\t}\n\t\t\t\tl.offset = min(l.renderedHeight-1, l.offset+newLines)\n\t\t\t}\n\t\t}\n\t}\n\treturn tea.Sequence(cmds...)\n}\n\n// Blur implements List.\nfunc (l *list[T]) Blur() tea.Cmd {\n\tl.focused = false\n\treturn l.render()\n}\n\n// DeleteItem implements List.\nfunc (l *list[T]) DeleteItem(id string) tea.Cmd {\n\tinx, ok := l.indexMap[id]\n\tif !ok {\n\t\treturn nil\n\t}\n\tl.items = append(l.items[:inx], l.items[inx+1:]...)\n\tdelete(l.renderedItems, id)\n\tdelete(l.indexMap, id)\n\n\t// Only update indices for items after the deleted one\n\titemsLen := len(l.items)\n\tfor i := inx; i < itemsLen; i++ {\n\t\tif i >= 0 && i < len(l.items) {\n\t\t\titem := l.items[i]\n\t\t\tl.indexMap[item.ID()] = i\n\t\t}\n\t}\n\n\t// Adjust selectedItemIdx if the deleted item was selected or before it\n\tif l.selectedItemIdx == inx {\n\t\t// Deleted item was selected, select the previous item if possible\n\t\tif inx > 0 {\n\t\t\tl.selectedItemIdx = inx - 1\n\t\t} else {\n\t\t\tl.selectedItemIdx = -1\n\t\t}\n\t} else if l.selectedItemIdx > inx {\n\t\t// Selected item is after the deleted one, shift index down\n\t\tl.selectedItemIdx--\n\t}\n\tcmd := l.render()\n\tif l.rendered != \"\" {\n\t\tif l.renderedHeight <= l.height {\n\t\t\tl.offset = 0\n\t\t} else {\n\t\t\tmaxOffset := l.renderedHeight - l.height\n\t\t\tif l.offset > maxOffset {\n\t\t\t\tl.offset = maxOffset\n\t\t\t}\n\t\t}\n\t}\n\treturn cmd\n}\n\n// Focus implements List.\nfunc (l *list[T]) Focus() tea.Cmd {\n\tl.focused = true\n\treturn l.render()\n}\n\n// GetSize implements List.\nfunc (l *list[T]) GetSize() (int, int) {\n\treturn l.width, l.height\n}\n\n// GoToBottom implements List.\nfunc (l *list[T]) GoToBottom() tea.Cmd {\n\tl.offset = 0\n\tl.selectedItemIdx = -1\n\tl.direction = DirectionBackward\n\treturn l.render()\n}\n\n// GoToTop implements List.\nfunc (l *list[T]) GoToTop() tea.Cmd {\n\tl.offset = 0\n\tl.selectedItemIdx = -1\n\tl.direction = DirectionForward\n\treturn l.render()\n}\n\n// IsFocused implements List.\nfunc (l *list[T]) IsFocused() bool {\n\treturn l.focused\n}\n\n// Items implements List.\nfunc (l *list[T]) Items() []T {\n\titemsLen := len(l.items)\n\tresult := make([]T, 0, itemsLen)\n\tfor i := range itemsLen {\n\t\tif i >= 0 && i < len(l.items) {\n\t\t\titem := l.items[i]\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (l *list[T]) incrementOffset(n int) {\n\t// no need for offset\n\tif l.renderedHeight <= l.height {\n\t\treturn\n\t}\n\tmaxOffset := l.renderedHeight - l.height\n\tn = min(n, maxOffset-l.offset)\n\tif n <= 0 {\n\t\treturn\n\t}\n\tl.offset += n\n\tl.cachedViewDirty = true\n}\n\nfunc (l *list[T]) decrementOffset(n int) {\n\tn = min(n, l.offset)\n\tif n <= 0 {\n\t\treturn\n\t}\n\tl.offset -= n\n\tif l.offset < 0 {\n\t\tl.offset = 0\n\t}\n\tl.cachedViewDirty = true\n}\n\n// MoveDown implements List.\nfunc (l *list[T]) MoveDown(n int) tea.Cmd {\n\toldOffset := l.offset\n\tif l.direction == DirectionForward {\n\t\tl.incrementOffset(n)\n\t} else {\n\t\tl.decrementOffset(n)\n\t}\n\n\tif oldOffset == l.offset {\n\t\t// no change in offset, so no need to change selection\n\t\treturn nil\n\t}\n\t// if we are not actively selecting move the whole selection down\n\tif l.hasSelection() && !l.selectionActive {\n\t\tif l.selectionStartLine < l.selectionEndLine {\n\t\t\tl.selectionStartLine -= n\n\t\t\tl.selectionEndLine -= n\n\t\t} else {\n\t\t\tl.selectionStartLine -= n\n\t\t\tl.selectionEndLine -= n\n\t\t}\n\t}\n\tif l.selectionActive {\n\t\tif l.selectionStartLine < l.selectionEndLine {\n\t\t\tl.selectionStartLine -= n\n\t\t} else {\n\t\t\tl.selectionEndLine -= n\n\t\t}\n\t}\n\treturn l.changeSelectionWhenScrolling()\n}\n\n// MoveUp implements List.\nfunc (l *list[T]) MoveUp(n int) tea.Cmd {\n\toldOffset := l.offset\n\tif l.direction == DirectionForward {\n\t\tl.decrementOffset(n)\n\t} else {\n\t\tl.incrementOffset(n)\n\t}\n\n\tif oldOffset == l.offset {\n\t\t// no change in offset, so no need to change selection\n\t\treturn nil\n\t}\n\n\tif l.hasSelection() && !l.selectionActive {\n\t\tif l.selectionStartLine > l.selectionEndLine {\n\t\t\tl.selectionStartLine += n\n\t\t\tl.selectionEndLine += n\n\t\t} else {\n\t\t\tl.selectionStartLine += n\n\t\t\tl.selectionEndLine += n\n\t\t}\n\t}\n\tif l.selectionActive {\n\t\tif l.selectionStartLine > l.selectionEndLine {\n\t\t\tl.selectionStartLine += n\n\t\t} else {\n\t\t\tl.selectionEndLine += n\n\t\t}\n\t}\n\treturn l.changeSelectionWhenScrolling()\n}\n\n// PrependItem implements List.\nfunc (l *list[T]) PrependItem(item T) tea.Cmd {\n\t// Pre-allocate with expected capacity\n\tcmds := make([]tea.Cmd, 0, 4)\n\tcmds = append(cmds, item.Init())\n\n\tl.items = append([]T{item}, l.items...)\n\n\t// Shift selectedItemIdx since all items moved down by 1\n\tif l.selectedItemIdx >= 0 {\n\t\tl.selectedItemIdx++\n\t}\n\n\t// Update index map incrementally: shift all existing indices up by 1\n\t// This is more efficient than rebuilding from scratch\n\tnewIndexMap := make(map[string]int, len(l.indexMap)+1)\n\tfor id, idx := range l.indexMap {\n\t\tnewIndexMap[id] = idx + 1 // All existing items shift down by 1\n\t}\n\tnewIndexMap[item.ID()] = 0 // New item is at index 0\n\tl.indexMap = newIndexMap\n\n\tif l.width > 0 && l.height > 0 {\n\t\tcmds = append(cmds, item.SetSize(l.width, l.height))\n\t}\n\tcmds = append(cmds, l.render())\n\tif l.direction == DirectionForward {\n\t\tif l.offset == 0 {\n\t\t\tcmd := l.GoToTop()\n\t\t\tif cmd != nil {\n\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t}\n\t\t} else {\n\t\t\tnewItem, ok := l.renderedItems[item.ID()]\n\t\t\tif ok {\n\t\t\t\tnewLines := newItem.height\n\t\t\t\tif len(l.items) > 1 {\n\t\t\t\t\tnewLines += l.gap\n\t\t\t\t}\n\t\t\t\tl.offset = min(l.renderedHeight-1, l.offset+newLines)\n\t\t\t}\n\t\t}\n\t}\n\treturn tea.Batch(cmds...)\n}\n\n// SelectItemAbove implements List.\nfunc (l *list[T]) SelectItemAbove() tea.Cmd {\n\tif l.selectedItemIdx < 0 {\n\t\treturn nil\n\t}\n\n\tnewIndex := l.firstSelectableItemAbove(l.selectedItemIdx)\n\tif newIndex == ItemNotFound {\n\t\t// no item above\n\t\treturn nil\n\t}\n\t// Pre-allocate with expected capacity\n\tcmds := make([]tea.Cmd, 0, 2)\n\tif newIndex == 1 {\n\t\tpeakAboveIndex := l.firstSelectableItemAbove(newIndex)\n\t\tif peakAboveIndex == ItemNotFound {\n\t\t\t// this means there is a section above move to the top\n\t\t\tcmd := l.GoToTop()\n\t\t\tif cmd != nil {\n\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t}\n\t\t}\n\t}\n\tif newIndex < 0 || newIndex >= len(l.items) {\n\t\treturn nil\n\t}\n\tl.prevSelectedItemIdx = l.selectedItemIdx\n\tl.selectedItemIdx = newIndex\n\tl.movingByItem = true\n\trenderCmd := l.render()\n\tif renderCmd != nil {\n\t\tcmds = append(cmds, renderCmd)\n\t}\n\treturn tea.Sequence(cmds...)\n}\n\n// SelectItemBelow implements List.\nfunc (l *list[T]) SelectItemBelow() tea.Cmd {\n\tif l.selectedItemIdx < 0 {\n\t\treturn nil\n\t}\n\n\tnewIndex := l.firstSelectableItemBelow(l.selectedItemIdx)\n\tif newIndex == ItemNotFound {\n\t\t// no item above\n\t\treturn nil\n\t}\n\tif newIndex < 0 || newIndex >= len(l.items) {\n\t\treturn nil\n\t}\n\tl.prevSelectedItemIdx = l.selectedItemIdx\n\tl.selectedItemIdx = newIndex\n\tl.movingByItem = true\n\treturn l.render()\n}\n\n// SelectedItem implements List.\nfunc (l *list[T]) SelectedItem() *T {\n\tif l.selectedItemIdx < 0 || l.selectedItemIdx >= len(l.items) {\n\t\treturn nil\n\t}\n\titem := l.items[l.selectedItemIdx]\n\treturn &item\n}\n\n// SetItems implements List.\nfunc (l *list[T]) SetItems(items []T) tea.Cmd {\n\tl.items = items\n\tvar cmds []tea.Cmd\n\tfor inx, item := range items {\n\t\tif i, ok := any(item).(Indexable); ok {\n\t\t\ti.SetIndex(inx)\n\t\t}\n\t\tcmds = append(cmds, item.Init())\n\t}\n\tcmds = append(cmds, l.reset(\"\"))\n\treturn tea.Batch(cmds...)\n}\n\n// SetSelected implements List.\nfunc (l *list[T]) SetSelected(id string) tea.Cmd {\n\tl.prevSelectedItemIdx = l.selectedItemIdx\n\tif idx, ok := l.indexMap[id]; ok {\n\t\tl.selectedItemIdx = idx\n\t} else {\n\t\tl.selectedItemIdx = -1\n\t}\n\treturn l.render()\n}\n\nfunc (l *list[T]) reset(selectedItemID string) tea.Cmd {\n\tvar cmds []tea.Cmd\n\tl.rendered = \"\"\n\tl.renderedHeight = 0\n\tl.offset = 0\n\tl.indexMap = make(map[string]int)\n\tl.renderedItems = make(map[string]renderedItem)\n\titemsLen := len(l.items)\n\tfor i := range itemsLen {\n\t\tif i < 0 || i >= len(l.items) {\n\t\t\tcontinue\n\t\t}\n\n\t\titem := l.items[i]\n\t\tl.indexMap[item.ID()] = i\n\t\tif l.width > 0 && l.height > 0 {\n\t\t\tcmds = append(cmds, item.SetSize(l.width, l.height))\n\t\t}\n\t}\n\t// Convert selectedItemID to index after rebuilding indexMap\n\tif selectedItemID != \"\" {\n\t\tif idx, ok := l.indexMap[selectedItemID]; ok {\n\t\t\tl.selectedItemIdx = idx\n\t\t} else {\n\t\t\tl.selectedItemIdx = -1\n\t\t}\n\t} else {\n\t\tl.selectedItemIdx = -1\n\t}\n\tcmds = append(cmds, l.render())\n\treturn tea.Batch(cmds...)\n}\n\n// SetSize implements List.\nfunc (l *list[T]) SetSize(width int, height int) tea.Cmd {\n\toldWidth := l.width\n\tl.width = width\n\tl.height = height\n\tif oldWidth != width {\n\t\t// Get current selected item ID before reset\n\t\tselectedID := \"\"\n\t\tif l.selectedItemIdx >= 0 && l.selectedItemIdx < len(l.items) {\n\t\t\titem := l.items[l.selectedItemIdx]\n\t\t\tselectedID = item.ID()\n\t\t}\n\t\tcmd := l.reset(selectedID)\n\t\treturn cmd\n\t}\n\treturn nil\n}\n\n// UpdateItem implements List.\nfunc (l *list[T]) UpdateItem(id string, item T) tea.Cmd {\n\t// Pre-allocate with expected capacity\n\tcmds := make([]tea.Cmd, 0, 1)\n\tif inx, ok := l.indexMap[id]; ok {\n\t\tl.items[inx] = item\n\t\toldItem, hasOldItem := l.renderedItems[id]\n\t\toldPosition := l.offset\n\t\tif l.direction == DirectionBackward {\n\t\t\toldPosition = (l.renderedHeight - 1) - l.offset\n\t\t}\n\n\t\tdelete(l.renderedItems, id)\n\t\tcmd := l.render()\n\n\t\t// need to check for nil because of sequence not handling nil\n\t\tif cmd != nil {\n\t\t\tcmds = append(cmds, cmd)\n\t\t}\n\t\tif hasOldItem && l.direction == DirectionBackward {\n\t\t\t// if we are the last item and there is no offset\n\t\t\t// make sure to go to the bottom\n\t\t\tif oldPosition < oldItem.end {\n\t\t\t\tnewItem, ok := l.renderedItems[item.ID()]\n\t\t\t\tif ok {\n\t\t\t\t\tnewLines := newItem.height - oldItem.height\n\t\t\t\t\tl.offset = ordered.Clamp(l.offset+newLines, 0, l.renderedHeight-1)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if hasOldItem && l.offset > oldItem.start {\n\t\t\tnewItem, ok := l.renderedItems[item.ID()]\n\t\t\tif ok {\n\t\t\t\tnewLines := newItem.height - oldItem.height\n\t\t\t\tl.offset = ordered.Clamp(l.offset+newLines, 0, l.renderedHeight-1)\n\t\t\t}\n\t\t}\n\t}\n\treturn tea.Sequence(cmds...)\n}\n\nfunc (l *list[T]) hasSelection() bool {\n\treturn l.selectionEndCol != l.selectionStartCol || l.selectionEndLine != l.selectionStartLine\n}\n\n// StartSelection implements List.\nfunc (l *list[T]) StartSelection(col, line int) {\n\tl.selectionStartCol = col\n\tl.selectionStartLine = line\n\tl.selectionEndCol = col\n\tl.selectionEndLine = line\n\tl.selectionActive = true\n}\n\n// EndSelection implements List.\nfunc (l *list[T]) EndSelection(col, line int) {\n\tif !l.selectionActive {\n\t\treturn\n\t}\n\tl.selectionEndCol = col\n\tl.selectionEndLine = line\n}\n\nfunc (l *list[T]) SelectionStop() {\n\tl.selectionActive = false\n}\n\nfunc (l *list[T]) SelectionClear() {\n\tl.selectionStartCol = -1\n\tl.selectionStartLine = -1\n\tl.selectionEndCol = -1\n\tl.selectionEndLine = -1\n\tl.selectionActive = false\n}\n\nfunc (l *list[T]) findWordBoundaries(col, line int) (startCol, endCol int) {\n\tnumLines := l.lineCount()\n\n\tif l.direction == DirectionBackward && numLines > l.height {\n\t\tline = ((numLines - 1) - l.height) + line + 1\n\t}\n\n\tif l.offset > 0 {\n\t\tif l.direction == DirectionBackward {\n\t\t\tline -= l.offset\n\t\t} else {\n\t\t\tline += l.offset\n\t\t}\n\t}\n\n\tif line < 0 || line >= numLines {\n\t\treturn 0, 0\n\t}\n\n\tcurrentLine := ansi.Strip(l.getLine(line))\n\tgr := uniseg.NewGraphemes(currentLine)\n\tstartCol = -1\n\tupTo := col\n\tfor gr.Next() {\n\t\tif gr.IsWordBoundary() && upTo > 0 {\n\t\t\tstartCol = col - upTo + 1\n\t\t} else if gr.IsWordBoundary() && upTo < 0 {\n\t\t\tendCol = col - upTo + 1\n\t\t\tbreak\n\t\t}\n\t\tif upTo == 0 && gr.Str() == \" \" {\n\t\t\treturn 0, 0\n\t\t}\n\t\tupTo -= 1\n\t}\n\tif startCol == -1 {\n\t\treturn 0, 0\n\t}\n\treturn startCol, endCol\n}\n\nfunc (l *list[T]) findParagraphBoundaries(line int) (startLine, endLine int, found bool) {\n\t// Helper function to get a line with ANSI stripped and icons replaced\n\tgetCleanLine := func(index int) string {\n\t\trawLine := l.getLine(index)\n\t\tcleanLine := ansi.Strip(rawLine)\n\t\tfor _, icon := range styles.SelectionIgnoreIcons {\n\t\t\tcleanLine = strings.ReplaceAll(cleanLine, icon, \" \")\n\t\t}\n\t\treturn cleanLine\n\t}\n\n\tnumLines := l.lineCount()\n\tif l.direction == DirectionBackward && numLines > l.height {\n\t\tline = (numLines - 1) - l.height + line + 1\n\t}\n\n\tif l.offset > 0 {\n\t\tif l.direction == DirectionBackward {\n\t\t\tline -= l.offset\n\t\t} else {\n\t\t\tline += l.offset\n\t\t}\n\t}\n\n\t// Ensure line is within bounds\n\tif line < 0 || line >= numLines {\n\t\treturn 0, 0, false\n\t}\n\n\tif strings.TrimSpace(getCleanLine(line)) == \"\" {\n\t\treturn 0, 0, false\n\t}\n\n\t// Find start of paragraph (search backwards for empty line or start of text)\n\tstartLine = line\n\tfor startLine > 0 && strings.TrimSpace(getCleanLine(startLine-1)) != \"\" {\n\t\tstartLine--\n\t}\n\n\t// Find end of paragraph (search forwards for empty line or end of text)\n\tendLine = line\n\tfor endLine < numLines-1 && strings.TrimSpace(getCleanLine(endLine+1)) != \"\" {\n\t\tendLine++\n\t}\n\n\t// revert the line numbers if we are in backward direction\n\tif l.direction == DirectionBackward && numLines > l.height {\n\t\tstartLine = startLine - (numLines - 1) + l.height - 1\n\t\tendLine = endLine - (numLines - 1) + l.height - 1\n\t}\n\tif l.offset > 0 {\n\t\tif l.direction == DirectionBackward {\n\t\t\tstartLine += l.offset\n\t\t\tendLine += l.offset\n\t\t} else {\n\t\t\tstartLine -= l.offset\n\t\t\tendLine -= l.offset\n\t\t}\n\t}\n\treturn startLine, endLine, true\n}\n\n// SelectWord selects the word at the given position.\nfunc (l *list[T]) SelectWord(col, line int) {\n\tstartCol, endCol := l.findWordBoundaries(col, line)\n\tl.selectionStartCol = startCol\n\tl.selectionStartLine = line\n\tl.selectionEndCol = endCol\n\tl.selectionEndLine = line\n\tl.selectionActive = false // Not actively selecting, just selected\n}\n\n// SelectParagraph selects the paragraph at the given position.\nfunc (l *list[T]) SelectParagraph(col, line int) {\n\tstartLine, endLine, found := l.findParagraphBoundaries(line)\n\tif !found {\n\t\treturn\n\t}\n\tl.selectionStartCol = 0\n\tl.selectionStartLine = startLine\n\tl.selectionEndCol = l.width - 1\n\tl.selectionEndLine = endLine\n\tl.selectionActive = false // Not actively selecting, just selected\n}\n\n// HasSelection returns whether there is an active selection.\nfunc (l *list[T]) HasSelection() bool {\n\treturn l.hasSelection()\n}\n\n// GetSelectedText returns the currently selected text.\nfunc (l *list[T]) GetSelectedText(paddingLeft int) string {\n\tif !l.hasSelection() {\n\t\treturn \"\"\n\t}\n\n\treturn l.selectionView(l.View(), true)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}