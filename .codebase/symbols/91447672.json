{
  "file_path": "/work/external-deps/Context-Engine/ctx-mcp-bridge/src/oauthHandler.js",
  "file_hash": "c42295043fb8c4205f473f3c9592b684b6801788",
  "updated_at": "2025-12-26T17:34:19.737722",
  "symbols": {
    "function_cleanupExpiredTokens_27": {
      "name": "cleanupExpiredTokens",
      "type": "function",
      "start_line": 27,
      "end_line": 35,
      "content_hash": "5ca7a50d7d8b0f8feb9c184c96970fe5f3c63489",
      "content": "function cleanupExpiredTokens() {\n  const now = Date.now();\n  const expiryMs = 86400000; // 24 hours\n  for (const [token, data] of tokenStore.entries()) {\n    if (now - data.createdAt > expiryMs) {\n      tokenStore.delete(token);\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateToken_37": {
      "name": "generateToken",
      "type": "function",
      "start_line": 37,
      "end_line": 39,
      "content_hash": "1b1fd1116c884ca1d19796c4492a56864b113deb",
      "content": "function generateToken() {\n  return randomBytes(32).toString(\"hex\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateCode_41": {
      "name": "generateCode",
      "type": "function",
      "start_line": 41,
      "end_line": 43,
      "content_hash": "7731b54ebd6f6354603deef19082a8eb343f837d",
      "content": "function generateCode() {\n  return randomBytes(16).toString(\"base64url\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_debugLog_45": {
      "name": "debugLog",
      "type": "function",
      "start_line": 45,
      "end_line": 56,
      "content_hash": "5f44eb527e3770a88082195ce373bb4767eb905a",
      "content": "function debugLog(message) {\n  try {\n    const text = typeof message === \"string\" ? message : String(message);\n    console.error(text);\n    const dest = process.env.CTXCE_DEBUG_LOG;\n    if (dest) {\n      fs.appendFileSync(dest, `${new Date().toISOString()} ${text}\\n`, \"utf8\");\n    }\n  } catch {\n    // ignore logging errors\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getOAuthMetadata_62": {
      "name": "getOAuthMetadata",
      "type": "function",
      "start_line": 62,
      "end_line": 74,
      "content_hash": "cec511efa6a84b032e344bae0d0c252649a1b058",
      "content": "export function getOAuthMetadata(issuerUrl) {\n  return {\n    issuer: issuerUrl,\n    authorization_endpoint: `${issuerUrl}/oauth/authorize`,\n    token_endpoint: `${issuerUrl}/oauth/token`,\n    registration_endpoint: `${issuerUrl}/oauth/register`, // RFC7591 Dynamic Client Registration\n    response_types_supported: [\"code\"],\n    grant_types_supported: [\"authorization_code\"],\n    token_endpoint_auth_methods_supported: [\"none\"],\n    code_challenge_methods_supported: [\"S256\"],\n    scopes_supported: [\"mcp\"],\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_escapeJsonForHtml_84": {
      "name": "escapeJsonForHtml",
      "type": "function",
      "start_line": 84,
      "end_line": 89,
      "content_hash": "3fb9f4f97f1084a87f69b4a35184cc2e1080c649",
      "content": "function escapeJsonForHtml(obj) {\n  const json = JSON.stringify(obj);\n  // Replace dangerous characters with HTML-safe equivalents\n  // </script> can break out of script tag, so replace </ with \\u003C/\n  return json.replace(/</g, '\\\\u003C').replace(/>/g, '\\\\u003E');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getLoginPage_91": {
      "name": "getLoginPage",
      "type": "function",
      "start_line": 91,
      "end_line": 213,
      "content_hash": "f17acb010fe2eba152416c4543452f086b6c58b2",
      "content": "export function getLoginPage(redirectUri, clientId, state, codeChallenge, codeChallengeMethod) {\n  const params = new URLSearchParams({\n    redirect_uri: redirectUri || \"\",\n    client_id: clientId || \"\",\n    state: state || \"\",\n    code_challenge: codeChallenge || \"\",\n    code_challenge_method: codeChallengeMethod || \"\",\n  });\n\n  return `<!DOCTYPE html>\n<html>\n<head>\n  <title>Context Engine MCP - Login</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 500px; margin: 50px auto; padding: 20px; }\n    h1 { color: #333; }\n    .form-group { margin-bottom: 15px; }\n    label { display: block; margin-bottom: 5px; font-weight: 500; }\n    input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }\n    button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }\n    button:hover { background: #0056b3; }\n    .info { background: #e7f3ff; padding: 10px; border-radius: 4px; margin-bottom: 20px; font-size: 14px; }\n    .error { color: #dc3545; margin-top: 10px; }\n    .success { color: #28a745; margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <h1>Context Engine MCP Bridge</h1>\n  <div class=\"info\">\n    This MCP bridge requires authentication. Please log in to your Context Engine backend.\n  </div>\n\n  <div id=\"result\"></div>\n\n  <form id=\"loginForm\">\n    <div class=\"form-group\">\n      <label>Backend URL</label>\n      <input type=\"url\" id=\"backendUrl\" placeholder=\"http://localhost:8004\" required>\n    </div>\n    <div class=\"form-group\">\n      <label>Username (optional)</label>\n      <input type=\"text\" id=\"username\" placeholder=\"Leave empty for token auth\">\n    </div>\n    <div class=\"form-group\">\n      <label>Password (optional)</label>\n      <input type=\"password\" id=\"password\" placeholder=\"Required if username provided\">\n    </div>\n    <div class=\"form-group\">\n      <label>Auth Token (if no username)</label>\n      <input type=\"text\" id=\"token\" placeholder=\"Your shared auth token\">\n    </div>\n    <button type=\"submit\">Login & Authorize</button>\n  </form>\n\n  <script>\n  const params = ${escapeJsonForHtml(Object.fromEntries(params))};\n  document.getElementById('loginForm').addEventListener('submit', async (e) => {\n    e.preventDefault();\n    const result = document.getElementById('result');\n    result.innerHTML = '<p style=\"color: #007bff;\">Logging in...</p>';\n\n    const backendUrl = document.getElementById('backendUrl').value;\n    const username = document.getElementById('username').value;\n    const password = document.getElementById('password').value;\n    const token = document.getElementById('token').value;\n\n    const usePassword = username && password;\n    const body = usePassword\n      ? { username, password, workspace: '/tmp/bridge-oauth' }\n      : { client: 'ctxce', workspace: '/tmp/bridge-oauth', token: token || undefined };\n\n    const target = backendUrl.replace(/\\\\/+$/, '') + (usePassword ? '/auth/login/password' : '/auth/login');\n\n    try {\n      const resp = await fetch(target, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(body)\n      });\n\n      if (!resp.ok) {\n        throw new Error('Login failed: ' + resp.status);\n      }\n\n      const data = await resp.json();\n      const sessionId = data.session_id || data.sessionId;\n      if (!sessionId) {\n        throw new Error('No session in response');\n      }\n\n      // Store the session and get authorization code\n      const storeResp = await fetch('/oauth/store-session', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          session_id: sessionId,\n          backend_url: backendUrl,\n          redirect_uri: params.redirect_uri,\n          state: params.state,\n          code_challenge: params.code_challenge,\n          code_challenge_method: params.code_challenge_method,\n          client_id: params.client_id\n        })\n      });\n\n      if (!storeResp.ok) {\n        throw new Error('Failed to store session');\n      }\n\n      const storeData = await storeResp.json();\n      if (storeData.redirect) {\n        window.location.href = storeData.redirect;\n      } else {\n        throw new Error('No redirect URL');\n      }\n    } catch (err) {\n      result.innerHTML = '<p class=\"error\">' + err.message + '</p>';\n    }\n  });\n  </script>\n</body>\n</html>`;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_validateClientAndRedirect_225": {
      "name": "validateClientAndRedirect",
      "type": "function",
      "start_line": 225,
      "end_line": 236,
      "content_hash": "ba6322198242a1ca560386b67d8d40b3ae092d55",
      "content": "function validateClientAndRedirect(clientId, redirectUri) {\n  if (!clientId || !redirectUri) {\n    return false;\n  }\n  const client = registeredClients.get(clientId);\n  if (!client) {\n    return false;\n  }\n  // Check if redirect_uri exactly matches one of the registered URIs\n  const redirectUris = client.redirectUris || [];\n  return redirectUris.includes(redirectUri);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleOAuthMetadata_242": {
      "name": "handleOAuthMetadata",
      "type": "function",
      "start_line": 242,
      "end_line": 245,
      "content_hash": "91ea14fca7b6839df78b53b041038e18bdcf818c",
      "content": "export function handleOAuthMetadata(_req, res, issuerUrl) {\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.end(JSON.stringify(getOAuthMetadata(issuerUrl)));\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleOAuthRegister_251": {
      "name": "handleOAuthRegister",
      "type": "function",
      "start_line": 251,
      "end_line": 294,
      "content_hash": "39fb9e6bececad764077a1667ad77dda159b1efe",
      "content": "export function handleOAuthRegister(req, res) {\n  let body = \"\";\n  req.on(\"data\", (chunk) => { body += chunk; });\n  req.on(\"end\", () => {\n    try {\n      const data = JSON.parse(body);\n\n      // Validate required fields\n      if (!data.redirect_uris || !Array.isArray(data.redirect_uris) || data.redirect_uris.length === 0) {\n        res.statusCode = 400;\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({ error: \"invalid_redirect_uri\" }));\n        return;\n      }\n\n      // Auto-approve any client registration for local bridge\n      const clientId = generateToken().slice(0, 32);\n      const client_id = `mcp_${clientId}`;\n\n      registeredClients.set(client_id, {\n        clientId: client_id,\n        redirectUris: data.redirect_uris,\n        grantTypes: data.grant_types || [\"authorization_code\"],\n        createdAt: Date.now(),\n      });\n\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.statusCode = 201;\n      res.end(JSON.stringify({\n        client_id: client_id,\n        client_id_issued_at: Math.floor(Date.now() / 1000),\n        grant_types: [\"authorization_code\"],\n        redirect_uris: data.redirect_uris,\n        response_types: [\"code\"],\n        token_endpoint_auth_method: \"none\",\n      }));\n    } catch (err) {\n      debugLog(\"[ctxce] /oauth/register error: \" + String(err));\n      res.statusCode = 400;\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({ error: \"invalid_client_metadata\", error_description: String(err) }));\n    }\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleOAuthAuthorize_300": {
      "name": "handleOAuthAuthorize",
      "type": "function",
      "start_line": 300,
      "end_line": 351,
      "content_hash": "bf6cafad221defa13c6e879f9dc6d1046ef6d807",
      "content": "export function handleOAuthAuthorize(_req, res, searchParams) {\n  const redirectUri = searchParams.get(\"redirect_uri\");\n  const clientId = searchParams.get(\"client_id\");\n  const state = searchParams.get(\"state\");\n  const responseType = searchParams.get(\"response_type\");\n  const codeChallenge = searchParams.get(\"code_challenge\");\n  const codeChallengeMethod = searchParams.get(\"code_challenge_method\") || \"S256\";\n\n  // Validate response_type is \"code\" (authorization code flow)\n  if (responseType !== \"code\") {\n    res.statusCode = 400;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({ error: \"unsupported_response_type\", error_description: \"Only response_type=code is supported\" }));\n    return;\n  }\n\n  // Validate client_id and redirect_uri against registered clients\n  if (!validateClientAndRedirect(clientId, redirectUri)) {\n    res.statusCode = 400;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({ error: \"invalid_client\", error_description: \"Unknown client_id or unauthorized redirect_uri\" }));\n    return;\n  }\n\n  // If already logged in (has valid session), auto-approve\n  const existingAuth = loadAnyAuthEntry();\n  if (existingAuth && existingAuth.entry && existingAuth.entry.sessionId) {\n    // Auto-generate code and redirect\n    const code = generateCode();\n    pendingCodes.set(code, {\n      clientId,\n      sessionId: existingAuth.entry.sessionId,\n      backendUrl: existingAuth.backendUrl,\n      codeChallenge,\n      codeChallengeMethod,\n      redirectUri,\n      createdAt: Date.now(),\n    });\n\n    const redirectUrl = new URL(redirectUri || \"http://localhost/callback\");\n    redirectUrl.searchParams.set(\"code\", code);\n    if (state) redirectUrl.searchParams.set(\"state\", state);\n    res.setHeader(\"Location\", redirectUrl.toString());\n    res.statusCode = 302;\n    res.end();\n    return;\n  }\n\n  // Otherwise, show login page\n  res.setHeader(\"Content-Type\", \"text/html\");\n  res.end(getLoginPage(redirectUri, clientId, state, codeChallenge, codeChallengeMethod));\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleOAuthStoreSession_362": {
      "name": "handleOAuthStoreSession",
      "type": "function",
      "start_line": 362,
      "end_line": 455,
      "content_hash": "39eb7974ee5c28a7ccf6dbc443de2d8c535d7f3f",
      "content": "export function handleOAuthStoreSession(req, res) {\n  let body = \"\";\n  req.on(\"data\", (chunk) => { body += chunk; });\n  req.on(\"end\", () => {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    try {\n      const data = JSON.parse(body);\n      const { session_id, backend_url, redirect_uri, state, code_challenge, code_challenge_method, client_id } = data;\n\n      if (!session_id || !backend_url) {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"Missing session_id or backend_url\" }));\n        return;\n      }\n\n      // Validate backend_url is a valid URL string (prevent prototype pollution)\n      // Only allow http/https schemes for backend API URLs\n      try {\n        const url = new URL(backend_url);\n        if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n          res.statusCode = 400;\n          res.end(JSON.stringify({ error: \"Invalid backend_url\", error_description: \"Only http/https URLs are allowed\" }));\n          return;\n        }\n      } catch {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"Invalid backend_url\" }));\n        return;\n      }\n\n      // Validate client_id and redirect_uri against registered clients\n      // Note: client_id is passed from the login page which gets it from the initial auth request\n      if (!validateClientAndRedirect(client_id, redirect_uri)) {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"invalid_client\", error_description: \"Unknown client_id or unauthorized redirect_uri\" }));\n        return;\n      }\n\n      // Additional CSRF protection: verify request came from a local browser origin\n      // Require Origin or Referer header to be present and from localhost\n      const origin = req.headers[\"origin\"] || req.headers[\"referer\"];\n      if (!origin) {\n        res.statusCode = 403;\n        res.end(JSON.stringify({ error: \"forbidden\", error_description: \"Origin or Referer header required\" }));\n        return;\n      }\n      try {\n        const originUrl = new URL(origin);\n        const hostname = originUrl.hostname;\n        // Only allow localhost or 127.0.0.1 origins\n        if (hostname !== \"localhost\" && hostname !== \"127.0.0.1\") {\n          res.statusCode = 403;\n          res.end(JSON.stringify({ error: \"forbidden\", error_description: \"Request must originate from localhost\" }));\n          return;\n        }\n      } catch {\n        // If origin parsing fails, reject the request\n        res.statusCode = 403;\n        res.end(JSON.stringify({ error: \"forbidden\", error_description: \"Invalid origin\" }));\n        return;\n      }\n\n      // Save the auth entry\n      saveAuthEntry(backend_url, {\n        sessionId: session_id,\n        userId: \"oauth-user\",\n        expiresAt: null,\n      });\n\n      // Generate auth code\n      const code = generateCode();\n      pendingCodes.set(code, {\n        clientId: client_id,\n        sessionId: session_id,\n        backendUrl: backend_url,\n        codeChallenge: code_challenge,\n        codeChallengeMethod: code_challenge_method,\n        redirectUri: redirect_uri,\n        createdAt: Date.now(),\n      });\n\n      // Return redirect URL\n      const redirectUrl = new URL(redirect_uri || \"http://localhost/callback\");\n      redirectUrl.searchParams.set(\"code\", code);\n      if (state) redirectUrl.searchParams.set(\"state\", state);\n\n      res.end(JSON.stringify({ redirect: redirectUrl.toString() }));\n    } catch (err) {\n      debugLog(\"[ctxce] /oauth/store-session error: \" + String(err));\n      res.statusCode = 400;\n      res.end(JSON.stringify({ error: String(err) }));\n    }\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleOAuthToken_461": {
      "name": "handleOAuthToken",
      "type": "function",
      "start_line": 461,
      "end_line": 546,
      "content_hash": "de7c1d471fb34aa5024b4675cfef6b676d7d055e",
      "content": "export function handleOAuthToken(req, res) {\n  let body = \"\";\n  req.on(\"data\", (chunk) => { body += chunk; });\n  req.on(\"end\", () => {\n    try {\n      const data = new URLSearchParams(body);\n      const code = data.get(\"code\");\n      const redirectUri = data.get(\"redirect_uri\");\n      const clientId = data.get(\"client_id\");\n      // PKCE code_verifier - extracted but not validated yet (local bridge, trusted)\n      data.get(\"code_verifier\");\n      const grantType = data.get(\"grant_type\");\n\n      res.setHeader(\"Content-Type\", \"application/json\");\n\n      if (grantType !== \"authorization_code\") {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"unsupported_grant_type\" }));\n        return;\n      }\n\n      const pendingData = pendingCodes.get(code);\n      if (!pendingData) {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"invalid_grant\", error_description: \"Invalid or expired code\" }));\n        return;\n      }\n\n      // Check code age (10 minute expiry)\n      if (Date.now() - pendingData.createdAt > 600000) {\n        pendingCodes.delete(code);\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"invalid_grant\", error_description: \"Code expired\" }));\n        return;\n      }\n\n      // Validate client_id matches the one used in authorize request\n      // This prevents code leakage from being used by a different client\n      if (pendingData.clientId !== clientId) {\n        pendingCodes.delete(code);\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"invalid_client\", error_description: \"client_id mismatch\" }));\n        return;\n      }\n\n      // Validate redirect_uri matches the one used in authorize request\n      // This prevents code interception from being used on a different redirect URI\n      if (pendingData.redirectUri !== redirectUri) {\n        pendingCodes.delete(code);\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: \"invalid_grant\", error_description: \"redirect_uri mismatch\" }));\n        return;\n      }\n\n      // TODO: Validate PKCE code_verifier against code_challenge\n      // For now, skip validation (local bridge, trusted)\n\n      // Clean up expired tokens periodically to prevent unbounded growth\n      cleanupExpiredTokens();\n\n      // Generate access token\n      const accessToken = generateToken();\n      tokenStore.set(accessToken, {\n        sessionId: pendingData.sessionId,\n        backendUrl: pendingData.backendUrl,\n        createdAt: Date.now(),\n      });\n\n      // Clean up pending code\n      pendingCodes.delete(code);\n\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({\n        access_token: accessToken,\n        token_type: \"Bearer\",\n        expires_in: 86400, // 24 hours\n        scope: \"mcp\",\n      }));\n    } catch (err) {\n      debugLog(\"[ctxce] /oauth/token error: \" + String(err));\n      res.statusCode = 400;\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({ error: \"invalid_request\" }));\n    }\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_validateBearerToken_553": {
      "name": "validateBearerToken",
      "type": "function",
      "start_line": 553,
      "end_line": 570,
      "content_hash": "8f36694e6265be16add71d7dab0509a013f2670a",
      "content": "export function validateBearerToken(token) {\n  const tokenData = tokenStore.get(token);\n  if (!tokenData) {\n    return null;\n  }\n\n  // Check token age (24 hour expiry)\n  const tokenAge = Date.now() - tokenData.createdAt;\n  if (tokenAge > 86400000) {\n    tokenStore.delete(token);\n    return null;\n  }\n\n  return {\n    sessionId: tokenData.sessionId,\n    backendUrl: tokenData.backendUrl,\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isOAuthEndpoint_577": {
      "name": "isOAuthEndpoint",
      "type": "function",
      "start_line": 577,
      "end_line": 585,
      "content_hash": "f4ecc41b6b77f9629ab677925ae6b80427aa9e14",
      "content": "export function isOAuthEndpoint(pathname) {\n  return (\n    pathname === \"/.well-known/oauth-authorization-server\" ||\n    pathname === \"/oauth/register\" ||\n    pathname === \"/oauth/authorize\" ||\n    pathname === \"/oauth/store-session\" ||\n    pathname === \"/oauth/token\"\n  );\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}