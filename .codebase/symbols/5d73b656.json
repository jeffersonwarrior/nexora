{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/router/router.rs",
  "file_hash": "2297f9ce5337fc25265dcb336b2d79bcfaab9545",
  "updated_at": "2025-12-26T17:34:23.158497",
  "symbols": {
    "struct_HandlerInput_20": {
      "name": "HandlerInput",
      "type": "struct",
      "start_line": 20,
      "end_line": 32,
      "content_hash": "ef45f3749ba7e0ac7eb94f7ed7902d7f8e9072cc",
      "content": "pub struct HandlerInput {\n    pub request: Request,\n    pub graph: Arc<HelixGraphEngine>,\n}\n\npub type ContMsg = (\n    RetChan,\n    Box<dyn FnOnce() -> Result<Response, GraphError> + Send + Sync>,\n);\npub type ContChan = flume::Sender<ContMsg>;\n\npub type ContFut = Pin<Box<dyn Future<Output = ()> + Send + Sync>>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IoContFn_33": {
      "name": "IoContFn",
      "type": "struct",
      "start_line": 33,
      "end_line": 34,
      "content_hash": "1cec19c52779276dee9a9e7e0affd3a67af5dc5c",
      "content": "pub struct IoContFn(pub Box<dyn FnOnce(ContChan, RetChan) -> ContFut + Send + Sync>);\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IoContFn_35": {
      "name": "IoContFn",
      "type": "impl",
      "start_line": 35,
      "end_line": 43,
      "content_hash": "9f8c953a49601f2c77807b6f4b557092ee2ab02a",
      "content": "impl IoContFn {\n    pub fn create_err<F>(func: F) -> GraphError\n    where\n        F: FnOnce(ContChan, RetChan) -> ContFut + Send + Sync + 'static,\n    {\n        GraphError::IoNeeded(Self(Box::new(func)))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Debug_44": {
      "name": "Debug",
      "type": "impl",
      "start_line": 44,
      "end_line": 44,
      "content_hash": "a6e9dd41ab65829f4386e984aa8517cd7e0e2e7b",
      "content": "impl Debug for IoContFn {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_45": {
      "name": "fmt",
      "type": "method",
      "start_line": 45,
      "end_line": 58,
      "content_hash": "afe96d090d1f03915bad60af435b70724d3516e3",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"Asyncronous IO is needed to complete the DB operation\")\n    }\n}\n\n\n\n// basic type for function pointer\npub type BasicHandlerFn = fn(HandlerInput) -> Result<Response, GraphError>;\n\n// thread safe type for multi threaded use\npub type HandlerFn = Arc<dyn Fn(HandlerInput) -> Result<Response, GraphError> + Send + Sync>;\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HandlerSubmission_59": {
      "name": "HandlerSubmission",
      "type": "struct",
      "start_line": 59,
      "end_line": 61,
      "content_hash": "2d4dee284fd7f9299fd5951878adb6fb6d1fe124",
      "content": "pub struct HandlerSubmission(pub Handler);\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Handler_62": {
      "name": "Handler",
      "type": "struct",
      "start_line": 62,
      "end_line": 67,
      "content_hash": "aa8a922672643679b025023fd9e5b6aa03ff1d0b",
      "content": "pub struct Handler {\n    pub name: &'static str,\n    pub func: BasicHandlerFn,\n    pub is_write: bool,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Handler_68": {
      "name": "Handler",
      "type": "impl",
      "start_line": 68,
      "end_line": 78,
      "content_hash": "14ade53921ffd2d815aef07c15bbdf286df89f5a",
      "content": "impl Handler {\n    pub const fn new(name: &'static str, func: BasicHandlerFn, is_write: bool) -> Self {\n        Self { name, func, is_write }\n    }\n}\n\ninventory::collect!(HandlerSubmission);\n\n/// Router for handling requests and MCP requests\n///\n/// Standard Routes and MCP Routes are stored in a HashMap with the method and path as the key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HelixRouter_79": {
      "name": "HelixRouter",
      "type": "struct",
      "start_line": 79,
      "end_line": 86,
      "content_hash": "2a9c7bbeaaef6a5a6c293d6028266de08c8c1dec",
      "content": "pub struct HelixRouter {\n    /// Name => Function\n    pub routes: HashMap<String, HandlerFn>,\n    pub mcp_routes: HashMap<String, MCPHandlerFn>,\n    /// Set of route names that perform write operations\n    pub write_routes: std::collections::HashSet<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixRouter_87": {
      "name": "HelixRouter",
      "type": "impl",
      "start_line": 87,
      "end_line": 88,
      "content_hash": "119302382197e3c9205f5b706d3fec565ee2ad93",
      "content": "impl HelixRouter {\n    /// Create a new router with a set of routes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_89": {
      "name": "new",
      "type": "method",
      "start_line": 89,
      "end_line": 104,
      "content_hash": "9bc5c8a623442bebf5cf0cee4b2152a9d697e646",
      "content": "    pub fn new(\n        routes: Option<HashMap<String, HandlerFn>>,\n        mcp_routes: Option<HashMap<String, MCPHandlerFn>>,\n        write_routes: Option<std::collections::HashSet<String>>,\n    ) -> Self {\n        let rts = routes.unwrap_or_default();\n        let mcp_rts = mcp_routes.unwrap_or_default();\n        let write_rts = write_routes.unwrap_or_default();\n        Self {\n            routes: rts,\n            mcp_routes: mcp_rts,\n            write_routes: write_rts,\n        }\n    }\n\n    /// Check if a route is a write operation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_write_route_105": {
      "name": "is_write_route",
      "type": "method",
      "start_line": 105,
      "end_line": 109,
      "content_hash": "1113419bc902a16f218cfe55d9df48980b5f116b",
      "content": "    pub fn is_write_route(&self, name: &str) -> bool {\n        self.write_routes.contains(name)\n    }\n\n    /// Add a route to the router",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_route_110": {
      "name": "add_route",
      "type": "method",
      "start_line": 110,
      "end_line": 118,
      "content_hash": "2ef689ba35c42430cb3b266767ce2659809a3a50",
      "content": "    pub fn add_route(&mut self, name: &str, handler: BasicHandlerFn, is_write: bool) {\n        self.routes.insert(name.to_string(), Arc::new(handler));\n        if is_write {\n            self.write_routes.insert(name.to_string());\n        }\n    }\n}\n\n#[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_RouterError_119": {
      "name": "RouterError",
      "type": "enum",
      "start_line": 119,
      "end_line": 123,
      "content_hash": "0d90ef656d37e1b1cc0a99cf1e53c1253711267c",
      "content": "pub enum RouterError {\n    Io(std::io::Error),\n    New(String),\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_fmt::Display_124": {
      "name": "fmt::Display",
      "type": "impl",
      "start_line": 124,
      "end_line": 124,
      "content_hash": "882d72046e4b414d2c1b47839b97ceecb0c6ac11",
      "content": "impl fmt::Display for RouterError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_125": {
      "name": "fmt",
      "type": "method",
      "start_line": 125,
      "end_line": 132,
      "content_hash": "29d086def31f897aae2a4ff136909efd8559eb17",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            RouterError::Io(e) => write!(f, \"IO error: {e}\"),\n            RouterError::New(msg) => write!(f, \"Graph error: {msg}\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_133": {
      "name": "From",
      "type": "impl",
      "start_line": 133,
      "end_line": 133,
      "content_hash": "568e51a5d33ed9365e5530b218b02ac8f5035d66",
      "content": "impl From<String> for RouterError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_134": {
      "name": "from",
      "type": "method",
      "start_line": 134,
      "end_line": 138,
      "content_hash": "6b5522c9d88a2ada9d4432ecb48816e06a8a7f6a",
      "content": "    fn from(error: String) -> Self {\n        RouterError::New(error)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_139": {
      "name": "From",
      "type": "impl",
      "start_line": 139,
      "end_line": 139,
      "content_hash": "95d7220937c614ed6b165b6859d226ccd85e3d3c",
      "content": "impl From<std::io::Error> for RouterError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_140": {
      "name": "from",
      "type": "method",
      "start_line": 140,
      "end_line": 144,
      "content_hash": "5bf547505000ced677b1c5bb3df0488836c67e4a",
      "content": "    fn from(error: std::io::Error) -> Self {\n        RouterError::Io(error)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_145": {
      "name": "From",
      "type": "impl",
      "start_line": 145,
      "end_line": 145,
      "content_hash": "4f6869a6049685ab34d61c2a6bde2156b5e98434",
      "content": "impl From<GraphError> for RouterError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_146": {
      "name": "from",
      "type": "method",
      "start_line": 146,
      "end_line": 150,
      "content_hash": "ab49f83caa6fe875ed05b3245c2aabcfd629d979",
      "content": "    fn from(error: GraphError) -> Self {\n        RouterError::New(error.to_string())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_151": {
      "name": "From",
      "type": "impl",
      "start_line": 151,
      "end_line": 151,
      "content_hash": "be982f82af57ceea346bef12dddc78477886245e",
      "content": "impl From<RouterError> for GraphError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_152": {
      "name": "from",
      "type": "method",
      "start_line": 152,
      "end_line": 163,
      "content_hash": "744a71780c63ac5f486fe707be4e74814de9a516",
      "content": "    fn from(error: RouterError) -> Self {\n        GraphError::New(error.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::protocol::{Format, Response};\n    use std::collections::{HashMap, HashSet};\n\n    // Helper function for tests",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_dummy_handler_164": {
      "name": "dummy_handler",
      "type": "method",
      "start_line": 164,
      "end_line": 170,
      "content_hash": "fd8b3bf23ee4eea6153711ac6351bb311a58a571",
      "content": "    fn dummy_handler(_input: HandlerInput) -> Result<Response, GraphError> {\n        Ok(Response {\n            body: b\"ok\".to_vec(),\n            fmt: Format::Json,\n        })\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_another_handler_171": {
      "name": "another_handler",
      "type": "method",
      "start_line": 171,
      "end_line": 182,
      "content_hash": "518a92f1c4848f68c5107c7f727b1b8885727723",
      "content": "    fn another_handler(_input: HandlerInput) -> Result<Response, GraphError> {\n        Ok(Response {\n            body: b\"another\".to_vec(),\n            fmt: Format::Json,\n        })\n    }\n\n    // ============================================================================\n    // HelixRouter Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_new_empty_183": {
      "name": "test_router_new_empty",
      "type": "method",
      "start_line": 183,
      "end_line": 191,
      "content_hash": "8c98153ced9dc39f90e0a1b5f0088b24648059cb",
      "content": "    fn test_router_new_empty() {\n        let router = HelixRouter::new(None, None, None);\n\n        assert!(router.routes.is_empty());\n        assert!(router.mcp_routes.is_empty());\n        assert!(router.write_routes.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_new_with_routes_192": {
      "name": "test_router_new_with_routes",
      "type": "method",
      "start_line": 192,
      "end_line": 206,
      "content_hash": "7c8147822cff446fcac31a17516fc008d8650b17",
      "content": "    fn test_router_new_with_routes() {\n        let mut routes: HashMap<String, HandlerFn> = HashMap::new();\n        routes.insert(\"test\".to_string(), Arc::new(dummy_handler));\n\n        let mut write_routes = HashSet::new();\n        write_routes.insert(\"test\".to_string());\n\n        let router = HelixRouter::new(Some(routes), None, Some(write_routes));\n\n        assert_eq!(router.routes.len(), 1);\n        assert!(router.routes.contains_key(\"test\"));\n        assert!(router.write_routes.contains(\"test\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_is_write_route_true_207": {
      "name": "test_router_is_write_route_true",
      "type": "method",
      "start_line": 207,
      "end_line": 216,
      "content_hash": "862e991bb847bfe694f442fabab746b911f32ba4",
      "content": "    fn test_router_is_write_route_true() {\n        let mut write_routes = HashSet::new();\n        write_routes.insert(\"write_op\".to_string());\n\n        let router = HelixRouter::new(None, None, Some(write_routes));\n\n        assert!(router.is_write_route(\"write_op\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_is_write_route_false_217": {
      "name": "test_router_is_write_route_false",
      "type": "method",
      "start_line": 217,
      "end_line": 227,
      "content_hash": "fbc51e7489f4bc14167b7d057d2978dbfacaee94",
      "content": "    fn test_router_is_write_route_false() {\n        let mut write_routes = HashSet::new();\n        write_routes.insert(\"write_op\".to_string());\n\n        let router = HelixRouter::new(None, None, Some(write_routes));\n\n        assert!(!router.is_write_route(\"read_op\"));\n        assert!(!router.is_write_route(\"nonexistent\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_add_route_basic_228": {
      "name": "test_router_add_route_basic",
      "type": "method",
      "start_line": 228,
      "end_line": 237,
      "content_hash": "d79106f0e9d0003f7f6fc04ff53eb1f056f45a54",
      "content": "    fn test_router_add_route_basic() {\n        let mut router = HelixRouter::new(None, None, None);\n\n        router.add_route(\"new_route\", dummy_handler, false);\n\n        assert!(router.routes.contains_key(\"new_route\"));\n        assert!(!router.write_routes.contains(\"new_route\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_add_route_as_write_238": {
      "name": "test_router_add_route_as_write",
      "type": "method",
      "start_line": 238,
      "end_line": 248,
      "content_hash": "83b463f0ff3ae58a47f4e0f0f5a2156a303b6ff4",
      "content": "    fn test_router_add_route_as_write() {\n        let mut router = HelixRouter::new(None, None, None);\n\n        router.add_route(\"write_route\", dummy_handler, true);\n\n        assert!(router.routes.contains_key(\"write_route\"));\n        assert!(router.write_routes.contains(\"write_route\"));\n        assert!(router.is_write_route(\"write_route\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_add_route_overwrites_249": {
      "name": "test_router_add_route_overwrites",
      "type": "method",
      "start_line": 249,
      "end_line": 269,
      "content_hash": "bf3ccd035071946b7a51f5606a2a4218606079e8",
      "content": "    fn test_router_add_route_overwrites() {\n        let mut router = HelixRouter::new(None, None, None);\n\n        // Add initial route\n        router.add_route(\"test\", dummy_handler, false);\n        assert!(router.routes.contains_key(\"test\"));\n\n        // Overwrite with new handler\n        router.add_route(\"test\", another_handler, true);\n\n        // Route should still exist (was overwritten)\n        assert!(router.routes.contains_key(\"test\"));\n        // And should now be a write route\n        assert!(router.is_write_route(\"test\"));\n    }\n\n    // ============================================================================\n    // RouterError Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_error_display_new_270": {
      "name": "test_router_error_display_new",
      "type": "method",
      "start_line": 270,
      "end_line": 276,
      "content_hash": "a83110256ece70089f756e403be28eef4db7dcdf",
      "content": "    fn test_router_error_display_new() {\n        let error = RouterError::New(\"test error\".to_string());\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"test error\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_router_error_from_string_277": {
      "name": "test_router_error_from_string",
      "type": "method",
      "start_line": 277,
      "end_line": 284,
      "content_hash": "542d443409c816d7b4c88af99dd37eee0ce02f36",
      "content": "    fn test_router_error_from_string() {\n        let error: RouterError = \"custom error\".to_string().into();\n        match error {\n            RouterError::New(msg) => assert_eq!(msg, \"custom error\"),\n            _ => panic!(\"Expected RouterError::New\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}