{
  "file_path": "/work/internal/config/provider_test.go",
  "file_hash": "41b22597c3a09303ac36d5b3fad89163c7270c9e",
  "updated_at": "2025-12-26T17:34:20.898943",
  "symbols": {
    "struct_mockProviderClient_14": {
      "name": "mockProviderClient",
      "type": "struct",
      "start_line": 14,
      "end_line": 17,
      "content_hash": "257394127a9e8c07d5c769b9b55d3dce0a4d6be7",
      "content": "type mockProviderClient struct {\n\tshouldFail bool\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetProviders_18": {
      "name": "GetProviders",
      "type": "method",
      "start_line": 18,
      "end_line": 28,
      "content_hash": "08366c691ea7ef496833d8784808da5e36612e01",
      "content": "func (m *mockProviderClient) GetProviders(ctx context.Context, githubURL string) ([]catwalk.Provider, error) {\n\tif m.shouldFail {\n\t\treturn nil, errors.New(\"failed to load providers\")\n\t}\n\treturn []catwalk.Provider{\n\t\t{\n\t\t\tName: \"Mock\",\n\t\t},\n\t}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_loadProvidersNoIssues_29": {
      "name": "TestProvider_loadProvidersNoIssues",
      "type": "function",
      "start_line": 29,
      "end_line": 52,
      "content_hash": "eee369cfe326afab3553f941dd64406b55c853b4",
      "content": "func TestProvider_loadProvidersNoIssues(t *testing.T) {\n\tclient := &mockProviderClient{shouldFail: false}\n\ttmpPath := t.TempDir() + \"/providers.json\"\n\tproviders, err := loadProviders(false, client, tmpPath)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, providers)\n\t// Check for required providers instead of exact count\n\tproviderMap := make(map[string]bool)\n\tproviderNames := make(map[string]bool)\n\tfor _, p := range providers {\n\t\tproviderMap[string(p.ID)] = true\n\t\tproviderNames[p.Name] = true\n\t}\n\t// Mock provider from client has no ID, just check by name\n\trequire.True(t, providerNames[\"Mock\"], \"Expected mock provider from client\")\n\t// Check that injected providers are included\n\trequire.True(t, providerMap[\"mistral-general\"], \"Expected mistral-general provider injected\")\n\n\t// check if file got saved\n\tfileInfo, err := os.Stat(tmpPath)\n\trequire.NoError(t, err)\n\trequire.False(t, fileInfo.IsDir(), \"Expected a file, not a directory\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_loadProvidersWithIssues_53": {
      "name": "TestProvider_loadProvidersWithIssues",
      "type": "function",
      "start_line": 53,
      "end_line": 85,
      "content_hash": "d203f4b794134125c020b07c1bc4d8e5c0e96d95",
      "content": "func TestProvider_loadProvidersWithIssues(t *testing.T) {\n\tclient := &mockProviderClient{shouldFail: true}\n\ttmpPath := t.TempDir() + \"/providers.json\"\n\t// store providers to a temporary file\n\toldProviders := []catwalk.Provider{\n\t\t{\n\t\t\tName: \"OldProvider\",\n\t\t},\n\t}\n\tdata, err := json.Marshal(oldProviders)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal old providers: %v\", err)\n\t}\n\n\terr = os.WriteFile(tmpPath, data, 0o644)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to write old providers to file: %v\", err)\n\t}\n\tproviders, err := loadProviders(true, client, tmpPath)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, providers)\n\t// Check that old provider is there + injected providers\n\tproviderMap := make(map[string]bool)\n\tproviderNames := make(map[string]bool)\n\tfor _, p := range providers {\n\t\tproviderMap[string(p.ID)] = true\n\t\tproviderNames[p.Name] = true\n\t}\n\trequire.True(t, providerNames[\"OldProvider\"], \"Expected to keep old provider when loading fails\")\n\trequire.True(t, providerMap[\"mistral-general\"], \"Expected to have mistral-general provider injected\")\n\trequire.True(t, providerMap[\"xai\"], \"Expected to have xai provider injected\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_loadProvidersWithIssuesAndNoCache_86": {
      "name": "TestProvider_loadProvidersWithIssuesAndNoCache",
      "type": "function",
      "start_line": 86,
      "end_line": 94,
      "content_hash": "d3c166001cf97cf7d2f22bdf0bcbce1f0d5245cf",
      "content": "func TestProvider_loadProvidersWithIssuesAndNoCache(t *testing.T) {\n\tclient := &mockProviderClient{shouldFail: true}\n\ttmpPath := t.TempDir() + \"/providers.json\"\n\tproviders, err := loadProviders(false, client, tmpPath)\n\t// When Catwalk fails and no cache, fallback to embedded providers\n\trequire.NoError(t, err)\n\trequire.NotNil(t, providers)\n\trequire.Greater(t, len(providers), 0, \"Expected embedded providers as fallback\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}