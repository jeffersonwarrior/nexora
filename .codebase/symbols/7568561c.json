{
  "file_path": "/work/external-deps/Context-Engine/vscode-extension/context-engine-uploader/extension.js",
  "file_hash": "b67839e51f3db66372c9f5a7d226259dce9da884",
  "updated_at": "2025-12-26T17:34:24.464548",
  "symbols": {
    "function_getEffectiveConfig_42": {
      "name": "getEffectiveConfig",
      "type": "function",
      "start_line": 42,
      "end_line": 48,
      "content_hash": "343fe0e22ddbd7ff1772cee15b5f8cced7943a0d",
      "content": "function getEffectiveConfig() {\n  try {\n    return profiles.getUploaderConfig();\n  } catch (_) {\n    return vscode.workspace.getConfiguration('contextEngineUploader');\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getResolvedTargetPathForSidebar_50": {
      "name": "getResolvedTargetPathForSidebar",
      "type": "function",
      "start_line": 50,
      "end_line": 64,
      "content_hash": "ff88ac941061bb9c61ecfefb23534a940ba5cdf9",
      "content": "function getResolvedTargetPathForSidebar() {\n  try {\n    const config = getEffectiveConfig();\n    const result = resolveTargetPathFromConfig(config);\n    let target = result && result.path ? result.path : undefined;\n    let source = (result && result.inferred) ? 'inferred' : 'settings';\n    if (!target && watchedTargetPath) {\n      target = watchedTargetPath;\n      source = 'runtime';\n    }\n    return { path: target, source };\n  } catch (_) {\n    return { path: watchedTargetPath, source: watchedTargetPath ? 'runtime' : undefined };\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_scheduleRestartAfterProfileChange_66": {
      "name": "scheduleRestartAfterProfileChange",
      "type": "function",
      "start_line": 66,
      "end_line": 84,
      "content_hash": "96445f0ce672b4b488da31cdfd24756c3674cf5c",
      "content": "function scheduleRestartAfterProfileChange() {\n  try {\n    if (pendingProfileRestartTimer) {\n      clearTimeout(pendingProfileRestartTimer);\n      pendingProfileRestartTimer = undefined;\n    }\n  } catch (_) {\n  }\n  try {\n    pendingProfileRestartTimer = setTimeout(() => {\n      pendingProfileRestartTimer = undefined;\n      if (!watchProcess) {\n        return;\n      }\n      runSequence('auto').catch(error => log(`Auto-restart after profile change failed: ${error instanceof Error ? error.message : String(error)}`));\n    }, 250);\n  } catch (_) {\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_activate_86": {
      "name": "activate",
      "type": "function",
      "start_line": 86,
      "end_line": 590,
      "content_hash": "1fe8cd778af534bbb1f3010d75a0c74ea7a824a0",
      "content": "function activate(context) {\n  outputChannel = vscode.window.createOutputChannel('Context Engine Upload');\n  context.subscriptions.push(outputChannel);\n  extensionRoot = context.extensionPath;\n  globalStoragePath = context.globalStorageUri && context.globalStorageUri.fsPath ? context.globalStorageUri.fsPath : undefined;\n  try {\n    profiles.init({\n      vscode,\n      context,\n      log,\n      onProfileChanged: () => {\n        try { ensureTargetPathConfigured(); } catch (_) {}\n        try {\n          if (watchProcess) {\n            scheduleRestartAfterProfileChange();\n          }\n        } catch (_) {}\n      },\n    });\n  } catch (error) {\n    log(`Profiles init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    workspacePathUtils = createWorkspacePathUtils({\n      vscode,\n      path,\n      fs,\n      log,\n      updateStatusBarTooltip,\n    });\n  } catch (error) {\n    workspacePathUtils = undefined;\n    log(`Workspace path utils init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    logsTerminalManager = createLogsTerminalManager({\n      vscode,\n      fs,\n      log,\n      getEffectiveConfig,\n      getWorkspaceFolderPath,\n    });\n  } catch (error) {\n    logsTerminalManager = undefined;\n    log(`Logs terminal manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    promptPlusManager = createPromptPlusManager({\n      vscode,\n      spawn,\n      path,\n      fs,\n      log,\n      extensionRoot,\n      getEffectiveConfig,\n      getTargetPath,\n      getWorkspaceFolderPath,\n      detectDefaultTargetPath,\n      resolveBridgeHttpUrl,\n      getPythonOverridePath: () => pythonOverridePath,\n      appendOutput: (text) => {\n        if (outputChannel) {\n          outputChannel.append(text);\n        }\n      },\n    });\n  } catch (error) {\n    promptPlusManager = undefined;\n    log(`Prompt+ manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    onboardingManager = createOnboardingManager({\n      vscode,\n      context,\n      log,\n      appendOutput: text => {\n        if (outputChannel) {\n          outputChannel.append(text);\n        }\n      },\n      showOutput: () => {\n        if (outputChannel) {\n          outputChannel.show(true);\n        }\n      },\n    });\n  } catch (error) {\n    onboardingManager = undefined;\n    log(`Onboarding manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    bridgeManager = createBridgeManager({\n      vscode,\n      spawn,\n      log,\n      getEffectiveConfig,\n      resolveBridgeWorkspacePath,\n      normalizeBridgeUrl,\n      normalizeWorkspaceForBridge,\n      resolveBridgeCliInvocation,\n      attachOutput,\n      terminateProcess,\n      scheduleMcpConfigRefreshAfterBridge,\n    });\n  } catch (error) {\n    bridgeManager = undefined;\n    log(`Bridge manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    ctxConfigManager = createCtxConfigManager({\n      vscode,\n      spawnSync,\n      log,\n      extensionRoot,\n      getEffectiveConfig,\n      resolveOptions,\n      ensurePythonDependencies,\n      buildChildEnv,\n      resolveBridgeHttpUrl,\n    });\n  } catch (error) {\n    ctxConfigManager = undefined;\n    log(`CTX config manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    mcpConfigManager = createMcpConfigManager({\n      vscode,\n      log,\n      extensionRoot,\n      getEffectiveConfig,\n      getWorkspaceFolderPath,\n      resolveBridgeWorkspacePath,\n      normalizeBridgeUrl,\n      normalizeWorkspaceForBridge,\n      resolveBridgeCliInvocation,\n      resolveBridgeHttpUrl,\n      requiresHttpBridge,\n      ensureHttpBridgeReadyForConfigs,\n      getBridgeIsRunning: () => (bridgeManager && typeof bridgeManager.isRunning === 'function' ? bridgeManager.isRunning() : false),\n      writeCtxConfig,\n    });\n  } catch (error) {\n    mcpConfigManager = undefined;\n    log(`MCP config manager init failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    // Ensure manager resources are cleaned up when the extension deactivates.\n    const managerDisposable = {\n      dispose: () => {\n        try { if (mcpConfigManager && typeof mcpConfigManager.dispose === 'function') mcpConfigManager.dispose(); } catch (_) {}\n        try { if (ctxConfigManager && typeof ctxConfigManager.dispose === 'function') ctxConfigManager.dispose(); } catch (_) {}\n        try { if (bridgeManager && typeof bridgeManager.dispose === 'function') bridgeManager.dispose(); } catch (_) {}\n        try { if (logsTerminalManager && typeof logsTerminalManager.dispose === 'function') logsTerminalManager.dispose(); } catch (_) {}\n        try { if (promptPlusManager && typeof promptPlusManager.dispose === 'function') promptPlusManager.dispose(); } catch (_) {}\n        try { if (onboardingManager && typeof onboardingManager.dispose === 'function') onboardingManager.dispose(); } catch (_) {}\n      }\n    };\n    context.subscriptions.push(managerDisposable);\n  } catch (_) {\n    // ignore\n  }\n  try {\n    const venvPy = resolvePrivateVenvPython();\n    if (venvPy) {\n      pythonOverridePath = venvPy;\n      log(`Detected existing private venv interpreter: ${venvPy}`);\n    }\n  } catch (_) {}\n  statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);\n  statusBarItem.command = 'contextEngineUploader.indexCodebase';\n  context.subscriptions.push(statusBarItem);\n  statusBarItem.show();\n  setStatusBarState('idle');\n  updateStatusBarTooltip();\n  promptStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 90);\n  promptStatusBarItem.command = 'contextEngineUploader.promptEnhance';\n  promptStatusBarItem.text = '$(sparkle) Prompt+';\n  promptStatusBarItem.tooltip = 'Enhance selection with Unicorn Mode via ctx.py';\n  context.subscriptions.push(promptStatusBarItem);\n  promptStatusBarItem.show();\n\n\n  try {\n    const disposables = profiles.registerCommands({\n      resolveTargetPathFromConfig,\n      getWorkspaceFolderPath,\n      detectDefaultTargetPath,\n      normalizeWorkspaceForBridge,\n      runSequence,\n      writeMcpConfig,\n      writeCtxConfig,\n      fetch: (typeof fetch === 'function' ? fetch : undefined),\n    });\n    if (Array.isArray(disposables)) {\n      context.subscriptions.push(...disposables);\n    }\n  } catch (error) {\n    log(`Profiles command registration failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  try {\n    sidebarApi = sidebar.register(context, {\n      profiles,\n      getEffectiveConfig,\n      getResolvedTargetPath: getResolvedTargetPathForSidebar,\n      getState: () => ({\n        statusMode,\n        httpBridgeProcess: bridgeManager ? bridgeManager.getState().process : undefined,\n        httpBridgePort: bridgeManager ? bridgeManager.getState().port : undefined,\n      }),\n      onboarding: onboardingManager,\n    });\n  } catch (error) {\n    log(`Sidebar registration failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  const startDisposable = vscode.commands.registerCommand('contextEngineUploader.start', () => {\n    runSequence('auto').catch(error => log(`Start failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const stopDisposable = vscode.commands.registerCommand('contextEngineUploader.stop', () => {\n    stopProcesses().catch(error => log(`Stop failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const restartDisposable = vscode.commands.registerCommand('contextEngineUploader.restart', () => {\n    stopProcesses().then(() => runSequence('auto')).catch(error => log(`Restart failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const indexDisposable = vscode.commands.registerCommand('contextEngineUploader.indexCodebase', () => {\n    vscode.window.showInformationMessage('Context Engine indexing started.');\n    if (outputChannel) { outputChannel.show(true); }\n    runSequence('force').catch(error => log(`Index failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const uploadGitHistoryDisposable = vscode.commands.registerCommand('contextEngineUploader.uploadGitHistory', () => {\n    vscode.window.showInformationMessage('Context Engine git history upload (force sync bundle) started.');\n    if (outputChannel) { outputChannel.show(true); }\n    runSequence('force').catch(error => log(`Git history upload failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const ctxConfigDisposable = vscode.commands.registerCommand('contextEngineUploader.writeCtxConfig', () => {\n    writeCtxConfig().catch(error => log(`CTX config write failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const mcpConfigDisposable = vscode.commands.registerCommand('contextEngineUploader.writeMcpConfig', () => {\n    writeMcpConfig().catch(error => log(`MCP config write failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const mcpConfigSelectDisposable = vscode.commands.registerCommand('contextEngineUploader.writeMcpConfigSelect', async () => {\n    try {\n      const cfg = getEffectiveConfig();\n      const claudeEnabled = !!cfg.get('mcpClaudeEnabled', true);\n      const windsurfEnabled = !!cfg.get('mcpWindsurfEnabled', false);\n      const augmentEnabled = !!cfg.get('mcpAugmentEnabled', false);\n\n      const items = [\n        {\n          label: 'All enabled targets',\n          description: 'Writes MCP config for all enabled clients',\n          id: 'all',\n        },\n        {\n          label: 'Claude Code (.mcp.json)',\n          description: claudeEnabled ? 'Enabled' : 'Disabled in settings',\n          id: 'claude',\n        },\n        {\n          label: 'Windsurf (mcp_config.json)',\n          description: windsurfEnabled ? 'Enabled' : 'Disabled in settings',\n          id: 'windsurf',\n        },\n        {\n          label: 'Augment Code (~/.augment/settings.json)',\n          description: augmentEnabled ? 'Enabled' : 'Disabled in settings',\n          id: 'augment',\n        },\n      ];\n\n      const picked = await vscode.window.showQuickPick(items, { placeHolder: 'Select which MCP config to write' });\n      if (!picked) {\n        return;\n      }\n\n      if (picked.id === 'all') {\n        await writeMcpConfig();\n      } else if (picked.id === 'claude') {\n        await writeMcpConfig({ targets: ['claude'] });\n      } else if (picked.id === 'windsurf') {\n        await writeMcpConfig({ targets: ['windsurf'] });\n      } else if (picked.id === 'augment') {\n        await writeMcpConfig({ targets: ['augment'] });\n      }\n    } catch (error) {\n      log(`MCP config select failed: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to select MCP config target. See output for details.');\n    }\n  });\n  const mcpConfigClaudeDisposable = vscode.commands.registerCommand('contextEngineUploader.writeMcpConfigClaude', () => {\n    writeMcpConfig({ targets: ['claude'] }).catch(error => log(`Claude MCP config write failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const mcpConfigWindsurfDisposable = vscode.commands.registerCommand('contextEngineUploader.writeMcpConfigWindsurf', () => {\n    writeMcpConfig({ targets: ['windsurf'] }).catch(error => log(`Windsurf MCP config write failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const mcpConfigAugmentDisposable = vscode.commands.registerCommand('contextEngineUploader.writeMcpConfigAugment', () => {\n    writeMcpConfig({ targets: ['augment'] }).catch(error => log(`Augment MCP config write failed: ${error instanceof Error ? error.message : String(error)}`));\n  });\n  const cloneStackDisposable = vscode.commands.registerCommand('contextEngineUploader.cloneAndStartStack', () => {\n    if (!onboardingManager || typeof onboardingManager.cloneAndStartStack !== 'function') {\n      vscode.window.showErrorMessage('Context Engine onboarding is unavailable in this session.');\n      return;\n    }\n    onboardingManager.cloneAndStartStack();\n  });\n  const startStackDisposable = vscode.commands.registerCommand('contextEngineUploader.startSavedStack', () => {\n    if (!onboardingManager || typeof onboardingManager.startSavedStack !== 'function') {\n      vscode.window.showErrorMessage('Context Engine onboarding is unavailable in this session.');\n      return;\n    }\n    onboardingManager.startSavedStack();\n  });\n  const showLogsDisposable = vscode.commands.registerCommand('contextEngineUploader.showUploadServiceLogs', () => {\n    try {\n      if (outputChannel) {\n        outputChannel.show(true);\n      } else {\n        vscode.window.showErrorMessage('Context Engine Uploader: output channel is unavailable.');\n      }\n    } catch (e) {\n      log(`Show logs failed: ${e && e.message ? e.message : String(e)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to show logs. See output for details.');\n    }\n  });\n  const tailDockerLogsDisposable = vscode.commands.registerCommand('contextEngineUploader.tailUploadServiceLogs', () => {\n    try {\n      if (logsTerminalManager && typeof logsTerminalManager.open === 'function') {\n        logsTerminalManager.open();\n      } else {\n        vscode.window.showErrorMessage('Context Engine Uploader: log tailing is unavailable (extension failed to initialize logs terminal manager). See output for details.');\n      }\n    } catch (e) {\n      log(`Tail docker logs failed: ${e && e.message ? e.message : String(e)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to tail upload service logs. See output for details.');\n    }\n  });\n  const startBridgeDisposable = vscode.commands.registerCommand('contextEngineUploader.startMcpHttpBridge', () => {\n    startHttpBridgeProcess().catch(error => {\n      log(`HTTP MCP bridge start failed: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to start HTTP MCP bridge. Check Output for details.');\n    });\n  });\n  const stopBridgeDisposable = vscode.commands.registerCommand('contextEngineUploader.stopMcpHttpBridge', () => {\n    stopHttpBridgeProcess().catch(error => {\n      log(`HTTP MCP bridge stop failed: ${error instanceof Error ? error.message : String(error)}`);\n    });\n  });\n  try {\n    const promptDisposables = registerPromptPlusCommands({\n      vscode,\n      fs,\n      path,\n      log,\n      getEffectiveConfig,\n      resolveTargetPathFromConfig,\n      writeCtxConfig,\n      getPromptPlusManager: () => promptPlusManager,\n      getSidebarApi: () => sidebarApi,\n    });\n    if (Array.isArray(promptDisposables) && promptDisposables.length) {\n      context.subscriptions.push(...promptDisposables);\n    }\n  } catch (error) {\n    log(`Prompt+ command registration failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  const authLoginDisposable = vscode.commands.registerCommand('contextEngineUploader.authLogin', () => {\n    try {\n      const cfg = getEffectiveConfig();\n      const endpoint = (cfg.get('endpoint') || '').trim();\n      runAuthLoginFlow(endpoint || undefined, buildAuthDeps()).catch(error => {\n        log(`Auth login failed: ${error instanceof Error ? error.message : String(error)}`);\n        vscode.window.showErrorMessage('Context Engine Uploader: auth login failed. See output for details.');\n      });\n    } catch (error) {\n      runAuthLoginFlow(undefined, buildAuthDeps()).catch(error2 => {\n        log(`Auth login failed: ${error2 instanceof Error ? error2.message : String(error2)}`);\n        vscode.window.showErrorMessage('Context Engine Uploader: auth login failed. See output for details.');\n      });\n    }\n  });\n  const configDisposable = vscode.workspace.onDidChangeConfiguration(event => {\n    if (event.affectsConfiguration('contextEngineUploader') && watchProcess) {\n      runSequence('auto').catch(error => log(`Auto-restart failed: ${error instanceof Error ? error.message : String(error)}`));\n    }\n    if (event.affectsConfiguration('contextEngineUploader.targetPath')) {\n      updateStatusBarTooltip();\n    }\n    if (\n      event.affectsConfiguration('contextEngineUploader.mcpIndexerUrl') ||\n      event.affectsConfiguration('contextEngineUploader.mcpMemoryUrl') ||\n      event.affectsConfiguration('contextEngineUploader.mcpClaudeEnabled') ||\n      event.affectsConfiguration('contextEngineUploader.mcpWindsurfEnabled') ||\n      event.affectsConfiguration('contextEngineUploader.mcpAugmentEnabled') ||\n      event.affectsConfiguration('contextEngineUploader.mcpTransportMode') ||\n      event.affectsConfiguration('contextEngineUploader.windsurfMcpPath') ||\n      event.affectsConfiguration('contextEngineUploader.augmentMcpPath') ||\n      event.affectsConfiguration('contextEngineUploader.claudeHookEnabled') ||\n      event.affectsConfiguration('contextEngineUploader.surfaceQdrantCollectionHint')\n    ) {\n      // Best-effort auto-update of MCP + hook configurations when settings change\n      writeMcpConfig().catch(error => log(`Auto MCP config write failed: ${error instanceof Error ? error.message : String(error)}`));\n    }\n    if (\n      event.affectsConfiguration('contextEngineUploader.autoStartMcpBridge') ||\n      event.affectsConfiguration('contextEngineUploader.mcpBridgePort') ||\n      event.affectsConfiguration('contextEngineUploader.mcpBridgeBinPath') ||\n      event.affectsConfiguration('contextEngineUploader.mcpBridgeLocalOnly') ||\n      event.affectsConfiguration('contextEngineUploader.mcpIndexerUrl') ||\n      event.affectsConfiguration('contextEngineUploader.mcpMemoryUrl') ||\n      event.affectsConfiguration('contextEngineUploader.mcpServerMode') ||\n      event.affectsConfiguration('contextEngineUploader.mcpTransportMode')\n    ) {\n      handleHttpBridgeSettingsChanged().catch(error => log(`HTTP MCP bridge restart failed: ${error instanceof Error ? error.message : String(error)}`));\n    }\n  });\n  const workspaceDisposable = vscode.workspace.onDidChangeWorkspaceFolders(() => {\n    ensureTargetPathConfigured();\n  });\n  const terminalCloseDisposable = vscode.window.onDidCloseTerminal(term => {\n    try {\n      if (logsTerminalManager && typeof logsTerminalManager.handleDidCloseTerminal === 'function') {\n        logsTerminalManager.handleDidCloseTerminal(term);\n      }\n    } catch (_) {}\n  });\n  context.subscriptions.push(\n    startDisposable,\n    stopDisposable,\n    restartDisposable,\n    indexDisposable,\n    uploadGitHistoryDisposable,\n    cloneStackDisposable,\n    startStackDisposable,\n    showLogsDisposable,\n    tailDockerLogsDisposable,\n    authLoginDisposable,\n    startBridgeDisposable,\n    stopBridgeDisposable,\n    mcpConfigDisposable,\n    mcpConfigSelectDisposable,\n    mcpConfigClaudeDisposable,\n    mcpConfigWindsurfDisposable,\n    mcpConfigAugmentDisposable,\n    ctxConfigDisposable,\n    configDisposable,\n    workspaceDisposable,\n    terminalCloseDisposable\n  );\n  const config = getEffectiveConfig();\n  ensureTargetPathConfigured();\n// TODO: organise in another modulenise in another module\n  try {\n    const endpoint = (config.get('endpoint') || '').trim();\n    const resolved = resolveTargetPathFromConfig(config);\n    const targetPath = resolved && resolved.path ? String(resolved.path).trim() : '';\n    const needsSetup = !endpoint || !targetPath;\n    if (needsSetup && context && context.workspaceState) {\n      const alreadyPrompted = !!context.workspaceState.get(ONBOARDING_PROMPT_KEY);\n      if (!alreadyPrompted) {\n        context.workspaceState.update(ONBOARDING_PROMPT_KEY, true).catch(() => {});\n        vscode.window.showInformationMessage(\n          'Context Engine Uploader: finish setup for this workspace to start indexing/uploading.',\n          'Setup Workspace',\n          'Later'\n        ).then(choice => {\n          if (choice === 'Setup Workspace') {\n            vscode.commands.executeCommand('contextEngineUploader.setupWorkspace');\n          }\n        });\n      }\n    }\n  } catch (_) {\n  }\n  if (config.get('runOnStartup')) {\n    runSequence('auto').catch(error => log(`Startup run failed: ${error instanceof Error ? error.message : String(error)}`));\n  }\n\n  // Optionally keep MCP + hook + ctx config in sync on activation\n  if (config.get('autoWriteMcpConfigOnStartup')) {\n    writeMcpConfig().catch(error => log(`MCP config auto-write on activation failed: ${error instanceof Error ? error.message : String(error)}`));\n  } else if (config.get('scaffoldCtxConfig', true)) {\n    // Legacy behavior: scaffold ctx_config.json/.env directly when MCP auto-write is disabled\n    writeCtxConfig().catch(error => log(`CTX config auto-scaffold on activation failed: ${error instanceof Error ? error.message : String(error)}`));\n  }\n  if (config.get('autoStartMcpBridge', false)) {\n    const transportModeRaw = config.get('mcpTransportMode') || 'sse-remote';\n    const serverModeRaw = config.get('mcpServerMode') || 'bridge';\n    const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n    const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n    if (requiresHttpBridge(serverMode, transportMode)) {\n      startHttpBridgeProcess().catch(error => log(`Auto-start HTTP MCP bridge failed: ${error instanceof Error ? error.message : String(error)}`));\n    } else {\n      log('Context Engine Uploader: autoStartMcpBridge is enabled, but current MCP wiring does not use the HTTP bridge; skipping auto-start.');\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_buildAuthDeps_591": {
      "name": "buildAuthDeps",
      "type": "function",
      "start_line": 591,
      "end_line": 603,
      "content_hash": "b783affe0139e2644e0d7751c0026bcfe477536e",
      "content": "function buildAuthDeps() {\n  return {\n    vscode,\n    spawn,\n    spawnSync,\n    resolveBridgeCliInvocation,\n    getWorkspaceFolderPath,\n    attachOutput,\n    log,\n    getEffectiveConfig,\n    fetchGlobal: (typeof fetch === 'function' ? fetch : undefined),\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runSequence_604": {
      "name": "runSequence",
      "type": "function",
      "start_line": 604,
      "end_line": 644,
      "content_hash": "f3709ed29598e6f1f9f261320b4f9e42c0b4d007",
      "content": "async function runSequence(mode = 'auto') {\n  const options = resolveOptions();\n  if (!options) {\n    return;\n  }\n\n  try {\n    await ensureAuthIfRequired(options.endpoint, buildAuthDeps());\n  } catch (error) {\n    log(`Auth preflight check failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  const depsSatisfied = await ensurePythonDependencies(options.pythonPath);\n  if (!depsSatisfied) {\n    setStatusBarState('idle');\n    return;\n  }\n  // Re-resolve options in case ensurePythonDependencies switched to a better interpreter\n  const reoptions = resolveOptions();\n  if (reoptions) {\n    Object.assign(options, reoptions);\n  }\n  await stopProcesses();\n  const needsForce = mode === 'force' || needsForceSync(options.targetPath);\n  if (needsForce) {\n    setStatusBarState('indexing');\n    if (outputChannel) { outputChannel.show(true); }\n    const code = await runOnce(options);\n    if (code === 0) {\n      setStatusBarState('indexed');\n      ensureIndexedWatcher(options.targetPath);\n      if (options.startWatchAfterForce) {\n        startWatch(options);\n      }\n    } else {\n      setStatusBarState('idle');\n    }\n    return;\n  }\n  startWatch(options);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveOptions_645": {
      "name": "resolveOptions",
      "type": "function",
      "start_line": 645,
      "end_line": 718,
      "content_hash": "b9afe95298581f5412fa3471a06466c61f8f6f52",
      "content": "function resolveOptions() {\n  const config = getEffectiveConfig();\n  let pythonPath = (config.get('pythonPath') || 'python3').trim();\n  if (pythonOverridePath && fs.existsSync(pythonOverridePath)) {\n    pythonPath = pythonOverridePath;\n  }\n  const endpoint = (config.get('endpoint') || '').trim();\n  const targetPath = getTargetPath(config);\n  const interval = config.get('intervalSeconds') || 5;\n  const extraForceArgs = config.get('extraForceArgs') || [];\n  const extraWatchArgs = config.get('extraWatchArgs') || [];\n  const hostRootOverride = (config.get('hostRoot') || '').trim();\n  const containerRoot = (config.get('containerRoot') || DEFAULT_CONTAINER_ROOT).trim() || DEFAULT_CONTAINER_ROOT;\n  const startWatchAfterForce = config.get('startWatchAfterForce', true);\n  const configuredScriptDir = (config.get('scriptWorkingDirectory') || '').trim();\n  const candidates = [];\n  if (configuredScriptDir) {\n    candidates.push(configuredScriptDir);\n  }\n  // Prefer packaged script; also try workspace ./scripts fallback for dev\n  candidates.push(extensionRoot);\n  const wsRoot = getWorkspaceFolderPath();\n  if (wsRoot) {\n    candidates.push(path.join(wsRoot, 'scripts'));\n  }\n  candidates.push(path.join(extensionRoot, '..', 'out'));\n  let workingDirectory;\n  let scriptPath;\n  for (const candidate of candidates) {\n    if (!candidate) {\n      continue;\n    }\n    const resolved = path.resolve(candidate);\n    const testPath = path.join(resolved, 'standalone_upload_client.py');\n    if (fs.existsSync(testPath)) {\n      workingDirectory = resolved;\n      scriptPath = testPath;\n      break;\n    }\n  }\n  if (!workingDirectory || !scriptPath) {\n    vscode.window.showErrorMessage('Context Engine Uploader: extension path unavailable.');\n    return undefined;\n  }\n  const scriptSource = workingDirectory === extensionRoot ? 'packaged' : (workingDirectory.includes('\\\\out') || workingDirectory.endsWith('/out') ? 'staged out' : 'custom');\n  if (!endpoint) {\n    vscode.window.showErrorMessage('Context Engine Uploader: set contextEngineUploader.endpoint.');\n    return undefined;\n  }\n  if (!targetPath) {\n    return undefined;\n  }\n  const resolvedTarget = path.resolve(targetPath);\n  let derivedHostRoot = path.dirname(resolvedTarget);\n  if (!derivedHostRoot || derivedHostRoot === resolvedTarget) {\n    derivedHostRoot = resolvedTarget;\n  }\n  const hostRoot = hostRootOverride || derivedHostRoot;\n  log(`Using ${scriptSource} standalone_upload_client.py at ${scriptPath}`);\n  log(`Uploader path mapping hostRoot=${hostRoot || 'n/a'} -> containerRoot=${containerRoot}`);\n  return {\n    pythonPath,\n    workingDirectory,\n    scriptPath,\n    targetPath,\n    endpoint,\n    interval,\n    extraForceArgs,\n    extraWatchArgs,\n    hostRoot,\n    containerRoot,\n    startWatchAfterForce\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveTargetPathFromConfig_719": {
      "name": "resolveTargetPathFromConfig",
      "type": "function",
      "start_line": 719,
      "end_line": 724,
      "content_hash": "4eb21091fd563cd6c2797b55a0d3097e3a25732c",
      "content": "function resolveTargetPathFromConfig(config) {\n  if (workspacePathUtils && typeof workspacePathUtils.resolveTargetPathFromConfig === 'function') {\n    return workspacePathUtils.resolveTargetPathFromConfig(config);\n  }\n  return { path: (config.get('targetPath') || '').trim(), inspected: {}, inferred: false };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getTargetPath_726": {
      "name": "getTargetPath",
      "type": "function",
      "start_line": 726,
      "end_line": 731,
      "content_hash": "d848568cd8f229e7e609f3933e63bb31c271c426",
      "content": "function getTargetPath(config) {\n  if (workspacePathUtils && typeof workspacePathUtils.getTargetPath === 'function') {\n    return workspacePathUtils.getTargetPath(config);\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_saveTargetPath_732": {
      "name": "saveTargetPath",
      "type": "function",
      "start_line": 732,
      "end_line": 736,
      "content_hash": "00ac14b8cba66225716eae76b3caa2bda35f75f5",
      "content": "function saveTargetPath(config, targetPath) {\n  if (workspacePathUtils && typeof workspacePathUtils.saveTargetPath === 'function') {\n    return workspacePathUtils.saveTargetPath(config, targetPath);\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getWorkspaceFolderPath_737": {
      "name": "getWorkspaceFolderPath",
      "type": "function",
      "start_line": 737,
      "end_line": 743,
      "content_hash": "48d0b711fd4593479a101ceacb32696c88ca7c14",
      "content": "function getWorkspaceFolderPath() {\n  if (workspacePathUtils && typeof workspacePathUtils.getWorkspaceFolderPath === 'function') {\n    return workspacePathUtils.getWorkspaceFolderPath();\n  }\n  const folders = vscode.workspace.workspaceFolders;\n  return (folders && folders.length) ? folders[0].uri.fsPath : undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_scheduleMcpConfigRefreshAfterBridge_744": {
      "name": "scheduleMcpConfigRefreshAfterBridge",
      "type": "function",
      "start_line": 744,
      "end_line": 752,
      "content_hash": "30955ad11162154c01c48d9d5e0aa278c1071a94",
      "content": "function scheduleMcpConfigRefreshAfterBridge(delayMs = 1500) {\n  try {\n    if (mcpConfigManager && typeof mcpConfigManager.scheduleMcpConfigRefreshAfterBridge === 'function') {\n      return mcpConfigManager.scheduleMcpConfigRefreshAfterBridge(delayMs);\n    }\n  } catch (error) {\n    log(`Context Engine Uploader: failed to schedule MCP config refresh: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectDefaultTargetPath_753": {
      "name": "detectDefaultTargetPath",
      "type": "function",
      "start_line": 753,
      "end_line": 758,
      "content_hash": "92fe35046c76550c9522b71d010e6b0a2fffbb03",
      "content": "function detectDefaultTargetPath(workspaceFolderPath) {\n  if (workspacePathUtils && typeof workspacePathUtils.detectDefaultTargetPath === 'function') {\n    return workspacePathUtils.detectDefaultTargetPath(workspaceFolderPath);\n  }\n  return workspaceFolderPath;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveBridgeWorkspacePath_760": {
      "name": "resolveBridgeWorkspacePath",
      "type": "function",
      "start_line": 760,
      "end_line": 781,
      "content_hash": "b76cdb78831416636588a5e1841a803baed43a9d",
      "content": "function resolveBridgeWorkspacePath() {\n  try {\n    const settings = getEffectiveConfig();\n    const target = getTargetPath(settings);\n    if (target) {\n      return path.resolve(target);\n    }\n  } catch (error) {\n    log(`Context Engine Uploader: failed to resolve bridge workspace path via getTargetPath: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  const fallbackFolder = getWorkspaceFolderPath();\n  if (!fallbackFolder) {\n    return undefined;\n  }\n  try {\n    const autoTarget = detectDefaultTargetPath(fallbackFolder);\n    return autoTarget ? path.resolve(autoTarget) : path.resolve(fallbackFolder);\n  } catch (error) {\n    log(`Context Engine Uploader: failed fallback bridge workspace path detection: ${error instanceof Error ? error.message : String(error)}`);\n    return undefined;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensureTargetPathConfigured_783": {
      "name": "ensureTargetPathConfigured",
      "type": "function",
      "start_line": 783,
      "end_line": 797,
      "content_hash": "46e9e830bc4a68d10a38b210c40d3fb27f7b7f3b",
      "content": "function ensureTargetPathConfigured() {\n  const config = getEffectiveConfig();\n  const current = (config.get('targetPath') || '').trim();\n  if (current) {\n    updateStatusBarTooltip(current);\n    return;\n  }\n  const folderPath = getWorkspaceFolderPath();\n  if (!folderPath) {\n    updateStatusBarTooltip();\n    return;\n  }\n  const autoTarget = detectDefaultTargetPath(folderPath);\n  updateStatusBarTooltip(autoTarget);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_updateStatusBarTooltip_798": {
      "name": "updateStatusBarTooltip",
      "type": "function",
      "start_line": 798,
      "end_line": 807,
      "content_hash": "81e2e1bb4d7421f5c573147e43deaad6b2e1ede9",
      "content": "  function updateStatusBarTooltip(targetPath) {\n  if (!statusBarItem) {\n    return;\n  }\n  if (targetPath) {\n    statusBarItem.tooltip = `Index Codebase (${targetPath})`;\n  } else {\n    statusBarItem.tooltip = 'Index Codebase';\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_needsForceSync_808": {
      "name": "needsForceSync",
      "type": "function",
      "start_line": 808,
      "end_line": 820,
      "content_hash": "c8adab9e88354aa00603a0a337fd48e59788f1ca",
      "content": "function needsForceSync(targetPath) {\n  try {\n    const cachePath = path.join(targetPath, '.context-engine', 'file_cache.json');\n    if (!fs.existsSync(cachePath)) {\n      return true;\n    }\n    const stats = fs.statSync(cachePath);\n    return stats.size === 0;\n  } catch (error) {\n    log(`Force detection failed: ${error instanceof Error ? error.message : String(error)}`);\n    return true;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensurePythonDependencies_821": {
      "name": "ensurePythonDependencies",
      "type": "function",
      "start_line": 821,
      "end_line": 860,
      "content_hash": "a438c202f5f649f4e16fd41cb26fdbad6e07f1db",
      "content": "async function ensurePythonDependencies(pythonPath) {\n  // Probe current interpreter with bundled python_libs first\n  let ok = await checkPythonDeps(pythonPath);\n  if (ok) {\n    return true;\n  }\n\n  // If that fails, try to auto-detect a better system Python before falling back to a venv\n  const autoPython = await detectSystemPython();\n  if (autoPython && autoPython !== pythonPath) {\n    log(`Falling back to auto-detected Python interpreter: ${autoPython}`);\n    ok = await checkPythonDeps(autoPython);\n    if (ok) {\n      pythonOverridePath = autoPython;\n      return true;\n    }\n  }\n\n  // As a last resort, offer to create a private venv and install deps via pip\n  const choice = await vscode.window.showErrorMessage(\n    'Context Engine Uploader: missing Python modules. Create isolated environment and auto-install?',\n    'Auto-install to private venv',\n    'Cancel'\n  );\n  if (choice !== 'Auto-install to private venv') {\n    return false;\n  }\n  const created = await ensurePrivateVenv();\n  if (!created) return false;\n  const venvPython = resolvePrivateVenvPython();\n  if (!venvPython) {\n    vscode.window.showErrorMessage('Context Engine Uploader: failed to locate private venv python.');\n    return false;\n  }\n  const installed = await installDepsInto(venvPython);\n  if (!installed) return false;\n  pythonOverridePath = venvPython;\n  log(`Using private venv interpreter: ${pythonOverridePath}`);\n  return await checkPythonDeps(venvPython);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_checkPythonDeps_862": {
      "name": "checkPythonDeps",
      "type": "function",
      "start_line": 862,
      "end_line": 897,
      "content_hash": "6e87481287bf1e311ba7fa9e91eefc9a389c2a0b",
      "content": "async function checkPythonDeps(pythonPath) {\n  const missing = [];\n  let pythonError;\n  const env = { ...process.env };\n  try {\n    const libsPath = path.join(extensionRoot, 'python_libs');\n    if (fs.existsSync(libsPath)) {\n      const existing = env.PYTHONPATH || '';\n      env.PYTHONPATH = existing ? `${libsPath}${path.delimiter}${existing}` : libsPath;\n      log(`Using bundled python_libs at ${libsPath} for dependency check.`);\n    }\n  } catch (error) {\n    log(`Failed to configure PYTHONPATH for dependency check: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  for (const moduleName of REQUIRED_PYTHON_MODULES) {\n    const check = spawnSync(pythonPath, ['-c', `import ${moduleName}`], { encoding: 'utf8', env });\n    if (check.error) {\n      pythonError = check.error;\n      break;\n    }\n    if (check.status !== 0) {\n      missing.push(moduleName);\n    }\n  }\n  if (pythonError) {\n    const message = `Context Engine Uploader: failed to run ${pythonPath}. Update contextEngineUploader.pythonPath.`;\n    vscode.window.showErrorMessage(message);\n    log(`Dependency check failed: ${pythonError.message || pythonError}`);\n    return false;\n  }\n  if (missing.length) {\n    log(`Missing Python modules for ${pythonPath}: ${missing.join(', ')}`);\n    return false;\n  }\n  return true;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_venvRootDir_899": {
      "name": "venvRootDir",
      "type": "function",
      "start_line": 899,
      "end_line": 910,
      "content_hash": "fe82bbc89b4f64b2425ca33f1214f7c6e1894496",
      "content": "function venvRootDir() {\n  // Prefer workspace storage; fallback to extension storage\n  try {\n    const ws = getWorkspaceFolderPath();\n    const base = ws && fs.existsSync(ws) ? path.join(ws, '.vscode', '.context-engine-uploader')\n      : (globalStoragePath || path.join(extensionRoot, '.storage'));\n    if (!fs.existsSync(base)) fs.mkdirSync(base, { recursive: true });\n    return base;\n  } catch (e) {\n    return extensionRoot;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_privateVenvPath_912": {
      "name": "privateVenvPath",
      "type": "function",
      "start_line": 912,
      "end_line": 914,
      "content_hash": "90d652b65ab740df0785a18e72be72dc263d3afd",
      "content": "function privateVenvPath() {\n  return path.join(venvRootDir(), 'py-venv');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolvePrivateVenvPython_916": {
      "name": "resolvePrivateVenvPython",
      "type": "function",
      "start_line": 916,
      "end_line": 920,
      "content_hash": "a65de5455ad46d0bb84c82471348c842ee65bae2",
      "content": "function resolvePrivateVenvPython() {\n  const venvPath = privateVenvPath();\n  const bin = process.platform === 'win32' ? path.join(venvPath, 'Scripts', 'python.exe') : path.join(venvPath, 'bin', 'python');\n  return fs.existsSync(bin) ? bin : undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensurePrivateVenv_922": {
      "name": "ensurePrivateVenv",
      "type": "function",
      "start_line": 922,
      "end_line": 947,
      "content_hash": "e0932b3929fe1f41d3098a12b0baa007f662fccd",
      "content": "async function ensurePrivateVenv() {\n  try {\n    const python = resolvePrivateVenvPython();\n    if (python) {\n      log('Private venv already exists.');\n      return true;\n    }\n    const venvPath = privateVenvPath();\n    const basePy = await detectSystemPython();\n    if (!basePy) {\n      vscode.window.showErrorMessage('Context Engine Uploader: no Python interpreter found to bootstrap venv.');\n      return false;\n    }\n    log(`Creating private venv at ${venvPath} using ${basePy}`);\n    const res = spawnSync(basePy, ['-m', 'venv', venvPath], { encoding: 'utf8' });\n    if (res.status !== 0) {\n      log(`venv creation failed: ${res.stderr || res.stdout}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to create private venv.');\n      return false;\n    }\n    return true;\n  } catch (e) {\n    log(`ensurePrivateVenv error: ${e && e.message ? e.message : String(e)}`);\n    return false;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_installDepsInto_949": {
      "name": "installDepsInto",
      "type": "function",
      "start_line": 949,
      "end_line": 964,
      "content_hash": "5daf210c21e4d9bd126b28f75229953476fc8190",
      "content": "async function installDepsInto(pythonBin) {\n  try {\n    log(`Installing Python deps into private venv via ${pythonBin}`);\n    const args = ['-m', 'pip', 'install', ...REQUIRED_PYTHON_MODULES];\n    const res = spawnSync(pythonBin, args, { encoding: 'utf8' });\n    if (res.status !== 0) {\n      log(`pip install failed: ${res.stderr || res.stdout}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: pip install failed. See Output for details.');\n      return false;\n    }\n    return true;\n  } catch (e) {\n    log(`installDepsInto error: ${e && e.message ? e.message : String(e)}`);\n    return false;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectSystemPython_966": {
      "name": "detectSystemPython",
      "type": "function",
      "start_line": 966,
      "end_line": 989,
      "content_hash": "07fb2c779a7e52cd5cb867f26607ccd66b84b571",
      "content": "async function detectSystemPython() {\n  // Try configured pythonPath, then common names\n  const candidates = [];\n  try {\n    const cfg = getEffectiveConfig();\n    const configured = (cfg.get('pythonPath') || '').trim();\n    if (configured) candidates.push(configured);\n  } catch {}\n  if (process.platform === 'win32') {\n    candidates.push('py', 'python3', 'python');\n  } else {\n    candidates.push('python3', 'python');\n    // Add common Homebrew path on Apple Silicon\n    candidates.push('/opt/homebrew/bin/python3');\n  }\n  for (const cmd of candidates) {\n    const probe = spawnSync(cmd, ['-c', 'import sys; print(sys.executable)'], { encoding: 'utf8' });\n    if (!probe.error && probe.status === 0) {\n      const p = (probe.stdout || '').trim();\n      if (p) return p;\n    }\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_requiresHttpBridge_991": {
      "name": "requiresHttpBridge",
      "type": "function",
      "start_line": 991,
      "end_line": 1000,
      "content_hash": "6ea4bae09a83e30c0bac8b736466306eeb99bbd6",
      "content": "function requiresHttpBridge(serverMode, transportMode) {\n  try {\n    if (bridgeManager && typeof bridgeManager.requiresHttpBridge === 'function') {\n      return bridgeManager.requiresHttpBridge(serverMode, transportMode);\n    }\n  } catch (_) {\n    // ignore\n  }\n  return serverMode === 'bridge' && transportMode === 'http';\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensureHttpBridgeReadyForConfigs_1002": {
      "name": "ensureHttpBridgeReadyForConfigs",
      "type": "function",
      "start_line": 1002,
      "end_line": 1011,
      "content_hash": "2e42f9453c8b87ac81b7fe83ccded005b2411ae4",
      "content": "async function ensureHttpBridgeReadyForConfigs() {\n  try {\n    if (bridgeManager && typeof bridgeManager.ensureReadyForConfigs === 'function') {\n      return await bridgeManager.ensureReadyForConfigs();\n    }\n  } catch (error) {\n    log(`Failed to ensure HTTP bridge is ready: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  return false;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveBridgeHttpUrl_1013": {
      "name": "resolveBridgeHttpUrl",
      "type": "function",
      "start_line": 1013,
      "end_line": 1022,
      "content_hash": "43c98bdef84e18513f85c57a0a7e152f0d4a75e2",
      "content": "function resolveBridgeHttpUrl() {\n  try {\n    if (bridgeManager && typeof bridgeManager.resolveBridgeHttpUrl === 'function') {\n      return bridgeManager.resolveBridgeHttpUrl();\n    }\n  } catch (_) {\n    // ignore\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_startHttpBridgeProcess_1024": {
      "name": "startHttpBridgeProcess",
      "type": "function",
      "start_line": 1024,
      "end_line": 1029,
      "content_hash": "c9b99216238df2029907f5517ae6b6ecc6a4cebc",
      "content": "async function startHttpBridgeProcess() {\n  if (bridgeManager && typeof bridgeManager.start === 'function') {\n    return bridgeManager.start();\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stopHttpBridgeProcess_1031": {
      "name": "stopHttpBridgeProcess",
      "type": "function",
      "start_line": 1031,
      "end_line": 1036,
      "content_hash": "661f9def698caad76d06e7f997868e0aa264e396",
      "content": "function stopHttpBridgeProcess() {\n  if (bridgeManager && typeof bridgeManager.stop === 'function') {\n    return bridgeManager.stop();\n  }\n  return Promise.resolve();\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleHttpBridgeSettingsChanged_1038": {
      "name": "handleHttpBridgeSettingsChanged",
      "type": "function",
      "start_line": 1038,
      "end_line": 1042,
      "content_hash": "94685c470e67d0721b104e3ef7f3c6fe2b863c86",
      "content": "async function handleHttpBridgeSettingsChanged() {\n  if (bridgeManager && typeof bridgeManager.handleSettingsChanged === 'function') {\n    return bridgeManager.handleSettingsChanged();\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setStatusBarState_1043": {
      "name": "setStatusBarState",
      "type": "function",
      "start_line": 1043,
      "end_line": 1061,
      "content_hash": "1c3108edd10f8a4414eb545822027125e7061253",
      "content": "function setStatusBarState(mode) {\n  if (!statusBarItem) {\n    return;\n  }\n  statusMode = mode;\n  if (mode === 'indexing') {\n    statusBarItem.text = '$(sync~spin) Indexing...';\n    statusBarItem.color = undefined;\n  } else if (mode === 'indexed') {\n    statusBarItem.text = '$(check) Indexed';\n    statusBarItem.color = new vscode.ThemeColor('charts.green');\n  } else if (mode === 'watch') {\n    statusBarItem.text = '$(sync) Watching (Click Force Index)';\n    statusBarItem.color = new vscode.ThemeColor('charts.purple');\n  } else {\n    statusBarItem.text = '$(sync) Index Codebase';\n    statusBarItem.color = undefined;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runOnce_1062": {
      "name": "runOnce",
      "type": "function",
      "start_line": 1062,
      "end_line": 1088,
      "content_hash": "b2f8d750fea8a1484d1c94eef909ca09160aba2b",
      "content": "function runOnce(options) {\n  return new Promise(resolve => {\n    const args = buildArgs(options, 'force');\n    const baseEnv = buildChildEnv(options);\n    const childEnv = { ...baseEnv, REMOTE_UPLOAD_GIT_FORCE: '1' };\n    const child = spawn(options.pythonPath, args, { cwd: options.workingDirectory, env: childEnv });\n    forceProcess = child;\n    attachOutput(child, 'force');\n    let finished = false;\n    const finish = code => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      log(`Force sync exited with code ${code}`);\n      if (forceProcess === child) {\n        forceProcess = undefined;\n      }\n      resolve(typeof code === 'number' ? code : 1);\n    };\n    child.on('close', finish);\n    child.on('error', error => {\n      log(`Force sync failed: ${error.message}`);\n      finish(1);\n    });\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_finish_1071": {
      "name": "finish",
      "type": "function",
      "start_line": 1071,
      "end_line": 1081,
      "content_hash": "d0d7bfe480cfe3351146ecb93b08600d499de1a2",
      "content": "    const finish = code => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      log(`Force sync exited with code ${code}`);\n      if (forceProcess === child) {\n        forceProcess = undefined;\n      }\n      resolve(typeof code === 'number' ? code : 1);\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_startWatch_1089": {
      "name": "startWatch",
      "type": "function",
      "start_line": 1089,
      "end_line": 1116,
      "content_hash": "5866bc02e66083f975af4b37b8bac99322fc62e9",
      "content": "function startWatch(options) {\n  disposeIndexedWatcher();\n  const args = buildArgs(options, 'watch');\n  const child = spawn(options.pythonPath, args, { cwd: options.workingDirectory, env: buildChildEnv(options) });\n  watchProcess = child;\n  attachOutput(child, 'watch');\n  if (outputChannel) { outputChannel.show(true); }\n  setStatusBarState('watch');\n  child.on('close', code => {\n    log(`Watch exited with code ${code}`);\n    if (watchProcess === child) {\n      watchProcess = undefined;\n      if (statusMode !== 'indexing') {\n        setStatusBarState('idle');\n      }\n    }\n  });\n  child.on('error', error => {\n    log(`Watch failed: ${error.message}`);\n    if (watchProcess === child) {\n      watchProcess = undefined;\n      if (statusMode !== 'indexing') {\n        setStatusBarState('idle');\n      }\n    }\n  });\n  vscode.window.showInformationMessage('Context Engine remote watch started.');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_buildArgs_1117": {
      "name": "buildArgs",
      "type": "function",
      "start_line": 1117,
      "end_line": 1131,
      "content_hash": "7407be29ab239e1eb63d4d867fd598e75788dd5a",
      "content": "function buildArgs(options, mode) {\n  const args = ['-u', options.scriptPath, '--path', options.targetPath, '--endpoint', options.endpoint];\n  if (mode === 'force') {\n    args.push('--force');\n    if (options.extraForceArgs && options.extraForceArgs.length) {\n      args.push(...options.extraForceArgs);\n    }\n  } else {\n    args.push('--watch', '--interval', String(options.interval));\n    if (options.extraWatchArgs && options.extraWatchArgs.length) {\n      args.push(...options.extraWatchArgs);\n    }\n  }\n  return args;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_attachOutput_1132": {
      "name": "attachOutput",
      "type": "function",
      "start_line": 1132,
      "end_line": 1147,
      "content_hash": "023b07fbbd601ae11d4e23ac5e7b5047cd0d8631",
      "content": "function attachOutput(child, label) {\n  if (!outputChannel) {\n    return;\n  }\n  if (child.stdout) {\n    child.stdout.on('data', data => {\n      outputChannel.append(`[${label}] ${data}`);\n    });\n  }\n  if (child.stderr) {\n    child.stderr.on('data', data => {\n      const chunk = data.toString();\n      outputChannel.append(`[${label} err] ${chunk}`);\n    });\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensureIndexedWatcher_1148": {
      "name": "ensureIndexedWatcher",
      "type": "function",
      "start_line": 1148,
      "end_line": 1178,
      "content_hash": "dbe9922cdcd9f39bc432282301b1c7850927bd99",
      "content": "function ensureIndexedWatcher(targetPath) {\n  try {\n    disposeIndexedWatcher();\n    watchedTargetPath = targetPath;\n    let pattern;\n    if (targetPath && fs.existsSync(targetPath)) {\n      pattern = new vscode.RelativePattern(targetPath, '**/*');\n    } else {\n      const folder = getWorkspaceFolderPath();\n      if (folder && fs.existsSync(folder)) {\n        pattern = new vscode.RelativePattern(folder, '**/*');\n      } else {\n        pattern = '**/*';\n      }\n    }\n    workspaceWatcher = vscode.workspace.createFileSystemWatcher(pattern, false, false, false);\n    const flipToIdle = () => {\n      if (statusMode === 'indexed') {\n        setStatusBarState('idle');\n      }\n    };\n    indexedWatchDisposables.push(workspaceWatcher);\n    indexedWatchDisposables.push(workspaceWatcher.onDidCreate(flipToIdle));\n    indexedWatchDisposables.push(workspaceWatcher.onDidChange(flipToIdle));\n    indexedWatchDisposables.push(workspaceWatcher.onDidDelete(flipToIdle));\n    indexedWatchDisposables.push(vscode.workspace.onDidChangeTextDocument(() => flipToIdle()));\n    log('Indexed watcher armed; any file change will return status bar to \"Index Codebase\".');\n  } catch (e) {\n    log(`Failed to arm indexed watcher: ${e && e.message ? e.message : String(e)}`);\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_flipToIdle_1164": {
      "name": "flipToIdle",
      "type": "function",
      "start_line": 1164,
      "end_line": 1168,
      "content_hash": "0a9a02dd1fdb8d3b217eba2a51a538b0fb5d708a",
      "content": "    const flipToIdle = () => {\n      if (statusMode === 'indexed') {\n        setStatusBarState('idle');\n      }\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_disposeIndexedWatcher_1180": {
      "name": "disposeIndexedWatcher",
      "type": "function",
      "start_line": 1180,
      "end_line": 1194,
      "content_hash": "64b44d73a14a03ba05623aa05935e51cbcd13683",
      "content": "function disposeIndexedWatcher() {\n  try {\n    for (const d of indexedWatchDisposables) {\n      try { if (d && typeof d.dispose === 'function') d.dispose(); } catch (_) {}\n    }\n    indexedWatchDisposables = [];\n    if (workspaceWatcher && typeof workspaceWatcher.dispose === 'function') {\n      workspaceWatcher.dispose();\n    }\n    workspaceWatcher = undefined;\n    watchedTargetPath = undefined;\n  } catch (e) {\n    // ignore\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stopProcesses_1196": {
      "name": "stopProcesses",
      "type": "function",
      "start_line": 1196,
      "end_line": 1201,
      "content_hash": "f6df5ea9071ac4ef992928b086599a41b6b5d59d",
      "content": "async function stopProcesses() {\n  await Promise.all([terminateProcess(forceProcess, 'force'), terminateProcess(watchProcess, 'watch')]);\n  if (!forceProcess && !watchProcess && statusMode !== 'indexing') {\n    setStatusBarState('idle');\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_terminateProcess_1202": {
      "name": "terminateProcess",
      "type": "function",
      "start_line": 1202,
      "end_line": 1263,
      "content_hash": "24659f749af1f0ee4f8f10528fe142a9e3887c9a",
      "content": "function terminateProcess(proc, label, afterStop) {\n  if (!proc) {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    let finished = false;\n    let termTimer;\n    let killTimer;\n    const clearTimers = () => {\n      if (termTimer) clearTimeout(termTimer);\n      if (killTimer) clearTimeout(killTimer);\n    };\n    const finalize = (reason) => {\n      if (finished) return;\n      finished = true;\n      clearTimers();\n      if (typeof afterStop === 'function') {\n        afterStop();\n      }\n      if (proc === forceProcess) {\n        forceProcess = undefined;\n      }\n      if (proc === watchProcess) {\n        watchProcess = undefined;\n      }\n      log(`${label} process stopped${reason ? ` (${reason})` : ''}.`);\n      resolve();\n    };\n\n    // Resolve only after the child actually exits (or after forced kill path)\n    const onExit = (code, signal) => {\n      finalize(`exit code=${code} signal=${signal || ''}`.trim());\n    };\n    proc.once('exit', onExit);\n    proc.once('close', onExit);\n\n    try {\n      proc.kill(); // default SIGTERM\n    } catch (error) {\n      finalize('kill() threw');\n      return;\n    }\n\n    const waitSigtermMs = 4000;\n    const waitSigkillMs = 2000;\n\n    // If process doesn't exit after SIGTERM, escalate to SIGKILL and then force-resolve\n    termTimer = setTimeout(() => {\n      try {\n        if (proc && !proc.killed) {\n          proc.kill('SIGKILL');\n          log(`${label} process did not exit after ${waitSigtermMs}ms; sent SIGKILL.`);\n        }\n      } catch (_) {\n        // ignore\n      }\n      killTimer = setTimeout(() => {\n        finalize(`forced after ${waitSigtermMs + waitSigkillMs}ms`);\n      }, waitSigkillMs);\n    }, waitSigtermMs);\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_clearTimers_1210": {
      "name": "clearTimers",
      "type": "function",
      "start_line": 1210,
      "end_line": 1213,
      "content_hash": "4ae0dcb61d39034cfb3b834d2e61a49feccf7017",
      "content": "    const clearTimers = () => {\n      if (termTimer) clearTimeout(termTimer);\n      if (killTimer) clearTimeout(killTimer);\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_finalize_1214": {
      "name": "finalize",
      "type": "function",
      "start_line": 1214,
      "end_line": 1229,
      "content_hash": "88e304c9658e31b1c824fbd5b43269127910c7bb",
      "content": "    const finalize = (reason) => {\n      if (finished) return;\n      finished = true;\n      clearTimers();\n      if (typeof afterStop === 'function') {\n        afterStop();\n      }\n      if (proc === forceProcess) {\n        forceProcess = undefined;\n      }\n      if (proc === watchProcess) {\n        watchProcess = undefined;\n      }\n      log(`${label} process stopped${reason ? ` (${reason})` : ''}.`);\n      resolve();\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_onExit_1232": {
      "name": "onExit",
      "type": "function",
      "start_line": 1232,
      "end_line": 1234,
      "content_hash": "5c45b0a5c7a5b73a6183fb8d84ef27eb585faa63",
      "content": "    const onExit = (code, signal) => {\n      finalize(`exit code=${code} signal=${signal || ''}`.trim());\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_log_1264": {
      "name": "log",
      "type": "function",
      "start_line": 1264,
      "end_line": 1270,
      "content_hash": "5dcef832897c0b1c6dd4cf596baac84487af855d",
      "content": "function log(message) {\n  if (!outputChannel) {\n    return;\n  }\n  const timestamp = new Date().toISOString();\n  outputChannel.appendLine(`[${timestamp}] ${message}`);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_buildChildEnv_1271": {
      "name": "buildChildEnv",
      "type": "function",
      "start_line": 1271,
      "end_line": 1317,
      "content_hash": "c842d7f1cc5439a666f1fa5b6ded0c5f40a62cb5",
      "content": "function buildChildEnv(options) {\n  const env = {\n    ...process.env,\n    WORKSPACE_PATH: options.targetPath,\n    WATCH_ROOT: options.targetPath\n  };\n  try {\n    const settings = getEffectiveConfig();\n    const devRemoteMode = settings.get('devRemoteMode', false);\n    if (devRemoteMode) {\n      // Enable dev-remote upload mode for the standalone upload client.\n      // This causes standalone_upload_client.py to ignore any 'dev-workspace'\n      // directories when scanning for files to upload.\n      env.REMOTE_UPLOAD_MODE = 'development';\n      env.DEV_REMOTE_MODE = '1';\n      log('Context Engine Uploader: devRemoteMode enabled (REMOTE_UPLOAD_MODE=development, DEV_REMOTE_MODE=1).');\n    }\n    const gitMaxCommits = settings.get('gitMaxCommits');\n    if (typeof gitMaxCommits === 'number' && !Number.isNaN(gitMaxCommits)) {\n      env.REMOTE_UPLOAD_GIT_MAX_COMMITS = String(gitMaxCommits);\n    }\n    const gitSinceRaw = settings.get('gitSince');\n    const gitSince = typeof gitSinceRaw === 'string' ? gitSinceRaw.trim() : '';\n    if (gitSince) {\n      env.REMOTE_UPLOAD_GIT_SINCE = gitSince;\n    }\n  } catch (error) {\n    log(`Failed to read devRemoteMode setting: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  if (options.hostRoot) {\n    env.HOST_ROOT = options.hostRoot;\n  }\n  if (options.containerRoot) {\n    env.CONTAINER_ROOT = options.containerRoot;\n  }\n  try {\n    const libsPath = path.join(options.workingDirectory, 'python_libs');\n    if (fs.existsSync(libsPath)) {\n      const existing = process.env.PYTHONPATH || '';\n      env.PYTHONPATH = existing ? `${libsPath}${path.delimiter}${existing}` : libsPath;\n      log(`Detected bundled python_libs at ${libsPath}; setting PYTHONPATH for child process.`);\n    }\n  } catch (error) {\n    log(`Failed to configure PYTHONPATH for bundled deps: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  return env;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeBridgeUrl_1318": {
      "name": "normalizeBridgeUrl",
      "type": "function",
      "start_line": 1318,
      "end_line": 1327,
      "content_hash": "00efeb17203b89378df4645b3245e661adf83bfb",
      "content": "function normalizeBridgeUrl(url) {\n  if (!url || typeof url !== 'string') {\n    return '';\n  }\n  const trimmed = url.trim();\n  if (!trimmed) {\n    return '';\n  }\n  return trimmed;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeWorkspaceForBridge_1329": {
      "name": "normalizeWorkspaceForBridge",
      "type": "function",
      "start_line": 1329,
      "end_line": 1342,
      "content_hash": "a8c426259a7d02faf7032bcc1f6b0242b7feb790",
      "content": "function normalizeWorkspaceForBridge(workspacePath) {\n  if (!workspacePath || typeof workspacePath !== 'string') {\n    return '';\n  }\n  try {\n    const resolved = path.resolve(workspacePath);\n    if (process.platform === 'win32') {\n      return resolved.replace(/\\//g, '\\\\');\n    }\n    return resolved;\n  } catch (_) {\n    return workspacePath;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeMcpConfig_1344": {
      "name": "writeMcpConfig",
      "type": "function",
      "start_line": 1344,
      "end_line": 1349,
      "content_hash": "953a25391a84e1441069b17649d28c5c144ac161",
      "content": "async function writeMcpConfig() {\n  const options = arguments.length ? arguments[0] : undefined;\n  if (mcpConfigManager && typeof mcpConfigManager.writeMcpConfig === 'function') {\n    return mcpConfigManager.writeMcpConfig(options);\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeCtxConfig_1351": {
      "name": "writeCtxConfig",
      "type": "function",
      "start_line": 1351,
      "end_line": 1355,
      "content_hash": "d7f365ddddd0321c4f83dab3a90d410233480014",
      "content": "async function writeCtxConfig() {\n  if (ctxConfigManager && typeof ctxConfigManager.writeCtxConfig === 'function') {\n    return ctxConfigManager.writeCtxConfig();\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_deactivate_1356": {
      "name": "deactivate",
      "type": "function",
      "start_line": 1356,
      "end_line": 1359,
      "content_hash": "a5e18132eee0fcf16700c5114cee274865054a69",
      "content": "function deactivate() {\n  disposeIndexedWatcher();\n  return Promise.all([stopProcesses()]);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveBridgeCliInvocation_1365": {
      "name": "resolveBridgeCliInvocation",
      "type": "function",
      "start_line": 1365,
      "end_line": 1387,
      "content_hash": "007d981b4c3b187fc26bb985c6fe20873eb5c306",
      "content": "function resolveBridgeCliInvocation() {\n  const binPath = findLocalBridgeBin();\n  if (binPath) {\n    return {\n      command: 'node',\n      args: [binPath],\n      kind: 'local'\n    };\n  }\n  const isWindows = process.platform === 'win32';\n  if (isWindows) {\n    return {\n      command: 'cmd',\n      args: ['/c', 'npx', '@context-engine-bridge/context-engine-mcp-bridge'],\n      kind: 'npx'\n    };\n  }\n  return {\n    command: 'npx',\n    args: ['@context-engine-bridge/context-engine-mcp-bridge'],\n    kind: 'npx'\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findLocalBridgeBin_1389": {
      "name": "findLocalBridgeBin",
      "type": "function",
      "start_line": 1389,
      "end_line": 1415,
      "content_hash": "2769262b7bfdf155e47e24e8b72b97d16aec3245",
      "content": "function findLocalBridgeBin() {\n  let localOnly = true;\n  let configured = '';\n  try {\n    const settings = getEffectiveConfig();\n    localOnly = settings.get('mcpBridgeLocalOnly', true);\n    configured = (settings.get('mcpBridgeBinPath') || '').trim();\n  } catch (_) {\n    // ignore config lookup failures and fall back to env/npx behavior\n  }\n\n  // When local-only is disabled, skip local resolution and always fall back to npx\n  if (localOnly === false) {\n    return undefined;\n  }\n\n  if (configured && fs.existsSync(configured)) {\n    return path.resolve(configured);\n  }\n\n  const envOverride = (process.env.CTXCE_BRIDGE_BIN || '').trim();\n  if (envOverride && fs.existsSync(envOverride)) {\n    return path.resolve(envOverride);\n  }\n\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}