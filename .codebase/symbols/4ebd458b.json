{
  "file_path": "/work/.local/tools/modelscan/sdk/storage/task.go",
  "file_hash": "b49d7c3476c4b648f42f3601aaad4f75bbb5d83b",
  "updated_at": "2025-12-26T17:34:20.078393",
  "symbols": {
    "struct_Task_12": {
      "name": "Task",
      "type": "struct",
      "start_line": 12,
      "end_line": 28,
      "content_hash": "55323e21b79c879610f4ca90e48cc04100540d87",
      "content": "type Task struct {\n\tID          string                 `json:\"id\"`\n\tAgentID     string                 `json:\"agent_id\"`\n\tTeamID      *string                `json:\"team_id,omitempty\"`\n\tType        string                 `json:\"type\"`\n\tStatus      string                 `json:\"status\"`\n\tPriority    int                    `json:\"priority\"`\n\tInput       string                 `json:\"input\"`\n\tOutput      string                 `json:\"output\"`\n\tMetadata    map[string]interface{} `json:\"metadata\"`\n\tCreatedAt   time.Time              `json:\"created_at\"`\n\tStartedAt   *time.Time             `json:\"started_at,omitempty\"`\n\tCompletedAt *time.Time             `json:\"completed_at,omitempty\"`\n\tUpdatedAt   time.Time              `json:\"updated_at\"`\n}\n\n// TaskRepository handles task database operations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TaskRepository_29": {
      "name": "TaskRepository",
      "type": "struct",
      "start_line": 29,
      "end_line": 33,
      "content_hash": "98de63f310b4f14171aea893e62638aefb1b17f2",
      "content": "type TaskRepository struct {\n\tdb *sql.DB\n}\n\n// NewTaskRepository creates a new task repository",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewTaskRepository_34": {
      "name": "NewTaskRepository",
      "type": "function",
      "start_line": 34,
      "end_line": 38,
      "content_hash": "1a8f342948ac151b3cfe0187ef72ceb20efbccb8",
      "content": "func NewTaskRepository(db *sql.DB) *TaskRepository {\n\treturn &TaskRepository{db: db}\n}\n\n// Create creates a new task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Create_39": {
      "name": "Create",
      "type": "method",
      "start_line": 39,
      "end_line": 57,
      "content_hash": "429c3a092e1e5c2377f9649fa4c3ac5a47c9dda9",
      "content": "func (r *TaskRepository) Create(ctx context.Context, task *Task) error {\n\tmetadataJSON, _ := json.Marshal(task.Metadata)\n\n\tquery := `\n\t\tINSERT INTO tasks (id, agent_id, team_id, type, status, priority, input, output, metadata)\n\t\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`\n\n\t_, err := r.db.ExecContext(ctx, query,\n\t\ttask.ID, task.AgentID, task.TeamID, task.Type, task.Status,\n\t\ttask.Priority, task.Input, task.Output, metadataJSON)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create task: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// Get retrieves a task by ID",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Get_58": {
      "name": "Get",
      "type": "method",
      "start_line": 58,
      "end_line": 88,
      "content_hash": "dd285232ed3d3a8f96497afdaacc8df7d054cedf",
      "content": "func (r *TaskRepository) Get(ctx context.Context, id string) (*Task, error) {\n\tquery := `\n\t\tSELECT id, agent_id, team_id, type, status, priority, input, output, metadata,\n\t\t       created_at, started_at, completed_at, updated_at\n\t\tFROM tasks WHERE id = ?\n\t`\n\n\ttask := &Task{}\n\tvar metadataJSON []byte\n\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\n\t\t&task.ID, &task.AgentID, &task.TeamID, &task.Type, &task.Status,\n\t\t&task.Priority, &task.Input, &task.Output, &metadataJSON,\n\t\t&task.CreatedAt, &task.StartedAt, &task.CompletedAt, &task.UpdatedAt)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, fmt.Errorf(\"task not found: %s\", id)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get task: %w\", err)\n\t}\n\n\tif len(metadataJSON) > 0 {\n\t\tif err := json.Unmarshal(metadataJSON, &task.Metadata); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal metadata: %w\", err)\n\t\t}\n\t}\n\n\treturn task, nil\n}\n\n// Update updates a task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_89": {
      "name": "Update",
      "type": "method",
      "start_line": 89,
      "end_line": 118,
      "content_hash": "d1e259024794962aa2a9925aa5d7b7b61d4a1d42",
      "content": "func (r *TaskRepository) Update(ctx context.Context, task *Task) error {\n\tmetadataJSON, _ := json.Marshal(task.Metadata)\n\n\tquery := `\n\t\tUPDATE tasks \n\t\tSET agent_id = ?, team_id = ?, type = ?, status = ?, priority = ?,\n\t\t    input = ?, output = ?, metadata = ?, started_at = ?, completed_at = ?, updated_at = CURRENT_TIMESTAMP\n\t\tWHERE id = ?\n\t`\n\n\tresult, err := r.db.ExecContext(ctx, query,\n\t\ttask.AgentID, task.TeamID, task.Type, task.Status, task.Priority,\n\t\ttask.Input, task.Output, metadataJSON, task.StartedAt, task.CompletedAt, task.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update task: %w\", err)\n\t}\n\n\trowsAffected, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\n\tif rowsAffected == 0 {\n\t\treturn fmt.Errorf(\"task not found: %s\", task.ID)\n\t}\n\n\treturn nil\n}\n\n// Delete deletes a task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Delete_119": {
      "name": "Delete",
      "type": "method",
      "start_line": 119,
      "end_line": 139,
      "content_hash": "509c28db6c475d21a24481cafdd5124d044b6c8a",
      "content": "func (r *TaskRepository) Delete(ctx context.Context, id string) error {\n\tquery := `DELETE FROM tasks WHERE id = ?`\n\n\tresult, err := r.db.ExecContext(ctx, query, id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete task: %w\", err)\n\t}\n\n\trowsAffected, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\n\tif rowsAffected == 0 {\n\t\treturn fmt.Errorf(\"task not found: %s\", id)\n\t}\n\n\treturn nil\n}\n\n// ListByAgent retrieves tasks for a specific agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListByAgent_140": {
      "name": "ListByAgent",
      "type": "method",
      "start_line": 140,
      "end_line": 181,
      "content_hash": "bc6c8682b82af30212ef96ca5468c5ea65c36e9d",
      "content": "func (r *TaskRepository) ListByAgent(ctx context.Context, agentID string, limit, offset int) ([]*Task, error) {\n\tquery := `\n\t\tSELECT id, agent_id, team_id, type, status, priority, input, output, metadata,\n\t\t       created_at, started_at, completed_at, updated_at\n\t\tFROM tasks \n\t\tWHERE agent_id = ?\n\t\tORDER BY created_at DESC\n\t\tLIMIT ? OFFSET ?\n\t`\n\n\trows, err := r.db.QueryContext(ctx, query, agentID, limit, offset)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list tasks by agent: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar tasks []*Task\n\tfor rows.Next() {\n\t\ttask := &Task{}\n\t\tvar metadataJSON []byte\n\n\t\terr := rows.Scan(\n\t\t\t&task.ID, &task.AgentID, &task.TeamID, &task.Type, &task.Status,\n\t\t\t&task.Priority, &task.Input, &task.Output, &metadataJSON,\n\t\t\t&task.CreatedAt, &task.StartedAt, &task.CompletedAt, &task.UpdatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan task: %w\", err)\n\t\t}\n\n\t\tif len(metadataJSON) > 0 {\n\t\t\tif err := json.Unmarshal(metadataJSON, &task.Metadata); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal metadata: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\ttasks = append(tasks, task)\n\t}\n\n\treturn tasks, nil\n}\n\n// ListByTeam retrieves tasks for a specific team",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListByTeam_182": {
      "name": "ListByTeam",
      "type": "method",
      "start_line": 182,
      "end_line": 223,
      "content_hash": "62143dfdf63a65691b9db431bc0142901b303289",
      "content": "func (r *TaskRepository) ListByTeam(ctx context.Context, teamID string, limit, offset int) ([]*Task, error) {\n\tquery := `\n\t\tSELECT id, agent_id, team_id, type, status, priority, input, output, metadata,\n\t\t       created_at, started_at, completed_at, updated_at\n\t\tFROM tasks \n\t\tWHERE team_id = ?\n\t\tORDER BY created_at DESC\n\t\tLIMIT ? OFFSET ?\n\t`\n\n\trows, err := r.db.QueryContext(ctx, query, teamID, limit, offset)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list tasks by team: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar tasks []*Task\n\tfor rows.Next() {\n\t\ttask := &Task{}\n\t\tvar metadataJSON []byte\n\n\t\terr := rows.Scan(\n\t\t\t&task.ID, &task.AgentID, &task.TeamID, &task.Type, &task.Status,\n\t\t\t&task.Priority, &task.Input, &task.Output, &metadataJSON,\n\t\t\t&task.CreatedAt, &task.StartedAt, &task.CompletedAt, &task.UpdatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan task: %w\", err)\n\t\t}\n\n\t\tif len(metadataJSON) > 0 {\n\t\t\tif err := json.Unmarshal(metadataJSON, &task.Metadata); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal metadata: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\ttasks = append(tasks, task)\n\t}\n\n\treturn tasks, nil\n}\n\n// ListByStatus retrieves tasks by status",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListByStatus_224": {
      "name": "ListByStatus",
      "type": "method",
      "start_line": 224,
      "end_line": 265,
      "content_hash": "9eb769331457f633d7e20e77fe6fa366f8a83c85",
      "content": "func (r *TaskRepository) ListByStatus(ctx context.Context, status string, limit, offset int) ([]*Task, error) {\n\tquery := `\n\t\tSELECT id, agent_id, team_id, type, status, priority, input, output, metadata,\n\t\t       created_at, started_at, completed_at, updated_at\n\t\tFROM tasks \n\t\tWHERE status = ?\n\t\tORDER BY priority DESC, created_at ASC\n\t\tLIMIT ? OFFSET ?\n\t`\n\n\trows, err := r.db.QueryContext(ctx, query, status, limit, offset)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list tasks by status: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar tasks []*Task\n\tfor rows.Next() {\n\t\ttask := &Task{}\n\t\tvar metadataJSON []byte\n\n\t\terr := rows.Scan(\n\t\t\t&task.ID, &task.AgentID, &task.TeamID, &task.Type, &task.Status,\n\t\t\t&task.Priority, &task.Input, &task.Output, &metadataJSON,\n\t\t\t&task.CreatedAt, &task.StartedAt, &task.CompletedAt, &task.UpdatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan task: %w\", err)\n\t\t}\n\n\t\tif len(metadataJSON) > 0 {\n\t\t\tif err := json.Unmarshal(metadataJSON, &task.Metadata); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal metadata: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\ttasks = append(tasks, task)\n\t}\n\n\treturn tasks, nil\n}\n\n// UpdateStatus updates task status",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_UpdateStatus_266": {
      "name": "UpdateStatus",
      "type": "method",
      "start_line": 266,
      "end_line": 288,
      "content_hash": "fca5eefee000a7834b4c7c7ff917bea17d7b3c58",
      "content": "func (r *TaskRepository) UpdateStatus(ctx context.Context, id, status string) error {\n\tquery := `\n\t\tUPDATE tasks \n\t\tSET status = ?, updated_at = CURRENT_TIMESTAMP\n\t\tWHERE id = ?\n\t`\n\n\tresult, err := r.db.ExecContext(ctx, query, status, id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update task status: %w\", err)\n\t}\n\n\trowsAffected, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\n\tif rowsAffected == 0 {\n\t\treturn fmt.Errorf(\"task not found: %s\", id)\n\t}\n\n\treturn nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}