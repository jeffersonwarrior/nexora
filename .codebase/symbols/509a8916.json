{
  "file_path": "/work/external-deps/claude-mem/scripts/bug-report/index.ts",
  "file_hash": "644eb73b65cb6d98152f03da7f978cb42847e7b1",
  "updated_at": "2025-12-26T17:34:24.245946",
  "symbols": {
    "function_generateBugReport_26": {
      "name": "generateBugReport",
      "type": "function",
      "start_line": 26,
      "end_line": 116,
      "content_hash": "871f38274e21faa73a1b74c1da6af1a60348367f",
      "content": "export async function generateBugReport(\n  input: BugReportInput\n): Promise<BugReportResult> {\n  try {\n    // Collect system diagnostics\n    const diagnostics = await collectDiagnostics({\n      includeLogs: input.includeLogs !== false,\n    });\n\n    const formattedDiagnostics = formatDiagnostics(diagnostics);\n\n    // Build the prompt\n    const prompt = buildPrompt(\n      formattedDiagnostics,\n      input.issueDescription,\n      input.expectedBehavior,\n      input.stepsToReproduce\n    );\n\n    // Use Agent SDK to generate formatted issue\n    let generatedMarkdown = \"\";\n    let charCount = 0;\n    const startTime = Date.now();\n\n    const stream = query({\n      prompt,\n      options: {\n        model: \"sonnet\",\n        systemPrompt: `You are a GitHub issue formatter. Format bug reports clearly and professionally.`,\n        permissionMode: \"bypassPermissions\",\n        allowDangerouslySkipPermissions: true,\n        includePartialMessages: true,\n      },\n    });\n\n    // Progress spinner frames\n    const spinnerFrames = [\"\u280b\", \"\u2819\", \"\u2839\", \"\u2838\", \"\u283c\", \"\u2834\", \"\u2826\", \"\u2827\", \"\u2807\", \"\u280f\"];\n    let spinnerIdx = 0;\n\n    // Stream the response\n    for await (const message of stream) {\n      if (message.type === \"stream_event\") {\n        const event = message.event as { type: string; delta?: { type: string; text?: string } };\n        if (event.type === \"content_block_delta\" && event.delta?.type === \"text_delta\" && event.delta.text) {\n          generatedMarkdown += event.delta.text;\n          charCount += event.delta.text.length;\n\n          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n          const spinner = spinnerFrames[spinnerIdx++ % spinnerFrames.length];\n          process.stdout.write(`\\r   ${spinner} Generating... ${charCount} chars (${elapsed}s)`);\n        }\n      }\n\n      // Handle full assistant messages (fallback)\n      if (message.type === \"assistant\") {\n        for (const block of message.message.content) {\n          if (block.type === \"text\" && !generatedMarkdown) {\n            generatedMarkdown = block.text;\n            charCount = generatedMarkdown.length;\n          }\n        }\n      }\n\n      // Handle result\n      if (message.type === \"result\") {\n        const result = message as SDKResultMessage;\n        if (result.subtype === \"success\" && !generatedMarkdown && result.result) {\n          generatedMarkdown = result.result;\n          charCount = generatedMarkdown.length;\n        }\n      }\n    }\n\n    // Clear the progress line\n    process.stdout.write(\"\\r\" + \" \".repeat(60) + \"\\r\");\n\n    // Extract title from markdown (first heading)\n    const titleMatch = generatedMarkdown.match(/^#\\s+(.+)$/m);\n    const title = titleMatch ? titleMatch[1] : \"Bug Report\";\n\n    return {\n      title,\n      body: generatedMarkdown,\n      success: true,\n    };\n  } catch (error) {\n    // Fallback to template-based generation\n    console.error(\"Agent SDK failed, using template fallback:\", error);\n    return generateTemplateFallback(input);\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_buildPrompt_118": {
      "name": "buildPrompt",
      "type": "function",
      "start_line": 118,
      "end_line": 164,
      "content_hash": "47768be3206ef5487a864ef605f78c79bcf5a7d4",
      "content": "function buildPrompt(\n  diagnostics: string,\n  issueDescription: string,\n  expectedBehavior?: string,\n  stepsToReproduce?: string\n): string {\n  let prompt = `You are a GitHub issue formatter. Given system diagnostics and a user's bug description, create a well-structured GitHub issue for the claude-mem repository.\n\nSYSTEM DIAGNOSTICS:\n${diagnostics}\n\nUSER DESCRIPTION:\n${issueDescription}\n`;\n\n  if (expectedBehavior) {\n    prompt += `\\nEXPECTED BEHAVIOR:\n${expectedBehavior}\n`;\n  }\n\n  if (stepsToReproduce) {\n    prompt += `\\nSTEPS TO REPRODUCE:\n${stepsToReproduce}\n`;\n  }\n\n  prompt += `\n\nIMPORTANT: If any part of the user's description is in a language other than English, translate it to English while preserving technical accuracy and meaning.\n\nCreate a GitHub issue with:\n1. Clear, descriptive title (max 80 chars) in English - start with a single # heading\n2. Problem statement summarizing the issue in English\n3. Environment section (versions, platform) from the diagnostics\n4. Steps to reproduce (if provided) in English\n5. Expected vs actual behavior in English\n6. Relevant logs (formatted as code blocks) if present in diagnostics\n7. Any additional context that would help diagnose the issue\n\nFormat the output as valid GitHub Markdown. Make sure the title is a single # heading at the very top.\nDo NOT add meta-commentary like \"Here's a formatted issue\" - just output the raw markdown.\nAll content must be in English for the GitHub issue.\n`;\n\n  return prompt;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateTemplateFallback_166": {
      "name": "generateTemplateFallback",
      "type": "function",
      "start_line": 166,
      "end_line": 195,
      "content_hash": "357fcb4d86607363335803199cb64bb2bbde7a9f",
      "content": "async function generateTemplateFallback(\n  input: BugReportInput\n): Promise<BugReportResult> {\n  const diagnostics = await collectDiagnostics({\n    includeLogs: input.includeLogs !== false,\n  });\n  const formattedDiagnostics = formatDiagnostics(diagnostics);\n\n  let body = `# Bug Report\\n\\n`;\n  body += `## Description\\n\\n`;\n  body += `${input.issueDescription}\\n\\n`;\n\n  if (input.expectedBehavior) {\n    body += `## Expected Behavior\\n\\n`;\n    body += `${input.expectedBehavior}\\n\\n`;\n  }\n\n  if (input.stepsToReproduce) {\n    body += `## Steps to Reproduce\\n\\n`;\n    body += `${input.stepsToReproduce}\\n\\n`;\n  }\n\n  body += formattedDiagnostics;\n\n  return {\n    title: \"Bug Report\",\n    body,\n    success: true,\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}