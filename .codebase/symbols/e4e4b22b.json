{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/reranker/fusion/rrf.rs",
  "file_hash": "5932c089862f4c99ec1c1310826e97a5465354b2",
  "updated_at": "2025-12-26T17:34:20.358272",
  "symbols": {
    "struct_RRFReranker_26": {
      "name": "RRFReranker",
      "type": "struct",
      "start_line": 26,
      "end_line": 30,
      "content_hash": "609018aff3352c772deaeec18c19613b7640c541",
      "content": "pub struct RRFReranker {\n    /// The k parameter in the RRF formula (default: 60)\n    k: f64,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_RRFReranker_31": {
      "name": "RRFReranker",
      "type": "impl",
      "start_line": 31,
      "end_line": 32,
      "content_hash": "ffe0476482a109e3a8fcbf9b504e205af514a058",
      "content": "impl RRFReranker {\n    /// Create a new RRF reranker with default k=60.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_33": {
      "name": "new",
      "type": "method",
      "start_line": 33,
      "end_line": 40,
      "content_hash": "7bed238810bdd64cb90d51466def20e58902a558",
      "content": "    pub fn new() -> Self {\n        Self { k: 60.0 }\n    }\n\n    /// Create a new RRF reranker with custom k value.\n    ///\n    /// # Arguments\n    /// * `k` - The k parameter in the RRF formula. Higher values give less weight to ranking position.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_k_41": {
      "name": "with_k",
      "type": "method",
      "start_line": 41,
      "end_line": 107,
      "content_hash": "9a8a65a532a8addae0d141a406ff62578d1d4594",
      "content": "    pub fn with_k(k: f64) -> RerankerResult<Self> {\n        if k <= 0.0 {\n            return Err(RerankerError::InvalidParameter(\n                \"k must be positive\".to_string(),\n            ));\n        }\n        Ok(Self { k })\n    }\n\n    /// Fuse multiple ranked lists using RRF.\n    ///\n    /// # Arguments\n    /// * `lists` - Vector of iterators, each representing a ranked list\n    /// * `k` - The k parameter for RRF formula\n    ///\n    /// # Returns\n    /// A vector of items reranked by RRF scores\n    pub fn fuse_lists<'arena, I>(lists: Vec<I>, k: f64) -> RerankerResult<Vec<TraversalValue<'arena>>>\n    where\n        I: Iterator<Item = TraversalValue<'arena>>,\n    {\n        if lists.is_empty() {\n            return Err(RerankerError::EmptyInput);\n        }\n\n        let mut rrf_scores: HashMap<u128, f64> = HashMap::new();\n        let mut items_map: HashMap<u128, TraversalValue<'arena>> = HashMap::new();\n\n        // Process each ranked list\n        for list in lists {\n            for (rank, item) in list.enumerate() {\n                let id = match &item {\n                    TraversalValue::Node(n) => n.id,\n                    TraversalValue::Edge(e) => e.id,\n                    TraversalValue::Vector(v) => v.id,\n                    _ => continue,\n                };\n\n                // Calculate reciprocal rank: 1 / (k + rank)\n                // rank starts at 0, so actual rank is rank + 1\n                let rr_score = 1.0 / (k + (rank as f64) + 1.0);\n\n                // Sum reciprocal ranks across all lists\n                *rrf_scores.entry(id).or_insert(0.0) += rr_score;\n\n                // Store the item (keep first occurrence)\n                items_map.entry(id).or_insert(item);\n            }\n        }\n\n        // Convert to scored items and sort by RRF score (descending)\n        let mut scored_items: Vec<(u128, f64)> = rrf_scores.into_iter().collect();\n        scored_items.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Update scores and collect results\n        let mut results = Vec::with_capacity(scored_items.len());\n        for (id, score) in scored_items {\n            if let Some(mut item) = items_map.remove(&id) {\n                update_score(&mut item, score)?;\n                results.push(item);\n            }\n        }\n\n        Ok(results)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_108": {
      "name": "Default",
      "type": "impl",
      "start_line": 108,
      "end_line": 108,
      "content_hash": "cda25f18f3a35363c960472e890fd4d1a238580a",
      "content": "impl Default for RRFReranker {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_109": {
      "name": "default",
      "type": "method",
      "start_line": 109,
      "end_line": 113,
      "content_hash": "0bfc0b5dc630e980580df80d5e54d3932858b373",
      "content": "    fn default() -> Self {\n        Self::new()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Reranker_114": {
      "name": "Reranker",
      "type": "impl",
      "start_line": 114,
      "end_line": 137,
      "content_hash": "ec6de750227044214882bfd13468c7d6ff85562b",
      "content": "impl Reranker for RRFReranker {\n    fn rerank<'arena, I>(&self, items: I, _query: Option<&str>) -> RerankerResult<Vec<TraversalValue<'arena>>>\n    where\n        I: Iterator<Item = TraversalValue<'arena>>,\n    {\n        // For a single list, RRF just converts ranks to RRF scores\n        let items_vec: Vec<_> = items.collect();\n\n        if items_vec.is_empty() {\n            return Err(RerankerError::EmptyInput);\n        }\n\n        let mut results = Vec::with_capacity(items_vec.len());\n\n        for (rank, mut item) in items_vec.into_iter().enumerate() {\n            // Calculate RRF score for this item based on its rank\n            let rrf_score = 1.0 / (self.k + (rank as f64) + 1.0);\n            update_score(&mut item, rrf_score)?;\n            results.push(item);\n        }\n\n        Ok(results)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_name_138": {
      "name": "name",
      "type": "method",
      "start_line": 138,
      "end_line": 157,
      "content_hash": "78d0b307f35322aee3c9eca96bb9973944c89aa3",
      "content": "    fn name(&self) -> &str {\n        \"RRF\"\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        helix_engine::vector_core::vector::HVector,\n        utils::items::Node,\n    };\n    use bumpalo::Bump;\n\n    fn alloc_vector<'a>(arena: &'a Bump, data: &[f64]) -> HVector<'a> {\n        let slice = arena.alloc_slice_copy(data);\n        HVector::from_slice(\"test_vector\", 0, slice)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_single_list_158": {
      "name": "test_rrf_single_list",
      "type": "method",
      "start_line": 158,
      "end_line": 184,
      "content_hash": "3b5406b329b972cd234a7278173985de0435381f",
      "content": "    fn test_rrf_single_list() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::new();\n\n        let vectors: Vec<TraversalValue> = (0..5)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0, 2.0, 3.0]);\n                v.distance = Some((i + 1) as f64);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        assert_eq!(results.len(), 5);\n\n        // Check that RRF scores are calculated correctly\n        for (rank, item) in results.iter().enumerate() {\n            if let TraversalValue::Vector(v) = item {\n                let expected_score = 1.0 / (60.0 + (rank as f64) + 1.0);\n                assert!((v.distance.unwrap() - expected_score).abs() < 1e-10);\n            }\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_custom_k_185": {
      "name": "test_rrf_custom_k",
      "type": "method",
      "start_line": 185,
      "end_line": 205,
      "content_hash": "790a6e40076ec6b51b03f9428ca8fde906b09046",
      "content": "    fn test_rrf_custom_k() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::with_k(10.0).unwrap();\n\n        let vectors: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        // First item should have score 1/(10+1) = 1/11\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert!((v.distance.unwrap() - 1.0 / 11.0).abs() < 1e-10);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_multiple_lists_206": {
      "name": "test_rrf_fuse_multiple_lists",
      "type": "method",
      "start_line": 206,
      "end_line": 264,
      "content_hash": "a9b62be19fc63917497dd3bc7a95524a222da425",
      "content": "    fn test_rrf_fuse_multiple_lists() {\n        let arena = Bump::new();\n        // Create two lists with some overlap\n        let list1: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[3.0]);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let list2: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[4.0]);\n                v.id = 4;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = RRFReranker::fuse_lists(\n            vec![list1.into_iter(), list2.into_iter()],\n            60.0,\n        )\n        .unwrap();\n\n        // Items 1 and 2 appear in both lists, so should have higher scores\n        assert_eq!(results.len(), 4);\n\n        // Items 1 and 2 both appear at ranks 0 and 1 in the two lists\n        // So they should have equal RRF scores and be the top 2 results\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert!(v.id == 1 || v.id == 2);\n        }\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert!(v.id == 1 || v.id == 2);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_invalid_k_265": {
      "name": "test_rrf_invalid_k",
      "type": "method",
      "start_line": 265,
      "end_line": 273,
      "content_hash": "fd0a966b90bfb4a72cec3b2936e8205c5f15a394",
      "content": "    fn test_rrf_invalid_k() {\n        let result = RRFReranker::with_k(-1.0);\n        assert!(result.is_err());\n\n        let result = RRFReranker::with_k(0.0);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_empty_input_274": {
      "name": "test_rrf_empty_input",
      "type": "method",
      "start_line": 274,
      "end_line": 281,
      "content_hash": "298958991d8dfa58aa23a7c705fbd2270fa44477",
      "content": "    fn test_rrf_empty_input() {\n        let reranker = RRFReranker::new();\n        let empty: Vec<TraversalValue> = vec![];\n        let result = reranker.rerank(empty.into_iter(), None);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_empty_lists_282": {
      "name": "test_rrf_fuse_empty_lists",
      "type": "method",
      "start_line": 282,
      "end_line": 287,
      "content_hash": "4c7501eb0e038c9a613942042453ed4776229549",
      "content": "    fn test_rrf_fuse_empty_lists() {\n        let result = RRFReranker::fuse_lists(Vec::<std::vec::IntoIter<TraversalValue>>::new(), 60.0);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_single_list_288": {
      "name": "test_rrf_fuse_single_list",
      "type": "method",
      "start_line": 288,
      "end_line": 307,
      "content_hash": "93cf4f15ebe7cb09dd865d64d5d95ca3e36dec6a",
      "content": "    fn test_rrf_fuse_single_list() {\n        let arena = Bump::new();\n        let list: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = RRFReranker::fuse_lists(vec![list.into_iter()], 60.0).unwrap();\n\n        assert_eq!(results.len(), 3);\n        // Single list fusion should maintain order with RRF scores\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 0);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_three_lists_308": {
      "name": "test_rrf_fuse_three_lists",
      "type": "method",
      "start_line": 308,
      "end_line": 373,
      "content_hash": "a406ab300ede98d5e75518c8c97dabae95423e4c",
      "content": "    fn test_rrf_fuse_three_lists() {\n        let arena = Bump::new();\n        // Create three lists with different overlaps\n        let list1: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[3.0]);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let list2: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[4.0]);\n                v.id = 4;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let list3: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[5.0]);\n                v.id = 5;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = RRFReranker::fuse_lists(\n            vec![list1.into_iter(), list2.into_iter(), list3.into_iter()],\n            60.0,\n        )\n        .unwrap();\n\n        // Item 1 appears in all three lists at rank 0, should be highest\n        assert_eq!(results.len(), 5);\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_disjoint_lists_374": {
      "name": "test_rrf_fuse_disjoint_lists",
      "type": "method",
      "start_line": 374,
      "end_line": 420,
      "content_hash": "b04d9eb8779a016a2852e4c10f9015a8961d54e3",
      "content": "    fn test_rrf_fuse_disjoint_lists() {\n        let arena = Bump::new();\n        // Two lists with no overlap\n        let list1: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let list2: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[3.0]);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[4.0]);\n                v.id = 4;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = RRFReranker::fuse_lists(\n            vec![list1.into_iter(), list2.into_iter()],\n            60.0,\n        )\n        .unwrap();\n\n        // All items should be present with equal RRF scores for same ranks\n        assert_eq!(results.len(), 4);\n\n        // Items at rank 0 in their respective lists should have same score\n        if let (TraversalValue::Vector(v1), TraversalValue::Vector(v2)) = (&results[0], &results[1]) {\n            let score1 = v1.distance.unwrap();\n            let score2 = v2.distance.unwrap();\n            assert!((score1 - score2).abs() < 1e-10);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_very_large_k_421": {
      "name": "test_rrf_very_large_k",
      "type": "method",
      "start_line": 421,
      "end_line": 443,
      "content_hash": "caf8cfeb663eaaeccea9bb13e9fa39e38d13102e",
      "content": "    fn test_rrf_very_large_k() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::with_k(1000.0).unwrap();\n\n        let vectors: Vec<TraversalValue> = (0..5)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        // With very large k, scores should be very small and close together\n        assert_eq!(results.len(), 5);\n        if let TraversalValue::Vector(v) = &results[0] {\n            let score = v.distance.unwrap();\n            assert!(score < 0.001); // 1/1001 \u2248 0.001\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_very_small_k_444": {
      "name": "test_rrf_very_small_k",
      "type": "method",
      "start_line": 444,
      "end_line": 467,
      "content_hash": "b60595468d21ce1e325e1bef5c36d69368e3f55b",
      "content": "    fn test_rrf_very_small_k() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::with_k(0.1).unwrap();\n\n        let vectors: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        // With very small k, scores should be more differentiated\n        assert_eq!(results.len(), 3);\n        if let TraversalValue::Vector(v) = &results[0] {\n            let score = v.distance.unwrap();\n            assert!(score > 0.9); // 1/1.1 \u2248 0.909\n        }\n    }\n\n    #[ignore] // Score updates don't support plain Node types, only Vector and NodeWithScore\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_with_nodes_468": {
      "name": "test_rrf_with_nodes",
      "type": "method",
      "start_line": 468,
      "end_line": 493,
      "content_hash": "84583b7cdf766432f64a3d619f151ec00de95e1c",
      "content": "    fn test_rrf_with_nodes() {\n        let reranker = RRFReranker::new();\n\n        let nodes: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let node = Node {\n                    id: i as u128,\n                    label: \"test\",\n                    version: 1,\n                    properties: None,\n                };\n                TraversalValue::Node(node)\n            })\n            .collect();\n\n        let results = reranker.rerank(nodes.into_iter(), None).unwrap();\n\n        assert_eq!(results.len(), 3);\n        // Verify nodes are properly reranked\n        if let TraversalValue::Node(n) = &results[0] {\n            assert_eq!(n.id, 0);\n        }\n    }\n\n    #[ignore] // Score updates don't support plain Node types, only Vector and NodeWithScore\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_mixed_types_494": {
      "name": "test_rrf_mixed_types",
      "type": "method",
      "start_line": 494,
      "end_line": 526,
      "content_hash": "d68cd56f1f038ed64bc5f0bce3336e2fd613c6a1",
      "content": "    fn test_rrf_mixed_types() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::new();\n\n        let items: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let node = Node {\n                    id: 2,\n                    label: \"test\",\n                    version: 1,\n                    properties: None,\n                };\n                TraversalValue::Node(node)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[2.0]);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = reranker.rerank(items.into_iter(), None).unwrap();\n\n        // Should handle mixed types\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_fuse_with_different_list_lengths_527": {
      "name": "test_rrf_fuse_with_different_list_lengths",
      "type": "method",
      "start_line": 527,
      "end_line": 559,
      "content_hash": "16ea88cb6cb9d1207b9c64dcc7114763635e11db",
      "content": "    fn test_rrf_fuse_with_different_list_lengths() {\n        let arena = Bump::new();\n        let list1: Vec<TraversalValue> = (0..10)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let list2: Vec<TraversalValue> = (5..8)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = RRFReranker::fuse_lists(\n            vec![list1.into_iter(), list2.into_iter()],\n            60.0,\n        )\n        .unwrap();\n\n        // Items 5, 6, 7 appear in both lists, should rank higher\n        assert_eq!(results.len(), 10);\n        if let TraversalValue::Vector(v) = &results[0] {\n            // First result should be one of the overlapping items\n            assert!(v.id >= 5 && v.id <= 7);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_score_monotonicity_560": {
      "name": "test_rrf_score_monotonicity",
      "type": "method",
      "start_line": 560,
      "end_line": 582,
      "content_hash": "2968628b33d23cd9a237572d183a3c47b111d149",
      "content": "    fn test_rrf_score_monotonicity() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::new();\n\n        let vectors: Vec<TraversalValue> = (0..10)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        // Scores should be monotonically decreasing\n        for i in 0..results.len() - 1 {\n            if let (TraversalValue::Vector(v1), TraversalValue::Vector(v2)) = (&results[i], &results[i + 1]) {\n                assert!(v1.distance.unwrap() >= v2.distance.unwrap());\n            }\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_default_name_583": {
      "name": "test_rrf_default_name",
      "type": "method",
      "start_line": 583,
      "end_line": 588,
      "content_hash": "274452d5f150c5d4a8b8b17e9583d064460a1cc0",
      "content": "    fn test_rrf_default_name() {\n        let reranker = RRFReranker::new();\n        assert_eq!(reranker.name(), \"RRF\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rrf_preserves_item_data_589": {
      "name": "test_rrf_preserves_item_data",
      "type": "method",
      "start_line": 589,
      "end_line": 611,
      "content_hash": "ea499c0917835d5431606f1a4f39fc13bccacbff",
      "content": "    fn test_rrf_preserves_item_data() {\n        let arena = Bump::new();\n        let reranker = RRFReranker::new();\n\n        let vectors: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0 * i as f64, 2.0 * i as f64]);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = reranker.rerank(vectors.into_iter(), None).unwrap();\n\n        // Verify vector data is preserved\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.data, &[0.0, 0.0]);\n        }\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.data, &[1.0, 2.0]);\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}