{
  "file_path": "/work/internal/agent/tools/fetch_test.go",
  "file_hash": "3e47e047f14939e23c7cb0775c88baa1440632ad",
  "updated_at": "2025-12-26T17:34:20.094246",
  "symbols": {
    "function_TestNewFetchTool_15": {
      "name": "TestNewFetchTool",
      "type": "function",
      "start_line": 15,
      "end_line": 23,
      "content_hash": "25b39b4dcddfa729c38828fc02ef4f8d0ad660ac",
      "content": "func TestNewFetchTool(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tassert.NotNil(t, tool)\n\tassert.Equal(t, FetchToolName, tool.Info().Name)\n\tassert.NotEmpty(t, tool.Info().Description)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewFetchTool_WithCustomClient_24": {
      "name": "TestNewFetchTool_WithCustomClient",
      "type": "function",
      "start_line": 24,
      "end_line": 31,
      "content_hash": "0e86ba33664f6510c9cc274c5eb951f3fd2f0a5a",
      "content": "func TestNewFetchTool_WithCustomClient(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\tcustomClient := &http.Client{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", customClient)\n\n\tassert.NotNil(t, tool)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_MissingURL_32": {
      "name": "TestFetchTool_MissingURL",
      "type": "function",
      "start_line": 32,
      "end_line": 53,
      "content_hash": "008d57bf9eae761d4a185e26753876402ba0b2e0",
      "content": "func TestFetchTool_MissingURL(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-1\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.True(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"URL parameter is required\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_InvalidFormat_54": {
      "name": "TestFetchTool_InvalidFormat",
      "type": "function",
      "start_line": 54,
      "end_line": 76,
      "content_hash": "f591fd62648d2c36620f690bf12f142fe39b68aa",
      "content": "func TestFetchTool_InvalidFormat(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    \"https://example.com\",\n\t\tFormat: \"invalid\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-2\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.True(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"Format must be one of\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_InvalidURL_77": {
      "name": "TestFetchTool_InvalidURL",
      "type": "function",
      "start_line": 77,
      "end_line": 99,
      "content_hash": "3189bad72e191cb9c233ec9b2f749ea058de8092",
      "content": "func TestFetchTool_InvalidURL(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    \"ftp://example.com\",\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-3\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.True(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"URL must start with http:// or https://\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_MissingSessionID_100": {
      "name": "TestFetchTool_MissingSessionID",
      "type": "function",
      "start_line": 100,
      "end_line": 121,
      "content_hash": "0503d682bfb98856392726d40fd7ba347077c401",
      "content": "func TestFetchTool_MissingSessionID(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.Background() // No session ID\n\tparams := FetchParams{\n\t\tURL:    \"https://example.com\",\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-4\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\t_, err := tool.Run(ctx, toolCall)\n\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"session ID is required\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_SuccessfulFetch_122": {
      "name": "TestFetchTool_SuccessfulFetch",
      "type": "function",
      "start_line": 122,
      "end_line": 151,
      "content_hash": "0acfad77eb717e6b5ee2d2da7dd253c6ee8822a4",
      "content": "func TestFetchTool_SuccessfulFetch(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Test content\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    server.URL,\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-5\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"Test content\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_PermissionHandling_152": {
      "name": "TestFetchTool_PermissionHandling",
      "type": "function",
      "start_line": 152,
      "end_line": 158,
      "content_hash": "28a3400156701cbf54e6c43684970761b0cf1340",
      "content": "func TestFetchTool_PermissionHandling(t *testing.T) {\n\t// Note: Permission testing requires permission.Service mock with denial logic\n\t// The existing mockPermissionService always grants permission\n\t// Full permission testing is covered in integration tests\n\tt.Skip(\"Permission denial testing requires custom mock\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_HTTPError_159": {
      "name": "TestFetchTool_HTTPError",
      "type": "function",
      "start_line": 159,
      "end_line": 186,
      "content_hash": "cfaa5b27de476eec649c7a54aaeea892ef3dad3e",
      "content": "func TestFetchTool_HTTPError(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    server.URL + \"/notfound\",\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-7\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.True(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"404\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_WithTimeout_187": {
      "name": "TestFetchTool_WithTimeout",
      "type": "function",
      "start_line": 187,
      "end_line": 215,
      "content_hash": "84068ccb5436cd5742a2c7433818f1e0726b0988",
      "content": "func TestFetchTool_WithTimeout(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"test\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:     server.URL,\n\t\tFormat:  \"text\",\n\t\tTimeout: 30,\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-8\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_MaxTimeoutCap_216": {
      "name": "TestFetchTool_MaxTimeoutCap",
      "type": "function",
      "start_line": 216,
      "end_line": 244,
      "content_hash": "9409e248a468a0b54e12a0a9216b0e7bf8e9a859",
      "content": "func TestFetchTool_MaxTimeoutCap(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"test\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:     server.URL,\n\t\tFormat:  \"text\",\n\t\tTimeout: 300, // Should be capped at 120\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-9\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_HTMLFormat_245": {
      "name": "TestFetchTool_HTMLFormat",
      "type": "function",
      "start_line": 245,
      "end_line": 275,
      "content_hash": "fa4538d71fad41abfe1fac4091ff5548780a17bd",
      "content": "func TestFetchTool_HTMLFormat(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"<html><body><h1>Title</h1></body></html>\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    server.URL,\n\t\tFormat: \"html\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-10\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\t// HTML format returns the HTML content as-is (not converted to markdown)\n\tassert.Contains(t, resp.Content, \"<html>\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_MarkdownFormat_276": {
      "name": "TestFetchTool_MarkdownFormat",
      "type": "function",
      "start_line": 276,
      "end_line": 304,
      "content_hash": "780bc26d5ca9adc9c18b7939a25b0d885efebd01",
      "content": "func TestFetchTool_MarkdownFormat(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"<html><body><h1>Title</h1><p>Content</p></body></html>\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    server.URL,\n\t\tFormat: \"markdown\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-11\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_UserAgent_305": {
      "name": "TestFetchTool_UserAgent",
      "type": "function",
      "start_line": 305,
      "end_line": 336,
      "content_hash": "b32caf4082481f60089f7815b06f119a629a4c5b",
      "content": "func TestFetchTool_UserAgent(t *testing.T) {\n\tvar receivedUserAgent string\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treceivedUserAgent = r.Header.Get(\"User-Agent\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"test\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL:    server.URL,\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-12\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\t// User-Agent is set to \"nexora/1.0\" for identification\n\tassert.Contains(t, receivedUserAgent, \"nexora\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_SimpleMode_337": {
      "name": "TestFetchTool_SimpleMode",
      "type": "function",
      "start_line": 337,
      "end_line": 367,
      "content_hash": "17e07c693f5752e029a0f262645aadda7fcbd8bd",
      "content": "func TestFetchTool_SimpleMode(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"<html><body><h1>Test Title</h1><p>Test content</p></body></html>\"))\n\t}))\n\tdefer server.Close()\n\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL: server.URL,\n\t\tFormat: \"text\", // Use text format to get simple output\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-13\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\t// Text format returns the content as-is\n\tassert.Contains(t, resp.Content, \"Test Title\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFetchTool_SimpleModeInvalidURL_368": {
      "name": "TestFetchTool_SimpleModeInvalidURL",
      "type": "function",
      "start_line": 368,
      "end_line": 390,
      "content_hash": "df5b4bc4955a8742203b671c02bf5d310eb95831",
      "content": "func TestFetchTool_SimpleModeInvalidURL(t *testing.T) {\n\tmockPermissions := &mockPermissionService{}\n\ttool := NewFetchTool(mockPermissions, \"/tmp\", nil)\n\n\tctx := context.WithValue(context.Background(), SessionIDContextKey, \"test-session\")\n\tparams := FetchParams{\n\t\tURL: \"ftp://example.com\",\n\t\tFormat: \"text\",\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-14\",\n\t\tName:  FetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.True(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"URL must start with http:// or https://\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewWebFetchTool_BackwardCompatibility_391": {
      "name": "TestNewWebFetchTool_BackwardCompatibility",
      "type": "function",
      "start_line": 391,
      "end_line": 397,
      "content_hash": "3477c3087e51f370c719d6977e7c0ad325e074d0",
      "content": "func TestNewWebFetchTool_BackwardCompatibility(t *testing.T) {\n\ttool := NewWebFetchTool(\"/tmp\", nil)\n\n\tassert.NotNil(t, tool)\n\tassert.Equal(t, WebFetchToolName, tool.Info().Name)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewWebFetchTool_SuccessfulFetch_398": {
      "name": "TestNewWebFetchTool_SuccessfulFetch",
      "type": "function",
      "start_line": 398,
      "end_line": 424,
      "content_hash": "43a90fbcdd8db87cf3b1325fb3183535d3e3289e",
      "content": "func TestNewWebFetchTool_SuccessfulFetch(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"<html><body><h1>Test</h1></body></html>\"))\n\t}))\n\tdefer server.Close()\n\n\ttool := NewWebFetchTool(\"/tmp\", nil)\n\n\tctx := context.Background()\n\tparams := WebFetchParams{\n\t\tURL: server.URL,\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test-15\",\n\t\tName:  WebFetchToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\tassert.Contains(t, resp.Content, \"Fetched content from\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}