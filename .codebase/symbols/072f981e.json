{
  "file_path": "/work/internal/config/resolve.go",
  "file_hash": "5352e7b7d0e17a7ab887cd297886cdc7f86ca87a",
  "updated_at": "2025-12-26T17:34:22.031545",
  "symbols": {
    "interface_VariableResolver_13": {
      "name": "VariableResolver",
      "type": "interface",
      "start_line": 13,
      "end_line": 16,
      "content_hash": "4225e43e46cb59c78723cbce8fd3ebb224fa9ddb",
      "content": "type VariableResolver interface {\n\tResolveValue(value string) (string, error)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_Shell_17": {
      "name": "Shell",
      "type": "interface",
      "start_line": 17,
      "end_line": 20,
      "content_hash": "bf7a0a37215814a8f2229e14f6055da20412ce40",
      "content": "type Shell interface {\n\tExec(ctx context.Context, command string) (stdout, stderr string, err error)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_shellVariableResolver_21": {
      "name": "shellVariableResolver",
      "type": "struct",
      "start_line": 21,
      "end_line": 25,
      "content_hash": "711ddeec205b27ed785c44b1b9477bfea5d6fabc",
      "content": "type shellVariableResolver struct {\n\tshell Shell\n\tenv   env.Env\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewShellVariableResolver_26": {
      "name": "NewShellVariableResolver",
      "type": "function",
      "start_line": 26,
      "end_line": 40,
      "content_hash": "8a21f96ad3d2ee6aa6b43864ddea6b368896a678",
      "content": "func NewShellVariableResolver(env env.Env) VariableResolver {\n\treturn &shellVariableResolver{\n\t\tenv: env,\n\t\tshell: shell.NewShell(\n\t\t\t&shell.Options{\n\t\t\t\tEnv: env.Env(),\n\t\t\t},\n\t\t),\n\t}\n}\n\n// ResolveValue is a method for resolving values, such as environment variables.\n// it will resolve shell-like variable substitution anywhere in the string, including:\n// - $(command) for command substitution\n// - $VAR or ${VAR} for environment variables",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ResolveValue_41": {
      "name": "ResolveValue",
      "type": "method",
      "start_line": 41,
      "end_line": 153,
      "content_hash": "045303aaa157fb728792aaf79191261ecb312335",
      "content": "func (r *shellVariableResolver) ResolveValue(value string) (string, error) {\n\t// Special case: lone $ is an error (backward compatibility)\n\tif value == \"$\" {\n\t\treturn \"\", fmt.Errorf(\"invalid value format: %s\", value)\n\t}\n\n\t// If no $ found, return as-is\n\tif !strings.Contains(value, \"$\") {\n\t\treturn value, nil\n\t}\n\n\tresult := value\n\n\t// Handle command substitution: $(command)\n\tfor {\n\t\tstart := strings.Index(result, \"$(\")\n\t\tif start == -1 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Find matching closing parenthesis\n\t\tdepth := 0\n\t\tend := -1\n\t\tfor i := start + 2; i < len(result); i++ {\n\t\t\tif result[i] == '(' {\n\t\t\t\tdepth++\n\t\t\t} else if result[i] == ')' {\n\t\t\t\tif depth == 0 {\n\t\t\t\t\tend = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdepth--\n\t\t\t}\n\t\t}\n\n\t\tif end == -1 {\n\t\t\treturn \"\", fmt.Errorf(\"unmatched $( in value: %s\", value)\n\t\t}\n\n\t\tcommand := result[start+2 : end]\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n\n\t\tstdout, _, err := r.shell.Exec(ctx, command)\n\t\tcancel()\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"command execution failed for '%s': %w\", command, err)\n\t\t}\n\n\t\t// Replace the $(command) with the output\n\t\treplacement := strings.TrimSpace(stdout)\n\t\tresult = result[:start] + replacement + result[end+1:]\n\t}\n\n\t// Handle environment variables: $VAR and ${VAR}\n\tsearchStart := 0\n\tfor {\n\t\tstart := strings.Index(result[searchStart:], \"$\")\n\t\tif start == -1 {\n\t\t\tbreak\n\t\t}\n\t\tstart += searchStart // Adjust for the offset\n\n\t\t// Skip if this is part of $( which we already handled\n\t\tif start+1 < len(result) && result[start+1] == '(' {\n\t\t\t// Skip past this $(...)\n\t\t\tsearchStart = start + 1\n\t\t\tcontinue\n\t\t}\n\t\tvar varName string\n\t\tvar end int\n\n\t\tif start+1 < len(result) && result[start+1] == '{' {\n\t\t\t// Handle ${VAR} format\n\t\t\tcloseIdx := strings.Index(result[start+2:], \"}\")\n\t\t\tif closeIdx == -1 {\n\t\t\t\treturn \"\", fmt.Errorf(\"unmatched ${ in value: %s\", value)\n\t\t\t}\n\t\t\tvarName = result[start+2 : start+2+closeIdx]\n\t\t\tend = start + 2 + closeIdx + 1\n\t\t} else {\n\t\t\t// Handle $VAR format - variable names must start with letter or underscore\n\t\t\tif start+1 >= len(result) {\n\t\t\t\treturn \"\", fmt.Errorf(\"incomplete variable reference at end of string: %s\", value)\n\t\t\t}\n\n\t\t\tif result[start+1] != '_' &&\n\t\t\t\t(result[start+1] < 'a' || result[start+1] > 'z') &&\n\t\t\t\t(result[start+1] < 'A' || result[start+1] > 'Z') {\n\t\t\t\treturn \"\", fmt.Errorf(\"invalid variable name starting with '%c' in: %s\", result[start+1], value)\n\t\t\t}\n\n\t\t\tend = start + 1\n\t\t\tfor end < len(result) && (result[end] == '_' ||\n\t\t\t\t(result[end] >= 'a' && result[end] <= 'z') ||\n\t\t\t\t(result[end] >= 'A' && result[end] <= 'Z') ||\n\t\t\t\t(result[end] >= '0' && result[end] <= '9')) {\n\t\t\t\tend++\n\t\t\t}\n\t\t\tvarName = result[start+1 : end]\n\t\t}\n\n\t\tenvValue := r.env.Get(varName)\n\t\tif envValue == \"\" {\n\t\t\treturn \"\", fmt.Errorf(\"environment variable %q not set\", varName)\n\t\t}\n\n\t\tresult = result[:start] + envValue + result[end:]\n\t\tsearchStart = start + len(envValue) // Continue searching after the replacement\n\t}\n\n\treturn result, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_environmentVariableResolver_154": {
      "name": "environmentVariableResolver",
      "type": "struct",
      "start_line": 154,
      "end_line": 157,
      "content_hash": "8e7607c9b2ecdb30eaf4241d5e9f2bfea61eb4e0",
      "content": "type environmentVariableResolver struct {\n\tenv env.Env\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewEnvironmentVariableResolver_158": {
      "name": "NewEnvironmentVariableResolver",
      "type": "function",
      "start_line": 158,
      "end_line": 164,
      "content_hash": "fe3353315eb3922686117de8b108cb6c723cb9a3",
      "content": "func NewEnvironmentVariableResolver(env env.Env) VariableResolver {\n\treturn &environmentVariableResolver{\n\t\tenv: env,\n\t}\n}\n\n// ResolveValue resolves environment variables from the provided env.Env.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ResolveValue_165": {
      "name": "ResolveValue",
      "type": "method",
      "start_line": 165,
      "end_line": 176,
      "content_hash": "91000b0eb362fa76d4e13e07a5567776dddb5501",
      "content": "func (r *environmentVariableResolver) ResolveValue(value string) (string, error) {\n\tif !strings.HasPrefix(value, \"$\") {\n\t\treturn value, nil\n\t}\n\n\tvarName := strings.TrimPrefix(value, \"$\")\n\tresolvedValue := r.env.Get(varName)\n\tif resolvedValue == \"\" {\n\t\treturn \"\", fmt.Errorf(\"environment variable %q not set\", varName)\n\t}\n\treturn resolvedValue, nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}