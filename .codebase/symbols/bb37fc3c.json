{
  "file_path": "/work/internal/cmd/index_cmd.go",
  "file_hash": "11e65d4703cbdf364fece8f72b5209b4419de6a5",
  "updated_at": "2025-12-26T17:34:24.021593",
  "symbols": {
    "function_init_44": {
      "name": "init",
      "type": "function",
      "start_line": 44,
      "end_line": 51,
      "content_hash": "0806ddd9749f215ca99d056829d309af0c3d91ae",
      "content": "func init() {\n\tindexCmd.Flags().BoolVarP(&indexRecursive, \"recursive\", \"r\", true, \"Index directories recursively\")\n\tindexCmd.Flags().BoolVarP(&indexEmbeddings, \"embeddings\", \"e\", true, \"Generate semantic embeddings\")\n\tindexCmd.Flags().StringVarP(&indexOutput, \"output\", \"o\", \"nexora_index.db\", \"Output database path\")\n\tindexCmd.Flags().BoolVarP(&indexIncludeTests, \"include-tests\", \"t\", false, \"Include test files\")\n\tindexCmd.Flags().IntVarP(&indexWorkers, \"workers\", \"w\", 4, \"Number of parallel workers\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runIndex_52": {
      "name": "runIndex",
      "type": "function",
      "start_line": 52,
      "end_line": 91,
      "content_hash": "b8bf8ab6d6b5b2d9b35a65a69e579044f6c79794",
      "content": "func runIndex(cmd *cobra.Command, args []string) error {\n\tstart := time.Now()\n\n\t// Determine path to index\n\tvar path string\n\tif len(args) == 0 {\n\t\tpath = \".\"\n\t} else {\n\t\tpath = args[0]\n\t}\n\n\t// Resolve path\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve path %s: %w\", path, err)\n\t}\n\n\t// Check if path exists\n\tif _, err := os.Stat(absPath); os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"path does not exist: %s\", absPath)\n\t}\n\n\t// Create progress reporter\n\tprogress := &IndexProgress{}\n\n\t// Index the codebase\n\tctx := context.Background()\n\terr = indexCodebase(ctx, absPath, progress)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"indexing failed: %w\", err)\n\t}\n\n\tduration := time.Since(start)\n\tfmt.Printf(\"\u2705 Indexing complete symbols=%d embeddings=%d duration=%s database=%s\\n\",\n\t\tprogress.SymbolsFound, progress.EmbeddingsGenerated, duration.Round(time.Millisecond), indexOutput)\n\n\treturn nil\n}\n\n// IndexProgress tracks indexing progress",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IndexProgress_92": {
      "name": "IndexProgress",
      "type": "struct",
      "start_line": 92,
      "end_line": 99,
      "content_hash": "f46374f48798eb6e89681f4391e0a3a6a916d57b",
      "content": "type IndexProgress struct {\n\tSymbolsFound        int\n\tEmbeddingsGenerated int\n\tFilesProcessed      int\n\tCurrentFile         string\n\tDirectoriesIndexed  int\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_UpdateStats_100": {
      "name": "UpdateStats",
      "type": "method",
      "start_line": 100,
      "end_line": 108,
      "content_hash": "af12238ded026da82c55a7f9f5a7c0b1556826e6",
      "content": "func (p *IndexProgress) UpdateStats() {\n\t// Suppress output during tests\n\tif flag.Lookup(\"test.v\") == nil {\n\t\tfmt.Printf(\"\ud83d\udcca Progress: files=%d, symbols=%d, embeddings=%d, current=%s\\n\",\n\t\t\tp.FilesProcessed, p.SymbolsFound, p.EmbeddingsGenerated, filepath.Base(p.CurrentFile))\n\t}\n}\n\n// indexCodebase handles the complete indexing pipeline",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_indexCodebase_109": {
      "name": "indexCodebase",
      "type": "function",
      "start_line": 109,
      "end_line": 221,
      "content_hash": "05545192b966c98e4b652f9b3f9090e78daaa89e",
      "content": "func indexCodebase(ctx context.Context, path string, progress *IndexProgress) error {\n\t// Create output database\n\tif err := ensureOutputDir(indexOutput); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory: %w\", err)\n\t}\n\n\t// Initialize indexer\n\tstorage, err := indexer.NewIndexer(indexOutput)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize storage: %w\", err)\n\t}\n\tdefer storage.Close()\n\n\t// Initialize embedding engine if requested\n\tvar embeddingEngine *indexer.EmbeddingEngine\n\tif indexEmbeddings {\n\t\t// For now, use mock provider - in production would have configurable provider\n\t\tprovider := indexer.NewLocalProvider(\"mock\", \"/tmp\")\n\t\tembeddingEngine = indexer.NewEmbeddingEngine(provider, storage)\n\t}\n\n\t// Create parser\n\tparser := indexer.NewASTParser()\n\n\t// Find all Go files\n\tgoFiles, err := findGoFiles(path, indexRecursive)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find Go files: %w\", err)\n\t}\n\n\tif len(goFiles) == 0 {\n\t\treturn fmt.Errorf(\"no Go files found in %s\", path)\n\t}\n\n\t// Process files - use directory parsing since ParseFile isn't exposed\n\tsymbolMap := make(map[string]*indexer.Symbol)\n\tallSymbols := []indexer.Symbol{}\n\n\t// Group files by directory and parse each directory\n\tdirFiles := make(map[string][]string)\n\tfor _, file := range goFiles {\n\t\tdir := filepath.Dir(file)\n\t\tdirFiles[dir] = append(dirFiles[dir], file)\n\t}\n\n\tfileCount := 0\n\tfor dir := range dirFiles {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Parse directory\n\t\tsymbols, err := parser.ParseDirectory(ctx, dir)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to parse directory %s: %v\\n\", dir, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Filter to only include files we want\n\t\tfor _, symbol := range symbols {\n\t\t\tsymbolMap[symbol.Name+\"@\"+symbol.Package] = &symbol\n\t\t\tallSymbols = append(allSymbols, symbol)\n\t\t\tprogress.SymbolsFound++\n\t\t\tfileCount++\n\n\t\t\tif fileCount%10 == 0 {\n\t\t\t\tprogress.CurrentFile = symbol.File\n\t\t\t\tprogress.FilesProcessed = fileCount\n\t\t\t\tprogress.UpdateStats()\n\t\t\t}\n\t\t}\n\t\tprogress.DirectoriesIndexed++\n\t}\n\n\tprogress.FilesProcessed = len(goFiles)\n\tprogress.UpdateStats()\n\n\t// Store symbols\n\terr = storage.StoreSymbols(ctx, allSymbols)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to store symbols: %w\", err)\n\t}\n\n\t// Generate and store embeddings if requested\n\tif indexEmbeddings && embeddingEngine != nil {\n\n\t\tembeddings, err := embeddingEngine.GenerateSymbolEmbeddings(ctx, allSymbols)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to generate embeddings: %w\", err)\n\t\t}\n\n\t\tprogress.EmbeddingsGenerated = len(embeddings)\n\n\t\terr = storage.StoreEmbeddings(ctx, embeddings)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to store embeddings: %w\", err)\n\t\t}\n\t}\n\n\t// Build and store graph\n\tgraphBuilder := indexer.NewGraphBuilder()\n\tgraph, err := graphBuilder.BuildGraph(ctx, symbolMap)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to build graph: %w\", err)\n\t}\n\n\t// For now, just keep graph in memory - could be serialized to JSON later\n\t_ = graph\n\n\treturn nil\n}\n\n// findGoFiles finds all Go files in the specified path",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findGoFiles_222": {
      "name": "findGoFiles",
      "type": "function",
      "start_line": 222,
      "end_line": 271,
      "content_hash": "99ff12850ce5267623154807d9f175f3ed6b4b90",
      "content": "func findGoFiles(root string, recursive bool) ([]string, error) {\n\tvar files []string\n\n\terr := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Skip if not a Go file\n\t\tif filepath.Ext(path) != \".go\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Skip test files unless requested\n\t\tif !indexIncludeTests && (strings.Contains(filepath.Base(path), \"_test.go\")) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Skip hidden files and directories\n\t\tif strings.HasPrefix(filepath.Base(path), \".\") {\n\t\t\tif info.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Skip vendor directory\n\t\tif strings.Contains(path, \"vendor\"+string(filepath.Separator)) {\n\t\t\tif info.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Skip .git directory\n\t\tif strings.Contains(path, \".git\"+string(filepath.Separator)) {\n\t\t\tif info.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tfiles = append(files, path)\n\t\treturn nil\n\t})\n\n\treturn files, err\n}\n\n// ensureOutputDir ensures the output directory exists",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensureOutputDir_272": {
      "name": "ensureOutputDir",
      "type": "function",
      "start_line": 272,
      "end_line": 275,
      "content_hash": "f03064f436032bb7b495e781f42e3119e01bed69",
      "content": "func ensureOutputDir(dbPath string) error {\n\tdir := filepath.Dir(dbPath)\n\treturn os.MkdirAll(dir, 0o755)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}