{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/commands/integrations/helix.rs",
  "file_hash": "0dbf27181ab1d850748aed9e7bf2aebc487abeba",
  "updated_at": "2025-12-26T17:34:21.248669",
  "symbols": {
    "struct_HelixManager_28": {
      "name": "HelixManager",
      "type": "struct",
      "start_line": 28,
      "end_line": 31,
      "content_hash": "3c78bf41882bae0171b924f1c67f37406a788524",
      "content": "pub struct HelixManager<'a> {\n    project: &'a ProjectContext,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixManager_32": {
      "name": "HelixManager",
      "type": "impl",
      "start_line": 32,
      "end_line": 32,
      "content_hash": "9516f7869fb7743f92867384cd036190bb7c89c5",
      "content": "impl<'a> HelixManager<'a> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_33": {
      "name": "new",
      "type": "method",
      "start_line": 33,
      "end_line": 432,
      "content_hash": "20e8979476cc4441b4886f1657a627219b2cfc7d",
      "content": "    pub fn new(project: &'a ProjectContext) -> Self {\n        Self { project }\n    }\n\n    pub async fn create_instance_config(\n        &self,\n        _instance_name: &str,\n        region: Option<String>,\n    ) -> Result<CloudInstanceConfig> {\n        // Generate unique cluster ID\n        // let cluster_id = format!(\"helix-{}-{}\", instance_name, Uuid::new_v4());\n        let cluster_id = \"YOUR_CLUSTER_ID\".to_string();\n\n        // Use provided region or default to us-east-1\n        let region = region.or_else(|| Some(\"us-east-1\".to_string()));\n\n        Ok(CloudInstanceConfig {\n            cluster_id,\n            region,\n            build_mode: BuildMode::Release,\n            env_vars: HashMap::new(),\n            db_config: DbConfig::default(),\n        })\n    }\n\n    #[allow(dead_code)]\n    pub async fn init_cluster(\n        &self,\n        instance_name: &str,\n        config: &CloudInstanceConfig,\n    ) -> Result<()> {\n        // Check authentication first\n        require_auth().await?;\n\n        print_status(\n            \"CLOUD\",\n            &format!(\"Initializing Helix cloud cluster: {}\", config.cluster_id),\n        );\n        print_status(\n            \"INFO\",\n            \"Note: Cluster provisioning API is not yet implemented\",\n        );\n        print_status(\n            \"INFO\",\n            \"This will create the configuration locally and provision the cluster when the API is ready\",\n        );\n\n        // TODO: When the backend API is ready, implement actual cluster creation\n        // let credentials = Credentials::read_from_file(&self.credentials_path());\n        // let create_request = json!({\n        //     \"name\": instance_name,\n        //     \"cluster_id\": config.cluster_id,\n        //     \"region\": config.region,\n        //     \"instance_type\": \"small\",\n        //     \"user_id\": credentials.user_id\n        // });\n\n        // let client = reqwest::Client::new();\n        // let cloud_url = format!(\"http://{}/clusters/create\", *CLOUD_AUTHORITY);\n\n        // let response = client\n        //     .post(cloud_url)\n        //     .header(\"x-api-key\", &credentials.helix_admin_key)\n        //     .header(\"Content-Type\", \"application/json\")\n        //     .json(&create_request)\n        //     .send()\n        //     .await?;\n\n        // match response.status() {\n        //     reqwest::StatusCode::CREATED => {\n        //         print_success(\"Cluster creation initiated\");\n        //         self.wait_for_cluster_ready(&config.cluster_id).await?;\n        //     }\n        //     reqwest::StatusCode::CONFLICT => {\n        //         return Err(eyre!(\"Cluster name '{}' already exists\", instance_name));\n        //     }\n        //     reqwest::StatusCode::UNAUTHORIZED => {\n        //         return Err(eyre!(\"Authentication failed. Run 'helix auth login'\"));\n        //     }\n        //     _ => {\n        //         let error_text = response.text().await.unwrap_or_default();\n        //         return Err(eyre!(\"Failed to create cluster: {}\", error_text));\n        //     }\n        // }\n\n        print_success(format!(\"Cloud instance '{instance_name}' configuration created\").as_str());\n        print_status(\n            \"NEXT\",\n            \"Run 'helix build <instance>' to compile your project for this instance\",\n        );\n\n        Ok(())\n    }\n\n    pub(crate) async fn deploy(\n        &self,\n        path: Option<String>,\n        cluster_name: String,\n        build_mode: BuildMode,\n    ) -> Result<()> {\n        let credentials = require_auth().await?;\n        let path = match get_path_or_cwd(path.as_ref()) {\n            Ok(path) => path,\n            Err(e) => {\n                return Err(eyre!(\"Error: failed to get path: {e}\"));\n            }\n        };\n        let files =\n            collect_hx_files(&path, &self.project.config.project.queries).unwrap_or_default();\n\n        let content = match generate_content(&files) {\n            Ok(content) => content,\n            Err(e) => {\n                return Err(eyre!(\"Error: failed to generate content: {e}\"));\n            }\n        };\n\n        // Optionally load config from helix.toml or legacy config.hx.json\n        let helix_toml_path = path.join(\"helix.toml\");\n        let config_hx_path = path.join(\"config.hx.json\");\n        let schema_path = path.join(\"schema.hx\");\n\n        let _config: Option<Config> = if helix_toml_path.exists() {\n            // v2 format: helix.toml (config is already loaded in self.project)\n            None\n        } else if config_hx_path.exists() {\n            // v1 backward compatibility: config.hx.json\n            if schema_path.exists() {\n                Config::from_files(config_hx_path, schema_path).ok()\n            } else {\n                Config::from_file(config_hx_path).ok()\n            }\n        } else {\n            None\n        };\n\n        // get cluster information from helix.toml\n        let cluster_info = match self.project.config.get_instance(&cluster_name)? {\n            InstanceInfo::Helix(config) => config,\n            _ => {\n                return Err(eyre!(\"Error: cluster is not a cloud instance\"));\n            }\n        };\n\n        // Separate schema from query files\n        let mut schema_content = String::new();\n        let mut queries_map: HashMap<String, String> = HashMap::new();\n\n        for file in &content.files {\n            if file.name.ends_with(\"schema.hx\") {\n                schema_content = file.content.clone();\n            } else {\n                queries_map.insert(file.name.clone(), file.content.clone());\n            }\n        }\n\n        let dev_profile = build_mode == BuildMode::Dev;\n\n        // Prepare deployment payload\n        let payload = json!({\n            \"schema\": schema_content,\n            \"queries\": queries_map,\n            \"env_vars\": cluster_info.env_vars,\n            \"instance_name\": cluster_name,\n            \"dev_profile\": dev_profile\n        });\n\n        // Initiate deployment with SSE streaming\n        let client = reqwest::Client::new();\n        let deploy_url = format!(\"https://{}/deploy\", *CLOUD_AUTHORITY);\n\n        let mut event_source = client\n            .post(&deploy_url)\n            .header(\"x-api-key\", &credentials.helix_admin_key)\n            .header(\"x-cluster-id\", &cluster_info.cluster_id)\n            .header(\"Content-Type\", \"application/json\")\n            .json(&payload)\n            .eventsource()?;\n\n        let progress = SseProgressHandler::new(\"Deploying queries...\");\n        let mut deployment_success = false;\n\n        // Process SSE events\n        use futures_util::StreamExt;\n\n        while let Some(event) = event_source.next().await {\n            match event {\n                Ok(reqwest_eventsource::Event::Open) => {\n                    // Connection opened\n                }\n                Ok(reqwest_eventsource::Event::Message(message)) => {\n                    // Parse the SSE event\n                    let sse_event: SseEvent = match serde_json::from_str(&message.data) {\n                        Ok(event) => event,\n                        Err(e) => {\n                            progress.println(&format!(\"Failed to parse event: {}\", e));\n                            continue;\n                        }\n                    };\n\n                    match sse_event {\n                        SseEvent::Progress {\n                            percentage,\n                            message,\n                        } => {\n                            progress.set_progress(percentage);\n                            if let Some(msg) = message {\n                                progress.set_message(&msg);\n                            }\n                        }\n                        SseEvent::Log { message, .. } => {\n                            progress.println(&message);\n                        }\n                        SseEvent::StatusTransition { to, message, .. } => {\n                            let msg = message.unwrap_or_else(|| format!(\"Status: {}\", to));\n                            progress.println(&msg);\n                        }\n                        SseEvent::Success { .. } => {\n                            deployment_success = true;\n                            progress.finish(\"Deployment completed successfully!\");\n                            event_source.close();\n                            break;\n                        }\n                        SseEvent::Error { error } => {\n                            progress.finish_error(&format!(\"Error: {}\", error));\n                            event_source.close();\n                            return Err(eyre!(\"Deployment failed: {}\", error));\n                        }\n                        // Deploy-specific events\n                        SseEvent::ValidatingQueries => {\n                            progress.set_message(\"Validating queries...\");\n                        }\n                        SseEvent::Building {\n                            estimated_percentage,\n                        } => {\n                            progress.set_progress(estimated_percentage as f64);\n                            progress.set_message(\"Building...\");\n                        }\n                        SseEvent::Deploying => {\n                            progress.set_message(\"Deploying to infrastructure...\");\n                        }\n                        SseEvent::Deployed { url, auth_key } => {\n                            deployment_success = true;\n                            progress.finish(\"Deployment completed!\");\n                            print_success(&format!(\"Deployed to: {}\", url));\n                            print_status(\"AUTH_KEY\", &format!(\"Your auth key: {}\", auth_key));\n\n                            // Prompt user for .env handling\n                            println!();\n                            println!(\"Would you like to save connection details to a .env file?\");\n                            println!(\"  1. Add to .env in project root (Recommended)\");\n                            println!(\"  2. Don't add\");\n                            println!(\"  3. Specify custom path\");\n                            print!(\"\\nChoice [1]: \");\n\n                            use std::io::{self, Write};\n                            io::stdout().flush().ok();\n\n                            let mut input = String::new();\n                            if io::stdin().read_line(&mut input).is_ok() {\n                                let choice = input.trim();\n                                match choice {\n                                    \"1\" | \"\" => {\n                                        let env_path = self.project.root.join(\".env\");\n                                        let comment = format!(\n                                            \"# HelixDB Cloud URL for instance: {}\",\n                                            cluster_name\n                                        );\n                                        if let Err(e) = crate::utils::add_env_var_with_comment(\n                                            &env_path,\n                                            \"HELIX_CLOUD_URL\",\n                                            &url,\n                                            Some(&comment),\n                                        ) {\n                                            print_error(&format!(\"Failed to write .env: {}\", e));\n                                        }\n                                        match crate::utils::add_env_var_to_file(\n                                            &env_path,\n                                            \"HELIX_API_KEY\",\n                                            &auth_key,\n                                        ) {\n                                            Ok(_) => print_success(&format!(\n                                                \"Added HELIX_CLOUD_URL and HELIX_API_KEY to {}\",\n                                                env_path.display()\n                                            )),\n                                            Err(e) => {\n                                                print_error(&format!(\"Failed to write .env: {}\", e))\n                                            }\n                                        }\n                                    }\n                                    \"2\" => {\n                                        print_status(\"INFO\", \"Skipped saving to .env\");\n                                    }\n                                    \"3\" => {\n                                        print!(\"Enter path: \");\n                                        io::stdout().flush().ok();\n                                        let mut path_input = String::new();\n                                        if io::stdin().read_line(&mut path_input).is_ok() {\n                                            let custom_path = PathBuf::from(path_input.trim());\n                                            let comment = format!(\n                                                \"# HelixDB Cloud URL for instance: {}\",\n                                                cluster_name\n                                            );\n                                            if let Err(e) = crate::utils::add_env_var_with_comment(\n                                                &custom_path,\n                                                \"HELIX_CLOUD_URL\",\n                                                &url,\n                                                Some(&comment),\n                                            ) {\n                                                print_error(&format!(\n                                                    \"Failed to write .env: {}\",\n                                                    e\n                                                ));\n                                            }\n                                            match crate::utils::add_env_var_to_file(\n                                                &custom_path,\n                                                \"HELIX_API_KEY\",\n                                                &auth_key,\n                                            ) {\n                                                Ok(_) => print_success(&format!(\n                                                    \"Added HELIX_CLOUD_URL and HELIX_API_KEY to {}\",\n                                                    custom_path.display()\n                                                )),\n                                                Err(e) => print_error(&format!(\n                                                    \"Failed to write .env: {}\",\n                                                    e\n                                                )),\n                                            }\n                                        }\n                                    }\n                                    _ => {\n                                        print_status(\n                                            \"INFO\",\n                                            \"Invalid choice, skipped saving to .env\",\n                                        );\n                                    }\n                                }\n                            }\n\n                            event_source.close();\n                            break;\n                        }\n                        SseEvent::Redeployed { url } => {\n                            deployment_success = true;\n                            progress.finish(\"Redeployment completed!\");\n                            print_success(&format!(\"Redeployed to: {}\", url));\n                            event_source.close();\n                            break;\n                        }\n                        SseEvent::BadRequest { error } => {\n                            progress.finish_error(&format!(\"Bad request: {}\", error));\n                            event_source.close();\n                            return Err(eyre!(\"Bad request: {}\", error));\n                        }\n                        SseEvent::QueryValidationError { error } => {\n                            progress.finish_error(&format!(\"Query validation failed: {}\", error));\n                            event_source.close();\n                            return Err(eyre!(\"Query validation error: {}\", error));\n                        }\n                        _ => {\n                            // Ignore other event types\n                        }\n                    }\n                }\n                Err(err) => {\n                    progress.finish_error(&format!(\"Stream error: {}\", err));\n                    return Err(eyre!(\"Deployment stream error: {}\", err));\n                }\n            }\n        }\n\n        if !deployment_success {\n            return Err(eyre!(\"Deployment did not complete successfully\"));\n        }\n\n        print_success(\"Queries deployed successfully\");\n        Ok(())\n    }\n\n    #[allow(dead_code)]\n    pub(crate) async fn redeploy(\n        &self,\n        path: Option<String>,\n        cluster_name: String,\n        build_mode: BuildMode,\n    ) -> Result<()> {\n        // Redeploy is similar to deploy but may have different backend handling\n        // For now, we'll use the same implementation with a different status message\n        print_status(\n            \"REDEPLOY\",\n            &format!(\"Redeploying to cluster: {}\", cluster_name),\n        );\n\n        // Call deploy with the same logic\n        // In the future, this could use a different endpoint or add a \"redeploy\" flag\n        self.deploy(path, cluster_name, build_mode).await\n    }\n}\n\n/// Returns the path or the current working directory if no path is provided",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_path_or_cwd_433": {
      "name": "get_path_or_cwd",
      "type": "method",
      "start_line": 433,
      "end_line": 438,
      "content_hash": "0cb2b3664eac2810bd76e4431cabbc7da9411ac4",
      "content": "pub fn get_path_or_cwd(path: Option<&String>) -> Result<PathBuf> {\n    match path {\n        Some(p) => Ok(PathBuf::from(p)),\n        None => Ok(env::current_dir()?),\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}