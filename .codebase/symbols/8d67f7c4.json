{
  "file_path": "/work/context-engine/scripts/health_check.py",
  "file_hash": "c257d7e7a89801429545511768c202282f470859",
  "updated_at": "2025-12-26T17:34:21.443631",
  "symbols": {
    "function_assert_true_27": {
      "name": "assert_true",
      "type": "function",
      "start_line": 27,
      "end_line": 32,
      "content_hash": "d556aead27a147b00be5506189f15ed2bf0d7a97",
      "content": "def assert_true(cond: bool, msg: str):\n    if not cond:\n        print(f\"[FAIL] {msg}\")\n        sys.exit(1)\n    else:\n        print(f\"[OK] {msg}\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_35": {
      "name": "main",
      "type": "function",
      "start_line": 35,
      "end_line": 157,
      "content_hash": "ca6b3dff54ff942d83c0a7079ce07d05644ad90c",
      "content": "def main():\n    qdrant_url = os.environ.get(\"QDRANT_URL\", \"http://localhost:6333\")\n    api_key = os.environ.get(\"QDRANT_API_KEY\")\n    collection = os.environ.get(\"COLLECTION_NAME\", \"codebase\")\n    model_name = os.environ.get(\"EMBEDDING_MODEL\", \"BAAI/bge-base-en-v1.5\")\n\n    print(f\"Health check -> {qdrant_url} collection={collection} model={model_name}\")\n\n    # Init embedding to derive dimension and test embedding\n    if _EMBEDDER_FACTORY:\n        model = get_embedding_model(model_name)\n        dim = get_model_dimension(model_name)\n    else:\n        model = TextEmbedding(model_name=model_name)\n        dim = len(next(model.embed([\"health dim probe\"])))\n    vec_name_expect = sanitize_vector_name(model_name)\n\n    client = QdrantClient(url=qdrant_url, api_key=api_key or None)\n\n    # Get all collections and check each one\n    try:\n        collections_response = client.get_collections()\n        collections = [c.name for c in collections_response.collections]\n        print(f\"Found collections: {collections}\")\n        try:\n            created = ensure_collections(collections)\n            if created:\n                print(f\"[OK] Synced collections registry (new entries: {created})\")\n            else:\n                print(\"[OK] Synced collections registry\")\n        except AuthDisabledError:\n            pass\n        except Exception as e:\n            print(f\"[WARN] Failed to sync collections registry: {e}\")\n    except Exception as e:\n        print(f\"Error getting collections: {e}\")\n        sys.exit(1)\n\n    if not collections:\n        print(\"No collections found - nothing to health check\")\n        return\n\n    # Check each collection\n    for collection_name in collections:\n        print(f\"Checking collection: {collection_name}\")\n\n        # 1) Collection exists and has expected named vector/dimension\n        info = client.get_collection(collection_name)\n        cfg = info.config.params.vectors\n        if isinstance(cfg, dict):\n            present_names = list(cfg.keys())\n            assert_true(len(present_names) >= 1, \"Collection has at least one named vector\")\n            assert_true(\n                vec_name_expect in present_names,\n                f\"Expected vector name present: {vec_name_expect} in {present_names}\",\n            )\n            got_dim = cfg[vec_name_expect].size\n        else:\n            present_names = [\"<unnamed>\"]\n            got_dim = cfg.size\n        assert_true(\n            got_dim == dim, f\"Vector dimension matches embedding ({got_dim} == {dim})\"\n        )\n\n        # 2) HNSW tuned params (best effort; allow >= thresholds)\n        hcfg = info.config.hnsw_config\n        try:\n            m = getattr(hcfg, \"m\", None)\n            efc = getattr(hcfg, \"ef_construct\", None)\n            assert_true(m is None or m >= 16, f\"HNSW m>=16 (got {m})\")\n            assert_true(efc is None or efc >= 256, f\"HNSW ef_construct>=256 (got {efc})\")\n        except Exception:\n            print(\"[WARN] Could not read HNSW config; continuing\")\n\n        # 3) Test queries on this collection\n        probe_text = \"split code into overlapping line chunks\"\n        probe_vec = next(model.embed([probe_text])).tolist()\n\n        # Unfiltered query\n        qp = client.query_points(\n            collection_name=collection_name,\n            query=probe_vec,\n            using=vec_name_expect,\n            limit=3,\n            with_payload=True,\n            search_params=models.SearchParams(hnsw_ef=128),\n        )\n        res_points = getattr(qp, \"points\", qp)\n        assert_true(isinstance(res_points, list), \"query_points returns a list of points\")\n\n        # Filtered by language + kind (should not error; may return 0 results if dataset sparse)\n        flt = models.Filter(\n            must=[\n                models.FieldCondition(\n                    key=\"metadata.language\", match=models.MatchValue(value=\"python\")\n                ),\n                models.FieldCondition(\n                    key=\"metadata.kind\", match=models.MatchValue(value=\"function\")\n                ),\n            ]\n        )\n        qp2 = client.query_points(\n            collection_name=collection_name,\n            query=probe_vec,\n            using=vec_name_expect,\n            query_filter=flt,\n            limit=3,\n            with_payload=True,\n        )\n        res2 = getattr(qp2, \"points\", qp2) or []\n        # If results exist, ensure payload has kind/symbol keys\n        if res2:\n            md: Dict[str, Any] = (res2[0].payload or {}).get(\"metadata\") or {}\n            assert_true(\n                \"kind\" in md and \"symbol\" in md,\n                \"payload includes metadata.kind and metadata.symbol\",\n            )\n        else:\n            print(\"[OK] Filtered query ran (no results is acceptable depending on data)\")\n\n        print(f\"[OK] Collection {collection_name} health check passed\")\n\n    print(f\"[OK] All {len(collections)} collections passed health check\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}