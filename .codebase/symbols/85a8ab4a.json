{
  "file_path": "/work/internal/agent/tools/find.go",
  "file_hash": "10d0f4cd7ae47e4e4158d89ccea29c6b42deeb4a",
  "updated_at": "2025-12-26T17:34:21.328193",
  "symbols": {
    "struct_FindParams_24": {
      "name": "FindParams",
      "type": "struct",
      "start_line": 24,
      "end_line": 31,
      "content_hash": "39b2ce9f72e09f4398bf7426f5a13076fd89c9ba",
      "content": "type FindParams struct {\n\tPattern    string `json:\"pattern,omitempty\" description:\"Filename pattern to search for (supports glob patterns like *.go)\"`\n\tPath       string `json:\"path,omitempty\" description:\"The directory to search in. Defaults to current working directory.\"`\n\tType       string `json:\"type,omitempty\" description:\"Type of file to find: 'f' for files, 'd' for directories, empty for both\"`\n\tContains   string `json:\"contains,omitempty\" description:\"Text content to search for within files (slower search)\"`\n\tMaxResults int    `json:\"max_results,omitempty\" description:\"Maximum number of results to return (default: 100)\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FindPermissionsParams_32": {
      "name": "FindPermissionsParams",
      "type": "struct",
      "start_line": 32,
      "end_line": 39,
      "content_hash": "93fd8ef658f2bfd621052620f8974fdf840cad8a",
      "content": "type FindPermissionsParams struct {\n\tPattern    string\n\tPath       string\n\tType       string\n\tContains   string\n\tMaxResults int\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FindResult_40": {
      "name": "FindResult",
      "type": "struct",
      "start_line": 40,
      "end_line": 46,
      "content_hash": "4067f617b7d4c10d6ee9c4eed0c320b88aeb28e6",
      "content": "type FindResult struct {\n\tPath     string `json:\"path\"`\n\tType     string `json:\"type\"`\n\tSize     int64  `json:\"size,omitempty\"`\n\tModified string `json:\"modified,omitempty\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FindResponseMetadata_47": {
      "name": "FindResponseMetadata",
      "type": "struct",
      "start_line": 47,
      "end_line": 52,
      "content_hash": "25b631073f1af5fb8aeb7a7df2a4bd6f1d42da21",
      "content": "type FindResponseMetadata struct {\n\tNumberOfResults int    `json:\"number_of_results\"`\n\tTruncated       bool   `json:\"truncated\"`\n\tToolUsed        string `json:\"tool_used\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewFindTool_53": {
      "name": "NewFindTool",
      "type": "function",
      "start_line": 53,
      "end_line": 131,
      "content_hash": "dcb9b90a7149b66b3da002bd3d36434d8d1becff",
      "content": "func NewFindTool(permissions permission.Service, workingDir string) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tFindToolName,\n\t\tstring(findDescription),\n\t\tfunc(ctx context.Context, params FindParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\t// Set defaults\n\t\t\tif params.MaxResults <= 0 || params.MaxResults > 1000 {\n\t\t\t\tparams.MaxResults = 100\n\t\t\t}\n\n\t\t\tsearchPath := params.Path\n\t\t\tif searchPath == \"\" {\n\t\t\t\tsearchPath = workingDir\n\t\t\t}\n\t\t\tabsPath, err := filepath.Abs(searchPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"invalid path: %v\", err)), nil\n\t\t\t}\n\n\t\t\t// Permission checking - currently handled at higher level by the agent framework\n\t\t\t// Future enhancement: Add explicit permission validation for security-sensitive paths\n\t\t\t// This could include:\n\t\t\t// - Checking file system permissions before search\n\t\t\t// - Validating path doesn't access system-critical directories\n\t\t\t// - Implementing user denylist patterns for sensitive locations\n\n\t\t\t// Perform the search\n\t\t\tresults, toolUsed, err := findFiles(ctx, params, absPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"search failed: %v\", err)), nil\n\t\t\t}\n\n\t\t\t// Format output\n\t\t\tif len(results) == 0 {\n\t\t\t\treturn fantasy.WithResponseMetadata(\n\t\t\t\t\tfantasy.NewTextResponse(\"No matching files found\"),\n\t\t\t\t\tFindResponseMetadata{\n\t\t\t\t\t\tNumberOfResults: 0,\n\t\t\t\t\t\tTruncated:       false,\n\t\t\t\t\t\tToolUsed:        toolUsed,\n\t\t\t\t\t},\n\t\t\t\t), nil\n\t\t\t}\n\n\t\t\tvar output strings.Builder\n\t\t\tfmt.Fprintf(&output, \"Found %d matching item(s):\\n\\n\", len(results))\n\n\t\t\tfor _, result := range results {\n\t\t\t\ticon := \"\ud83d\udcc4\"\n\t\t\t\tif result.Type == \"d\" {\n\t\t\t\t\ticon = \"\ud83d\udcc1\"\n\t\t\t\t}\n\t\t\t\tfmt.Fprintf(&output, \"%s %s\", icon, result.Path)\n\t\t\t\tif result.Type == \"f\" {\n\t\t\t\t\tfmt.Fprintf(&output, \" (%d bytes)\", result.Size)\n\t\t\t\t}\n\t\t\t\tif result.Modified != \"\" {\n\t\t\t\t\tfmt.Fprintf(&output, \" [modified: %s]\", result.Modified)\n\t\t\t\t}\n\t\t\t\toutput.WriteString(\"\\n\")\n\t\t\t}\n\n\t\t\ttruncated := len(results) >= params.MaxResults\n\t\t\tif truncated {\n\t\t\t\toutput.WriteString(fmt.Sprintf(\"\\n(Results truncated at %d items. Use max_results parameter to see more.)\", params.MaxResults))\n\t\t\t}\n\n\t\t\treturn fantasy.WithResponseMetadata(\n\t\t\t\tfantasy.NewTextResponse(output.String()),\n\t\t\t\tFindResponseMetadata{\n\t\t\t\t\tNumberOfResults: len(results),\n\t\t\t\t\tTruncated:       truncated,\n\t\t\t\t\tToolUsed:        toolUsed,\n\t\t\t\t},\n\t\t\t), nil\n\t\t},\n\t)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findFiles_132": {
      "name": "findFiles",
      "type": "function",
      "start_line": 132,
      "end_line": 152,
      "content_hash": "5139116a3f7024df1d43561dcf79eaa04463a08f",
      "content": "func findFiles(ctx context.Context, params FindParams, searchPath string) ([]FindResult, string, error) {\n\t// Try fd first if no content search is needed\n\tif params.Contains == \"\" {\n\t\tif results, err := findWithFD(ctx, params, searchPath); err == nil {\n\t\t\treturn results, \"fd\", nil\n\t\t}\n\t}\n\n\t// Fallback to ripgrep for pattern/content search\n\tif results, err := findWithRipGrep(ctx, params, searchPath); err == nil {\n\t\treturn results, \"ripgrep\", nil\n\t}\n\n\t// Final fallback to simple directory listing\n\tif results, err := findSimple(ctx, params, searchPath); err == nil {\n\t\treturn results, \"simple\", nil\n\t}\n\n\treturn nil, \"none\", fmt.Errorf(\"all search methods failed\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findWithFD_153": {
      "name": "findWithFD",
      "type": "function",
      "start_line": 153,
      "end_line": 232,
      "content_hash": "f5efe363227969e47a354fb8da6d65dfe20b3615",
      "content": "func findWithFD(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) {\n\tfdCmd := getFDCmd(ctx)\n\tif fdCmd == nil {\n\t\treturn nil, fmt.Errorf(\"fd not available\")\n\t}\n\n\tfdCmd.Dir = searchPath\n\n\t// Build fd arguments\n\targs := []string{\"--absolute-path\", \"--color=never\"}\n\n\tif params.Type == \"f\" {\n\t\targs = append(args, \"--type\", \"file\")\n\t} else if params.Type == \"d\" {\n\t\targs = append(args, \"--type\", \"directory\")\n\t}\n\n\tif params.Pattern != \"\" {\n\t\targs = append(args, params.Pattern)\n\t}\n\n\t// Limit results\n\targs = append(args, \"--max-results\", fmt.Sprintf(\"%d\", params.MaxResults))\n\n\tfdCmd.Args = args\n\n\t// Execute with timeout\n\toutput, err := fdCmd.Output()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fd command failed: %w\", err)\n\t}\n\n\tlines := strings.Split(strings.TrimSpace(string(output)), \"\\n\")\n\tresults := make([]FindResult, 0, len(lines))\n\n\tfor _, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tinfo, err := filepath.Abs(line)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileInfo, err := os.Stat(info)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\ttyp := \"f\"\n\t\tif fileInfo.IsDir() {\n\t\t\ttyp = \"d\"\n\t\t}\n\n\t\tresult := FindResult{\n\t\t\tPath: info,\n\t\t\tType: typ,\n\t\t\tSize: fileInfo.Size(),\n\t\t}\n\n\t\tif !fileInfo.IsDir() {\n\t\t\tresult.Modified = fileInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n\t\t}\n\n\t\tresults = append(results, result)\n\t}\n\n\t// Sort by type (directories first) then by name\n\tsort.Slice(results, func(i, j int) bool {\n\t\tif results[i].Type != results[j].Type {\n\t\t\treturn results[i].Type > results[j].Type // directories (d) > files (f)\n\t\t}\n\t\treturn results[i].Path < results[j].Path\n\t})\n\n\treturn results, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findWithRipGrep_233": {
      "name": "findWithRipGrep",
      "type": "function",
      "start_line": 233,
      "end_line": 320,
      "content_hash": "aeb72de2b227febe36555b595e5e371f73539b0e",
      "content": "func findWithRipGrep(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) {\n\t// Build ripgrep command for pattern matching\n\tif params.Pattern == \"\" && params.Contains == \"\" {\n\t\treturn nil, fmt.Errorf(\"no pattern or content specified for ripgrep search\")\n\t}\n\n\tpattern := params.Pattern\n\tif params.Contains != \"\" {\n\t\tpattern = params.Contains\n\t}\n\n\trgCmd := getRgSearchCmd(ctx, pattern, searchPath, \"\")\n\tif rgCmd == nil {\n\t\treturn nil, fmt.Errorf(\"ripgrep not available\")\n\t}\n\n\t// Configure ripgrep settings\n\trgCmd.Args = append(rgCmd.Args,\n\t\t\"--absolute-path\",\n\t\t\"--no-heading\",\n\t\t\"--with-filename\",\n\t\t\"--line-number\",\n\t\t\"--max-count\", \"1\", // Only one line per file for speed\n\t)\n\n\tif params.Type == \"f\" {\n\t\trgCmd.Args = append(rgCmd.Args, \"--type\", \"file\")\n\t} else if params.Type == \"d\" {\n\t\t// Ripgrep doesn't search directories, so skip\n\t\treturn []FindResult{}, nil\n\t}\n\n\t// Execute with timeout\n\toutput, err := rgCmd.Output()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ripgrep command failed: %w\", err)\n\t}\n\n\t// Parse output - we only need file paths\n\tseen := make(map[string]bool)\n\tresults := make([]FindResult, 0, params.MaxResults)\n\n\tlines := strings.Split(strings.TrimSpace(string(output)), \"\\n\")\n\tfor _, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Extract path from ripgrep output (format: filename:line:content)\n\t\tparts := strings.SplitN(line, \":\", 3)\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilePath := parts[0]\n\t\tif _, exists := seen[filePath]; exists {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[filePath] = true\n\t\tabsPath, err := filepath.Abs(filePath)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileInfo, err := os.Stat(absPath)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := FindResult{\n\t\t\tPath:     absPath,\n\t\t\tType:     \"f\",\n\t\t\tSize:     fileInfo.Size(),\n\t\t\tModified: fileInfo.ModTime().Format(\"2006-01-02 15:04:05\"),\n\t\t}\n\n\t\tresults = append(results, result)\n\n\t\tif len(results) >= params.MaxResults {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn results, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findSimple_321": {
      "name": "findSimple",
      "type": "function",
      "start_line": 321,
      "end_line": 368,
      "content_hash": "0bd45919eb033dc9397bd957b7773649b8278632",
      "content": "func findSimple(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) {\n\t// Simple directory listing as fallback\n\tfiles, _, err := fsext.ListDirectory(searchPath, nil, 0, params.MaxResults)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresults := make([]FindResult, 0, len(files))\n\n\tfor _, file := range files {\n\t\tabsPath, err := filepath.Abs(file)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileInfo, err := os.Stat(absPath)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\ttyp := \"f\"\n\t\tif fileInfo.IsDir() {\n\t\t\ttyp = \"d\"\n\t\t}\n\n\t\t// Apply pattern filter if specified\n\t\tif params.Pattern != \"\" {\n\t\t\tmatched, err := filepath.Match(params.Pattern, filepath.Base(file))\n\t\t\tif err != nil || !matched {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tresult := FindResult{\n\t\t\tPath: file,\n\t\t\tType: typ,\n\t\t\tSize: fileInfo.Size(),\n\t\t}\n\n\t\tif !fileInfo.IsDir() {\n\t\t\tresult.Modified = fileInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n\t\t}\n\n\t\tresults = append(results, result)\n\t}\n\n\treturn results, nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}