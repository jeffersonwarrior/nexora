{
  "file_path": "/work/internal/indexer/graph.go",
  "file_hash": "94d71e358d17586227d7cd3d44c269c8b57cd14e",
  "updated_at": "2025-12-26T17:34:23.613106",
  "symbols": {
    "struct_Graph_14": {
      "name": "Graph",
      "type": "struct",
      "start_line": 14,
      "end_line": 22,
      "content_hash": "829ed6a8270cef59140aebbe47922b65f25e6742",
      "content": "type Graph struct {\n\tNodes       map[string]*GraphNode   `json:\"nodes\"`\n\tEdges       map[string][]*GraphEdge `json:\"edges\"`\n\tCallGraph   map[string][]string     `json:\"call_graph\"` // simple representation: node -> list of callers\n\tMutex       sync.RWMutex            `json:\"-\"`          // protects concurrent access\n\tNodeMetrics map[string]NodeMetrics  `json:\"node_metrics\"`\n}\n\n// NodeMetrics represents computed metrics for graph nodes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NodeMetrics_23": {
      "name": "NodeMetrics",
      "type": "struct",
      "start_line": 23,
      "end_line": 30,
      "content_hash": "85877ead06851683eca9fafd22ff0e870e261ed7",
      "content": "type NodeMetrics struct {\n\tDegree       int       `json:\"degree\"`\n\tInDegree     int       `json:\"in_degree\"`\n\tOutDegree    int       `json:\"out_degree\"`\n\tLastModified time.Time `json:\"last_modified\"`\n}\n\n// GraphNode represents a node in the graph (a symbol)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GraphNode_31": {
      "name": "GraphNode",
      "type": "struct",
      "start_line": 31,
      "end_line": 43,
      "content_hash": "a6b3976246ba6ec5ed6536f383714d93da3f2b80",
      "content": "type GraphNode struct {\n\tID         string  `json:\"id\"`\n\tSymbol     *Symbol `json:\"symbol\"`\n\tNodeType   string  `json:\"node_type\"` // \"function\", \"struct\", \"interface\", \"variable\"\n\tPackage    string  `json:\"package\"`\n\tFile       string  `json:\"file\"`\n\tLineNumber int     `json:\"line_number\"`\n\tCallCount  int     `json:\"call_count\"` // how many functions this calls\n\tCalledBy   int     `json:\"called_by\"`  // how many functions call this\n\tCyclomatic int     `json:\"cyclomatic\"` // cyclomatic complexity\n}\n\n// GraphEdge represents a relationship between nodes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GraphEdge_44": {
      "name": "GraphEdge",
      "type": "struct",
      "start_line": 44,
      "end_line": 53,
      "content_hash": "e30c70215314a106d4dfac286f8b47f98c42f227",
      "content": "type GraphEdge struct {\n\tID       string `json:\"id\"`\n\tFrom     string `json:\"from\"`\n\tTo       string `json:\"to\"`\n\tType     string `json:\"type\"`     // \"calls\", \"implements\", \"embeds\", \"references\", \"depends_on\"\n\tWeight   int    `json:\"weight\"`   // strength of relationship\n\tLocation string `json:\"location\"` // file:line where this relationship occurs\n}\n\n// uniqueKeys returns the keys of a map as a slice",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_uniqueKeys_54": {
      "name": "uniqueKeys",
      "type": "function",
      "start_line": 54,
      "end_line": 62,
      "content_hash": "9f91c10967df381ad9d90ed4b7aab4484ccd1653",
      "content": "func uniqueKeys(m map[string]bool) []string {\n\tkeys := make([]string, 0, len(m))\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n// GraphBuilder constructs call graphs and dependency graphs from symbols",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GraphBuilder_63": {
      "name": "GraphBuilder",
      "type": "struct",
      "start_line": 63,
      "end_line": 68,
      "content_hash": "2f97d31c566066cab78b25d4d73b4b7863787d88",
      "content": "type GraphBuilder struct {\n\tfs      *token.FileSet\n\tsymbols map[string]*Symbol\n}\n\n// NewGraphBuilder creates a new GraphBuilder",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewGraphBuilder_69": {
      "name": "NewGraphBuilder",
      "type": "function",
      "start_line": 69,
      "end_line": 76,
      "content_hash": "516e5b5a823ab65413a7a6e5ccc3f954e4cdfc12",
      "content": "func NewGraphBuilder() *GraphBuilder {\n\treturn &GraphBuilder{\n\t\tfs:      token.NewFileSet(),\n\t\tsymbols: make(map[string]*Symbol),\n\t}\n}\n\n// BuildGraph constructs a graph from a map of symbols",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_BuildGraph_77": {
      "name": "BuildGraph",
      "type": "method",
      "start_line": 77,
      "end_line": 136,
      "content_hash": "0117f7038506af42de8c3c456bd36e47d7a6bbfe",
      "content": "func (gb *GraphBuilder) BuildGraph(ctx context.Context, symbols map[string]*Symbol) (*Graph, error) {\n\t// Store symbols for use in resolveFunctionCall\n\tgb.symbols = symbols\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\tgraph := &Graph{\n\t\tNodes:       make(map[string]*GraphNode),\n\t\tEdges:       make(map[string][]*GraphEdge),\n\t\tCallGraph:   make(map[string][]string),\n\t\tNodeMetrics: make(map[string]NodeMetrics),\n\t}\n\n\t// First pass: create nodes for all symbols\n\tfor id, symbol := range symbols {\n\t\tnode := &GraphNode{\n\t\t\tID:         id,\n\t\t\tSymbol:     symbol,\n\t\t\tNodeType:   symbol.Type,\n\t\t\tPackage:    symbol.Package,\n\t\t\tFile:       symbol.File,\n\t\t\tLineNumber: symbol.Line,\n\t\t}\n\n\t\t// Calculate cyclomatic complexity for functions\n\t\tif symbol.Type == \"func\" {\n\t\t\tnode.Cyclomatic = gb.calculateCyclomaticComplexity(symbol)\n\t\t}\n\n\t\tgraph.Nodes[id] = node\n\t}\n\n\t// Second pass: analyze relationships and create edges\n\tfor id, symbol := range symbols {\n\t\t// Build call relationships\n\t\tif symbol.Type == \"function\" || symbol.Type == \"method\" {\n\t\t\tgb.buildCallRelationships(graph, id, symbol)\n\t\t}\n\n\t\t// Build structural relationships\n\t\tgb.buildStructuralRelationships(graph, id, symbol)\n\n\t\t// Build import relationships\n\t\tgb.buildImportRelationships(graph, id, symbol)\n\t}\n\n\t// Build the simplified call graph\n\tgb.buildCallGraph(graph)\n\n\t// Calculate metrics\n\tgb.calculateNodeMetrics(graph)\n\n\treturn graph, nil\n}\n\n// buildCallRelationships creates edges for function calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildCallRelationships_137": {
      "name": "buildCallRelationships",
      "type": "method",
      "start_line": 137,
      "end_line": 169,
      "content_hash": "041cff320ca7c8ef7953d90d900f44581a069f80",
      "content": "func (gb *GraphBuilder) buildCallRelationships(graph *Graph, callerID string, symbol *Symbol) {\n\tfor _, call := range symbol.Calls {\n\t\t// Try to resolve the called function\n\t\tcalleeID := gb.resolveFunctionCall(call)\n\t\tif calleeID == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if both nodes exist\n\t\tcallerNode, callerExists := graph.Nodes[callerID]\n\t\tcalleeNode, calleeExists := graph.Nodes[calleeID]\n\n\t\tif !callerExists || !calleeExists {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create edge\n\t\tedge := &GraphEdge{\n\t\t\tID:       fmt.Sprintf(\"%s->%s\", callerID, calleeID),\n\t\t\tFrom:     callerID,\n\t\t\tTo:       calleeID,\n\t\t\tType:     \"calls\",\n\t\t\tWeight:   1, // Can be enhanced with call frequency\n\t\t\tLocation: fmt.Sprintf(\"%s:%d\", symbol.File, 0),\n\t\t}\n\n\t\tgraph.Edges[callerID] = append(graph.Edges[callerID], edge)\n\t\tcallerNode.CallCount++\n\t\tcalleeNode.CalledBy++\n\t}\n}\n\n// buildStructuralRelationships creates edges for struct/interface relationships",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildStructuralRelationships_170": {
      "name": "buildStructuralRelationships",
      "type": "method",
      "start_line": 170,
      "end_line": 183,
      "content_hash": "d1b9b70d40b5bdf8e959f6d89cc526594b9cdc75",
      "content": "func (gb *GraphBuilder) buildStructuralRelationships(graph *Graph, id string, symbol *Symbol) {\n\tstructType := strings.TrimPrefix(symbol.Type, \"struct \")\n\n\tswitch structType {\n\tcase \"struct\":\n\t\t// Handle embedded fields\n\t\tgb.buildEmbeddingRelationships(graph, id, symbol)\n\tcase \"interface\":\n\t\t// Handle method implementations\n\t\tgb.buildImplementationRelationships(graph, id, symbol)\n\t}\n}\n\n// buildEmbeddingRelationships handles struct embedding",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildEmbeddingRelationships_184": {
      "name": "buildEmbeddingRelationships",
      "type": "method",
      "start_line": 184,
      "end_line": 227,
      "content_hash": "6da458f2e0f0c26518c19924e4057dadd73ca19b",
      "content": "func (gb *GraphBuilder) buildEmbeddingRelationships(graph *Graph, id string, symbol *Symbol) {\n\tif symbol.Signature == \"\" {\n\t\treturn\n\t}\n\n\t// Parse embedded fields from signature (simplified approach)\n\tsignature := symbol.Signature\n\tfields := strings.Split(signature, \";\")\n\n\tfor _, field := range fields {\n\t\tfield = strings.TrimSpace(field)\n\t\tif strings.Contains(field, \"embedded:\") {\n\t\t\t// Extract embedded type\n\t\t\tparts := strings.Split(field, \"embedded:\")\n\t\t\tif len(parts) < 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tembeddedType := strings.TrimSpace(parts[1])\n\n\t\t\t// Try to resolve embedded type\n\t\t\tembeddedID := gb.resolveType(embeddedType, symbol.Package)\n\t\t\tif embeddedID == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif _, exists := graph.Nodes[embeddedID]; !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tedge := &GraphEdge{\n\t\t\t\tID:       fmt.Sprintf(\"%s->%s\", id, embeddedID),\n\t\t\t\tFrom:     id,\n\t\t\t\tTo:       embeddedID,\n\t\t\t\tType:     \"embeds\",\n\t\t\t\tWeight:   2, // Structural relationship\n\t\t\t\tLocation: fmt.Sprintf(\"%s:%d\", symbol.File, symbol.Line),\n\t\t\t}\n\n\t\t\tgraph.Edges[id] = append(graph.Edges[id], edge)\n\t\t}\n\t}\n}\n\n// buildImplementationRelationships handles interface implementation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildImplementationRelationships_228": {
      "name": "buildImplementationRelationships",
      "type": "method",
      "start_line": 228,
      "end_line": 254,
      "content_hash": "cdf53f2ffefc6e4b497842df4a4a0c12404a9bcc",
      "content": "func (gb *GraphBuilder) buildImplementationRelationships(graph *Graph, id string, symbol *Symbol) {\n\tif symbol.Signature == \"\" {\n\t\treturn\n\t}\n\n\t// Find structs that implement this interface\n\tfor nodeID, node := range graph.Nodes {\n\t\tif node.NodeType != \"struct\" || nodeID == id {\n\t\t\tcontinue\n\t\t}\n\n\t\tif gb.structImplementsInterface(node.Symbol, symbol) {\n\t\t\tedge := &GraphEdge{\n\t\t\t\tID:       fmt.Sprintf(\"%s->%s\", nodeID, id),\n\t\t\t\tFrom:     nodeID,\n\t\t\t\tTo:       id,\n\t\t\t\tType:     \"implements\",\n\t\t\t\tWeight:   3, // Interface implementation is strong relationship\n\t\t\t\tLocation: node.File,\n\t\t\t}\n\n\t\t\tgraph.Edges[nodeID] = append(graph.Edges[nodeID], edge)\n\t\t}\n\t}\n}\n\n// buildImportRelationships handles package dependencies",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildImportRelationships_255": {
      "name": "buildImportRelationships",
      "type": "method",
      "start_line": 255,
      "end_line": 279,
      "content_hash": "979dfc7ac1d9e7dc7e41c9706bc201f50fca3fe2",
      "content": "func (gb *GraphBuilder) buildImportRelationships(graph *Graph, id string, symbol *Symbol) {\n\tfor _, pkg := range symbol.Imports {\n\t\t// Create relationship to package symbols\n\t\tfor nodeID, node := range graph.Nodes {\n\t\t\tif nodeID == id {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(node.Package, pkg) {\n\t\t\t\tedge := &GraphEdge{\n\t\t\t\t\tID:       fmt.Sprintf(\"%s->%s\", id, nodeID),\n\t\t\t\t\tFrom:     id,\n\t\t\t\t\tTo:       nodeID,\n\t\t\t\t\tType:     \"depends_on\",\n\t\t\t\t\tWeight:   1, // Import dependency\n\t\t\t\t\tLocation: symbol.File,\n\t\t\t\t}\n\n\t\t\t\tgraph.Edges[id] = append(graph.Edges[id], edge)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// buildCallGraph creates a simplified call graph representation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildCallGraph_280": {
      "name": "buildCallGraph",
      "type": "method",
      "start_line": 280,
      "end_line": 298,
      "content_hash": "4b85ea89958740267994730e1642ece65a09ab82",
      "content": "func (gb *GraphBuilder) buildCallGraph(graph *Graph) {\n\tgraph.Mutex.Lock()\n\tdefer graph.Mutex.Unlock()\n\n\t// Initialize CallGraph if nil\n\tif graph.CallGraph == nil {\n\t\tgraph.CallGraph = make(map[string][]string)\n\t}\n\n\tfor fromID, edges := range graph.Edges {\n\t\tfor _, edge := range edges {\n\t\t\tif edge.Type == \"calls\" {\n\t\t\t\tgraph.CallGraph[fromID] = append(graph.CallGraph[fromID], edge.To)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// calculateNodeMetrics computes various metrics for graph nodes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateNodeMetrics_299": {
      "name": "calculateNodeMetrics",
      "type": "method",
      "start_line": 299,
      "end_line": 332,
      "content_hash": "479a9bbe13c033bd88ced4ee3bf0da14f57ce8a8",
      "content": "func (gb *GraphBuilder) calculateNodeMetrics(graph *Graph) {\n\tgraph.Mutex.RLock()\n\tdefer graph.Mutex.RUnlock()\n\n\t// Calculate degree centrality (sum of incoming and outgoing edges)\n\tfor nodeID := range graph.Nodes {\n\t\tmetrics := NodeMetrics{\n\t\t\tDegree:       0,\n\t\t\tInDegree:     0,\n\t\t\tOutDegree:    0,\n\t\t\tLastModified: time.Now(),\n\t\t}\n\n\t\t// Count outgoing edges\n\t\tif edges, exists := graph.Edges[nodeID]; exists {\n\t\t\tmetrics.OutDegree = len(edges)\n\t\t\tmetrics.Degree += len(edges)\n\t\t}\n\n\t\t// Count incoming edges\n\t\tfor _, edges := range graph.Edges {\n\t\t\tfor _, edge := range edges {\n\t\t\t\tif edge.To == nodeID {\n\t\t\t\t\tmetrics.InDegree++\n\t\t\t\t\tmetrics.Degree++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgraph.NodeMetrics[nodeID] = metrics\n\t}\n}\n\n// resolveFunctionCall attempts to resolve a function call to a symbol ID",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_resolveFunctionCall_333": {
      "name": "resolveFunctionCall",
      "type": "method",
      "start_line": 333,
      "end_line": 368,
      "content_hash": "81adab58b55f9ec193ac8da9034b93576754307d",
      "content": "func (gb *GraphBuilder) resolveFunctionCall(callName string) string {\n\t// This is a simplified resolver - in practice, this would be more sophisticated\n\t// using type information and package resolution\n\n\tif gb.symbols == nil {\n\t\treturn \"\"\n\t}\n\n\t// Clean the call name\n\tname := strings.TrimSpace(callName)\n\tif name == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// Try exact match first - return the map key (ID) when symbol name matches\n\tfor id, symbol := range gb.symbols {\n\t\tif symbol.Name == name {\n\t\t\treturn id\n\t\t}\n\t}\n\n\t// Try to match qualified names (e.g., \"pkg.Func\")\n\tparts := strings.Split(name, \".\")\n\tif len(parts) > 1 {\n\t\tfor id, symbol := range gb.symbols {\n\t\t\tif strings.HasSuffix(symbol.Name, \".\"+parts[len(parts)-1]) {\n\t\t\t\treturn id\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return empty string if no match found\n\treturn \"\"\n}\n\n// resolveType attempts to resolve a type name to a symbol ID",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_resolveType_369": {
      "name": "resolveType",
      "type": "method",
      "start_line": 369,
      "end_line": 378,
      "content_hash": "f05e6433c350e825573d66669e788bf728f36d7f",
      "content": "func (gb *GraphBuilder) resolveType(typeName, currentPackage string) string {\n\t// Strip package qualifier if present\n\tif idx := strings.LastIndex(typeName, \".\"); idx != -1 {\n\t\ttypeName = typeName[idx+1:]\n\t}\n\n\treturn typeName\n}\n\n// structImplementsInterface checks if a struct implements an interface",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_structImplementsInterface_379": {
      "name": "structImplementsInterface",
      "type": "method",
      "start_line": 379,
      "end_line": 401,
      "content_hash": "a9cb80f4d4084c3f36faf1c2c4784056a0de7d4c",
      "content": "func (gb *GraphBuilder) structImplementsInterface(structSymbol, interfaceSymbol *Symbol) bool {\n\t// Simplified implementation - checks for method name overlap\n\t// In practice, this would use type information to check actual method signatures\n\n\tif structSymbol.Type != \"struct\" || interfaceSymbol.Type != \"interface\" {\n\t\treturn false\n\t}\n\n\t// Extract method names from struct signature\n\tstructMethods := gb.extractMethods(structSymbol.Signature)\n\tinterfaceMethods := gb.extractMethods(interfaceSymbol.Signature)\n\n\t// Check if all interface methods are present in struct\n\tfor intMethod := range interfaceMethods {\n\t\tif _, found := structMethods[intMethod]; !found {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// extractMethods extracts method names from a signature",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractMethods_402": {
      "name": "extractMethods",
      "type": "method",
      "start_line": 402,
      "end_line": 427,
      "content_hash": "21b61d02ad68de13772b26caf40351dcddc23919",
      "content": "func (gb *GraphBuilder) extractMethods(signature string) map[string]bool {\n\tmethods := make(map[string]bool)\n\n\t// This is a very simplified parser\n\t// In practice, this would properly parse the Go AST from the signature\n\tlines := strings.Split(signature, \"\\n\")\n\tfor _, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif strings.HasPrefix(line, \"func \") {\n\t\t\t// Extract method name\n\t\t\tparts := strings.Fields(line)\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tmethodName := parts[2]\n\t\t\t\t// Remove parenthesis from receiver methods\n\t\t\t\tif idx := strings.Index(methodName, \"(\"); idx != -1 {\n\t\t\t\t\tmethodName = strings.TrimSpace(methodName[:idx])\n\t\t\t\t}\n\t\t\t\tmethods[methodName] = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn methods\n}\n\n// calculateCyclomaticComplexity calculates cyclomatic complexity of a function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateCyclomaticComplexity_428": {
      "name": "calculateCyclomaticComplexity",
      "type": "method",
      "start_line": 428,
      "end_line": 448,
      "content_hash": "992a21a2131e5d6d91e58671d474cf5abc01ee25",
      "content": "func (gb *GraphBuilder) calculateCyclomaticComplexity(symbol *Symbol) int {\n\t// Simplified complexity calculation from signature\n\t// In practice, this would parse the function body\n\n\tcomplexity := 1 // Base complexity\n\n\tsignature := symbol.Signature\n\n\t// Count potential complexity indicators\n\tcomplexity += strings.Count(signature, \"if\") * 1\n\tcomplexity += strings.Count(signature, \"for\") * 1\n\tcomplexity += strings.Count(signature, \"range\") * 1\n\tcomplexity += strings.Count(signature, \"switch\") * 1\n\tcomplexity += strings.Count(signature, \"select\") * 1\n\tcomplexity += strings.Count(signature, \"&&\") * 1 // Rough approximation\n\tcomplexity += strings.Count(signature, \"||\") * 1 // Rough approximation\n\n\treturn int(complexity)\n}\n\n// FindCallers returns all functions that call the given function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindCallers_449": {
      "name": "FindCallers",
      "type": "method",
      "start_line": 449,
      "end_line": 464,
      "content_hash": "d30dd7826e7e4af97f49673afff2158a75a9794c",
      "content": "func (g *Graph) FindCallers(symbolID string) []string {\n\tvar callers []string\n\n\tfor callerID, callees := range g.CallGraph {\n\t\tfor _, callee := range callees {\n\t\t\tif callee == symbolID {\n\t\t\t\tcallers = append(callers, callerID)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn callers\n}\n\n// FindCallees returns all functions called by the given function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindCallees_465": {
      "name": "FindCallees",
      "type": "method",
      "start_line": 465,
      "end_line": 469,
      "content_hash": "9ed752795063f22cecad4f68e60f0b48f982b404",
      "content": "func (g *Graph) FindCallees(symbolID string) []string {\n\treturn g.CallGraph[symbolID]\n}\n\n// GetUpstreamDependencies returns all symbols that this symbol depends on",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetUpstreamDependencies_470": {
      "name": "GetUpstreamDependencies",
      "type": "method",
      "start_line": 470,
      "end_line": 488,
      "content_hash": "d060a2c9584d2876e6a7a728b5104beaaf51b2fb",
      "content": "func (g *Graph) GetUpstreamDependencies(symbolID string) []string {\n\tvar deps []string\n\n\tif edges, exists := g.Edges[symbolID]; exists {\n\t\tfor _, edge := range edges {\n\t\t\tdeps = append(deps, edge.To)\n\t\t}\n\t}\n\n\t// Remove duplicates\n\tunique := make(map[string]bool)\n\tfor _, dep := range deps {\n\t\tunique[dep] = true\n\t}\n\n\treturn uniqueKeys(unique)\n}\n\n// GetDownstreamDependencies returns all symbols that depend on this symbol",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetDownstreamDependencies_489": {
      "name": "GetDownstreamDependencies",
      "type": "method",
      "start_line": 489,
      "end_line": 504,
      "content_hash": "cc5989956baa561cc26cf45a1f534854fb11081f",
      "content": "func (g *Graph) GetDownstreamDependencies(symbolID string) []string {\n\tvar downstream []string\n\n\tfor sourceID, edges := range g.Edges {\n\t\tfor _, edge := range edges {\n\t\t\tif edge.To == symbolID {\n\t\t\t\tdownstream = append(downstream, sourceID)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn downstream\n}\n\n// GetImpactAnalysis performs impact analysis for a given symbol",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetImpactAnalysis_505": {
      "name": "GetImpactAnalysis",
      "type": "method",
      "start_line": 505,
      "end_line": 533,
      "content_hash": "42bb2f9f7c1066bafc60fe58b898a5f6ac9bb3ce",
      "content": "func (g *Graph) GetImpactAnalysis(symbolID string, maxDepth int) ImpactAnalysis {\n\tdirectCalls := g.FindCallees(symbolID)\n\tif directCalls == nil {\n\t\tdirectCalls = []string{}\n\t}\n\n\tdirectCallers := g.FindCallers(symbolID)\n\tif directCallers == nil {\n\t\tdirectCallers = []string{}\n\t}\n\n\tanalysis := ImpactAnalysis{\n\t\tSymbolID:       symbolID,\n\t\tDirectCalls:    directCalls,\n\t\tDirectCallers:  directCallers,\n\t\tDownstreamDeps: g.GetDownstreamDependencies(symbolID),\n\t\tUpstreamDeps:   g.GetUpstreamDependencies(symbolID),\n\t}\n\n\t// Calculate transitive dependencies\n\tif maxDepth > 0 {\n\t\tanalysis.TransitiveDownstream = g.getTransitiveDependencies(symbolID, \"downstream\", maxDepth)\n\t\tanalysis.TransitiveUpstream = g.getTransitiveDependencies(symbolID, \"upstream\", maxDepth)\n\t}\n\n\treturn analysis\n}\n\n// getTransitiveDependencies recursively finds all dependencies up to maxDepth",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTransitiveDependencies_534": {
      "name": "getTransitiveDependencies",
      "type": "method",
      "start_line": 534,
      "end_line": 569,
      "content_hash": "129b9712b36be27df1d4f20cb284ee1b1b89c78f",
      "content": "func (g *Graph) getTransitiveDependencies(symbolID, direction string, maxDepth int) []string {\n\tvisited := make(map[string]bool)\n\tvar result []string\n\n\tvar traverse func(currentID string, depth int)\n\n\ttraverse = func(currentID string, depth int) {\n\t\tif depth <= 0 {\n\t\t\treturn\n\t\t}\n\n\t\tvar next []string\n\t\tif direction == \"downstream\" {\n\t\t\tnext = g.GetDownstreamDependencies(currentID)\n\t\t} else {\n\t\t\tnext = g.GetUpstreamDependencies(currentID)\n\t\t}\n\n\t\tfor _, nextID := range next {\n\t\t\tif !visited[nextID] && nextID != symbolID {\n\t\t\t\tvisited[nextID] = true\n\t\t\t\tresult = append(result, nextID)\n\t\t\t\ttraverse(nextID, depth-1)\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(symbolID, maxDepth)\n\n\t// Sort for consistent output\n\tsort.Strings(result)\n\n\treturn result\n}\n\n// ImpactAnalysis contains the results of an impact analysis",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ImpactAnalysis_570": {
      "name": "ImpactAnalysis",
      "type": "struct",
      "start_line": 570,
      "end_line": 580,
      "content_hash": "811267a55931ae904ad2eb6d35103f3b2d262c56",
      "content": "type ImpactAnalysis struct {\n\tSymbolID             string   `json:\"symbol_id\"`\n\tDirectCalls          []string `json:\"direct_calls\"`\n\tDirectCallers        []string `json:\"direct_callers\"`\n\tDownstreamDeps       []string `json:\"downstream_deps\"`\n\tUpstreamDeps         []string `json:\"upstream_deps\"`\n\tTransitiveDownstream []string `json:\"transitive_downstream\"`\n\tTransitiveUpstream   []string `json:\"transitive_upstream\"`\n}\n\n// GetCriticalPath finds the critical path(s) through the codebase",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetCriticalPath_581": {
      "name": "GetCriticalPath",
      "type": "method",
      "start_line": 581,
      "end_line": 584,
      "content_hash": "e4398c7e3ebf5cefd1c8e5dc6646640c4d25ad68",
      "content": "func (g *Graph) GetCriticalPath() []string {\n\t// Simple implementation: find nodes with highest combined metrics\n\tvar critical []string\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_nodeScore_585": {
      "name": "nodeScore",
      "type": "struct",
      "start_line": 585,
      "end_line": 614,
      "content_hash": "a0c7d4e3d668fbde62a8dc3f2d4d1b55c7f64a1d",
      "content": "\ttype nodeScore struct {\n\t\tid    string\n\t\tscore float64\n\t}\n\n\tvar scores []nodeScore\n\n\tfor id, node := range g.Nodes {\n\t\t// Calculate a simple score based on call counts and complexity\n\t\tscore := float64(node.CalledBy)*2 + float64(node.CallCount) + float64(node.Cyclomatic)*0.5\n\t\tscores = append(scores, nodeScore{id: id, score: score})\n\t}\n\n\t// Sort by score\n\tsort.Slice(scores, func(i, j int) bool {\n\t\treturn scores[i].score > scores[j].score\n\t})\n\n\t// Return top 10%\n\ttopCount := len(scores) / 10\n\tif topCount < 5 {\n\t\ttopCount = 5\n\t}\n\n\tfor i := 0; i < topCount && i < len(scores); i++ {\n\t\tcritical = append(critical, scores[i].id)\n\t}\n\n\treturn critical\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}