{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/test_utils.rs",
  "file_hash": "b435d8b4e7c9b3047e0a7b320947b5557d314f5b",
  "updated_at": "2025-12-26T17:34:21.836173",
  "symbols": {
    "struct_OldNode_22": {
      "name": "OldNode",
      "type": "struct",
      "start_line": 22,
      "end_line": 33,
      "content_hash": "9629d3aac712a508a72699530e0f83a83ad3e43c",
      "content": "pub struct OldNode {\n    #[serde(skip)]\n    pub id: u128,\n    pub label: String,\n    #[serde(default)]\n    pub version: u8,\n    #[serde(default)]\n    pub properties: Option<HashMap<String, Value>>,\n}\n\n/// Old Edge implementation for compatibility testing\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OldEdge_34": {
      "name": "OldEdge",
      "type": "struct",
      "start_line": 34,
      "end_line": 47,
      "content_hash": "7b50331cc0acaa0216dd384b9e5e847859701c94",
      "content": "pub struct OldEdge {\n    #[serde(skip)]\n    pub id: u128,\n    pub label: String,\n    #[serde(default)]\n    pub version: u8,\n    pub from_node: u128,\n    pub to_node: u128,\n    #[serde(default)]\n    pub properties: Option<HashMap<String, Value>>,\n}\n\n/// Old Vector implementation for compatibility testing\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OldVector_48": {
      "name": "OldVector",
      "type": "struct",
      "start_line": 48,
      "end_line": 103,
      "content_hash": "edb19c7b4124e7868cf4018496f7be3fbe788e05",
      "content": "pub struct OldVector {\n    #[serde(skip)]\n    pub id: u128,\n    pub label: String,\n    #[serde(default)]\n    pub version: u8,\n    #[serde(default)]\n    pub deleted: bool,\n    #[serde(default)]\n    pub properties: Option<HashMap<String, Value>>,\n}\n\n// ============================================================================\n// NODE FACTORY FUNCTIONS\n// ============================================================================\n\n/// Creates an arena-allocated Node with properties\npub fn create_arena_node<'arena>(\n    arena: &'arena Bump,\n    id: u128,\n    label: &str,\n    version: u8,\n    props: Vec<(&str, Value)>,\n) -> Node<'arena> {\n    let label_ref = arena.alloc_str(label);\n\n    if props.is_empty() {\n        Node {\n            id,\n            label: label_ref,\n            version,\n            properties: None,\n        }\n    } else {\n        let len = props.len();\n        let props_iter = props.into_iter().map(|(k, v)| {\n            let key: &'arena str = arena.alloc_str(k);\n            (key, v)\n        });\n        let props_map = ImmutablePropertiesMap::new(len, props_iter, arena);\n\n        Node {\n            id,\n            label: label_ref,\n            version,\n            properties: Some(props_map),\n        }\n    }\n}\n\n/// Creates a simple arena-allocated Node without properties\npub fn create_simple_node<'arena>(arena: &'arena Bump, id: u128, label: &str) -> Node<'arena> {\n    create_arena_node(arena, id, label, 0, vec![])\n}\n\n/// Creates an old-style Node for compatibility testing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_old_node_104": {
      "name": "create_old_node",
      "type": "function",
      "start_line": 104,
      "end_line": 187,
      "content_hash": "c9b12a4a1c6bd1e9b4f3d3b3d6e514f2a42e62c2",
      "content": "pub fn create_old_node(\n    id: u128,\n    label: &str,\n    version: u8,\n    props: Vec<(&str, Value)>,\n) -> OldNode {\n    if props.is_empty() {\n        OldNode {\n            id,\n            label: label.to_string(),\n            version,\n            properties: None,\n        }\n    } else {\n        let mut props_map = HashMap::new();\n        for (k, v) in props {\n            props_map.insert(k.to_string(), v);\n        }\n\n        OldNode {\n            id,\n            label: label.to_string(),\n            version,\n            properties: Some(props_map),\n        }\n    }\n}\n\n// ============================================================================\n// EDGE FACTORY FUNCTIONS\n// ============================================================================\n\n/// Creates an arena-allocated Edge with properties\npub fn create_arena_edge<'arena>(\n    arena: &'arena Bump,\n    id: u128,\n    label: &str,\n    version: u8,\n    from_node: u128,\n    to_node: u128,\n    props: Vec<(&str, Value)>,\n) -> Edge<'arena> {\n    let label_ref = arena.alloc_str(label);\n\n    if props.is_empty() {\n        Edge {\n            id,\n            label: label_ref,\n            version,\n            from_node,\n            to_node,\n            properties: None,\n        }\n    } else {\n        let len = props.len();\n        let props_iter = props.into_iter().map(|(k, v)| {\n            let key: &'arena str = arena.alloc_str(k);\n            (key, v)\n        });\n        let props_map = ImmutablePropertiesMap::new(len, props_iter, arena);\n\n        Edge {\n            id,\n            label: label_ref,\n            version,\n            from_node,\n            to_node,\n            properties: Some(props_map),\n        }\n    }\n}\n\n/// Creates a simple arena-allocated Edge without properties\npub fn create_simple_edge<'arena>(\n    arena: &'arena Bump,\n    id: u128,\n    label: &str,\n    from_node: u128,\n    to_node: u128,\n) -> Edge<'arena> {\n    create_arena_edge(arena, id, label, 0, from_node, to_node, vec![])\n}\n\n/// Creates an old-style Edge for compatibility testing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_old_edge_188": {
      "name": "create_old_edge",
      "type": "function",
      "start_line": 188,
      "end_line": 282,
      "content_hash": "2a9202ea8137415f691e6687adcdc3373942fe02",
      "content": "pub fn create_old_edge(\n    id: u128,\n    label: &str,\n    version: u8,\n    from_node: u128,\n    to_node: u128,\n    props: Vec<(&str, Value)>,\n) -> OldEdge {\n    if props.is_empty() {\n        OldEdge {\n            id,\n            label: label.to_string(),\n            version,\n            from_node,\n            to_node,\n            properties: None,\n        }\n    } else {\n        let mut props_map = HashMap::new();\n        for (k, v) in props {\n            props_map.insert(k.to_string(), v);\n        }\n\n        OldEdge {\n            id,\n            label: label.to_string(),\n            version,\n            from_node,\n            to_node,\n            properties: Some(props_map),\n        }\n    }\n}\n\n// ============================================================================\n// VECTOR FACTORY FUNCTIONS\n// ============================================================================\n\n/// Creates an arena-allocated HVector with properties\npub fn create_arena_vector<'arena>(\n    arena: &'arena Bump,\n    id: u128,\n    label: &str,\n    version: u8,\n    deleted: bool,\n    level: usize,\n    data: &[f64],\n    props: Vec<(&str, Value)>,\n) -> HVector<'arena> {\n    let label_ref = arena.alloc_str(label);\n    let data_ref = arena.alloc_slice_copy(data);\n\n    if props.is_empty() {\n        HVector {\n            id,\n            label: label_ref,\n            version,\n            deleted,\n            level,\n            distance: None,\n            data: data_ref,\n            properties: None,\n        }\n    } else {\n        let len = props.len();\n        let props_iter = props.into_iter().map(|(k, v)| {\n            let key: &'arena str = arena.alloc_str(k);\n            (key, v)\n        });\n        let props_map = ImmutablePropertiesMap::new(len, props_iter, arena);\n\n        HVector {\n            id,\n            label: label_ref,\n            version,\n            deleted,\n            level,\n            distance: None,\n            data: data_ref,\n            properties: Some(props_map),\n        }\n    }\n}\n\n/// Creates a simple arena-allocated HVector without properties\npub fn create_simple_vector<'arena>(\n    arena: &'arena Bump,\n    id: u128,\n    label: &str,\n    data: &[f64],\n) -> HVector<'arena> {\n    create_arena_vector(arena, id, label, 1, false, 0, data, vec![])\n}\n\n/// Creates vector data as raw bytes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_vector_bytes_283": {
      "name": "create_vector_bytes",
      "type": "function",
      "start_line": 283,
      "end_line": 287,
      "content_hash": "88f34eb4972d88262fcba85b06fba6bb58d0b73e",
      "content": "pub fn create_vector_bytes(data: &[f64]) -> Vec<u8> {\n    bytemuck::cast_slice(data).to_vec()\n}\n\n/// Creates an old-style Vector for compatibility testing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_old_vector_288": {
      "name": "create_old_vector",
      "type": "function",
      "start_line": 288,
      "end_line": 323,
      "content_hash": "f8d30d6ad32d48afe17181fa286a3d6ff9ab4c59",
      "content": "pub fn create_old_vector(\n    id: u128,\n    label: &str,\n    version: u8,\n    deleted: bool,\n    props: Vec<(&str, Value)>,\n) -> OldVector {\n    if props.is_empty() {\n        OldVector {\n            id,\n            label: label.to_string(),\n            version,\n            deleted,\n            properties: None,\n        }\n    } else {\n        let mut props_map = HashMap::new();\n        for (k, v) in props {\n            props_map.insert(k.to_string(), v);\n        }\n\n        OldVector {\n            id,\n            label: label.to_string(),\n            version,\n            deleted,\n            properties: Some(props_map),\n        }\n    }\n}\n\n// ============================================================================\n// PROPERTY BUILDERS\n// ============================================================================\n\n/// Creates a vector of properties with all Value types for comprehensive testing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_all_value_types_props_324": {
      "name": "all_value_types_props",
      "type": "function",
      "start_line": 324,
      "end_line": 343,
      "content_hash": "fe9f99a2e9102901057b5f47115cf6271e78182d",
      "content": "pub fn all_value_types_props() -> Vec<(&'static str, Value)> {\n    vec![\n        (\"string_val\", Value::String(\"test\".to_string())),\n        (\"f32_val\", Value::F32(3.14)),\n        (\"f64_val\", Value::F64(2.718)),\n        (\"i8_val\", Value::I8(-127)),\n        (\"i16_val\", Value::I16(-32000)),\n        (\"i32_val\", Value::I32(-2000000)),\n        (\"i64_val\", Value::I64(-9000000000)),\n        (\"u8_val\", Value::U8(255)),\n        (\"u16_val\", Value::U16(65000)),\n        (\"u32_val\", Value::U32(4000000)),\n        (\"u64_val\", Value::U64(18000000000)),\n        (\"u128_val\", Value::U128(340282366920938463463374607431768211455)),\n        (\"bool_val\", Value::Boolean(true)),\n        (\"empty_val\", Value::Empty),\n    ]\n}\n\n/// Creates nested Value structures for edge case testing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_nested_value_props_344": {
      "name": "nested_value_props",
      "type": "function",
      "start_line": 344,
      "end_line": 381,
      "content_hash": "f4df839f3bd8eb0d1dda52d3dd052142d5b0fbc6",
      "content": "pub fn nested_value_props() -> Vec<(&'static str, Value)> {\n    vec![\n        (\n            \"array_val\",\n            Value::Array(vec![\n                Value::I32(1),\n                Value::I32(2),\n                Value::I32(3),\n            ]),\n        ),\n        (\n            \"object_val\",\n            Value::Object(\n                vec![\n                    (\"nested_key\".to_string(), Value::String(\"nested_value\".to_string())),\n                    (\"nested_num\".to_string(), Value::I32(42)),\n                ]\n                .into_iter()\n                .collect(),\n            ),\n        ),\n        (\n            \"deeply_nested\",\n            Value::Array(vec![\n                Value::Object(\n                    vec![\n                        (\"inner\".to_string(), Value::Array(vec![Value::I32(1), Value::I32(2)])),\n                    ]\n                    .into_iter()\n                    .collect(),\n                ),\n            ]),\n        ),\n    ]\n}\n\n/// Creates a large number of properties for stress testing\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_many_props_382": {
      "name": "many_props",
      "type": "function",
      "start_line": 382,
      "end_line": 392,
      "content_hash": "515979ba313f35530eafa529565df87fd2c98043",
      "content": "pub fn many_props(count: usize) -> Vec<(String, Value)> {\n    (0..count)\n        .map(|i| (format!(\"key_{}\", i), Value::I32(i as i32)))\n        .collect()\n}\n\n// ============================================================================\n// ASSERTION HELPERS\n// ============================================================================\n\n/// Asserts that two nodes are semantically equal (properties may be in different order)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_assert_nodes_semantically_equal_393": {
      "name": "assert_nodes_semantically_equal",
      "type": "function",
      "start_line": 393,
      "end_line": 419,
      "content_hash": "57b2fe0ce619aa399a95a0f3b909c8bcae56c398",
      "content": "pub fn assert_nodes_semantically_equal(node1: &Node, node2: &Node) {\n    assert_eq!(node1.id, node2.id, \"Node IDs differ\");\n    assert_eq!(node1.label, node2.label, \"Node labels differ\");\n    assert_eq!(node1.version, node2.version, \"Node versions differ\");\n\n    match (&node1.properties, &node2.properties) {\n        (None, None) => {}\n        (Some(props1), Some(props2)) => {\n            assert_eq!(\n                props1.len(),\n                props2.len(),\n                \"Node property counts differ\"\n            );\n            // Check each property exists and has the same value\n            for (key1, val1) in props1.iter() {\n                if let Some(val2) = props2.get(key1) {\n                    assert_eq!(val1, val2, \"Property value differs for key: {}\", key1);\n                } else {\n                    panic!(\"Property key '{}' not found in second node\", key1);\n                }\n            }\n        }\n        _ => panic!(\"One node has properties and the other doesn't\"),\n    }\n}\n\n/// Asserts that two edges are semantically equal (properties may be in different order)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_assert_edges_semantically_equal_420": {
      "name": "assert_edges_semantically_equal",
      "type": "function",
      "start_line": 420,
      "end_line": 447,
      "content_hash": "20430e85d4312eaa58e70410083d24f2a7f205e9",
      "content": "pub fn assert_edges_semantically_equal(edge1: &Edge, edge2: &Edge) {\n    assert_eq!(edge1.id, edge2.id, \"Edge IDs differ\");\n    assert_eq!(edge1.label, edge2.label, \"Edge labels differ\");\n    assert_eq!(edge1.version, edge2.version, \"Edge versions differ\");\n    assert_eq!(edge1.from_node, edge2.from_node, \"Edge from_node differs\");\n    assert_eq!(edge1.to_node, edge2.to_node, \"Edge to_node differs\");\n\n    match (&edge1.properties, &edge2.properties) {\n        (None, None) => {}\n        (Some(props1), Some(props2)) => {\n            assert_eq!(\n                props1.len(),\n                props2.len(),\n                \"Edge property counts differ\"\n            );\n            for (key1, val1) in props1.iter() {\n                if let Some(val2) = props2.get(key1) {\n                    assert_eq!(val1, val2, \"Property value differs for key: {}\", key1);\n                } else {\n                    panic!(\"Property key '{}' not found in second edge\", key1);\n                }\n            }\n        }\n        _ => panic!(\"One edge has properties and the other doesn't\"),\n    }\n}\n\n/// Asserts that two vectors are semantically equal (excluding distance and level which are runtime)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_assert_vectors_semantically_equal_448": {
      "name": "assert_vectors_semantically_equal",
      "type": "function",
      "start_line": 448,
      "end_line": 491,
      "content_hash": "81c7ab920b8b5b33c448e081af7b2db264f0b769",
      "content": "pub fn assert_vectors_semantically_equal(vec1: &HVector, vec2: &HVector) {\n    assert_eq!(vec1.id, vec2.id, \"Vector IDs differ\");\n    assert_eq!(vec1.label, vec2.label, \"Vector labels differ\");\n    assert_eq!(vec1.version, vec2.version, \"Vector versions differ\");\n    assert_eq!(vec1.deleted, vec2.deleted, \"Vector deleted flags differ\");\n    assert_eq!(vec1.data.len(), vec2.data.len(), \"Vector dimensions differ\");\n\n    // Compare vector data with floating point tolerance\n    for (i, (v1, v2)) in vec1.data.iter().zip(vec2.data.iter()).enumerate() {\n        assert!(\n            (v1 - v2).abs() < 1e-10,\n            \"Vector data differs at index {}: {} vs {}\",\n            i,\n            v1,\n            v2\n        );\n    }\n\n    match (&vec1.properties, &vec2.properties) {\n        (None, None) => {}\n        (Some(props1), Some(props2)) => {\n            assert_eq!(\n                props1.len(),\n                props2.len(),\n                \"Vector property counts differ\"\n            );\n            for (key1, val1) in props1.iter() {\n                if let Some(val2) = props2.get(key1) {\n                    assert_eq!(val1, val2, \"Property value differs for key: {}\", key1);\n                } else {\n                    panic!(\"Property key '{}' not found in second vector\", key1);\n                }\n            }\n        }\n        _ => panic!(\"One vector has properties and the other doesn't\"),\n    }\n}\n\n// ============================================================================\n// DIAGNOSTIC HELPERS\n// ============================================================================\n\n/// Prints byte-level comparison of two byte arrays\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_byte_comparison_492": {
      "name": "print_byte_comparison",
      "type": "function",
      "start_line": 492,
      "end_line": 518,
      "content_hash": "0e910ae9c77191e121706aec38f95e633dd1dbac",
      "content": "pub fn print_byte_comparison(label: &str, bytes1: &[u8], bytes2: &[u8]) {\n    println!(\"\\n=== {} ===\", label);\n    println!(\"Bytes1 ({} total): {:02x?}\", bytes1.len(), bytes1);\n    println!(\"Bytes2 ({} total): {:02x?}\", bytes2.len(), bytes2);\n\n    if bytes1.len() != bytes2.len() {\n        println!(\"WARNING: Byte arrays have different lengths!\");\n    }\n\n    println!(\"\\nByte-by-byte comparison:\");\n    let min_len = bytes1.len().min(bytes2.len());\n    for (i, (b1, b2)) in bytes1.iter().zip(bytes2.iter()).take(min_len).enumerate() {\n        if b1 != b2 {\n            println!(\"  Index {}: bytes1={:02x} ({}), bytes2={:02x} ({})\", i, b1, b1, b2, b2);\n        }\n    }\n\n    if bytes1.len() > min_len {\n        println!(\"  Bytes1 has {} extra bytes\", bytes1.len() - min_len);\n    }\n    if bytes2.len() > min_len {\n        println!(\"  Bytes2 has {} extra bytes\", bytes2.len() - min_len);\n    }\n}\n\n/// Prints human-readable interpretation of bytes\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_byte_interpretation_519": {
      "name": "print_byte_interpretation",
      "type": "function",
      "start_line": 519,
      "end_line": 539,
      "content_hash": "d7a7da2dc101d491dd3469c8e311e85c8cc7dfb5",
      "content": "pub fn print_byte_interpretation(label: &str, bytes: &[u8]) {\n    println!(\"\\n{} as string interpretation:\", label);\n    for (i, byte) in bytes.iter().enumerate() {\n        if *byte >= 32 && *byte < 127 {\n            print!(\"{}\", *byte as char);\n        } else {\n            print!(\"[{:02x}]\", byte);\n        }\n        if (i + 1) % 60 == 0 {\n            println!();\n        }\n    }\n    println!();\n}\n\n// ============================================================================\n// RANDOM DATA GENERATORS (for property-based testing)\n// ============================================================================\n\n/// Generates a random string of given length\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_random_string_540": {
      "name": "random_string",
      "type": "function",
      "start_line": 540,
      "end_line": 549,
      "content_hash": "cfbf0aba3e70712889fb5fe46fef18e0cccc5089",
      "content": "pub fn random_string(len: usize) -> String {\n    use rand::Rng;\n    let mut rng = rand::rng();\n    (0..len)\n        .map(|_| rng.random_range(b'a'..=b'z') as char)\n        .collect()\n}\n\n/// Generates random valid UTF-8 strings including Unicode\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_random_utf8_string_550": {
      "name": "random_utf8_string",
      "type": "function",
      "start_line": 550,
      "end_line": 560,
      "content_hash": "1da1f52a603e931563529f26860fb10c1d743422",
      "content": "pub fn random_utf8_string(len: usize) -> String {\n    use rand::Rng;\n    let mut rng = rand::rng();\n    let chars = vec!['a', 'b', '\u00f1', '\u4e2d', '\u6587', '\ud83d\udd25', '\ud83d\ude80', '\u00e9', '\u00fc'];\n    (0..len)\n        .map(|_| chars[rng.random_range(0..chars.len())])\n        .collect()\n}\n\n/// Generates a random f64 vector of given dimensions\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_random_f64_vector_561": {
      "name": "random_f64_vector",
      "type": "function",
      "start_line": 561,
      "end_line": 568,
      "content_hash": "b30751e224f3a2e3fa5aa26d643864dda95767db",
      "content": "pub fn random_f64_vector(dimensions: usize) -> Vec<f64> {\n    use rand::Rng;\n    let mut rng = rand::rng();\n    (0..dimensions).map(|_| rng.random_range(-1.0..1.0)).collect()\n}\n\n/// Generates a random Value for property testing\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_random_value_569": {
      "name": "random_value",
      "type": "function",
      "start_line": 569,
      "end_line": 588,
      "content_hash": "b158dd000887c27c37c07495f6e966691ab3970a",
      "content": "pub fn random_value() -> Value {\n    use rand::Rng;\n    let mut rng = rand::rng();\n    match rng.random_range(0..10) {\n        0 => Value::String(random_string(10)),\n        1 => Value::I32(rng.random()),\n        2 => Value::I64(rng.random()),\n        3 => Value::F64(rng.random()),\n        4 => Value::Boolean(rng.random()),\n        5 => Value::U64(rng.random()),\n        6 => Value::Empty,\n        7 => Value::Array(vec![Value::I32(rng.random()), Value::I32(rng.random())]),\n        8 => {\n            let mut map = HashMap::new();\n            map.insert(\"key\".to_string(), Value::I32(rng.random()));\n            Value::Object(map)\n        }\n        _ => Value::String(\"default\".to_string()),\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}