{
  "file_path": "/work/external-deps/helix-db/helix-db/src/utils/properties.rs",
  "file_hash": "0396e738f427fb5a58292aee8c17d430adde99da",
  "updated_at": "2025-12-26T17:34:22.608760",
  "symbols": {
    "struct_ImmutablePropertiesMap_26": {
      "name": "ImmutablePropertiesMap",
      "type": "struct",
      "start_line": 26,
      "end_line": 33,
      "content_hash": "a76a124a4d37d75a0b23136cb0d85c9cb7c44cf9",
      "content": "pub struct ImmutablePropertiesMap<'arena> {\n    len: usize,\n    key_lengths: *const usize,\n    key_datas: *const *const u8,\n    values: *const Value,\n    _phantom: marker::PhantomData<(&'arena str, &'arena Value)>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ImmutablePropertiesMap_34": {
      "name": "ImmutablePropertiesMap",
      "type": "impl",
      "start_line": 34,
      "end_line": 34,
      "content_hash": "9f999b07500d015987893bf1a5a562b2f7bba9b8",
      "content": "impl<'arena> ImmutablePropertiesMap<'arena> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_35": {
      "name": "new",
      "type": "method",
      "start_line": 35,
      "end_line": 119,
      "content_hash": "5bd2e23288d038cbcfdf1554201a304d2781c8af",
      "content": "    pub fn new(\n        len: usize,\n        items: impl Iterator<Item = (&'arena str, Value)>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Self {\n        let Ok(map) = Self::new_from_try(len, items.map(Ok::<_, Infallible>), arena);\n        map\n    }\n\n    pub fn from_bincode_bytes<'txn>(\n        bytes: &'txn [u8],\n        arena: &'arena bumpalo::Bump,\n    ) -> bincode::Result<Self> {\n        bincode::options()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(ImmutablePropertiesMapDeSeed { arena }, bytes)\n    }\n\n    pub fn new_from_try<Error>(\n        len: usize,\n        items: impl Iterator<Item = Result<(&'arena str, Value), Error>>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<Self, Error> {\n        if len == 0 {\n            return Ok(Self {\n                len: 0,\n                key_lengths: ptr::null(),\n                key_datas: ptr::null(),\n                values: ptr::null(),\n                _phantom: marker::PhantomData,\n            });\n        }\n\n        let key_length_layout = alloc::Layout::array::<usize>(len)\n                .expect(\"LayoutError for key_length_layout: arithmetic overflow or total size exceeds isize::MAX\");\n        let key_datas_layout = alloc::Layout::array::<*const u8>(len)\n                .expect(\"LayoutError for key_datas_layout: arithmetic overflow or total size exceeds isize::MAX\");\n        let values_layout = alloc::Layout::array::<Value>(len).expect(\n            \"LayoutError for values_layout: arithmetic overflow or total size exceeds isize::MAX\",\n        );\n\n        let key_lengths: ptr::NonNull<usize> = arena.alloc_layout(key_length_layout).cast();\n        let key_datas: ptr::NonNull<*const u8> = arena.alloc_layout(key_datas_layout).cast();\n        let values: ptr::NonNull<Value> = arena.alloc_layout(values_layout).cast();\n\n        let mut index = 0;\n        for entry in items {\n            let (key, value) = entry?;\n            let (key_data, key_length) = (key.as_ptr(), key.len());\n\n            unsafe {\n                // SAFETY: We assert we are in-bounds above, using an incrementing counter below.\n                assert!(\n                    index < len,\n                    \"len that was passed in was incorrect, iterator is yielding more items\"\n                );\n\n                key_lengths.add(index).write(key_length);\n                key_datas.add(index).write(key_data);\n                values.add(index).write(value);\n            }\n\n            // SAFETY: Used for out of bounds check\n            index += 1;\n        }\n\n        // SAFETY: We assert that the real count is correct.\n        // We could still recover by constructing slices with the real length,\n        // but that means somewhere is potentially messing up and could lead to\n        // data loss.\n        assert_eq!(\n            index, len,\n            \"len that was passed in was incorrect, iterator yielded less items\"\n        );\n\n        Ok(ImmutablePropertiesMap {\n            len,\n            key_lengths: key_lengths.as_ptr(),\n            key_datas: key_datas.as_ptr(),\n            values: values.as_ptr(),\n            _phantom: marker::PhantomData,\n        })\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_120": {
      "name": "get",
      "type": "method",
      "start_line": 120,
      "end_line": 123,
      "content_hash": "f9855c5ee82b991e8492fea4e1cd1662ff6279b6",
      "content": "    pub fn get(&self, q: &str) -> Option<&'arena Value> {\n        self.iter().find_map(|(k, v)| q.eq(k).then_some(v))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_len_124": {
      "name": "len",
      "type": "method",
      "start_line": 124,
      "end_line": 127,
      "content_hash": "46c09ac786075f30d3c9547b571eba72e089986f",
      "content": "    pub fn len(&self) -> usize {\n        self.len\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_empty_128": {
      "name": "is_empty",
      "type": "method",
      "start_line": 128,
      "end_line": 131,
      "content_hash": "ef910135b77b3c3bffdd8b20435164f60180e99e",
      "content": "    pub fn is_empty(&self) -> bool {\n        self.len == 0\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_iter_132": {
      "name": "iter",
      "type": "method",
      "start_line": 132,
      "end_line": 161,
      "content_hash": "a24dd8fa62b350ebcef3c2a1c64917e51ef6e00d",
      "content": "    pub fn iter(&self) -> impl Iterator<Item = (&'arena str, &'arena Value)> {\n        let (key_datas, key_lengths, values) = match self.len {\n            0 => ([].as_slice(), [].as_slice(), [].as_slice()),\n            _ => unsafe {\n                // SAFETY: These are all slices but we are optimising storage space by reusing\n                // the same length field. We never construct a slice from a null pointer, even\n                // when len is zero as we check\n                (\n                    slice::from_raw_parts(self.key_datas, self.len),\n                    slice::from_raw_parts(self.key_lengths, self.len),\n                    slice::from_raw_parts(self.values, self.len),\n                )\n            },\n        };\n\n        key_datas\n            .iter()\n            .copied()\n            .zip(key_lengths.iter().copied())\n            .map(|(data, len)| unsafe {\n                // SAFETY: This is an immutable struct and we deconstruct a valid &'arena str\n                // on creation. This is just putting it back together, and it couldn't have\n                // changed in between then.\n                let bytes: &'arena [u8] = slice::from_raw_parts(data, len);\n                str::from_utf8_unchecked(bytes)\n            })\n            .zip(values)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_162": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 162,
      "end_line": 177,
      "content_hash": "44f76ab87b8ec59324e02471c2b7d9505a2d6d62",
      "content": "impl<'arena> Serialize for ImmutablePropertiesMap<'arena> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        use serde::ser::SerializeMap;\n        let mut map = serializer.serialize_map(Some(self.len))?;\n\n        for (key, value) in self.iter() {\n            map.serialize_entry(key, value)?;\n        }\n\n        map.end()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ImmutablePropertiesMapDeSeed_178": {
      "name": "ImmutablePropertiesMapDeSeed",
      "type": "struct",
      "start_line": 178,
      "end_line": 181,
      "content_hash": "57257f86fed2e76f687a9177789aa5bd50c65fde",
      "content": "pub struct ImmutablePropertiesMapDeSeed<'arena> {\n    pub arena: &'arena bumpalo::Bump,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_serde::de::DeserializeSeed_182": {
      "name": "serde::de::DeserializeSeed",
      "type": "impl",
      "start_line": 182,
      "end_line": 188,
      "content_hash": "21afce5053be770975328916eb1d6b6490af2c57",
      "content": "impl<'de, 'arena> serde::de::DeserializeSeed<'de> for ImmutablePropertiesMapDeSeed<'arena> {\n    type Value = ImmutablePropertiesMap<'arena>;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: serde::de::Deserializer<'de>,\n    {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ImmutablePropertiesMapVisitor_189": {
      "name": "ImmutablePropertiesMapVisitor",
      "type": "struct",
      "start_line": 189,
      "end_line": 192,
      "content_hash": "7c728b018339459bb1b16314b26e75eeabeb3140",
      "content": "        struct ImmutablePropertiesMapVisitor<'arena> {\n            arena: &'arena bumpalo::Bump,\n        }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_serde::de::Visitor_193": {
      "name": "serde::de::Visitor",
      "type": "impl",
      "start_line": 193,
      "end_line": 195,
      "content_hash": "fac7a6eafd1cc5988e696f3dab73e5e899b45213",
      "content": "        impl<'de, 'arena> serde::de::Visitor<'de> for ImmutablePropertiesMapVisitor<'arena> {\n            type Value = ImmutablePropertiesMap<'arena>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expecting_196": {
      "name": "expecting",
      "type": "method",
      "start_line": 196,
      "end_line": 225,
      "content_hash": "0819c6ea9d27ccbbad0edb5343ab88b30654b649",
      "content": "            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::MapAccess<'de>,\n            {\n                let num_items = map.size_hint()\n                    .expect(\"You shouldn't have updated bincode. In v1.3.3 a size_hint was always passed for maps\");\n\n                let entries = iter::from_fn(move || {\n                    map.next_entry()\n                        .map(|entry| {\n                            entry.map(|(k, v)| {\n                                let k: &'arena str = self.arena.alloc_str(k);\n                                (k, v)\n                            })\n                        })\n                        .transpose()\n                });\n\n                ImmutablePropertiesMap::new_from_try(num_items, entries, self.arena)\n            }\n        }\n\n        let visitor = ImmutablePropertiesMapVisitor { arena: self.arena };\n        deserializer.deserialize_map(visitor)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}