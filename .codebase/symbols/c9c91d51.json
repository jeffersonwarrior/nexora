{
  "file_path": "/work/context-engine/tests/test_tier2_fallback.py",
  "file_hash": "66ddb62eb86797366424c2da04c35b6492d48136",
  "updated_at": "2025-12-26T17:34:21.749438",
  "symbols": {
    "class_FakeEmbedder_14": {
      "name": "FakeEmbedder",
      "type": "class",
      "start_line": 14,
      "end_line": 31,
      "content_hash": "140670479746b2e0403f6ce6d45735e54abdf96a",
      "content": "class FakeEmbedder:\n    def __init__(self, model_name: str = \"fake\"):\n        self.model_name = model_name\n\n    class _Vec:\n        def __init__(self, arr):\n            self._arr = arr\n        def tolist(self):\n            return self._arr\n        def __len__(self):\n            return len(self._arr)\n\n    def embed(self, texts):\n        # Deterministic small vector by hashing; yields objects with .tolist()\n        for t in texts:\n            h = sum(ord(c) for c in t) % 997\n            vec = [(float((h + i) % 13) / 13.0) for i in range(32)]\n            yield self._Vec(vec)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___15": {
      "name": "__init__",
      "type": "method",
      "start_line": 15,
      "end_line": 16,
      "content_hash": "0fb67702324c29fd98072d614d7c56189685fa17",
      "content": "    def __init__(self, model_name: str = \"fake\"):\n        self.model_name = model_name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class__Vec_18": {
      "name": "_Vec",
      "type": "class",
      "start_line": 18,
      "end_line": 24,
      "content_hash": "ab430a0529aed2ec20bfac5f6a5a8a3cf260014b",
      "content": "    class _Vec:\n        def __init__(self, arr):\n            self._arr = arr\n        def tolist(self):\n            return self._arr\n        def __len__(self):\n            return len(self._arr)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___19": {
      "name": "__init__",
      "type": "method",
      "start_line": 19,
      "end_line": 20,
      "content_hash": "1a6311791de6e83903db940df6920ca4bb3d31ed",
      "content": "        def __init__(self, arr):\n            self._arr = arr",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tolist_21": {
      "name": "tolist",
      "type": "method",
      "start_line": 21,
      "end_line": 22,
      "content_hash": "48b68fcaed05deaa04a77181edc1aff3229435e7",
      "content": "        def tolist(self):\n            return self._arr",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___len___23": {
      "name": "__len__",
      "type": "method",
      "start_line": 23,
      "end_line": 24,
      "content_hash": "4dd660df55df9f47809cea6b1f1b70260ab86436",
      "content": "        def __len__(self):\n            return len(self._arr)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_embed_26": {
      "name": "embed",
      "type": "method",
      "start_line": 26,
      "end_line": 31,
      "content_hash": "cfb3a94a03a96534a508f3604967eeba0be3acfd",
      "content": "    def embed(self, texts):\n        # Deterministic small vector by hashing; yields objects with .tolist()\n        for t in texts:\n            h = sum(ord(c) for c in t) % 997\n            vec = [(float((h + i) % 13) / 13.0) for i in range(32)]\n            yield self._Vec(vec)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_qdrant_container_35": {
      "name": "qdrant_container",
      "type": "function",
      "start_line": 35,
      "end_line": 80,
      "content_hash": "7c81e0da0bd678b79f451f69036de2d4ac772b93",
      "content": "def qdrant_container():\n    os.environ.setdefault(\"TESTCONTAINERS_RYUK_DISABLED\", \"true\")\n    os.environ.setdefault(\"TESTCONTAINERS_RYUK_TIMEOUT\", \"0\")\n    try:\n        from testcontainers.core.container import DockerContainer\n    except Exception:  # pragma: no cover\n        pytest.skip(\"testcontainers not available\")\n    import time, urllib.request\n\n    container = DockerContainer(\"qdrant/qdrant:latest\")\n    try:\n        container.with_env(\"TESTCONTAINERS_RYUK_DISABLED\", \"true\")\n        container.with_env(\"TESTCONTAINERS_RYUK_TIMEOUT\", \"0\")\n        container.with_exposed_ports(6333)\n        container.start()\n        host = container.get_container_host_ip()\n        deadline = time.time() + 30\n        port = None\n        last_exc = None\n        while time.time() < deadline:\n            try:\n                port = int(container.get_exposed_port(6333))\n                break\n            except Exception as exc:\n                last_exc = exc\n                time.sleep(0.25)\n        if port is None:\n            raise RuntimeError(f\"qdrant port mapping unavailable: {last_exc}\")\n        url = f\"http://{host}:{port}\"\n\n        deadline = time.time() + 60\n        while time.time() < deadline:\n            try:\n                with urllib.request.urlopen(url + \"/readyz\", timeout=2) as r:\n                    if 200 <= r.status < 300:\n                        break\n            except Exception:\n                pass\n            time.sleep(1)\n\n        yield url\n    finally:\n        try:\n            container.stop()\n        except Exception:\n            pass",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_tier2_fallback_unconditional_with_language_filter_85": {
      "name": "test_tier2_fallback_unconditional_with_language_filter",
      "type": "function",
      "start_line": 85,
      "end_line": 133,
      "content_hash": "e18a08924473a8d2f98cf522e0c85482a3f6cf54",
      "content": "async def test_tier2_fallback_unconditional_with_language_filter(tmp_path, monkeypatch, qdrant_container):\n    # Env for services\n    os.environ[\"QDRANT_URL\"] = qdrant_container\n    os.environ[\"COLLECTION_NAME\"] = f\"test-{uuid.uuid4().hex[:8]}\"\n    os.environ[\"USE_TREE_SITTER\"] = \"0\"\n    os.environ[\"HYBRID_IN_PROCESS\"] = \"1\"\n    os.environ[\"EMBEDDING_MODEL\"] = \"fake\"\n    os.environ[\"REFRAG_GATE_FIRST\"] = \"1\"  # ensure Tier-1 gate-first path is active\n\n    # Stub embeddings everywhere (FakeEmbedder produces 32-dim vectors)\n    monkeypatch.setattr(ing, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_model_dimension\", lambda *a, **k: 32)  # Match FakeEmbedder dim\n    monkeypatch.setattr(srv, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(hy, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(hy, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n\n    # Create tiny repo\n    (tmp_path / \"pkg\").mkdir()\n    f1 = tmp_path / \"pkg\" / \"a.py\"\n    f1.write_text(\"def f():\\n    return 1\\n\")\n\n    # Index via function call (no shell)\n    ing.index_repo(\n        root=tmp_path,\n        qdrant_url=qdrant_container,\n        api_key=\"\",\n        collection=os.environ[\"COLLECTION_NAME\"],\n        model_name=\"fake\",\n        recreate=True,\n    )\n\n    # Construct a path_glob that excludes the actual file so Tier-1 yields zero\n    nonmatch_glob = str(tmp_path / \"does_not_match\" / \"*.py\")\n\n    # Call context_answer with a language filter present; Tier\u20112 should trigger and return results\n    out = await srv.context_answer(\n        query=\"def f\",\n        limit=3,\n        per_path=1,\n        include_snippet=False,\n        language=\"python\",\n        path_glob=nonmatch_glob,\n    )\n\n    assert isinstance(out, dict)\n    cits = out.get(\"citations\") or []\n    # Despite Tier-1 returning zero due to path_glob, Tier-2 relaxed search should find a.py\n    assert any(str(f1) in (c.get(\"path\") or \"\") for c in cits)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}