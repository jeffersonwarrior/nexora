{
  "file_path": "/work/external-deps/Context-Engine/scripts/ingest_history.py",
  "file_hash": "6795d789f9aa6d600edc4f7c0d60878adeddc04f",
  "updated_at": "2025-12-26T17:34:23.461105",
  "symbols": {
    "function__manifest_run_id_39": {
      "name": "_manifest_run_id",
      "type": "function",
      "start_line": 39,
      "end_line": 47,
      "content_hash": "ee8764fba623b8c9eb3e43ef06fc368d2073ed1a",
      "content": "def _manifest_run_id(manifest_path: str) -> str:\n    try:\n        stem = Path(str(manifest_path)).name\n        if stem.endswith(\".json\"):\n            stem = stem[: -len(\".json\")]\n        stem = stem.strip()\n        return stem or \"git_history\"\n    except Exception:\n        return \"git_history\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__history_prune_enabled_50": {
      "name": "_history_prune_enabled",
      "type": "function",
      "start_line": 50,
      "end_line": 59,
      "content_hash": "f13cb8d797e654b0132506fbb29398ef8253ef18",
      "content": "def _history_prune_enabled() -> bool:\n    try:\n        return str(os.environ.get(\"GIT_HISTORY_PRUNE\", \"1\")).strip().lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n            \"on\",\n        }\n    except Exception:\n        return True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__prune_old_commit_points_62": {
      "name": "_prune_old_commit_points",
      "type": "function",
      "start_line": 62,
      "end_line": 95,
      "content_hash": "1b1c9e0dff98510404fb85cd16db6d259a8966fa",
      "content": "def _prune_old_commit_points(\n    client: QdrantClient,\n    run_id: str,\n    *,\n    mode: str,\n) -> None:\n    try:\n        if mode != \"snapshot\" or not _history_prune_enabled():\n            return\n    except Exception:\n        return\n\n    try:\n        keep_cond = models.FieldCondition(\n            key=\"metadata.git_history_run_id\", match=models.MatchValue(value=run_id)\n        )\n        flt = models.Filter(\n            must=[\n                models.FieldCondition(\n                    key=\"metadata.kind\", match=models.MatchValue(value=\"git_message\")\n                ),\n                models.FieldCondition(\n                    key=\"metadata.repo\", match=models.MatchValue(value=REPO_NAME)\n                ),\n            ],\n            must_not=[keep_cond],\n        )\n        client.delete(\n            collection_name=COLLECTION,\n            points_selector=models.FilterSelector(filter=flt),\n            wait=True,\n        )\n    except Exception:\n        return",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__cleanup_manifest_files_98": {
      "name": "_cleanup_manifest_files",
      "type": "function",
      "start_line": 98,
      "end_line": 145,
      "content_hash": "251a6d633275d0469f2b742546c3d3388477543e",
      "content": "def _cleanup_manifest_files(manifest_path: str) -> None:\n    try:\n        p = Path(str(manifest_path))\n    except Exception:\n        return\n\n    try:\n        delete_self = str(os.environ.get(\"GIT_HISTORY_DELETE_MANIFEST\", \"0\")).strip().lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n            \"on\",\n        }\n    except Exception:\n        delete_self = False\n\n    if delete_self:\n        try:\n            p.unlink()\n        except Exception:\n            pass\n\n    try:\n        raw = str(os.environ.get(\"GIT_HISTORY_MANIFEST_MAX_FILES\", \"0\")).strip()\n        max_keep = int(raw) if raw else 0\n    except Exception:\n        max_keep = 0\n\n    if max_keep <= 0:\n        return\n\n    try:\n        parent = p.parent\n        files = []\n        for cand in parent.glob(\"git_history_*.json\"):\n            try:\n                files.append((cand.stat().st_mtime, cand))\n            except Exception:\n                continue\n        files.sort(key=lambda t: t[0])\n        excess = files[:-max_keep] if len(files) > max_keep else []\n        for _ts, fp in excess:\n            try:\n                fp.unlink()\n            except Exception:\n                continue\n    except Exception:\n        return",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_run_148": {
      "name": "run",
      "type": "function",
      "start_line": 148,
      "end_line": 154,
      "content_hash": "f0b1fb4f9ddc1a52b55da33542ea2ccc409c09d6",
      "content": "def run(cmd: str) -> str:\n    p = subprocess.run(\n        shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True\n    )\n    if p.returncode != 0:\n        raise RuntimeError(f\"Command failed: {cmd}\\n{p.stderr}\")\n    return p.stdout",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_try_run_157": {
      "name": "try_run",
      "type": "function",
      "start_line": 157,
      "end_line": 160,
      "content_hash": "6f6f6ec5c922de4306387f0fb3b23b3c3ef7e7bb",
      "content": "def try_run(cmd: str) -> subprocess.CompletedProcess:\n    return subprocess.run(\n        shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensure_base_ref_163": {
      "name": "ensure_base_ref",
      "type": "function",
      "start_line": 163,
      "end_line": 179,
      "content_hash": "b829cf60e70d25242b011bb5ea0779e5b7b304b4",
      "content": "def ensure_base_ref(args) -> str:\n    # Prefer local HEAD when present\n    proc = try_run(\"git rev-parse --verify HEAD\")\n    if proc.returncode == 0 and proc.stdout.strip():\n        return \"HEAD\"\n    # Fallback: fetch shallow history from remote and use its HEAD\n    remote = args.remote or \"origin\"\n    depth = args.fetch_depth or 1000\n    try_run(f\"git fetch --all --tags --prune --depth {depth}\")\n    ref = try_run(f\"git symbolic-ref -q {remote}/HEAD\")\n    if ref.returncode == 0 and ref.stdout.strip():\n        return ref.stdout.strip()\n    # Last resort: try common branch names\n    for b in (f\"{remote}/main\", f\"{remote}/master\"):\n        if try_run(f\"git rev-parse --verify {b}\").returncode == 0:\n            return b\n    raise RuntimeError(\"Could not determine a base revision (HEAD or remote HEAD)\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_list_commits_182": {
      "name": "list_commits",
      "type": "function",
      "start_line": 182,
      "end_line": 201,
      "content_hash": "873ea1660c492802656a4515d622ae0adfd518c5",
      "content": "def list_commits(args) -> List[str]:\n    cmd = [\"git\", \"rev-list\", \"--no-merges\"]\n    if args.since:\n        cmd += [f\"--since={args.since}\"]\n    if args.until:\n        cmd += [f\"--until={args.until}\"]\n    if args.author:\n        cmd += [f\"--author={args.author}\"]\n    if args.grep:\n        cmd += [f\"--grep={args.grep}\"]\n    base = ensure_base_ref(args)\n    if args.path:\n        cmd += [base, \"--\", args.path]\n    else:\n        cmd += [base]\n    out = run(\" \".join(shlex.quote(c) for c in cmd))\n    commits = [l.strip() for l in out.splitlines() if l.strip()]\n    if args.max_commits and len(commits) > args.max_commits:\n        commits = commits[: args.max_commits]\n    return commits",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__redact_emails_204": {
      "name": "_redact_emails",
      "type": "function",
      "start_line": 204,
      "end_line": 207,
      "content_hash": "8308684792c6665ae9f3d6e6c4360f0050e12fe3",
      "content": "def _redact_emails(text: str) -> str:\n    return re.sub(\n        r\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\", \"<redacted>\", text or \"\"\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_commit_metadata_210": {
      "name": "commit_metadata",
      "type": "function",
      "start_line": 210,
      "end_line": 227,
      "content_hash": "7423be1887dc5c9297c3ebb3c2060b603eba57af",
      "content": "def commit_metadata(commit: str) -> Dict[str, Any]:\n    fmt = \"%H%x1f%an%x1f%ae%x1f%ad%x1f%s%x1f%b\"\n    out = run(f\"git show -s --format={fmt} {commit}\")\n    parts = out.strip().split(\"\\x1f\")\n    sha, an, ae, ad, subj, body = (parts + [\"\"] * 6)[:6]\n    files_out = run(f\"git diff-tree --no-commit-id --name-only -r {commit}\")\n    files = [f for f in files_out.splitlines() if f]\n    message = _redact_emails((subj + (\"\\n\" + body if body else \"\")).strip())\n    if len(message) > 2000:\n        message = message[:2000] + \"\u2026\"\n    return {\n        \"commit_id\": sha,\n        \"author_name\": an,\n        # email stripped for privacy\n        \"authored_date\": ad,\n        \"message\": message,\n        \"files\": files,\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stable_id_230": {
      "name": "stable_id",
      "type": "function",
      "start_line": 230,
      "end_line": 232,
      "content_hash": "a54712cbbcb10370b27d96b050390a65eed23c21",
      "content": "def stable_id(commit_id: str) -> int:\n    h = hashlib.sha1(commit_id.encode(\"utf-8\")).hexdigest()\n    return int(h[:16], 16)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__commit_summary_enabled_235": {
      "name": "_commit_summary_enabled",
      "type": "function",
      "start_line": 235,
      "end_line": 249,
      "content_hash": "59d112f3f23121750b51f4cacd4935148adea6d9",
      "content": "def _commit_summary_enabled() -> bool:\n    \"\"\"Check REFRAG_COMMIT_DESCRIBE to decide if commit summarization is enabled.\n\n    This is an opt-in feature: set REFRAG_COMMIT_DESCRIBE=1 (and enable the decoder)\n    to generate per-commit lineage summaries at ingest time.\n    \"\"\"\n    try:\n        return str(os.environ.get(\"REFRAG_COMMIT_DESCRIBE\", \"0\")).strip().lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n            \"on\",\n        }\n    except Exception:\n        return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generate_commit_summary_252": {
      "name": "generate_commit_summary",
      "type": "function",
      "start_line": 252,
      "end_line": 345,
      "content_hash": "368717d5af97fcb0d9de7b4165dc711b560379fb",
      "content": "def generate_commit_summary(md: Dict[str, Any], diff_text: str) -> tuple[str, list[str], list[str]]:\n    \"\"\"Best-effort: ask local decoder to summarize a git commit.\n\n    Returns (goal, symbols, tags). On failure returns (\"\", [], []).\n\n    The summary is designed to be compact and search-friendly, mirroring the\n    Context Lineage goals: high-level intent, key symbols, and short tags.\n    \"\"\"\n    goal: str = \"\"\n    symbols: list[str] = []\n    tags: list[str] = []\n    if not _commit_summary_enabled() or not diff_text.strip():\n        return goal, symbols, tags\n    try:\n        from scripts.refrag_llamacpp import (  # type: ignore\n            LlamaCppRefragClient,\n            is_decoder_enabled,\n            get_runtime_kind,\n        )\n\n        if not is_decoder_enabled():\n            return \"\", [], []\n        runtime = get_runtime_kind()\n        commit_id = str(md.get(\"commit_id\") or \"\")\n        message = str(md.get(\"message\") or \"\")\n        files = md.get(\"files\") or []\n        try:\n            files_str = \"\\n\".join(str(f) for f in files[:50])\n        except Exception:\n            files_str = \"\"\n        # Truncate diff text to keep summarization fast/token-efficient\n        try:\n            max_chars = int(os.environ.get(\"COMMIT_SUMMARY_DIFF_CHARS\", \"6000\") or 6000)\n        except Exception:\n            max_chars = 6000\n        body = diff_text[:max_chars]\n\n        if runtime == \"glm\":\n            from scripts.refrag_glm import GLMRefragClient  # type: ignore\n\n            client = GLMRefragClient()\n            prompt = (\n                \"You are a JSON-only function that summarizes git commits for search enrichment.\\n\"\n                \"Respond with a single JSON object and nothing else (no prose, no markdown).\\n\"\n                \"Exact format: {\\\"goal\\\": string (<=200 chars), \\\"symbols\\\": [1-6 short strings], \\\"tags\\\": [3-6 short strings]}.\\n\"\n                f\"Commit id: {commit_id}\\n\"\n                f\"Message:\\n{message}\\n\"\n                f\"Files:\\n{files_str}\\n\"\n                \"Diff:\\n\" + body\n            )\n            out = client.generate_with_soft_embeddings(\n                prompt=prompt,\n                max_tokens=int(os.environ.get(\"COMMIT_SUMMARY_MAX_TOKENS\", \"128\") or 128),\n                temperature=float(os.environ.get(\"COMMIT_SUMMARY_TEMPERATURE\", \"0.10\") or 0.10),\n                top_p=float(os.environ.get(\"COMMIT_SUMMARY_TOP_P\", \"0.9\") or 0.9),\n                stop=[\"\\n\\n\"],\n                force_json=True,\n            )\n        else:\n            client = LlamaCppRefragClient()\n            prompt = (\n                \"You summarize git commits for search enrichment.\\n\"\n                \"Return strictly JSON: {\\\"goal\\\": string (<=200 chars), \\\"symbols\\\": [1-6 short strings], \\\"tags\\\": [3-6 short strings]}.\\n\"\n                f\"Commit id: {commit_id}\\n\"\n                f\"Message:\\n{message}\\n\"\n                f\"Files:\\n{files_str}\\n\"\n                \"Diff:\\n\" + body\n            )\n            out = client.generate_with_soft_embeddings(\n                prompt=prompt,\n                max_tokens=int(os.environ.get(\"COMMIT_SUMMARY_MAX_TOKENS\", \"128\") or 128),\n                temperature=float(os.environ.get(\"COMMIT_SUMMARY_TEMPERATURE\", \"0.10\") or 0.10),\n                top_k=int(os.environ.get(\"COMMIT_SUMMARY_TOP_K\", \"30\") or 30),\n                top_p=float(os.environ.get(\"COMMIT_SUMMARY_TOP_P\", \"0.9\") or 0.9),\n                stop=[\"\\n\\n\"],\n            )\n        import json as _json\n        try:\n            obj = _json.loads(out)\n            if isinstance(obj, dict):\n                g = obj.get(\"goal\")\n                s = obj.get(\"symbols\")\n                t = obj.get(\"tags\")\n                if isinstance(g, str):\n                    goal = g.strip()[:200]\n                if isinstance(s, list):\n                    symbols = [str(x).strip() for x in s if str(x).strip()][:6]\n                if isinstance(t, list):\n                    tags = [str(x).strip() for x in t if str(x).strip()][:6]\n        except Exception:\n            pass\n    except Exception:\n        return \"\", [], []\n    return goal, symbols, tags",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_build_text_348": {
      "name": "build_text",
      "type": "function",
      "start_line": 348,
      "end_line": 357,
      "content_hash": "e5522ce54fb89bc3172cac0cb18d8c25f9eac2f4",
      "content": "def build_text(\n    md: Dict[str, Any], max_files: int = 200, include_body: bool = True\n) -> str:\n    msg = md.get(\"message\", \"\")\n    files = md.get(\"files\", [])\n    if not include_body:\n        msg = msg.splitlines()[0] if msg else \"\"\n    head = msg.strip()\n    files_part = \"\\n\".join(files[:max_files])\n    return (head + \"\\n\\nFiles:\\n\" + files_part).strip()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ingest_from_manifest_360": {
      "name": "_ingest_from_manifest",
      "type": "function",
      "start_line": 360,
      "end_line": 471,
      "content_hash": "0060b06d5f67f4b47de3351dc1fba21497ddbb95",
      "content": "def _ingest_from_manifest(\n    manifest_path: str,\n    model: Any,\n    client: QdrantClient,\n    vec_name: str,\n    include_body: bool,\n    per_batch: int,\n) -> int:\n    try:\n        with open(manifest_path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n    except Exception as e:\n        print(f\"Failed to read manifest {manifest_path}: {e}\")\n        return 0\n\n    commits = data.get(\"commits\") or []\n    if not commits:\n        print(\"No commits in manifest.\")\n        return 0\n\n    run_id = _manifest_run_id(manifest_path)\n    mode = str(data.get(\"mode\") or \"delta\").strip().lower() or \"delta\"\n\n    points: List[models.PointStruct] = []\n    count = 0\n    for c in commits:\n        try:\n            if not isinstance(c, dict):\n                continue\n            commit_id = str(c.get(\"commit_id\") or \"\").strip()\n            if not commit_id:\n                continue\n            author_name = str(c.get(\"author_name\") or \"\")\n            authored_date = str(c.get(\"authored_date\") or \"\")\n            message = str(c.get(\"message\") or \"\")\n            files = c.get(\"files\") or []\n            if not isinstance(files, list):\n                files = []\n            md: Dict[str, Any] = {\n                \"commit_id\": commit_id,\n                \"author_name\": author_name,\n                \"authored_date\": authored_date,\n                \"message\": message,\n                \"files\": files,\n            }\n            text = build_text(md, include_body=include_body)\n            try:\n                vec = next(model.embed([text])).tolist()\n            except Exception:\n                continue\n\n            goal: str = \"\"\n            sym: List[str] = []\n            tgs: List[str] = []\n            diff_text = str(c.get(\"diff\") or \"\")\n            if diff_text.strip():\n                try:\n                    goal, sym, tgs = generate_commit_summary(md, diff_text)\n                except Exception:\n                    goal, sym, tgs = \"\", [], []\n\n            md_payload: Dict[str, Any] = {\n                \"language\": \"git\",\n                \"kind\": \"git_message\",\n                \"symbol\": commit_id,\n                \"symbol_path\": commit_id,\n                \"repo\": REPO_NAME,\n                \"commit_id\": commit_id,\n                \"git_history_run_id\": run_id,\n                \"git_history_mode\": mode,\n                \"author_name\": author_name,\n                \"authored_date\": authored_date,\n                \"message\": message,\n                \"files\": files,\n                \"path\": \".git\",\n                \"path_prefix\": \".git\",\n                \"ingested_at\": int(time.time()),\n            }\n            if goal:\n                md_payload[\"lineage_goal\"] = goal\n            if sym:\n                md_payload[\"lineage_symbols\"] = sym\n            if tgs:\n                md_payload[\"lineage_tags\"] = tgs\n\n            payload = {\n                \"document\": (message.splitlines()[0] if message else commit_id),\n                \"information\": text[:512],\n                \"metadata\": md_payload,\n            }\n            pid = stable_id(commit_id)\n            pt = models.PointStruct(id=pid, vector={vec_name: vec}, payload=payload)\n            points.append(pt)\n            count += 1\n            if len(points) >= per_batch:\n                client.upsert(collection_name=COLLECTION, points=points)\n                points.clear()\n        except Exception:\n            continue\n\n    if points:\n        client.upsert(collection_name=COLLECTION, points=points)\n    try:\n        _prune_old_commit_points(client, run_id, mode=mode)\n    except Exception:\n        pass\n    try:\n        _cleanup_manifest_files(manifest_path)\n    except Exception:\n        pass\n    print(f\"Ingested {count} commits into {COLLECTION} from manifest {manifest_path}.\")\n    return count",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_474": {
      "name": "main",
      "type": "function",
      "start_line": 474,
      "end_line": 589,
      "content_hash": "7a5b2703e8b532c1dc161243c288a25b9e0dbd0c",
      "content": "def main():\n    ap = argparse.ArgumentParser(\n        description=\"Ingest Git history into Qdrant deterministically\"\n    )\n    ap.add_argument(\n        \"--since\", type=str, default=None, help=\"e.g., '2 years ago' or '2023-01-01'\"\n    )\n    ap.add_argument(\"--until\", type=str, default=None)\n    ap.add_argument(\"--author\", type=str, default=None)\n    ap.add_argument(\n        \"--grep\", type=str, default=None, help=\"Filter commit messages by regex\"\n    )\n    ap.add_argument(\n        \"--path\", type=str, default=None, help=\"Limit history to a path subtree\"\n    )\n    ap.add_argument(\"--max-commits\", type=int, default=500)\n    ap.add_argument(\"--per-batch\", type=int, default=128)\n    ap.add_argument(\n        \"--include-body\", action=\"store_true\", help=\"Include full body in text to embed\"\n    )\n    ap.add_argument(\n        \"--remote\",\n        type=str,\n        default=\"origin\",\n        help=\"Remote to fetch from if no local HEAD is present\",\n    )\n    ap.add_argument(\n        \"--manifest-json\",\n        type=str,\n        default=None,\n        help=\"Path to git history manifest JSON produced by upload client\",\n    )\n    ap.add_argument(\n        \"--fetch-depth\",\n        type=int,\n        default=1000,\n        help=\"Shallow fetch depth for history, when needed\",\n    )\n    args = ap.parse_args()\n\n    # Use embedder factory for Qwen3 support\n    if _EMBEDDER_FACTORY:\n        model = _get_embedding_model(MODEL_NAME)\n    else:\n        model = TextEmbedding(model_name=MODEL_NAME)\n    vec_name = _sanitize_vector_name(MODEL_NAME)\n    client = QdrantClient(url=QDRANT_URL, api_key=API_KEY or None)\n\n    if args.manifest_json:\n        _ingest_from_manifest(\n            args.manifest_json,\n            model,\n            client,\n            vec_name,\n            args.include_body,\n            args.per_batch,\n        )\n        return\n\n    commits = list_commits(args)\n    if not commits:\n        print(\"No commits matched filters.\")\n        return\n\n    points: List[models.PointStruct] = []\n    for sha in commits:\n        md = commit_metadata(sha)\n        text = build_text(md, include_body=args.include_body)\n        vec = next(model.embed([text])).tolist()\n        goal, sym, tgs = \"\", [], []\n        try:\n            diff = run(f\"git show --stat --patch --unified=3 {sha}\")\n            goal, sym, tgs = generate_commit_summary(md, diff)\n        except Exception:\n            pass\n\n        md_payload: Dict[str, Any] = {\n            \"language\": \"git\",\n            \"kind\": \"git_message\",\n            \"symbol\": md[\"commit_id\"],\n            \"symbol_path\": md[\"commit_id\"],\n            \"repo\": REPO_NAME,\n            \"commit_id\": md[\"commit_id\"],\n            \"author_name\": md[\"author_name\"],\n            \"authored_date\": md[\"authored_date\"],\n            \"message\": md[\"message\"],\n            \"files\": md[\"files\"],\n            \"path\": \".git\",\n            \"path_prefix\": \".git\",\n            \"ingested_at\": int(time.time()),\n        }\n        if goal:\n            md_payload[\"lineage_goal\"] = goal\n        if sym:\n            md_payload[\"lineage_symbols\"] = sym\n        if tgs:\n            md_payload[\"lineage_tags\"] = tgs\n\n        payload = {\n            \"document\": (\n                md.get(\"message\", \"\").splitlines()[0]\n                if md.get(\"message\")\n                else md[\"commit_id\"]\n            ),\n            \"information\": text[:512],\n            \"metadata\": md_payload,\n        }\n        pid = stable_id(md[\"commit_id\"])  # deterministic per-commit\n        point = models.PointStruct(id=pid, vector={vec_name: vec}, payload=payload)\n        points.append(point)\n        if len(points) >= args.per_batch:\n            client.upsert(collection_name=COLLECTION, points=points)\n            points.clear()\n    if points:\n        client.upsert(collection_name=COLLECTION, points=points)\n    print(f\"Ingested {len(commits)} commits into {COLLECTION}.\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}