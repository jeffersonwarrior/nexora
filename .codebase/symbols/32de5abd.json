{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/mcp/mcp.rs",
  "file_hash": "6d38c82129f8b18d5c34fce9ba820da8de8f3332",
  "updated_at": "2025-12-26T17:34:20.936885",
  "symbols": {
    "struct_McpConnections_24": {
      "name": "McpConnections",
      "type": "struct",
      "start_line": 24,
      "end_line": 27,
      "content_hash": "25be82409371dc3db8cf66ad10f8eccfd9420e92",
      "content": "pub struct McpConnections {\n    pub connections: HashMap<String, MCPConnection>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_McpConnections_28": {
      "name": "McpConnections",
      "type": "impl",
      "start_line": 28,
      "end_line": 28,
      "content_hash": "b1acbbe094724a6b739f494fbd7cc8845d4a6cdb",
      "content": "impl McpConnections {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_29": {
      "name": "new",
      "type": "method",
      "start_line": 29,
      "end_line": 34,
      "content_hash": "3825abfb7d7562299b46a32094420f86b0605b73",
      "content": "    pub fn new() -> Self {\n        Self {\n            connections: HashMap::new(),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_with_max_connections_35": {
      "name": "new_with_max_connections",
      "type": "method",
      "start_line": 35,
      "end_line": 40,
      "content_hash": "91937503b3730553102511795e9464e7e2899728",
      "content": "    pub fn new_with_max_connections(max_connections: usize) -> Self {\n        Self {\n            connections: HashMap::with_capacity(max_connections),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_connection_41": {
      "name": "add_connection",
      "type": "method",
      "start_line": 41,
      "end_line": 45,
      "content_hash": "7f69ea67b327cfa71754b4f4f6e9532da3c6b04f",
      "content": "    pub fn add_connection(&mut self, connection: MCPConnection) {\n        self.connections\n            .insert(connection.connection_id.clone(), connection);\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_remove_connection_46": {
      "name": "remove_connection",
      "type": "method",
      "start_line": 46,
      "end_line": 49,
      "content_hash": "591332438e75e11287174c598db72c9e13039744",
      "content": "    pub fn remove_connection(&mut self, connection_id: &str) -> Option<MCPConnection> {\n        self.connections.remove(connection_id)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_connection_50": {
      "name": "get_connection",
      "type": "method",
      "start_line": 50,
      "end_line": 53,
      "content_hash": "a772d83e572e7df7ddeff70f26866e4d386a51a3",
      "content": "    pub fn get_connection(&self, connection_id: &str) -> Option<&MCPConnection> {\n        self.connections.get(connection_id)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_connection_mut_54": {
      "name": "get_connection_mut",
      "type": "method",
      "start_line": 54,
      "end_line": 58,
      "content_hash": "2bd4201c02322b13fbac1ee48729edf89bf7916f",
      "content": "    pub fn get_connection_mut(&mut self, connection_id: &str) -> Option<&mut MCPConnection> {\n        self.connections.get_mut(connection_id)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_59": {
      "name": "Default",
      "type": "impl",
      "start_line": 59,
      "end_line": 59,
      "content_hash": "bab9d8b0b7442454b5362a16ea26da5aa1912598",
      "content": "impl Default for McpConnections {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_60": {
      "name": "default",
      "type": "method",
      "start_line": 60,
      "end_line": 64,
      "content_hash": "0bfc0b5dc630e980580df80d5e54d3932858b373",
      "content": "    fn default() -> Self {\n        Self::new()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_McpBackend_65": {
      "name": "McpBackend",
      "type": "struct",
      "start_line": 65,
      "end_line": 68,
      "content_hash": "1d385879c14717b6eaf24f02b9414cfb99ce3c94",
      "content": "pub struct McpBackend {\n    pub db: Arc<HelixGraphStorage>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_McpBackend_69": {
      "name": "McpBackend",
      "type": "impl",
      "start_line": 69,
      "end_line": 69,
      "content_hash": "2d52f5bde41cad5f247717622af40c5fd05ebadd",
      "content": "impl McpBackend {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_70": {
      "name": "new",
      "type": "method",
      "start_line": 70,
      "end_line": 76,
      "content_hash": "3da63501c9b2f699aa5fe6ec24faa6aa8e3622ff",
      "content": "    pub fn new(db: Arc<HelixGraphStorage>) -> Self {\n        Self { db }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"snake_case\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ToolCallRequest_77": {
      "name": "ToolCallRequest",
      "type": "struct",
      "start_line": 77,
      "end_line": 83,
      "content_hash": "aa2701353f3872350890093b6e611c876c757b3c",
      "content": "pub struct ToolCallRequest {\n    pub connection_id: String,\n    pub tool: ToolArgs,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"snake_case\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ResourceCallRequest_84": {
      "name": "ResourceCallRequest",
      "type": "struct",
      "start_line": 84,
      "end_line": 87,
      "content_hash": "f910ee11ed7359e24a35e0db920b261d1fae072e",
      "content": "pub struct ResourceCallRequest {\n    pub connection_id: String,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPConnection_88": {
      "name": "MCPConnection",
      "type": "struct",
      "start_line": 88,
      "end_line": 93,
      "content_hash": "9f3cca18530c08b71edf0ab67092a6ce244aeffe",
      "content": "pub struct MCPConnection {\n    pub connection_id: String,\n    pub query_chain: Vec<QueryStep>,\n    pub current_position: usize,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_MCPConnection_94": {
      "name": "MCPConnection",
      "type": "impl",
      "start_line": 94,
      "end_line": 94,
      "content_hash": "b854d11e1c65f4ce04b9abd5ee6299369446f067",
      "content": "impl MCPConnection {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_95": {
      "name": "new",
      "type": "method",
      "start_line": 95,
      "end_line": 102,
      "content_hash": "4cb3f5fcfb6e66c07ac494e1ba4e5b4ddbf0ae82",
      "content": "    pub fn new(connection_id: String) -> Self {\n        Self {\n            connection_id,\n            query_chain: Vec::new(),\n            current_position: 0,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_query_step_103": {
      "name": "add_query_step",
      "type": "method",
      "start_line": 103,
      "end_line": 107,
      "content_hash": "8413e13b46bfdca0dfa69db53813d4a490256da6",
      "content": "    pub fn add_query_step(&mut self, step: QueryStep) {\n        self.query_chain.push(step);\n        self.current_position = 0;\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_reset_position_108": {
      "name": "reset_position",
      "type": "method",
      "start_line": 108,
      "end_line": 111,
      "content_hash": "8d82f5ec789439a8f09879b4d63e5841bd0034dc",
      "content": "    pub fn reset_position(&mut self) {\n        self.current_position = 0;\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_clear_chain_112": {
      "name": "clear_chain",
      "type": "method",
      "start_line": 112,
      "end_line": 136,
      "content_hash": "2b1914c3291cace035688d0e791501969e58c4bc",
      "content": "    pub fn clear_chain(&mut self) {\n        self.query_chain.clear();\n        self.reset_position();\n    }\n\n    pub fn next_item<'db, 'arena>(\n        &mut self,\n        db: &'db HelixGraphStorage,\n        arena: &'arena Bump,\n    ) -> Result<TraversalValue<'arena>, GraphError>\n    where\n        'db: 'arena,\n    {\n        let txn = db.graph_env.read_txn()?;\n        let stream = execute_query_chain(&self.query_chain, db, &txn, arena)?;\n        match stream.nth(self.current_position)? {\n            Some(value) => {\n                self.current_position += 1;\n                Ok(value)\n            }\n            None => Ok(TraversalValue::Empty),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPToolInput_137": {
      "name": "MCPToolInput",
      "type": "struct",
      "start_line": 137,
      "end_line": 149,
      "content_hash": "605cd9806bd717a78acf02319eae71410c25769a",
      "content": "pub struct MCPToolInput {\n    pub request: Request,\n    pub mcp_backend: Arc<McpBackend>,\n    pub mcp_connections: Arc<Mutex<McpConnections>>,\n    pub schema: Option<String>,\n}\n\npub type BasicMCPHandlerFn = for<'a> fn(&'a mut MCPToolInput) -> Result<Response, GraphError>;\n\npub type MCPHandlerFn =\n    Arc<dyn for<'a> Fn(&'a mut MCPToolInput) -> Result<Response, GraphError> + Send + Sync>;\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPHandlerSubmission_150": {
      "name": "MCPHandlerSubmission",
      "type": "struct",
      "start_line": 150,
      "end_line": 152,
      "content_hash": "d59e60202dc4cdfb2893e45ef55aee9371dc9d67",
      "content": "pub struct MCPHandlerSubmission(pub MCPHandler);\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPHandler_153": {
      "name": "MCPHandler",
      "type": "struct",
      "start_line": 153,
      "end_line": 157,
      "content_hash": "f070d82e0a5abcdc5a13ca4a322b5a3ad1b5dd49",
      "content": "pub struct MCPHandler {\n    pub name: &'static str,\n    pub func: BasicMCPHandlerFn,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_MCPHandler_158": {
      "name": "MCPHandler",
      "type": "impl",
      "start_line": 158,
      "end_line": 166,
      "content_hash": "06d35ebbdeaedb5d7f0d4d2f039d023ecd5c152d",
      "content": "impl MCPHandler {\n    pub const fn new(name: &'static str, func: BasicMCPHandlerFn) -> Self {\n        Self { name, func }\n    }\n}\n\ninventory::collect!(MCPHandlerSubmission);\n\n/// Helper function to execute a tool step on a connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_execute_tool_step_167": {
      "name": "execute_tool_step",
      "type": "method",
      "start_line": 167,
      "end_line": 263,
      "content_hash": "4111a64452e782e39fe7414be5cb9d84272fc439",
      "content": "fn execute_tool_step(\n    input: &mut MCPToolInput,\n    connection_id: &str,\n    tool: ToolArgs,\n) -> Result<Response, GraphError> {\n    tracing::debug!(\n        \"[EXECUTE_TOOL_STEP] Starting with connection_id: {}\",\n        connection_id\n    );\n\n    // Clone necessary data while holding the lock\n    let query_chain = {\n        tracing::debug!(\"[EXECUTE_TOOL_STEP] Acquiring connection lock\");\n        let mut connections = input.mcp_connections.lock().unwrap();\n\n        tracing::debug!(\n            \"[EXECUTE_TOOL_STEP] Available connections: {:?}\",\n            connections.connections.keys().collect::<Vec<_>>()\n        );\n\n        let connection = connections\n            .get_connection_mut(connection_id)\n            .ok_or_else(|| {\n                tracing::error!(\n                    \"[EXECUTE_TOOL_STEP] Connection not found: {}\",\n                    connection_id\n                );\n                GraphError::StorageError(format!(\"Connection not found: {}\", connection_id))\n            })?;\n\n        tracing::debug!(\n            \"[EXECUTE_TOOL_STEP] Adding query step, current chain length: {}\",\n            connection.query_chain.len()\n        );\n        connection.add_query_step(tool);\n        connection.query_chain.clone()\n    };\n\n    tracing::debug!(\n        \"[EXECUTE_TOOL_STEP] Executing query chain with {} steps\",\n        query_chain.len()\n    );\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn().map_err(|e| {\n        tracing::error!(\n            \"[EXECUTE_TOOL_STEP] Failed to create read transaction: {:?}\",\n            e\n        );\n        e\n    })?;\n\n    let stream = execute_query_chain(&query_chain, storage, &txn, &arena).map_err(|e| {\n        tracing::error!(\"[EXECUTE_TOOL_STEP] Failed to execute query chain: {:?}\", e);\n        e\n    })?;\n\n    let mut iter = stream.into_inner_iter();\n\n    let (first, consumed_one) = match iter.next() {\n        Some(value) => {\n            let val = value.map_err(|e| {\n                tracing::error!(\"[EXECUTE_TOOL_STEP] Error getting first value: {:?}\", e);\n                e\n            })?;\n            (val, true)\n        }\n        None => (TraversalValue::Empty, false),\n    };\n\n    tracing::debug!(\n        \"[EXECUTE_TOOL_STEP] Got first result, consumed: {}\",\n        consumed_one\n    );\n\n    // Update connection state\n    {\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(connection_id)\n            .ok_or_else(|| {\n                tracing::error!(\n                    \"[EXECUTE_TOOL_STEP] Connection not found when updating state: {}\",\n                    connection_id\n                );\n                GraphError::StorageError(format!(\"Connection not found: {}\", connection_id))\n            })?;\n        connection.current_position = if consumed_one { 1 } else { 0 };\n    }\n\n    tracing::debug!(\"[EXECUTE_TOOL_STEP] Successfully completed\");\n    Ok(Format::Json.create_response(&first))\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InitRequest_264": {
      "name": "InitRequest",
      "type": "struct",
      "start_line": 264,
      "end_line": 269,
      "content_hash": "c12274a90e8461135fcd8b45595b7664c623b4d3",
      "content": "pub struct InitRequest {\n    pub connection_addr: String,\n    pub connection_port: u16,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_init_270": {
      "name": "init",
      "type": "method",
      "start_line": 270,
      "end_line": 278,
      "content_hash": "2ae0cf414c847777618a548d7ef2be7ba640f47e",
      "content": "pub fn init(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let connection_id = uuid::Uuid::from_u128(v6_uuid()).to_string();\n    let mut connections = input.mcp_connections.lock().unwrap();\n    connections.add_connection(MCPConnection::new(connection_id.clone()));\n    drop(connections);\n    Ok(Format::Json.create_response(&connection_id))\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tool_call_279": {
      "name": "tool_call",
      "type": "method",
      "start_line": 279,
      "end_line": 288,
      "content_hash": "67a5f0da2abaca4d65546c83977b692b73452e1d",
      "content": "pub fn tool_call(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: ToolCallRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    execute_tool_step(input, &data.connection_id, data.tool)\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NextRequest_289": {
      "name": "NextRequest",
      "type": "struct",
      "start_line": 289,
      "end_line": 293,
      "content_hash": "85f005874d9f778e76904674fec39fcf711ca1d3",
      "content": "pub struct NextRequest {\n    pub connection_id: String,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_294": {
      "name": "next",
      "type": "method",
      "start_line": 294,
      "end_line": 380,
      "content_hash": "56c41fbe153bd45914ee72434d74074f21370787",
      "content": "pub fn next(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: NextRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => {\n            tracing::error!(\"[NEXT] Failed to parse request: {:?}\", err);\n            return Err(GraphError::from(err));\n        }\n    };\n\n    tracing::debug!(\"[NEXT] Processing for connection: {}\", data.connection_id);\n\n    // Clone necessary data while holding the lock\n    let (query_chain, current_position) = {\n        let connections = input.mcp_connections.lock().unwrap();\n        tracing::debug!(\n            \"[NEXT] Available connections: {:?}\",\n            connections.connections.keys().collect::<Vec<_>>()\n        );\n\n        let connection = connections\n            .get_connection(&data.connection_id)\n            .ok_or_else(|| {\n                tracing::error!(\"[NEXT] Connection not found: {}\", data.connection_id);\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n        (connection.query_chain.clone(), connection.current_position)\n    };\n\n    tracing::debug!(\n        \"[NEXT] Current position: {}, chain length: {}\",\n        current_position,\n        query_chain.len()\n    );\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn().map_err(|e| {\n        tracing::error!(\"[NEXT] Failed to create read transaction: {:?}\", e);\n        e\n    })?;\n\n    let stream = execute_query_chain(&query_chain, storage, &txn, &arena).map_err(|e| {\n        tracing::error!(\"[NEXT] Failed to execute query chain: {:?}\", e);\n        e\n    })?;\n\n    let next_value = match stream.nth(current_position).map_err(|e| {\n        tracing::error!(\n            \"[NEXT] Error iterating to position {}: {:?}\",\n            current_position,\n            e\n        );\n        e\n    })? {\n        Some(value) => {\n            // Update current_position\n            let mut connections = input.mcp_connections.lock().unwrap();\n            let connection = connections\n                .get_connection_mut(&data.connection_id)\n                .ok_or_else(|| {\n                    tracing::error!(\n                        \"[NEXT] Connection not found when updating position: {}\",\n                        data.connection_id\n                    );\n                    GraphError::StorageError(format!(\n                        \"Connection not found: {}\",\n                        data.connection_id\n                    ))\n                })?;\n            connection.current_position += 1;\n            tracing::debug!(\n                \"[NEXT] Updated position to: {}\",\n                connection.current_position\n            );\n            value\n        }\n        None => {\n            tracing::debug!(\"[NEXT] No more values, returning Empty\");\n            TraversalValue::Empty\n        }\n    };\n\n    Ok(Format::Json.create_response(&next_value))\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Range_381": {
      "name": "Range",
      "type": "struct",
      "start_line": 381,
      "end_line": 386,
      "content_hash": "02e9d32db5ba3bb38cbe115eae6d5286432fa36a",
      "content": "pub struct Range {\n    pub start: usize,\n    pub end: usize,\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CollectRequest_387": {
      "name": "CollectRequest",
      "type": "struct",
      "start_line": 387,
      "end_line": 393,
      "content_hash": "1abec60d7ec56fc6c2d3e83bb0b3ebf38e18168c",
      "content": "pub struct CollectRequest {\n    pub connection_id: String,\n    pub range: Option<Range>,\n    pub drop: Option<bool>,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_collect_394": {
      "name": "collect",
      "type": "method",
      "start_line": 394,
      "end_line": 452,
      "content_hash": "0cea463c673468e3fab7c041123469a97e4cbcc5",
      "content": "pub fn collect(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: CollectRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    // Clone necessary data while holding the lock\n    let query_chain = {\n        let connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n        connection.query_chain.clone()\n    };\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn()?;\n    let stream = execute_query_chain(&query_chain, storage, &txn, &arena)?;\n    let iter = stream.into_inner_iter();\n\n    let range = data.range;\n    let start = range.as_ref().map(|r| r.start).unwrap_or(0);\n    let end = range.as_ref().map(|r| r.end);\n\n    let mut values = Vec::new();\n    for (index, item) in iter.enumerate() {\n        let item = item?;\n        if index >= start {\n            if let Some(end) = end\n                && index >= end\n            {\n                break;\n            }\n            values.push(item);\n        }\n    }\n\n    // Update connection state\n    {\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n\n        if data.drop.unwrap_or(true) {\n            connection.clear_chain();\n        }\n    }\n\n    Ok(Format::Json.create_response(&values))\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AggregateRequest_453": {
      "name": "AggregateRequest",
      "type": "struct",
      "start_line": 453,
      "end_line": 459,
      "content_hash": "11c7a898c1a4709b7b4f85f2ba9251a3b145d10a",
      "content": "pub struct AggregateRequest {\n    pub connection_id: String,\n    properties: Vec<String>,\n    pub drop: Option<bool>,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_aggregate_by_460": {
      "name": "aggregate_by",
      "type": "method",
      "start_line": 460,
      "end_line": 505,
      "content_hash": "3073e3054aef23ce361983beb381c4ebb6374749",
      "content": "pub fn aggregate_by(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: AggregateRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    // Clone necessary data while holding the lock\n    let query_chain = {\n        let connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n        connection.query_chain.clone()\n    };\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn()?;\n    let stream = execute_query_chain(&query_chain, storage, &txn, &arena)?;\n\n    let aggregation = stream\n        .into_ro()\n        .aggregate_by(&data.properties, true)?\n        .into_count();\n\n    // Update connection state\n    {\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n\n        if data.drop.unwrap_or(true) {\n            connection.clear_chain();\n        }\n    }\n\n    Ok(Format::Json.create_response(&aggregation))\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_group_by_506": {
      "name": "group_by",
      "type": "method",
      "start_line": 506,
      "end_line": 551,
      "content_hash": "2f03c4d89305b077aabe9bfdc247719174bad214",
      "content": "pub fn group_by(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: AggregateRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    // Clone necessary data while holding the lock\n    let query_chain = {\n        let connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n        connection.query_chain.clone()\n    };\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn()?;\n    let stream = execute_query_chain(&query_chain, storage, &txn, &arena)?;\n\n    let aggregation = stream\n        .into_ro()\n        .group_by(&data.properties, true)?\n        .into_count();\n\n    // Update connection state\n    {\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(&data.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n            })?;\n\n        if data.drop.unwrap_or(true) {\n            connection.clear_chain();\n        }\n    }\n\n    Ok(Format::Json.create_response(&aggregation))\n}\n\n#[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ResetRequest_552": {
      "name": "ResetRequest",
      "type": "struct",
      "start_line": 552,
      "end_line": 556,
      "content_hash": "28f5fe81348001c17742fa0867ccfe8cabdcb6c8",
      "content": "pub struct ResetRequest {\n    pub connection_id: String,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_reset_557": {
      "name": "reset",
      "type": "method",
      "start_line": 557,
      "end_line": 577,
      "content_hash": "4ea3287e0ac1488615fcbf464d6606081d6cba28",
      "content": "pub fn reset(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: ResetRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let mut connections = input.mcp_connections.lock().unwrap();\n    let connection = connections\n        .get_connection_mut(&data.connection_id)\n        .ok_or_else(|| {\n            GraphError::StorageError(format!(\"Connection not found: {}\", data.connection_id))\n        })?;\n\n    connection.clear_chain();\n    let connection_id = connection.connection_id.clone();\n    drop(connections);\n\n    Ok(Format::Json.create_response(&connection_id))\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_schema_resource_578": {
      "name": "schema_resource",
      "type": "method",
      "start_line": 578,
      "end_line": 599,
      "content_hash": "e1afafef20b2d6beb60b48795ad43f7caccadf04",
      "content": "pub fn schema_resource(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let data: ResourceCallRequest = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let connections = input.mcp_connections.lock().unwrap();\n    if !connections.connections.contains_key(&data.connection_id) {\n        return Err(GraphError::StorageError(\"Connection not found\".to_string()));\n    }\n    drop(connections);\n\n    if let Some(schema) = &input.schema {\n        Ok(Format::Json.create_response(&schema.clone()))\n    } else {\n        Ok(Format::Json.create_response(&\"no schema\".to_string()))\n    }\n}\n\n// Individual tool endpoint handlers\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OutStepData_600": {
      "name": "OutStepData",
      "type": "struct",
      "start_line": 600,
      "end_line": 606,
      "content_hash": "ff5563d596f8ea3300e53e52963f946c6fe7e855",
      "content": "pub struct OutStepData {\n    pub edge_label: String,\n    pub edge_type: EdgeType,\n    pub filter: Option<FilterTraversal>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OutStepInput_607": {
      "name": "OutStepInput",
      "type": "struct",
      "start_line": 607,
      "end_line": 612,
      "content_hash": "2024a1df953d808fbfbb44aa6e23bae3783adac7",
      "content": "pub struct OutStepInput {\n    pub connection_id: String,\n    pub data: OutStepData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_step_613": {
      "name": "out_step",
      "type": "method",
      "start_line": 613,
      "end_line": 628,
      "content_hash": "9b7feb2db545980e985f1afe7bb831275ab95a9b",
      "content": "pub fn out_step(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: OutStepInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::OutStep {\n        edge_label: req.data.edge_label,\n        edge_type: req.data.edge_type,\n        filter: req.data.filter,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InStepData_629": {
      "name": "InStepData",
      "type": "struct",
      "start_line": 629,
      "end_line": 635,
      "content_hash": "d94c73dcf98b0b5eaf2fa5bc88062815b043df30",
      "content": "pub struct InStepData {\n    pub edge_label: String,\n    pub edge_type: EdgeType,\n    pub filter: Option<FilterTraversal>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InStepInput_636": {
      "name": "InStepInput",
      "type": "struct",
      "start_line": 636,
      "end_line": 641,
      "content_hash": "ac9ab22be306896def3b3db63f24e2aabc20910c",
      "content": "pub struct InStepInput {\n    pub connection_id: String,\n    pub data: InStepData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_step_642": {
      "name": "in_step",
      "type": "method",
      "start_line": 642,
      "end_line": 657,
      "content_hash": "1d07a63a323bb402e4759ca7bae50e540368d90a",
      "content": "pub fn in_step(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: InStepInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::InStep {\n        edge_label: req.data.edge_label,\n        edge_type: req.data.edge_type,\n        filter: req.data.filter,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OutEStepData_658": {
      "name": "OutEStepData",
      "type": "struct",
      "start_line": 658,
      "end_line": 663,
      "content_hash": "ffa744291e21e895b2e6ffb31c570e5018d33751",
      "content": "pub struct OutEStepData {\n    pub edge_label: String,\n    pub filter: Option<FilterTraversal>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OutEStepInput_664": {
      "name": "OutEStepInput",
      "type": "struct",
      "start_line": 664,
      "end_line": 669,
      "content_hash": "58721aeeeb6a5b406162984e916a094b698e457e",
      "content": "pub struct OutEStepInput {\n    pub connection_id: String,\n    pub data: OutEStepData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_e_step_670": {
      "name": "out_e_step",
      "type": "method",
      "start_line": 670,
      "end_line": 684,
      "content_hash": "c85b80aa1ce8bf57564a8c476b16896f131b39ec",
      "content": "pub fn out_e_step(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: OutEStepInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::OutEStep {\n        edge_label: req.data.edge_label,\n        filter: req.data.filter,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InEStepData_685": {
      "name": "InEStepData",
      "type": "struct",
      "start_line": 685,
      "end_line": 690,
      "content_hash": "5072568148cb32a9e57ab7fd3cca2d4ce652514d",
      "content": "pub struct InEStepData {\n    pub edge_label: String,\n    pub filter: Option<FilterTraversal>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InEStepInput_691": {
      "name": "InEStepInput",
      "type": "struct",
      "start_line": 691,
      "end_line": 696,
      "content_hash": "fe5af8af4e5f54d14cbda69cab4d29a0f7004ab4",
      "content": "pub struct InEStepInput {\n    pub connection_id: String,\n    pub data: InEStepData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_e_step_697": {
      "name": "in_e_step",
      "type": "method",
      "start_line": 697,
      "end_line": 711,
      "content_hash": "a9c8ae1ec857612be688b16da935684930ed00db",
      "content": "pub fn in_e_step(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: InEStepInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::InEStep {\n        edge_label: req.data.edge_label,\n        filter: req.data.filter,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NFromTypeData_712": {
      "name": "NFromTypeData",
      "type": "struct",
      "start_line": 712,
      "end_line": 716,
      "content_hash": "cf99470efe310aadc291278598653bb565ea4afd",
      "content": "pub struct NFromTypeData {\n    pub node_type: String,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NFromTypeInput_717": {
      "name": "NFromTypeInput",
      "type": "struct",
      "start_line": 717,
      "end_line": 722,
      "content_hash": "82718df2328131d3a2864fe096746b626a28ff46",
      "content": "pub struct NFromTypeInput {\n    pub connection_id: String,\n    pub data: NFromTypeData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_n_from_type_723": {
      "name": "n_from_type",
      "type": "method",
      "start_line": 723,
      "end_line": 736,
      "content_hash": "94655824e1f3ae1b24c46bdac23da5b750fc3cb3",
      "content": "pub fn n_from_type(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: NFromTypeInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::NFromType {\n        node_type: req.data.node_type,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EFromTypeData_737": {
      "name": "EFromTypeData",
      "type": "struct",
      "start_line": 737,
      "end_line": 741,
      "content_hash": "bfb6e43f4b8acd461bfc7c497c3d7223af1cb396",
      "content": "pub struct EFromTypeData {\n    pub edge_type: String,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EFromTypeInput_742": {
      "name": "EFromTypeInput",
      "type": "struct",
      "start_line": 742,
      "end_line": 747,
      "content_hash": "449c11465dcba69a7f96b95007b26083a8939dfe",
      "content": "pub struct EFromTypeInput {\n    pub connection_id: String,\n    pub data: EFromTypeData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_e_from_type_748": {
      "name": "e_from_type",
      "type": "method",
      "start_line": 748,
      "end_line": 761,
      "content_hash": "9985d75aae660edc3f1ee81f01a80c1028d8e348",
      "content": "pub fn e_from_type(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: EFromTypeInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::EFromType {\n        edge_type: req.data.edge_type,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FilterItemsData_762": {
      "name": "FilterItemsData",
      "type": "struct",
      "start_line": 762,
      "end_line": 767,
      "content_hash": "1ac6e2c44c71776d960471055497042eddc6d5a0",
      "content": "pub struct FilterItemsData {\n    #[serde(default)]\n    pub filter: FilterTraversal,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FilterItemsInput_768": {
      "name": "FilterItemsInput",
      "type": "struct",
      "start_line": 768,
      "end_line": 773,
      "content_hash": "15858ad2f7d2db9fd4c47e94c51cb84969c1b17e",
      "content": "pub struct FilterItemsInput {\n    pub connection_id: String,\n    pub data: FilterItemsData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_filter_items_774": {
      "name": "filter_items",
      "type": "method",
      "start_line": 774,
      "end_line": 787,
      "content_hash": "f1d112a572fde33c3b3aeb53c92d42b1d636fb46",
      "content": "pub fn filter_items(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: FilterItemsInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::FilterItems {\n        filter: req.data.filter,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OrderByData_788": {
      "name": "OrderByData",
      "type": "struct",
      "start_line": 788,
      "end_line": 793,
      "content_hash": "a93b1e5001cc41663482e4d6b87752adaea1acac",
      "content": "pub struct OrderByData {\n    pub properties: String,\n    pub order: Order,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OrderByInput_794": {
      "name": "OrderByInput",
      "type": "struct",
      "start_line": 794,
      "end_line": 799,
      "content_hash": "b8ecfc6347c0d6684372c47667a2a895e907837f",
      "content": "pub struct OrderByInput {\n    pub connection_id: String,\n    pub data: OrderByData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_order_by_800": {
      "name": "order_by",
      "type": "method",
      "start_line": 800,
      "end_line": 814,
      "content_hash": "0aa0d3b67f070c3b0f74235aa31b67f087dfa4f1",
      "content": "pub fn order_by(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: OrderByInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::OrderBy {\n        properties: req.data.properties,\n        order: req.data.order,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchKeywordData_815": {
      "name": "SearchKeywordData",
      "type": "struct",
      "start_line": 815,
      "end_line": 821,
      "content_hash": "ebced269916c5a943877c8241e67151763db6f47",
      "content": "pub struct SearchKeywordData {\n    pub query: String,\n    pub limit: usize,\n    pub label: String,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchKeywordInput_822": {
      "name": "SearchKeywordInput",
      "type": "struct",
      "start_line": 822,
      "end_line": 827,
      "content_hash": "a1d12a62b62847fccfab9a07631a36892bd49282",
      "content": "pub struct SearchKeywordInput {\n    pub connection_id: String,\n    pub data: SearchKeywordData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_search_keyword_828": {
      "name": "search_keyword",
      "type": "method",
      "start_line": 828,
      "end_line": 878,
      "content_hash": "d62341fa98390a155feb6b915bfabac4407a9b59",
      "content": "pub fn search_keyword(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    use crate::helix_engine::traversal_core::ops::{bm25::search_bm25::SearchBM25Adapter, g::G};\n\n    let req: SearchKeywordInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    // Verify connection exists\n    {\n        let connections = input.mcp_connections.lock().unwrap();\n        connections\n            .get_connection(&req.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", req.connection_id))\n            })?;\n    }\n\n    // Execute long-running operation without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn()?;\n\n    // Perform BM25 search using the existing index\n    let results = G::new(storage, &txn, &arena)\n        .search_bm25(&req.data.label, &req.data.query, req.data.limit)?\n        .collect::<Result<Vec<_>, _>>()?;\n\n    let (first, consumed_one) = match results.first() {\n        Some(value) => (value.clone(), true),\n        None => (TraversalValue::Empty, false),\n    };\n\n    // Update connection state\n    {\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(&req.connection_id)\n            .ok_or_else(|| {\n                GraphError::StorageError(format!(\"Connection not found: {}\", req.connection_id))\n            })?;\n\n        // Store remaining results for pagination\n        connection.current_position = if consumed_one { 1 } else { 0 };\n        // Note: For search_keyword, we don't update the query_chain since it's a starting operation\n    }\n\n    Ok(Format::Json.create_response(&first))\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchVectorTextData_879": {
      "name": "SearchVectorTextData",
      "type": "struct",
      "start_line": 879,
      "end_line": 885,
      "content_hash": "80064da5f2f82e2d38350c4f273c44517ff3c103",
      "content": "pub struct SearchVectorTextData {\n    pub query: String,\n    pub label: String,\n    pub k: Option<usize>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchVectorTextInput_886": {
      "name": "SearchVectorTextInput",
      "type": "struct",
      "start_line": 886,
      "end_line": 891,
      "content_hash": "3cd33ad8555f5abb1b0a568829d95508d2fefd6e",
      "content": "pub struct SearchVectorTextInput {\n    pub connection_id: String,\n    pub data: SearchVectorTextData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_search_vector_text_892": {
      "name": "search_vector_text",
      "type": "method",
      "start_line": 892,
      "end_line": 1013,
      "content_hash": "52efae2b481b94c380b018f3b0e498c909bd4f2f",
      "content": "pub fn search_vector_text(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    use crate::helix_engine::traversal_core::ops::{g::G, vectors::search::SearchVAdapter};\n    use crate::helix_gateway::embedding_providers::{EmbeddingModel, get_embedding_model};\n\n    let req: SearchVectorTextInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => {\n            tracing::error!(\"[VECTOR_SEARCH] Failed to parse request: {:?}\", err);\n            return Err(GraphError::from(err));\n        }\n    };\n\n    tracing::debug!(\n        \"[VECTOR_SEARCH] Starting search for connection: {}, query: {}, label: {}, k: {:?}\",\n        req.connection_id,\n        req.data.query,\n        req.data.label,\n        req.data.k\n    );\n\n    // Verify connection exists\n    {\n        tracing::debug!(\"[VECTOR_SEARCH] Verifying connection exists\");\n        let connections = input.mcp_connections.lock().unwrap();\n        tracing::debug!(\n            \"[VECTOR_SEARCH] Available connections: {:?}\",\n            connections.connections.keys().collect::<Vec<_>>()\n        );\n\n        connections\n            .get_connection(&req.connection_id)\n            .ok_or_else(|| {\n                tracing::error!(\n                    \"[VECTOR_SEARCH] Connection not found: {}\",\n                    req.connection_id\n                );\n                GraphError::StorageError(format!(\"Connection not found: {}\", req.connection_id))\n            })?;\n    }\n\n    tracing::debug!(\"[VECTOR_SEARCH] Connection verified, starting long-running operations\");\n\n    // Execute long-running operations without holding the lock\n    let arena = Bump::new();\n    let storage = input.mcp_backend.db.as_ref();\n    let txn = storage.graph_env.read_txn().map_err(|e| {\n        tracing::error!(\"[VECTOR_SEARCH] Failed to create read transaction: {:?}\", e);\n        e\n    })?;\n\n    // Get embedding model and convert query text to vector\n    tracing::debug!(\"[VECTOR_SEARCH] Getting embedding model\");\n    let embedding_model = get_embedding_model(None, None, None).map_err(|e| {\n        tracing::error!(\"[VECTOR_SEARCH] Failed to get embedding model: {:?}\", e);\n        e\n    })?;\n\n    tracing::debug!(\"[VECTOR_SEARCH] Fetching embedding for query text\");\n    let query_embedding = embedding_model\n        .fetch_embedding(&req.data.query)\n        .map_err(|e| {\n            tracing::error!(\"[VECTOR_SEARCH] Failed to fetch embedding: {:?}\", e);\n            e\n        })?;\n    let query_vec_arena = arena.alloc_slice_copy(&query_embedding);\n\n    // Perform vector search\n    let k_value = req.data.k.unwrap_or(10);\n    let label_arena = arena.alloc_str(&req.data.label);\n\n    tracing::debug!(\n        \"[VECTOR_SEARCH] Performing vector search with k={}\",\n        k_value\n    );\n    let results = G::new(storage, &txn, &arena)\n        .search_v::<fn(&crate::helix_engine::vector_core::vector::HVector, &heed3::RoTxn) -> bool, _>(\n            query_vec_arena,\n            k_value,\n            label_arena,\n            None\n        )\n        .collect::<Result<Vec<_>,_>>()?;\n\n    tracing::debug!(\"[VECTOR_SEARCH] Search returned {} results\", results.len());\n\n    let (first, consumed_one) = match results.first() {\n        Some(value) => {\n            tracing::debug!(\"[VECTOR_SEARCH] Returning first result\");\n            (value.clone(), true)\n        }\n        None => {\n            tracing::debug!(\"[VECTOR_SEARCH] No results found, returning Empty\");\n            (TraversalValue::Empty, false)\n        }\n    };\n\n    // Update connection state\n    {\n        tracing::debug!(\"[VECTOR_SEARCH] Updating connection state\");\n        let mut connections = input.mcp_connections.lock().unwrap();\n        let connection = connections\n            .get_connection_mut(&req.connection_id)\n            .ok_or_else(|| {\n                tracing::error!(\n                    \"[VECTOR_SEARCH] Connection not found when updating state: {}\",\n                    req.connection_id\n                );\n                GraphError::StorageError(format!(\"Connection not found: {}\", req.connection_id))\n            })?;\n\n        connection.current_position = if consumed_one { 1 } else { 0 };\n        tracing::debug!(\n            \"[VECTOR_SEARCH] Updated position to: {}\",\n            connection.current_position\n        );\n    }\n\n    tracing::debug!(\"[VECTOR_SEARCH] Successfully completed\");\n    Ok(Format::Json.create_response(&first))\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchVectorData_1014": {
      "name": "SearchVectorData",
      "type": "struct",
      "start_line": 1014,
      "end_line": 1020,
      "content_hash": "5ad4acab51f3c183006f0aa8300dde7dc8ffffab",
      "content": "pub struct SearchVectorData {\n    pub vector: Vec<f64>,\n    pub k: usize,\n    pub min_score: Option<f64>,\n}\n\n#[derive(Debug, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SearchVectorInput_1021": {
      "name": "SearchVectorInput",
      "type": "struct",
      "start_line": 1021,
      "end_line": 1026,
      "content_hash": "6d9380ab18148d0fd6548f484135b3df73bc9e8d",
      "content": "pub struct SearchVectorInput {\n    pub connection_id: String,\n    pub data: SearchVectorData,\n}\n\n#[mcp_handler]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_search_vector_1027": {
      "name": "search_vector",
      "type": "method",
      "start_line": 1027,
      "end_line": 1041,
      "content_hash": "ee4717f67458bd6b6b03a71272cb68e70d18286a",
      "content": "pub fn search_vector(input: &mut MCPToolInput) -> Result<Response, GraphError> {\n    let req: SearchVectorInput = match sonic_rs::from_slice(&input.request.body) {\n        Ok(data) => data,\n        Err(err) => return Err(GraphError::from(err)),\n    };\n\n    let tool = ToolArgs::SearchVec {\n        vector: req.data.vector,\n        k: req.data.k,\n        min_score: req.data.min_score,\n        cutoff: None,\n    };\n\n    execute_tool_step(input, &req.connection_id, tool)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}