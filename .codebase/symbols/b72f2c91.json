{
  "file_path": "/work/internal/tui/tui.go",
  "file_hash": "98eca69a161b07b10c2266c3a6928e23fd7a450c",
  "updated_at": "2025-12-26T17:34:22.738020",
  "symbols": {
    "function_MouseEventFilter_60": {
      "name": "MouseEventFilter",
      "type": "function",
      "start_line": 60,
      "end_line": 73,
      "content_hash": "5a412937ec2486a20eff0b1a1d249d9839d81876",
      "content": "func MouseEventFilter(m tea.Model, msg tea.Msg) tea.Msg {\n\tswitch msg.(type) {\n\tcase tea.MouseWheelMsg, tea.MouseMotionMsg:\n\t\tnow := time.Now()\n\t\t// trackpad is sending too many requests\n\t\tif now.Sub(lastMouseEvent) < mouseEventDebounceDelay {\n\t\t\treturn nil\n\t\t}\n\t\tlastMouseEvent = now\n\t}\n\treturn msg\n}\n\n// appModel represents the main application model that manages pages, dialogs, and UI state.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_appModel_74": {
      "name": "appModel",
      "type": "struct",
      "start_line": 74,
      "end_line": 106,
      "content_hash": "d5dc8cfa3c18350b84e63fddb3140a8044b49fac",
      "content": "type appModel struct {\n\twWidth, wHeight int // Window dimensions\n\twidth, height   int\n\tkeyMap          KeyMap\n\n\tcurrentPage  page.PageID\n\tpreviousPage page.PageID\n\tpages        map[page.PageID]util.Model\n\tloadedPages  map[page.PageID]bool\n\n\t// Status\n\tstatus          status.StatusCmp\n\tshowingFullHelp bool\n\n\tapp *app.App\n\n\tdialog       dialogs.DialogCmp\n\tcompletions  completions.Completions\n\tisConfigured bool\n\n\t// Chat Page Specific\n\tselectedSessionID string // The ID of the currently selected session\n\n\t// sendProgressBar instructs the TUI to send progress bar updates to the\n\t// terminal.\n\tsendProgressBar bool\n\n\t// QueryVersion instructs the TUI to query for the terminal version when it\n\t// starts.\n\tQueryVersion bool\n}\n\n// Init initializes the application model and returns initial commands.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_107": {
      "name": "Init",
      "type": "method",
      "start_line": 107,
      "end_line": 137,
      "content_hash": "658e62717a244724c7b908bce9b55e8f8da972c5",
      "content": "func (a appModel) Init() tea.Cmd {\n\tvar cmds []tea.Cmd\n\n\t// Check if models need setup and show model dialog if necessary\n\tif a.app.Config().ModelsNeedSetup() {\n\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\treturn dialogs.OpenDialogMsg{\n\t\t\t\tModel: models.NewModelDialogCmp(),\n\t\t\t}\n\t\t})\n\t}\n\n\titem, ok := a.pages[a.currentPage]\n\tif !ok {\n\t\treturn tea.Batch(cmds...)\n\t}\n\n\tcmd := item.Init()\n\tcmds = append(cmds, cmd)\n\ta.loadedPages[a.currentPage] = true\n\n\tcmd = a.status.Init()\n\tcmds = append(cmds, cmd)\n\tif a.QueryVersion {\n\t\tcmds = append(cmds, tea.RequestTerminalVersion)\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// Update handles incoming messages and updates the application state.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_138": {
      "name": "Update",
      "type": "method",
      "start_line": 138,
      "end_line": 449,
      "content_hash": "d332a67e8d6824901af995d9b547ae8b6d5b9df9",
      "content": "func (a *appModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\t// Context for update operations - using background context since this is UI-driven\n\tctx := context.Background()\n\tvar cmds []tea.Cmd\n\tvar cmd tea.Cmd\n\ta.isConfigured = config.HasInitialDataConfig()\n\n\tswitch msg := msg.(type) {\n\tcase tea.EnvMsg:\n\t\t// Is this Windows Terminal?\n\t\tif !a.sendProgressBar {\n\t\t\ta.sendProgressBar = slices.Contains(msg, \"WT_SESSION\")\n\t\t}\n\tcase tea.TerminalVersionMsg:\n\t\tif a.sendProgressBar {\n\t\t\treturn a, nil\n\t\t}\n\t\ttermVersion := strings.ToLower(msg.Name)\n\t\tswitch {\n\t\tcase stringext.ContainsAny(termVersion, \"ghostty\", \"rio\"):\n\t\t\ta.sendProgressBar = true\n\t\tcase strings.Contains(termVersion, \"iterm2\"):\n\t\t\t// iTerm2 supports progress bars from version v3.6.6\n\t\t\tmatches := regexp.MustCompile(`^iterm2 (\\d+\\.\\d+\\.\\d+)$`).FindStringSubmatch(termVersion)\n\t\t\tif len(matches) == 2 && semver.Compare(\"v\"+matches[1], \"v3.6.6\") >= 0 {\n\t\t\t\ta.sendProgressBar = true\n\t\t\t}\n\t\t}\n\t\treturn a, nil\n\tcase tea.KeyboardEnhancementsMsg:\n\t\t// A non-zero value means we have key disambiguation support.\n\t\tif msg.Flags > 0 {\n\t\t\ta.keyMap.Models.SetHelp(\"ctrl+m\", \"models\")\n\t\t}\n\t\tfor id, page := range a.pages {\n\t\t\tm, pageCmd := page.Update(msg)\n\t\t\ta.pages[id] = m\n\n\t\t\tif pageCmd != nil {\n\t\t\t\tcmds = append(cmds, pageCmd)\n\t\t\t}\n\t\t}\n\t\treturn a, tea.Batch(cmds...)\n\tcase tea.WindowSizeMsg:\n\t\ta.wWidth, a.wHeight = msg.Width, msg.Height\n\t\ta.completions.Update(msg)\n\t\treturn a, a.handleWindowResize(msg.Width, msg.Height)\n\n\tcase pubsub.Event[mcp.Event]:\n\t\tswitch msg.Payload.Type {\n\t\tcase mcp.EventStateChanged:\n\t\t\treturn a, a.handleStateChanged(context.Background())\n\t\tcase mcp.EventPromptsListChanged:\n\t\t\treturn a, handleMCPPromptsEvent(context.Background(), msg.Payload.Name)\n\t\tcase mcp.EventToolsListChanged:\n\t\t\treturn a, handleMCPToolsEvent(context.Background(), msg.Payload.Name)\n\t\t}\n\n\t// Completions messages\n\tcase completions.OpenCompletionsMsg, completions.FilterCompletionsMsg,\n\t\tcompletions.CloseCompletionsMsg, completions.RepositionCompletionsMsg:\n\t\tu, completionCmd := a.completions.Update(msg)\n\t\tif model, ok := u.(completions.Completions); ok {\n\t\t\ta.completions = model\n\t\t}\n\n\t\treturn a, completionCmd\n\n\t// Dialog messages\n\tcase dialogs.OpenDialogMsg, dialogs.CloseDialogMsg:\n\t\tu, completionCmd := a.completions.Update(completions.CloseCompletionsMsg{})\n\t\ta.completions = u.(completions.Completions)\n\t\tu, dialogCmd := a.dialog.Update(msg)\n\t\ta.dialog = u.(dialogs.DialogCmp)\n\t\treturn a, tea.Batch(completionCmd, dialogCmd)\n\tcase commands.ShowArgumentsDialogMsg:\n\t\tvar args []commands.Argument\n\t\tfor _, arg := range msg.ArgNames {\n\t\t\targs = append(args, commands.Argument{\n\t\t\t\tName:     arg,\n\t\t\t\tTitle:    cases.Title(language.English).String(arg),\n\t\t\t\tRequired: true,\n\t\t\t})\n\t\t}\n\t\treturn a, util.CmdHandler(\n\t\t\tdialogs.OpenDialogMsg{\n\t\t\t\tModel: commands.NewCommandArgumentsDialog(\n\t\t\t\t\tmsg.CommandID,\n\t\t\t\t\tmsg.CommandID,\n\t\t\t\t\tmsg.CommandID,\n\t\t\t\t\tmsg.Description,\n\t\t\t\t\targs,\n\t\t\t\t\tmsg.OnSubmit,\n\t\t\t\t),\n\t\t\t},\n\t\t)\n\tcase commands.ShowMCPPromptArgumentsDialogMsg:\n\t\targs := make([]commands.Argument, 0, len(msg.Prompt.Arguments))\n\t\tfor _, arg := range msg.Prompt.Arguments {\n\t\t\targs = append(args, commands.Argument(*arg))\n\t\t}\n\t\tdialog := commands.NewCommandArgumentsDialog(\n\t\t\tmsg.Prompt.Name,\n\t\t\tmsg.Prompt.Title,\n\t\t\tmsg.Prompt.Name,\n\t\t\tmsg.Prompt.Description,\n\t\t\targs,\n\t\t\tmsg.OnSubmit,\n\t\t)\n\t\treturn a, util.CmdHandler(\n\t\t\tdialogs.OpenDialogMsg{\n\t\t\t\tModel: dialog,\n\t\t\t},\n\t\t)\n\t// Page change messages\n\tcase page.PageChangeMsg:\n\t\treturn a, a.moveToPage(msg.ID)\n\n\t// Status Messages\n\tcase util.InfoMsg, util.ClearStatusMsg:\n\t\ts, statusCmd := a.status.Update(msg)\n\t\ta.status = s.(status.StatusCmp)\n\t\tcmds = append(cmds, statusCmd)\n\t\treturn a, tea.Batch(cmds...)\n\n\t// Session\n\tcase cmpChat.SessionSelectedMsg:\n\t\ta.selectedSessionID = msg.ID\n\tcase cmpChat.SessionClearedMsg:\n\t\ta.selectedSessionID = \"\"\n\t// Commands\n\tcase commands.SwitchSessionsMsg:\n\t\treturn a, func() tea.Msg {\n\t\t\tallSessions, _ := a.app.Sessions.List(context.Background())\n\t\t\treturn dialogs.OpenDialogMsg{\n\t\t\t\tModel: sessions.NewSessionDialogCmp(allSessions, a.selectedSessionID),\n\t\t\t}\n\t\t}\n\n\tcase commands.SwitchModelMsg:\n\t\treturn a, util.CmdHandler(\n\t\t\tdialogs.OpenDialogMsg{\n\t\t\t\tModel: models.NewModelDialogCmp(),\n\t\t\t},\n\t\t)\n\t// Compact\n\tcase commands.CompactMsg:\n\t\treturn a, func() tea.Msg {\n\t\t\terr := a.app.AgentCoordinator.Summarize(context.Background(), msg.SessionID)\n\t\t\tif err != nil {\n\t\t\t\treturn util.ReportError(err)()\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\tcase commands.QuitMsg:\n\t\treturn a, util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: quit.NewQuitDialog(),\n\t\t})\n\tcase commands.ToggleYoloModeMsg:\n\t\ta.app.Permissions.SetSkipRequests(!a.app.Permissions.SkipRequests())\n\tcase commands.ToggleHelpMsg:\n\t\ta.status.ToggleFullHelp()\n\t\ta.showingFullHelp = !a.showingFullHelp\n\t\treturn a, a.handleWindowResize(a.wWidth, a.wHeight)\n\t// Model Switch\n\tcase models.ModelSelectedMsg:\n\t\tif a.app.AgentCoordinator.IsBusy() {\n\t\t\treturn a, util.ReportWarn(\"Agent is busy, please wait...\")\n\t\t}\n\n\t\tcfg := config.Get()\n\t\tif err := cfg.UpdatePreferredModel(msg.ModelType, msg.Model); err != nil {\n\t\t\treturn a, util.ReportError(err)\n\t\t}\n\n\t\tgo a.app.UpdateAgentModel(ctx)\n\n\t\tmodelTypeName := \"large\"\n\t\tif msg.ModelType == config.SelectedModelTypeSmall {\n\t\t\tmodelTypeName = \"small\"\n\t\t}\n\t\treturn a, util.ReportInfo(fmt.Sprintf(\"%s model changed to %s\", modelTypeName, msg.Model.Model))\n\n\t// File Picker\n\tcase commands.OpenFilePickerMsg:\n\t\tif a.dialog.ActiveDialogID() == filepicker.FilePickerID {\n\t\t\t// If the commands dialog is already open, close it\n\t\t\treturn a, util.CmdHandler(dialogs.CloseDialogMsg{})\n\t\t}\n\t\treturn a, util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: filepicker.NewFilePickerCmp(a.app.Config().WorkingDir()),\n\t\t})\n\t// Permissions\n\tcase pubsub.Event[permission.PermissionNotification]:\n\t\titem, ok := a.pages[a.currentPage]\n\t\tif !ok {\n\t\t\treturn a, nil\n\t\t}\n\n\t\t// Forward to view.\n\t\tupdated, itemCmd := item.Update(msg)\n\t\ta.pages[a.currentPage] = updated\n\n\t\treturn a, itemCmd\n\tcase pubsub.Event[permission.PermissionRequest]:\n\t\treturn a, util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: permissions.NewPermissionDialogCmp(msg.Payload, &permissions.Options{\n\t\t\t\tDiffMode: config.Get().Options.TUI.DiffMode,\n\t\t\t}),\n\t\t})\n\tcase permissions.PermissionResponseMsg:\n\t\tswitch msg.Action {\n\t\tcase permissions.PermissionAllow:\n\t\t\ta.app.Permissions.Grant(msg.Permission)\n\t\tcase permissions.PermissionAllowForSession:\n\t\t\ta.app.Permissions.GrantPersistent(msg.Permission)\n\t\tcase permissions.PermissionDeny:\n\t\t\ta.app.Permissions.Deny(msg.Permission)\n\t\t}\n\t\treturn a, nil\n\tcase splash.OnboardingCompleteMsg:\n\t\titem, ok := a.pages[a.currentPage]\n\t\tif !ok {\n\t\t\treturn a, nil\n\t\t}\n\n\t\ta.isConfigured = config.HasInitialDataConfig()\n\t\tupdated, pageCmd := item.Update(msg)\n\t\ta.pages[a.currentPage] = updated\n\n\t\tcmds = append(cmds, pageCmd)\n\t\treturn a, tea.Batch(cmds...)\n\n\tcase tea.KeyPressMsg:\n\t\treturn a, a.handleKeyPressMsg(msg)\n\n\tcase tea.MouseWheelMsg:\n\t\tif a.dialog.HasDialogs() {\n\t\t\tu, dialogCmd := a.dialog.Update(msg)\n\t\t\ta.dialog = u.(dialogs.DialogCmp)\n\t\t\tcmds = append(cmds, dialogCmd)\n\t\t} else {\n\t\t\titem, ok := a.pages[a.currentPage]\n\t\t\tif !ok {\n\t\t\t\treturn a, nil\n\t\t\t}\n\n\t\t\tupdated, pageCmd := item.Update(msg)\n\t\t\ta.pages[a.currentPage] = updated\n\n\t\t\tcmds = append(cmds, pageCmd)\n\t\t}\n\t\treturn a, tea.Batch(cmds...)\n\tcase tea.PasteMsg:\n\t\tif a.dialog.HasDialogs() {\n\t\t\tu, dialogCmd := a.dialog.Update(msg)\n\t\t\tif model, ok := u.(dialogs.DialogCmp); ok {\n\t\t\t\ta.dialog = model\n\t\t\t}\n\n\t\t\tcmds = append(cmds, dialogCmd)\n\t\t} else {\n\t\t\titem, ok := a.pages[a.currentPage]\n\t\t\tif !ok {\n\t\t\t\treturn a, nil\n\t\t\t}\n\n\t\t\tupdated, pageCmd := item.Update(msg)\n\t\t\ta.pages[a.currentPage] = updated\n\n\t\t\tcmds = append(cmds, pageCmd)\n\t\t}\n\t\treturn a, tea.Batch(cmds...)\n\t// Update Available\n\tcase pubsub.UpdateAvailableMsg:\n\t\t// Show update notification in status bar\n\t\tstatusMsg := fmt.Sprintf(\"Nexora update available: v%s \u2192 v%s.\", msg.CurrentVersion, msg.LatestVersion)\n\t\tif msg.IsDevelopment {\n\t\t\tstatusMsg = fmt.Sprintf(\"This is a development version of Nexora. The latest version is v%s.\", msg.LatestVersion)\n\t\t}\n\t\ts, statusCmd := a.status.Update(util.InfoMsg{\n\t\t\tType: util.InfoTypeUpdate,\n\t\t\tMsg:  statusMsg,\n\t\t\tTTL:  cacheTTL,\n\t\t})\n\t\ta.status = s.(status.StatusCmp)\n\t\treturn a, statusCmd\n\t}\n\ts, _ := a.status.Update(msg)\n\ta.status = s.(status.StatusCmp)\n\n\titem, ok := a.pages[a.currentPage]\n\tif !ok {\n\t\treturn a, nil\n\t}\n\n\tupdated, cmd := item.Update(msg)\n\ta.pages[a.currentPage] = updated\n\n\tif a.dialog.HasDialogs() {\n\t\tu, dialogCmd := a.dialog.Update(msg)\n\t\tif model, ok := u.(dialogs.DialogCmp); ok {\n\t\t\ta.dialog = model\n\t\t}\n\n\t\tcmds = append(cmds, dialogCmd)\n\t}\n\tcmds = append(cmds, cmd)\n\treturn a, tea.Batch(cmds...)\n}\n\n// handleWindowResize processes window resize events and updates all components.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleWindowResize_450": {
      "name": "handleWindowResize",
      "type": "method",
      "start_line": 450,
      "end_line": 487,
      "content_hash": "3671d92bb0adeaeaa4ab0253a3252d5ecce23a38",
      "content": "func (a *appModel) handleWindowResize(width, height int) tea.Cmd {\n\tvar cmds []tea.Cmd\n\n\t// Adjust height based on help display\n\tif a.showingFullHelp {\n\t\theight -= fullHelpHeightReduction\n\t} else {\n\t\theight -= minimalHelpHeightReduction\n\t}\n\n\ta.width, a.height = width, height\n\t// Update status bar\n\ts, cmd := a.status.Update(tea.WindowSizeMsg{Width: width, Height: height})\n\tif model, ok := s.(status.StatusCmp); ok {\n\t\ta.status = model\n\t}\n\tcmds = append(cmds, cmd)\n\n\t// Update the current view.\n\tfor p, page := range a.pages {\n\t\tupdated, pageCmd := page.Update(tea.WindowSizeMsg{Width: width, Height: height})\n\t\ta.pages[p] = updated\n\n\t\tcmds = append(cmds, pageCmd)\n\t}\n\n\t// Update the dialogs\n\tdialog, cmd := a.dialog.Update(tea.WindowSizeMsg{Width: width, Height: height})\n\tif model, ok := dialog.(dialogs.DialogCmp); ok {\n\t\ta.dialog = model\n\t}\n\n\tcmds = append(cmds, cmd)\n\n\treturn tea.Batch(cmds...)\n}\n\n// handleKeyPressMsg processes keyboard input and routes to appropriate handlers.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleKeyPressMsg_488": {
      "name": "handleKeyPressMsg",
      "type": "method",
      "start_line": 488,
      "end_line": 589,
      "content_hash": "4776ad6941bd29142cf00f968cde935b72471e77",
      "content": "func (a *appModel) handleKeyPressMsg(msg tea.KeyPressMsg) tea.Cmd {\n\t// Check this first as the user should be able to quit no matter what.\n\tif key.Matches(msg, a.keyMap.Quit) {\n\t\tif a.dialog.ActiveDialogID() == quit.QuitDialogID {\n\t\t\treturn tea.Quit\n\t\t}\n\t\treturn util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: quit.NewQuitDialog(),\n\t\t})\n\t}\n\n\tif a.completions.Open() {\n\t\t// completions\n\t\tkeyMap := a.completions.KeyMap()\n\t\tswitch {\n\t\tcase key.Matches(msg, keyMap.Up), key.Matches(msg, keyMap.Down),\n\t\t\tkey.Matches(msg, keyMap.Select), key.Matches(msg, keyMap.Cancel),\n\t\t\tkey.Matches(msg, keyMap.UpInsert), key.Matches(msg, keyMap.DownInsert):\n\t\t\tu, cmd := a.completions.Update(msg)\n\t\t\ta.completions = u.(completions.Completions)\n\t\t\treturn cmd\n\t\t}\n\t}\n\tif a.dialog.HasDialogs() {\n\t\tu, dialogCmd := a.dialog.Update(msg)\n\t\ta.dialog = u.(dialogs.DialogCmp)\n\t\treturn dialogCmd\n\t}\n\tswitch {\n\t// help\n\tcase key.Matches(msg, a.keyMap.Help):\n\t\ta.status.ToggleFullHelp()\n\t\ta.showingFullHelp = !a.showingFullHelp\n\t\treturn a.handleWindowResize(a.wWidth, a.wHeight)\n\t// dialogs\n\tcase key.Matches(msg, a.keyMap.Commands):\n\t\t// if the app is not configured show no commands\n\t\tif !a.isConfigured {\n\t\t\treturn nil\n\t\t}\n\t\tif a.dialog.ActiveDialogID() == commands.CommandsDialogID {\n\t\t\treturn util.CmdHandler(dialogs.CloseDialogMsg{})\n\t\t}\n\t\tif a.dialog.HasDialogs() {\n\t\t\treturn nil\n\t\t}\n\t\treturn util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: commands.NewCommandDialog(a.selectedSessionID),\n\t\t})\n\tcase key.Matches(msg, a.keyMap.Models):\n\t\t// if the app is not configured show no models\n\t\tif !a.isConfigured {\n\t\t\treturn nil\n\t\t}\n\t\tif a.dialog.ActiveDialogID() == models.ModelsDialogID {\n\t\t\treturn util.CmdHandler(dialogs.CloseDialogMsg{})\n\t\t}\n\t\tif a.dialog.HasDialogs() {\n\t\t\treturn nil\n\t\t}\n\t\treturn util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\tModel: models.NewModelDialogCmp(),\n\t\t})\n\tcase key.Matches(msg, a.keyMap.Sessions):\n\t\t// if the app is not configured show no sessions\n\t\tif !a.isConfigured {\n\t\t\treturn nil\n\t\t}\n\t\tif a.dialog.ActiveDialogID() == sessions.SessionsDialogID {\n\t\t\treturn util.CmdHandler(dialogs.CloseDialogMsg{})\n\t\t}\n\t\tif a.dialog.HasDialogs() && a.dialog.ActiveDialogID() != commands.CommandsDialogID {\n\t\t\treturn nil\n\t\t}\n\t\tvar cmds []tea.Cmd\n\t\tcmds = append(cmds,\n\t\t\tfunc() tea.Msg {\n\t\t\t\tallSessions, _ := a.app.Sessions.List(context.Background())\n\t\t\t\treturn dialogs.OpenDialogMsg{\n\t\t\t\t\tModel: sessions.NewSessionDialogCmp(allSessions, a.selectedSessionID),\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t\treturn tea.Sequence(cmds...)\n\tcase key.Matches(msg, a.keyMap.Suspend):\n\t\tif a.app.AgentCoordinator != nil && a.app.AgentCoordinator.IsBusy() {\n\t\t\treturn util.ReportWarn(\"Agent is busy, please wait...\")\n\t\t}\n\t\treturn tea.Suspend\n\tdefault:\n\t\titem, ok := a.pages[a.currentPage]\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\n\t\tupdated, cmd := item.Update(msg)\n\t\ta.pages[a.currentPage] = updated\n\t\treturn cmd\n\t}\n}\n\n// moveToPage handles navigation between different pages in the application.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_moveToPage_590": {
      "name": "moveToPage",
      "type": "method",
      "start_line": 590,
      "end_line": 613,
      "content_hash": "d9cb6119f733b3dee6f0f7f7957a4080fa085ab7",
      "content": "func (a *appModel) moveToPage(pageID page.PageID) tea.Cmd {\n\tif a.app.AgentCoordinator.IsBusy() {\n\t\t// Agent busy navigation - temporarily blocking page transitions during agent operations\n\t\t// Future enhancement: Consider queue or allow certain safe page transitions during agent work\n\t\treturn util.ReportWarn(\"Agent is busy, please wait...\")\n\t}\n\n\tvar cmds []tea.Cmd\n\tif _, ok := a.loadedPages[pageID]; !ok {\n\t\tcmd := a.pages[pageID].Init()\n\t\tcmds = append(cmds, cmd)\n\t\ta.loadedPages[pageID] = true\n\t}\n\ta.previousPage = a.currentPage\n\ta.currentPage = pageID\n\tif sizable, ok := a.pages[a.currentPage].(core.Sizeable); ok {\n\t\tcmd := sizable.SetSize(a.width, a.height)\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// View renders the complete application interface including pages, dialogs, and overlays.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_614": {
      "name": "View",
      "type": "method",
      "start_line": 614,
      "end_line": 701,
      "content_hash": "d16f1982c35fd9f5e79e562f78fa22209095765c",
      "content": "func (a *appModel) View() tea.View {\n\tvar view tea.View\n\tt := styles.CurrentTheme()\n\tview.AltScreen = true\n\tview.MouseMode = tea.MouseModeCellMotion\n\tview.BackgroundColor = t.BgBase\n\tif a.wWidth < minWindowWidth || a.wHeight < minWindowHeight {\n\t\tview.SetContent(\n\t\t\tlipgloss.NewCanvas(\n\t\t\t\tlipgloss.NewLayer(\n\t\t\t\t\tt.S().Base.Width(a.wWidth).Height(a.wHeight).\n\t\t\t\t\t\tAlign(lipgloss.Center, lipgloss.Center).\n\t\t\t\t\t\tRender(\n\t\t\t\t\t\t\tt.S().Base.\n\t\t\t\t\t\t\t\tPadding(1, 4).\n\t\t\t\t\t\t\t\tForeground(t.White).\n\t\t\t\t\t\t\t\tBorderStyle(lipgloss.RoundedBorder()).\n\t\t\t\t\t\t\t\tBorderForeground(t.Primary).\n\t\t\t\t\t\t\t\tRender(\"Window too small!\"),\n\t\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t).Render(),\n\t\t)\n\t\treturn view\n\t}\n\n\tpage := a.pages[a.currentPage]\n\tif withHelp, ok := page.(core.KeyMapHelp); ok {\n\t\ta.status.SetKeyMap(withHelp.Help())\n\t}\n\tpageView := page.View()\n\tcomponents := []string{\n\t\tpageView,\n\t}\n\tcomponents = append(components, a.status.View())\n\n\tappView := lipgloss.JoinVertical(lipgloss.Top, components...)\n\tlayers := []*lipgloss.Layer{\n\t\tlipgloss.NewLayer(appView),\n\t}\n\tif a.dialog.HasDialogs() {\n\t\tlayers = append(\n\t\t\tlayers,\n\t\t\ta.dialog.GetLayers()...,\n\t\t)\n\t}\n\n\tvar cursor *tea.Cursor\n\tif v, ok := page.(util.Cursor); ok {\n\t\tcursor = v.Cursor()\n\t\t// Hide the cursor if it's positioned outside the textarea\n\t\tstatusHeight := a.height - strings.Count(pageView, \"\\n\") + 1\n\t\tif cursor != nil && cursor.Y+statusHeight+chat.EditorHeight-2 <= a.height { // 2 for the top and bottom app padding\n\t\t\tcursor = nil\n\t\t}\n\t}\n\tactiveView := a.dialog.ActiveModel()\n\tif activeView != nil {\n\t\tcursor = nil // Reset cursor if a dialog is active unless it implements util.Cursor\n\t\tif v, ok := activeView.(util.Cursor); ok {\n\t\t\tcursor = v.Cursor()\n\t\t}\n\t}\n\n\tif a.completions.Open() && cursor != nil {\n\t\tcmp := a.completions.View()\n\t\tx, y := a.completions.Position()\n\t\tlayers = append(\n\t\t\tlayers,\n\t\t\tlipgloss.NewLayer(cmp).X(x).Y(y),\n\t\t)\n\t}\n\n\tcanvas := lipgloss.NewCanvas(\n\t\tlayers...,\n\t)\n\n\tview.Content = canvas.Render()\n\tview.Cursor = cursor\n\n\tif a.sendProgressBar && a.app != nil && a.app.AgentCoordinator != nil && a.app.AgentCoordinator.IsBusy() {\n\t\t// HACK: use a random percentage to prevent ghostty from hiding it\n\t\t// after a timeout.\n\t\tview.ProgressBar = tea.NewProgressBar(tea.ProgressBarIndeterminate, rand.Intn(100))\n\t}\n\treturn view\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleStateChanged_702": {
      "name": "handleStateChanged",
      "type": "method",
      "start_line": 702,
      "end_line": 708,
      "content_hash": "c5a06376f340563ddf228e9501ec0fcc6b4c0503",
      "content": "func (a *appModel) handleStateChanged(ctx context.Context) tea.Cmd {\n\treturn func() tea.Msg {\n\t\ta.app.UpdateAgentModel(ctx)\n\t\treturn nil\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleMCPPromptsEvent_709": {
      "name": "handleMCPPromptsEvent",
      "type": "function",
      "start_line": 709,
      "end_line": 715,
      "content_hash": "057db6dc561edf975a9fbd7bf64e9a1b6e2de09f",
      "content": "func handleMCPPromptsEvent(ctx context.Context, name string) tea.Cmd {\n\treturn func() tea.Msg {\n\t\tmcp.RefreshPrompts(ctx, name)\n\t\treturn nil\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_handleMCPToolsEvent_716": {
      "name": "handleMCPToolsEvent",
      "type": "function",
      "start_line": 716,
      "end_line": 723,
      "content_hash": "6afb86809decdcb7832aa69150e5baa812f0fc2f",
      "content": "func handleMCPToolsEvent(ctx context.Context, name string) tea.Cmd {\n\treturn func() tea.Msg {\n\t\tmcp.RefreshTools(ctx, name)\n\t\treturn nil\n\t}\n}\n\n// New creates and initializes a new TUI application model.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_724": {
      "name": "New",
      "type": "function",
      "start_line": 724,
      "end_line": 745,
      "content_hash": "d4779b0584ee2936602fd4ef207906035c1d01aa",
      "content": "func New(app *app.App) *appModel {\n\tchatPage := chat.New(app)\n\tkeyMap := DefaultKeyMap()\n\tkeyMap.pageBindings = chatPage.Bindings()\n\n\tmodel := &appModel{\n\t\tcurrentPage: chat.ChatPageID,\n\t\tapp:         app,\n\t\tstatus:      status.NewStatusCmp(),\n\t\tloadedPages: make(map[page.PageID]bool),\n\t\tkeyMap:      keyMap,\n\n\t\tpages: map[page.PageID]util.Model{\n\t\t\tchat.ChatPageID: chatPage,\n\t\t},\n\n\t\tdialog:      dialogs.NewDialogCmp(),\n\t\tcompletions: completions.New(),\n\t}\n\n\treturn model\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}