{
  "file_path": "/work/internal/tui/components/chat/sidebar/sidebar.go",
  "file_hash": "135ef54764fae132dcc5f825738ccf100b823ff2",
  "updated_at": "2025-12-26T17:34:24.957959",
  "symbols": {
    "struct_FileHistory_34": {
      "name": "FileHistory",
      "type": "struct",
      "start_line": 34,
      "end_line": 48,
      "content_hash": "087c3e87b51785533c1138bfb6700b1827dc55f6",
      "content": "type FileHistory struct {\n\tinitialVersion history.File\n\tlatestVersion  history.File\n}\n\nconst LogoHeightBreakpoint = 30\n\n// Default maximum number of items to show in each section\nconst (\n\tDefaultMaxFilesShown = 10\n\tDefaultMaxLSPsShown  = 8\n\tDefaultMaxMCPsShown  = 8\n\tMinItemsPerSection   = 2 // Minimum items to show per section\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SessionFile_49": {
      "name": "SessionFile",
      "type": "struct",
      "start_line": 49,
      "end_line": 54,
      "content_hash": "da16bce0282627bdab379d2075777771f8112898",
      "content": "type SessionFile struct {\n\tHistory   FileHistory\n\tFilePath  string\n\tAdditions int\n\tDeletions int\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SessionFilesMsg_55": {
      "name": "SessionFilesMsg",
      "type": "struct",
      "start_line": 55,
      "end_line": 58,
      "content_hash": "af7183e5002d5e4174c5888498106c2ead3f6c34",
      "content": "type SessionFilesMsg struct {\n\tFiles []SessionFile\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_Sidebar_59": {
      "name": "Sidebar",
      "type": "interface",
      "start_line": 59,
      "end_line": 65,
      "content_hash": "2ff87d205de8e14688069f0d6de8d786a291e106",
      "content": "type Sidebar interface {\n\tutil.Model\n\tcore.Sizeable\n\tSetSession(session session.Session) tea.Cmd\n\tSetCompactMode(bool)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_sidebarCmp_66": {
      "name": "sidebarCmp",
      "type": "struct",
      "start_line": 66,
      "end_line": 76,
      "content_hash": "59d5cbe41988745e759a065bc36d90a8506dc45b",
      "content": "type sidebarCmp struct {\n\twidth, height int\n\tsession       session.Session\n\tlogo          string\n\tcwd           string\n\tlspClients    *csync.Map[string, *lsp.Client]\n\tcompactMode   bool\n\thistory       history.Service\n\tfiles         *csync.Map[string, SessionFile]\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_77": {
      "name": "New",
      "type": "function",
      "start_line": 77,
      "end_line": 85,
      "content_hash": "b3c0df842ef1eb100dd8932eb5938564fed6df7b",
      "content": "func New(history history.Service, lspClients *csync.Map[string, *lsp.Client], compact bool) Sidebar {\n\treturn &sidebarCmp{\n\t\tlspClients:  lspClients,\n\t\thistory:     history,\n\t\tcompactMode: compact,\n\t\tfiles:       csync.NewMap[string, SessionFile](),\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_86": {
      "name": "Init",
      "type": "method",
      "start_line": 86,
      "end_line": 89,
      "content_hash": "1f7a39e3225199203a0a0a3af39a4e930dcf5627",
      "content": "func (m *sidebarCmp) Init() tea.Cmd {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_90": {
      "name": "Update",
      "type": "method",
      "start_line": 90,
      "end_line": 112,
      "content_hash": "bb3a1807d56820388d4677b9ecfaee47a570b34f",
      "content": "func (m *sidebarCmp) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase SessionFilesMsg:\n\t\tm.files = csync.NewMap[string, SessionFile]()\n\t\tfor _, file := range msg.Files {\n\t\t\tm.files.Set(file.FilePath, file)\n\t\t}\n\t\treturn m, nil\n\n\tcase chat.SessionClearedMsg:\n\t\tm.session = session.Session{}\n\tcase pubsub.Event[history.File]:\n\t\treturn m, m.handleFileHistoryEvent(msg)\n\tcase pubsub.Event[session.Session]:\n\t\tif msg.Type == pubsub.UpdatedEvent {\n\t\t\tif m.session.ID == msg.Payload.ID {\n\t\t\t\tm.session = msg.Payload\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_113": {
      "name": "View",
      "type": "method",
      "start_line": 113,
      "end_line": 176,
      "content_hash": "ff1a8e44fcfc60a5505c9539b53f5e4199b7ab18",
      "content": "func (m *sidebarCmp) View() string {\n\tt := styles.CurrentTheme()\n\tparts := []string{}\n\n\tstyle := t.S().Base.\n\t\tWidth(m.width).\n\t\tHeight(m.height).\n\t\tPadding(1)\n\tif m.compactMode {\n\t\tstyle = style.PaddingTop(0)\n\t}\n\n\tif !m.compactMode {\n\t\tif m.height > LogoHeightBreakpoint {\n\t\t\tparts = append(parts, m.logo)\n\t\t} else {\n\t\t\t// Use a smaller logo for smaller screens\n\t\t\tparts = append(parts,\n\t\t\t\tlogo.SmallRender(m.width-style.GetHorizontalFrameSize()),\n\t\t\t\t\"\")\n\t\t}\n\t}\n\n\tif !m.compactMode && m.session.ID != \"\" {\n\t\tparts = append(parts, t.S().Muted.Render(m.session.Title), \"\")\n\t} else if m.session.ID != \"\" {\n\t\tparts = append(parts, t.S().Text.Render(m.session.Title), \"\")\n\t}\n\n\tif !m.compactMode {\n\t\tparts = append(parts,\n\t\t\tm.cwd,\n\t\t\t\"\",\n\t\t)\n\t}\n\tparts = append(parts,\n\t\tm.currentModelBlock(),\n\t)\n\n\t// Check if we should use horizontal layout for sections\n\tif m.compactMode && m.width > m.height {\n\t\t// Horizontal layout for compact mode when width > height\n\t\tsectionsContent := m.renderSectionsHorizontal()\n\t\tif sectionsContent != \"\" {\n\t\t\tparts = append(parts, \"\", sectionsContent)\n\t\t}\n\t} else {\n\t\t// Vertical layout (default)\n\t\tif m.session.ID != \"\" {\n\t\t\tparts = append(parts, \"\", m.filesBlock())\n\t\t}\n\t\tparts = append(parts,\n\t\t\t\"\",\n\t\t\tm.lspBlock(),\n\t\t\t\"\",\n\t\t\tm.mcpBlock(),\n\t\t)\n\t}\n\n\treturn style.Render(\n\t\tlipgloss.JoinVertical(lipgloss.Left, parts...),\n\t)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleFileHistoryEvent_177": {
      "name": "handleFileHistoryEvent",
      "type": "method",
      "start_line": 177,
      "end_line": 221,
      "content_hash": "e5b7231eaf0160ce38fcc3000b8ef5cbf357f274",
      "content": "func (m *sidebarCmp) handleFileHistoryEvent(event pubsub.Event[history.File]) tea.Cmd {\n\treturn func() tea.Msg {\n\t\tfile := event.Payload\n\t\tfound := false\n\t\tfor existing := range m.files.Seq() {\n\t\t\tif existing.FilePath != file.Path {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif existing.History.latestVersion.Version < file.Version {\n\t\t\t\texisting.History.latestVersion = file\n\t\t\t} else if file.Version == 0 {\n\t\t\t\texisting.History.initialVersion = file\n\t\t\t} else {\n\t\t\t\t// If the version is not greater than the latest, we ignore it\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbefore, _ := fsext.ToUnixLineEndings(existing.History.initialVersion.Content)\n\t\t\tafter, _ := fsext.ToUnixLineEndings(existing.History.latestVersion.Content)\n\t\t\tpath := existing.History.initialVersion.Path\n\t\t\tcwd := config.Get().WorkingDir()\n\t\t\tpath = strings.TrimPrefix(path, cwd)\n\t\t\t_, additions, deletions := diff.GenerateDiff(before, after, path)\n\t\t\texisting.Additions = additions\n\t\t\texisting.Deletions = deletions\n\t\t\tm.files.Set(file.Path, existing)\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t\tif found {\n\t\t\treturn nil\n\t\t}\n\t\tsf := SessionFile{\n\t\t\tHistory: FileHistory{\n\t\t\t\tinitialVersion: file,\n\t\t\t\tlatestVersion:  file,\n\t\t\t},\n\t\t\tFilePath:  file.Path,\n\t\t\tAdditions: 0,\n\t\t\tDeletions: 0,\n\t\t}\n\t\tm.files.Set(file.Path, sf)\n\t\treturn nil\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_loadSessionFiles_222": {
      "name": "loadSessionFiles",
      "type": "method",
      "start_line": 222,
      "end_line": 266,
      "content_hash": "d1d9c5c3eccb29c4e8f5502e3b3fe9e389c078ec",
      "content": "func (m *sidebarCmp) loadSessionFiles() tea.Msg {\n\tfiles, err := m.history.ListBySession(context.Background(), m.session.ID)\n\tif err != nil {\n\t\treturn util.InfoMsg{\n\t\t\tType: util.InfoTypeError,\n\t\t\tMsg:  err.Error(),\n\t\t}\n\t}\n\n\tfileMap := make(map[string]FileHistory)\n\n\tfor _, file := range files {\n\t\tif existing, ok := fileMap[file.Path]; ok {\n\t\t\t// Update the latest version\n\t\t\texisting.latestVersion = file\n\t\t\tfileMap[file.Path] = existing\n\t\t} else {\n\t\t\t// Add the initial version\n\t\t\tfileMap[file.Path] = FileHistory{\n\t\t\t\tinitialVersion: file,\n\t\t\t\tlatestVersion:  file,\n\t\t\t}\n\t\t}\n\t}\n\n\tsessionFiles := make([]SessionFile, 0, len(fileMap))\n\tfor path, fh := range fileMap {\n\t\tcwd := config.Get().WorkingDir()\n\t\tpath = strings.TrimPrefix(path, cwd)\n\t\tbefore, _ := fsext.ToUnixLineEndings(fh.initialVersion.Content)\n\t\tafter, _ := fsext.ToUnixLineEndings(fh.latestVersion.Content)\n\t\t_, additions, deletions := diff.GenerateDiff(before, after, path)\n\t\tsessionFiles = append(sessionFiles, SessionFile{\n\t\t\tHistory:   fh,\n\t\t\tFilePath:  path,\n\t\t\tAdditions: additions,\n\t\t\tDeletions: deletions,\n\t\t})\n\t}\n\n\treturn SessionFilesMsg{\n\t\tFiles: sessionFiles,\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_267": {
      "name": "SetSize",
      "type": "method",
      "start_line": 267,
      "end_line": 274,
      "content_hash": "9ae4b3fea25cdf41a057b7fc86d7f5fb2f8c46f4",
      "content": "func (m *sidebarCmp) SetSize(width, height int) tea.Cmd {\n\tm.logo = m.logoBlock()\n\tm.cwd = cwd()\n\tm.width = width\n\tm.height = height\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_275": {
      "name": "GetSize",
      "type": "method",
      "start_line": 275,
      "end_line": 278,
      "content_hash": "020107d0fdeb4d844d2cd2a273eb05e647c381e8",
      "content": "func (m *sidebarCmp) GetSize() (int, int) {\n\treturn m.width, m.height\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_logoBlock_279": {
      "name": "logoBlock",
      "type": "method",
      "start_line": 279,
      "end_line": 290,
      "content_hash": "04edc6c471098d50f0dbd23c4a17bf33eb9f36eb",
      "content": "func (m *sidebarCmp) logoBlock() string {\n\tt := styles.CurrentTheme()\n\treturn logo.Render(version.Version, true, logo.Opts{\n\t\tFieldColor:   t.Primary,\n\t\tTitleColorA:  t.Secondary,\n\t\tTitleColorB:  t.Primary,\n\t\tCharmColor:   t.Secondary,\n\t\tVersionColor: t.Primary,\n\t\tWidth:        m.width - 2,\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getMaxWidth_291": {
      "name": "getMaxWidth",
      "type": "method",
      "start_line": 291,
      "end_line": 295,
      "content_hash": "c0206f194b05526f4829a09d8001666f89e2c9b4",
      "content": "func (m *sidebarCmp) getMaxWidth() int {\n\treturn min(m.width-2, 58) // -2 for padding\n}\n\n// calculateAvailableHeight estimates how much height is available for dynamic content",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateAvailableHeight_296": {
      "name": "calculateAvailableHeight",
      "type": "method",
      "start_line": 296,
      "end_line": 328,
      "content_hash": "1434df488ce8b477e9291b9a4822ffcd6dd001c8",
      "content": "func (m *sidebarCmp) calculateAvailableHeight() int {\n\tusedHeight := 0\n\n\tif !m.compactMode {\n\t\tif m.height > LogoHeightBreakpoint {\n\t\t\tusedHeight += 7 // Approximate logo height\n\t\t} else {\n\t\t\tusedHeight += 2 // Smaller logo height\n\t\t}\n\t\tusedHeight += 1 // Empty line after logo\n\t}\n\n\tif m.session.ID != \"\" {\n\t\tusedHeight += 1 // Title line\n\t\tusedHeight += 1 // Empty line after title\n\t}\n\n\tif !m.compactMode {\n\t\tusedHeight += 1 // CWD line\n\t\tusedHeight += 1 // Empty line after CWD\n\t}\n\n\tusedHeight += 2 // Model info\n\n\tusedHeight += 6 // 3 sections \u00d7 2 lines each (header + empty line)\n\n\t// Base padding\n\tusedHeight += 2 // Top and bottom padding\n\n\treturn max(0, m.height-usedHeight)\n}\n\n// getDynamicLimits calculates how many items to show in each section based on available height",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getDynamicLimits_329": {
      "name": "getDynamicLimits",
      "type": "method",
      "start_line": 329,
      "end_line": 368,
      "content_hash": "01fed1c63e106f2e01743768f89064e272213c76",
      "content": "func (m *sidebarCmp) getDynamicLimits() (maxFiles, maxLSPs, maxMCPs int) {\n\tavailableHeight := m.calculateAvailableHeight()\n\n\t// If we have very little space, use minimum values\n\tif availableHeight < 10 {\n\t\treturn MinItemsPerSection, MinItemsPerSection, MinItemsPerSection\n\t}\n\n\t// Distribute available height among the three sections\n\t// Give priority to files, then LSPs, then MCPs\n\ttotalSections := 3\n\theightPerSection := availableHeight / totalSections\n\n\t// Calculate limits for each section, ensuring minimums\n\tmaxFiles = max(MinItemsPerSection, min(DefaultMaxFilesShown, heightPerSection))\n\tmaxLSPs = max(MinItemsPerSection, min(DefaultMaxLSPsShown, heightPerSection))\n\tmaxMCPs = max(MinItemsPerSection, min(DefaultMaxMCPsShown, heightPerSection))\n\n\t// If we have extra space, give it to files first\n\tremainingHeight := availableHeight - (maxFiles + maxLSPs + maxMCPs)\n\tif remainingHeight > 0 {\n\t\textraForFiles := min(remainingHeight, DefaultMaxFilesShown-maxFiles)\n\t\tmaxFiles += extraForFiles\n\t\tremainingHeight -= extraForFiles\n\n\t\tif remainingHeight > 0 {\n\t\t\textraForLSPs := min(remainingHeight, DefaultMaxLSPsShown-maxLSPs)\n\t\t\tmaxLSPs += extraForLSPs\n\t\t\tremainingHeight -= extraForLSPs\n\n\t\t\tif remainingHeight > 0 {\n\t\t\t\tmaxMCPs += min(remainingHeight, DefaultMaxMCPsShown-maxMCPs)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxFiles, maxLSPs, maxMCPs\n}\n\n// renderSectionsHorizontal renders the files, LSPs, and MCPs sections horizontally",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_renderSectionsHorizontal_369": {
      "name": "renderSectionsHorizontal",
      "type": "method",
      "start_line": 369,
      "end_line": 384,
      "content_hash": "4874c32a731be554f71a53ad2ff488aee4ae626f",
      "content": "func (m *sidebarCmp) renderSectionsHorizontal() string {\n\t// Calculate available width for each section\n\ttotalWidth := m.width - 4 // Account for padding and spacing\n\tsectionWidth := min(50, totalWidth/3)\n\n\t// Get the sections content with limited height\n\tvar filesContent, lspContent, mcpContent string\n\n\tfilesContent = m.filesBlockCompact(sectionWidth)\n\tlspContent = m.lspBlockCompact(sectionWidth)\n\tmcpContent = m.mcpBlockCompact(sectionWidth)\n\n\treturn lipgloss.JoinHorizontal(lipgloss.Top, filesContent, \" \", lspContent, \" \", mcpContent)\n}\n\n// filesBlockCompact renders the files block with limited width and height for horizontal layout",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_filesBlockCompact_385": {
      "name": "filesBlockCompact",
      "type": "method",
      "start_line": 385,
      "end_line": 416,
      "content_hash": "bf8b12ecf58680bd9d5f717324c48b074752f511",
      "content": "func (m *sidebarCmp) filesBlockCompact(maxWidth int) string {\n\t// Convert map to slice and handle type conversion\n\tsessionFiles := slices.Collect(m.files.Seq())\n\tfileSlice := make([]files.SessionFile, len(sessionFiles))\n\tfor i, sf := range sessionFiles {\n\t\tfileSlice[i] = files.SessionFile{\n\t\t\tHistory: files.FileHistory{\n\t\t\t\tInitialVersion: sf.History.initialVersion,\n\t\t\t\tLatestVersion:  sf.History.latestVersion,\n\t\t\t},\n\t\t\tFilePath:  sf.FilePath,\n\t\t\tAdditions: sf.Additions,\n\t\t\tDeletions: sf.Deletions,\n\t\t}\n\t}\n\n\t// Limit items for horizontal layout\n\tmaxItems := min(5, len(fileSlice))\n\tavailableHeight := m.height - 8 // Reserve space for header and other content\n\tif availableHeight > 0 {\n\t\tmaxItems = min(maxItems, availableHeight)\n\t}\n\n\treturn files.RenderFileBlock(fileSlice, files.RenderOptions{\n\t\tMaxWidth:    maxWidth,\n\t\tMaxItems:    maxItems,\n\t\tShowSection: true,\n\t\tSectionName: \"Modified Files\",\n\t}, true)\n}\n\n// lspBlockCompact renders the LSP block with limited width and height for horizontal layout",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_lspBlockCompact_417": {
      "name": "lspBlockCompact",
      "type": "method",
      "start_line": 417,
      "end_line": 434,
      "content_hash": "b5bf7047e14ea99a5d1e2dbaf5a56ba7c5466ee5",
      "content": "func (m *sidebarCmp) lspBlockCompact(maxWidth int) string {\n\t// Limit items for horizontal layout\n\tlspConfigs := config.Get().LSP.Sorted()\n\tmaxItems := min(5, len(lspConfigs))\n\tavailableHeight := m.height - 8\n\tif availableHeight > 0 {\n\t\tmaxItems = min(maxItems, availableHeight)\n\t}\n\n\treturn lspcomponent.RenderLSPBlock(m.lspClients, lspcomponent.RenderOptions{\n\t\tMaxWidth:    maxWidth,\n\t\tMaxItems:    maxItems,\n\t\tShowSection: true,\n\t\tSectionName: \"LSPs\",\n\t}, true)\n}\n\n// mcpBlockCompact renders the MCP block with limited width and height for horizontal layout",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_mcpBlockCompact_435": {
      "name": "mcpBlockCompact",
      "type": "method",
      "start_line": 435,
      "end_line": 450,
      "content_hash": "3f9259c9af6e7c9735ede4c64ffbf8053006b0a5",
      "content": "func (m *sidebarCmp) mcpBlockCompact(maxWidth int) string {\n\t// Limit items for horizontal layout\n\tmaxItems := min(5, len(config.Get().MCP.Sorted()))\n\tavailableHeight := m.height - 8\n\tif availableHeight > 0 {\n\t\tmaxItems = min(maxItems, availableHeight)\n\t}\n\n\treturn mcp.RenderMCPBlock(mcp.RenderOptions{\n\t\tMaxWidth:    maxWidth,\n\t\tMaxItems:    maxItems,\n\t\tShowSection: true,\n\t\tSectionName: \"MCPs\",\n\t}, true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_filesBlock_451": {
      "name": "filesBlock",
      "type": "method",
      "start_line": 451,
      "end_line": 478,
      "content_hash": "d77c75a39d78a38c9b1b24af23186994c7e305f3",
      "content": "func (m *sidebarCmp) filesBlock() string {\n\t// Convert map to slice and handle type conversion\n\tsessionFiles := slices.Collect(m.files.Seq())\n\tfileSlice := make([]files.SessionFile, len(sessionFiles))\n\tfor i, sf := range sessionFiles {\n\t\tfileSlice[i] = files.SessionFile{\n\t\t\tHistory: files.FileHistory{\n\t\t\t\tInitialVersion: sf.History.initialVersion,\n\t\t\t\tLatestVersion:  sf.History.latestVersion,\n\t\t\t},\n\t\t\tFilePath:  sf.FilePath,\n\t\t\tAdditions: sf.Additions,\n\t\t\tDeletions: sf.Deletions,\n\t\t}\n\t}\n\n\t// Limit the number of files shown\n\tmaxFiles, _, _ := m.getDynamicLimits()\n\tmaxFiles = min(len(fileSlice), maxFiles)\n\n\treturn files.RenderFileBlock(fileSlice, files.RenderOptions{\n\t\tMaxWidth:    m.getMaxWidth(),\n\t\tMaxItems:    maxFiles,\n\t\tShowSection: true,\n\t\tSectionName: core.Section(\"Modified Files\", m.getMaxWidth()),\n\t}, true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_lspBlock_479": {
      "name": "lspBlock",
      "type": "method",
      "start_line": 479,
      "end_line": 492,
      "content_hash": "5e8cfb97271e174389f4f5cbdf551333da0ae8e8",
      "content": "func (m *sidebarCmp) lspBlock() string {\n\t// Limit the number of LSPs shown\n\t_, maxLSPs, _ := m.getDynamicLimits()\n\tlspConfigs := config.Get().LSP.Sorted()\n\tmaxLSPs = min(len(lspConfigs), maxLSPs)\n\n\treturn lspcomponent.RenderLSPBlock(m.lspClients, lspcomponent.RenderOptions{\n\t\tMaxWidth:    m.getMaxWidth(),\n\t\tMaxItems:    maxLSPs,\n\t\tShowSection: true,\n\t\tSectionName: core.Section(\"LSPs\", m.getMaxWidth()),\n\t}, true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_mcpBlock_493": {
      "name": "mcpBlock",
      "type": "method",
      "start_line": 493,
      "end_line": 506,
      "content_hash": "824c50004cd991a7bec8e4b2cf5ba4e05470f37e",
      "content": "func (m *sidebarCmp) mcpBlock() string {\n\t// Limit the number of MCPs shown\n\t_, _, maxMCPs := m.getDynamicLimits()\n\tmcps := config.Get().MCP.Sorted()\n\tmaxMCPs = min(len(mcps), maxMCPs)\n\n\treturn mcp.RenderMCPBlock(mcp.RenderOptions{\n\t\tMaxWidth:    m.getMaxWidth(),\n\t\tMaxItems:    maxMCPs,\n\t\tShowSection: true,\n\t\tSectionName: core.Section(\"MCPs\", m.getMaxWidth()),\n\t}, true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatTokensAndCost_507": {
      "name": "formatTokensAndCost",
      "type": "function",
      "start_line": 507,
      "end_line": 548,
      "content_hash": "cf48f88639cd07b69f3caeb257b04b7cd4e7500c",
      "content": "func formatTokensAndCost(tokens, contextWindow int64, cost float64) string {\n\tt := styles.CurrentTheme()\n\t// Format tokens in human-readable format (e.g., 110K, 1.2M)\n\tvar formattedTokens string\n\tswitch {\n\tcase tokens >= 1_000_000:\n\t\tformattedTokens = fmt.Sprintf(\"%.1fM\", float64(tokens)/1_000_000)\n\tcase tokens >= 1_000:\n\t\tformattedTokens = fmt.Sprintf(\"%.1fK\", float64(tokens)/1_000)\n\tdefault:\n\t\tformattedTokens = fmt.Sprintf(\"%d\", tokens)\n\t}\n\n\t// Remove .0 suffix if present\n\tif strings.HasSuffix(formattedTokens, \".0K\") {\n\t\tformattedTokens = strings.Replace(formattedTokens, \".0K\", \"K\", 1)\n\t}\n\tif strings.HasSuffix(formattedTokens, \".0M\") {\n\t\tformattedTokens = strings.Replace(formattedTokens, \".0M\", \"M\", 1)\n\t}\n\n\t// Calculate percentage, handling zero context window\n\tpercentage := 0.0\n\tif contextWindow > 0 {\n\t\tpercentage = (float64(tokens) / float64(contextWindow)) * 100\n\t}\n\n\tbaseStyle := t.S().Base\n\n\tformattedCost := baseStyle.Foreground(t.FgMuted).Render(fmt.Sprintf(\"$%.2f\", cost))\n\n\tformattedTokens = baseStyle.Foreground(t.FgSubtle).Render(fmt.Sprintf(\"(%s)\", formattedTokens))\n\tformattedPercentage := baseStyle.Foreground(t.FgMuted).Render(fmt.Sprintf(\"%d%%\", int(percentage)))\n\tformattedTokens = fmt.Sprintf(\"%s %s\", formattedPercentage, formattedTokens)\n\tif percentage > 80 {\n\t\t// add the warning icon\n\t\tformattedTokens = fmt.Sprintf(\"%s %s\", styles.WarningIcon, formattedTokens)\n\t}\n\n\treturn fmt.Sprintf(\"%s %s\", formattedTokens, formattedCost)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_currentModelBlock_549": {
      "name": "currentModelBlock",
      "type": "method",
      "start_line": 549,
      "end_line": 615,
      "content_hash": "7cef33f06a86d9f1d66fff2343421917b858020d",
      "content": "func (s *sidebarCmp) currentModelBlock() string {\n\tcfg := config.Get()\n\tagentCfg := cfg.Agents[config.AgentCoder]\n\n\tif agentCfg.Model == \"\" {\n\t\treturn styles.CurrentTheme().S().Text.Render(\"No model configured\")\n\t}\n\n\tselectedModel := cfg.Models[agentCfg.Model]\n\tif selectedModel.Provider == \"\" {\n\t\treturn styles.CurrentTheme().S().Text.Render(\"No provider configured\")\n\t}\n\n\tmodel := cfg.GetModelByType(agentCfg.Model)\n\tif model == nil {\n\t\treturn styles.CurrentTheme().S().Text.Render(\"Model not found\")\n\t}\n\n\tmodelProvider := cfg.GetProviderForModel(agentCfg.Model)\n\tif modelProvider == nil {\n\t\treturn styles.CurrentTheme().S().Text.Render(\"Provider not found\")\n\t}\n\n\tt := styles.CurrentTheme()\n\n\tmodelIcon := t.S().Base.Foreground(t.FgSubtle).Render(styles.ModelIcon)\n\tmodelName := t.S().Text.Render(model.Name)\n\tmodelInfo := fmt.Sprintf(\"%s %s\", modelIcon, modelName)\n\tparts := []string{\n\t\tmodelInfo,\n\t}\n\tif model.CanReason {\n\t\treasoningInfoStyle := t.S().Subtle.PaddingLeft(2)\n\t\tswitch modelProvider.Type {\n\t\tcase catwalk.TypeAnthropic:\n\t\t\tformatter := cases.Title(language.English, cases.NoLower)\n\t\t\tif selectedModel.Think {\n\t\t\t\tparts = append(parts, reasoningInfoStyle.Render(formatter.String(\"Thinking on\")))\n\t\t\t} else {\n\t\t\t\tparts = append(parts, reasoningInfoStyle.Render(formatter.String(\"Thinking off\")))\n\t\t\t}\n\t\tdefault:\n\t\t\treasoningEffort := model.DefaultReasoningEffort\n\t\t\tif selectedModel.ReasoningEffort != \"\" {\n\t\t\t\treasoningEffort = selectedModel.ReasoningEffort\n\t\t\t}\n\t\t\tformatter := cases.Title(language.English, cases.NoLower)\n\t\t\tparts = append(parts, reasoningInfoStyle.Render(formatter.String(fmt.Sprintf(\"Reasoning %s\", reasoningEffort))))\n\t\t}\n\t}\n\tif s.session.ID != \"\" && model != nil {\n\t\tparts = append(\n\t\t\tparts,\n\t\t\t\"  \"+formatTokensAndCost(\n\t\t\t\ts.session.CompletionTokens+s.session.PromptTokens,\n\t\t\t\tint64(model.ContextWindow),\n\t\t\t\ts.session.Cost,\n\t\t\t),\n\t\t)\n\t}\n\treturn lipgloss.JoinVertical(\n\t\tlipgloss.Left,\n\t\tparts...,\n\t)\n}\n\n// SetSession implements Sidebar.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSession_616": {
      "name": "SetSession",
      "type": "method",
      "start_line": 616,
      "end_line": 621,
      "content_hash": "08a8954b75da5c798667e7e8fa871c0ab9cf5bb2",
      "content": "func (m *sidebarCmp) SetSession(session session.Session) tea.Cmd {\n\tm.session = session\n\treturn m.loadSessionFiles\n}\n\n// SetCompactMode sets the compact mode for the sidebar.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetCompactMode_622": {
      "name": "SetCompactMode",
      "type": "method",
      "start_line": 622,
      "end_line": 625,
      "content_hash": "2cf2250c9c9682efa87ae6855a6a3c5b2902681d",
      "content": "func (m *sidebarCmp) SetCompactMode(compact bool) {\n\tm.compactMode = compact\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_cwd_626": {
      "name": "cwd",
      "type": "function",
      "start_line": 626,
      "end_line": 630,
      "content_hash": "db6bdfceeba4428648a2e85206e7daefe7e9fe95",
      "content": "func cwd() string {\n\tcwd := config.Get().WorkingDir()\n\tt := styles.CurrentTheme()\n\treturn t.S().Muted.Render(home.Short(cwd))\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}