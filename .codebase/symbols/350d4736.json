{
  "file_path": "/work/external-deps/Context-Engine/vscode-extension/context-engine-uploader/sidebar.js",
  "file_hash": "7844c5fc3a900a5b56a75f32e36a72298af2aefc",
  "updated_at": "2025-12-26T17:34:21.728890",
  "symbols": {
    "function_makeTreeItem_6": {
      "name": "makeTreeItem",
      "type": "function",
      "start_line": 6,
      "end_line": 24,
      "content_hash": "5fe220ddab56f073ae91bd4c8b87276a4db4d792",
      "content": "function makeTreeItem(label, opts = {}) {\n  const item = new vscode.TreeItem(label, opts.collapsibleState || vscode.TreeItemCollapsibleState.None);\n  if (opts.description !== undefined) {\n    item.description = opts.description;\n  }\n  if (opts.tooltip !== undefined) {\n    item.tooltip = opts.tooltip;\n  }\n  if (opts.icon !== undefined) {\n    item.iconPath = opts.icon;\n  }\n  if (opts.command !== undefined) {\n    item.command = opts.command;\n  }\n  if (opts.contextValue !== undefined) {\n    item.contextValue = opts.contextValue;\n  }\n  return item;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createProvider_26": {
      "name": "createProvider",
      "type": "function",
      "start_line": 26,
      "end_line": 34,
      "content_hash": "5106107ebe88d1da49d43bd3faa48e254d8ef573",
      "content": "function createProvider(getChildrenFn) {\n  const emitter = new vscode.EventEmitter();\n  return {\n    onDidChangeTreeData: emitter.event,\n    refresh: () => emitter.fire(undefined),\n    getTreeItem: element => element,\n    getChildren: async element => getChildrenFn(element),\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveMcpMode_36": {
      "name": "resolveMcpMode",
      "type": "function",
      "start_line": 36,
      "end_line": 46,
      "content_hash": "2728818c0e9dd9ffdcf7f2647491b1b6203f1625",
      "content": "function resolveMcpMode(cfg) {\n  try {\n    const transportModeRaw = cfg.get('mcpTransportMode') || 'sse-remote';\n    const serverModeRaw = cfg.get('mcpServerMode') || 'bridge';\n    const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n    const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n    return `${serverMode}/${transportMode}`;\n  } catch (_) {\n    return 'unknown';\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getWorkspaceRoot_48": {
      "name": "getWorkspaceRoot",
      "type": "function",
      "start_line": 48,
      "end_line": 58,
      "content_hash": "c1b9cb473a13d8946a099e34d4dba7cfe25f0faa",
      "content": "function getWorkspaceRoot() {\n  try {\n    const folders = vscode.workspace.workspaceFolders;\n    if (folders && folders.length) {\n      return folders[0].uri.fsPath;\n    }\n  } catch (_) {\n    // ignore\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_pathExists_60": {
      "name": "pathExists",
      "type": "function",
      "start_line": 60,
      "end_line": 70,
      "content_hash": "1168169d8f5732915a129a6481184c314b745553",
      "content": "function pathExists(p, expectDir = false) {\n  try {\n    if (!p) {\n      return false;\n    }\n    const stat = fs.statSync(p);\n    return expectDir ? stat.isDirectory() : stat.isFile();\n  } catch (_) {\n    return false;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findConfigFile_72": {
      "name": "findConfigFile",
      "type": "function",
      "start_line": 72,
      "end_line": 83,
      "content_hash": "25613aa3b4c1c02c29447e32e2d94c1527093453",
      "content": "function findConfigFile(bases, filename) {\n  for (const base of bases) {\n    if (!base) {\n      continue;\n    }\n    const candidate = path.join(base, filename);\n    if (pathExists(candidate)) {\n      return candidate;\n    }\n  }\n  return undefined;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_probeEndpointReachable_93": {
      "name": "probeEndpointReachable",
      "type": "function",
      "start_line": 93,
      "end_line": 125,
      "content_hash": "d32fdf2b0c26179a0203cbac6d7ab0b23b5ca7d2",
      "content": "async function probeEndpointReachable(endpoint) {\n  const base = (endpoint || '').trim().replace(/\\/+$/, '');\n  if (!base) {\n    return undefined;\n  }\n\n  const fetchFn = (typeof fetch === 'function' ? fetch : undefined);\n  if (!fetchFn) {\n    return undefined;\n  }\n\n  let timer;\n  let controller;\n  try {\n    controller = (typeof AbortController === 'function') ? new AbortController() : undefined;\n    if (controller) {\n      timer = setTimeout(() => {\n        try { controller.abort(); } catch (_) { }\n      }, _ENDPOINT_REACHABLE_TIMEOUT_MS);\n    }\n    const res = await fetchFn(`${base}/health`, { method: 'GET', signal: controller ? controller.signal : undefined });\n    if (!res) {\n      return false;\n    }\n    return !!res.ok;\n  } catch (_) {\n    return false;\n  } finally {\n    if (timer) {\n      clearTimeout(timer);\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getCachedEndpointReachable_127": {
      "name": "getCachedEndpointReachable",
      "type": "function",
      "start_line": 127,
      "end_line": 140,
      "content_hash": "79a77d512fba8df7441df92d06df5eb9308c69ad",
      "content": "async function getCachedEndpointReachable(endpoint) {\n  const key = (endpoint || '').trim();\n  if (!key) {\n    return undefined;\n  }\n  const now = Date.now();\n  const cached = _endpointReachableCache.get(key);\n  if (cached && cached.ts && (now - cached.ts) < _ENDPOINT_REACHABLE_TTL_MS) {\n    return cached.reachable;\n  }\n  const reachable = await probeEndpointReachable(key);\n  _endpointReachableCache.set(key, { reachable, ts: now });\n  return reachable;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_probeAuthEnabled_142": {
      "name": "probeAuthEnabled",
      "type": "function",
      "start_line": 142,
      "end_line": 178,
      "content_hash": "a1fe9b93d85a958fd03ac9b6b25872a48dddcaba",
      "content": "async function probeAuthEnabled(endpoint) {\n  const base = (endpoint || '').trim().replace(/\\/+$/, '');\n  if (!base) {\n    return undefined;\n  }\n\n  const fetchFn = (typeof fetch === 'function' ? fetch : undefined);\n  if (!fetchFn) {\n    return undefined;\n  }\n\n  let timer;\n  let controller;\n  try {\n    controller = (typeof AbortController === 'function') ? new AbortController() : undefined;\n    if (controller) {\n      timer = setTimeout(() => {\n        try { controller.abort(); } catch (_) { }\n      }, _AUTH_STATUS_TIMEOUT_MS);\n    }\n    const res = await fetchFn(`${base}/auth/status`, { method: 'GET', signal: controller ? controller.signal : undefined });\n    if (!res || !res.ok) {\n      return undefined;\n    }\n    const body = await res.json();\n    if (body && typeof body.enabled === 'boolean') {\n      return body.enabled;\n    }\n    return undefined;\n  } catch (_) {\n    return undefined;\n  } finally {\n    if (timer) {\n      clearTimeout(timer);\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getCachedAuthEnabled_180": {
      "name": "getCachedAuthEnabled",
      "type": "function",
      "start_line": 180,
      "end_line": 193,
      "content_hash": "2875775b9812137e45f3129ff310347a35ed3f37",
      "content": "async function getCachedAuthEnabled(endpoint) {\n  const key = (endpoint || '').trim();\n  if (!key) {\n    return undefined;\n  }\n  const now = Date.now();\n  const cached = _authStatusCache.get(key);\n  if (cached && cached.ts && (now - cached.ts) < _AUTH_STATUS_TTL_MS) {\n    return cached.enabled;\n  }\n  const enabled = await probeAuthEnabled(key);\n  _authStatusCache.set(key, { enabled, ts: now });\n  return enabled;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_register_195": {
      "name": "register",
      "type": "function",
      "start_line": 195,
      "end_line": 633,
      "content_hash": "96731f467907f06bbf28011c978ed4ae0f6f1448",
      "content": "function register(context, deps) {\n  const profiles = deps && deps.profiles;\n  const getEffectiveConfig = deps && deps.getEffectiveConfig;\n  const getResolvedTargetPath = deps && deps.getResolvedTargetPath;\n  const getState = deps && deps.getState;\n  const onboarding = deps && deps.onboarding;\n\n  const providers = [];\n\n  const profilesProvider = createProvider(async element => {\n    if (!profiles || typeof profiles.listProfiles !== 'function') {\n      return [];\n    }\n\n    if (!element) {\n      return [\n        makeTreeItem('Active Profile', { collapsibleState: vscode.TreeItemCollapsibleState.Expanded, contextValue: 'ctxceProfilesActiveRoot' }),\n        makeTreeItem('Manage Profiles', { collapsibleState: vscode.TreeItemCollapsibleState.Collapsed, contextValue: 'ctxceProfilesManageRoot' }),\n      ];\n    }\n\n    if (element.contextValue === 'ctxceProfilesActiveRoot') {\n      const active = typeof profiles.getActiveProfileSummary === 'function' ? profiles.getActiveProfileSummary() : { id: undefined, name: undefined };\n      const list = profiles.listProfiles();\n      const items = [];\n\n      items.push(makeTreeItem(`Current: ${active && active.id ? (active.name || active.id) : 'None'}`, {\n        description: active && active.id ? active.id : '',\n        icon: new vscode.ThemeIcon(active && active.id ? 'check' : 'circle-slash'),\n        contextValue: 'ctxceProfilesCurrent',\n      }));\n\n      items.push(makeTreeItem('None (use VS Code settings)', {\n        icon: new vscode.ThemeIcon(!active || !active.id ? 'check' : 'circle-slash'),\n        command: {\n          command: 'contextEngineUploader._setActiveProfile',\n          title: 'Set Active Profile',\n          arguments: [''],\n        },\n        contextValue: 'ProfilesChoice',\n      }));\n\n      for (const p of list) {\n        const isActive = !!(active && active.id && p.id === active.id);\n        items.push(makeTreeItem(p.name || p.id, {\n          description: p.id,\n          icon: new vscode.ThemeIcon(isActive ? 'check' : 'circle-outline'),\n          command: {\n            command: 'contextEngineUploader._setActiveProfile',\n            title: 'Set Active Profile',\n            arguments: [p.id],\n          },\n          contextValue: 'ProfilesChoice',\n        }));\n      }\n\n      return items;\n    }\n\n    if (element.contextValue === 'ctxceProfilesManageRoot') {\n      return [\n        makeTreeItem('Setup Workspace', { icon: new vscode.ThemeIcon('rocket'), command: { command: 'contextEngineUploader.setupWorkspace', title: 'Setup Workspace' } }),\n        makeTreeItem('Switch Profile', { icon: new vscode.ThemeIcon('sync'), command: { command: 'contextEngineUploader.switchProfile', title: 'Switch Profile' } }),\n        makeTreeItem('Create Profile From Current Settings', { icon: new vscode.ThemeIcon('add'), command: { command: 'contextEngineUploader.createProfileFromCurrentSettings', title: 'Create Profile From Current Settings' } }),\n        makeTreeItem('Import Profiles', { icon: new vscode.ThemeIcon('cloud-download'), command: { command: 'contextEngineUploader.importProfiles', title: 'Import Profiles' } }),\n        makeTreeItem('Export Profiles', { icon: new vscode.ThemeIcon('cloud-upload'), command: { command: 'contextEngineUploader.exportProfiles', title: 'Export Profiles' } }),\n      ];\n    }\n\n    return [];\n  });\n\n  const statusProvider = createProvider(async () => {\n    const cfg = getEffectiveConfig ? getEffectiveConfig() : vscode.workspace.getConfiguration('contextEngineUploader');\n    const state = typeof getState === 'function' ? getState() : {};\n\n    const endpoint = (() => {\n      try { return (cfg.get('endpoint') || '').trim(); } catch (_) { return ''; }\n    })();\n\n    const resolvedTarget = typeof getResolvedTargetPath === 'function' ? getResolvedTargetPath() : undefined;\n    const targetDescription = resolvedTarget && resolvedTarget.path ? resolvedTarget.path : '(unset)';\n    const targetTooltip = resolvedTarget && resolvedTarget.source ? `Source: ${resolvedTarget.source}` : undefined;\n\n    const mcpMode = resolveMcpMode(cfg);\n    const bridge = state && state.httpBridgeProcess ? `running:${state.httpBridgePort || ''}` : 'stopped';\n\n    return [\n      makeTreeItem('Run State', { description: state && state.statusMode ? state.statusMode : 'unknown', icon: new vscode.ThemeIcon('pulse') }),\n      makeTreeItem('Endpoint', { description: endpoint || '(unset)', icon: new vscode.ThemeIcon('link') }),\n      makeTreeItem('Target Path', { description: targetDescription, tooltip: targetTooltip, icon: new vscode.ThemeIcon('folder') }),\n      makeTreeItem('MCP Mode', { description: mcpMode, icon: new vscode.ThemeIcon('plug') }),\n      makeTreeItem('HTTP Bridge', { description: bridge, icon: new vscode.ThemeIcon('server-process') }),\n    ];\n  });\n\n  const actionsProvider = createProvider(async (element) => {\n    if (!element) {\n      return [\n        makeTreeItem('Getting Started', { collapsibleState: vscode.TreeItemCollapsibleState.Expanded, contextValue: 'ctxceActionsGettingStartedRoot' }),\n        makeTreeItem('Upload & Watch', { collapsibleState: vscode.TreeItemCollapsibleState.Expanded, contextValue: 'ctxceActionsUploadRoot' }),\n        makeTreeItem('MCP Bridge & Config', { collapsibleState: vscode.TreeItemCollapsibleState.Collapsed, contextValue: 'ctxceActionsBridgeRoot' }),\n        makeTreeItem('Utilities', { collapsibleState: vscode.TreeItemCollapsibleState.Collapsed, contextValue: 'ctxceActionsUtilitiesRoot' }),\n      ];\n    }\n\n    if (element.contextValue === 'ctxceActionsGettingStartedRoot') {\n      const cfg = getEffectiveConfig ? getEffectiveConfig() : vscode.workspace.getConfiguration('contextEngineUploader');\n\n      const endpoint = (() => {\n        try { return (cfg.get('endpoint') || '').trim(); } catch (_) { return ''; }\n      })();\n\n      const endpointExplicitlyConfigured = (() => {\n        try {\n          const overrides = profiles && typeof profiles.getActiveProfileOverrides === 'function'\n            ? profiles.getActiveProfileOverrides()\n            : {};\n          if (overrides && typeof overrides === 'object' && Object.prototype.hasOwnProperty.call(overrides, 'endpoint')) {\n            return true;\n          }\n        } catch (_) {\n        }\n        try {\n          const inspected = (cfg && typeof cfg.inspect === 'function') ? cfg.inspect('endpoint') : undefined;\n          if (!inspected || typeof inspected !== 'object') {\n            return false;\n          }\n          return inspected.workspaceFolderValue !== undefined || inspected.workspaceValue !== undefined || inspected.globalValue !== undefined;\n        } catch (_) {\n          return false;\n        }\n      })();\n\n      const endpointReachable = endpoint ? await getCachedEndpointReachable(endpoint) : undefined;\n\n      const resolvedTarget = typeof getResolvedTargetPath === 'function' ? getResolvedTargetPath() : undefined;\n      const targetDescription = resolvedTarget && resolvedTarget.path ? resolvedTarget.path : '(unset)';\n      const targetPath = resolvedTarget && resolvedTarget.path ? String(resolvedTarget.path) : '';\n      const targetExists = pathExists(targetPath, true);\n      const workspaceRoot = getWorkspaceRoot();\n      const configSearchBases = [targetPath, workspaceRoot].filter(Boolean);\n      const mcpConfigPath = findConfigFile(configSearchBases, '.mcp.json');\n      const ctxConfigPath = findConfigFile(configSearchBases, 'ctx_config.json');\n\n      const claudeEnabled = (() => {\n        try { return !!cfg.get('mcpClaudeEnabled', true); } catch (_) { return true; }\n      })();\n      const windsurfEnabled = (() => {\n        try { return !!cfg.get('mcpWindsurfEnabled', false); } catch (_) { return false; }\n      })();\n      const augmentEnabled = (() => {\n        try { return !!cfg.get('mcpAugmentEnabled', false); } catch (_) { return false; }\n      })();\n      const windsurfMcpPath = (() => {\n        try {\n          const custom = (cfg.get('windsurfMcpPath') || '').trim();\n          return custom || getDefaultWindsurfMcpPath();\n        } catch (_) {\n          return getDefaultWindsurfMcpPath();\n        }\n      })();\n      const augmentMcpPath = (() => {\n        try {\n          const custom = (cfg.get('augmentMcpPath') || '').trim();\n          return custom || getDefaultAugmentMcpPath();\n        } catch (_) {\n          return getDefaultAugmentMcpPath();\n        }\n      })();\n\n      const bridgeMode = (() => {\n        const mode = resolveMcpMode(cfg);\n        return typeof mode === 'string' && mode.startsWith('bridge/');\n      })();\n\n      const authEnabled = bridgeMode && endpoint && endpointReachable !== false ? await getCachedAuthEnabled(endpoint) : undefined;\n      const showAuth = !!(bridgeMode && endpoint && endpointReachable !== false && (authEnabled === true || authEnabled === undefined));\n\n      const missingEndpoint = !endpointExplicitlyConfigured || !endpoint;\n      const missingTarget = !targetPath || !targetExists;\n      const missingClaudeMcpConfig = !!(claudeEnabled && !mcpConfigPath);\n      const missingWindsurfMcpConfig = !!(windsurfEnabled && windsurfMcpPath && !pathExists(windsurfMcpPath));\n      const missingAugmentMcpConfig = !!(augmentEnabled && augmentMcpPath && !pathExists(augmentMcpPath));\n      const missingAnyMcpConfig = !!(missingClaudeMcpConfig || missingWindsurfMcpConfig || missingAugmentMcpConfig);\n      const missingCtxConfig = !ctxConfigPath;\n\n      const items = [\n        makeTreeItem('Setup Workspace', {\n          icon: new vscode.ThemeIcon('rocket'),\n          command: { command: 'contextEngineUploader.setupWorkspace', title: 'Setup Workspace' },\n          tooltip: 'Create and configure a profile for this workspace (recommended for first-time setup).',\n        }),\n      ];\n\n      const showCloneStack = !!(\n        onboarding &&\n        typeof onboarding.cloneAndStartStack === 'function' &&\n        (\n          endpointReachable === false ||\n          (!endpointExplicitlyConfigured && endpointReachable !== true)\n        )\n      );\n\n      if (showCloneStack) {\n        items.push(makeTreeItem('Clone & Start Context Engine Stack', {\n          icon: new vscode.ThemeIcon('cloud-download'),\n          command: { command: 'contextEngineUploader.cloneAndStartStack', title: 'Clone Stack & Run docker compose' },\n          tooltip: 'Clone https://github.com/m1rl0k/Context-Engine.git into a folder you choose and run docker compose up -d.',\n        }));\n      }\n\n      const savedStackPath = (() => {\n        try {\n          if (onboarding && typeof onboarding.getSavedStackPath === 'function') {\n            return onboarding.getSavedStackPath();\n          }\n        } catch (_) {\n        }\n        return undefined;\n      })();\n\n      if (endpointReachable === false && savedStackPath) {\n        items.push(makeTreeItem('Start Context Engine Stack', {\n          icon: new vscode.ThemeIcon('play'),\n          command: { command: 'contextEngineUploader.startSavedStack', title: 'Start Saved Stack' },\n          tooltip: `Start docker compose for the previously cloned stack at ${savedStackPath}`,\n        }));\n      }\n\n      items.push(\n        makeTreeItem('Read Docs', {\n          icon: new vscode.ThemeIcon('book'),\n          command: {\n            command: 'vscode.open',\n            title: 'Open Context Engine Docs',\n            arguments: [vscode.Uri.parse('https://github.com/m1rl0k/Context-Engine/blob/test/docs/GETTING_STARTED.md')],\n          },\n          tooltip: 'Open the Context Engine documentation in your browser.',\n        })\n      );\n\n      items.push(\n        makeTreeItem('Open Settings', {\n          icon: new vscode.ThemeIcon('gear'),\n          command: { command: 'workbench.action.openSettings', title: 'Open Settings', arguments: ['contextEngineUploader'] },\n          tooltip: 'Open VS Code settings filtered to Context Engine Uploader.',\n        })\n      );\n\n      if (missingEndpoint) {\n        items.push(makeTreeItem('Check Endpoint', {\n          description: '(unset)',\n          icon: new vscode.ThemeIcon('warning'),\n          command: { command: 'workbench.action.openSettings', title: 'Open Settings', arguments: ['contextEngineUploader.endpoint'] },\n          tooltip: 'Configure the upload service endpoint.',\n        }));\n      }\n\n      if (missingTarget) {\n        items.push(makeTreeItem('Check Target Path', {\n          description: targetPath ? `${targetDescription} (missing)` : '(unset)',\n          icon: new vscode.ThemeIcon('warning'),\n          command: { command: 'workbench.action.openSettings', title: 'Open Settings', arguments: ['contextEngineUploader.targetPath'] },\n          tooltip: 'Configure the target path to index/upload.',\n        }));\n      }\n\n      if (missingAnyMcpConfig) {\n        items.push(makeTreeItem('Write MCP Config...', {\n          description: 'Missing',\n          icon: new vscode.ThemeIcon('warning'),\n          command: { command: 'contextEngineUploader.writeMcpConfigSelect', title: 'Write MCP Config...' },\n          tooltip: 'Select which MCP config to write (All enabled, Claude, Windsurf, Augment).',\n        }));\n      }\n\n      if (missingCtxConfig) {\n        items.push(makeTreeItem('Write CTX Config (ctx_config.json)', {\n          description: 'Missing',\n          icon: new vscode.ThemeIcon('warning'),\n          command: { command: 'contextEngineUploader.writeCtxConfig', title: 'Write CTX Config' },\n          tooltip: 'Scaffold ctx_config.json/.env for local tools (Prompt+, etc.).',\n        }));\n      }\n\n      if (!missingEndpoint && !missingTarget && !missingAnyMcpConfig && !missingCtxConfig) {\n        items.push(makeTreeItem('All set', {\n          description: 'Ready',\n          icon: new vscode.ThemeIcon('check'),\n          tooltip: 'Workspace looks ready. You can start indexing/uploading now.',\n        }));\n      }\n\n      if (showAuth) {\n        items.push(makeTreeItem('Sign In', {\n          icon: new vscode.ThemeIcon('account'),\n          command: { command: 'contextEngineUploader.authLogin', title: 'Sign In' },\n          tooltip: 'Runs ctxce auth login for the configured endpoint.',\n        }));\n      }\n\n      return items;\n    }\n\n    if (element.contextValue === 'ctxceActionsUploadRoot') {\n      return [\n        makeTreeItem('Force Index Now', {\n          icon: new vscode.ThemeIcon('sync'),\n          command: { command: 'contextEngineUploader.indexCodebase', title: 'Index Codebase' },\n          tooltip: 'Runs the force upload once (then watch if enabled).',\n        }),\n        makeTreeItem('Start Upload / Watch', {\n          icon: new vscode.ThemeIcon('play'),\n          command: { command: 'contextEngineUploader.start', title: 'Start Upload / Watch' },\n        }),\n        makeTreeItem('Stop Upload / Watch', {\n          icon: new vscode.ThemeIcon('stop'),\n          command: { command: 'contextEngineUploader.stop', title: 'Stop Upload / Watch' },\n        }),\n        makeTreeItem('Restart Upload / Watch', {\n          icon: new vscode.ThemeIcon('refresh'),\n          command: { command: 'contextEngineUploader.restart', title: 'Restart Upload / Watch' },\n        }),\n        makeTreeItem('Show Extension Output', {\n          icon: new vscode.ThemeIcon('output'),\n          command: { command: 'contextEngineUploader.showUploadServiceLogs', title: 'Show Extension Output' },\n        }),\n        makeTreeItem('Tail Upload Service Logs (Docker)', {\n          icon: new vscode.ThemeIcon('terminal'),\n          command: { command: 'contextEngineUploader.tailUploadServiceLogs', title: 'Tail Upload Service Logs (Docker)' },\n        }),\n      ];\n    }\n\n    if (element.contextValue === 'ctxceActionsBridgeRoot') {\n      return [\n        makeTreeItem('Write MCP Config...', {\n          icon: new vscode.ThemeIcon('file-code'),\n          command: { command: 'contextEngineUploader.writeMcpConfigSelect', title: 'Write MCP Config...' },\n          tooltip: 'Select which MCP config to write (All enabled, Claude, Windsurf, Augment).',\n        }),\n        makeTreeItem('Write CTX Config (ctx_config.json)', {\n          icon: new vscode.ThemeIcon('file-text'),\n          command: { command: 'contextEngineUploader.writeCtxConfig', title: 'Write CTX Config' },\n        }),\n        makeTreeItem('Start MCP HTTP Bridge', {\n          icon: new vscode.ThemeIcon('broadcast'),\n          command: { command: 'contextEngineUploader.startMcpHttpBridge', title: 'Start MCP HTTP Bridge' },\n        }),\n        makeTreeItem('Stop MCP HTTP Bridge', {\n          icon: new vscode.ThemeIcon('debug-stop'),\n          command: { command: 'contextEngineUploader.stopMcpHttpBridge', title: 'Stop MCP HTTP Bridge' },\n        }),\n      ];\n    }\n\n    if (element.contextValue === 'ctxceActionsUtilitiesRoot') {\n      const cfg = getEffectiveConfig ? getEffectiveConfig() : vscode.workspace.getConfiguration('contextEngineUploader');\n      const endpoint = (() => {\n        try { return (cfg.get('endpoint') || '').trim(); } catch (_) { return ''; }\n      })();\n      const bridgeMode = (() => {\n        const mode = resolveMcpMode(cfg);\n        return typeof mode === 'string' && mode.startsWith('bridge/');\n      })();\n      const endpointReachable = endpoint ? await getCachedEndpointReachable(endpoint) : undefined;\n      const authEnabled = bridgeMode && endpoint && endpointReachable !== false ? await getCachedAuthEnabled(endpoint) : undefined;\n      const showAuth = !!(bridgeMode && endpoint && endpointReachable !== false && (authEnabled === true || authEnabled === undefined));\n\n      const items = [\n        makeTreeItem('Prompt+ (Replace Selection)', { icon: new vscode.ThemeIcon('sparkle'), command: { command: 'contextEngineUploader.promptEnhance', title: 'Prompt+ (Replace Selection)' } }),\n        makeTreeItem('Prompt+ (Copy to Clipboard)', { icon: new vscode.ThemeIcon('copy'), command: { command: 'contextEngineUploader.promptEnhanceCopy', title: 'Prompt+ (Copy to Clipboard)' } }),\n        makeTreeItem('Prompt+ (Open in New Editor)', { icon: new vscode.ThemeIcon('open-preview'), command: { command: 'contextEngineUploader.promptEnhanceOpen', title: 'Prompt+ (Open in New Editor)' } }),\n        makeTreeItem('Prompt+ Default Mode...', { icon: new vscode.ThemeIcon('settings-gear'), command: { command: 'contextEngineUploader.setCtxDefaultMode', title: 'Prompt+ Default Mode' } }),\n      ];\n\n      if (showAuth) {\n        items.push(makeTreeItem('Sign In', { icon: new vscode.ThemeIcon('account'), command: { command: 'contextEngineUploader.authLogin', title: 'Sign In' } }));\n      }\n\n      return items;\n    }\n\n    return [];\n  });\n\n  providers.push(profilesProvider, statusProvider, actionsProvider);\n\n  const setActiveDisposable = vscode.commands.registerCommand('contextEngineUploader._setActiveProfile', async (profileId) => {\n    if (!profiles || typeof profiles.setActiveProfileId !== 'function') {\n      return;\n    }\n    await profiles.setActiveProfileId(profileId || undefined);\n    profilesProvider.refresh();\n    statusProvider.refresh();\n  });\n\n  context.subscriptions.push(setActiveDisposable);\n\n  const profilesTree = vscode.window.createTreeView('contextEngineUploaderProfiles', { treeDataProvider: profilesProvider, showCollapseAll: false });\n  const statusTree = vscode.window.createTreeView('contextEngineUploaderStatus', { treeDataProvider: statusProvider, showCollapseAll: false });\n  const actionsTree = vscode.window.createTreeView('contextEngineUploaderActions', { treeDataProvider: actionsProvider, showCollapseAll: false });\n\n  context.subscriptions.push(profilesTree, statusTree, actionsTree);\n\n  let refreshTimer;\n  const bumpTimer = () => {\n    const visible = profilesTree.visible || statusTree.visible || actionsTree.visible;\n    if (!visible) {\n      if (refreshTimer) {\n        clearInterval(refreshTimer);\n        refreshTimer = undefined;\n      }\n      return;\n    }\n    if (!refreshTimer) {\n      refreshTimer = setInterval(() => {\n        profilesProvider.refresh();\n        statusProvider.refresh();\n        actionsProvider.refresh();\n      }, 2000);\n    }\n  };\n\n  profilesTree.onDidChangeVisibility(bumpTimer, null, context.subscriptions);\n  statusTree.onDidChangeVisibility(bumpTimer, null, context.subscriptions);\n  actionsTree.onDidChangeVisibility(bumpTimer, null, context.subscriptions);\n\n  bumpTimer();\n\n  return {\n    refresh: () => {\n      for (const p of providers) {\n        p.refresh();\n      }\n    },\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bumpTimer_602": {
      "name": "bumpTimer",
      "type": "function",
      "start_line": 602,
      "end_line": 618,
      "content_hash": "1a28c54cdfbff08f072cbb1085112563934ed2f9",
      "content": "  const bumpTimer = () => {\n    const visible = profilesTree.visible || statusTree.visible || actionsTree.visible;\n    if (!visible) {\n      if (refreshTimer) {\n        clearInterval(refreshTimer);\n        refreshTimer = undefined;\n      }\n      return;\n    }\n    if (!refreshTimer) {\n      refreshTimer = setInterval(() => {\n        profilesProvider.refresh();\n        statusProvider.refresh();\n        actionsProvider.refresh();\n      }, 2000);\n    }\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}