{
  "file_path": "/work/.local/tools/modelscan/sdk/agent/coordinator.go",
  "file_hash": "019995bfcf1087b1afeccd4300cefd07d9da41f2",
  "updated_at": "2025-12-26T17:34:25.002767",
  "symbols": {
    "struct_Coordinator_13": {
      "name": "Coordinator",
      "type": "struct",
      "start_line": 13,
      "end_line": 33,
      "content_hash": "2c334858ec63299c869d49a6c48e11006965c6e1",
      "content": "type Coordinator struct {\n\tteam       *Team\n\ttaskQueue  chan Task\n\tactive     map[string]*TaskExecution\n\tcompleted  map[string]*TaskResult\n\tmu         sync.RWMutex\n\tcapability *CapabilityMatcher\n\tstrategy   DistributionStrategy\n}\n\n// DistributionStrategy defines how tasks are distributed\ntype DistributionStrategy int\n\nconst (\n\tDistributionStrategyRoundRobin DistributionStrategy = iota\n\tDistributionStrategyCapabilityBased\n\tDistributionStrategyLoadBalance\n\tDistributionStrategyPriority\n)\n\n// TaskExecution tracks an active task execution",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TaskExecution_34": {
      "name": "TaskExecution",
      "type": "struct",
      "start_line": 34,
      "end_line": 43,
      "content_hash": "23a2acb018249875184ffeb8d43e62ef660f566a",
      "content": "type TaskExecution struct {\n\tTask       Task\n\tAgentID    string\n\tStartTime  time.Time\n\tDeadline   time.Time\n\tCancelFunc context.CancelFunc\n\tResultChan chan *TaskResult\n}\n\n// CapabilityMatcher matches agents to tasks based on capabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CapabilityMatcher_44": {
      "name": "CapabilityMatcher",
      "type": "struct",
      "start_line": 44,
      "end_line": 50,
      "content_hash": "c74d150b4e8a4458ff098412fe8e40e0a6628ea9",
      "content": "type CapabilityMatcher struct {\n\tagentCapabilities   map[string][]string\n\ttaskRequirements    map[string][]string\n\trelatedCapabilities map[string][]string // Maps a capability to related capabilities\n}\n\n// NewCoordinator creates a new coordinator",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCoordinator_51": {
      "name": "NewCoordinator",
      "type": "function",
      "start_line": 51,
      "end_line": 62,
      "content_hash": "03ebd2adc583a7d0cc225f3de5e4c477c5e0ecaa",
      "content": "func NewCoordinator(team *Team) *Coordinator {\n\treturn &Coordinator{\n\t\tteam:       team,\n\t\ttaskQueue:  make(chan Task, 100),\n\t\tactive:     make(map[string]*TaskExecution),\n\t\tcompleted:  make(map[string]*TaskResult),\n\t\tcapability: NewCapabilityMatcher(),\n\t\tstrategy:   DistributionStrategyRoundRobin,\n\t}\n}\n\n// NewCoordinatorWithStrategy creates a new coordinator with specific strategy",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCoordinatorWithStrategy_63": {
      "name": "NewCoordinatorWithStrategy",
      "type": "function",
      "start_line": 63,
      "end_line": 74,
      "content_hash": "ef8c0bc70c7fff6a97e39cf655c303a580287ca9",
      "content": "func NewCoordinatorWithStrategy(team *Team, strategy DistributionStrategy) *Coordinator {\n\treturn &Coordinator{\n\t\tteam:       team,\n\t\ttaskQueue:  make(chan Task, 100),\n\t\tactive:     make(map[string]*TaskExecution),\n\t\tcompleted:  make(map[string]*TaskResult),\n\t\tcapability: NewCapabilityMatcher(),\n\t\tstrategy:   strategy,\n\t}\n}\n\n// ExecuteTask executes a task using the team",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ExecuteTask_75": {
      "name": "ExecuteTask",
      "type": "method",
      "start_line": 75,
      "end_line": 83,
      "content_hash": "adb29b63198b183cc18fa5c37f32513141d73160",
      "content": "func (c *Coordinator) ExecuteTask(ctx context.Context, task Task) (*TaskResult, error) {\n\t// Start task execution\n\tc.taskQueue <- task\n\n\t// For now, execute synchronously\n\treturn c.executeTaskInternal(ctx, task)\n}\n\n// executeTaskInternal executes a single task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_executeTaskInternal_84": {
      "name": "executeTaskInternal",
      "type": "method",
      "start_line": 84,
      "end_line": 161,
      "content_hash": "2d60ffaa2612e3daaa9cf1f39926a03b5c4ced14",
      "content": "func (c *Coordinator) executeTaskInternal(ctx context.Context, task Task) (*TaskResult, error) {\n\tresult := &TaskResult{\n\t\tTaskID:    task.ID,\n\t\tStatus:    TaskStatusActive,\n\t\tStartTime: time.Now(),\n\t\tMetadata:  make(map[string]interface{}),\n\t}\n\n\t// Add to active tasks before selecting agent\n\tc.mu.Lock()\n\tc.active[task.ID] = &TaskExecution{\n\t\tTask:       task,\n\t\tAgentID:    \"\",\n\t\tStartTime:  time.Now(),\n\t\tDeadline:   time.Now().Add(30 * time.Minute), // Default 30 min deadline\n\t\tResultChan: make(chan *TaskResult, 1),\n\t}\n\tc.mu.Unlock()\n\n\t// Select an agent for the task\n\tagentID, err := c.selectAgent(task)\n\tif err != nil {\n\t\tresult.Status = TaskStatusFailed\n\t\tresult.Error = err.Error()\n\t\tresult.EndTime = time.Now()\n\t\tresult.Duration = result.EndTime.Sub(result.StartTime)\n\t\treturn result, err\n\t}\n\n\tresult.AgentID = agentID\n\n\t// Update the active task with the selected agent\n\tc.mu.Lock()\n\tif exec, exists := c.active[task.ID]; exists {\n\t\texec.AgentID = agentID\n\t}\n\tc.mu.Unlock()\n\n\t// Get the agent\n\tagent, exists := c.team.GetMember(agentID)\n\tif !exists {\n\t\tresult.Status = TaskStatusFailed\n\t\tresult.Error = fmt.Sprintf(\"agent %s not found\", agentID)\n\t\treturn result, fmt.Errorf(\"%s\", result.Error)\n\t}\n\n\t// Execute the task on the agent\n\ttask.Activate()\n\tresp, err := agent.Execute(ctx, task.Description)\n\n\tresult.EndTime = time.Now()\n\tresult.Duration = result.EndTime.Sub(result.StartTime)\n\n\tif err != nil {\n\t\tresult.Status = TaskStatusFailed\n\t\tresult.Error = err.Error()\n\t\ttask.Fail(err)\n\t} else {\n\t\tresult.Status = TaskStatusCompleted\n\t\tresult.Result = resp\n\t\ttask.Complete()\n\t}\n\n\t// Notify team of task completion\n\tc.team.Broadcast(ctx, \"coordinator\",\n\t\tfmt.Sprintf(\"Task %s completed by agent %s\", task.ID, agentID), MessageTypeResult)\n\n\t// Store result and clean up active task\n\tc.mu.Lock()\n\tresult.Metadata = map[string]interface{}{\"original_task\": task} // Store original task\n\tc.completed[task.ID] = result\n\tdelete(c.active, task.ID)\n\tc.mu.Unlock()\n\n\treturn result, nil\n}\n\n// selectAgent selects the best agent for a task based on strategy",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_selectAgent_162": {
      "name": "selectAgent",
      "type": "method",
      "start_line": 162,
      "end_line": 180,
      "content_hash": "6efb0fbeed29b80059377848009740c7820e07b3",
      "content": "func (c *Coordinator) selectAgent(task Task) (string, error) {\n\tswitch c.strategy {\n\tcase DistributionStrategyRoundRobin:\n\t\treturn c.selectRoundRobin()\n\tcase DistributionStrategyCapabilityBased:\n\t\treturn c.selectByCapability(task)\n\tcase DistributionStrategyLoadBalance:\n\t\treturn c.selectByLoad()\n\tcase DistributionStrategyPriority:\n\t\tif task.Priority > 0 {\n\t\t\treturn c.selectByCapability(task)\n\t\t}\n\t\treturn c.selectByLoad()\n\tdefault:\n\t\treturn c.selectRoundRobin()\n\t}\n}\n\n// selectRoundRobin selects the next agent in round-robin fashion",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_selectRoundRobin_181": {
      "name": "selectRoundRobin",
      "type": "method",
      "start_line": 181,
      "end_line": 226,
      "content_hash": "0a93992de7fe4c99b85380da9fd9ab48c8df7a18",
      "content": "func (c *Coordinator) selectRoundRobin() (string, error) {\n\tmembers := c.team.ListMembers()\n\tif len(members) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no agents available\")\n\t}\n\n\t// Count tasks for each agent from active and completed\n\tc.mu.RLock()\n\ttaskCounts := make(map[string]int)\n\n\t// Count active tasks\n\tfor _, exec := range c.active {\n\t\ttaskCounts[exec.AgentID]++\n\t}\n\n\t// Count total completed tasks to simulate round-robin\n\tcompletedCounts := make(map[string]int)\n\tfor _, result := range c.completed {\n\t\tif result.AgentID != \"\" {\n\t\t\tcompletedCounts[result.AgentID]++\n\t\t}\n\t}\n\tc.mu.RUnlock()\n\n\t// Total tasks per agent\n\ttotalCounts := make(map[string]int)\n\tfor _, agentID := range members {\n\t\ttotalCounts[agentID] = taskCounts[agentID] + completedCounts[agentID]\n\t}\n\n\t// Find agent with minimum total tasks (ties broken by alphabetical order for consistency)\n\tminTasks := int(^uint(0) >> 1)\n\tvar selectedAgent string\n\n\tfor _, agentID := range members {\n\t\tif totalCounts[agentID] < minTasks ||\n\t\t\t(totalCounts[agentID] == minTasks && (selectedAgent == \"\" || agentID < selectedAgent)) {\n\t\t\tminTasks = totalCounts[agentID]\n\t\t\tselectedAgent = agentID\n\t\t}\n\t}\n\n\treturn selectedAgent, nil\n}\n\n// selectByCapability selects agent based on capability matching",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_selectByCapability_227": {
      "name": "selectByCapability",
      "type": "method",
      "start_line": 227,
      "end_line": 246,
      "content_hash": "e8c548d89ceca5f3b7f5867beb514bd7a18f8428",
      "content": "func (c *Coordinator) selectByCapability(task Task) (string, error) {\n\tmembers := c.team.ListMembers()\n\tif len(members) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no agents available\")\n\t}\n\n\t// Get task requirements - first check explicit requirements in task data\n\tvar requirements []string\n\tif reqCaps, exists := task.Data[\"required_capabilities\"]; exists {\n\t\tif caps, ok := reqCaps.([]string); ok {\n\t\t\trequirements = caps\n\t\t}\n\t}\n\n\t// If no explicit requirements, extract from description\n\tif len(requirements) == 0 {\n\t\trequirements = c.capability.GetTaskRequirements(task.Description)\n\t}\n\n\t// Score each agent based on capability match",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_agentScore_247": {
      "name": "agentScore",
      "type": "struct",
      "start_line": 247,
      "end_line": 280,
      "content_hash": "7c51b889ec7111f05301a6142797fa6e2088b9f9",
      "content": "\ttype agentScore struct {\n\t\tid    string\n\t\tscore float64\n\t}\n\n\tvar scores []agentScore\n\n\tfor _, agentID := range members {\n\t\t_, exists := c.team.GetMember(agentID)\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check agent capabilities\n\t\tcapabilities := c.capability.GetAgentCapabilities(agentID)\n\n\t\t// Calculate match score\n\t\tscore := c.calculateCapabilityScore(requirements, capabilities)\n\t\tscores = append(scores, agentScore{id: agentID, score: score})\n\t}\n\n\t// Sort by score descending\n\tsort.Slice(scores, func(i, j int) bool {\n\t\treturn scores[i].score > scores[j].score\n\t})\n\n\tif len(scores) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no suitable agent found\")\n\t}\n\n\treturn scores[0].id, nil\n}\n\n// calculateCapabilityScore calculates how well an agent matches task requirements",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateCapabilityScore_281": {
      "name": "calculateCapabilityScore",
      "type": "method",
      "start_line": 281,
      "end_line": 303,
      "content_hash": "3dd7bdaffc93a3014c555d598e4fe67421708f3f",
      "content": "func (c *Coordinator) calculateCapabilityScore(requirements, capabilities []string) float64 {\n\tif len(requirements) == 0 {\n\t\treturn 1.0 // No requirements, any agent can do it\n\t}\n\n\tif len(capabilities) == 0 {\n\t\treturn 0.1 // Agent has no capabilities\n\t}\n\n\tmatches := 0\n\tfor _, req := range requirements {\n\t\tfor _, cap := range capabilities {\n\t\t\tif req == cap {\n\t\t\t\tmatches++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn float64(matches) / float64(len(requirements))\n}\n\n// selectByLoad selects agent based on current load",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_selectByLoad_304": {
      "name": "selectByLoad",
      "type": "method",
      "start_line": 304,
      "end_line": 320,
      "content_hash": "7ed0948383a21b421a38350f274b2d134b0f5fb9",
      "content": "func (c *Coordinator) selectByLoad() (string, error) {\n\tmembers := c.team.ListMembers()\n\tif len(members) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no agents available\")\n\t}\n\n\t// Sort by current task count\n\tsort.Slice(members, func(i, j int) bool {\n\t\tloadI := c.getAgentLoad(members[i])\n\t\tloadJ := c.getAgentLoad(members[j])\n\t\treturn loadI < loadJ\n\t})\n\n\treturn members[0], nil\n}\n\n// getAgentLoad returns the current load of an agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAgentLoad_321": {
      "name": "getAgentLoad",
      "type": "method",
      "start_line": 321,
      "end_line": 341,
      "content_hash": "dd2d0e497c050812c6f9693241439a485b63ace4",
      "content": "func (c *Coordinator) getAgentLoad(agentID string) int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tload := 0\n\t// Count active tasks\n\tfor _, exec := range c.active {\n\t\tif exec.AgentID == agentID {\n\t\t\tload++\n\t\t}\n\t}\n\t// Also count completed tasks for distribution purposes\n\tfor _, result := range c.completed {\n\t\tif result.AgentID == agentID {\n\t\t\tload++\n\t\t}\n\t}\n\treturn load\n}\n\n// GetTaskResult returns the result of a task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetTaskResult_342": {
      "name": "GetTaskResult",
      "type": "method",
      "start_line": 342,
      "end_line": 354,
      "content_hash": "b5de1e5f2a5d3fa2af0a3adf229e8e9e54b7e813",
      "content": "func (c *Coordinator) GetTaskResult(taskID string) (*TaskResult, error) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tresult, exists := c.completed[taskID]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"task result not found: %s\", taskID)\n\t}\n\n\treturn result, nil\n}\n\n// GetActiveTasks returns all currently active tasks",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetActiveTasks_355": {
      "name": "GetActiveTasks",
      "type": "method",
      "start_line": 355,
      "end_line": 367,
      "content_hash": "2a1bd4e0a3ed38985d3c8c204832045b3fe3bcfd",
      "content": "func (c *Coordinator) GetActiveTasks() []*TaskExecution {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tactive := make([]*TaskExecution, 0, len(c.active))\n\tfor _, exec := range c.active {\n\t\tactive = append(active, exec)\n\t}\n\n\treturn active\n}\n\n// CancelTask cancels an active task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CancelTask_368": {
      "name": "CancelTask",
      "type": "method",
      "start_line": 368,
      "end_line": 398,
      "content_hash": "443ec84dbe4b4fed53e630c65de57e611ea5ad77",
      "content": "func (c *Coordinator) CancelTask(taskID string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\texec, exists := c.active[taskID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"active task not found: %s\", taskID)\n\t}\n\n\tif exec.CancelFunc != nil {\n\t\texec.CancelFunc()\n\t}\n\n\tdelete(c.active, taskID)\n\n\t// Store cancelled result\n\tresult := &TaskResult{\n\t\tTaskID:    taskID,\n\t\tStatus:    TaskStatusCancelled,\n\t\tStartTime: exec.StartTime,\n\t\tEndTime:   time.Now(),\n\t\tDuration:  time.Since(exec.StartTime),\n\t\tAgentID:   exec.AgentID,\n\t\tMetadata:  map[string]interface{}{\"original_task\": exec.Task}, // Store original task\n\t}\n\tc.completed[taskID] = result\n\n\treturn nil\n}\n\n// SetStrategy sets the task distribution strategy",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetStrategy_399": {
      "name": "SetStrategy",
      "type": "method",
      "start_line": 399,
      "end_line": 403,
      "content_hash": "1bc711d4383c730c2c1ba74e4399f4162faacd5f",
      "content": "func (c *Coordinator) SetStrategy(strategy DistributionStrategy) {\n\tc.strategy = strategy\n}\n\n// SetCapabilityMatcher sets the capability matcher",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetCapabilityMatcher_404": {
      "name": "SetCapabilityMatcher",
      "type": "method",
      "start_line": 404,
      "end_line": 408,
      "content_hash": "5bd13de9e1a873bcd714afe778694ef0f14705ae",
      "content": "func (c *Coordinator) SetCapabilityMatcher(matcher *CapabilityMatcher) {\n\tc.capability = matcher\n}\n\n// NewCapabilityMatcher creates a new capability matcher",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCapabilityMatcher_409": {
      "name": "NewCapabilityMatcher",
      "type": "function",
      "start_line": 409,
      "end_line": 431,
      "content_hash": "3377b32dec443b9bb531190ff987d5f7e00d1b7e",
      "content": "func NewCapabilityMatcher() *CapabilityMatcher {\n\t// Initialize related capabilities mapping\n\trelated := map[string][]string{\n\t\t\"math\":       {\"calculator\"},\n\t\t\"calculator\": {\"math\"},\n\t\t\"calculate\":  {\"calculator\"},\n\t\t\"compute\":    {\"calculator\"},\n\t\t\"analysis\":   {\"analyze\"},\n\t\t\"analyze\":    {\"analysis\"},\n\t\t\"search\":     {\"find\"},\n\t\t\"find\":       {\"search\"},\n\t\t\"reader\":     {\"read\"},\n\t\t\"read\":       {\"reader\"},\n\t}\n\n\treturn &CapabilityMatcher{\n\t\tagentCapabilities:   make(map[string][]string),\n\t\ttaskRequirements:    make(map[string][]string),\n\t\trelatedCapabilities: related,\n\t}\n}\n\n// RegisterAgentCapabilities registers capabilities for an agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RegisterAgentCapabilities_432": {
      "name": "RegisterAgentCapabilities",
      "type": "method",
      "start_line": 432,
      "end_line": 436,
      "content_hash": "991207f48609f43c13a1efa5bcf53da5a0c5caaf",
      "content": "func (cm *CapabilityMatcher) RegisterAgentCapabilities(agentID string, capabilities []string) {\n\tcm.agentCapabilities[agentID] = capabilities\n}\n\n// RegisterCapability is an alias for RegisterAgentCapabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RegisterCapability_437": {
      "name": "RegisterCapability",
      "type": "method",
      "start_line": 437,
      "end_line": 441,
      "content_hash": "1221a1cede2bc60607710ddc9299ff89fd0081a6",
      "content": "func (cm *CapabilityMatcher) RegisterCapability(agentID string, capabilities []string) {\n\tcm.RegisterAgentCapabilities(agentID, capabilities)\n}\n\n// GetAgentCapabilities returns the capabilities of an agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetAgentCapabilities_442": {
      "name": "GetAgentCapabilities",
      "type": "method",
      "start_line": 442,
      "end_line": 446,
      "content_hash": "a17b5e0e4a311688a12aa1eb7bf835626f4ddee5",
      "content": "func (cm *CapabilityMatcher) GetAgentCapabilities(agentID string) []string {\n\treturn cm.agentCapabilities[agentID]\n}\n\n// FindBestAgent finds the best agent for required capabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindBestAgent_447": {
      "name": "FindBestAgent",
      "type": "method",
      "start_line": 447,
      "end_line": 451,
      "content_hash": "aadc6a07077523ba2a2cbe11883234327ff843af",
      "content": "func (cm *CapabilityMatcher) FindBestAgent(requiredCapabilities []string, availableAgents []string) string {\n\tif len(requiredCapabilities) == 0 || len(availableAgents) == 0 {\n\t\treturn \"\"\n\t}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_agentScore_452": {
      "name": "agentScore",
      "type": "struct",
      "start_line": 452,
      "end_line": 503,
      "content_hash": "ddf7edf4d280b375280cea04295030388912d555",
      "content": "\ttype agentScore struct {\n\t\tid                string\n\t\tscore             float64\n\t\tcanPartiallyMatch bool // Uses related capabilities\n\t}\n\n\tvar scores []agentScore\n\n\tfor _, agentID := range availableAgents {\n\t\tcapabilities := cm.GetAgentCapabilities(agentID)\n\n\t\t// Calculate match score\n\t\tscore := cm.calculateScore(requiredCapabilities, capabilities)\n\n\t\t// Check if this agent uses related capabilities for partial matching\n\t\tcanPartiallyMatch := false\n\t\tif score > 0 && score < 1.0 {\n\t\t\tfor _, req := range requiredCapabilities {\n\t\t\t\tif _, exists := cm.relatedCapabilities[req]; exists {\n\t\t\t\t\tcanPartiallyMatch = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscores = append(scores, agentScore{id: agentID, score: score, canPartiallyMatch: canPartiallyMatch})\n\t}\n\n\t// Sort by score descending\n\tsort.Slice(scores, func(i, j int) bool {\n\t\treturn scores[i].score > scores[j].score\n\t})\n\n\t// First try to find perfect match (score = 1.0)\n\tfor _, s := range scores {\n\t\tif s.score == 1.0 {\n\t\t\treturn s.id\n\t\t}\n\t}\n\n\t// If no perfect match, only allow partial matches for special cases\n\t// and only if all requirements can be satisfied (even with related capabilities)\n\tfor _, s := range scores {\n\t\tif s.score > 0 && s.canPartiallyMatch && s.score >= (float64(len(requiredCapabilities))/float64(len(requiredCapabilities))) {\n\t\t\treturn s.id\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// calculateScore calculates how well capabilities match requirements",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateScore_504": {
      "name": "calculateScore",
      "type": "method",
      "start_line": 504,
      "end_line": 556,
      "content_hash": "13ba85a1cfa0ced18d9ec42e6b2cd55c172964b4",
      "content": "func (cm *CapabilityMatcher) calculateScore(requirements, capabilities []string) float64 {\n\tif len(requirements) == 0 {\n\t\treturn 1.0 // No requirements, any agent can do it\n\t}\n\n\tif len(capabilities) == 0 {\n\t\treturn 0.0 // Agent has no capabilities\n\t}\n\n\tmatches := 0\n\tfor _, req := range requirements {\n\t\tmatched := false\n\t\t// Direct match\n\t\tfor _, cap := range capabilities {\n\t\t\tif req == cap {\n\t\t\t\tmatches++\n\t\t\t\tmatched = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Check for partial match (substring) if direct match failed\n\t\tif !matched {\n\t\t\tfor _, cap := range capabilities {\n\t\t\t\tif strings.Contains(req, cap) || strings.Contains(cap, req) {\n\t\t\t\t\tmatches++\n\t\t\t\t\tmatched = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check for related capabilities if still no match\n\t\tif !matched {\n\t\t\tif related, exists := cm.relatedCapabilities[req]; exists {\n\t\t\t\tfor _, relatedCap := range related {\n\t\t\t\t\tfor _, cap := range capabilities {\n\t\t\t\t\t\tif relatedCap == cap {\n\t\t\t\t\t\t\tmatches++\n\t\t\t\t\t\t\tmatched = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif matched {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn float64(matches) / float64(len(requirements))\n}\n\n// GetTaskRequirements extracts requirements from a task description",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetTaskRequirements_557": {
      "name": "GetTaskRequirements",
      "type": "method",
      "start_line": 557,
      "end_line": 593,
      "content_hash": "1af92baa6e1bc5916cdb782e6d83085433f3efff",
      "content": "func (cm *CapabilityMatcher) GetTaskRequirements(description string) []string {\n\t// Simple keyword-based requirement extraction\n\tdescLower := strings.ToLower(description)\n\n\tvar requirements []string\n\n\t// Check for math requirements\n\tif strings.Contains(descLower, \"calculate\") || strings.Contains(descLower, \"compute\") ||\n\t\tstrings.Contains(descLower, \"add\") || strings.Contains(descLower, \"multiply\") ||\n\t\tstrings.Contains(descLower, \"divide\") || strings.Contains(descLower, \"subtract\") ||\n\t\tstrings.Contains(descLower, \"math\") {\n\t\trequirements = append(requirements, \"calculator\")\n\t}\n\n\t// Check for file operations\n\tif strings.Contains(descLower, \"file\") || strings.Contains(descLower, \"read\") ||\n\t\tstrings.Contains(descLower, \"write\") || strings.Contains(descLower, \"delete\") ||\n\t\tstrings.Contains(descLower, \"create\") {\n\t\trequirements = append(requirements, \"file_ops\")\n\t}\n\n\t// Check for search requirements\n\tif strings.Contains(descLower, \"search\") || strings.Contains(descLower, \"find\") ||\n\t\tstrings.Contains(descLower, \"lookup\") || strings.Contains(descLower, \"query\") {\n\t\trequirements = append(requirements, \"search\")\n\t}\n\n\t// Check for analysis requirements\n\tif strings.Contains(descLower, \"analyze\") || strings.Contains(descLower, \"process\") ||\n\t\tstrings.Contains(descLower, \"summarize\") || strings.Contains(descLower, \"review\") {\n\t\trequirements = append(requirements, \"analysis\")\n\t}\n\n\treturn requirements\n}\n\n// SubmitTask adds a task to the queue",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SubmitTask_594": {
      "name": "SubmitTask",
      "type": "method",
      "start_line": 594,
      "end_line": 610,
      "content_hash": "b095e295f08a20ab4337405fc139cad408add05e",
      "content": "func (c *Coordinator) SubmitTask(ctx context.Context, task *Task) error {\n\t// Store task in active map\n\tc.mu.Lock()\n\tc.active[task.ID] = &TaskExecution{\n\t\tTask:       *task,\n\t\tAgentID:    \"\",\n\t\tStartTime:  time.Now(),\n\t\tDeadline:   time.Now().Add(30 * time.Minute), // Default 30 min deadline\n\t\tResultChan: make(chan *TaskResult, 1),\n\t}\n\tc.mu.Unlock()\n\n\tc.taskQueue <- *task\n\treturn nil\n}\n\n// GetTask retrieves a task by ID",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetTask_611": {
      "name": "GetTask",
      "type": "method",
      "start_line": 611,
      "end_line": 639,
      "content_hash": "9915ea431628410805dba26c7b123fc3ccb41ced",
      "content": "func (c *Coordinator) GetTask(taskID string) (*Task, bool) {\n\t// Check active tasks\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif exec, exists := c.active[taskID]; exists {\n\t\treturn &exec.Task, true\n\t}\n\n\t// Check completed tasks\n\tif result, exists := c.completed[taskID]; exists {\n\t\t// Try to get original task from metadata\n\t\tif task, ok := result.Metadata[\"original_task\"].(Task); ok {\n\t\t\t// Update the status to match the result\n\t\t\ttask.Status = result.Status\n\t\t\treturn &task, true\n\t\t}\n\t\t// Fallback: return a task with just the ID and status\n\t\ttask := Task{\n\t\t\tID:     taskID,\n\t\t\tStatus: result.Status,\n\t\t}\n\t\treturn &task, true\n\t}\n\n\treturn nil, false\n}\n\n// ListTasks returns all tasks (active and completed)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListTasks_640": {
      "name": "ListTasks",
      "type": "method",
      "start_line": 640,
      "end_line": 659,
      "content_hash": "fbd72c3c10b90bdca311a82ab0ac8938a40e71f5",
      "content": "func (c *Coordinator) ListTasks() []*Task {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tvar tasks []*Task\n\n\t// Add active tasks\n\tfor _, exec := range c.active {\n\t\ttasks = append(tasks, &exec.Task)\n\t}\n\n\t// Add completed tasks (as placeholders)\n\tfor taskID := range c.completed {\n\t\ttasks = append(tasks, &Task{ID: taskID})\n\t}\n\n\treturn tasks\n}\n\n// GetStats returns coordinator statistics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetStats_660": {
      "name": "GetStats",
      "type": "method",
      "start_line": 660,
      "end_line": 671,
      "content_hash": "8dfa4bb542d9e8fa7b37d19cb2b45710ba66511b",
      "content": "func (c *Coordinator) GetStats() map[string]interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tstats := make(map[string]interface{})\n\tstats[\"active_tasks\"] = len(c.active)\n\tstats[\"completed_tasks\"] = len(c.completed)\n\tstats[\"total_agents\"] = len(c.team.ListMembers())\n\tstats[\"strategy\"] = c.strategy\n\n\treturn stats\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}