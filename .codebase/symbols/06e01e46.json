{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/integration_tests.rs",
  "file_hash": "848a279d71c90b31b55a98a61acc7e1be9d90e25",
  "updated_at": "2025-12-26T17:34:21.190573",
  "symbols": {
    "function_test_node_bincode_roundtrip_simple_25": {
      "name": "test_node_bincode_roundtrip_simple",
      "type": "function",
      "start_line": 25,
      "end_line": 39,
      "content_hash": "9c990142dfcf0841cedcf300068e18309d2d3596",
      "content": "    fn test_node_bincode_roundtrip_simple() {\n        let arena = Bump::new();\n        let id = 12345u128;\n\n        let node = create_simple_node(&arena, id, \"Person\");\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &bytes, &arena2);\n\n        assert!(deserialized.is_ok());\n        assert_nodes_semantically_equal(&node, &deserialized.unwrap());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_bincode_roundtrip_with_properties_40": {
      "name": "test_node_bincode_roundtrip_with_properties",
      "type": "function",
      "start_line": 40,
      "end_line": 60,
      "content_hash": "2ce7c1537e495c7bdc52a45acf165025e8897ecc",
      "content": "    fn test_node_bincode_roundtrip_with_properties() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        let props = vec![\n            (\"name\", Value::String(\"Alice\".to_string())),\n            (\"age\", Value::I32(30)),\n            (\"active\", Value::Boolean(true)),\n        ];\n\n        let node = create_arena_node(&arena, id, \"User\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &bytes, &arena2);\n\n        assert!(deserialized.is_ok());\n        assert_nodes_semantically_equal(&node, &deserialized.unwrap());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_json_serialization_61": {
      "name": "test_node_json_serialization",
      "type": "function",
      "start_line": 61,
      "end_line": 74,
      "content_hash": "0113157048028b39d028f65f2024d8560417a4e1",
      "content": "    fn test_node_json_serialization() {\n        let arena = Bump::new();\n        let id = 55555u128;\n\n        let props = vec![(\"key\", Value::String(\"value\".to_string()))];\n        let node = create_arena_node(&arena, id, \"TestNode\", 0, props);\n\n        let json = sonic_rs::to_string(&node).unwrap();\n        assert!(json.contains(\"TestNode\"));\n        assert!(json.contains(\"key\"));\n        assert!(json.contains(\"value\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_multiple_roundtrips_75": {
      "name": "test_node_multiple_roundtrips",
      "type": "function",
      "start_line": 75,
      "end_line": 100,
      "content_hash": "bc340234a2665201085578813bd3a3edaa83f857",
      "content": "    fn test_node_multiple_roundtrips() {\n        let arena = Bump::new();\n        let id = 111222u128;\n\n        let props = vec![(\"data\", Value::I64(42))];\n        let node = create_arena_node(&arena, id, \"Multi\", 0, props);\n\n        // First roundtrip\n        let bytes1 = bincode::serialize(&node).unwrap();\n        let arena2 = Bump::new();\n        let node2 = Node::from_bincode_bytes(id, &bytes1, &arena2).unwrap();\n\n        // Second roundtrip\n        let bytes2 = bincode::serialize(&node2).unwrap();\n        let arena3 = Bump::new();\n        let node3 = Node::from_bincode_bytes(id, &bytes2, &arena3).unwrap();\n\n        // All should be semantically equal\n        assert_nodes_semantically_equal(&node, &node2);\n        assert_nodes_semantically_equal(&node2, &node3);\n\n        // Bytes should be identical\n        assert_eq!(bytes1, bytes2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_batch_serialization_101": {
      "name": "test_node_batch_serialization",
      "type": "function",
      "start_line": 101,
      "end_line": 129,
      "content_hash": "1fbab18b8c9e76a6da512d8015296fa759166a72",
      "content": "    fn test_node_batch_serialization() {\n        let arena = Bump::new();\n\n        let nodes: Vec<Node> = (0..10)\n            .map(|i| {\n                let props = vec![(\"index\", Value::I32(i))];\n                create_arena_node(&arena, i as u128, &format!(\"Node_{}\", i), 0, props)\n            })\n            .collect();\n\n        // Serialize all nodes\n        let serialized: Vec<Vec<u8>> = nodes\n            .iter()\n            .map(|n| bincode::serialize(n).unwrap())\n            .collect();\n\n        // Deserialize all nodes\n        let arena2 = Bump::new();\n        for (i, bytes) in serialized.iter().enumerate() {\n            let deserialized = Node::from_bincode_bytes(i as u128, bytes, &arena2);\n            assert!(deserialized.is_ok());\n        }\n    }\n\n    // ========================================================================\n    // EDGE ROUNDTRIP SERIALIZATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_bincode_roundtrip_simple_130": {
      "name": "test_edge_bincode_roundtrip_simple",
      "type": "function",
      "start_line": 130,
      "end_line": 144,
      "content_hash": "bcb13bc2725fa1689218f02974ec66db433d83d4",
      "content": "    fn test_edge_bincode_roundtrip_simple() {\n        let arena = Bump::new();\n        let id = 77777u128;\n\n        let edge = create_simple_edge(&arena, id, \"KNOWS\", 1, 2);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2);\n\n        assert!(deserialized.is_ok());\n        assert_edges_semantically_equal(&edge, &deserialized.unwrap());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_bincode_roundtrip_with_properties_145": {
      "name": "test_edge_bincode_roundtrip_with_properties",
      "type": "function",
      "start_line": 145,
      "end_line": 165,
      "content_hash": "2f3c60d55c5d43baddc2d16c47a2be9b5f8bd7db",
      "content": "    fn test_edge_bincode_roundtrip_with_properties() {\n        let arena = Bump::new();\n        let id = 88888u128;\n\n        let props = vec![\n            (\"weight\", Value::F64(0.95)),\n            (\"type\", Value::String(\"friendship\".to_string())),\n            (\"since\", Value::I64(2024)),\n        ];\n\n        let edge = create_arena_edge(&arena, id, \"FRIEND_OF\", 0, 100, 200, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2);\n\n        assert!(deserialized.is_ok());\n        assert_edges_semantically_equal(&edge, &deserialized.unwrap());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_json_serialization_166": {
      "name": "test_edge_json_serialization",
      "type": "function",
      "start_line": 166,
      "end_line": 178,
      "content_hash": "6eba828e61a2a0e46efc637376dab3f10e4118c7",
      "content": "    fn test_edge_json_serialization() {\n        let arena = Bump::new();\n        let id = 66666u128;\n\n        let edge = create_simple_edge(&arena, id, \"FOLLOWS\", 1, 2);\n        let json = sonic_rs::to_string(&edge).unwrap();\n\n        assert!(json.contains(\"FOLLOWS\"));\n        assert!(json.contains(\"from_node\"));\n        assert!(json.contains(\"to_node\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_multiple_roundtrips_179": {
      "name": "test_edge_multiple_roundtrips",
      "type": "function",
      "start_line": 179,
      "end_line": 201,
      "content_hash": "8c9b369c7006c71ee381720ab5e8fd77d5d3a0a0",
      "content": "    fn test_edge_multiple_roundtrips() {\n        let arena = Bump::new();\n        let id = 333444u128;\n\n        let props = vec![(\"distance\", Value::F64(10.5))];\n        let edge = create_arena_edge(&arena, id, \"CONNECTED\", 0, 10, 20, props);\n\n        // First roundtrip\n        let bytes1 = bincode::serialize(&edge).unwrap();\n        let arena2 = Bump::new();\n        let edge2 = Edge::from_bincode_bytes(id, &bytes1, &arena2).unwrap();\n\n        // Second roundtrip\n        let bytes2 = bincode::serialize(&edge2).unwrap();\n        let arena3 = Bump::new();\n        let edge3 = Edge::from_bincode_bytes(id, &bytes2, &arena3).unwrap();\n\n        assert_edges_semantically_equal(&edge, &edge2);\n        assert_edges_semantically_equal(&edge2, &edge3);\n        assert_eq!(bytes1, bytes2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_batch_serialization_202": {
      "name": "test_edge_batch_serialization",
      "type": "function",
      "start_line": 202,
      "end_line": 223,
      "content_hash": "647781106400bd06bec3e666ba003bf5f8ef0b4b",
      "content": "    fn test_edge_batch_serialization() {\n        let arena = Bump::new();\n\n        let edges: Vec<Edge> = (0..20)\n            .map(|i| {\n                create_simple_edge(&arena, i as u128, \"LINK\", i as u128, (i + 1) as u128)\n            })\n            .collect();\n\n        let serialized: Vec<Vec<u8>> = edges\n            .iter()\n            .map(|e| bincode::serialize(e).unwrap())\n            .collect();\n\n        let arena2 = Bump::new();\n        for (i, bytes) in serialized.iter().enumerate() {\n            let deserialized = Edge::from_bincode_bytes(i as u128, bytes, &arena2);\n            assert!(deserialized.is_ok());\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_self_loop_224": {
      "name": "test_edge_self_loop",
      "type": "function",
      "start_line": 224,
      "end_line": 243,
      "content_hash": "21906140fe5273de16873c64af8050293fa16dd6",
      "content": "    fn test_edge_self_loop() {\n        let arena = Bump::new();\n        let id = 555666u128;\n        let node_id = 999u128;\n\n        let edge = create_simple_edge(&arena, id, \"SELF_REF\", node_id, node_id);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.from_node, node_id);\n        assert_eq!(deserialized.to_node, node_id);\n    }\n\n    // ========================================================================\n    // VECTOR ROUNDTRIP SERIALIZATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_full_roundtrip_simple_244": {
      "name": "test_vector_full_roundtrip_simple",
      "type": "function",
      "start_line": 244,
      "end_line": 264,
      "content_hash": "44ecef61979909d971bfcbb4327fe6f2dbb2a777",
      "content": "    fn test_vector_full_roundtrip_simple() {\n        let arena = Bump::new();\n        let id = 123123u128;\n        let data = vec![1.0, 2.0, 3.0, 4.0];\n\n        let vector = create_simple_vector(&arena, id, \"embedding\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_full_roundtrip_with_properties_265": {
      "name": "test_vector_full_roundtrip_with_properties",
      "type": "function",
      "start_line": 265,
      "end_line": 290,
      "content_hash": "0f06ae686388bb80d8ec6e6219a473975bb16ac4",
      "content": "    fn test_vector_full_roundtrip_with_properties() {\n        let arena = Bump::new();\n        let id = 456456u128;\n        let data = vec![0.1, 0.2, 0.3];\n\n        let props = vec![\n            (\"model\", Value::String(\"text-embedding-3-small\".to_string())),\n            (\"dimensions\", Value::I32(3)),\n        ];\n\n        let vector = create_arena_vector(&arena, id, \"doc_vector\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_json_serialization_291": {
      "name": "test_vector_json_serialization",
      "type": "function",
      "start_line": 291,
      "end_line": 305,
      "content_hash": "0c319cd678e1528ca22e317b699bc252ff15168e",
      "content": "    fn test_vector_json_serialization() {\n        let arena = Bump::new();\n        let id = 789789u128;\n        let data = vec![1.0, 2.0];\n\n        let vector = create_simple_vector(&arena, id, \"test_vec\", &data);\n        let json = sonic_rs::to_string(&vector).unwrap();\n\n        assert!(json.contains(\"test_vec\"));\n        assert!(json.contains(\"version\"));\n        // Note: data is NOT included in JSON serialization\n        assert!(!json.contains(\"data\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_multiple_roundtrips_306": {
      "name": "test_vector_multiple_roundtrips",
      "type": "function",
      "start_line": 306,
      "end_line": 341,
      "content_hash": "9b34b5a251e1fce9d0d7db6078b8446c26fe3342",
      "content": "    fn test_vector_multiple_roundtrips() {\n        let arena = Bump::new();\n        let id = 147258u128;\n        let data = vec![5.5, 6.6, 7.7];\n\n        let vector = create_simple_vector(&arena, id, \"multi\", &data);\n\n        // First roundtrip\n        let props_bytes1 = bincode::serialize(&vector).unwrap();\n        let data_bytes1 = vector.vector_data_to_bytes().unwrap();\n        let arena2 = Bump::new();\n        let vector2 = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes1),\n            data_bytes1,\n            id,\n        ).unwrap();\n\n        // Second roundtrip\n        let props_bytes2 = bincode::serialize(&vector2).unwrap();\n        let data_bytes2 = vector2.vector_data_to_bytes().unwrap();\n        let arena3 = Bump::new();\n        let vector3 = HVector::from_bincode_bytes(\n            &arena3,\n            Some(&props_bytes2),\n            data_bytes2,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &vector2);\n        assert_vectors_semantically_equal(&vector2, &vector3);\n        assert_eq!(props_bytes1, props_bytes2);\n        assert_eq!(data_bytes1, data_bytes2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_batch_serialization_342": {
      "name": "test_vector_batch_serialization",
      "type": "function",
      "start_line": 342,
      "end_line": 379,
      "content_hash": "9896201f4954350b66619c1ba70f277bc45a3065",
      "content": "    fn test_vector_batch_serialization() {\n        let arena = Bump::new();\n\n        let vectors: Vec<HVector> = (0..15)\n            .map(|i| {\n                let data = vec![i as f64, (i + 1) as f64, (i + 2) as f64];\n                create_simple_vector(&arena, i as u128, &format!(\"vec_{}\", i), &data)\n            })\n            .collect();\n\n        // Serialize all\n        let serialized: Vec<(Vec<u8>, Vec<u8>)> = vectors\n            .iter()\n            .map(|v| {\n                let props = bincode::serialize(v).unwrap();\n                let data = v.vector_data_to_bytes().unwrap().to_vec();\n                (props, data)\n            })\n            .collect();\n\n        // Deserialize all\n        let arena2 = Bump::new();\n        for (i, (props_bytes, data_bytes)) in serialized.iter().enumerate() {\n            let result = HVector::from_bincode_bytes(\n                &arena2,\n                Some(props_bytes),\n                data_bytes,\n                i as u128,\n            );\n            assert!(result.is_ok());\n        }\n    }\n\n    // ========================================================================\n    // MIXED TYPE OPERATIONS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_mixed_node_edge_serialization_380": {
      "name": "test_mixed_node_edge_serialization",
      "type": "function",
      "start_line": 380,
      "end_line": 407,
      "content_hash": "4a295154ff49c1e9bebce27224e8a2e54a7bf388",
      "content": "    fn test_mixed_node_edge_serialization() {\n        let arena = Bump::new();\n\n        // Create nodes\n        let node1 = create_simple_node(&arena, 1, \"Alice\");\n        let node2 = create_simple_node(&arena, 2, \"Bob\");\n\n        // Create edge between them\n        let edge = create_simple_edge(&arena, 100, \"KNOWS\", 1, 2);\n\n        // Serialize\n        let node1_bytes = bincode::serialize(&node1).unwrap();\n        let node2_bytes = bincode::serialize(&node2).unwrap();\n        let edge_bytes = bincode::serialize(&edge).unwrap();\n\n        // Deserialize\n        let arena2 = Bump::new();\n        let node1_restored = Node::from_bincode_bytes(1, &node1_bytes, &arena2).unwrap();\n        let node2_restored = Node::from_bincode_bytes(2, &node2_bytes, &arena2).unwrap();\n        let edge_restored = Edge::from_bincode_bytes(100, &edge_bytes, &arena2).unwrap();\n\n        assert_eq!(node1_restored.label, \"Alice\");\n        assert_eq!(node2_restored.label, \"Bob\");\n        assert_eq!(edge_restored.from_node, 1);\n        assert_eq!(edge_restored.to_node, 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_mixed_all_types_serialization_408": {
      "name": "test_mixed_all_types_serialization",
      "type": "function",
      "start_line": 408,
      "end_line": 442,
      "content_hash": "cd828a0a1d48267833c4d4d7e8121aca5c9a67f2",
      "content": "    fn test_mixed_all_types_serialization() {\n        let arena = Bump::new();\n\n        // Create one of each type\n        let node = create_simple_node(&arena, 1, \"TestNode\");\n        let edge = create_simple_edge(&arena, 2, \"TestEdge\", 1, 3);\n        let vector = create_simple_vector(&arena, 3, \"TestVector\", &[1.0, 2.0, 3.0]);\n\n        // Serialize\n        let node_bytes = bincode::serialize(&node).unwrap();\n        let edge_bytes = bincode::serialize(&edge).unwrap();\n        let vector_props_bytes = bincode::serialize(&vector).unwrap();\n        let vector_data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Deserialize\n        let arena2 = Bump::new();\n        let node_restored = Node::from_bincode_bytes(1, &node_bytes, &arena2);\n        let edge_restored = Edge::from_bincode_bytes(2, &edge_bytes, &arena2);\n        let vector_restored = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&vector_props_bytes),\n            vector_data_bytes,\n            3,\n        );\n\n        assert!(node_restored.is_ok());\n        assert!(edge_restored.is_ok());\n        assert!(vector_restored.is_ok());\n    }\n\n    // ========================================================================\n    // ARENA LIFECYCLE TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_arena_multiple_deserializations_443": {
      "name": "test_arena_multiple_deserializations",
      "type": "function",
      "start_line": 443,
      "end_line": 466,
      "content_hash": "0d7b60da0d657acd5897a833c912ee011aa2612d",
      "content": "    fn test_arena_multiple_deserializations() {\n        // Test that we can deserialize multiple items into the same arena\n        let arena_serialize = Bump::new();\n\n        let node1 = create_simple_node(&arena_serialize, 1, \"Node1\");\n        let node2 = create_simple_node(&arena_serialize, 2, \"Node2\");\n        let node3 = create_simple_node(&arena_serialize, 3, \"Node3\");\n\n        let bytes1 = bincode::serialize(&node1).unwrap();\n        let bytes2 = bincode::serialize(&node2).unwrap();\n        let bytes3 = bincode::serialize(&node3).unwrap();\n\n        // Deserialize all into same arena\n        let shared_arena = Bump::new();\n        let restored1 = Node::from_bincode_bytes(1, &bytes1, &shared_arena).unwrap();\n        let restored2 = Node::from_bincode_bytes(2, &bytes2, &shared_arena).unwrap();\n        let restored3 = Node::from_bincode_bytes(3, &bytes3, &shared_arena).unwrap();\n\n        assert_eq!(restored1.label, \"Node1\");\n        assert_eq!(restored2.label, \"Node2\");\n        assert_eq!(restored3.label, \"Node3\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_arena_large_batch_deserialization_467": {
      "name": "test_arena_large_batch_deserialization",
      "type": "function",
      "start_line": 467,
      "end_line": 499,
      "content_hash": "0ef5781b82005cb6054f05036e5376871974557b",
      "content": "    fn test_arena_large_batch_deserialization() {\n        let arena_serialize = Bump::new();\n\n        // Create many items\n        let nodes: Vec<Node> = (0..100)\n            .map(|i| create_simple_node(&arena_serialize, i, &format!(\"Node{}\", i)))\n            .collect();\n\n        // Serialize all\n        let serialized: Vec<Vec<u8>> = nodes\n            .iter()\n            .map(|n| bincode::serialize(n).unwrap())\n            .collect();\n\n        // Deserialize all into single arena\n        let shared_arena = Bump::new();\n        let restored: Vec<Node> = serialized\n            .iter()\n            .enumerate()\n            .map(|(i, bytes)| {\n                Node::from_bincode_bytes(i as u128, bytes, &shared_arena).unwrap()\n            })\n            .collect();\n\n        assert_eq!(restored.len(), 100);\n        assert_eq!(restored[50].label, \"Node50\");\n    }\n\n    // ========================================================================\n    // BACKWARDS COMPATIBILITY INTEGRATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_node_to_new_node_500": {
      "name": "test_old_node_to_new_node",
      "type": "function",
      "start_line": 500,
      "end_line": 521,
      "content_hash": "1c04ad9cb90cb8be7b3bc5622dd57eec1dbda74d",
      "content": "    fn test_old_node_to_new_node() {\n        let id = 12345u128;\n\n        let old_node = create_old_node(\n            id,\n            \"OldNode\",\n            0,\n            vec![(\"old_prop\", Value::String(\"old_value\".to_string()))],\n        );\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena);\n\n        assert!(new_node.is_ok());\n        let restored = new_node.unwrap();\n        assert_eq!(restored.label, \"OldNode\");\n        assert_eq!(restored.id, id);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_old_edge_to_new_edge_522": {
      "name": "test_old_edge_to_new_edge",
      "type": "function",
      "start_line": 522,
      "end_line": 550,
      "content_hash": "5426f821c695610489c537a679610d091ea19139",
      "content": "    fn test_old_edge_to_new_edge() {\n        let id = 54321u128;\n\n        let old_edge = create_old_edge(\n            id,\n            \"OldEdge\",\n            0,\n            100,\n            200,\n            vec![(\"old_weight\", Value::F64(0.5))],\n        );\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        let arena = Bump::new();\n        let new_edge = Edge::from_bincode_bytes(id, &old_bytes, &arena);\n\n        assert!(new_edge.is_ok());\n        let restored = new_edge.unwrap();\n        assert_eq!(restored.label, \"OldEdge\");\n        assert_eq!(restored.from_node, 100);\n        assert_eq!(restored.to_node, 200);\n    }\n\n    // ========================================================================\n    // BINCODE CONFIGURATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_bincode_fixint_encoding_551": {
      "name": "test_bincode_fixint_encoding",
      "type": "function",
      "start_line": 551,
      "end_line": 576,
      "content_hash": "c7964c64770c6ded2e3a72ed4fdfa9331b67ad6a",
      "content": "    fn test_bincode_fixint_encoding() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        let node = create_simple_node(&arena, id, \"test\");\n\n        // Serialize with fixint encoding (like storage layer)\n        let bytes_fixint = bincode::options()\n            .with_fixint_encoding()\n            .serialize(&node)\n            .unwrap();\n\n        // Deserialize\n        let arena2 = Bump::new();\n        let result = bincode::options()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(\n                crate::protocol::custom_serde::node_serde::NodeDeSeed { arena: &arena2, id },\n                &bytes_fixint,\n            );\n\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_bincode_options_consistency_577": {
      "name": "test_vector_bincode_options_consistency",
      "type": "function",
      "start_line": 577,
      "end_line": 607,
      "content_hash": "3e53d165cf5dab5a15aa872e07849c7212983fb3",
      "content": "    fn test_vector_bincode_options_consistency() {\n        let arena = Bump::new();\n        let id = 777777u128;\n        let data = vec![1.0, 2.0, 3.0];\n\n        let vector = create_simple_vector(&arena, id, \"test\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Use same bincode options as from_bincode_bytes\n        let arena2 = Bump::new();\n        let result = bincode::options()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(\n                crate::protocol::custom_serde::vector_serde::VectorDeSeed {\n                    arena: &arena2,\n                    id,\n                    raw_vector_data: data_bytes,\n                },\n                &props_bytes,\n            );\n\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // SIZE AND PERFORMANCE CHARACTERISTICS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialized_size_empty_props_608": {
      "name": "test_node_serialized_size_empty_props",
      "type": "function",
      "start_line": 608,
      "end_line": 619,
      "content_hash": "4eb3b9a4d4445c6e4e1df7ab505f68c97ac63f75",
      "content": "    fn test_node_serialized_size_empty_props() {\n        let arena = Bump::new();\n        let id = 11111u128;\n\n        let node = create_simple_node(&arena, id, \"test\");\n        let bytes = bincode::serialize(&node).unwrap();\n\n        // Should be relatively small (label + version + empty props indicator)\n        assert!(bytes.len() < 100, \"Empty node should be small, got {} bytes\", bytes.len());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_serialized_size_scaling_620": {
      "name": "test_edge_serialized_size_scaling",
      "type": "function",
      "start_line": 620,
      "end_line": 640,
      "content_hash": "164ab3f03f376c4e52118fd8a6dcd21217eb7ad5",
      "content": "    fn test_edge_serialized_size_scaling() {\n        let arena = Bump::new();\n        let id = 22222u128;\n\n        // Edge with no props\n        let edge1 = create_simple_edge(&arena, id, \"LINK\", 1, 2);\n        let bytes1 = bincode::serialize(&edge1).unwrap();\n\n        // Edge with props\n        let props = vec![\n            (\"prop1\", Value::String(\"value1\".to_string())),\n            (\"prop2\", Value::String(\"value2\".to_string())),\n        ];\n        let edge2 = create_arena_edge(&arena, id, \"LINK\", 0, 1, 2, props);\n        let bytes2 = bincode::serialize(&edge2).unwrap();\n\n        // Edge with props should be larger\n        assert!(bytes2.len() > bytes1.len());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_size_calculation_641": {
      "name": "test_vector_data_size_calculation",
      "type": "function",
      "start_line": 641,
      "end_line": 653,
      "content_hash": "5191b89337085a0155eba341ae576c90c3ebfad5",
      "content": "    fn test_vector_data_size_calculation() {\n        let arena = Bump::new();\n        let id = 33333u128;\n\n        // 128 dimensions\n        let data = vec![0.0; 128];\n        let vector = create_simple_vector(&arena, id, \"test\", &data);\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Should be exactly 128 * 8 bytes (128 f64 values)\n        assert_eq!(data_bytes.len(), 128 * 8);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}