{
  "file_path": "/work/internal/tui/components/dialogs/commands/commands.go",
  "file_hash": "6a8f112ff6d1d48609b01c42e154d2e436cde7b2",
  "updated_at": "2025-12-26T17:34:23.141824",
  "symbols": {
    "method_String_36": {
      "name": "String",
      "type": "method",
      "start_line": 36,
      "end_line": 46,
      "content_hash": "ea860980a253bc742f60b0b975d869ee7e2125ad",
      "content": "func (c commandType) String() string { return []string{\"System\", \"User\", \"MCP\"}[c] }\n\nconst (\n\tSystemCommands commandType = iota\n\tUserCommands\n\tMCPPrompts\n)\n\ntype listModel = list.FilterableList[list.CompletionItem[Command]]\n\n// Command represents a command that can be executed",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Command_47": {
      "name": "Command",
      "type": "struct",
      "start_line": 47,
      "end_line": 55,
      "content_hash": "48c0e60df615d46e1dc7fd161535ede829f548f8",
      "content": "type Command struct {\n\tID          string\n\tTitle       string\n\tDescription string\n\tShortcut    string // Optional shortcut for the command\n\tHandler     func(cmd Command) tea.Cmd\n}\n\n// CommandsDialog represents the commands dialog.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_CommandsDialog_56": {
      "name": "CommandsDialog",
      "type": "interface",
      "start_line": 56,
      "end_line": 59,
      "content_hash": "aaabb492c86c4648b8fd520cecd96614a2312cbc",
      "content": "type CommandsDialog interface {\n\tdialogs.DialogModel\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_commandDialogCmp_60": {
      "name": "commandDialogCmp",
      "type": "struct",
      "start_line": 60,
      "end_line": 90,
      "content_hash": "6f4dde7a8f7d4545d2ae6b557a90834e68af353c",
      "content": "type commandDialogCmp struct {\n\twidth   int\n\twWidth  int // Width of the terminal window\n\twHeight int // Height of the terminal window\n\n\tcommandList  listModel\n\tkeyMap       CommandsDialogKeyMap\n\thelp         help.Model\n\tselected     commandType           // Selected SystemCommands, UserCommands, or MCPPrompts\n\tuserCommands []Command             // User-defined commands\n\tmcpPrompts   *csync.Slice[Command] // MCP prompts\n\tsessionID    string                // Current session ID\n}\n\ntype (\n\tSwitchSessionsMsg      struct{}\n\tNewSessionsMsg         struct{}\n\tSwitchModelMsg         struct{}\n\tQuitMsg                struct{}\n\tOpenFilePickerMsg      struct{}\n\tToggleHelpMsg          struct{}\n\tToggleCompactModeMsg   struct{}\n\tToggleThinkingMsg      struct{}\n\tOpenReasoningDialogMsg struct{}\n\tOpenExternalEditorMsg  struct{}\n\tToggleYoloModeMsg      struct{}\n\tCompactMsg             struct {\n\t\tSessionID string\n\t}\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCommandDialog_91": {
      "name": "NewCommandDialog",
      "type": "function",
      "start_line": 91,
      "end_line": 122,
      "content_hash": "7de4d1b8c67026adb393b0f270b709bd121cf477",
      "content": "func NewCommandDialog(sessionID string) CommandsDialog {\n\tkeyMap := DefaultCommandsDialogKeyMap()\n\tlistKeyMap := list.DefaultKeyMap()\n\tlistKeyMap.Down.SetEnabled(false)\n\tlistKeyMap.Up.SetEnabled(false)\n\tlistKeyMap.DownOneItem = keyMap.Next\n\tlistKeyMap.UpOneItem = keyMap.Previous\n\n\tt := styles.CurrentTheme()\n\tinputStyle := t.S().Base.PaddingLeft(1).PaddingBottom(1)\n\tcommandList := list.NewFilterableList(\n\t\t[]list.CompletionItem[Command]{},\n\t\tlist.WithFilterInputStyle(inputStyle),\n\t\tlist.WithFilterListOptions(\n\t\t\tlist.WithKeyMap(listKeyMap),\n\t\t\tlist.WithWrapNavigation(),\n\t\t\tlist.WithResizeByList(),\n\t\t),\n\t)\n\thelp := help.New()\n\thelp.Styles = t.S().Help\n\treturn &commandDialogCmp{\n\t\tcommandList: commandList,\n\t\twidth:       defaultWidth,\n\t\tkeyMap:      DefaultCommandsDialogKeyMap(),\n\t\thelp:        help,\n\t\tselected:    SystemCommands,\n\t\tsessionID:   sessionID,\n\t\tmcpPrompts:  csync.NewSlice[Command](),\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_123": {
      "name": "Init",
      "type": "method",
      "start_line": 123,
      "end_line": 132,
      "content_hash": "642eeee6ee488b67e81d0b7cb4f070234ba59308",
      "content": "func (c *commandDialogCmp) Init() tea.Cmd {\n\tcommands, err := LoadCustomCommands()\n\tif err != nil {\n\t\treturn util.ReportError(err)\n\t}\n\tc.userCommands = commands\n\tc.mcpPrompts.SetSlice(loadMCPPrompts())\n\treturn c.setCommandType(c.selected)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_133": {
      "name": "Update",
      "type": "method",
      "start_line": 133,
      "end_line": 179,
      "content_hash": "07421c4af9d76f88dcb2d66212eecc991e8fc71e",
      "content": "func (c *commandDialogCmp) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\tc.wWidth = msg.Width\n\t\tc.wHeight = msg.Height\n\t\treturn c, tea.Batch(\n\t\t\tc.setCommandType(c.selected),\n\t\t\tc.commandList.SetSize(c.listWidth(), c.listHeight()),\n\t\t)\n\tcase pubsub.Event[mcp.Event]:\n\t\t// Reload MCP prompts when MCP state changes\n\t\tif msg.Type == pubsub.UpdatedEvent {\n\t\t\tc.mcpPrompts.SetSlice(loadMCPPrompts())\n\t\t\t// If we're currently viewing MCP prompts, refresh the list\n\t\t\tif c.selected == MCPPrompts {\n\t\t\t\treturn c, c.setCommandType(MCPPrompts)\n\t\t\t}\n\t\t\treturn c, nil\n\t\t}\n\tcase tea.KeyPressMsg:\n\t\tswitch {\n\t\tcase key.Matches(msg, c.keyMap.Select):\n\t\t\tselectedItem := c.commandList.SelectedItem()\n\t\t\tif selectedItem == nil {\n\t\t\t\treturn c, nil // No item selected, do nothing\n\t\t\t}\n\t\t\tcommand := (*selectedItem).Value()\n\t\t\treturn c, tea.Sequence(\n\t\t\t\tutil.CmdHandler(dialogs.CloseDialogMsg{}),\n\t\t\t\tcommand.Handler(command),\n\t\t\t)\n\t\tcase key.Matches(msg, c.keyMap.Tab):\n\t\t\tif len(c.userCommands) == 0 && c.mcpPrompts.Len() == 0 {\n\t\t\t\treturn c, nil\n\t\t\t}\n\t\t\treturn c, c.setCommandType(c.next())\n\t\tcase key.Matches(msg, c.keyMap.Close):\n\t\t\treturn c, util.CmdHandler(dialogs.CloseDialogMsg{})\n\t\tdefault:\n\t\t\tu, cmd := c.commandList.Update(msg)\n\t\t\tc.commandList = u.(listModel)\n\t\t\treturn c, cmd\n\t\t}\n\t}\n\treturn c, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_180": {
      "name": "next",
      "type": "method",
      "start_line": 180,
      "end_line": 201,
      "content_hash": "3b669b5fcf2aa6d0695f645722097171ad0805a1",
      "content": "func (c *commandDialogCmp) next() commandType {\n\tswitch c.selected {\n\tcase SystemCommands:\n\t\tif len(c.userCommands) > 0 {\n\t\t\treturn UserCommands\n\t\t}\n\t\tif c.mcpPrompts.Len() > 0 {\n\t\t\treturn MCPPrompts\n\t\t}\n\t\tfallthrough\n\tcase UserCommands:\n\t\tif c.mcpPrompts.Len() > 0 {\n\t\t\treturn MCPPrompts\n\t\t}\n\t\tfallthrough\n\tcase MCPPrompts:\n\t\treturn SystemCommands\n\tdefault:\n\t\treturn SystemCommands\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_202": {
      "name": "View",
      "type": "method",
      "start_line": 202,
      "end_line": 220,
      "content_hash": "540cf9663755a8a6812e5e6fc583c09de070a1d4",
      "content": "func (c *commandDialogCmp) View() string {\n\tt := styles.CurrentTheme()\n\tlistView := c.commandList\n\tradio := c.commandTypeRadio()\n\n\theader := t.S().Base.Padding(0, 1, 1, 1).Render(core.Title(\"Commands\", c.width-lipgloss.Width(radio)-5) + \" \" + radio)\n\tif len(c.userCommands) == 0 && c.mcpPrompts.Len() == 0 {\n\t\theader = t.S().Base.Padding(0, 1, 1, 1).Render(core.Title(\"Commands\", c.width-4))\n\t}\n\tcontent := lipgloss.JoinVertical(\n\t\tlipgloss.Left,\n\t\theader,\n\t\tlistView.View(),\n\t\t\"\",\n\t\tt.S().Base.Width(c.width-2).PaddingLeft(1).AlignHorizontal(lipgloss.Left).Render(c.help.View(c.keyMap)),\n\t)\n\treturn c.style().Render(content)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Cursor_221": {
      "name": "Cursor",
      "type": "method",
      "start_line": 221,
      "end_line": 231,
      "content_hash": "498de38e584413e5caaae135da1b40c0c81246f0",
      "content": "func (c *commandDialogCmp) Cursor() *tea.Cursor {\n\tif cursor, ok := c.commandList.(util.Cursor); ok {\n\t\tcursor := cursor.Cursor()\n\t\tif cursor != nil {\n\t\t\tcursor = c.moveCursor(cursor)\n\t\t}\n\t\treturn cursor\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_commandTypeRadio_232": {
      "name": "commandTypeRadio",
      "type": "method",
      "start_line": 232,
      "end_line": 253,
      "content_hash": "16d2be940c40978e6294ba220b92cf174b96553e",
      "content": "func (c *commandDialogCmp) commandTypeRadio() string {\n\tt := styles.CurrentTheme()\n\n\tfn := func(i commandType) string {\n\t\tif i == c.selected {\n\t\t\treturn \"\u25c9 \" + i.String()\n\t\t}\n\t\treturn \"\u25cb \" + i.String()\n\t}\n\n\tparts := []string{\n\t\tfn(SystemCommands),\n\t}\n\tif len(c.userCommands) > 0 {\n\t\tparts = append(parts, fn(UserCommands))\n\t}\n\tif c.mcpPrompts.Len() > 0 {\n\t\tparts = append(parts, fn(MCPPrompts))\n\t}\n\treturn t.S().Base.Foreground(t.FgHalfMuted).Render(strings.Join(parts, \" \"))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_listWidth_254": {
      "name": "listWidth",
      "type": "method",
      "start_line": 254,
      "end_line": 257,
      "content_hash": "c5b2119134386f764b6f9aefebea4c08a7b17ac5",
      "content": "func (c *commandDialogCmp) listWidth() int {\n\treturn defaultWidth - 2 // 4 for padding\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setCommandType_258": {
      "name": "setCommandType",
      "type": "method",
      "start_line": 258,
      "end_line": 286,
      "content_hash": "7c3ff8cb58a94ac7cd650656b5be699fe5201780",
      "content": "func (c *commandDialogCmp) setCommandType(commandType commandType) tea.Cmd {\n\tc.selected = commandType\n\n\tvar commands []Command\n\tswitch c.selected {\n\tcase SystemCommands:\n\t\tcommands = c.defaultCommands()\n\tcase UserCommands:\n\t\tcommands = c.userCommands\n\tcase MCPPrompts:\n\t\tcommands = slices.Collect(c.mcpPrompts.Seq())\n\t}\n\n\tcommandItems := []list.CompletionItem[Command]{}\n\tfor _, cmd := range commands {\n\t\topts := []list.CompletionItemOption{\n\t\t\tlist.WithCompletionID(cmd.ID),\n\t\t}\n\t\tif cmd.Shortcut != \"\" {\n\t\t\topts = append(\n\t\t\t\topts,\n\t\t\t\tlist.WithCompletionShortcut(cmd.Shortcut),\n\t\t\t)\n\t\t}\n\t\tcommandItems = append(commandItems, list.NewCompletionItem(cmd.Title, cmd, opts...))\n\t}\n\treturn c.commandList.SetItems(commandItems)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_listHeight_287": {
      "name": "listHeight",
      "type": "method",
      "start_line": 287,
      "end_line": 291,
      "content_hash": "55c178eb6dcc8562cc6c05f32ddbdbeb78f8bf62",
      "content": "func (c *commandDialogCmp) listHeight() int {\n\tlistHeigh := len(c.commandList.Items()) + 2 + 4 // height based on items + 2 for the input + 4 for the sections\n\treturn min(listHeigh, c.wHeight/2)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_moveCursor_292": {
      "name": "moveCursor",
      "type": "method",
      "start_line": 292,
      "end_line": 299,
      "content_hash": "f2cd9119ab5e53ca28260f945a303dd7dc55edfd",
      "content": "func (c *commandDialogCmp) moveCursor(cursor *tea.Cursor) *tea.Cursor {\n\trow, col := c.Position()\n\toffset := row + 3\n\tcursor.Y += offset\n\tcursor.X = cursor.X + col + 2\n\treturn cursor\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_style_300": {
      "name": "style",
      "type": "method",
      "start_line": 300,
      "end_line": 307,
      "content_hash": "564c8c751de69dc24cdcebcb3f2095561b7107fc",
      "content": "func (c *commandDialogCmp) style() lipgloss.Style {\n\tt := styles.CurrentTheme()\n\treturn t.S().Base.\n\t\tWidth(c.width).\n\t\tBorder(lipgloss.RoundedBorder()).\n\t\tBorderForeground(t.BorderFocus)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Position_308": {
      "name": "Position",
      "type": "method",
      "start_line": 308,
      "end_line": 314,
      "content_hash": "81f831b9d4ca1d12743c7871c9c7ea1fa5267103",
      "content": "func (c *commandDialogCmp) Position() (int, int) {\n\trow := c.wHeight/4 - 2 // just a bit above the center\n\tcol := c.wWidth / 2\n\tcol -= c.width / 2\n\treturn row, col\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_defaultCommands_315": {
      "name": "defaultCommands",
      "type": "method",
      "start_line": 315,
      "end_line": 480,
      "content_hash": "9ed6c8b837b445230607fa52b031df5094d62232",
      "content": "func (c *commandDialogCmp) defaultCommands() []Command {\n\tcommands := []Command{\n\t\t{\n\t\t\tID:          \"new_session\",\n\t\t\tTitle:       \"New Session\",\n\t\t\tDescription: \"start a new session\",\n\t\t\tShortcut:    \"ctrl+n\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(NewSessionsMsg{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:          \"switch_session\",\n\t\t\tTitle:       \"Switch Session\",\n\t\t\tDescription: \"Switch to a different session\",\n\t\t\tShortcut:    \"ctrl+s\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(SwitchSessionsMsg{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:          \"switch_model\",\n\t\t\tTitle:       \"Switch Model\",\n\t\t\tDescription: \"Switch to a different model\",\n\t\t\tShortcut:    \"ctrl+l\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(SwitchModelMsg{})\n\t\t\t},\n\t\t},\n\t}\n\n\t// Only show compact command if there's an active session\n\tif c.sessionID != \"\" {\n\t\tcommands = append(commands, Command{\n\t\t\tID:          \"Summarize\",\n\t\t\tTitle:       \"Summarize Session\",\n\t\t\tDescription: \"Summarize the current session and create a new one with the summary\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(CompactMsg{\n\t\t\t\t\tSessionID: c.sessionID,\n\t\t\t\t})\n\t\t\t},\n\t\t})\n\t}\n\n\t// Add reasoning toggle for models that support it\n\tcfg := config.Get()\n\tif agentCfg, ok := cfg.Agents[config.AgentCoder]; ok {\n\t\tproviderCfg := cfg.GetProviderForModel(agentCfg.Model)\n\t\tmodel := cfg.GetModelByType(agentCfg.Model)\n\t\tif providerCfg != nil && model != nil && model.CanReason {\n\t\t\tselectedModel := cfg.Models[agentCfg.Model]\n\n\t\t\t// Anthropic models: thinking toggle\n\t\t\tif providerCfg.Type == catwalk.TypeAnthropic {\n\t\t\t\tstatus := \"Enable\"\n\t\t\t\tif selectedModel.Think {\n\t\t\t\t\tstatus = \"Disable\"\n\t\t\t\t}\n\t\t\t\tcommands = append(commands, Command{\n\t\t\t\t\tID:          \"toggle_thinking\",\n\t\t\t\t\tTitle:       status + \" Thinking Mode\",\n\t\t\t\t\tDescription: \"Toggle model thinking for reasoning-capable models\",\n\t\t\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\t\t\treturn util.CmdHandler(ToggleThinkingMsg{})\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// OpenAI models: reasoning effort dialog\n\t\t\tif len(model.ReasoningLevels) > 0 {\n\t\t\t\tcommands = append(commands, Command{\n\t\t\t\t\tID:          \"select_reasoning_effort\",\n\t\t\t\t\tTitle:       \"Select Reasoning Effort\",\n\t\t\t\t\tDescription: \"Choose reasoning effort level (low/medium/high)\",\n\t\t\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\t\t\treturn util.CmdHandler(OpenReasoningDialogMsg{})\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\t// Only show toggle compact mode command if window width is larger than compact breakpoint (90)\n\tif c.wWidth > 120 && c.sessionID != \"\" {\n\t\tcommands = append(commands, Command{\n\t\t\tID:          \"toggle_sidebar\",\n\t\t\tTitle:       \"Toggle Sidebar\",\n\t\t\tDescription: \"Toggle between compact and normal layout\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(ToggleCompactModeMsg{})\n\t\t\t},\n\t\t})\n\t}\n\tif c.sessionID != \"\" {\n\t\tagentCfg := config.Get().Agents[config.AgentCoder]\n\t\tmodel := config.Get().GetModelByType(agentCfg.Model)\n\t\tif model.SupportsImages {\n\t\t\tcommands = append(commands, Command{\n\t\t\t\tID:          \"file_picker\",\n\t\t\t\tTitle:       \"Open File Picker\",\n\t\t\t\tShortcut:    \"ctrl+f\",\n\t\t\t\tDescription: \"Open file picker\",\n\t\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\t\treturn util.CmdHandler(OpenFilePickerMsg{})\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\t// Add external editor command if $EDITOR is available\n\tif os.Getenv(\"EDITOR\") != \"\" {\n\t\tcommands = append(commands, Command{\n\t\t\tID:          \"open_external_editor\",\n\t\t\tTitle:       \"Open External Editor\",\n\t\t\tShortcut:    \"ctrl+o\",\n\t\t\tDescription: \"Open external editor to compose message\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(OpenExternalEditorMsg{})\n\t\t\t},\n\t\t})\n\t}\n\n\treturn append(commands, []Command{\n\t\t{\n\t\t\tID:          \"toggle_yolo\",\n\t\t\tTitle:       \"Toggle Yolo Mode\",\n\t\t\tDescription: \"Toggle yolo mode\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(ToggleYoloModeMsg{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:          \"toggle_help\",\n\t\t\tTitle:       \"Toggle Help\",\n\t\t\tShortcut:    \"ctrl+g\",\n\t\t\tDescription: \"Toggle help\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(ToggleHelpMsg{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:          \"init\",\n\t\t\tTitle:       \"Initialize Project\",\n\t\t\tDescription: fmt.Sprintf(\"Create/Update the %s memory file\", config.Get().Options.InitializeAs),\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\tinitPrompt, err := agent.InitializePrompt(*config.Get())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn util.ReportError(err)\n\t\t\t\t}\n\t\t\t\treturn util.CmdHandler(chat.SendMsg{\n\t\t\t\t\tText: initPrompt,\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:          \"quit\",\n\t\t\tTitle:       \"Quit\",\n\t\t\tDescription: \"Quit\",\n\t\t\tShortcut:    \"ctrl+c\",\n\t\t\tHandler: func(cmd Command) tea.Cmd {\n\t\t\t\treturn util.CmdHandler(QuitMsg{})\n\t\t\t},\n\t\t},\n\t}...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ID_481": {
      "name": "ID",
      "type": "method",
      "start_line": 481,
      "end_line": 483,
      "content_hash": "9efbace2a01a33749a70a392c4df53897eb37d2a",
      "content": "func (c *commandDialogCmp) ID() dialogs.DialogID {\n\treturn CommandsDialogID\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}