{
  "file_path": "/work/internal/config/config.go",
  "file_hash": "448f135dbe2d60f6c735df458ddb48b25f096cd6",
  "updated_at": "2025-12-26T17:34:23.398882",
  "symbols": {
    "struct_SelectedModel_61": {
      "name": "SelectedModel",
      "type": "struct",
      "start_line": 61,
      "end_line": 86,
      "content_hash": "3b894aa61e23281b8eec5b4ed8f1eb09e2d6ce0c",
      "content": "type SelectedModel struct {\n\t// The model id as used by the provider API.\n\t// Required.\n\tModel string `json:\"model\" jsonschema:\"required,description=The model ID as used by the provider API,example=gpt-4o\"`\n\t// The model provider, same as the key/id used in the providers config.\n\t// Required.\n\tProvider string `json:\"provider\" jsonschema:\"required,description=The model provider ID that matches a key in the providers config,example=openai\"`\n\n\t// Only used by models that use the openai provider and need this set.\n\tReasoningEffort string `json:\"reasoning_effort,omitempty\" jsonschema:\"description=Reasoning effort level for OpenAI models that support it,enum=low,enum=medium,enum=high\"`\n\n\t// Used by anthropic models that can reason to indicate if the model should think.\n\tThink bool `json:\"think,omitempty\" jsonschema:\"description=Enable thinking mode for Anthropic models that support reasoning\"`\n\n\t// Overrides the default model configuration.\n\tMaxTokens        int64    `json:\"max_tokens,omitempty\" jsonschema:\"description=Maximum number of tokens for model responses,maximum=200000,example=4096\"`\n\tTemperature      *float64 `json:\"temperature,omitempty\" jsonschema:\"description=Sampling temperature,minimum=0,maximum=1,example=0.7\"`\n\tTopP             *float64 `json:\"top_p,omitempty\" jsonschema:\"description=Top-p (nucleus) sampling parameter,minimum=0,maximum=1,example=0.9\"`\n\tTopK             *int64   `json:\"top_k,omitempty\" jsonschema:\"description=Top-k sampling parameter\"`\n\tFrequencyPenalty *float64 `json:\"frequency_penalty,omitempty\" jsonschema:\"description=Frequency penalty to reduce repetition\"`\n\tPresencePenalty  *float64 `json:\"presence_penalty,omitempty\" jsonschema:\"description=Presence penalty to increase topic diversity\"`\n\n\t// Override provider specific options.\n\tProviderOptions map[string]any `json:\"provider_options,omitempty\" jsonschema:\"description=Additional provider-specific options for the model\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ProviderConfig_87": {
      "name": "ProviderConfig",
      "type": "struct",
      "start_line": 87,
      "end_line": 119,
      "content_hash": "80302a67211aff6ecaa0a432f8b7b37860192392",
      "content": "type ProviderConfig struct {\n\t// The provider's id.\n\tID string `json:\"id,omitempty\" jsonschema:\"description=Unique identifier for the provider,example=openai\"`\n\t// The provider's name, used for display purposes.\n\tName string `json:\"name,omitempty\" jsonschema:\"description=Human-readable name for the provider,example=OpenAI\"`\n\t// The provider's API endpoint.\n\tBaseURL string `json:\"base_url,omitempty\" jsonschema:\"description=Base URL for the provider's API,format=uri,example=https://api.openai.com/v1\"`\n\t// The provider type, e.g. \"openai\", \"anthropic\", etc. if empty it defaults to openai.\n\tType catwalk.Type `json:\"type,omitempty\" jsonschema:\"description=Provider type that determines the API format,enum=openai,enum=openai-compat,enum=anthropic,enum=gemini,enum=azure,enum=vertexai,default=openai\"`\n\t// The provider's API key.\n\tAPIKey string `json:\"api_key,omitempty\" jsonschema:\"description=API key for authentication with the provider,example=$OPENAI_API_KEY\"`\n\t// OAuthToken for providers that use OAuth2 authentication.\n\tOAuthToken *oauth.Token `json:\"oauth,omitempty\" jsonschema:\"description=OAuth2 token for authentication with the provider\"`\n\t// Marks the provider as disabled.\n\tDisable bool `json:\"disable,omitempty\" jsonschema:\"description=Whether this provider is disabled,default=false\"`\n\n\t// Custom system prompt prefix.\n\tSystemPromptPrefix string `json:\"system_prompt_prefix,omitempty\" jsonschema:\"description=Custom prefix to add to system prompts for this provider\"`\n\n\t// Extra headers to send with each request to the provider.\n\tExtraHeaders map[string]string `json:\"extra_headers,omitempty\" jsonschema:\"description=Additional HTTP headers to send with requests\"`\n\t// Extra body\n\tExtraBody map[string]any `json:\"extra_body,omitempty\" jsonschema:\"description=Additional fields to include in request bodies, only works with openai-compatible providers\"`\n\n\tProviderOptions map[string]any `json:\"provider_options,omitempty\" jsonschema:\"description=Additional provider-specific options for this provider\"`\n\n\t// Used to pass extra parameters to the provider.\n\tExtraParams map[string]string `json:\"-\"`\n\n\t// The provider models\n\tModels []catwalk.Model `json:\"models,omitempty\" jsonschema:\"description=List of models available from this provider\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetupClaudeCode_120": {
      "name": "SetupClaudeCode",
      "type": "method",
      "start_line": 120,
      "end_line": 143,
      "content_hash": "c16400b167ec210a4251b415c0a973be61736f9d",
      "content": "func (pc *ProviderConfig) SetupClaudeCode() {\n\tpc.APIKey = fmt.Sprintf(\"Bearer %s\", pc.OAuthToken.AccessToken)\n\tpc.SystemPromptPrefix = \"You are Claude Code, Anthropic's official CLI for Claude.\"\n\tpc.ExtraHeaders[\"anthropic-version\"] = \"2023-06-01\"\n\n\tvalue := pc.ExtraHeaders[\"anthropic-beta\"]\n\tconst want = \"oauth-2025-04-20\"\n\tif !strings.Contains(value, want) {\n\t\tif value != \"\" {\n\t\t\tvalue += \",\"\n\t\t}\n\t\tvalue += want\n\t}\n\tpc.ExtraHeaders[\"anthropic-beta\"] = value\n}\n\ntype MCPType string\n\nconst (\n\tMCPStdio MCPType = \"stdio\"\n\tMCPSSE   MCPType = \"sse\"\n\tMCPHttp  MCPType = \"http\"\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPConfig_144": {
      "name": "MCPConfig",
      "type": "struct",
      "start_line": 144,
      "end_line": 160,
      "content_hash": "ad41bf63cf44c452e1f80498ad79ef60a540d11b",
      "content": "type MCPConfig struct {\n\tCommand  string            `json:\"command,omitempty\" jsonschema:\"description=Command to execute for stdio MCP servers,example=npx\"`\n\tEnv      map[string]string `json:\"env,omitempty\" jsonschema:\"description=Environment variables to set for the MCP server\"`\n\tArgs     []string          `json:\"args,omitempty\" jsonschema:\"description=Arguments to pass to the MCP server command\"`\n\tType     MCPType           `json:\"type\" jsonschema:\"required,description=Type of MCP connection,enum=stdio,enum=sse,enum=http,default=stdio\"`\n\tURL      string            `json:\"url,omitempty\" jsonschema:\"description=URL for HTTP or SSE MCP servers,format=uri,example=http://localhost:3000/mcp\"`\n\tDisabled bool              `json:\"disabled,omitempty\" jsonschema:\"description=Whether this MCP server is disabled,default=false\"`\n\tTimeout  int               `json:\"timeout,omitempty\" jsonschema:\"description=Timeout in seconds for MCP server connections,default=15,example=30,example=60,example=120\"`\n\n\t// Environment variable configuration support\n\t// Environment variables that can override these settings:\n\t// - NEXORA_PROVIDER_HEADER_{KEY}=value for HTTP headers (e.g., NEXORA_PROVIDER_HEADER_AUTHORIZATION='Bearer token')\n\t// - NEXORA_PROVIDER_BASE_URL=value for provider base URL override\n\t// Headers are converted to lowercase and underscores become hyphens\n\tHeaders map[string]string `json:\"headers,omitempty\" jsonschema:\"description=HTTP headers for HTTP/SSE MCP servers\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_LSPConfig_161": {
      "name": "LSPConfig",
      "type": "struct",
      "start_line": 161,
      "end_line": 171,
      "content_hash": "fc5d313866dbefbe6b3859446a12b379dd492b22",
      "content": "type LSPConfig struct {\n\tDisabled    bool              `json:\"disabled,omitempty\" jsonschema:\"description=Whether this LSP server is disabled,default=false\"`\n\tCommand     string            `json:\"command,omitempty\" jsonschema:\"required,description=Command to execute for the LSP server,example=gopls\"`\n\tArgs        []string          `json:\"args,omitempty\" jsonschema:\"description=Arguments to pass to the LSP server command\"`\n\tEnv         map[string]string `json:\"env,omitempty\" jsonschema:\"description=Environment variables to set to the LSP server command\"`\n\tFileTypes   []string          `json:\"filetypes,omitempty\" jsonschema:\"description=File types this LSP server handles,example=go,example=mod,example=rs,example=c,example=js,example=ts\"`\n\tRootMarkers []string          `json:\"root_markers,omitempty\" jsonschema:\"description=Files or directories that indicate the project root,example=go.mod,example=package.json,example=Cargo.toml\"`\n\tInitOptions map[string]any    `json:\"init_options,omitempty\" jsonschema:\"description=Initialization options passed to the LSP server during initialize request\"`\n\tOptions     map[string]any    `json:\"options,omitempty\" jsonschema:\"description=LSP server-specific settings passed during initialization\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TUIOptions_172": {
      "name": "TUIOptions",
      "type": "struct",
      "start_line": 172,
      "end_line": 181,
      "content_hash": "302d2170d20d445b877dd029517fd07a212f4b3d",
      "content": "type TUIOptions struct {\n\tCompactMode bool   `json:\"compact_mode,omitempty\" jsonschema:\"description=Enable compact mode for the TUI interface,default=false\"`\n\tDiffMode    string `json:\"diff_mode,omitempty\" jsonschema:\"description=Diff mode for the TUI interface,enum=unified,enum=split\"`\n\t// Here we can add themes later or any TUI related options\n\t//\n\n\tCompletions Completions `json:\"completions,omitzero\" jsonschema:\"description=Completions UI options\"`\n}\n\n// Completions defines options for the completions UI.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Completions_182": {
      "name": "Completions",
      "type": "struct",
      "start_line": 182,
      "end_line": 186,
      "content_hash": "f55bab59998a9da39bf41e8d1658f2498117b194",
      "content": "type Completions struct {\n\tMaxDepth *int `json:\"max_depth,omitempty\" jsonschema:\"description=Maximum depth for the ls tool,default=0,example=10\"`\n\tMaxItems *int `json:\"max_items,omitempty\" jsonschema:\"description=Maximum number of items to return for the ls tool,default=1000,example=100\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Limits_187": {
      "name": "Limits",
      "type": "method",
      "start_line": 187,
      "end_line": 190,
      "content_hash": "cbb00843d45a9696ba47a368595a6e24c0285c22",
      "content": "func (c Completions) Limits() (depth, items int) {\n\treturn ptrValOr(c.MaxDepth, 0), ptrValOr(c.MaxItems, 0)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Permissions_191": {
      "name": "Permissions",
      "type": "struct",
      "start_line": 191,
      "end_line": 203,
      "content_hash": "d8003b12f947e6af7bd6b71199ed4d6de7c8aa58",
      "content": "type Permissions struct {\n\tAllowedTools []string `json:\"allowed_tools,omitempty\" jsonschema:\"description=List of tools that don't require permission prompts,example=bash,example=view\"` // Tools that don't require permission prompts\n\tSkipRequests bool     `json:\"-\"`                                                                                                                              // Automatically accept all permissions (YOLO mode)\n}\n\ntype TrailerStyle string\n\nconst (\n\tTrailerStyleNone         TrailerStyle = \"none\"\n\tTrailerStyleCoAuthoredBy TrailerStyle = \"co-authored-by\"\n\tTrailerStyleAssistedBy   TrailerStyle = \"assisted-by\"\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Attribution_204": {
      "name": "Attribution",
      "type": "struct",
      "start_line": 204,
      "end_line": 218,
      "content_hash": "7dcdd32d6ae65626177f05384b6ed9ed555eefc4",
      "content": "type Attribution struct {\n\tTrailerStyle  TrailerStyle `json:\"trailer_style,omitempty\" jsonschema:\"description=Style of attribution trailer to add to commits,enum=none,enum=co-authored-by,enum=assisted-by,default=assisted-by\"`\n\tCoAuthoredBy  *bool        `json:\"co_authored_by,omitempty\" jsonschema:\"description=Deprecated: use trailer_style instead\"`\n\tGeneratedWith bool         `json:\"generated_with,omitempty\" jsonschema:\"description=Add Generated with Nexora line to commit messages and issues and PRs,default=true\"`\n}\n\n// JSONSchemaExtend marks the co_authored_by field as deprecated in the schema.\nfunc (Attribution) JSONSchemaExtend(schema *jsonschema.Schema) {\n\tif schema.Properties != nil {\n\t\tif prop, ok := schema.Properties.Get(\"co_authored_by\"); ok {\n\t\t\tprop.Deprecated = true\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Options_219": {
      "name": "Options",
      "type": "struct",
      "start_line": 219,
      "end_line": 235,
      "content_hash": "2ef2f41a569c0d4d6ac4d8ccb4e9f62599a9b4d3",
      "content": "type Options struct {\n\tContextPaths              []string     `json:\"context_paths,omitempty\" jsonschema:\"description=Paths to files containing context information for the AI,example=.cursorrules,example=NEXORA.md\"`\n\tTUI                       *TUIOptions  `json:\"tui,omitempty\" jsonschema:\"description=Terminal user interface options\"`\n\tDebug                     bool         `json:\"debug,omitempty\" jsonschema:\"description=Enable debug logging,default=false\"`\n\tDebugLSP                  bool         `json:\"debug_lsp,omitempty\" jsonschema:\"description=Enable debug logging for LSP servers,default=false\"`\n\tDisableAutoSummarize      bool         `json:\"disable_auto_summarize,omitempty\" jsonschema:\"description=Disable automatic conversation summarization,default=false\"`\n\tDataDirectory             string       `json:\"data_directory,omitempty\" jsonschema:\"description=Directory for storing application data (relative to working directory),default=.nexora,example=.nexora\"` // Relative to the cwd\n\tDisabledTools             []string     `json:\"disabled_tools\" jsonschema:\"description=Tools to disable\"`\n\tDisableProviderAutoUpdate bool         `json:\"disable_provider_auto_update,omitempty\" jsonschema:\"description=Disable providers auto-update,default=false\"`\n\tAttribution               *Attribution `json:\"attribution,omitempty\" jsonschema:\"description=Attribution settings for generated content\"`\n\tIsTurboMode               bool         `json:\"is_turbo_mode,omitempty\" jsonschema:\"description=Enable turbo mode for faster performance,default=false\"`\n\n\tInitializeAs string `json:\"initialize_as,omitempty\" jsonschema:\"description=Name of the context file to create/update during project initialization,default=AGENTS.md,example=AGENTS.md,example=NEXORA.md,example=CLAUDE.md,example=docs/LLMs.md\"`\n}\n\ntype MCPs map[string]MCPConfig\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCP_236": {
      "name": "MCP",
      "type": "struct",
      "start_line": 236,
      "end_line": 240,
      "content_hash": "81b8c8adea8f77adba2144c0729dd67a7413de33",
      "content": "type MCP struct {\n\tName string    `json:\"name\"`\n\tMCP  MCPConfig `json:\"mcp\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Sorted_241": {
      "name": "Sorted",
      "type": "method",
      "start_line": 241,
      "end_line": 256,
      "content_hash": "1dd2a238d0854bfe2d05a8f7195ab3e8f67439a6",
      "content": "func (m MCPs) Sorted() []MCP {\n\tsorted := make([]MCP, 0, len(m))\n\tfor k, v := range m {\n\t\tsorted = append(sorted, MCP{\n\t\t\tName: k,\n\t\t\tMCP:  v,\n\t\t})\n\t}\n\tslices.SortFunc(sorted, func(a, b MCP) int {\n\t\treturn strings.Compare(a.Name, b.Name)\n\t})\n\treturn sorted\n}\n\ntype LSPs map[string]LSPConfig\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_LSP_257": {
      "name": "LSP",
      "type": "struct",
      "start_line": 257,
      "end_line": 261,
      "content_hash": "e2c418bf8741f3ff77e0510738b34aa50970a80e",
      "content": "type LSP struct {\n\tName string    `json:\"name\"`\n\tLSP  LSPConfig `json:\"lsp\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Sorted_262": {
      "name": "Sorted",
      "type": "method",
      "start_line": 262,
      "end_line": 275,
      "content_hash": "3f47f0282a131f1171fd56fb9449432bb3d062c7",
      "content": "func (l LSPs) Sorted() []LSP {\n\tsorted := make([]LSP, 0, len(l))\n\tfor k, v := range l {\n\t\tsorted = append(sorted, LSP{\n\t\t\tName: k,\n\t\t\tLSP:  v,\n\t\t})\n\t}\n\tslices.SortFunc(sorted, func(a, b LSP) int {\n\t\treturn strings.Compare(a.Name, b.Name)\n\t})\n\treturn sorted\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ResolvedEnv_276": {
      "name": "ResolvedEnv",
      "type": "method",
      "start_line": 276,
      "end_line": 279,
      "content_hash": "5ef4f581bea94fbc60ab746ede6ecbae9332737d",
      "content": "func (l LSPConfig) ResolvedEnv() []string {\n\treturn resolveEnvs(l.Env)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ResolvedEnv_280": {
      "name": "ResolvedEnv",
      "type": "method",
      "start_line": 280,
      "end_line": 283,
      "content_hash": "e2e8341d7c1ce80e842d06a93f48a6b261af5d7e",
      "content": "func (m MCPConfig) ResolvedEnv() []string {\n\treturn resolveEnvs(m.Env)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ResolvedHeaders_284": {
      "name": "ResolvedHeaders",
      "type": "method",
      "start_line": 284,
      "end_line": 296,
      "content_hash": "383326cde5832449330b027cf78174f2384d7365",
      "content": "func (m MCPConfig) ResolvedHeaders() map[string]string {\n\tresolver := NewShellVariableResolver(env.New())\n\tfor e, v := range m.Headers {\n\t\tvar err error\n\t\tm.Headers[e], err = resolver.ResolveValue(v)\n\t\tif err != nil {\n\t\t\tslog.Error(\"error resolving header variable\", \"error\", err, \"variable\", e, \"value\", v)\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn m.Headers\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Agent_297": {
      "name": "Agent",
      "type": "struct",
      "start_line": 297,
      "end_line": 319,
      "content_hash": "242b7d86f8362b633a4fe78570bcdb1968e07ecb",
      "content": "type Agent struct {\n\tID          string `json:\"id,omitempty\"`\n\tName        string `json:\"name,omitempty\"`\n\tDescription string `json:\"description,omitempty\"`\n\t// This is the id of the system prompt used by the agent\n\tDisabled bool `json:\"disabled,omitempty\"`\n\n\tModel SelectedModelType `json:\"model\" jsonschema:\"required,description=The model type to use for this agent,enum=large,enum=small,default=large\"`\n\n\t// The available tools for the agent\n\t//  if this is nil, all tools are available\n\tAllowedTools []string `json:\"allowed_tools,omitempty\"`\n\n\t// this tells us which MCPs are available for this agent\n\t//  if this is empty all mcps are available\n\t//  the string array is the list of tools from the AllowedMCP the agent has available\n\t//  if the string array is nil, all tools from the AllowedMCP are available\n\tAllowedMCP map[string][]string `json:\"allowed_mcp,omitempty\"`\n\n\t// Overrides the context paths for this agent\n\tContextPaths []string `json:\"context_paths,omitempty\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Tools_320": {
      "name": "Tools",
      "type": "struct",
      "start_line": 320,
      "end_line": 323,
      "content_hash": "ec187ecd9ecf629c0471ebceacd1996d6c408d21",
      "content": "type Tools struct {\n\tLs ToolLs `json:\"ls,omitzero\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ToolLs_324": {
      "name": "ToolLs",
      "type": "struct",
      "start_line": 324,
      "end_line": 328,
      "content_hash": "113844a0b1644b71f530b36ff941617bf360cf24",
      "content": "type ToolLs struct {\n\tMaxDepth *int `json:\"max_depth,omitempty\" jsonschema:\"description=Maximum depth for the ls tool,default=0,example=10\"`\n\tMaxItems *int `json:\"max_items,omitempty\" jsonschema:\"description=Maximum number of items to return for the ls tool,default=1000,example=100\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Limits_329": {
      "name": "Limits",
      "type": "method",
      "start_line": 329,
      "end_line": 333,
      "content_hash": "f8df004d613645147bf84457c9183725c965c91d",
      "content": "func (t ToolLs) Limits() (depth, items int) {\n\treturn ptrValOr(t.MaxDepth, 0), ptrValOr(t.MaxItems, 0)\n}\n\n// AIOPSConfig contains configuration for the AI operations service.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AIOPSConfig_334": {
      "name": "AIOPSConfig",
      "type": "struct",
      "start_line": 334,
      "end_line": 341,
      "content_hash": "9cebc649295119c4c4a5452d97ef7f25607008d5",
      "content": "type AIOPSConfig struct {\n\tEnabled  bool          `json:\"enabled\" yaml:\"enabled\" jsonschema:\"description=Enable AI operations service\"`\n\tEndpoint string        `json:\"endpoint\" yaml:\"endpoint\" jsonschema:\"description=AIOPS service endpoint (e.g., http://gpu-box:8420)\"`\n\tTimeout  time.Duration `json:\"timeout\" yaml:\"timeout\" jsonschema:\"description=Request timeout for AI operations\"`\n\tFallback bool          `json:\"fallback\" yaml:\"fallback\" jsonschema:\"description=Continue without AIOPs if unavailable\"`\n}\n\n// Config holds the configuration for nexora.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Config_342": {
      "name": "Config",
      "type": "struct",
      "start_line": 342,
      "end_line": 379,
      "content_hash": "846cacfbc2c4aab25f07d1bde55f41a5990973df",
      "content": "type Config struct {\n\tSchema string `json:\"$schema,omitempty\"`\n\n\t// We currently only support large/small as values here.\n\tModels map[SelectedModelType]SelectedModel `json:\"models,omitempty\" jsonschema:\"description=Model configurations for different model types,example={\\\"large\\\":{\\\"model\\\":\\\"gpt-4o\\\",\\\"provider\\\":\\\"openai\\\"}}\"`\n\t// Recently used models stored in the data directory config.\n\tRecentModels map[SelectedModelType][]SelectedModel `json:\"recent_models,omitempty\" jsonschema:\"description=Recently used models sorted by most recent first\"`\n\n\t// The providers that are configured\n\tProviders *csync.Map[string, ProviderConfig] `json:\"providers,omitempty\" jsonschema:\"description=AI provider configurations\"`\n\n\tMCP MCPs `json:\"mcp,omitempty\" jsonschema:\"description=Model Context Protocol server configurations\"`\n\n\tLSP LSPs `json:\"lsp,omitempty\" jsonschema:\"description=Language Server Protocol configurations\"`\n\n\tOptions *Options `json:\"options,omitempty\" jsonschema:\"description=General application options\"`\n\n\tPermissions *Permissions `json:\"permissions,omitempty\" jsonschema:\"description=Permission settings for tool usage\"`\n\n\tTools Tools `json:\"tools,omitzero\" jsonschema:\"description=Tool configurations\"`\n\n\tAIOPS AIOPSConfig `json:\"aiops,omitempty\" jsonschema:\"description=AI operations service configuration for local model support\"`\n\n\tAgents map[string]Agent `json:\"-\"`\n\n\t// Internal\n\tworkingDir string `json:\"-\"`\n\t// Architecture note: resolver field creates tight coupling\n\t// Future refactoring should consider:\n\t// - Creating separate configuration loading and resolution phases\n\t// - Implementing dependency injection for resolvers\n\t// - Moving runtime concerns out of configuration struct\n\tresolver        VariableResolver\n\tdataConfigDir   string             `json:\"-\"`\n\tknownProviders  []catwalk.Provider `json:\"-\"`\n\tmodelsNeedSetup bool               `json:\"-\"` // Flag to indicate if TUI setup is needed for models\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_WorkingDir_380": {
      "name": "WorkingDir",
      "type": "method",
      "start_line": 380,
      "end_line": 384,
      "content_hash": "0e61b6e2a0b28925f276188d986782dae6ceed56",
      "content": "func (c *Config) WorkingDir() string {\n\treturn c.workingDir\n}\n\n// ModelsNeedSetup returns true if models need TUI setup",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ModelsNeedSetup_385": {
      "name": "ModelsNeedSetup",
      "type": "method",
      "start_line": 385,
      "end_line": 388,
      "content_hash": "518d4060036b00cbfd98665a5b923aa4e7fa4b8d",
      "content": "func (c *Config) ModelsNeedSetup() bool {\n\treturn c.modelsNeedSetup\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_EnabledProviders_389": {
      "name": "EnabledProviders",
      "type": "method",
      "start_line": 389,
      "end_line": 399,
      "content_hash": "212e2ce40fae70fc2858cfc7980e27e801e53f83",
      "content": "func (c *Config) EnabledProviders() []ProviderConfig {\n\tvar enabled []ProviderConfig\n\tfor p := range c.Providers.Seq() {\n\t\tif !p.Disable {\n\t\t\tenabled = append(enabled, p)\n\t\t}\n\t}\n\treturn enabled\n}\n\n// IsConfigured  return true if at least one provider is configured",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsConfigured_400": {
      "name": "IsConfigured",
      "type": "method",
      "start_line": 400,
      "end_line": 404,
      "content_hash": "1a80d698ea048659d5cf147e23e9c1ce2bde5af6",
      "content": "func (c *Config) IsConfigured() bool {\n\treturn len(c.EnabledProviders()) > 0\n}\n\n// AreModelsConfigured return true if both large and small models are configured",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_AreModelsConfigured_405": {
      "name": "AreModelsConfigured",
      "type": "method",
      "start_line": 405,
      "end_line": 422,
      "content_hash": "7f7b365b9b591ee9262a8ddc5bea889f6dd2ba8f",
      "content": "func (c *Config) AreModelsConfigured() bool {\n\t_, largeSelected := c.Models[SelectedModelTypeLarge]\n\t_, smallSelected := c.Models[SelectedModelTypeSmall]\n\n\tif !largeSelected || !smallSelected {\n\t\treturn false\n\t}\n\n\t// Check if providers exist for both models\n\tlargeModel, _ := c.Models[SelectedModelTypeLarge]\n\tsmallModel, _ := c.Models[SelectedModelTypeSmall]\n\n\t_, largeProviderExists := c.Providers.Get(largeModel.Provider)\n\t_, smallProviderExists := c.Providers.Get(smallModel.Provider)\n\n\treturn largeProviderExists && smallProviderExists\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetModel_423": {
      "name": "GetModel",
      "type": "method",
      "start_line": 423,
      "end_line": 449,
      "content_hash": "3612c29e872bebc560036a45fe8e1e1f06a5eb30",
      "content": "func (c *Config) GetModel(provider, model string) *catwalk.Model {\n\tif providerConfig, ok := c.Providers.Get(provider); ok {\n\t\tfor _, m := range providerConfig.Models {\n\t\t\tif m.ID == model {\n\t\t\t\treturn &m\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fall back to catwalk known providers if not found in provider config\n\tproviders, err := Providers(c)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tfor _, p := range providers {\n\t\tif string(p.ID) == provider {\n\t\t\tfor _, m := range p.Models {\n\t\t\t\tif m.ID == model {\n\t\t\t\t\treturn &m\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetProviderForModel_450": {
      "name": "GetProviderForModel",
      "type": "method",
      "start_line": 450,
      "end_line": 481,
      "content_hash": "4906a151e5f344be157aeb850084c1291ec813d4",
      "content": "func (c *Config) GetProviderForModel(modelType SelectedModelType) *ProviderConfig {\n\tmodel, ok := c.Models[modelType]\n\tif !ok {\n\t\treturn nil\n\t}\n\tif providerConfig, ok := c.Providers.Get(model.Provider); ok {\n\t\treturn &providerConfig\n\t}\n\n\t// Fall back to known providers if not found in config\n\t// This handles injected providers like \"nexora\"\n\tproviders, err := Providers(c)\n\tif err == nil {\n\t\tfor _, p := range providers {\n\t\t\tif string(p.ID) == model.Provider {\n\t\t\t\t// Create a ProviderConfig from the known provider\n\t\t\t\tcfg := ProviderConfig{\n\t\t\t\t\tID:           string(p.ID),\n\t\t\t\t\tName:         p.Name,\n\t\t\t\t\tBaseURL:      p.APIEndpoint,\n\t\t\t\t\tType:         p.Type,\n\t\t\t\t\tModels:       p.Models,\n\t\t\t\t\tExtraHeaders: make(map[string]string),\n\t\t\t\t}\n\t\t\t\treturn &cfg\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetModelByType_482": {
      "name": "GetModelByType",
      "type": "method",
      "start_line": 482,
      "end_line": 489,
      "content_hash": "c570a6651a4b4c8bef97fce791c64a1ff928187e",
      "content": "func (c *Config) GetModelByType(modelType SelectedModelType) *catwalk.Model {\n\tmodel, ok := c.Models[modelType]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn c.GetModel(model.Provider, model.Model)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_LargeModel_490": {
      "name": "LargeModel",
      "type": "method",
      "start_line": 490,
      "end_line": 497,
      "content_hash": "b1dcad64c102561dfbc531d9f2aa8ad2885733da",
      "content": "func (c *Config) LargeModel() *catwalk.Model {\n\tmodel, ok := c.Models[SelectedModelTypeLarge]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn c.GetModel(model.Provider, model.Model)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SmallModel_498": {
      "name": "SmallModel",
      "type": "method",
      "start_line": 498,
      "end_line": 505,
      "content_hash": "c3deacc122aa63fd805ff4b44e05eb964a05cbcb",
      "content": "func (c *Config) SmallModel() *catwalk.Model {\n\tmodel, ok := c.Models[SelectedModelTypeSmall]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn c.GetModel(model.Provider, model.Model)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetCompactMode_506": {
      "name": "SetCompactMode",
      "type": "method",
      "start_line": 506,
      "end_line": 513,
      "content_hash": "5d21ada649ffa0ac035d1f152cfe635de2d08924",
      "content": "func (c *Config) SetCompactMode(enabled bool) error {\n\tif c.Options == nil {\n\t\tc.Options = &Options{}\n\t}\n\tc.Options.TUI.CompactMode = enabled\n\treturn c.SetConfigField(\"options.tui.compact_mode\", enabled)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Resolve_514": {
      "name": "Resolve",
      "type": "method",
      "start_line": 514,
      "end_line": 520,
      "content_hash": "6c1ecc52f8b280f2fefe167f0e83b89f85caf4be",
      "content": "func (c *Config) Resolve(key string) (string, error) {\n\tif c.resolver == nil {\n\t\treturn \"\", fmt.Errorf(\"no variable resolver configured\")\n\t}\n\treturn c.resolver.ResolveValue(key)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_UpdatePreferredModel_521": {
      "name": "UpdatePreferredModel",
      "type": "method",
      "start_line": 521,
      "end_line": 531,
      "content_hash": "964d2cf523ba4eaf44da8727973f4c5df5c7daf6",
      "content": "func (c *Config) UpdatePreferredModel(modelType SelectedModelType, model SelectedModel) error {\n\tc.Models[modelType] = model\n\tif err := c.SetConfigField(fmt.Sprintf(\"models.%s\", modelType), model); err != nil {\n\t\treturn fmt.Errorf(\"failed to update preferred model: %w\", err)\n\t}\n\tif err := c.recordRecentModel(modelType, model); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetConfigField_532": {
      "name": "SetConfigField",
      "type": "method",
      "start_line": 532,
      "end_line": 552,
      "content_hash": "38e39cfdf309cd15a73a0af4b1400f0eef4a94eb",
      "content": "func (c *Config) SetConfigField(key string, value any) error {\n\t// read the data\n\tdata, err := os.ReadFile(c.dataConfigDir)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tdata = []byte(\"{}\")\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"failed to read config file: %w\", err)\n\t\t}\n\t}\n\n\tnewValue, err := sjson.Set(string(data), key, value)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set config field %s: %w\", key, err)\n\t}\n\tif err := os.WriteFile(c.dataConfigDir, []byte(newValue), 0o600); err != nil {\n\t\treturn fmt.Errorf(\"failed to write config file: %w\", err)\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RefreshOAuthToken_553": {
      "name": "RefreshOAuthToken",
      "type": "method",
      "start_line": 553,
      "end_line": 589,
      "content_hash": "f89057377952ebfd4146496c9eeb01bde26200a1",
      "content": "func (c *Config) RefreshOAuthToken(ctx context.Context, providerID string) error {\n\tproviderConfig, exists := c.Providers.Get(providerID)\n\tif !exists {\n\t\treturn fmt.Errorf(\"provider %s not found\", providerID)\n\t}\n\n\tif providerConfig.OAuthToken == nil {\n\t\treturn fmt.Errorf(\"provider %s does not have an OAuth token\", providerID)\n\t}\n\n\t// Only Anthropic provider uses OAuth for now\n\tif providerID != string(catwalk.InferenceProviderAnthropic) {\n\t\treturn fmt.Errorf(\"OAuth refresh not supported for provider %s\", providerID)\n\t}\n\n\tnewToken, err := claude.RefreshToken(ctx, providerConfig.OAuthToken.RefreshToken)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh OAuth token for provider %s: %w\", providerID, err)\n\t}\n\n\tslog.Info(\"Successfully refreshed OAuth token in background\", \"provider\", providerID)\n\tproviderConfig.OAuthToken = newToken\n\tproviderConfig.APIKey = fmt.Sprintf(\"Bearer %s\", newToken.AccessToken)\n\tproviderConfig.SetupClaudeCode()\n\n\tc.Providers.Set(providerID, providerConfig)\n\n\tif err := cmp.Or(\n\t\tc.SetConfigField(fmt.Sprintf(\"providers.%s.api_key\", providerID), newToken.AccessToken),\n\t\tc.SetConfigField(fmt.Sprintf(\"providers.%s.oauth\", providerID), newToken),\n\t); err != nil {\n\t\treturn fmt.Errorf(\"failed to persist refreshed token: %w\", err)\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetProviderAPIKey_590": {
      "name": "SetProviderAPIKey",
      "type": "method",
      "start_line": 590,
      "end_line": 655,
      "content_hash": "63554a073e369dcd0ce12224c693297246cb9b9f",
      "content": "func (c *Config) SetProviderAPIKey(providerID string, apiKey any) error {\n\tvar providerConfig ProviderConfig\n\tvar exists bool\n\tvar setKeyOrToken func()\n\n\tswitch v := apiKey.(type) {\n\tcase string:\n\t\tif err := c.SetConfigField(fmt.Sprintf(\"providers.%s.api_key\", providerID), v); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save api key to config file: %w\", err)\n\t\t}\n\t\tsetKeyOrToken = func() { providerConfig.APIKey = v }\n\tcase *oauth.Token:\n\t\tif err := cmp.Or(\n\t\t\tc.SetConfigField(fmt.Sprintf(\"providers.%s.api_key\", providerID), v.AccessToken),\n\t\t\tc.SetConfigField(fmt.Sprintf(\"providers.%s.oauth\", providerID), v),\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsetKeyOrToken = func() {\n\t\t\tproviderConfig.APIKey = v.AccessToken\n\t\t\tproviderConfig.OAuthToken = v\n\t\t\tproviderConfig.SetupClaudeCode()\n\t\t}\n\t}\n\n\tproviderConfig, exists = c.Providers.Get(providerID)\n\tif exists {\n\t\tsetKeyOrToken()\n\t\tc.Providers.Set(providerID, providerConfig)\n\t\treturn nil\n\t}\n\n\tvar foundProvider *catwalk.Provider\n\tfor _, p := range c.knownProviders {\n\t\tif string(p.ID) == providerID {\n\t\t\tfoundProvider = &p\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif foundProvider != nil {\n\t\t// Create new provider config based on known provider\n\t\tproviderConfig = ProviderConfig{\n\t\t\tID:           providerID,\n\t\t\tName:         foundProvider.Name,\n\t\t\tBaseURL:      foundProvider.APIEndpoint,\n\t\t\tType:         foundProvider.Type,\n\t\t\tDisable:      false,\n\t\t\tExtraHeaders: make(map[string]string),\n\t\t\tExtraParams:  make(map[string]string),\n\t\t\tModels:       foundProvider.Models,\n\t\t}\n\t\tsetKeyOrToken()\n\t} else {\n\t\treturn fmt.Errorf(\"provider with ID %s not found in known providers\", providerID)\n\t}\n\t// Store the updated provider config\n\tc.Providers.Set(providerID, providerConfig)\n\treturn nil\n}\n\nconst maxRecentModelsPerType = 5\n\n// ValidateAndFallbackModels attempts to validate the current models and falls back to\n// recent models if they are invalid. Returns true if models are valid or fallback succeeded,\n// false if all attempts failed.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ValidateAndFallbackModels_656": {
      "name": "ValidateAndFallbackModels",
      "type": "method",
      "start_line": 656,
      "end_line": 679,
      "content_hash": "6ca897909083e9634b5f68c846a6663cf8b22a4c",
      "content": "func (c *Config) ValidateAndFallbackModels() (bool, error) {\n\tif !c.AreModelsConfigured() {\n\t\treturn false, nil\n\t}\n\n\t// Validate current models\n\tlargeValid, err := c.validateModel(SelectedModelTypeLarge)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tsmallValid, err := c.validateModel(SelectedModelTypeSmall)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif largeValid && smallValid {\n\t\treturn true, nil // Current models are valid\n\t}\n\n\t// Try recent models fallback\n\treturn c.tryRecentModelsFallback()\n}\n\n// validateModel checks if a specific model type is valid",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_validateModel_680": {
      "name": "validateModel",
      "type": "method",
      "start_line": 680,
      "end_line": 705,
      "content_hash": "4478a77311e937d4f04da1c6834be13f92937272",
      "content": "func (c *Config) validateModel(modelType SelectedModelType) (bool, error) {\n\tmodel, ok := c.Models[modelType]\n\tif !ok {\n\t\treturn false, nil // Model not selected\n\t}\n\n\t// Check if provider exists\n\t_, providerExists := c.Providers.Get(model.Provider)\n\tif !providerExists {\n\t\treturn false, nil // Provider not configured\n\t}\n\n\t// Check if model exists in provider config first\n\tif providerConfig, ok := c.Providers.Get(model.Provider); ok {\n\t\tfor _, m := range providerConfig.Models {\n\t\t\tif m.ID == model.Model {\n\t\t\t\treturn true, nil // Found in provider config\n\t\t\t}\n\t\t}\n\t}\n\n\t// Model not found in provider config, so it's invalid\n\treturn false, nil\n}\n\n// tryRecentModelsFallback attempts to fallback to recent models if current models are invalid",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tryRecentModelsFallback_706": {
      "name": "tryRecentModelsFallback",
      "type": "method",
      "start_line": 706,
      "end_line": 745,
      "content_hash": "c2aa69275c889dec812cf5b5f0b77aedf48a6970",
      "content": "func (c *Config) tryRecentModelsFallback() (bool, error) {\n\tif c.RecentModels == nil {\n\t\treturn false, nil // No recent models to try\n\t}\n\n\t// Try recent models for large model\n\tsuccess := false\n\tif recentLarge, exists := c.RecentModels[SelectedModelTypeLarge]; exists && len(recentLarge) > 0 {\n\t\tfor _, recentModel := range recentLarge {\n\t\t\tif c.isValidRecentModel(SelectedModelTypeLarge, recentModel) {\n\t\t\t\tc.Models[SelectedModelTypeLarge] = recentModel\n\t\t\t\tif err := c.SetConfigField(fmt.Sprintf(\"models.%s\", SelectedModelTypeLarge), recentModel); err != nil {\n\t\t\t\t\treturn false, fmt.Errorf(\"failed to update fallback large model: %w\", err)\n\t\t\t\t}\n\t\t\t\tsuccess = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Try recent models for small model\n\tsmallSuccess := false\n\tif recentSmall, exists := c.RecentModels[SelectedModelTypeSmall]; exists && len(recentSmall) > 0 {\n\t\tfor _, recentModel := range recentSmall {\n\t\t\tif c.isValidRecentModel(SelectedModelTypeSmall, recentModel) {\n\t\t\t\tc.Models[SelectedModelTypeSmall] = recentModel\n\t\t\t\tif err := c.SetConfigField(fmt.Sprintf(\"models.%s\", SelectedModelTypeSmall), recentModel); err != nil {\n\t\t\t\t\treturn false, fmt.Errorf(\"failed to update fallback small model: %w\", err)\n\t\t\t\t}\n\t\t\t\tsmallSuccess = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return true if at least one model was successfully restored\n\treturn success || smallSuccess, nil\n}\n\n// isValidRecentModel checks if a recent model is valid and can be used as fallback",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isValidRecentModel_746": {
      "name": "isValidRecentModel",
      "type": "method",
      "start_line": 746,
      "end_line": 770,
      "content_hash": "12abd62ed6e71c0d5b795bd167a76df87eb98ead",
      "content": "func (c *Config) isValidRecentModel(modelType SelectedModelType, model SelectedModel) bool {\n\tif model.Provider == \"\" || model.Model == \"\" {\n\t\treturn false\n\t}\n\n\t// Check if provider exists\n\t_, providerExists := c.Providers.Get(model.Provider)\n\tif !providerExists {\n\t\treturn false\n\t}\n\n\t// Check if model exists in provider config\n\tif providerConfig, ok := c.Providers.Get(model.Provider); ok {\n\t\tfor _, m := range providerConfig.Models {\n\t\t\tif m.ID == model.Model {\n\t\t\t\treturn true // Found in provider config\n\t\t\t}\n\t\t}\n\t}\n\n\t// Model not found, so it's invalid\n\treturn false\n}\n\n// RepairConfig attempts to repair configuration issues",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RepairConfig_771": {
      "name": "RepairConfig",
      "type": "method",
      "start_line": 771,
      "end_line": 792,
      "content_hash": "fc21a7b02fcdc382d1b098d6e7f97690b75e8b1b",
      "content": "func (c *Config) RepairConfig() error {\n\t// Clean up invalid recent models\n\tif c.RecentModels != nil {\n\t\tfor modelType, recentModels := range c.RecentModels {\n\t\t\tvalidModels := []SelectedModel{}\n\t\t\tfor _, model := range recentModels {\n\t\t\t\tif c.isValidRecentModel(modelType, model) {\n\t\t\t\t\tvalidModels = append(validModels, model)\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.RecentModels[modelType] = validModels\n\t\t\tif err := c.SetConfigField(fmt.Sprintf(\"recent_models.%s\", modelType), validModels); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to repair recent models: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Try one more time to validate and fallback models after cleanup\n\t_, err := c.ValidateAndFallbackModels()\n\treturn err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_recordRecentModel_793": {
      "name": "recordRecentModel",
      "type": "method",
      "start_line": 793,
      "end_line": 833,
      "content_hash": "ad8e378b7be1fb6be7f25a08d22015d0def56764",
      "content": "func (c *Config) recordRecentModel(modelType SelectedModelType, model SelectedModel) error {\n\tif model.Provider == \"\" || model.Model == \"\" {\n\t\treturn nil\n\t}\n\n\tif c.RecentModels == nil {\n\t\tc.RecentModels = make(map[SelectedModelType][]SelectedModel)\n\t}\n\n\teq := func(a, b SelectedModel) bool {\n\t\treturn a.Provider == b.Provider && a.Model == b.Model\n\t}\n\n\tentry := SelectedModel{\n\t\tProvider: model.Provider,\n\t\tModel:    model.Model,\n\t}\n\n\tcurrent := c.RecentModels[modelType]\n\twithoutCurrent := slices.DeleteFunc(slices.Clone(current), func(existing SelectedModel) bool {\n\t\treturn eq(existing, entry)\n\t})\n\n\tupdated := append([]SelectedModel{entry}, withoutCurrent...)\n\tif len(updated) > maxRecentModelsPerType {\n\t\tupdated = updated[:maxRecentModelsPerType]\n\t}\n\n\tif slices.EqualFunc(current, updated, eq) {\n\t\treturn nil\n\t}\n\n\tc.RecentModels[modelType] = updated\n\n\tif err := c.SetConfigField(fmt.Sprintf(\"recent_models.%s\", modelType), updated); err != nil {\n\t\treturn fmt.Errorf(\"failed to persist recent models: %w\", err)\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_allToolNames_834": {
      "name": "allToolNames",
      "type": "function",
      "start_line": 834,
      "end_line": 855,
      "content_hash": "b336ec5949e4985a10d25084c3886e8eb285c9c5",
      "content": "func allToolNames() []string {\n\treturn []string{\n\t\t\"agent\",\n\t\t\"bash\",\n\t\t\"job_output\",\n\t\t\"job_kill\",\n\t\t\"download\",\n\t\t\"edit\",\n\t\t\"multiedit\",\n\t\t\"lsp_diagnostics\",\n\t\t\"lsp_references\",\n\t\t\"fetch\",\n\t\t\"agentic_fetch\",\n\t\t\"glob\",\n\t\t\"grep\",\n\t\t\"ls\",\n\t\t\"sourcegraph\",\n\t\t\"view\",\n\t\t\"write\",\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveAllowedTools_856": {
      "name": "resolveAllowedTools",
      "type": "function",
      "start_line": 856,
      "end_line": 863,
      "content_hash": "75c1bc1726cfde679520ea192c0cffc21eeff0c8",
      "content": "func resolveAllowedTools(allTools []string, disabledTools []string) []string {\n\tif disabledTools == nil {\n\t\treturn allTools\n\t}\n\t// filter out disabled tools (exclude mode)\n\treturn filterSlice(allTools, disabledTools, false)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveReadOnlyTools_864": {
      "name": "resolveReadOnlyTools",
      "type": "function",
      "start_line": 864,
      "end_line": 869,
      "content_hash": "89c495b62fdee7872e31dce1c1773da9cfc3912a",
      "content": "func resolveReadOnlyTools(tools []string) []string {\n\treadOnlyTools := []string{\"glob\", \"grep\", \"ls\", \"sourcegraph\", \"view\"}\n\t// filter to only include tools that are in allowedtools (include mode)\n\treturn filterSlice(tools, readOnlyTools, true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_filterSlice_870": {
      "name": "filterSlice",
      "type": "function",
      "start_line": 870,
      "end_line": 881,
      "content_hash": "dd9adbe2af392e8cf2a0c6b3a56dd485123f5894",
      "content": "func filterSlice(data []string, mask []string, include bool) []string {\n\tfiltered := []string{}\n\tfor _, s := range data {\n\t\t// if include is true, we include items that ARE in the mask\n\t\t// if include is false, we include items that are NOT in the mask\n\t\tif include == slices.Contains(mask, s) {\n\t\t\tfiltered = append(filtered, s)\n\t\t}\n\t}\n\treturn filtered\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetupAgents_882": {
      "name": "SetupAgents",
      "type": "method",
      "start_line": 882,
      "end_line": 908,
      "content_hash": "c4f117926b99ba391e7a20554620747aa07899a1",
      "content": "func (c *Config) SetupAgents() {\n\tallowedTools := resolveAllowedTools(allToolNames(), c.Options.DisabledTools)\n\n\tagents := map[string]Agent{\n\t\tAgentCoder: {\n\t\t\tID:           AgentCoder,\n\t\t\tName:         \"Coder\",\n\t\t\tDescription:  \"An agent that helps with executing coding tasks.\",\n\t\t\tModel:        SelectedModelTypeLarge,\n\t\t\tContextPaths: c.Options.ContextPaths,\n\t\t\tAllowedTools: allowedTools,\n\t\t},\n\n\t\tAgentTask: {\n\t\t\tID:           AgentTask,\n\t\t\tName:         \"Task\",\n\t\t\tDescription:  \"An agent that helps with searching for context and finding implementation details.\",\n\t\t\tModel:        SelectedModelTypeLarge,\n\t\t\tContextPaths: c.Options.ContextPaths,\n\t\t\tAllowedTools: resolveReadOnlyTools(allowedTools),\n\t\t\t// NO MCPs or LSPs by default\n\t\t\tAllowedMCP: map[string][]string{},\n\t\t},\n\t}\n\tc.Agents = agents\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Resolver_909": {
      "name": "Resolver",
      "type": "method",
      "start_line": 909,
      "end_line": 912,
      "content_hash": "723fd1a14536006b5d7e33fd47be154160f757d1",
      "content": "func (c *Config) Resolver() VariableResolver {\n\treturn c.resolver\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_TestConnection_913": {
      "name": "TestConnection",
      "type": "method",
      "start_line": 913,
      "end_line": 980,
      "content_hash": "09bf312795f6e0b6e335b0698bef50c109d901a0",
      "content": "func (c *ProviderConfig) TestConnection(resolver VariableResolver) error {\n\ttestURL := \"\"\n\theaders := make(map[string]string)\n\tapiKey, _ := resolver.ResolveValue(c.APIKey)\n\tswitch c.Type {\n\tcase catwalk.TypeOpenAI, catwalk.TypeOpenAICompat, catwalk.TypeOpenRouter:\n\t\tbaseURL, _ := resolver.ResolveValue(c.BaseURL)\n\t\tif baseURL == \"\" {\n\t\t\tbaseURL = \"https://api.openai.com/v1\"\n\t\t}\n\t\tif c.ID == string(catwalk.InferenceProviderOpenRouter) {\n\t\t\ttestURL = baseURL + \"/credits\"\n\t\t} else {\n\t\t\ttestURL = baseURL + \"/models\"\n\t\t}\n\t\theaders[\"Authorization\"] = \"Bearer \" + apiKey\n\tcase catwalk.TypeAnthropic:\n\t\tbaseURL, _ := resolver.ResolveValue(c.BaseURL)\n\t\tif baseURL == \"\" {\n\t\t\tbaseURL = \"https://api.anthropic.com/v1\"\n\t\t}\n\t\ttestURL = baseURL + \"/models\"\n\t\t// Provider-specific endpoint handling\n\t\t// When catwalk library releases constants, replace hardcoded version with:\n\t\t// const KimiCodingAPIPath = \"/v1/models\"\n\t\t// This will improve maintainability and consistency\n\t\tif c.ID == \"kimi-coding\" {\n\t\t\ttestURL = baseURL + \"/v1/models\"\n\t\t}\n\t\t// MiniMax uses Authorization header\n\t\tif c.ID == \"minimax\" {\n\t\t\theaders[\"Authorization\"] = \"Bearer \" + apiKey\n\t\t\ttestURL = baseURL + \"/v1/models\" // MiniMax uses /v1/models for testing\n\t\t} else {\n\t\t\theaders[\"x-api-key\"] = apiKey\n\t\t}\n\t\theaders[\"anthropic-version\"] = \"2023-06-01\"\n\tcase catwalk.TypeGoogle:\n\t\tbaseURL, _ := resolver.ResolveValue(c.BaseURL)\n\t\tif baseURL == \"\" {\n\t\t\tbaseURL = \"https://generativelanguage.googleapis.com\"\n\t\t}\n\t\ttestURL = baseURL + \"/v1beta/models?key=\" + url.QueryEscape(apiKey)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tclient := &http.Client{}\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", testURL, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create request for provider %s: %w\", c.ID, err)\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\tfor k, v := range c.ExtraHeaders {\n\t\treq.Header.Set(k, v)\n\t}\n\tb, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create request for provider %s: %w\", c.ID, err)\n\t}\n\tif b.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to connect to provider %s: %s\", c.ID, b.Status)\n\t}\n\t_ = b.Body.Close()\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveEnvs_981": {
      "name": "resolveEnvs",
      "type": "function",
      "start_line": 981,
      "end_line": 1004,
      "content_hash": "1e3f3c19c5eeb7d81705c0fd7582b24c85cf1fb4",
      "content": "func resolveEnvs(envs map[string]string) []string {\n\tresolver := NewShellVariableResolver(env.New())\n\tfor e, v := range envs {\n\t\tvar err error\n\t\tenvs[e], err = resolver.ResolveValue(v)\n\t\tif err != nil {\n\t\t\tslog.Error(\"error resolving environment variable\", \"error\", err, \"variable\", e, \"value\", v)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tres := make([]string, 0, len(envs))\n\tfor k, v := range envs {\n\t\tres = append(res, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\treturn res\n}\n\nfunc ptrValOr[T any](t *T, el T) T {\n\tif t == nil {\n\t\treturn el\n\t}\n\treturn *t\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}