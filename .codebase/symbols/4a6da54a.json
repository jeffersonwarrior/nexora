{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/date.rs",
  "file_hash": "b1818c3e50b88dfa836d1c17aba6c921221fe3a2",
  "updated_at": "2025-12-26T17:34:22.587086",
  "symbols": {
    "struct_Date_18": {
      "name": "Date",
      "type": "struct",
      "start_line": 18,
      "end_line": 18,
      "content_hash": "93c3bf9b2a7547ba1608679f45a54b19703de0e0",
      "content": "pub struct Date(DateTime<Utc>);",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Date_19": {
      "name": "Date",
      "type": "impl",
      "start_line": 19,
      "end_line": 19,
      "content_hash": "6f4cae86c8a391af78bbd0010aba7bef7f108424",
      "content": "impl Date {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inner_20": {
      "name": "inner",
      "type": "method",
      "start_line": 20,
      "end_line": 24,
      "content_hash": "158925247ee65bfdde6c70c9d5786a75d96b8ba3",
      "content": "    pub fn inner(&self) -> &DateTime<Utc> {\n        &self.0\n    }\n\n    /// Converts the Date to an RFC3339 string.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_rfc3339_25": {
      "name": "to_rfc3339",
      "type": "method",
      "start_line": 25,
      "end_line": 29,
      "content_hash": "4bed4dc2d29b11b9c0c770828c318cec1089ac71",
      "content": "    pub fn to_rfc3339(&self) -> String {\n        self.0.to_rfc3339()\n    }\n\n    /// Creates a new Date from a Value.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_30": {
      "name": "new",
      "type": "method",
      "start_line": 30,
      "end_line": 77,
      "content_hash": "c6baca118de5959e8425e42c73b28130d54161c8",
      "content": "    pub fn new(date: &Value) -> Result<Self, DateError> {\n        match date {\n            Value::String(date) => {\n                let date = match date.parse::<DateTime<Utc>>() {\n                    Ok(date) => date.with_timezone(&Utc),\n                    Err(e) => match date.parse::<NaiveDate>() {\n                        Ok(date) => match date.and_hms_opt(0, 0, 0) {\n                            Some(date) => date.and_utc(),\n                            None => {\n                                return Err(DateError::ParseError(e.to_string()));\n                            }\n                        },\n                        Err(e) => {\n                            return Err(DateError::ParseError(e.to_string()));\n                        }\n                    },\n                };\n                Ok(Date(date))\n            }\n            Value::I64(date) => {\n                let date = match DateTime::from_timestamp(*date, 0) {\n                    Some(date) => date,\n                    None => {\n                        return Err(DateError::ParseError(\n                            \"Date must be a valid date\".to_string(),\n                        ));\n                    }\n                };\n                Ok(Date(date))\n            }\n            Value::U64(date) => {\n                let date = match DateTime::from_timestamp(*date as i64, 0) {\n                    Some(date) => date,\n                    None => {\n                        return Err(DateError::ParseError(\n                            \"Date must be a valid date\".to_string(),\n                        ));\n                    }\n                };\n                Ok(Date(date))\n            }\n            _ => Err(DateError::ParseError(\n                \"Date must be a valid date\".to_string(),\n            )),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_DateVisitor_78": {
      "name": "DateVisitor",
      "type": "struct",
      "start_line": 78,
      "end_line": 79,
      "content_hash": "79f363fce8a7515b2264aa133f59aec8376bf403",
      "content": "struct DateVisitor;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Visitor_80": {
      "name": "Visitor",
      "type": "impl",
      "start_line": 80,
      "end_line": 82,
      "content_hash": "ffe4e0f697a1541a910b0774b117c5b39ebc9c84",
      "content": "impl<'de> Visitor<'de> for DateVisitor {\n    type Value = Date;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expecting_83": {
      "name": "expecting",
      "type": "method",
      "start_line": 83,
      "end_line": 131,
      "content_hash": "a1b91dd4403affae7099eb27cb77316fdd230115",
      "content": "    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a valid Date\")\n    }\n\n    /// Visits a string and parses it into a chrono DateTime<Utc>.\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: serde::de::Error,\n    {\n        let date = match v.parse::<DateTime<Utc>>() {\n            Ok(date) => date.with_timezone(&Utc),\n            Err(e) => match v.parse::<NaiveDate>() {\n                Ok(date) => match date.and_hms_opt(0, 0, 0) {\n                    Some(date) => date.and_utc(),\n                    None => {\n                        return Err(E::custom(e.to_string()));\n                    }\n                },\n                Err(e) => {\n                    return Err(E::custom(e.to_string()));\n                }\n            },\n        };\n        Ok(Date(date))\n    }\n\n    /// Visits a i64 and parses it into a chrono DateTime<Utc>.\n    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n    where\n        E: serde::de::Error,\n    {\n        Ok(Date(match DateTime::from_timestamp(v, 0) {\n            Some(date) => date,\n            None => return Err(E::custom(\"Date must be a valid date\".to_string())),\n        }))\n    }\n\n    /// Visits a u64 and parses it into a chrono DateTime<Utc>.\n    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n    where\n        E: serde::de::Error,\n    {\n        Ok(Date(match DateTime::from_timestamp(v as i64, 0) {\n            Some(date) => date,\n            None => return Err(E::custom(\"Date must be a valid date\".to_string())),\n        }))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deserialize_132": {
      "name": "Deserialize",
      "type": "impl",
      "start_line": 132,
      "end_line": 140,
      "content_hash": "2514156cba0dc8424795ba7db8cdbf8626ac6333",
      "content": "impl<'de> Deserialize<'de> for Date {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_any(DateVisitor)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_141": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 141,
      "end_line": 150,
      "content_hash": "8952e32742dfc4ed6919b8a7558bdbd93e9f2571",
      "content": "impl Serialize for Date {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        serializer.serialize_str(&self.to_rfc3339())\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_DateError_151": {
      "name": "DateError",
      "type": "enum",
      "start_line": 151,
      "end_line": 154,
      "content_hash": "fa4c97f7c7913d5cee930d8a2a6ed309e9dc90bf",
      "content": "pub enum DateError {\n    ParseError(String),\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_fmt::Display_155": {
      "name": "fmt::Display",
      "type": "impl",
      "start_line": 155,
      "end_line": 155,
      "content_hash": "26fd748573d192125bfc8c93ca6389eb1d421df0",
      "content": "impl fmt::Display for DateError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_156": {
      "name": "fmt",
      "type": "method",
      "start_line": 156,
      "end_line": 162,
      "content_hash": "6d2e89a971934da4a5c0a329923c93833cb7932a",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            DateError::ParseError(error) => write!(f, \"{error}\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deref_163": {
      "name": "Deref",
      "type": "impl",
      "start_line": 163,
      "end_line": 165,
      "content_hash": "8207805c92fa3f7816e13e5e801d0839d3104836",
      "content": "impl Deref for Date {\n    type Target = DateTime<Utc>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_deref_166": {
      "name": "deref",
      "type": "method",
      "start_line": 166,
      "end_line": 175,
      "content_hash": "a5c9478ecc2a0934ec756dbc9102b1d4355f63d2",
      "content": "    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_naive_date_serialization_176": {
      "name": "test_naive_date_serialization",
      "type": "method",
      "start_line": 176,
      "end_line": 182,
      "content_hash": "f160ecbc4c2aaa75c8c542840602c94cb4437524",
      "content": "    fn test_naive_date_serialization() {\n        let date = Date::new(&Value::String(\"2021-01-01\".to_string())).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        assert_eq!(serialized, \"\\\"2021-01-01T00:00:00+00:00\\\"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_naive_date_deserialization_183": {
      "name": "test_naive_date_deserialization",
      "type": "method",
      "start_line": 183,
      "end_line": 190,
      "content_hash": "01a1a868ffa49bd608f743969ea2c93cf313f1e1",
      "content": "    fn test_naive_date_deserialization() {\n        let date = Date::new(&Value::String(\"2021-01-01\".to_string())).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        let deserialized: Date = sonic_rs::from_str(&serialized).unwrap();\n        assert_eq!(deserialized, date);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_timestamp_serialization_191": {
      "name": "test_timestamp_serialization",
      "type": "method",
      "start_line": 191,
      "end_line": 197,
      "content_hash": "2b8685e3a3e1671ef5e3e9a84d435bbf1e5bbdba",
      "content": "    fn test_timestamp_serialization() {\n        let date = Date::new(&Value::I64(1609459200)).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        assert_eq!(serialized, \"\\\"2021-01-01T00:00:00+00:00\\\"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_timestamp_deserialization_198": {
      "name": "test_timestamp_deserialization",
      "type": "method",
      "start_line": 198,
      "end_line": 205,
      "content_hash": "b41e5ba259658cad2919d35bc8882a950dc440e5",
      "content": "    fn test_timestamp_deserialization() {\n        let date = Date::new(&Value::I64(1609459200)).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        let deserialized: Date = sonic_rs::from_str(&serialized).unwrap();\n        assert_eq!(deserialized, date);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rfc3339_serialization_206": {
      "name": "test_rfc3339_serialization",
      "type": "method",
      "start_line": 206,
      "end_line": 212,
      "content_hash": "4e1008d4d844aaa874ce5983c70672f51ad10f29",
      "content": "    fn test_rfc3339_serialization() {\n        let date = Date::new(&Value::String(\"2021-01-01T00:00:00Z\".to_string())).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        assert_eq!(serialized, \"\\\"2021-01-01T00:00:00+00:00\\\"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rfc3339_deserialization_213": {
      "name": "test_rfc3339_deserialization",
      "type": "method",
      "start_line": 213,
      "end_line": 219,
      "content_hash": "26e6b74ced231a0ad817218380b3f6240a02852b",
      "content": "    fn test_rfc3339_deserialization() {\n        let date = Date::new(&Value::String(\"2021-01-01T00:00:00Z\".to_string())).unwrap();\n        let serialized = sonic_rs::to_string(&date).unwrap();\n        let deserialized: Date = sonic_rs::from_str(&serialized).unwrap();\n        assert_eq!(deserialized, date);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}