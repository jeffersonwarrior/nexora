{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/value.rs",
  "file_hash": "2c47ea548af2af7e1edd157c7d417a6b03d20e31",
  "updated_at": "2025-12-26T17:34:20.839331",
  "symbols": {
    "enum_Value_21": {
      "name": "Value",
      "type": "enum",
      "start_line": 21,
      "end_line": 42,
      "content_hash": "293c0e44112fc07f42021fd9f93e4bee5417a513",
      "content": "pub enum Value {\n    String(String),\n    F32(f32),\n    F64(f64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    U128(u128),\n    Date(Date),\n    Boolean(bool),\n    Id(ID),\n    Array(Vec<Value>),\n    Object(HashMap<String, Value>),\n    #[default]\n    Empty,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Value_43": {
      "name": "Value",
      "type": "impl",
      "start_line": 43,
      "end_line": 43,
      "content_hash": "b01873d78000a8c96a21bb06945f84fa553eb427",
      "content": "impl Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inner_stringify_44": {
      "name": "inner_stringify",
      "type": "method",
      "start_line": 44,
      "end_line": 74,
      "content_hash": "3068f9f849dc5aa231c090b5f2fcb73d0fecee33",
      "content": "    pub fn inner_stringify(&self) -> String {\n        match self {\n            Value::String(s) => s.to_string(),\n            Value::F32(f) => f.to_string(),\n            Value::F64(f) => f.to_string(),\n            Value::I8(i) => i.to_string(),\n            Value::I16(i) => i.to_string(),\n            Value::I32(i) => i.to_string(),\n            Value::I64(i) => i.to_string(),\n            Value::U8(u) => u.to_string(),\n            Value::U16(u) => u.to_string(),\n            Value::U32(u) => u.to_string(),\n            Value::U64(u) => u.to_string(),\n            Value::U128(u) => u.to_string(),\n            Value::Date(d) => d.to_string(),\n            Value::Boolean(b) => b.to_string(),\n            Value::Id(id) => id.stringify(),\n            Value::Array(arr) => arr\n                .iter()\n                .map(|v| v.inner_stringify())\n                .collect::<Vec<String>>()\n                .join(\" \"),\n            Value::Object(obj) => obj\n                .iter()\n                .map(|(k, v)| format!(\"{k} {}\", v.inner_stringify()))\n                .collect::<Vec<String>>()\n                .join(\" \"),\n            _ => panic!(\"Not primitive\"),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inner_str_75": {
      "name": "inner_str",
      "type": "method",
      "start_line": 75,
      "end_line": 95,
      "content_hash": "0858108b89a9d4dc4ba245385015711c6bfdaad4",
      "content": "    pub fn inner_str(&self) -> Cow<'_, str> {\n        match self {\n            Value::String(s) => Cow::Borrowed(s.as_str()),\n            Value::F32(f) => Cow::Owned(f.to_string()),\n            Value::F64(f) => Cow::Owned(f.to_string()),\n            Value::I8(i) => Cow::Owned(i.to_string()),\n            Value::I16(i) => Cow::Owned(i.to_string()),\n            Value::I32(i) => Cow::Owned(i.to_string()),\n            Value::I64(i) => Cow::Owned(i.to_string()),\n            Value::U8(u) => Cow::Owned(u.to_string()),\n            Value::U16(u) => Cow::Owned(u.to_string()),\n            Value::U32(u) => Cow::Owned(u.to_string()),\n            Value::U64(u) => Cow::Owned(u.to_string()),\n            Value::U128(u) => Cow::Owned(u.to_string()),\n            Value::Date(d) => Cow::Owned(d.to_string()),\n            Value::Id(id) => Cow::Owned(id.stringify()),\n            Value::Boolean(b) => Cow::Borrowed(if *b { \"true\" } else { \"false\" }),\n            _ => panic!(\"Not primitive\"),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_variant_string_96": {
      "name": "to_variant_string",
      "type": "method",
      "start_line": 96,
      "end_line": 118,
      "content_hash": "c0cb107df6c890bb18aad6a82d43b60574b7c23c",
      "content": "    pub fn to_variant_string(&self) -> &str {\n        match self {\n            Value::String(_) => \"String\",\n            Value::F32(_) => \"F32\",\n            Value::F64(_) => \"F64\",\n            Value::I8(_) => \"I8\",\n            Value::I16(_) => \"I16\",\n            Value::I32(_) => \"I32\",\n            Value::I64(_) => \"I64\",\n            Value::U8(_) => \"U8\",\n            Value::U16(_) => \"U16\",\n            Value::U32(_) => \"U32\",\n            Value::U64(_) => \"U64\",\n            Value::U128(_) => \"U128\",\n            Value::Date(_) => \"Date\",\n            Value::Boolean(_) => \"Boolean\",\n            Value::Id(_) => \"Id\",\n            Value::Array(_) => \"Array\",\n            Value::Object(_) => \"Object\",\n            Value::Empty => \"Empty\",\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_as_str_119": {
      "name": "as_str",
      "type": "method",
      "start_line": 119,
      "end_line": 127,
      "content_hash": "9132b4b93a0382ef17cef6864da144d15c1ac5d2",
      "content": "    pub fn as_str(&self) -> &str {\n        match self {\n            Value::String(s) => s.as_str(),\n            _ => panic!(\"Not a string\"),\n        }\n    }\n\n    /// Checks if this value contains the needle value (as strings).\n    /// Converts both values to their string representations and performs substring matching.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_contains_128": {
      "name": "contains",
      "type": "method",
      "start_line": 128,
      "end_line": 133,
      "content_hash": "6389ed98db0dfda34c655441a5fc1d681e019fdd",
      "content": "    pub fn contains(&self, needle: &str) -> bool {\n        self.inner_str().contains(needle)\n    }\n\n    #[inline]\n    #[allow(unused_variables)] // default is not used but needed for function signature",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_map_value_or_134": {
      "name": "map_value_or",
      "type": "method",
      "start_line": 134,
      "end_line": 151,
      "content_hash": "102b703f394d963c39349acacb2ee3648b88caeb",
      "content": "    pub fn map_value_or(\n        self,\n        default: bool,\n        f: impl Fn(&Value) -> bool,\n    ) -> Result<bool, GraphError> {\n        Ok(f(&self))\n    }\n\n    #[inline]\n    pub fn is_in<T>(&self, values: &[T]) -> bool\n    where\n        T: PartialEq,\n        Value: IntoPrimitive<T> + Into<T>,\n    {\n        values.contains(self.into_primitive())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_152": {
      "name": "Ord",
      "type": "impl",
      "start_line": 152,
      "end_line": 152,
      "content_hash": "9973cb786fd80722f30f4bf2cff4f52bc73623fe",
      "content": "impl Ord for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_153": {
      "name": "cmp",
      "type": "method",
      "start_line": 153,
      "end_line": 217,
      "content_hash": "0be0e7c8398b033d25194c497faec7b699f7f762",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        let to_i128 = |value: &Value| -> Option<i128> {\n            match value {\n                Value::I8(v) => Some(*v as i128),\n                Value::I16(v) => Some(*v as i128),\n                Value::I32(v) => Some(*v as i128),\n                Value::I64(v) => Some(*v as i128),\n                Value::U8(v) => Some(*v as i128),\n                Value::U16(v) => Some(*v as i128),\n                Value::U32(v) => Some(*v as i128),\n                Value::U64(v) => Some(*v as i128),\n                Value::U128(v) => {\n                    if *v <= i128::MAX as u128 {\n                        Some(*v as i128)\n                    } else {\n                        None\n                    }\n                }\n                _ => None,\n            }\n        };\n        let is_integer = |value: &Value| -> bool {\n            matches!(\n                value,\n                Value::I8(_)\n                    | Value::I16(_)\n                    | Value::I32(_)\n                    | Value::I64(_)\n                    | Value::U8(_)\n                    | Value::U16(_)\n                    | Value::U32(_)\n                    | Value::U64(_)\n                    | Value::U128(_)\n            )\n        };\n\n        match (self, other) {\n            (Value::String(s), Value::String(o)) => s.cmp(o),\n            (Value::F32(s), Value::F32(o)) => match s.partial_cmp(o) {\n                Some(o) => o,\n                None => Ordering::Equal,\n            },\n            (Value::F64(s), Value::F64(o)) => match s.partial_cmp(o) {\n                Some(o) => o,\n                None => Ordering::Equal,\n            },\n            (Value::Date(s), Value::Date(o)) => s.cmp(o),\n            (Value::Boolean(s), Value::Boolean(o)) => s.cmp(o),\n            (Value::Array(s), Value::Array(o)) => s.cmp(o),\n            (Value::Empty, Value::Empty) => Ordering::Equal,\n            (Value::Empty, _) => Ordering::Less,\n            (_, Value::Empty) => Ordering::Greater,\n            (s, o) if is_integer(s) && is_integer(o) => match (to_i128(s), to_i128(o)) {\n                (Some(s), Some(o)) => s.cmp(&o),\n                (None, Some(_)) => Ordering::Greater,\n                (Some(_), None) => Ordering::Less,\n                (None, None) => match (self, other) {\n                    (Value::U128(s), Value::U128(o)) => s.cmp(o),\n                    _ => unreachable!(),\n                },\n            },\n            (_, _) => Ordering::Equal,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_218": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 218,
      "end_line": 218,
      "content_hash": "8acbb7e63be118bf4e386f1b1693fd27775cdebe",
      "content": "impl PartialOrd for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_219": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 219,
      "end_line": 223,
      "content_hash": "0854185509a7f9c0a486be05a054ab4c3c192e2e",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_224": {
      "name": "Eq",
      "type": "impl",
      "start_line": 224,
      "end_line": 225,
      "content_hash": "80ce0d6add696e3fd2170dcba5797bdc1b7efdc1",
      "content": "impl Eq for Value {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_226": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 226,
      "end_line": 226,
      "content_hash": "f58497066c4dbe95f73b7407c3f3d72a08fef061",
      "content": "impl PartialEq<Value> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_227": {
      "name": "eq",
      "type": "method",
      "start_line": 227,
      "end_line": 288,
      "content_hash": "cda6bc5856a894ed4e01914557da79dafaa7e6aa",
      "content": "    fn eq(&self, other: &Value) -> bool {\n        let to_f64 = |value: &Value| -> Option<f64> {\n            match value {\n                Value::I8(v) => Some(*v as f64),\n                Value::I16(v) => Some(*v as f64),\n                Value::I32(v) => Some(*v as f64),\n                Value::I64(v) => Some(*v as f64),\n                Value::U8(v) => Some(*v as f64),\n                Value::U16(v) => Some(*v as f64),\n                Value::U32(v) => Some(*v as f64),\n                Value::U64(v) => Some(*v as f64),\n                Value::U128(v) => Some(*v as f64),\n                Value::F32(v) => Some(*v as f64),\n                Value::F64(v) => Some(*v),\n                _ => None,\n            }\n        };\n\n        let is_numeric = |value: &Value| -> bool {\n            matches!(\n                value,\n                Value::I8(_)\n                    | Value::I16(_)\n                    | Value::I32(_)\n                    | Value::I64(_)\n                    | Value::U8(_)\n                    | Value::U16(_)\n                    | Value::U32(_)\n                    | Value::U64(_)\n                    | Value::U128(_)\n                    | Value::F32(_)\n                    | Value::F64(_)\n            )\n        };\n\n        match (self, other) {\n            (Value::String(s), Value::String(o)) => s == o,\n            (Value::Date(s), Value::Date(o)) => s == o,\n            (Value::Boolean(s), Value::Boolean(o)) => s == o,\n            (Value::Array(s), Value::Array(o)) => s == o,\n            (Value::Empty, Value::Empty) => true,\n            (Value::Empty, _) => false,\n            (_, Value::Empty) => false,\n\n            (s, o) if is_numeric(s) && is_numeric(o) => match (to_f64(s), to_f64(o)) {\n                (Some(s_val), Some(o_val)) => {\n                    if !matches!(self, Value::F32(_) | Value::F64(_))\n                        && !matches!(other, Value::F32(_) | Value::F64(_))\n                    {\n                        self.cmp(other) == Ordering::Equal\n                    } else {\n                        s_val == o_val\n                    }\n                }\n                _ => false,\n            },\n\n            _ => false,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_289": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 289,
      "end_line": 289,
      "content_hash": "dd4b7f4b1eb613d29372bd12f2db8d46cd107135",
      "content": "impl PartialEq<ID> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_290": {
      "name": "eq",
      "type": "method",
      "start_line": 290,
      "end_line": 298,
      "content_hash": "dd413464e2d07966c6a6dba3378555f51fc1d301",
      "content": "    fn eq(&self, other: &ID) -> bool {\n        match self {\n            Value::Id(id) => id == other,\n            Value::String(s) => &ID::from(s) == other,\n            Value::U128(u) => &ID::from(*u) == other,\n            _ => false,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_299": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 299,
      "end_line": 299,
      "content_hash": "4a3fdf29aede985fa96bd8f26c2717c543df28b2",
      "content": "impl PartialEq<u8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_300": {
      "name": "eq",
      "type": "method",
      "start_line": 300,
      "end_line": 303,
      "content_hash": "296adddfada839b94aafd7911a64a734a3ff613f",
      "content": "    fn eq(&self, other: &u8) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_304": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 304,
      "end_line": 304,
      "content_hash": "4fbd7b7928872121ac0a9b7385a8c5cdf099bbdc",
      "content": "impl PartialEq<u16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_305": {
      "name": "eq",
      "type": "method",
      "start_line": 305,
      "end_line": 308,
      "content_hash": "f941a8b53411cc6d52f4a3e192b126737c2dee8f",
      "content": "    fn eq(&self, other: &u16) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_309": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 309,
      "end_line": 309,
      "content_hash": "aa22adfbe0d1b688770a5f3044da3c28a2486916",
      "content": "impl PartialEq<u32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_310": {
      "name": "eq",
      "type": "method",
      "start_line": 310,
      "end_line": 313,
      "content_hash": "3ee8b92e13e2ca2f0917701eda98af26b29d3a7f",
      "content": "    fn eq(&self, other: &u32) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_314": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 314,
      "end_line": 314,
      "content_hash": "1881b1ff65d16b075078f3295552b4f667c4024e",
      "content": "impl PartialEq<u64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_315": {
      "name": "eq",
      "type": "method",
      "start_line": 315,
      "end_line": 318,
      "content_hash": "5d5d25a6da8ba05c82e6d6266b4c18a8af860007",
      "content": "    fn eq(&self, other: &u64) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_319": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 319,
      "end_line": 319,
      "content_hash": "44a776d0961f01225e8efc2a2df4a3a6f2b7c4c0",
      "content": "impl PartialEq<u128> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_320": {
      "name": "eq",
      "type": "method",
      "start_line": 320,
      "end_line": 323,
      "content_hash": "f7c3eb1f05ea768083ca3f01a456d9ad87774ebe",
      "content": "    fn eq(&self, other: &u128) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_324": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 324,
      "end_line": 324,
      "content_hash": "13afc4c5e6cca2e4c0f958a27bed4644db4f3897",
      "content": "impl PartialEq<i8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_325": {
      "name": "eq",
      "type": "method",
      "start_line": 325,
      "end_line": 328,
      "content_hash": "cead5262241eee3e3455c55e3825c0f4d93ce265",
      "content": "    fn eq(&self, other: &i8) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_329": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 329,
      "end_line": 329,
      "content_hash": "e2a340d6787fe5a86de0088dd25e684e78641916",
      "content": "impl PartialEq<i16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_330": {
      "name": "eq",
      "type": "method",
      "start_line": 330,
      "end_line": 333,
      "content_hash": "52a61caa4eacaf35b1a42901d0657953ff0f1e55",
      "content": "    fn eq(&self, other: &i16) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_334": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 334,
      "end_line": 334,
      "content_hash": "5a590179578506620d51b76ecffa940076ef36b2",
      "content": "impl PartialEq<i32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_335": {
      "name": "eq",
      "type": "method",
      "start_line": 335,
      "end_line": 338,
      "content_hash": "cc1bbd9c06be027ae54008320144048aa4524ff3",
      "content": "    fn eq(&self, other: &i32) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_339": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 339,
      "end_line": 339,
      "content_hash": "2f00044787f7a1fc1910eb97aa18cb49314aa315",
      "content": "impl PartialEq<i64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_340": {
      "name": "eq",
      "type": "method",
      "start_line": 340,
      "end_line": 344,
      "content_hash": "8ebb8e9dbf7e700e4ae66d35f7d6d9e5cc946739",
      "content": "    fn eq(&self, other: &i64) -> bool {\n        self == &Value::from(*other)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_345": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 345,
      "end_line": 345,
      "content_hash": "f2ec1a4a1bfbaec75b843132f47cb7673e1f1eae",
      "content": "impl PartialEq<f32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_346": {
      "name": "eq",
      "type": "method",
      "start_line": 346,
      "end_line": 349,
      "content_hash": "4bda092a2c605852f8f602b32c43a401b052faf1",
      "content": "    fn eq(&self, other: &f32) -> bool {\n        self == &Value::from(*other)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_350": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 350,
      "end_line": 350,
      "content_hash": "afee8ff1f33ffd99e9e467b0e58b18b10ebbf0ba",
      "content": "impl PartialEq<f64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_351": {
      "name": "eq",
      "type": "method",
      "start_line": 351,
      "end_line": 355,
      "content_hash": "cc039e33faa1234126999abb1c736210ec6f8ad6",
      "content": "    fn eq(&self, other: &f64) -> bool {\n        self == &Value::from(*other)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_356": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 356,
      "end_line": 356,
      "content_hash": "aa1093bf44d6b3c6c16135a2a0d78f92d0b17561",
      "content": "impl PartialEq<String> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_357": {
      "name": "eq",
      "type": "method",
      "start_line": 357,
      "end_line": 364,
      "content_hash": "de81a0c082a8183a13f47bc3cd981a28fc2333af",
      "content": "    fn eq(&self, other: &String) -> bool {\n        match self {\n            Value::String(s) => s == other,\n            _ => false,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_365": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 365,
      "end_line": 365,
      "content_hash": "a35f2abd26ea13a7953aa6007e8bcc7cb2153aa6",
      "content": "impl PartialEq<bool> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_366": {
      "name": "eq",
      "type": "method",
      "start_line": 366,
      "end_line": 370,
      "content_hash": "dc1d341f3e36b2371a9e7de995de8d725fa04027",
      "content": "    fn eq(&self, other: &bool) -> bool {\n        self == &Value::from(*other)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_371": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 371,
      "end_line": 371,
      "content_hash": "eb9b2a20c29f57d4677a299e145f51be457a2492",
      "content": "impl PartialEq<&str> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_372": {
      "name": "eq",
      "type": "method",
      "start_line": 372,
      "end_line": 376,
      "content_hash": "0882b2397a2595ee164fbda49c28f1fdf9b01810",
      "content": "    fn eq(&self, other: &&str) -> bool {\n        self == &Value::from(*other)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_377": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 377,
      "end_line": 377,
      "content_hash": "64f08446c2ef1d0e04bd5a266041221ac9db6c32",
      "content": "impl PartialEq<DateTime<Utc>> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_378": {
      "name": "eq",
      "type": "method",
      "start_line": 378,
      "end_line": 382,
      "content_hash": "0064a49b56844deeed095859f08f02169a24818a",
      "content": "    fn eq(&self, other: &DateTime<Utc>) -> bool {\n        self == &Value::from(*other)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_383": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 383,
      "end_line": 383,
      "content_hash": "0a1fa864dd3c26f86c0f88f121db49763425920c",
      "content": "impl PartialOrd<i8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_384": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 384,
      "end_line": 387,
      "content_hash": "e92c215ffeda85ff03174ce1fb3bcdc6ad736e38",
      "content": "    fn partial_cmp(&self, other: &i8) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_388": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 388,
      "end_line": 388,
      "content_hash": "cb01cca8539c89322efc3d40b104e404a8580f2d",
      "content": "impl PartialOrd<i16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_389": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 389,
      "end_line": 392,
      "content_hash": "6bc421d1466a8a7825ff3cbbc5aa5d7d26d918ee",
      "content": "    fn partial_cmp(&self, other: &i16) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_393": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 393,
      "end_line": 393,
      "content_hash": "adeb041600a2376d7b4242c671f74c760da0828b",
      "content": "impl PartialOrd<i32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_394": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 394,
      "end_line": 397,
      "content_hash": "2c41a4284be9385d34ddfe8b3dc2a6da1bc33e07",
      "content": "    fn partial_cmp(&self, other: &i32) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_398": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 398,
      "end_line": 398,
      "content_hash": "cbf1d1881839a67c347fe13c3f63789db7d31f64",
      "content": "impl PartialOrd<i64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_399": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 399,
      "end_line": 402,
      "content_hash": "36b2844e6afca92952ebe7109ea413a824a04131",
      "content": "    fn partial_cmp(&self, other: &i64) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_403": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 403,
      "end_line": 403,
      "content_hash": "bff41b444b6acdf6c485aa37b756014d118acba9",
      "content": "impl PartialOrd<f32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_404": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 404,
      "end_line": 407,
      "content_hash": "f389d765e4af50766528365522358bcb7424db45",
      "content": "    fn partial_cmp(&self, other: &f32) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_408": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 408,
      "end_line": 408,
      "content_hash": "bf3667254728bb302e898551892eb8c5e1cd36cb",
      "content": "impl PartialOrd<f64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_409": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 409,
      "end_line": 412,
      "content_hash": "214e56b7b0e0aa7884c924e92c0757cf681880e9",
      "content": "    fn partial_cmp(&self, other: &f64) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_413": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 413,
      "end_line": 413,
      "content_hash": "951cefe0289abe32723a8340bcd312314f9e9f49",
      "content": "impl PartialOrd<u8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_414": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 414,
      "end_line": 417,
      "content_hash": "37d7d85e4fa5e81c4dc56c35b5c170f0bb00fcc0",
      "content": "    fn partial_cmp(&self, other: &u8) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_418": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 418,
      "end_line": 418,
      "content_hash": "869bc00452be3fb58a28ded0557c70c63b09d948",
      "content": "impl PartialOrd<u16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_419": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 419,
      "end_line": 422,
      "content_hash": "1bd861e3a38974b69119e4edd02b38c837e041d7",
      "content": "    fn partial_cmp(&self, other: &u16) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_423": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 423,
      "end_line": 423,
      "content_hash": "e4b23c1fdb2569760b0d1804f74658295dc6b755",
      "content": "impl PartialOrd<u32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_424": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 424,
      "end_line": 427,
      "content_hash": "0ae2ef8fb9188c11998d2cb37c6f799852a129a0",
      "content": "    fn partial_cmp(&self, other: &u32) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_428": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 428,
      "end_line": 428,
      "content_hash": "da813f55488024d7c489e288e52f07edaebf73ea",
      "content": "impl PartialOrd<u64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_429": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 429,
      "end_line": 432,
      "content_hash": "37929922b36a3d1cad839831d024c8978c09cad8",
      "content": "    fn partial_cmp(&self, other: &u64) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_433": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 433,
      "end_line": 433,
      "content_hash": "b07360a3be9de9190fc40f5a8096f2a6b03a2b34",
      "content": "impl PartialOrd<u128> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_434": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 434,
      "end_line": 438,
      "content_hash": "b6a717a30f8513f721d30231c587ef8df2563ed6",
      "content": "    fn partial_cmp(&self, other: &u128) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_439": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 439,
      "end_line": 439,
      "content_hash": "3775cd5c174bb4b6bdeba502213d342baf6fc686",
      "content": "impl PartialOrd<ID> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_440": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 440,
      "end_line": 449,
      "content_hash": "0cdf835078c6b1244c85dfb7a2e720e98aa20b6d",
      "content": "    fn partial_cmp(&self, other: &ID) -> Option<Ordering> {\n        match self {\n            Value::Id(id) => id.partial_cmp(other),\n            Value::String(s) => Some(ID::from(s).partial_cmp(other)?),\n            Value::U128(u) => Some(u.partial_cmp(other)?),\n            _ => None,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_450": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 450,
      "end_line": 450,
      "content_hash": "c60878a91008e384cebd385b08f4db757c01ad85",
      "content": "impl PartialOrd<DateTime<Utc>> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_451": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 451,
      "end_line": 457,
      "content_hash": "871683d6e1b41f083558fe4312e6c8057a557440",
      "content": "    fn partial_cmp(&self, other: &DateTime<Utc>) -> Option<Ordering> {\n        self.partial_cmp(&Value::from(*other))\n    }\n}\n\n/// Custom serialisation implementation for Value that removes enum variant names in JSON\n/// whilst preserving them for binary formats like bincode.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_458": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 458,
      "end_line": 529,
      "content_hash": "827404836bbac426731ad0f775ca269ecc618f2a",
      "content": "impl Serialize for Value {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match self {\n                Value::String(s) => s.serialize(serializer),\n                Value::F32(f) => f.serialize(serializer),\n                Value::F64(f) => f.serialize(serializer),\n                Value::I8(i) => i.serialize(serializer),\n                Value::I16(i) => i.serialize(serializer),\n                Value::I32(i) => i.serialize(serializer),\n                Value::I64(i) => i.serialize(serializer),\n                Value::U8(i) => i.serialize(serializer),\n                Value::U16(i) => i.serialize(serializer),\n                Value::U32(i) => i.serialize(serializer),\n                Value::U64(i) => i.serialize(serializer),\n                Value::U128(i) => i.serialize(serializer),\n                Value::Boolean(b) => b.serialize(serializer),\n                Value::Date(d) => d.serialize(serializer),\n                Value::Id(id) => id.serialize(serializer),\n                Value::Array(arr) => {\n                    use serde::ser::SerializeSeq;\n                    let mut seq = serializer.serialize_seq(Some(arr.len()))?;\n                    for value in arr {\n                        seq.serialize_element(&value)?;\n                    }\n                    seq.end()\n                }\n                Value::Object(obj) => {\n                    use serde::ser::SerializeMap;\n                    let mut map = serializer.serialize_map(Some(obj.len()))?;\n                    for (k, v) in obj {\n                        map.serialize_entry(k, v)?;\n                    }\n                    map.end()\n                }\n                Value::Empty => serializer.serialize_none(),\n            }\n        } else {\n            match self {\n                Value::String(s) => serializer.serialize_newtype_variant(\"Value\", 0, \"String\", s),\n                Value::F32(f) => serializer.serialize_newtype_variant(\"Value\", 1, \"F32\", f),\n                Value::F64(f) => serializer.serialize_newtype_variant(\"Value\", 2, \"F64\", f),\n                Value::I8(i) => serializer.serialize_newtype_variant(\"Value\", 3, \"I8\", i),\n                Value::I16(i) => serializer.serialize_newtype_variant(\"Value\", 4, \"I16\", i),\n                Value::I32(i) => serializer.serialize_newtype_variant(\"Value\", 5, \"I32\", i),\n                Value::I64(i) => serializer.serialize_newtype_variant(\"Value\", 6, \"I64\", i),\n                Value::U8(i) => serializer.serialize_newtype_variant(\"Value\", 7, \"U8\", i),\n                Value::U16(i) => serializer.serialize_newtype_variant(\"Value\", 8, \"U16\", i),\n                Value::U32(i) => serializer.serialize_newtype_variant(\"Value\", 9, \"U32\", i),\n                Value::U64(i) => serializer.serialize_newtype_variant(\"Value\", 10, \"U64\", i),\n                Value::U128(i) => serializer.serialize_newtype_variant(\"Value\", 11, \"U128\", i),\n                Value::Date(d) => serializer.serialize_newtype_variant(\"Value\", 12, \"Date\", d),\n                Value::Boolean(b) => {\n                    serializer.serialize_newtype_variant(\"Value\", 13, \"Boolean\", b)\n                }\n                Value::Id(id) => serializer.serialize_newtype_variant(\"Value\", 14, \"Id\", id),\n                Value::Array(a) => serializer.serialize_newtype_variant(\"Value\", 15, \"Array\", a),\n                Value::Object(obj) => {\n                    serializer.serialize_newtype_variant(\"Value\", 16, \"Object\", obj)\n                }\n                Value::Empty => serializer.serialize_unit_variant(\"Value\", 17, \"Empty\"),\n            }\n        }\n    }\n}\n\n/// Custom deserialisation implementation for Value that handles both JSON and binary formats.\n/// For JSON, parses raw values directly.\n/// For binary formats like bincode, reconstructs the full enum structure.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deserialize_530": {
      "name": "Deserialize",
      "type": "impl",
      "start_line": 530,
      "end_line": 536,
      "content_hash": "4cd9cfc584aa974049edf0cef9d913ec67e2bdf1",
      "content": "impl<'de> Deserialize<'de> for Value {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        /// Visitor implementation that handles conversion of raw values into Value enum variants.\n        /// Supports both direct value parsing for JSON and enum variant parsing for binary formats.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ValueVisitor_537": {
      "name": "ValueVisitor",
      "type": "struct",
      "start_line": 537,
      "end_line": 538,
      "content_hash": "59d19237b5933c42ebb03c04cf24caa7a06078c0",
      "content": "        struct ValueVisitor;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Visitor_539": {
      "name": "Visitor",
      "type": "impl",
      "start_line": 539,
      "end_line": 542,
      "content_hash": "45504e550e384eee8f89349caed8bca430913500",
      "content": "        impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expecting_543": {
      "name": "expecting",
      "type": "method",
      "start_line": 543,
      "end_line": 728,
      "content_hash": "66561ca70900b6f0acf944e4830d6649a87f246d",
      "content": "            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a string, number, boolean, array, null, or Value enum\")\n            }\n\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::String(value.to_owned()))\n            }\n\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_f32<E>(self, value: f32) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::F32(value))\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::F64(value))\n            }\n\n            #[inline]\n            fn visit_i8<E>(self, value: i8) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::I8(value))\n            }\n\n            #[inline]\n            fn visit_i16<E>(self, value: i16) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::I16(value))\n            }\n\n            #[inline]\n            fn visit_i32<E>(self, value: i32) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::I32(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::I64(value))\n            }\n\n            #[inline]\n            fn visit_u8<E>(self, value: u8) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::U8(value))\n            }\n\n            #[inline]\n            fn visit_u16<E>(self, value: u16) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::U16(value))\n            }\n\n            #[inline]\n            fn visit_u32<E>(self, value: u32) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::U32(value))\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::U64(value))\n            }\n\n            #[inline]\n            fn visit_u128<E>(self, value: u128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::U128(value))\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::Boolean(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Value::Empty)\n            }\n\n            /// Handles array values by recursively deserialising each element\n            fn visit_seq<A>(self, mut seq: A) -> Result<Value, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut values = Vec::new();\n                while let Some(value) = seq.next_element()? {\n                    values.push(value);\n                }\n                Ok(Value::Array(values))\n            }\n\n            /// Handles object values by recursively deserialising each key-value pair\n            fn visit_map<A>(self, mut map: A) -> Result<Value, A::Error>\n            where\n                A: serde::de::MapAccess<'de>,\n            {\n                let mut object = HashMap::new();\n                while let Some((key, value)) = map.next_entry()? {\n                    object.insert(key, value);\n                }\n                Ok(Value::Object(object))\n            }\n\n            /// Handles binary format deserialisation using numeric indices to identify variants\n            /// Maps indices 0-5 to corresponding Value enum variants\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::EnumAccess<'de>,\n            {\n                let (variant_idx, variant_data) = data.variant_seed(VariantIdxDeserializer)?;\n                match variant_idx {\n                    0 => Ok(Value::String(variant_data.newtype_variant()?)),\n                    1 => Ok(Value::F32(variant_data.newtype_variant()?)),\n                    2 => Ok(Value::F64(variant_data.newtype_variant()?)),\n                    3 => Ok(Value::I8(variant_data.newtype_variant()?)),\n                    4 => Ok(Value::I16(variant_data.newtype_variant()?)),\n                    5 => Ok(Value::I32(variant_data.newtype_variant()?)),\n                    6 => Ok(Value::I64(variant_data.newtype_variant()?)),\n                    7 => Ok(Value::U8(variant_data.newtype_variant()?)),\n                    8 => Ok(Value::U16(variant_data.newtype_variant()?)),\n                    9 => Ok(Value::U32(variant_data.newtype_variant()?)),\n                    10 => Ok(Value::U64(variant_data.newtype_variant()?)),\n                    11 => Ok(Value::U128(variant_data.newtype_variant()?)),\n                    12 => Ok(Value::Date(variant_data.newtype_variant()?)),\n                    13 => Ok(Value::Boolean(variant_data.newtype_variant()?)),\n                    14 => Ok(Value::Id(variant_data.newtype_variant()?)),\n                    15 => Ok(Value::Array(variant_data.newtype_variant()?)),\n                    16 => Ok(Value::Object(variant_data.newtype_variant()?)),\n                    17 => {\n                        variant_data.unit_variant()?;\n                        Ok(Value::Empty)\n                    }\n                    _ => Err(serde::de::Error::invalid_value(\n                        serde::de::Unexpected::Unsigned(variant_idx as u64),\n                        &\"variant index 0 through 17\",\n                    )),\n                }\n            }\n        }\n\n        /// Helper deserialiser for handling numeric variant indices in binary format",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_VariantIdxDeserializer_729": {
      "name": "VariantIdxDeserializer",
      "type": "struct",
      "start_line": 729,
      "end_line": 730,
      "content_hash": "71fcb4741470b60acafc0cb6bf99ec5b6e986090",
      "content": "        struct VariantIdxDeserializer;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DeserializeSeed_731": {
      "name": "DeserializeSeed",
      "type": "impl",
      "start_line": 731,
      "end_line": 741,
      "content_hash": "1f819308199fa285accf27797b7db421231731ce",
      "content": "        impl<'de> DeserializeSeed<'de> for VariantIdxDeserializer {\n            type Value = u32;\n            #[inline]\n            fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                deserializer.deserialize_u32(self)\n            }\n        }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Visitor_742": {
      "name": "Visitor",
      "type": "impl",
      "start_line": 742,
      "end_line": 745,
      "content_hash": "07d0fbb314434a22ba2811e0125331d568a0d155",
      "content": "        impl<'de> Visitor<'de> for VariantIdxDeserializer {\n            type Value = u32;\n\n            #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expecting_746": {
      "name": "expecting",
      "type": "method",
      "start_line": 746,
      "end_line": 813,
      "content_hash": "1756bc8cf77f153bbce4f37fda077207bb0b18f0",
      "content": "            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"variant index\")\n            }\n\n            #[inline]\n            fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(v)\n            }\n        }\n        // Choose deserialisation strategy based on format\n        if deserializer.is_human_readable() {\n            // For JSON, accept any value type\n            deserializer.deserialize_any(ValueVisitor)\n        } else {\n            // For binary, use enum variant indices\n            deserializer.deserialize_enum(\n                \"Value\",\n                &[\n                    \"String\", \"F32\", \"F64\", \"I8\", \"I16\", \"I32\", \"I64\", \"U8\", \"U16\", \"U32\", \"U64\",\n                    \"U128\", \"Date\", \"Boolean\", \"Id\", \"Array\", \"Object\", \"Empty\",\n                ],\n                ValueVisitor,\n            )\n        }\n    }\n}\n\n/// Module for custom serialisation of property hashmaps\n/// Ensures consistent handling of Value enum serialisation within property maps\npub mod properties_format {\n    use super::*;\n\n    #[inline]\n    pub fn serialize<S>(\n        properties: &Option<HashMap<String, Value>>,\n        serializer: S,\n    ) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match properties {\n            Some(properties) => {\n                use serde::ser::SerializeMap;\n                let mut map = serializer.serialize_map(Some(properties.len()))?;\n                for (k, v) in properties {\n                    map.serialize_entry(k, v)?;\n                }\n                map.end()\n            }\n            None => serializer.serialize_none(),\n        }\n    }\n\n    #[inline]\n    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<HashMap<String, Value>>, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        match Option::<HashMap<String, Value>>::deserialize(deserializer) {\n            Ok(properties) => Ok(properties),\n            Err(e) => Err(e),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_814": {
      "name": "From",
      "type": "impl",
      "start_line": 814,
      "end_line": 815,
      "content_hash": "62d48ac58de14e994fc5c5480d59bf2d22937a86",
      "content": "impl From<&str> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_816": {
      "name": "from",
      "type": "method",
      "start_line": 816,
      "end_line": 820,
      "content_hash": "d31cf293b18e7881fe1991a2ac37d35c0a5886dd",
      "content": "    fn from(s: &str) -> Self {\n        Value::String(s.trim_matches('\"').to_string())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_821": {
      "name": "From",
      "type": "impl",
      "start_line": 821,
      "end_line": 822,
      "content_hash": "81b8a14a31f155c0bb93a8516189e5400b72c813",
      "content": "impl From<String> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_823": {
      "name": "from",
      "type": "method",
      "start_line": 823,
      "end_line": 826,
      "content_hash": "1d6ac470cd33af3ececeb4f8e9d50ab31d7cbfee",
      "content": "    fn from(s: String) -> Self {\n        Value::String(s.trim_matches('\"').to_string())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_827": {
      "name": "From",
      "type": "impl",
      "start_line": 827,
      "end_line": 828,
      "content_hash": "6d1d911048496cae3d58deac1425282b938e1097",
      "content": "impl From<bool> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_829": {
      "name": "from",
      "type": "method",
      "start_line": 829,
      "end_line": 833,
      "content_hash": "4a06204fc0450def168963bdd03ca4629ed16958",
      "content": "    fn from(b: bool) -> Self {\n        Value::Boolean(b)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_834": {
      "name": "From",
      "type": "impl",
      "start_line": 834,
      "end_line": 835,
      "content_hash": "bfddf4bf9ba1394bbc15970f570e2ad17586abfb",
      "content": "impl From<f32> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_836": {
      "name": "from",
      "type": "method",
      "start_line": 836,
      "end_line": 840,
      "content_hash": "8e37fb1fbe91cd71e7d17175ca2a913967a91f5c",
      "content": "    fn from(f: f32) -> Self {\n        Value::F32(f)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_841": {
      "name": "From",
      "type": "impl",
      "start_line": 841,
      "end_line": 842,
      "content_hash": "3370026c8df305cb5012dd56d166eaf208755f1d",
      "content": "impl From<f64> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_843": {
      "name": "from",
      "type": "method",
      "start_line": 843,
      "end_line": 847,
      "content_hash": "727863593b4ab21eae88d7fc94868093700cec6f",
      "content": "    fn from(f: f64) -> Self {\n        Value::F64(f)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_848": {
      "name": "From",
      "type": "impl",
      "start_line": 848,
      "end_line": 849,
      "content_hash": "b4f4fe7af7f391d7ca79fec3580f32fd9034d678",
      "content": "impl From<i8> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_850": {
      "name": "from",
      "type": "method",
      "start_line": 850,
      "end_line": 854,
      "content_hash": "8ca48c0ba95d3b6c6fce6aa14b7b39bb4c37b23f",
      "content": "    fn from(i: i8) -> Self {\n        Value::I8(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_855": {
      "name": "From",
      "type": "impl",
      "start_line": 855,
      "end_line": 856,
      "content_hash": "df08e48d7b3ce8e3279530c74e37031f1cc778d3",
      "content": "impl From<i16> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_857": {
      "name": "from",
      "type": "method",
      "start_line": 857,
      "end_line": 861,
      "content_hash": "f2cf02b3b7240b3cbf894f04f10c86e1e7e38aa3",
      "content": "    fn from(i: i16) -> Self {\n        Value::I16(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_862": {
      "name": "From",
      "type": "impl",
      "start_line": 862,
      "end_line": 863,
      "content_hash": "ad2a1d7169fa4316e9e7a8617ff24134f61dfe9a",
      "content": "impl From<i32> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_864": {
      "name": "from",
      "type": "method",
      "start_line": 864,
      "end_line": 868,
      "content_hash": "b8a63698b5fdfe9e64302e4ce4c38b4eb4d6cb46",
      "content": "    fn from(i: i32) -> Self {\n        Value::I32(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_869": {
      "name": "From",
      "type": "impl",
      "start_line": 869,
      "end_line": 870,
      "content_hash": "bb111d795461a7474f73edf4c253219148f82bbb",
      "content": "impl From<i64> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_871": {
      "name": "from",
      "type": "method",
      "start_line": 871,
      "end_line": 875,
      "content_hash": "b7a595dbe150dd37ddddfbd266ce0c8002c452ae",
      "content": "    fn from(i: i64) -> Self {\n        Value::I64(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_876": {
      "name": "From",
      "type": "impl",
      "start_line": 876,
      "end_line": 877,
      "content_hash": "a68c783812bf62bd79faeb531789cd06b623e421",
      "content": "impl From<u8> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_878": {
      "name": "from",
      "type": "method",
      "start_line": 878,
      "end_line": 882,
      "content_hash": "a9fa6fd934c6fe5ca752da552e89be564870051a",
      "content": "    fn from(i: u8) -> Self {\n        Value::U8(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_883": {
      "name": "From",
      "type": "impl",
      "start_line": 883,
      "end_line": 884,
      "content_hash": "687bd01e3f930235060caf3a0c1048aed57ba987",
      "content": "impl From<u16> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_885": {
      "name": "from",
      "type": "method",
      "start_line": 885,
      "end_line": 889,
      "content_hash": "d069e7a9c1192abbe9422a91a130a4c753446ee9",
      "content": "    fn from(i: u16) -> Self {\n        Value::U16(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_890": {
      "name": "From",
      "type": "impl",
      "start_line": 890,
      "end_line": 891,
      "content_hash": "b6e943b0871f0e0f1bbb35e880cc52ec03793fa4",
      "content": "impl From<u32> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_892": {
      "name": "from",
      "type": "method",
      "start_line": 892,
      "end_line": 896,
      "content_hash": "fb9280a548abcc31ed7ce17b6c3ac5e7732c5b8e",
      "content": "    fn from(i: u32) -> Self {\n        Value::U32(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_897": {
      "name": "From",
      "type": "impl",
      "start_line": 897,
      "end_line": 898,
      "content_hash": "505137837c5a8fcb9d456b5dbf1b568cceda5b90",
      "content": "impl From<u64> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_899": {
      "name": "from",
      "type": "method",
      "start_line": 899,
      "end_line": 903,
      "content_hash": "0f567bfb50b7989d5da92e99816fd4b7bdd58cfe",
      "content": "    fn from(i: u64) -> Self {\n        Value::U64(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_904": {
      "name": "From",
      "type": "impl",
      "start_line": 904,
      "end_line": 905,
      "content_hash": "93149a07c61bf9fd6200c0e6845aa6bd9b3e1528",
      "content": "impl From<u128> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_906": {
      "name": "from",
      "type": "method",
      "start_line": 906,
      "end_line": 910,
      "content_hash": "4fe60927142dfa4351acd20edc1d3204cc1b4c29",
      "content": "    fn from(i: u128) -> Self {\n        Value::U128(i)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_911": {
      "name": "From",
      "type": "impl",
      "start_line": 911,
      "end_line": 912,
      "content_hash": "b8255948971418faadaa77bf11883567235c56a7",
      "content": "impl From<Vec<Value>> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_913": {
      "name": "from",
      "type": "method",
      "start_line": 913,
      "end_line": 917,
      "content_hash": "b64bb92c3ac66c43d33c969e6c0eecbfa2b0a067",
      "content": "    fn from(v: Vec<Value>) -> Self {\n        Value::Array(v)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_918": {
      "name": "From",
      "type": "impl",
      "start_line": 918,
      "end_line": 919,
      "content_hash": "afa49856bb6869c40c9a8138f6efa96a3fcfb628",
      "content": "impl From<Vec<bool>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_920": {
      "name": "from",
      "type": "method",
      "start_line": 920,
      "end_line": 924,
      "content_hash": "c6bea754f4e567a661bfbb3c947e1d8abbf6e929",
      "content": "    fn from(v: Vec<bool>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_925": {
      "name": "From",
      "type": "impl",
      "start_line": 925,
      "end_line": 926,
      "content_hash": "acfe1478586dd18944ccf265a59091cf25feda84",
      "content": "impl From<Vec<String>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_927": {
      "name": "from",
      "type": "method",
      "start_line": 927,
      "end_line": 931,
      "content_hash": "1b65bce4aa0570080fb6b9435ffc32adee4a32f1",
      "content": "    fn from(v: Vec<String>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_932": {
      "name": "From",
      "type": "impl",
      "start_line": 932,
      "end_line": 933,
      "content_hash": "9ccda5ce2ed907110493fd9abec5f4cfed601d67",
      "content": "impl From<Vec<i64>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_934": {
      "name": "from",
      "type": "method",
      "start_line": 934,
      "end_line": 938,
      "content_hash": "8a34365cc30bf4b008195168eabb9c7fa4ca9705",
      "content": "    fn from(v: Vec<i64>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_939": {
      "name": "From",
      "type": "impl",
      "start_line": 939,
      "end_line": 940,
      "content_hash": "a64f759671f1e54db48841c536520604970ff0ed",
      "content": "impl From<Vec<i32>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_941": {
      "name": "from",
      "type": "method",
      "start_line": 941,
      "end_line": 945,
      "content_hash": "27c008f32391150fe64d52a1decc21b993ed91b5",
      "content": "    fn from(v: Vec<i32>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_946": {
      "name": "From",
      "type": "impl",
      "start_line": 946,
      "end_line": 947,
      "content_hash": "0e781c259485b04b2cab983468f5d90e6e88bdea",
      "content": "impl From<Vec<i16>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_948": {
      "name": "from",
      "type": "method",
      "start_line": 948,
      "end_line": 952,
      "content_hash": "99d842f57efb08bfcbf63d1112a0d4e10fc61421",
      "content": "    fn from(v: Vec<i16>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_953": {
      "name": "From",
      "type": "impl",
      "start_line": 953,
      "end_line": 954,
      "content_hash": "68a79ff121c6758a88ef18b1bf3d20fce8340c2c",
      "content": "impl From<Vec<i8>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_955": {
      "name": "from",
      "type": "method",
      "start_line": 955,
      "end_line": 959,
      "content_hash": "c1c3e18a7476d26d7903f82681849119666e571b",
      "content": "    fn from(v: Vec<i8>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_960": {
      "name": "From",
      "type": "impl",
      "start_line": 960,
      "end_line": 961,
      "content_hash": "aca068240dde76ba13d47bf2d52f2cc25d7d0493",
      "content": "impl From<Vec<u128>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_962": {
      "name": "from",
      "type": "method",
      "start_line": 962,
      "end_line": 966,
      "content_hash": "604d818682c4997af2462e6f148d7fa461077f23",
      "content": "    fn from(v: Vec<u128>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_967": {
      "name": "From",
      "type": "impl",
      "start_line": 967,
      "end_line": 968,
      "content_hash": "d85e66441350ae8026c44c4975f01201150d8c3c",
      "content": "impl From<Vec<u64>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_969": {
      "name": "from",
      "type": "method",
      "start_line": 969,
      "end_line": 973,
      "content_hash": "9adce016c43353e4e456dbb4634ed3a64a57ee15",
      "content": "    fn from(v: Vec<u64>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_974": {
      "name": "From",
      "type": "impl",
      "start_line": 974,
      "end_line": 975,
      "content_hash": "7929b709121bd37486c5083bdca2255585def097",
      "content": "impl From<Vec<u32>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_976": {
      "name": "from",
      "type": "method",
      "start_line": 976,
      "end_line": 980,
      "content_hash": "a1a8da3a8d2d1995fb56b474a76f227503368a6c",
      "content": "    fn from(v: Vec<u32>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_981": {
      "name": "From",
      "type": "impl",
      "start_line": 981,
      "end_line": 982,
      "content_hash": "519f1edfae66450d93f051683d8922e57bafea5c",
      "content": "impl From<Vec<u16>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_983": {
      "name": "from",
      "type": "method",
      "start_line": 983,
      "end_line": 987,
      "content_hash": "5b257d20f583406d2335d80302b05b83f3c703e2",
      "content": "    fn from(v: Vec<u16>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_988": {
      "name": "From",
      "type": "impl",
      "start_line": 988,
      "end_line": 989,
      "content_hash": "d034b8ac1b87a485fcf6be23b2e77c923fe47323",
      "content": "impl From<Vec<u8>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_990": {
      "name": "from",
      "type": "method",
      "start_line": 990,
      "end_line": 994,
      "content_hash": "33370f7ef9399419b563952f0474bd7bc4494bad",
      "content": "    fn from(v: Vec<u8>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_995": {
      "name": "From",
      "type": "impl",
      "start_line": 995,
      "end_line": 996,
      "content_hash": "e45130111d0f7811785f41fc74f9bd239e0d9cf1",
      "content": "impl From<Vec<f64>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_997": {
      "name": "from",
      "type": "method",
      "start_line": 997,
      "end_line": 1001,
      "content_hash": "5fa581b45bea7552365391f7fc9cc546b7294250",
      "content": "    fn from(v: Vec<f64>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1002": {
      "name": "From",
      "type": "impl",
      "start_line": 1002,
      "end_line": 1003,
      "content_hash": "01c3a71799546d4cfa09ce876975131183d74341",
      "content": "impl From<Vec<f32>> for Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1004": {
      "name": "from",
      "type": "method",
      "start_line": 1004,
      "end_line": 1008,
      "content_hash": "53952465403ce23e1dcdefb83f2711fcc05fc5da",
      "content": "    fn from(v: Vec<f32>) -> Self {\n        Value::Array(v.into_iter().map(|v| v.into()).collect())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1009": {
      "name": "From",
      "type": "impl",
      "start_line": 1009,
      "end_line": 1010,
      "content_hash": "209bffc59200ae2ae5be481d7ffd515dd7e12436",
      "content": "impl From<usize> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1011": {
      "name": "from",
      "type": "method",
      "start_line": 1011,
      "end_line": 1019,
      "content_hash": "425f00b8b5848bf82eb83ae893c49f4a104f0c1c",
      "content": "    fn from(v: usize) -> Self {\n        if cfg!(target_pointer_width = \"64\") {\n            Value::U64(v as u64)\n        } else {\n            Value::U128(v as u128)\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1020": {
      "name": "From",
      "type": "impl",
      "start_line": 1020,
      "end_line": 1021,
      "content_hash": "8f112a7172443344dc5b9f0ba471edb7176877e5",
      "content": "impl From<Value> for String {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1022": {
      "name": "from",
      "type": "method",
      "start_line": 1022,
      "end_line": 1029,
      "content_hash": "3ea896ac2081e53d761530f7b6c2043f1495c51a",
      "content": "    fn from(v: Value) -> Self {\n        match v {\n            Value::String(s) => s,\n            _ => panic!(\"Value is not a string\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1030": {
      "name": "From",
      "type": "impl",
      "start_line": 1030,
      "end_line": 1031,
      "content_hash": "a5344964d64a9e732b3d3508b77574da894771db",
      "content": "impl From<ID> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1032": {
      "name": "from",
      "type": "method",
      "start_line": 1032,
      "end_line": 1036,
      "content_hash": "6f7e7c010f97fd37ba57ad2d93ea233f435345cc",
      "content": "    fn from(id: ID) -> Self {\n        Value::String(id.to_string())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1037": {
      "name": "From",
      "type": "impl",
      "start_line": 1037,
      "end_line": 1041,
      "content_hash": "99f72b0227da5a31191ef08d5c1cb389258f4f2c",
      "content": "impl<'a, K> From<&'a K> for Value\nwhere\n    K: Into<Value> + Serialize + Clone,\n{\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1042": {
      "name": "from",
      "type": "method",
      "start_line": 1042,
      "end_line": 1046,
      "content_hash": "4c10968b5b72387d0568718031a855ed083566ed",
      "content": "    fn from(k: &'a K) -> Self {\n        k.clone().into()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1047": {
      "name": "From",
      "type": "impl",
      "start_line": 1047,
      "end_line": 1048,
      "content_hash": "861259722f56e7fcda3697cde10ef13785cea58b",
      "content": "impl From<chrono::DateTime<Utc>> for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1049": {
      "name": "from",
      "type": "method",
      "start_line": 1049,
      "end_line": 1053,
      "content_hash": "c417ba1beda2dabdbfdfa2d0d036e847e6f73079",
      "content": "    fn from(dt: chrono::DateTime<Utc>) -> Self {\n        Value::String(dt.to_rfc3339())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1054": {
      "name": "From",
      "type": "impl",
      "start_line": 1054,
      "end_line": 1054,
      "content_hash": "884b215f72cbef30c28735810ee0f3ec9aa7fd67",
      "content": "impl From<Value> for GenRef<String> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1055": {
      "name": "from",
      "type": "method",
      "start_line": 1055,
      "end_line": 1078,
      "content_hash": "32058e9548128a8d2e0504a768b5904cb3583ee3",
      "content": "    fn from(v: Value) -> Self {\n        match v {\n            Value::String(s) => GenRef::Literal(s),\n            Value::I8(i) => GenRef::Std(format!(\"{i}\")),\n            Value::I16(i) => GenRef::Std(format!(\"{i}\")),\n            Value::I32(i) => GenRef::Std(format!(\"{i}\")),\n            Value::I64(i) => GenRef::Std(format!(\"{i}\")),\n            Value::F32(f) => GenRef::Std(format!(\"{f:?}\")), // {:?} forces decimal point\n            Value::F64(f) => GenRef::Std(format!(\"{f:?}\")),\n            Value::Boolean(b) => GenRef::Std(format!(\"{b}\")),\n            Value::U8(u) => GenRef::Std(format!(\"{u}\")),\n            Value::U16(u) => GenRef::Std(format!(\"{u}\")),\n            Value::U32(u) => GenRef::Std(format!(\"{u}\")),\n            Value::U64(u) => GenRef::Std(format!(\"{u}\")),\n            Value::U128(u) => GenRef::Std(format!(\"{u}\")),\n            Value::Date(d) => GenRef::Std(format!(\"{d:?}\")),\n            Value::Id(id) => GenRef::Literal(id.stringify()),\n            Value::Array(_a) => unimplemented!(),\n            Value::Object(_o) => unimplemented!(),\n            Value::Empty => GenRef::Literal(\"\".to_string()),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FilterValues_1079": {
      "name": "FilterValues",
      "type": "impl",
      "start_line": 1079,
      "end_line": 1080,
      "content_hash": "f58ff9194d43f3cf6207bef8f5d8328edd172387",
      "content": "impl FilterValues for Value {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_compare_1081": {
      "name": "compare",
      "type": "method",
      "start_line": 1081,
      "end_line": 1097,
      "content_hash": "4151b3e7b2e2def8c9ef507472cfcca7fbbcbb0c",
      "content": "    fn compare(&self, value: &Value, operator: Option<Operator>) -> bool {\n        debug_println!(\"comparing value1: {:?}, value2: {:?}\", self, value);\n        let comparison = match (self, value) {\n            (Value::Array(a1), Value::Array(a2)) => a1\n                .iter()\n                .any(|a1_item| a2.iter().any(|a2_item| a1_item.compare(a2_item, operator))),\n            (value, Value::Array(a)) => a.iter().any(|a_item| value.compare(a_item, operator)),\n            (value1, value2) => match operator {\n                Some(op) => op.execute(value1, value2),\n                None => value1 == value2,\n            },\n        };\n        debug_println!(\"comparison: {:?}\", comparison);\n        comparison\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1098": {
      "name": "From",
      "type": "impl",
      "start_line": 1098,
      "end_line": 1098,
      "content_hash": "d92f0ba399cd677048edfd90d1d5bbdffd779c7f",
      "content": "impl From<Value> for i8 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1099": {
      "name": "from",
      "type": "method",
      "start_line": 1099,
      "end_line": 1118,
      "content_hash": "5b51b681ccc571790a3a5ff091112564b5ae3e35",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::I8(i) => i,\n            Value::I16(i) => i as i8,\n            Value::I32(i) => i as i8,\n            Value::I64(i) => i as i8,\n            Value::U8(i) => i as i8,\n            Value::U16(i) => i as i8,\n            Value::U32(i) => i as i8,\n            Value::U64(i) => i as i8,\n            Value::U128(i) => i as i8,\n            Value::F32(i) => i as i8,\n            Value::F64(i) => i as i8,\n            Value::Boolean(i) => i as i8,\n            Value::String(s) => s.parse::<i8>().unwrap(),\n            _ => panic!(\"Value cannot be cast to i8\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1119": {
      "name": "From",
      "type": "impl",
      "start_line": 1119,
      "end_line": 1119,
      "content_hash": "ea9996e35a86571c088a819417cf36dc05c0a3e0",
      "content": "impl From<Value> for i16 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1120": {
      "name": "from",
      "type": "method",
      "start_line": 1120,
      "end_line": 1139,
      "content_hash": "005e36e6d63494be9508809ed88bb576858e7405",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::I16(i) => i,\n            Value::I8(i) => i as i16,\n            Value::I32(i) => i as i16,\n            Value::I64(i) => i as i16,\n            Value::U8(i) => i as i16,\n            Value::U16(i) => i as i16,\n            Value::U32(i) => i as i16,\n            Value::U64(i) => i as i16,\n            Value::U128(i) => i as i16,\n            Value::F32(i) => i as i16,\n            Value::F64(i) => i as i16,\n            Value::Boolean(i) => i as i16,\n            Value::String(s) => s.parse::<i16>().unwrap(),\n            _ => panic!(\"Value cannot be cast to i16\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1140": {
      "name": "From",
      "type": "impl",
      "start_line": 1140,
      "end_line": 1140,
      "content_hash": "fae8c44e280ee65bdc9f43d503e2269462a70b06",
      "content": "impl From<Value> for i32 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1141": {
      "name": "from",
      "type": "method",
      "start_line": 1141,
      "end_line": 1160,
      "content_hash": "fa1f22dddd21e3a189aa78799dd204a39b440ac8",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::I32(i) => i,\n            Value::I8(i) => i as i32,\n            Value::I16(i) => i as i32,\n            Value::I64(i) => i as i32,\n            Value::U8(i) => i as i32,\n            Value::U16(i) => i as i32,\n            Value::U32(i) => i as i32,\n            Value::U64(i) => i as i32,\n            Value::U128(i) => i as i32,\n            Value::F32(i) => i as i32,\n            Value::F64(i) => i as i32,\n            Value::Boolean(i) => i as i32,\n            Value::String(s) => s.parse::<i32>().unwrap(),\n            _ => panic!(\"Value cannot be cast to i32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1161": {
      "name": "From",
      "type": "impl",
      "start_line": 1161,
      "end_line": 1161,
      "content_hash": "6b273f204a5929977f3bdf6927ff0e575a61e1d1",
      "content": "impl From<Value> for i64 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1162": {
      "name": "from",
      "type": "method",
      "start_line": 1162,
      "end_line": 1181,
      "content_hash": "85cef484332695ccbd1e4a5b7b326dd883f4abc2",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::I64(i) => i,\n            Value::I8(i) => i as i64,\n            Value::I16(i) => i as i64,\n            Value::I32(i) => i as i64,\n            Value::U8(i) => i as i64,\n            Value::U16(i) => i as i64,\n            Value::U32(i) => i as i64,\n            Value::U64(i) => i as i64,\n            Value::U128(i) => i as i64,\n            Value::F32(i) => i as i64,\n            Value::F64(i) => i as i64,\n            Value::Boolean(i) => i as i64,\n            Value::String(s) => s.parse::<i64>().unwrap(),\n            _ => panic!(\"Value cannot be cast to i64\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1182": {
      "name": "From",
      "type": "impl",
      "start_line": 1182,
      "end_line": 1182,
      "content_hash": "065f89547cccc9256f2d3c1faeb57c1928539c6a",
      "content": "impl From<Value> for u8 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1183": {
      "name": "from",
      "type": "method",
      "start_line": 1183,
      "end_line": 1202,
      "content_hash": "e23ff8b974b6bd2b23953d48a3acda7a6cf3b087",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::U8(i) => i,\n            Value::I8(i) => i as u8,\n            Value::I16(i) => i as u8,\n            Value::I32(i) => i as u8,\n            Value::I64(i) => i as u8,\n            Value::U16(i) => i as u8,\n            Value::U32(i) => i as u8,\n            Value::U64(i) => i as u8,\n            Value::U128(i) => i as u8,\n            Value::F32(i) => i as u8,\n            Value::F64(i) => i as u8,\n            Value::Boolean(i) => i as u8,\n            Value::String(s) => s.parse::<u8>().unwrap(),\n            _ => panic!(\"Value cannot be cast to u8\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1203": {
      "name": "From",
      "type": "impl",
      "start_line": 1203,
      "end_line": 1203,
      "content_hash": "6d977d7d84ccfeec45e24df15a0f5939edfa5ebf",
      "content": "impl From<Value> for u16 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1204": {
      "name": "from",
      "type": "method",
      "start_line": 1204,
      "end_line": 1223,
      "content_hash": "3823426b5331e8088b73ef7514e52ed6b29bf295",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::U16(i) => i,\n            Value::I8(i) => i as u16,\n            Value::I16(i) => i as u16,\n            Value::I32(i) => i as u16,\n            Value::I64(i) => i as u16,\n            Value::U8(i) => i as u16,\n            Value::U32(i) => i as u16,\n            Value::U64(i) => i as u16,\n            Value::U128(i) => i as u16,\n            Value::F32(i) => i as u16,\n            Value::F64(i) => i as u16,\n            Value::Boolean(i) => i as u16,\n            Value::String(s) => s.parse::<u16>().unwrap(),\n            _ => panic!(\"Value cannot be cast to u16\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1224": {
      "name": "From",
      "type": "impl",
      "start_line": 1224,
      "end_line": 1224,
      "content_hash": "7ea243d3a3a194b950b660fa8e11fa98f6c86fb6",
      "content": "impl From<Value> for u32 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1225": {
      "name": "from",
      "type": "method",
      "start_line": 1225,
      "end_line": 1244,
      "content_hash": "a22049f54f99572903ee38236a44355cf17ced5a",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::U32(i) => i,\n            Value::I8(i) => i as u32,\n            Value::I16(i) => i as u32,\n            Value::I32(i) => i as u32,\n            Value::I64(i) => i as u32,\n            Value::U8(i) => i as u32,\n            Value::U16(i) => i as u32,\n            Value::U64(i) => i as u32,\n            Value::U128(i) => i as u32,\n            Value::F32(i) => i as u32,\n            Value::F64(i) => i as u32,\n            Value::Boolean(i) => i as u32,\n            Value::String(s) => s.parse::<u32>().unwrap(),\n            _ => panic!(\"Value cannot be cast to u32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1245": {
      "name": "From",
      "type": "impl",
      "start_line": 1245,
      "end_line": 1245,
      "content_hash": "88442e9e613b731daf96dd98c1afefab6681c9f5",
      "content": "impl From<Value> for u64 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1246": {
      "name": "from",
      "type": "method",
      "start_line": 1246,
      "end_line": 1264,
      "content_hash": "cd06a098ffb35e8d78de9039efb2ef9d68b3cf7a",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::U64(i) => i,\n            Value::I8(i) => i as u64,\n            Value::I16(i) => i as u64,\n            Value::I32(i) => i as u64,\n            Value::U8(i) => i as u64,\n            Value::U16(i) => i as u64,\n            Value::U32(i) => i as u64,\n            Value::U128(i) => i as u64,\n            Value::F32(i) => i as u64,\n            Value::F64(i) => i as u64,\n            Value::Boolean(i) => i as u64,\n            Value::String(s) => s.parse::<u64>().unwrap(),\n            _ => panic!(\"Value cannot be cast to u64\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1265": {
      "name": "From",
      "type": "impl",
      "start_line": 1265,
      "end_line": 1265,
      "content_hash": "7994c3b28e84317d23f23ea05a15c34c4e8ba60d",
      "content": "impl From<Value> for u128 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1266": {
      "name": "from",
      "type": "method",
      "start_line": 1266,
      "end_line": 1285,
      "content_hash": "b7101bfdddffa10013b78a008b1a88d33e7a546a",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::U128(i) => i,\n            Value::I8(i) => i as u128,\n            Value::I16(i) => i as u128,\n            Value::I32(i) => i as u128,\n            Value::I64(i) => i as u128,\n            Value::U8(i) => i as u128,\n            Value::U16(i) => i as u128,\n            Value::U32(i) => i as u128,\n            Value::U64(i) => i as u128,\n            Value::F32(i) => i as u128,\n            Value::F64(i) => i as u128,\n            Value::Boolean(i) => i as u128,\n            Value::String(s) => s.parse::<u128>().unwrap(),\n            _ => panic!(\"Value cannot be cast to u128\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1286": {
      "name": "From",
      "type": "impl",
      "start_line": 1286,
      "end_line": 1286,
      "content_hash": "edabbcf4ad8542e17e5354af8aed12f47374dd3a",
      "content": "impl From<Value> for Date {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1287": {
      "name": "from",
      "type": "method",
      "start_line": 1287,
      "end_line": 1295,
      "content_hash": "6de54f120c4f1684b3d92b6df19698033a1c1db3",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::String(s) => Date::new(&Value::String(s)).unwrap(),\n            Value::I64(i) => Date::new(&Value::I64(i)).unwrap(),\n            Value::U64(i) => Date::new(&Value::U64(i)).unwrap(),\n            _ => panic!(\"Value cannot be cast to date\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1296": {
      "name": "From",
      "type": "impl",
      "start_line": 1296,
      "end_line": 1296,
      "content_hash": "7a6841e76fdd5dfd9d2449e7819b51b19a025175",
      "content": "impl From<Value> for bool {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1297": {
      "name": "from",
      "type": "method",
      "start_line": 1297,
      "end_line": 1304,
      "content_hash": "bc3612eeab04f3bd7a4b1c63f512678c4326ca4c",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::Boolean(b) => b,\n            _ => panic!(\"Value cannot be cast to boolean\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1305": {
      "name": "From",
      "type": "impl",
      "start_line": 1305,
      "end_line": 1305,
      "content_hash": "04824c8fb17b59504d555e9a40653f078618e04c",
      "content": "impl From<Value> for ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1306": {
      "name": "from",
      "type": "method",
      "start_line": 1306,
      "end_line": 1315,
      "content_hash": "72cf821047ec7619103046cd7d417933a64d5254",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::Id(id) => id,\n            Value::String(s) => ID::from(s),\n            Value::U128(i) => ID::from(i),\n            _ => panic!(\"Value cannot be cast to id\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1316": {
      "name": "From",
      "type": "impl",
      "start_line": 1316,
      "end_line": 1316,
      "content_hash": "2f7438425ff915f8c03be27eea45bab79f697532",
      "content": "impl From<Value> for Vec<Value> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1317": {
      "name": "from",
      "type": "method",
      "start_line": 1317,
      "end_line": 1324,
      "content_hash": "0e44f40959695f7c72cc470b749a62b4ede6140e",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::Array(a) => a,\n            _ => panic!(\"Value cannot be cast to array\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1325": {
      "name": "From",
      "type": "impl",
      "start_line": 1325,
      "end_line": 1325,
      "content_hash": "af406df344957604cca7b7e8fd75869063e82eb2",
      "content": "impl From<Value> for HashMap<String, Value> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1326": {
      "name": "from",
      "type": "method",
      "start_line": 1326,
      "end_line": 1333,
      "content_hash": "4c491a4843afd71e7aa04715d0b9a6bcd6c9dbf8",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::Object(o) => o,\n            _ => panic!(\"Value cannot be cast to object\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1334": {
      "name": "From",
      "type": "impl",
      "start_line": 1334,
      "end_line": 1334,
      "content_hash": "2d13211aec180a0488fb83fc69acef3a259afeed",
      "content": "impl From<Value> for f32 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1335": {
      "name": "from",
      "type": "method",
      "start_line": 1335,
      "end_line": 1353,
      "content_hash": "f2a8981e15914a0a170cdf71642d2910c3f68041",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::F32(f) => f,\n            Value::F64(f) => f as f32,\n            Value::I8(i) => i as f32,\n            Value::I16(i) => i as f32,\n            Value::I32(i) => i as f32,\n            Value::I64(i) => i as f32,\n            Value::U8(i) => i as f32,\n            Value::U16(i) => i as f32,\n            Value::U32(i) => i as f32,\n            Value::U64(i) => i as f32,\n            Value::U128(i) => i as f32,\n            Value::String(s) => s.parse::<f32>().unwrap(),\n            _ => panic!(\"Value cannot be cast to f32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1354": {
      "name": "From",
      "type": "impl",
      "start_line": 1354,
      "end_line": 1354,
      "content_hash": "30d277d2381a55c6b3eaecf97405c24504c09dd2",
      "content": "impl From<Value> for f64 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1355": {
      "name": "from",
      "type": "method",
      "start_line": 1355,
      "end_line": 1379,
      "content_hash": "0e1bf1323aada1cc3b2380d7c8d9faa10e3016c6",
      "content": "    fn from(val: Value) -> Self {\n        match val {\n            Value::F64(f) => f,\n            Value::F32(f) => f as f64,\n            Value::I8(i) => i as f64,\n            Value::I16(i) => i as f64,\n            Value::I32(i) => i as f64,\n            Value::I64(i) => i as f64,\n            Value::U8(i) => i as f64,\n            Value::U16(i) => i as f64,\n            Value::U32(i) => i as f64,\n            Value::U64(i) => i as f64,\n            Value::U128(i) => i as f64,\n            Value::String(s) => s.parse::<f64>().unwrap(),\n            _ => panic!(\"Value cannot be cast to f64\"),\n        }\n    }\n}\n\npub mod casting {\n    use crate::helixc::parser::types::FieldType;\n\n    use super::*;\n\n    #[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_CastType_1380": {
      "name": "CastType",
      "type": "enum",
      "start_line": 1380,
      "end_line": 1400,
      "content_hash": "d53237225089e7203b528eb2aeb0a642e17a37b6",
      "content": "    pub enum CastType {\n        String,\n        I8,\n        I16,\n        I32,\n        I64,\n        U8,\n        U16,\n        U32,\n        U64,\n        U128,\n        F32,\n        F64,\n        Date,\n        Boolean,\n        Id,\n        Array,\n        Object,\n        Empty,\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cast_1401": {
      "name": "cast",
      "type": "method",
      "start_line": 1401,
      "end_line": 1423,
      "content_hash": "2b2ef74bdbff427a287a5f76812fd0cf5cdd58a2",
      "content": "    pub fn cast(value: Value, cast_type: CastType) -> Value {\n        match cast_type {\n            CastType::String => Value::String(value.inner_stringify()),\n            CastType::I8 => Value::I8(value.into()),\n            CastType::I16 => Value::I16(value.into()),\n            CastType::I32 => Value::I32(value.into()),\n            CastType::I64 => Value::I64(value.into()),\n            CastType::U8 => Value::U8(value.into()),\n            CastType::U16 => Value::U16(value.into()),\n            CastType::U32 => Value::U32(value.into()),\n            CastType::U64 => Value::U64(value.into()),\n            CastType::U128 => Value::U128(value.into()),\n            CastType::F32 => Value::F32(value.into()),\n            CastType::F64 => Value::F64(value.into()),\n            CastType::Date => Value::Date(value.into()),\n            CastType::Boolean => Value::Boolean(value.into()),\n            CastType::Id => Value::Id(value.into()),\n            CastType::Array => Value::Array(value.into()),\n            CastType::Object => Value::Object(value.into()),\n            CastType::Empty => Value::Empty,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::fmt::Display_1424": {
      "name": "std::fmt::Display",
      "type": "impl",
      "start_line": 1424,
      "end_line": 1424,
      "content_hash": "ce76365c2b8b4fcfd3b8572d73dd6990b023afba",
      "content": "    impl std::fmt::Display for CastType {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_1425": {
      "name": "fmt",
      "type": "method",
      "start_line": 1425,
      "end_line": 1448,
      "content_hash": "bd5ca9438e5e1a45ad7d554367dfa61b8855eb22",
      "content": "        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            match self {\n                CastType::String => write!(f, \"String\"),\n                CastType::I8 => write!(f, \"I8\"),\n                CastType::I16 => write!(f, \"I16\"),\n                CastType::I32 => write!(f, \"I32\"),\n                CastType::I64 => write!(f, \"I64\"),\n                CastType::U8 => write!(f, \"U8\"),\n                CastType::U16 => write!(f, \"U16\"),\n                CastType::U32 => write!(f, \"U32\"),\n                CastType::U64 => write!(f, \"U64\"),\n                CastType::U128 => write!(f, \"U128\"),\n                CastType::F32 => write!(f, \"F32\"),\n                CastType::F64 => write!(f, \"F64\"),\n                CastType::Date => write!(f, \"Date\"),\n                CastType::Boolean => write!(f, \"Boolean\"),\n                CastType::Id => write!(f, \"Id\"),\n                CastType::Array => write!(f, \"Array\"),\n                CastType::Object => write!(f, \"Object\"),\n                CastType::Empty => write!(f, \"Empty\"),\n            }\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_1449": {
      "name": "From",
      "type": "impl",
      "start_line": 1449,
      "end_line": 1449,
      "content_hash": "455eb7eae0cda77814f0352cc782705edef7d892",
      "content": "    impl From<FieldType> for CastType {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_1450": {
      "name": "from",
      "type": "method",
      "start_line": 1450,
      "end_line": 1474,
      "content_hash": "21474443f7df17cd288f5edf328b9104f0f3af93",
      "content": "        fn from(value: FieldType) -> Self {\n            match value {\n                FieldType::String => CastType::String,\n                FieldType::I8 => CastType::I8,\n                FieldType::I16 => CastType::I16,\n                FieldType::I32 => CastType::I32,\n                FieldType::I64 => CastType::I64,\n                FieldType::U8 => CastType::U8,\n                FieldType::U16 => CastType::U16,\n                FieldType::U32 => CastType::U32,\n                FieldType::U64 => CastType::U64,\n                FieldType::U128 => CastType::U128,\n                FieldType::F32 => CastType::F32,\n                FieldType::F64 => CastType::F64,\n                FieldType::Date => CastType::Date,\n                FieldType::Boolean => CastType::Boolean,\n                FieldType::Uuid => CastType::Id,\n                FieldType::Array(_) => CastType::Array,\n                FieldType::Object(_) => CastType::Object,\n                _ => CastType::Empty,\n            }\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_IntoPrimitive_1475": {
      "name": "IntoPrimitive",
      "type": "trait",
      "start_line": 1475,
      "end_line": 1475,
      "content_hash": "5ee8df5f2ccbc2c231630445e3004bf6411ca92d",
      "content": "pub trait IntoPrimitive<T> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1476": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1476,
      "end_line": 1478,
      "content_hash": "8b68eedd99a1335ff63fd782b55c647e988c8a99",
      "content": "    fn into_primitive(&self) -> &T;\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1479": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1479,
      "end_line": 1479,
      "content_hash": "231604a9adf8850b0db11bb8c1e50bf5813ca995",
      "content": "impl IntoPrimitive<String> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1480": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1480,
      "end_line": 1487,
      "content_hash": "2eb3d2ea65d33b27bf66e395b5503fe3da84c5ae",
      "content": "    fn into_primitive(&self) -> &String {\n        match self {\n            Value::String(s) => s,\n            _ => panic!(\"Value is not a string\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1488": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1488,
      "end_line": 1488,
      "content_hash": "29a1cc83a081c18c91fd06701e196f1ae602e0ad",
      "content": "impl IntoPrimitive<i8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1489": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1489,
      "end_line": 1496,
      "content_hash": "0e3c6c4b87d77aec8b49ab371775a9808d55d4c1",
      "content": "    fn into_primitive(&self) -> &i8 {\n        match self {\n            Value::I8(i) => i,\n            _ => panic!(\"Value is not an i8\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1497": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1497,
      "end_line": 1497,
      "content_hash": "7b6e9adf817018d9355c5eba7319aba3d879189b",
      "content": "impl IntoPrimitive<i16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1498": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1498,
      "end_line": 1505,
      "content_hash": "79ca5462456e1d9275b7b918c1721d8380aa7635",
      "content": "    fn into_primitive(&self) -> &i16 {\n        match self {\n            Value::I16(i) => i,\n            _ => panic!(\"Value is not an i16\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1506": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1506,
      "end_line": 1506,
      "content_hash": "3f578c1061d6ced6d7fa7d041b868cff84173659",
      "content": "impl IntoPrimitive<i32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1507": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1507,
      "end_line": 1514,
      "content_hash": "1264c63560b6136ba08197d6e51d30a89d3c2689",
      "content": "    fn into_primitive(&self) -> &i32 {\n        match self {\n            Value::I32(i) => i,\n            _ => panic!(\"Value is not an i32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1515": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1515,
      "end_line": 1515,
      "content_hash": "d0ee19d8b961334d8fbf4c9a757f8b63818f3731",
      "content": "impl IntoPrimitive<i64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1516": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1516,
      "end_line": 1523,
      "content_hash": "da81efecee0b6c0038544aa08588cfe06108ecef",
      "content": "    fn into_primitive(&self) -> &i64 {\n        match self {\n            Value::I64(i) => i,\n            _ => panic!(\"Value is not an i64\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1524": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1524,
      "end_line": 1524,
      "content_hash": "fad9f0357230caa609086805321ab04bb96cf2bf",
      "content": "impl IntoPrimitive<u8> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1525": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1525,
      "end_line": 1532,
      "content_hash": "35aab9ae74db53519ac2e033fd13d0f69758b5bd",
      "content": "    fn into_primitive(&self) -> &u8 {\n        match self {\n            Value::U8(i) => i,\n            _ => panic!(\"Value is not an u8\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1533": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1533,
      "end_line": 1533,
      "content_hash": "c09130701dd6fe06bfa67032b6375751aa72cb21",
      "content": "impl IntoPrimitive<u16> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1534": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1534,
      "end_line": 1541,
      "content_hash": "5f56f1ee143e4ea5e8ea2b5cc3ed93cf2fcfdb38",
      "content": "    fn into_primitive(&self) -> &u16 {\n        match self {\n            Value::U16(i) => i,\n            _ => panic!(\"Value is not an u16\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1542": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1542,
      "end_line": 1542,
      "content_hash": "04e343d3eb7b7106cf03d3b3e52b3872591057f3",
      "content": "impl IntoPrimitive<u32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1543": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1543,
      "end_line": 1550,
      "content_hash": "22efdd0537690c1a686f126a6e07d8d4b22468c6",
      "content": "    fn into_primitive(&self) -> &u32 {\n        match self {\n            Value::U32(i) => i,\n            _ => panic!(\"Value is not an u32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1551": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1551,
      "end_line": 1551,
      "content_hash": "69fb17e151dd4aeb0541f366cc4e9082827933f5",
      "content": "impl IntoPrimitive<u64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1552": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1552,
      "end_line": 1559,
      "content_hash": "07d5cdba5274879bcff1033aaff1cbea52362047",
      "content": "    fn into_primitive(&self) -> &u64 {\n        match self {\n            Value::U64(i) => i,\n            _ => panic!(\"Value is not an u64\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1560": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1560,
      "end_line": 1560,
      "content_hash": "eef5fdd1817aca57487e18b0ae932ea1489b57ff",
      "content": "impl IntoPrimitive<u128> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1561": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1561,
      "end_line": 1568,
      "content_hash": "33868170cf5c4bea4ca623fb40fa680d1d637d97",
      "content": "    fn into_primitive(&self) -> &u128 {\n        match self {\n            Value::U128(i) => i,\n            _ => panic!(\"Value is not an u128\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1569": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1569,
      "end_line": 1569,
      "content_hash": "132d17651b01a5b45058c6ae827f9246b38761dc",
      "content": "impl IntoPrimitive<f32> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1570": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1570,
      "end_line": 1577,
      "content_hash": "d23fbaf3f2193b9c6cf1971dc32694fb97570bf5",
      "content": "    fn into_primitive(&self) -> &f32 {\n        match self {\n            Value::F32(i) => i,\n            _ => panic!(\"Value is not an f32\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1578": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1578,
      "end_line": 1578,
      "content_hash": "0b65f06378664890e2070b39340b709840df6920",
      "content": "impl IntoPrimitive<f64> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1579": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1579,
      "end_line": 1586,
      "content_hash": "abbb659b65afe62bfa0f81a0ca18bae39e983fac",
      "content": "    fn into_primitive(&self) -> &f64 {\n        match self {\n            Value::F64(i) => i,\n            _ => panic!(\"Value is not an f64\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1587": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1587,
      "end_line": 1587,
      "content_hash": "ffe52190fff4d2875fa12b72130e46004fb9c555",
      "content": "impl IntoPrimitive<bool> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1588": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1588,
      "end_line": 1595,
      "content_hash": "726f30d002b014398a7e7c5f35763b990f2f5389",
      "content": "    fn into_primitive(&self) -> &bool {\n        match self {\n            Value::Boolean(i) => i,\n            _ => panic!(\"Value is not a boolean\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1596": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1596,
      "end_line": 1596,
      "content_hash": "93490b094244612156022ab146956b068ab40089",
      "content": "impl IntoPrimitive<ID> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1597": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1597,
      "end_line": 1604,
      "content_hash": "b0348deb0eecdea8a35485ddaaaf0cd2cad4fb50",
      "content": "    fn into_primitive(&self) -> &ID {\n        match self {\n            Value::Id(i) => i,\n            _ => panic!(\"Value is not an id\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1605": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1605,
      "end_line": 1605,
      "content_hash": "95e2a8d258fcd3900f6b051bbb005fe27e4e7d98",
      "content": "impl IntoPrimitive<Vec<Value>> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1606": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1606,
      "end_line": 1613,
      "content_hash": "859ca6d33cb37b21badb4f05492e2cab505a07de",
      "content": "    fn into_primitive(&self) -> &Vec<Value> {\n        match self {\n            Value::Array(i) => i,\n            _ => panic!(\"Value is not an array\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1614": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1614,
      "end_line": 1614,
      "content_hash": "8940a78f20b4e1c892a218c23d6c9a0da657b423",
      "content": "impl IntoPrimitive<HashMap<String, Value>> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1615": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1615,
      "end_line": 1622,
      "content_hash": "bfc38f3110986034a22dc2233c292097c2ea873b",
      "content": "    fn into_primitive(&self) -> &HashMap<String, Value> {\n        match self {\n            Value::Object(i) => i,\n            _ => panic!(\"Value is not an object\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoPrimitive_1623": {
      "name": "IntoPrimitive",
      "type": "impl",
      "start_line": 1623,
      "end_line": 1623,
      "content_hash": "be56d8e20ebc5276926f0264960321714b8e35cb",
      "content": "impl IntoPrimitive<Date> for Value {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_primitive_1624": {
      "name": "into_primitive",
      "type": "method",
      "start_line": 1624,
      "end_line": 1631,
      "content_hash": "253000154d604f94ec89542ed280f3b9f3fb98fd",
      "content": "    fn into_primitive(&self) -> &Date {\n        match self {\n            Value::Date(i) => i,\n            _ => panic!(\"Value is not a date\"),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Value_1632": {
      "name": "Value",
      "type": "impl",
      "start_line": 1632,
      "end_line": 1633,
      "content_hash": "ef6c0d3b104e846625556d91509c0d5d88429c19",
      "content": "impl Value {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_as_f64_1634": {
      "name": "as_f64",
      "type": "method",
      "start_line": 1634,
      "end_line": 1647,
      "content_hash": "c84b8a1bb6692365d4fcd16ef65f3fdd37abc0b8",
      "content": "    pub fn as_f64(&self) -> f64 {\n        *self.into_primitive()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // Value Creation and From Implementations\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_from_primitives_1648": {
      "name": "test_value_from_primitives",
      "type": "method",
      "start_line": 1648,
      "end_line": 1668,
      "content_hash": "e14ee6c995b7cb323e3dbbe79ff31d74c17e993a",
      "content": "    fn test_value_from_primitives() {\n        assert!(matches!(Value::from(\"test\"), Value::String(_)));\n        assert!(matches!(\n            Value::from(String::from(\"test\")),\n            Value::String(_)\n        ));\n        assert!(matches!(Value::from(true), Value::Boolean(true)));\n        assert!(matches!(Value::from(42i8), Value::I8(42)));\n        assert!(matches!(Value::from(42i16), Value::I16(42)));\n        assert!(matches!(Value::from(42i32), Value::I32(42)));\n        assert!(matches!(Value::from(42i64), Value::I64(42)));\n        assert!(matches!(Value::from(42u8), Value::U8(42)));\n        assert!(matches!(Value::from(42u16), Value::U16(42)));\n        assert!(matches!(Value::from(42u32), Value::U32(42)));\n        assert!(matches!(Value::from(42u64), Value::U64(42)));\n        assert!(matches!(Value::from(42u128), Value::U128(42)));\n        assert!(matches!(Value::from(3.14f32), Value::F32(_)));\n        assert!(matches!(Value::from(3.14f64), Value::F64(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_from_string_trims_quotes_1669": {
      "name": "test_value_from_string_trims_quotes",
      "type": "method",
      "start_line": 1669,
      "end_line": 1677,
      "content_hash": "50f652227a9de3f592d107ecab44ebce9a0209e5",
      "content": "    fn test_value_from_string_trims_quotes() {\n        let val = Value::from(\"\\\"quoted\\\"\");\n        assert_eq!(val, Value::String(\"quoted\".to_string()));\n\n        let val2 = Value::from(String::from(\"\\\"test\\\"\"));\n        assert_eq!(val2, Value::String(\"test\".to_string()));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_from_vec_1678": {
      "name": "test_value_from_vec",
      "type": "method",
      "start_line": 1678,
      "end_line": 1696,
      "content_hash": "fca6e340b4d35613ad63c01e7660e35f4c74e40a",
      "content": "    fn test_value_from_vec() {\n        let vec_vals = vec![Value::I32(1), Value::I32(2), Value::I32(3)];\n        let val = Value::from(vec_vals.clone());\n        assert!(matches!(val, Value::Array(_)));\n        if let Value::Array(arr) = val {\n            assert_eq!(arr.len(), 3);\n        }\n\n        // Test From<Vec<primitive>>\n        let vec_i64 = vec![1i64, 2i64, 3i64];\n        let val = Value::from(vec_i64);\n        assert!(matches!(val, Value::Array(_)));\n\n        let vec_str = vec![String::from(\"a\"), String::from(\"b\")];\n        let val = Value::from(vec_str);\n        assert!(matches!(val, Value::Array(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_from_usize_1697": {
      "name": "test_value_from_usize",
      "type": "method",
      "start_line": 1697,
      "end_line": 1708,
      "content_hash": "d2a2de221cc4aa68c3c7e7ae79ac0f891a238e7c",
      "content": "    fn test_value_from_usize() {\n        let val = Value::from(42usize);\n        // Should be U64 on 64-bit systems\n        if cfg!(target_pointer_width = \"64\") {\n            assert!(matches!(val, Value::U64(42)));\n        } else {\n            assert!(matches!(val, Value::U128(42)));\n        }\n    }\n\n    #[test]\n    #[ignore]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_from_datetime_1709": {
      "name": "test_value_from_datetime",
      "type": "method",
      "start_line": 1709,
      "end_line": 1726,
      "content_hash": "b3fa0b407feadd263efcdd3b6c771b600eee505a",
      "content": "    fn test_value_from_datetime() {\n        let dt = Utc::now();\n        let val = Value::from(dt);\n        // Now returns Value::Date instead of Value::String\n        assert!(matches!(val, Value::Date(_)));\n        if let Value::Date(d) = val {\n            // Should be RFC3339 format when converted to string\n            let s = d.to_rfc3339();\n            assert!(s.contains('T'));\n            assert!(s.contains('Z') || s.contains('+'));\n        }\n    }\n\n    // ============================================================================\n    // Equality Tests (PartialEq)\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_eq_1727": {
      "name": "test_value_eq",
      "type": "method",
      "start_line": 1727,
      "end_line": 1737,
      "content_hash": "08edc5c6e9dca8c7e05caf0d0b4b4e81fcbc9ad9",
      "content": "    fn test_value_eq() {\n        assert_eq!(Value::I64(1), Value::I64(1));\n        assert_eq!(Value::U64(1), Value::U64(1));\n        assert_eq!(Value::F64(1.0), Value::F64(1.0));\n        assert_eq!(Value::I64(1), Value::U64(1));\n        assert_eq!(Value::U64(1), Value::I64(1));\n        assert_eq!(Value::I32(1), 1 as i32);\n        assert_eq!(Value::U32(1), 1 as i32);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_cross_type_numeric_equality_1738": {
      "name": "test_value_cross_type_numeric_equality",
      "type": "method",
      "start_line": 1738,
      "end_line": 1753,
      "content_hash": "b5cace6d74be60c55e1783881ef74ed1df3b302e",
      "content": "    fn test_value_cross_type_numeric_equality() {\n        // Integer cross-type equality\n        assert_eq!(Value::I8(42), Value::I16(42));\n        assert_eq!(Value::I8(42), Value::I32(42));\n        assert_eq!(Value::U8(42), Value::U16(42));\n        assert_eq!(Value::U8(42), Value::I32(42));\n\n        // Float cross-type equality (use value that's exactly representable in both f32 and f64)\n        assert_eq!(Value::F32(2.0), Value::F64(2.0));\n\n        // Integer to float equality\n        assert_eq!(Value::I32(42), Value::F64(42.0));\n        assert_eq!(Value::U64(100), Value::F32(100.0));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_string_equality_1754": {
      "name": "test_value_string_equality",
      "type": "method",
      "start_line": 1754,
      "end_line": 1762,
      "content_hash": "dbe81b0cab3a7cedd84ca1ddb694227cd75ce0f1",
      "content": "    fn test_value_string_equality() {\n        let val = Value::String(\"test\".to_string());\n        assert_eq!(val, Value::String(\"test\".to_string()));\n        assert_eq!(val, String::from(\"test\"));\n        assert_eq!(val, \"test\");\n        assert_ne!(val, \"other\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_boolean_equality_1763": {
      "name": "test_value_boolean_equality",
      "type": "method",
      "start_line": 1763,
      "end_line": 1770,
      "content_hash": "dc2a8e58ffbce1fce3ad23305c82a10bbbf893cb",
      "content": "    fn test_value_boolean_equality() {\n        assert_eq!(Value::Boolean(true), Value::Boolean(true));\n        assert_eq!(Value::Boolean(true), true);\n        assert_eq!(Value::Boolean(false), false);\n        assert_ne!(Value::Boolean(true), Value::Boolean(false));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_array_equality_1771": {
      "name": "test_value_array_equality",
      "type": "method",
      "start_line": 1771,
      "end_line": 1780,
      "content_hash": "50f74004e424d7fafafce524d14846f19238dab2",
      "content": "    fn test_value_array_equality() {\n        let arr1 = Value::Array(vec![Value::I32(1), Value::I32(2)]);\n        let arr2 = Value::Array(vec![Value::I32(1), Value::I32(2)]);\n        let arr3 = Value::Array(vec![Value::I32(1), Value::I32(3)]);\n\n        assert_eq!(arr1, arr2);\n        assert_ne!(arr1, arr3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_empty_equality_1781": {
      "name": "test_value_empty_equality",
      "type": "method",
      "start_line": 1781,
      "end_line": 1791,
      "content_hash": "a06396d39424fb47961baf818f51dfb2fd429c6e",
      "content": "    fn test_value_empty_equality() {\n        assert_eq!(Value::Empty, Value::Empty);\n        assert_ne!(Value::Empty, Value::I32(0));\n        assert_ne!(Value::Empty, Value::String(String::new()));\n    }\n\n    // ============================================================================\n    // Ordering Tests (Ord, PartialOrd)\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_integers_1792": {
      "name": "test_value_ordering_integers",
      "type": "method",
      "start_line": 1792,
      "end_line": 1802,
      "content_hash": "de68e5a695bdbc9762d8eace1532544c9faaa1f3",
      "content": "    fn test_value_ordering_integers() {\n        assert!(Value::I32(1) < Value::I32(2));\n        assert!(Value::I32(2) > Value::I32(1));\n        assert!(Value::I32(1) == Value::I32(1));\n\n        // Cross-type integer ordering\n        assert!(Value::I8(10) < Value::I32(20));\n        assert!(Value::U8(5) < Value::I16(10));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_floats_1803": {
      "name": "test_value_ordering_floats",
      "type": "method",
      "start_line": 1803,
      "end_line": 1808,
      "content_hash": "29c4dd902d184f881c7ea42d1b5738da0ee9fb52",
      "content": "    fn test_value_ordering_floats() {\n        assert!(Value::F64(1.5) < Value::F64(2.5));\n        assert!(Value::F32(3.14) > Value::F32(2.71));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_strings_1809": {
      "name": "test_value_ordering_strings",
      "type": "method",
      "start_line": 1809,
      "end_line": 1814,
      "content_hash": "b115c0a028f1ec3b3442da3f31900ee647319a0c",
      "content": "    fn test_value_ordering_strings() {\n        assert!(Value::String(\"apple\".to_string()) < Value::String(\"banana\".to_string()));\n        assert!(Value::String(\"xyz\".to_string()) > Value::String(\"abc\".to_string()));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_empty_1815": {
      "name": "test_value_ordering_empty",
      "type": "method",
      "start_line": 1815,
      "end_line": 1823,
      "content_hash": "c35b3bbabfa1d19bc49d53052bc0acf2f968712a",
      "content": "    fn test_value_ordering_empty() {\n        // Empty is always less than other values\n        assert!(Value::Empty < Value::I32(0));\n        assert!(Value::Empty < Value::String(String::new()));\n        assert!(Value::Empty < Value::Boolean(false));\n        assert_eq!(Value::Empty.cmp(&Value::Empty), Ordering::Equal);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_mixed_types_1824": {
      "name": "test_value_ordering_mixed_types",
      "type": "method",
      "start_line": 1824,
      "end_line": 1833,
      "content_hash": "00b6b3d3d1dd2ae6d03c1ce4587afdf1382783cf",
      "content": "    fn test_value_ordering_mixed_types() {\n        // Non-comparable types should return Equal\n        assert_eq!(\n            Value::String(\"test\".to_string()).cmp(&Value::I32(42)),\n            Ordering::Equal\n        );\n        assert_eq!(Value::Boolean(true).cmp(&Value::F64(3.14)), Ordering::Equal);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_ordering_u128_edge_cases_1834": {
      "name": "test_value_ordering_u128_edge_cases",
      "type": "method",
      "start_line": 1834,
      "end_line": 1847,
      "content_hash": "bb09c7cf3bc628629f37980547a2e2c2c26b43b9",
      "content": "    fn test_value_ordering_u128_edge_cases() {\n        // Test U128 values that exceed i128::MAX\n        let large_u128 = u128::MAX;\n        let small_u128 = 100u128;\n\n        assert!(Value::U128(small_u128) < Value::U128(large_u128));\n        assert!(Value::U128(large_u128) > Value::U128(small_u128));\n    }\n\n    // ============================================================================\n    // Value Methods\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_stringify_1848": {
      "name": "test_inner_stringify",
      "type": "method",
      "start_line": 1848,
      "end_line": 1856,
      "content_hash": "d1ec5ddd809ba8a1bebc124c52206f50330ed21f",
      "content": "    fn test_inner_stringify() {\n        assert_eq!(Value::String(\"test\".to_string()).inner_stringify(), \"test\");\n        assert_eq!(Value::I32(42).inner_stringify(), \"42\");\n        assert_eq!(Value::F64(3.14).inner_stringify(), \"3.14\");\n        assert_eq!(Value::Boolean(true).inner_stringify(), \"true\");\n        assert_eq!(Value::U64(100).inner_stringify(), \"100\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_stringify_array_1857": {
      "name": "test_inner_stringify_array",
      "type": "method",
      "start_line": 1857,
      "end_line": 1863,
      "content_hash": "0c4d77fda5565964681875b74ab81e18a412c88b",
      "content": "    fn test_inner_stringify_array() {\n        let arr = Value::Array(vec![Value::I32(1), Value::I32(2), Value::I32(3)]);\n        let result = arr.inner_stringify();\n        assert_eq!(result, \"1 2 3\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_stringify_object_1864": {
      "name": "test_inner_stringify_object",
      "type": "method",
      "start_line": 1864,
      "end_line": 1877,
      "content_hash": "40c3d3ed3bfaccedb2e8c1f82253bf009c31f426",
      "content": "    fn test_inner_stringify_object() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\".to_string(), Value::I32(1));\n        map.insert(\"key2\".to_string(), Value::I32(2));\n\n        let obj = Value::Object(map);\n        let result = obj.inner_stringify();\n        // Order may vary, but should contain both key-value pairs\n        assert!(result.contains(\"key1\") && result.contains(\"1\"));\n        assert!(result.contains(\"key2\") && result.contains(\"2\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"Not primitive\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_stringify_empty_panics_1878": {
      "name": "test_inner_stringify_empty_panics",
      "type": "method",
      "start_line": 1878,
      "end_line": 1882,
      "content_hash": "baf84d2625c443529df3bac06bb716dcb445f8f8",
      "content": "    fn test_inner_stringify_empty_panics() {\n        Value::Empty.inner_stringify();\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_to_variant_string_1883": {
      "name": "test_to_variant_string",
      "type": "method",
      "start_line": 1883,
      "end_line": 1896,
      "content_hash": "b886bce10299fe34c45e649f769ce7083a100517",
      "content": "    fn test_to_variant_string() {\n        assert_eq!(\n            Value::String(\"test\".to_string()).to_variant_string(),\n            \"String\"\n        );\n        assert_eq!(Value::I32(42).to_variant_string(), \"I32\");\n        assert_eq!(Value::F64(3.14).to_variant_string(), \"F64\");\n        assert_eq!(Value::Boolean(true).to_variant_string(), \"Boolean\");\n        assert_eq!(Value::Empty.to_variant_string(), \"Empty\");\n        assert_eq!(Value::Array(vec![]).to_variant_string(), \"Array\");\n        assert_eq!(Value::Object(HashMap::new()).to_variant_string(), \"Object\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_as_str_1897": {
      "name": "test_as_str",
      "type": "method",
      "start_line": 1897,
      "end_line": 1903,
      "content_hash": "efe7b639aecf808e9369e3b9c133b3bb3bb3603e",
      "content": "    fn test_as_str() {\n        let val = Value::String(\"test\".to_string());\n        assert_eq!(val.as_str(), \"test\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Not a string\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_as_str_panics_on_non_string_1904": {
      "name": "test_as_str_panics_on_non_string",
      "type": "method",
      "start_line": 1904,
      "end_line": 1912,
      "content_hash": "2a5f096da9a7578b41d6063ae3220ffc93a3b2c1",
      "content": "    fn test_as_str_panics_on_non_string() {\n        Value::I32(42).as_str();\n    }\n\n    // ============================================================================\n    // Serialization/Deserialization\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_json_serialization_1913": {
      "name": "test_json_serialization",
      "type": "method",
      "start_line": 1913,
      "end_line": 1928,
      "content_hash": "8be583537cfd85522bdf700ea1e801a3e631db0d",
      "content": "    fn test_json_serialization() {\n        // JSON should serialize without enum variant names\n        let val = Value::I32(42);\n        let json = sonic_rs::to_string(&val).unwrap();\n        assert_eq!(json, \"42\");\n\n        let val = Value::String(\"test\".to_string());\n        let json = sonic_rs::to_string(&val).unwrap();\n        assert_eq!(json, \"\\\"test\\\"\");\n\n        let val = Value::Boolean(true);\n        let json = sonic_rs::to_string(&val).unwrap();\n        assert_eq!(json, \"true\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_json_deserialization_1929": {
      "name": "test_json_deserialization",
      "type": "method",
      "start_line": 1929,
      "end_line": 1943,
      "content_hash": "40759a07c95dabed4be14b777f4cf7ebfa444937",
      "content": "    fn test_json_deserialization() {\n        let val: Value = sonic_rs::from_str(\"42\").unwrap();\n        assert_eq!(val, Value::I64(42)); // JSON integers default to I64\n\n        let val: Value = sonic_rs::from_str(\"\\\"test\\\"\").unwrap();\n        assert_eq!(val, Value::String(\"test\".to_string()));\n\n        let val: Value = sonic_rs::from_str(\"true\").unwrap();\n        assert_eq!(val, Value::Boolean(true));\n\n        let val: Value = sonic_rs::from_str(\"3.14\").unwrap();\n        assert!(matches!(val, Value::F64(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_json_array_serialization_1944": {
      "name": "test_json_array_serialization",
      "type": "method",
      "start_line": 1944,
      "end_line": 1950,
      "content_hash": "01f866fd7a08e5f1fbdbc228d061a299d6f4a40e",
      "content": "    fn test_json_array_serialization() {\n        let arr = Value::Array(vec![Value::I32(1), Value::I32(2), Value::I32(3)]);\n        let json = sonic_rs::to_string(&arr).unwrap();\n        assert_eq!(json, \"[1,2,3]\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_json_object_serialization_1951": {
      "name": "test_json_object_serialization",
      "type": "method",
      "start_line": 1951,
      "end_line": 1960,
      "content_hash": "e0c272758b8739168b706094bc9c060bf0cccb12",
      "content": "    fn test_json_object_serialization() {\n        let mut map = HashMap::new();\n        map.insert(\"key\".to_string(), Value::String(\"value\".to_string()));\n        let obj = Value::Object(map);\n        let json = sonic_rs::to_string(&obj).unwrap();\n        assert!(json.contains(\"\\\"key\\\"\"));\n        assert!(json.contains(\"\\\"value\\\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_bincode_serialization_roundtrip_1961": {
      "name": "test_bincode_serialization_roundtrip",
      "type": "method",
      "start_line": 1961,
      "end_line": 1982,
      "content_hash": "5934bfc6b3124aef889d19e320d0e40ab45ac42d",
      "content": "    fn test_bincode_serialization_roundtrip() {\n        let test_values = vec![\n            Value::String(\"test\".to_string()),\n            Value::I32(42),\n            Value::F64(3.14),\n            Value::Boolean(true),\n            Value::U128(u128::MAX),\n            Value::Empty,\n            Value::Array(vec![Value::I32(1), Value::I32(2)]),\n        ];\n\n        for val in test_values {\n            let encoded = bincode::serialize(&val).unwrap();\n            let decoded: Value = bincode::deserialize(&encoded).unwrap();\n            assert_eq!(val, decoded);\n        }\n    }\n    // ============================================================================\n    // Type Conversions (Into implementations)\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_primitives_1983": {
      "name": "test_value_into_primitives",
      "type": "method",
      "start_line": 1983,
      "end_line": 2001,
      "content_hash": "9180e2c30590123259d60c01ac4ec90d520f0cb7",
      "content": "    fn test_value_into_primitives() {\n        let val = Value::I32(42);\n        let i: i32 = val.into();\n        assert_eq!(i, 42);\n\n        let val = Value::F64(3.14);\n        let f: f64 = val.into();\n        assert_eq!(f, 3.14);\n\n        let val = Value::Boolean(true);\n        let b: bool = val.into();\n        assert_eq!(b, true);\n\n        let val = Value::String(\"test\".to_string());\n        let s: String = val.into();\n        assert_eq!(s, \"test\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_cross_type_conversion_2002": {
      "name": "test_value_into_cross_type_conversion",
      "type": "method",
      "start_line": 2002,
      "end_line": 2019,
      "content_hash": "cd770ae8c127506934f746db1ca2c240f8ade35c",
      "content": "    fn test_value_into_cross_type_conversion() {\n        // I32 to I64\n        let val = Value::I32(42);\n        let i: i64 = val.into();\n        assert_eq!(i, 42);\n\n        // U8 to U32\n        let val = Value::U8(255);\n        let u: u32 = val.into();\n        assert_eq!(u, 255);\n\n        // I32 to F32\n        let val = Value::I32(42);\n        let f: f32 = val.into();\n        assert_eq!(f, 42.0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_string_parsing_conversion_2020": {
      "name": "test_value_string_parsing_conversion",
      "type": "method",
      "start_line": 2020,
      "end_line": 2031,
      "content_hash": "402291b94ec167725df718fb6ad007745ca1adbe",
      "content": "    fn test_value_string_parsing_conversion() {\n        let val = Value::String(\"42\".to_string());\n        let i: i32 = val.into();\n        assert_eq!(i, 42);\n\n        let val = Value::String(\"3.14\".to_string());\n        let f: f64 = val.into();\n        assert_eq!(f, 3.14);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Value is not a string\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_string_panics_on_non_string_2032": {
      "name": "test_value_into_string_panics_on_non_string",
      "type": "method",
      "start_line": 2032,
      "end_line": 2038,
      "content_hash": "8fd80c3ca3d036a859d6a423735d8d88ef7076c4",
      "content": "    fn test_value_into_string_panics_on_non_string() {\n        let val = Value::I32(42);\n        let _: String = val.into();\n    }\n\n    #[test]\n    #[should_panic(expected = \"Value cannot be cast to boolean\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_bool_panics_on_non_boolean_2039": {
      "name": "test_value_into_bool_panics_on_non_boolean",
      "type": "method",
      "start_line": 2039,
      "end_line": 2044,
      "content_hash": "44cc0c409cd827c16980219875132058452a2558",
      "content": "    fn test_value_into_bool_panics_on_non_boolean() {\n        let val = Value::I32(1);\n        let _: bool = val.into();\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_array_2045": {
      "name": "test_value_into_array",
      "type": "method",
      "start_line": 2045,
      "end_line": 2053,
      "content_hash": "bb5a70cbaba25a5358c0345fa3e96df3d9e76cc3",
      "content": "    fn test_value_into_array() {\n        let arr = vec![Value::I32(1), Value::I32(2)];\n        let val = Value::Array(arr.clone());\n        let result: Vec<Value> = val.into();\n        assert_eq!(result, arr);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Value cannot be cast to array\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_into_array_panics_on_non_array_2054": {
      "name": "test_value_into_array_panics_on_non_array",
      "type": "method",
      "start_line": 2054,
      "end_line": 2063,
      "content_hash": "c8545b14fd5697bab9fc78782fbb0eeaff7fd304",
      "content": "    fn test_value_into_array_panics_on_non_array() {\n        let val = Value::I32(42);\n        let _: Vec<Value> = val.into();\n    }\n\n    // ============================================================================\n    // IntoPrimitive Trait\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_into_primitive_2064": {
      "name": "test_into_primitive",
      "type": "method",
      "start_line": 2064,
      "end_line": 2079,
      "content_hash": "b4ab3dddd4e7cf2b575bc9c439684c31567900c4",
      "content": "    fn test_into_primitive() {\n        let val = Value::I32(42);\n        let i: &i32 = val.into_primitive();\n        assert_eq!(*i, 42);\n\n        let val = Value::Boolean(true);\n        let b: &bool = val.into_primitive();\n        assert_eq!(*b, true);\n\n        let val = Value::String(\"test\".to_string());\n        let s = val.as_str();\n        assert_eq!(s, \"test\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Value is not an i32\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_into_primitive_panics_on_wrong_type_2080": {
      "name": "test_into_primitive_panics_on_wrong_type",
      "type": "method",
      "start_line": 2080,
      "end_line": 2089,
      "content_hash": "6fdebdf9df68f4dee5fe11b7d8b6058c7d9c6d90",
      "content": "    fn test_into_primitive_panics_on_wrong_type() {\n        let val = Value::I64(42);\n        let _: &i32 = val.into_primitive();\n    }\n\n    // ============================================================================\n    // Edge Cases and UTF-8\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_utf8_strings_2090": {
      "name": "test_value_utf8_strings",
      "type": "method",
      "start_line": 2090,
      "end_line": 2111,
      "content_hash": "ce1051ccf9a72bb9c96ab2f91174bc571bef8cfb",
      "content": "    fn test_value_utf8_strings() {\n        let utf8_strings = vec![\n            \"Hello\",\n            \"\u4e16\u754c\",   // Chinese\n            \"\ud83d\ude80\ud83c\udf1f\",   // Emojis\n            \"\u041f\u0440\u0438\u0432\u0435\u0442\", // Russian\n            \"\u0645\u0631\u062d\u0628\u0627\",  // Arabic\n            \"\u00d1o\u00f1o\",   // Spanish with tildes\n        ];\n\n        for s in utf8_strings {\n            let val = Value::String(s.to_string());\n            assert_eq!(val.inner_stringify(), s);\n\n            // Test serialization roundtrip\n            let json = sonic_rs::to_string(&val).unwrap();\n            let decoded: Value = sonic_rs::from_str(&json).unwrap();\n            assert_eq!(val, decoded);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_large_numbers_2112": {
      "name": "test_value_large_numbers",
      "type": "method",
      "start_line": 2112,
      "end_line": 2123,
      "content_hash": "abfc7d24ec8d3e87f95fa806a198a071c46ee126",
      "content": "    fn test_value_large_numbers() {\n        let val = Value::U128(u128::MAX);\n        assert_eq!(val, Value::U128(u128::MAX));\n\n        let val = Value::I64(i64::MAX);\n        assert_eq!(val, Value::I64(i64::MAX));\n\n        let val = Value::I64(i64::MIN);\n        assert_eq!(val, Value::I64(i64::MIN));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_nested_arrays_2124": {
      "name": "test_value_nested_arrays",
      "type": "method",
      "start_line": 2124,
      "end_line": 2138,
      "content_hash": "2fe0d3695d362c124f86babefc06da60c1a82456",
      "content": "    fn test_value_nested_arrays() {\n        let inner = vec![Value::I32(1), Value::I32(2)];\n        let outer = Value::Array(vec![\n            Value::Array(inner.clone()),\n            Value::Array(inner.clone()),\n        ]);\n\n        assert!(matches!(outer, Value::Array(_)));\n        if let Value::Array(arr) = outer {\n            assert_eq!(arr.len(), 2);\n            assert!(matches!(arr[0], Value::Array(_)));\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_nested_objects_2139": {
      "name": "test_value_nested_objects",
      "type": "method",
      "start_line": 2139,
      "end_line": 2150,
      "content_hash": "833b79604ada854d69ba822163f508e1188e3266",
      "content": "    fn test_value_nested_objects() {\n        let mut inner = HashMap::new();\n        inner.insert(\"inner_key\".to_string(), Value::I32(42));\n\n        let mut outer = HashMap::new();\n        outer.insert(\"outer_key\".to_string(), Value::Object(inner));\n\n        let val = Value::Object(outer);\n        assert!(matches!(val, Value::Object(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_empty_collections_2151": {
      "name": "test_value_empty_collections",
      "type": "method",
      "start_line": 2151,
      "end_line": 2163,
      "content_hash": "d64f1b453a22c4e4b3b4d43be78b63ac1b61d30c",
      "content": "    fn test_value_empty_collections() {\n        let empty_arr = Value::Array(vec![]);\n        assert_eq!(empty_arr.inner_stringify(), \"\");\n\n        let empty_obj = Value::Object(HashMap::new());\n        assert_eq!(empty_obj.inner_stringify(), \"\");\n    }\n\n    // ============================================================================\n    // Casting Module\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cast_to_string_2164": {
      "name": "test_cast_to_string",
      "type": "method",
      "start_line": 2164,
      "end_line": 2170,
      "content_hash": "dee51cbd3e993835fd173e109b88a76de63b416e",
      "content": "    fn test_cast_to_string() {\n        let val = Value::I32(42);\n        let result = casting::cast(val, casting::CastType::String);\n        assert_eq!(result, Value::String(\"42\".to_string()));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cast_between_numeric_types_2171": {
      "name": "test_cast_between_numeric_types",
      "type": "method",
      "start_line": 2171,
      "end_line": 2181,
      "content_hash": "340817ee348b306cd5b3a9981d25d86e5940c5bc",
      "content": "    fn test_cast_between_numeric_types() {\n        let val = Value::I32(42);\n        let result = casting::cast(val, casting::CastType::I64);\n        assert_eq!(result, Value::I64(42));\n\n        let val = Value::F64(3.14);\n        let result = casting::cast(val, casting::CastType::F32);\n        assert!(matches!(result, Value::F32(_)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cast_to_empty_2182": {
      "name": "test_cast_to_empty",
      "type": "method",
      "start_line": 2182,
      "end_line": 2192,
      "content_hash": "7b89b7e997ab350bd518f6bdde518b1a06bd87b3",
      "content": "    fn test_cast_to_empty() {\n        let val = Value::I32(42);\n        let result = casting::cast(val, casting::CastType::Empty);\n        assert_eq!(result, Value::Empty);\n    }\n\n    // ============================================================================\n    // Additional Edge Case Tests for inner_str()\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_string_returns_borrowed_2193": {
      "name": "test_inner_str_string_returns_borrowed",
      "type": "method",
      "start_line": 2193,
      "end_line": 2200,
      "content_hash": "729d19cc265f48ca8bf53361f7b754fcf8e4104a",
      "content": "    fn test_inner_str_string_returns_borrowed() {\n        let val = Value::String(\"test\".to_string());\n        let cow = val.inner_str();\n        assert!(matches!(cow, std::borrow::Cow::Borrowed(_)));\n        assert_eq!(&*cow, \"test\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_numeric_returns_owned_2201": {
      "name": "test_inner_str_numeric_returns_owned",
      "type": "method",
      "start_line": 2201,
      "end_line": 2208,
      "content_hash": "575be0416da7ef6a7c10ce6b239faa32d750fd53",
      "content": "    fn test_inner_str_numeric_returns_owned() {\n        let val = Value::I32(42);\n        let cow = val.inner_str();\n        assert!(matches!(cow, std::borrow::Cow::Owned(_)));\n        assert_eq!(&*cow, \"42\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_boolean_returns_borrowed_2209": {
      "name": "test_inner_str_boolean_returns_borrowed",
      "type": "method",
      "start_line": 2209,
      "end_line": 2221,
      "content_hash": "86df991435c47bc4e529ce9f963b4377aadc6d52",
      "content": "    fn test_inner_str_boolean_returns_borrowed() {\n        let val_true = Value::Boolean(true);\n        let cow_true = val_true.inner_str();\n        assert!(matches!(cow_true, std::borrow::Cow::Borrowed(_)));\n        assert_eq!(&*cow_true, \"true\");\n\n        let val_false = Value::Boolean(false);\n        let cow_false = val_false.inner_str();\n        assert!(matches!(cow_false, std::borrow::Cow::Borrowed(_)));\n        assert_eq!(&*cow_false, \"false\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_all_numeric_types_2222": {
      "name": "test_inner_str_all_numeric_types",
      "type": "method",
      "start_line": 2222,
      "end_line": 2234,
      "content_hash": "56a435d08be7e0130483bbed7216e9bf181af3ac",
      "content": "    fn test_inner_str_all_numeric_types() {\n        assert_eq!(&*Value::I8(-42).inner_str(), \"-42\");\n        assert_eq!(&*Value::I16(-1000).inner_str(), \"-1000\");\n        assert_eq!(&*Value::I32(-100000).inner_str(), \"-100000\");\n        assert_eq!(&*Value::I64(-1000000000).inner_str(), \"-1000000000\");\n        assert_eq!(&*Value::U8(255).inner_str(), \"255\");\n        assert_eq!(&*Value::U16(65535).inner_str(), \"65535\");\n        assert_eq!(&*Value::U32(4294967295).inner_str(), \"4294967295\");\n        assert_eq!(&*Value::U64(18446744073709551615).inner_str(), \"18446744073709551615\");\n        assert_eq!(&*Value::U128(u128::MAX).inner_str(), u128::MAX.to_string());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_float_precision_2235": {
      "name": "test_inner_str_float_precision",
      "type": "method",
      "start_line": 2235,
      "end_line": 2242,
      "content_hash": "c5d0cfd240f428790a3b78a1f3655d4c8c764d18",
      "content": "    fn test_inner_str_float_precision() {\n        let val = Value::F64(3.141592653589793);\n        let cow = val.inner_str();\n        assert!(cow.starts_with(\"3.14159\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"Not primitive\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_empty_panics_2243": {
      "name": "test_inner_str_empty_panics",
      "type": "method",
      "start_line": 2243,
      "end_line": 2248,
      "content_hash": "e8ad74f1bf294e44771ccf4f667cfdc3d6a58b3f",
      "content": "    fn test_inner_str_empty_panics() {\n        Value::Empty.inner_str();\n    }\n\n    #[test]\n    #[should_panic(expected = \"Not primitive\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_str_array_panics_2249": {
      "name": "test_inner_str_array_panics",
      "type": "method",
      "start_line": 2249,
      "end_line": 2257,
      "content_hash": "d4e61f33576de1f49c606317209cffbb886ae0dd",
      "content": "    fn test_inner_str_array_panics() {\n        Value::Array(vec![Value::I32(1)]).inner_str();\n    }\n\n    // ============================================================================\n    // contains() Method Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_contains_string_with_substring_2258": {
      "name": "test_contains_string_with_substring",
      "type": "method",
      "start_line": 2258,
      "end_line": 2266,
      "content_hash": "61f86e42e595b30b439bfd5a0942c5d288d40f66",
      "content": "    fn test_contains_string_with_substring() {\n        let val = Value::String(\"hello world\".to_string());\n        assert!(val.contains(\"world\"));\n        assert!(val.contains(\"hello\"));\n        assert!(val.contains(\"o w\"));\n        assert!(val.contains(\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_contains_string_without_substring_2267": {
      "name": "test_contains_string_without_substring",
      "type": "method",
      "start_line": 2267,
      "end_line": 2273,
      "content_hash": "88e366bbdffea82a451717bdb51fb1d9b5dfe4fa",
      "content": "    fn test_contains_string_without_substring() {\n        let val = Value::String(\"hello world\".to_string());\n        assert!(!val.contains(\"xyz\"));\n        assert!(!val.contains(\"World\")); // Case sensitive\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_contains_numeric_converted_to_string_2274": {
      "name": "test_contains_numeric_converted_to_string",
      "type": "method",
      "start_line": 2274,
      "end_line": 2282,
      "content_hash": "7964031c5812c9634c9fc203b3c1cd2162c4c73f",
      "content": "    fn test_contains_numeric_converted_to_string() {\n        let val = Value::I32(12345);\n        assert!(val.contains(\"123\"));\n        assert!(val.contains(\"345\"));\n        assert!(val.contains(\"12345\"));\n        assert!(!val.contains(\"999\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_contains_boolean_2283": {
      "name": "test_contains_boolean",
      "type": "method",
      "start_line": 2283,
      "end_line": 2298,
      "content_hash": "f55dd040acc6ba582467e2e5f3bf1f2d69895df5",
      "content": "    fn test_contains_boolean() {\n        let val_true = Value::Boolean(true);\n        assert!(val_true.contains(\"true\"));\n        assert!(val_true.contains(\"ru\"));\n        assert!(!val_true.contains(\"false\"));\n\n        let val_false = Value::Boolean(false);\n        assert!(val_false.contains(\"false\"));\n        assert!(val_false.contains(\"als\"));\n    }\n\n    // ============================================================================\n    // to_variant_string() Complete Coverage\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_to_variant_string_all_variants_2299": {
      "name": "test_to_variant_string_all_variants",
      "type": "method",
      "start_line": 2299,
      "end_line": 2322,
      "content_hash": "5d80e0ad54954df4c2fef64be1109ada4381d9cc",
      "content": "    fn test_to_variant_string_all_variants() {\n        assert_eq!(Value::String(\"\".to_string()).to_variant_string(), \"String\");\n        assert_eq!(Value::F32(0.0).to_variant_string(), \"F32\");\n        assert_eq!(Value::F64(0.0).to_variant_string(), \"F64\");\n        assert_eq!(Value::I8(0).to_variant_string(), \"I8\");\n        assert_eq!(Value::I16(0).to_variant_string(), \"I16\");\n        assert_eq!(Value::I32(0).to_variant_string(), \"I32\");\n        assert_eq!(Value::I64(0).to_variant_string(), \"I64\");\n        assert_eq!(Value::U8(0).to_variant_string(), \"U8\");\n        assert_eq!(Value::U16(0).to_variant_string(), \"U16\");\n        assert_eq!(Value::U32(0).to_variant_string(), \"U32\");\n        assert_eq!(Value::U64(0).to_variant_string(), \"U64\");\n        assert_eq!(Value::U128(0).to_variant_string(), \"U128\");\n        assert_eq!(Value::Boolean(false).to_variant_string(), \"Boolean\");\n        assert_eq!(Value::Empty.to_variant_string(), \"Empty\");\n        assert_eq!(Value::Array(vec![]).to_variant_string(), \"Array\");\n        assert_eq!(Value::Object(HashMap::new()).to_variant_string(), \"Object\");\n    }\n\n    // ============================================================================\n    // Float Edge Cases (NaN, Infinity)\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_float_nan_ordering_2323": {
      "name": "test_float_nan_ordering",
      "type": "method",
      "start_line": 2323,
      "end_line": 2331,
      "content_hash": "c459a944b00ecfc4219e17a8ce69e19d0ae47d3a",
      "content": "    fn test_float_nan_ordering() {\n        let nan = Value::F64(f64::NAN);\n        let num = Value::F64(1.0);\n        // NaN comparisons should return Equal as per the implementation\n        assert_eq!(nan.cmp(&num), Ordering::Equal);\n        assert_eq!(nan.cmp(&nan), Ordering::Equal);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_float_infinity_2332": {
      "name": "test_float_infinity",
      "type": "method",
      "start_line": 2332,
      "end_line": 2342,
      "content_hash": "89133663200a554d35bc90c96876d4e9706b7131",
      "content": "    fn test_float_infinity() {\n        let inf = Value::F64(f64::INFINITY);\n        let neg_inf = Value::F64(f64::NEG_INFINITY);\n        let num = Value::F64(1000.0);\n\n        assert!(inf > num);\n        assert!(neg_inf < num);\n        assert!(inf > neg_inf);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_float_negative_zero_2343": {
      "name": "test_float_negative_zero",
      "type": "method",
      "start_line": 2343,
      "end_line": 2354,
      "content_hash": "effc17f564d0d34bbf53fffa6a478720d633184b",
      "content": "    fn test_float_negative_zero() {\n        let pos_zero = Value::F64(0.0);\n        let neg_zero = Value::F64(-0.0);\n        // IEEE 754: 0.0 == -0.0\n        assert_eq!(pos_zero, neg_zero);\n    }\n\n    // ============================================================================\n    // inner_stringify() Complete Coverage\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_inner_stringify_all_numeric_types_2355": {
      "name": "test_inner_stringify_all_numeric_types",
      "type": "method",
      "start_line": 2355,
      "end_line": 2373,
      "content_hash": "24f91c59f25e6ad174d6f99bae7dbc396b6f654f",
      "content": "    fn test_inner_stringify_all_numeric_types() {\n        assert_eq!(Value::I8(-128).inner_stringify(), \"-128\");\n        assert_eq!(Value::I8(127).inner_stringify(), \"127\");\n        assert_eq!(Value::I16(-32768).inner_stringify(), \"-32768\");\n        assert_eq!(Value::I32(i32::MIN).inner_stringify(), i32::MIN.to_string());\n        assert_eq!(Value::I64(i64::MAX).inner_stringify(), i64::MAX.to_string());\n        assert_eq!(Value::U8(0).inner_stringify(), \"0\");\n        assert_eq!(Value::U8(255).inner_stringify(), \"255\");\n        assert_eq!(Value::U16(65535).inner_stringify(), \"65535\");\n        assert_eq!(Value::U32(u32::MAX).inner_stringify(), u32::MAX.to_string());\n        assert_eq!(Value::U64(u64::MAX).inner_stringify(), u64::MAX.to_string());\n        assert_eq!(Value::U128(u128::MAX).inner_stringify(), u128::MAX.to_string());\n    }\n\n    // ============================================================================\n    // Numeric Cross-Type Comparison Edge Cases\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_numeric_cross_type_ordering_2374": {
      "name": "test_numeric_cross_type_ordering",
      "type": "method",
      "start_line": 2374,
      "end_line": 2381,
      "content_hash": "f8c2e5406573719a27836ad50fa9c9c8d8e74b74",
      "content": "    fn test_numeric_cross_type_ordering() {\n        // Compare different integer types\n        assert!(Value::I8(10) < Value::I64(100));\n        assert!(Value::U8(50) > Value::I8(25));\n        assert!(Value::U64(1000) > Value::I16(500));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_u128_greater_than_i128_max_2382": {
      "name": "test_u128_greater_than_i128_max",
      "type": "method",
      "start_line": 2382,
      "end_line": 2389,
      "content_hash": "a3b9d3b1813c5c7e5179cc31055058b2fdf8d019",
      "content": "    fn test_u128_greater_than_i128_max() {\n        let large = Value::U128((i128::MAX as u128) + 1);\n        let small = Value::U128(100);\n        // When one U128 exceeds i128::MAX, special handling applies\n        assert!(large > small);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_u128_comparison_both_large_2390": {
      "name": "test_u128_comparison_both_large",
      "type": "method",
      "start_line": 2390,
      "end_line": 2400,
      "content_hash": "11d1c14080add85c8822e3caa3fa4b1cf37bc45b",
      "content": "    fn test_u128_comparison_both_large() {\n        let a = Value::U128(u128::MAX);\n        let b = Value::U128(u128::MAX - 1);\n        assert!(a > b);\n    }\n\n    // ============================================================================\n    // Default Trait\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_default_is_empty_2401": {
      "name": "test_value_default_is_empty",
      "type": "method",
      "start_line": 2401,
      "end_line": 2410,
      "content_hash": "523bb9cf6efcc07c0252b4a3a8cf5496040c5704",
      "content": "    fn test_value_default_is_empty() {\n        let val: Value = Default::default();\n        assert!(matches!(val, Value::Empty));\n    }\n\n    // ============================================================================\n    // Clone Trait\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_value_clone_2411": {
      "name": "test_value_clone",
      "type": "method",
      "start_line": 2411,
      "end_line": 2420,
      "content_hash": "8bca92ab235f9fd21457e7dcd48e57a93edd04f0",
      "content": "    fn test_value_clone() {\n        let original = Value::String(\"test\".to_string());\n        let cloned = original.clone();\n        assert_eq!(original, cloned);\n\n        let arr_original = Value::Array(vec![Value::I32(1), Value::I32(2)]);\n        let arr_cloned = arr_original.clone();\n        assert_eq!(arr_original, arr_cloned);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}