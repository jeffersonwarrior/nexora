{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/tests/gateway_tests.rs",
  "file_hash": "8d45d21d7686e9f8e938b0665a6e6214ba7aa440",
  "updated_at": "2025-12-26T17:34:22.169029",
  "symbols": {
    "function_create_test_graph_12": {
      "name": "create_test_graph",
      "type": "function",
      "start_line": 12,
      "end_line": 27,
      "content_hash": "7c48aa707d3be65dbe1b139ac276f01b96779441",
      "content": "fn create_test_graph() -> (Arc<HelixGraphEngine>, TempDir) {\n    let temp_dir = TempDir::new().unwrap();\n    let opts = HelixGraphEngineOpts {\n        path: temp_dir.path().to_str().unwrap().to_string(),\n        config: Config::default(),\n        version_info: Default::default(),\n    };\n    let graph = Arc::new(HelixGraphEngine::new(opts).unwrap());\n    (graph, temp_dir)\n}\n\n// ============================================================================\n// HelixGateway Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_new_basic_28": {
      "name": "test_gateway_new_basic",
      "type": "function",
      "start_line": 28,
      "end_line": 37,
      "content_hash": "f4ac9a068f13db62f2ce947f506d34cc1b72d718",
      "content": "fn test_gateway_new_basic() {\n    let (graph, _temp_dir) = create_test_graph();\n    let gateway = HelixGateway::new(\"127.0.0.1:8080\", graph, 8, None, None, None, None);\n\n    assert_eq!(gateway.address, \"127.0.0.1:8080\");\n    assert_eq!(gateway.workers_per_core, 8);\n    assert!(gateway.opts.is_none());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_new_with_routes_38": {
      "name": "test_gateway_new_with_routes",
      "type": "function",
      "start_line": 38,
      "end_line": 47,
      "content_hash": "0a97788a51473fdda1b12c2182d3e9e7c717cf3e",
      "content": "fn test_gateway_new_with_routes() {\n    let (graph, _temp_dir) = create_test_graph();\n    let routes = HashMap::new();\n    let gateway = HelixGateway::new(\"127.0.0.1:8080\", graph, 8, Some(routes), None, None, None);\n\n    assert_eq!(gateway.address, \"127.0.0.1:8080\");\n    assert!(gateway.router.routes.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_new_with_mcp_routes_48": {
      "name": "test_gateway_new_with_mcp_routes",
      "type": "function",
      "start_line": 48,
      "end_line": 57,
      "content_hash": "9935b8039f6ff0fcf571a9d544eb20b99fa287c4",
      "content": "fn test_gateway_new_with_mcp_routes() {\n    let (graph, _temp_dir) = create_test_graph();\n    let mcp_routes = HashMap::new();\n    let gateway = HelixGateway::new(\"127.0.0.1:8080\", graph, 8, None, Some(mcp_routes), None, None);\n\n    assert_eq!(gateway.address, \"127.0.0.1:8080\");\n    assert!(gateway.router.mcp_routes.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_new_with_opts_58": {
      "name": "test_gateway_new_with_opts",
      "type": "function",
      "start_line": 58,
      "end_line": 70,
      "content_hash": "b6c871b4d7d2fd809944276bcd155851b42e4e10",
      "content": "fn test_gateway_new_with_opts() {\n    let (graph, temp_dir) = create_test_graph();\n    let opts = HelixGraphEngineOpts {\n        path: temp_dir.path().to_str().unwrap().to_string(),\n        config: Config::default(),\n        version_info: Default::default(),\n    };\n    let gateway = HelixGateway::new(\"127.0.0.1:8080\", graph, 8, None, None, None, Some(opts));\n\n    assert!(gateway.opts.is_some());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_new_with_cluster_id_71": {
      "name": "test_gateway_new_with_cluster_id",
      "type": "function",
      "start_line": 71,
      "end_line": 85,
      "content_hash": "60cc6a8add388cf6aee4f43a81eea1ca0c90344e",
      "content": "fn test_gateway_new_with_cluster_id() {\n    unsafe {\n        std::env::set_var(\"CLUSTER_ID\", \"test-cluster-123\");\n    }\n    let (graph, _temp_dir) = create_test_graph();\n    let gateway = HelixGateway::new(\"127.0.0.1:8080\", graph, 8, None, None, None, None);\n\n    assert!(gateway.cluster_id.is_some());\n    assert_eq!(gateway.cluster_id.unwrap(), \"test-cluster-123\");\n    unsafe {\n        std::env::remove_var(\"CLUSTER_ID\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_fields_86": {
      "name": "test_gateway_fields",
      "type": "function",
      "start_line": 86,
      "end_line": 94,
      "content_hash": "f38991f285818d08d3127bc9a139e04169054cc1",
      "content": "fn test_gateway_fields() {\n    let (graph, _temp_dir) = create_test_graph();\n    let gateway = HelixGateway::new(\"0.0.0.0:3000\", graph, 10, None, None, None, None);\n\n    assert_eq!(gateway.address, \"0.0.0.0:3000\");\n    assert_eq!(gateway.workers_per_core, 10);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_address_format_95": {
      "name": "test_gateway_address_format",
      "type": "function",
      "start_line": 95,
      "end_line": 104,
      "content_hash": "2b903035ddc36361947fec4e2968891eedcf445e",
      "content": "fn test_gateway_address_format() {\n    let (graph, _temp_dir) = create_test_graph();\n    let gateway = HelixGateway::new(\"localhost:8080\", graph.clone(), 1, None, None, None, None);\n    assert_eq!(gateway.address, \"localhost:8080\");\n\n    let gateway2 = HelixGateway::new(\"0.0.0.0:80\", graph, 1, None, None, None, None);\n    assert_eq!(gateway2.address, \"0.0.0.0:80\");\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_workers_per_core_105": {
      "name": "test_gateway_workers_per_core",
      "type": "function",
      "start_line": 105,
      "end_line": 130,
      "content_hash": "1890997669a6962fe6ddc4bea3fb6ca9dda3e462",
      "content": "fn test_gateway_workers_per_core() {\n    let (graph, _temp_dir) = create_test_graph();\n\n    let gateway1 = HelixGateway::new(\"127.0.0.1:8080\", graph.clone(), 1, None, None, None, None);\n    assert_eq!(gateway1.workers_per_core, 1);\n\n    let gateway2 = HelixGateway::new(\"127.0.0.1:8080\", graph.clone(), 10, None, None, None, None);\n    assert_eq!(gateway2.workers_per_core, 10);\n\n    let gateway3 = HelixGateway::new(\n        \"127.0.0.1:8080\",\n        graph,\n        GatewayOpts::DEFAULT_WORKERS_PER_CORE,\n        None,\n        None,\n        None,\n        None,\n    );\n    assert_eq!(gateway3.workers_per_core, 8);\n}\n\n// ============================================================================\n// AppState Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_app_state_creation_131": {
      "name": "test_app_state_creation",
      "type": "function",
      "start_line": 131,
      "end_line": 156,
      "content_hash": "16fc47ce46b3028fc51169d81a62120eac708879",
      "content": "fn test_app_state_creation() {\n    let (graph, _temp_dir) = create_test_graph();\n    let router = Arc::new(HelixRouter::new(None, None, None));\n    let rt = Arc::new(\n        tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(1)\n            .enable_all()\n            .build()\n            .unwrap(),\n    );\n\n    let cores = core_affinity::get_core_ids().unwrap_or_default();\n    let core_setter = Arc::new(CoreSetter::new(cores, 2));\n    let worker_pool = WorkerPool::new(core_setter, graph, router, rt);\n\n    let state = AppState {\n        worker_pool,\n        schema_json: None,\n        cluster_id: None,\n    };\n\n    assert!(state.schema_json.is_none());\n    assert!(state.cluster_id.is_none());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_app_state_with_schema_157": {
      "name": "test_app_state_with_schema",
      "type": "function",
      "start_line": 157,
      "end_line": 182,
      "content_hash": "ad7bc3a13af0a6d54b5368d72d6758d5ade035ef",
      "content": "fn test_app_state_with_schema() {\n    let (graph, _temp_dir) = create_test_graph();\n    let router = Arc::new(HelixRouter::new(None, None, None));\n    let rt = Arc::new(\n        tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(1)\n            .enable_all()\n            .build()\n            .unwrap(),\n    );\n\n    let cores = core_affinity::get_core_ids().unwrap_or_default();\n    let core_setter = Arc::new(CoreSetter::new(cores, 2));\n    let worker_pool = WorkerPool::new(core_setter, graph, router, rt);\n\n    let state = AppState {\n        worker_pool,\n        schema_json: Some(\"{\\\"schema\\\": \\\"test\\\"}\".to_string()),\n        cluster_id: None,\n    };\n\n    assert!(state.schema_json.is_some());\n    assert_eq!(state.schema_json.unwrap(), \"{\\\"schema\\\": \\\"test\\\"}\");\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_app_state_with_cluster_id_183": {
      "name": "test_app_state_with_cluster_id",
      "type": "function",
      "start_line": 183,
      "end_line": 212,
      "content_hash": "8b69bdb4576b3ac68d9a1ec57732f1bbca9e9ea5",
      "content": "fn test_app_state_with_cluster_id() {\n    let (graph, _temp_dir) = create_test_graph();\n    let router = Arc::new(HelixRouter::new(None, None, None));\n    let rt = Arc::new(\n        tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(1)\n            .enable_all()\n            .build()\n            .unwrap(),\n    );\n\n    let cores = core_affinity::get_core_ids().unwrap_or_default();\n    let core_setter = Arc::new(CoreSetter::new(cores, 2));\n    let worker_pool = WorkerPool::new(core_setter, graph, router, rt);\n\n    let state = AppState {\n        worker_pool,\n        schema_json: None,\n        cluster_id: Some(\"cluster-456\".to_string()),\n    };\n\n    assert!(state.cluster_id.is_some());\n    assert_eq!(state.cluster_id.unwrap(), \"cluster-456\");\n}\n\n// ============================================================================\n// CoreSetter Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_new_213": {
      "name": "test_core_setter_new",
      "type": "function",
      "start_line": 213,
      "end_line": 221,
      "content_hash": "fdee14e67c797379ee0044f3b362a22d0b4eb226",
      "content": "fn test_core_setter_new() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter = CoreSetter::new(cores.clone(), 8);\n\n    assert_eq!(setter.cores.len(), 2);\n    assert_eq!(setter.threads_per_core, 8);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_num_threads_single_core_222": {
      "name": "test_core_setter_num_threads_single_core",
      "type": "function",
      "start_line": 222,
      "end_line": 229,
      "content_hash": "8a55a614c5057976fc30443b48f5a021df97932a",
      "content": "fn test_core_setter_num_threads_single_core() {\n    let cores = vec![CoreId { id: 0 }];\n    let setter = CoreSetter::new(cores, 1);\n\n    assert_eq!(setter.num_threads(), 1);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_num_threads_multiple_cores_230": {
      "name": "test_core_setter_num_threads_multiple_cores",
      "type": "function",
      "start_line": 230,
      "end_line": 237,
      "content_hash": "879c1df7193271cccb3d829c4d9688491c038849",
      "content": "fn test_core_setter_num_threads_multiple_cores() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }, CoreId { id: 2 }];\n    let setter = CoreSetter::new(cores, 1);\n\n    assert_eq!(setter.num_threads(), 3);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_num_threads_multiple_threads_per_core_238": {
      "name": "test_core_setter_num_threads_multiple_threads_per_core",
      "type": "function",
      "start_line": 238,
      "end_line": 245,
      "content_hash": "08d2ce3ab6e4b3e64a6d287d481ed2780c4b6196",
      "content": "fn test_core_setter_num_threads_multiple_threads_per_core() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter = CoreSetter::new(cores, 8);\n\n    assert_eq!(setter.num_threads(), 16);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_num_threads_edge_cases_246": {
      "name": "test_core_setter_num_threads_edge_cases",
      "type": "function",
      "start_line": 246,
      "end_line": 257,
      "content_hash": "5f1450ee099ee560784ce64f52b6657cd00f2133",
      "content": "fn test_core_setter_num_threads_edge_cases() {\n    // Zero cores\n    let setter1 = CoreSetter::new(vec![], 8);\n    assert_eq!(setter1.num_threads(), 0);\n\n    // Zero threads per core\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter2 = CoreSetter::new(cores, 0);\n    assert_eq!(setter2.num_threads(), 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_calculation_258": {
      "name": "test_core_setter_calculation",
      "type": "function",
      "start_line": 258,
      "end_line": 270,
      "content_hash": "df8bb8be0cdfec7d053c21255f020c90d62e48c9",
      "content": "fn test_core_setter_calculation() {\n    let cores = vec![\n        CoreId { id: 0 },\n        CoreId { id: 1 },\n        CoreId { id: 2 },\n        CoreId { id: 3 },\n    ];\n    let setter = CoreSetter::new(cores, 8);\n\n    assert_eq!(setter.num_threads(), 32);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_empty_cores_271": {
      "name": "test_core_setter_empty_cores",
      "type": "function",
      "start_line": 271,
      "end_line": 278,
      "content_hash": "a7b2f476e8e8e8e30de64a5cd8184e056417cb0f",
      "content": "fn test_core_setter_empty_cores() {\n    let setter = CoreSetter::new(vec![], 10);\n\n    assert_eq!(setter.cores.len(), 0);\n    assert_eq!(setter.num_threads(), 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_single_thread_279": {
      "name": "test_core_setter_single_thread",
      "type": "function",
      "start_line": 279,
      "end_line": 287,
      "content_hash": "76615ca104e9d9147ef91b2a1f1a06b82a8c9161",
      "content": "fn test_core_setter_single_thread() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter = CoreSetter::new(cores, 1);\n\n    assert_eq!(setter.threads_per_core, 1);\n    assert_eq!(setter.num_threads(), 2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_many_threads_288": {
      "name": "test_core_setter_many_threads",
      "type": "function",
      "start_line": 288,
      "end_line": 295,
      "content_hash": "9fcdb5b37c6d91171a3786b74d2a82b1554a0ad3",
      "content": "fn test_core_setter_many_threads() {\n    let cores = vec![CoreId { id: 0 }];\n    let setter = CoreSetter::new(cores, 100);\n\n    assert_eq!(setter.num_threads(), 100);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_num_threads_consistency_296": {
      "name": "test_core_setter_num_threads_consistency",
      "type": "function",
      "start_line": 296,
      "end_line": 303,
      "content_hash": "1ab1c0b2db584eef194a49712d2041a39524f996",
      "content": "fn test_core_setter_num_threads_consistency() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter = CoreSetter::new(cores, 8);\n\n    assert_eq!(setter.num_threads(), 16);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_threads_per_core_zero_304": {
      "name": "test_core_setter_threads_per_core_zero",
      "type": "function",
      "start_line": 304,
      "end_line": 312,
      "content_hash": "24f11faac3d29f353741ea1344c9c90765c601be",
      "content": "fn test_core_setter_threads_per_core_zero() {\n    let cores = vec![CoreId { id: 0 }];\n    let setter = CoreSetter::new(cores, 0);\n\n    assert_eq!(setter.threads_per_core, 0);\n    assert_eq!(setter.num_threads(), 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_with_default_workers_313": {
      "name": "test_core_setter_with_default_workers",
      "type": "function",
      "start_line": 313,
      "end_line": 321,
      "content_hash": "0f8e483275d274ce72542fe1fb10d5c9756268a1",
      "content": "fn test_core_setter_with_default_workers() {\n    let cores = vec![CoreId { id: 0 }, CoreId { id: 1 }];\n    let setter = CoreSetter::new(cores, GatewayOpts::DEFAULT_WORKERS_PER_CORE);\n\n    assert_eq!(setter.threads_per_core, 8);\n    assert_eq!(setter.num_threads(), 16);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_core_setter_index_initial_value_322": {
      "name": "test_core_setter_index_initial_value",
      "type": "function",
      "start_line": 322,
      "end_line": 329,
      "content_hash": "81a065942f214348de271b5a407634bf429cb414",
      "content": "fn test_core_setter_index_initial_value() {\n    let cores = vec![CoreId { id: 0 }];\n    let setter = CoreSetter::new(cores, 1);\n\n    assert_eq!(setter.incrementing_index.load(atomic::Ordering::SeqCst), 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_gateway_opts_default_workers_per_core_330": {
      "name": "test_gateway_opts_default_workers_per_core",
      "type": "function",
      "start_line": 330,
      "end_line": 345,
      "content_hash": "2b024b841d622dd70e1e56dde247ddfcacee4960",
      "content": "fn test_gateway_opts_default_workers_per_core() {\n    assert_eq!(GatewayOpts::DEFAULT_WORKERS_PER_CORE, 8);\n}\n\n// ============================================================================\n// API Key Verification Integration Tests\n// ============================================================================\n\n#[cfg(feature = \"api-key\")]\nmod api_key_tests {\n    use crate::helix_gateway::key_verification::verify_key;\n    use crate::protocol::request::Request;\n    use crate::protocol::{Format, HelixError};\n    use axum::body::Bytes;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_verify_key_wrong_key_346": {
      "name": "test_verify_key_wrong_key",
      "type": "function",
      "start_line": 346,
      "end_line": 356,
      "content_hash": "f60e60c1e8dde60bb39cc3eb7d5d6e42ae325e60",
      "content": "    fn test_verify_key_wrong_key() {\n        let wrong_key = \"wrong-api-key\";\n        let result = verify_key(wrong_key);\n\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(matches!(e, HelixError::InvalidApiKey));\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_verify_key_empty_key_357": {
      "name": "test_verify_key_empty_key",
      "type": "function",
      "start_line": 357,
      "end_line": 364,
      "content_hash": "1fc5dfe4b0675628770f872c3ede36b3e922d0c9",
      "content": "    fn test_verify_key_empty_key() {\n        let empty_key = \"\";\n        let result = verify_key(empty_key);\n\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_request_with_api_key_365": {
      "name": "test_request_with_api_key",
      "type": "function",
      "start_line": 365,
      "end_line": 381,
      "content_hash": "5181858a4f0df4d6a9df257c95dd3b42f083b32a",
      "content": "    fn test_request_with_api_key() {\n        let api_key = \"test-api-key\".to_string();\n\n        let request = Request {\n            name: \"test_query\".to_string(),\n            req_type: crate::protocol::request::RequestType::Query,\n            api_key: Some(api_key.clone()),\n            body: Bytes::from(\"{}\"),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        assert!(request.api_key.is_some());\n        assert_eq!(request.api_key.unwrap(), api_key);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_request_without_api_key_382": {
      "name": "test_request_without_api_key",
      "type": "function",
      "start_line": 382,
      "end_line": 395,
      "content_hash": "291852e111f5f53196c7d3cb848ddc6f3ab76764",
      "content": "    fn test_request_without_api_key() {\n        let request = Request {\n            name: \"test_query\".to_string(),\n            req_type: crate::protocol::request::RequestType::Query,\n            api_key: None,\n            body: Bytes::from(\"{}\"),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        assert!(request.api_key.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_api_key_hash_consistency_396": {
      "name": "test_api_key_hash_consistency",
      "type": "function",
      "start_line": 396,
      "end_line": 407,
      "content_hash": "e0a8a6ad3c534a4a4f07a65ee25dac5ae3c244db",
      "content": "    fn test_api_key_hash_consistency() {\n        // Test that SHA-256 produces consistent hashes for the same input\n        use sha2::{Digest, Sha256};\n\n        let test_key = \"test-api-key\";\n        let hash1 = Sha256::digest(test_key.as_bytes());\n        let hash2 = Sha256::digest(test_key.as_bytes());\n\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_sha256_verification_works_408": {
      "name": "test_sha256_verification_works",
      "type": "function",
      "start_line": 408,
      "end_line": 423,
      "content_hash": "2eaca4df8f4ef5240b1124dcb914057a28851754",
      "content": "    fn test_sha256_verification_works() {\n        use sha2::{Digest, Sha256};\n        use subtle::ConstantTimeEq;\n\n        // Test that SHA-256 verification works correctly\n        let test_key = \"test-api-key-12345\";\n        let hash = Sha256::digest(test_key.as_bytes());\n\n        let correct_hash = Sha256::digest(test_key.as_bytes());\n        let wrong_hash = Sha256::digest(\"wrong-key\".as_bytes());\n\n        assert!(bool::from(hash.ct_eq(&correct_hash)));\n        assert!(!bool::from(hash.ct_eq(&wrong_hash)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_verify_key_error_type_424": {
      "name": "test_verify_key_error_type",
      "type": "function",
      "start_line": 424,
      "end_line": 437,
      "content_hash": "82d2a32f66da971d265d822b50479bcebbde3e0a",
      "content": "    fn test_verify_key_error_type() {\n        let wrong_key = \"definitely-wrong-key\";\n        let result = verify_key(wrong_key);\n\n        assert!(result.is_err());\n        match result {\n            Err(HelixError::InvalidApiKey) => {\n                // Expected error type\n            }\n            _ => panic!(\"Expected InvalidApiKey error\"),\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_verify_key_error_message_438": {
      "name": "test_verify_key_error_message",
      "type": "function",
      "start_line": 438,
      "end_line": 447,
      "content_hash": "3d807670fd834310efdb0f864611556b1265d7a0",
      "content": "    fn test_verify_key_error_message() {\n        let wrong_key = \"wrong-key\";\n        let result = verify_key(wrong_key);\n\n        if let Err(e) = result {\n            assert_eq!(e.to_string(), \"Invalid API key\");\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_verify_key_error_http_status_448": {
      "name": "test_verify_key_error_http_status",
      "type": "function",
      "start_line": 448,
      "end_line": 459,
      "content_hash": "e53af53142477c864ea775541aff2d054230a704",
      "content": "    fn test_verify_key_error_http_status() {\n        use axum::response::IntoResponse;\n\n        let wrong_key = \"wrong-key\";\n        let result = verify_key(wrong_key);\n\n        if let Err(e) = result {\n            let response = e.into_response();\n            assert_eq!(response.status(), 403);\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}