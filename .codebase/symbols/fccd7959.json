{
  "file_path": "/work/.local/tools/modelscan/sdk/agent/messagebus.go",
  "file_hash": "de4a05253a7c8392222c104f2fd8aa4911ea5eea",
  "updated_at": "2025-12-26T17:34:21.613236",
  "symbols": {
    "struct_TeamMessage_11": {
      "name": "TeamMessage",
      "type": "struct",
      "start_line": 11,
      "end_line": 34,
      "content_hash": "50882b6ccc1c6ca9050b6e8629ddea0538607e44",
      "content": "type TeamMessage struct {\n\tID        string                 `json:\"id\"`\n\tType      MessageType            `json:\"type\"`\n\tFrom      string                 `json:\"from\"`\n\tTo        string                 `json:\"to,omitempty\"` // Empty for broadcast\n\tContent   string                 `json:\"content\"`\n\tData      map[string]interface{} `json:\"data,omitempty\"`\n\tContext   map[string]interface{} `json:\"context,omitempty\"`\n\tTimestamp time.Time              `json:\"timestamp\"`\n}\n\n// MessageType defines the type of team message\ntype MessageType int\n\nconst (\n\tMessageTypeText MessageType = iota\n\tMessageTypeTask\n\tMessageTypeResult\n\tMessageTypeStatus\n\tMessageTypeError\n\tMessageTypeHandoff\n)\n\n// String returns the string representation of MessageType",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_String_35": {
      "name": "String",
      "type": "method",
      "start_line": 35,
      "end_line": 57,
      "content_hash": "cc601a4e23a86434eae4f4df34c422a6bbc11684",
      "content": "func (mt MessageType) String() string {\n\tswitch mt {\n\tcase MessageTypeText:\n\t\treturn \"text\"\n\tcase MessageTypeTask:\n\t\treturn \"task\"\n\tcase MessageTypeResult:\n\t\treturn \"result\"\n\tcase MessageTypeStatus:\n\t\treturn \"status\"\n\tcase MessageTypeError:\n\t\treturn \"error\"\n\tcase MessageTypeHandoff:\n\t\treturn \"handoff\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// MessageHandler defines the function signature for handling team messages\ntype MessageHandler func(TeamMessage) error\n\n// MessageBus provides inter-agent communication capabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_MessageBus_58": {
      "name": "MessageBus",
      "type": "interface",
      "start_line": 58,
      "end_line": 78,
      "content_hash": "af727c1c902e8b63f2e3245a7a2333fabade3bbb",
      "content": "type MessageBus interface {\n\t// Subscribe registers a message handler for an agent\n\tSubscribe(id string, handler MessageHandler) error\n\n\t// Unsubscribe removes a message handler\n\tUnsubscribe(id string) error\n\n\t// Send sends a message to a specific agent\n\tSend(ctx context.Context, msg TeamMessage) error\n\n\t// Broadcast sends a message to all agents except sender\n\tBroadcast(ctx context.Context, msg TeamMessage) error\n\n\t// GetStats returns message bus statistics\n\tGetStats() MessageBusStats\n\n\t// Shutdown gracefully shuts down the message bus\n\tShutdown()\n}\n\n// MessageBusStats contains statistics about the message bus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MessageBusStats_79": {
      "name": "MessageBusStats",
      "type": "struct",
      "start_line": 79,
      "end_line": 87,
      "content_hash": "6033c282b7ab559f1838b517dbe3fb3f611fe988",
      "content": "type MessageBusStats struct {\n\tSubscribers       int\n\tMessagesSent      int\n\tMessagesDelivered int\n\tMessagesFailed    int\n\tUptime            time.Duration\n}\n\n// InMemoryMessageBus implements MessageBus with in-memory storage",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_InMemoryMessageBus_88": {
      "name": "InMemoryMessageBus",
      "type": "struct",
      "start_line": 88,
      "end_line": 99,
      "content_hash": "c159944a9712592e8bf4830a1d67d719b124738b",
      "content": "type InMemoryMessageBus struct {\n\tmu           sync.RWMutex\n\tsubscribers  map[string]MessageHandler\n\tstats        MessageBusStats\n\tstartTime    time.Time\n\tctx          context.Context\n\tcancel       context.CancelFunc\n\twg           sync.WaitGroup\n\tshutdownOnce sync.Once\n}\n\n// NewInMemoryMessageBus creates a new in-memory message bus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewInMemoryMessageBus_100": {
      "name": "NewInMemoryMessageBus",
      "type": "function",
      "start_line": 100,
      "end_line": 116,
      "content_hash": "8f6ad9c5c308077978c0933b9e40e9d62a0fb97a",
      "content": "func NewInMemoryMessageBus() *InMemoryMessageBus {\n\tctx, cancel := context.WithCancel(context.Background())\n\tmb := &InMemoryMessageBus{\n\t\tsubscribers: make(map[string]MessageHandler),\n\t\tstartTime:   time.Now(),\n\t\tctx:         ctx,\n\t\tcancel:      cancel,\n\t}\n\n\t// Start maintenance goroutine\n\tmb.wg.Add(1)\n\tgo mb.maintenanceLoop()\n\n\treturn mb\n}\n\n// Subscribe registers a message handler for an agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Subscribe_117": {
      "name": "Subscribe",
      "type": "method",
      "start_line": 117,
      "end_line": 138,
      "content_hash": "ba7bd03a3e5fc56ad168d786a91547a8c8669ec0",
      "content": "func (mb *InMemoryMessageBus) Subscribe(id string, handler MessageHandler) error {\n\tif id == \"\" {\n\t\treturn fmt.Errorf(\"subscriber ID cannot be empty\")\n\t}\n\tif handler == nil {\n\t\treturn fmt.Errorf(\"handler cannot be nil\")\n\t}\n\n\tmb.mu.Lock()\n\tdefer mb.mu.Unlock()\n\n\tif _, exists := mb.subscribers[id]; exists {\n\t\treturn fmt.Errorf(\"subscriber %s already exists\", id)\n\t}\n\n\tmb.subscribers[id] = handler\n\tmb.stats.Subscribers = len(mb.subscribers)\n\n\treturn nil\n}\n\n// Unsubscribe removes a message handler",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Unsubscribe_139": {
      "name": "Unsubscribe",
      "type": "method",
      "start_line": 139,
      "end_line": 153,
      "content_hash": "b50f12ceef8933e9fbd37669dc0d7433a297ae8b",
      "content": "func (mb *InMemoryMessageBus) Unsubscribe(id string) error {\n\tmb.mu.Lock()\n\tdefer mb.mu.Unlock()\n\n\tif _, exists := mb.subscribers[id]; !exists {\n\t\treturn fmt.Errorf(\"subscriber %s not found\", id)\n\t}\n\n\tdelete(mb.subscribers, id)\n\tmb.stats.Subscribers = len(mb.subscribers)\n\n\treturn nil\n}\n\n// Send sends a message to a specific agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Send_154": {
      "name": "Send",
      "type": "method",
      "start_line": 154,
      "end_line": 213,
      "content_hash": "43fb0466bfe710eac6ada56b3094af8e31010712",
      "content": "func (mb *InMemoryMessageBus) Send(ctx context.Context, msg TeamMessage) error {\n\tif msg.From == \"\" {\n\t\treturn fmt.Errorf(\"message sender cannot be empty\")\n\t}\n\tif msg.To == \"\" {\n\t\treturn fmt.Errorf(\"message recipient cannot be empty for direct message\")\n\t}\n\tif msg.Timestamp.IsZero() {\n\t\tmsg.Timestamp = time.Now()\n\t}\n\n\t// Generate message ID if not provided\n\tif msg.ID == \"\" {\n\t\tmsg.ID = fmt.Sprintf(\"%s-%s-%d\", msg.From, msg.To, time.Now().UnixNano())\n\t}\n\n\t// Increment sent counter regardless of outcome\n\tmb.mu.Lock()\n\tmb.stats.MessagesSent++\n\tmb.mu.Unlock()\n\n\tmb.mu.RLock()\n\thandler, exists := mb.subscribers[msg.To]\n\tmb.mu.RUnlock()\n\n\tif !exists {\n\t\tmb.mu.Lock()\n\t\tmb.stats.MessagesFailed++\n\t\tmb.mu.Unlock()\n\t\treturn fmt.Errorf(\"recipient %s not found\", msg.To)\n\t}\n\n\t// Deliver message asynchronously\n\tmb.wg.Add(1)\n\tgo func() {\n\t\tdefer mb.wg.Done()\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tmb.mu.Lock()\n\t\t\tmb.stats.MessagesFailed++\n\t\t\tmb.mu.Unlock()\n\t\t\treturn\n\t\tdefault:\n\t\t\tif err := handler(msg); err != nil {\n\t\t\t\tmb.mu.Lock()\n\t\t\t\tmb.stats.MessagesFailed++\n\t\t\t\tmb.mu.Unlock()\n\t\t\t} else {\n\t\t\t\tmb.mu.Lock()\n\t\t\t\tmb.stats.MessagesDelivered++\n\t\t\t\tmb.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// Broadcast sends a message to all agents except sender",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Broadcast_214": {
      "name": "Broadcast",
      "type": "method",
      "start_line": 214,
      "end_line": 276,
      "content_hash": "6d0486fb499261069b1fcd12613ff7e885c38960",
      "content": "func (mb *InMemoryMessageBus) Broadcast(ctx context.Context, msg TeamMessage) error {\n\tif msg.From == \"\" {\n\t\treturn fmt.Errorf(\"message sender cannot be empty\")\n\t}\n\tif msg.Timestamp.IsZero() {\n\t\tmsg.Timestamp = time.Now()\n\t}\n\n\t// Generate message ID if not provided\n\tif msg.ID == \"\" {\n\t\tmsg.ID = fmt.Sprintf(\"broadcast-%s-%d\", msg.From, time.Now().UnixNano())\n\t}\n\n\tmb.mu.RLock()\n\thandlers := make(map[string]MessageHandler)\n\tfor id, handler := range mb.subscribers {\n\t\tif id != msg.From { // Don't send to sender\n\t\t\thandlers[id] = handler\n\t\t}\n\t}\n\tmb.mu.RUnlock()\n\n\tif len(handlers) == 0 {\n\t\treturn fmt.Errorf(\"no recipients available for broadcast\")\n\t}\n\n\t// Deliver messages asynchronously to all recipients\n\tfor recipientID, handler := range handlers {\n\t\tmb.wg.Add(1)\n\t\tgo func(recipient string, h MessageHandler) {\n\t\t\tdefer mb.wg.Done()\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tmb.mu.Lock()\n\t\t\t\tmb.stats.MessagesFailed++\n\t\t\t\tmb.mu.Unlock()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\trecipientMsg := msg\n\t\t\t\trecipientMsg.To = recipient\n\n\t\t\t\tif err := h(recipientMsg); err != nil {\n\t\t\t\t\tmb.mu.Lock()\n\t\t\t\t\tmb.stats.MessagesFailed++\n\t\t\t\t\tmb.mu.Unlock()\n\t\t\t\t} else {\n\t\t\t\t\tmb.mu.Lock()\n\t\t\t\t\tmb.stats.MessagesDelivered++\n\t\t\t\t\tmb.mu.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}(recipientID, handler)\n\t}\n\n\tmb.mu.Lock()\n\tmb.stats.MessagesSent += len(handlers)\n\tmb.mu.Unlock()\n\n\treturn nil\n}\n\n// GetStats returns message bus statistics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetStats_277": {
      "name": "GetStats",
      "type": "method",
      "start_line": 277,
      "end_line": 286,
      "content_hash": "7412b6ea3a4e5b8c61f766463b432f8c959b7aad",
      "content": "func (mb *InMemoryMessageBus) GetStats() MessageBusStats {\n\tmb.mu.RLock()\n\tdefer mb.mu.RUnlock()\n\n\tstats := mb.stats\n\tstats.Uptime = time.Since(mb.startTime)\n\treturn stats\n}\n\n// Shutdown gracefully shuts down the message bus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Shutdown_287": {
      "name": "Shutdown",
      "type": "method",
      "start_line": 287,
      "end_line": 312,
      "content_hash": "6c911cfc2c081f7b298adfcc3238b91d695ac610",
      "content": "func (mb *InMemoryMessageBus) Shutdown() {\n\tmb.shutdownOnce.Do(func() {\n\t\tmb.cancel()\n\n\t\t// Wait for all message deliveries to complete\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tmb.wg.Wait()\n\t\t\tclose(done)\n\t\t}()\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\t// All deliveries completed\n\t\tcase <-time.After(5 * time.Second):\n\t\t\t// Timeout - force shutdown\n\t\t}\n\n\t\tmb.mu.Lock()\n\t\tmb.subscribers = make(map[string]MessageHandler)\n\t\tmb.stats.Subscribers = 0 // Reset subscriber count\n\t\tmb.mu.Unlock()\n\t})\n}\n\n// maintenanceLoop performs periodic maintenance tasks",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_maintenanceLoop_313": {
      "name": "maintenanceLoop",
      "type": "method",
      "start_line": 313,
      "end_line": 333,
      "content_hash": "7558c3a3563e14cb48bceeda68773cdfae93bae4",
      "content": "func (mb *InMemoryMessageBus) maintenanceLoop() {\n\tdefer mb.wg.Done()\n\n\tticker := time.NewTicker(30 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-mb.ctx.Done():\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\t// Perform maintenance tasks (could include cleanup, stats updates, etc.)\n\t\t\t// For now, just update uptime\n\t\t\tmb.mu.RLock()\n\t\t\t_ = mb.stats.Uptime\n\t\t\tmb.mu.RUnlock()\n\t\t}\n\t}\n}\n\n// NewTeamMessage creates a new team message with proper initialization",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewTeamMessage_334": {
      "name": "NewTeamMessage",
      "type": "function",
      "start_line": 334,
      "end_line": 346,
      "content_hash": "5ae85d7ef0800196b85d332d8aa9edf5a99b5c6f",
      "content": "func NewTeamMessage(msgType MessageType, from, to, content string) TeamMessage {\n\treturn TeamMessage{\n\t\tID:        fmt.Sprintf(\"%s-%d\", from, time.Now().UnixNano()),\n\t\tType:      msgType,\n\t\tFrom:      from,\n\t\tTo:        to,\n\t\tContent:   content,\n\t\tData:      make(map[string]interface{}),\n\t\tTimestamp: time.Now(),\n\t}\n}\n\n// AddData adds a key-value pair to the message data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_AddData_347": {
      "name": "AddData",
      "type": "method",
      "start_line": 347,
      "end_line": 354,
      "content_hash": "320485d626d0fca935e52fc837bfc11803072e1c",
      "content": "func (tm *TeamMessage) AddData(key string, value interface{}) {\n\tif tm.Data == nil {\n\t\ttm.Data = make(map[string]interface{})\n\t}\n\ttm.Data[key] = value\n}\n\n// GetData retrieves a value from the message data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetData_355": {
      "name": "GetData",
      "type": "method",
      "start_line": 355,
      "end_line": 361,
      "content_hash": "beb7752510661ae845005737b98445fccdb9109f",
      "content": "func (tm *TeamMessage) GetData(key string) (interface{}, bool) {\n\tif tm.Data == nil {\n\t\treturn nil, false\n\t}\n\tvalue, exists := tm.Data[key]\n\treturn value, exists\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}