{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/schema_methods.rs",
  "file_hash": "8f52c0bc69f2a170419f32d62796ffd78ebaa8d4",
  "updated_at": "2025-12-26T17:34:20.982971",
  "symbols": {
    "impl_SchemaVersionMap_18": {
      "name": "SchemaVersionMap",
      "type": "impl",
      "start_line": 18,
      "end_line": 18,
      "content_hash": "30ead5627860a11605ca2567f7660f1e898e20ee",
      "content": "impl<'a> SchemaVersionMap<'a> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_latest_19": {
      "name": "get_latest",
      "type": "method",
      "start_line": 19,
      "end_line": 25,
      "content_hash": "dc279bc40dbb2c2badb0eeb55e11906b4b97f9b6",
      "content": "    pub fn get_latest(&self) -> (FieldLookup<'a>, FieldLookup<'a>, FieldLookup<'a>) {\n        self.0\n            .get(self.0.keys().max().unwrap_or(&1))\n            .unwrap_or(&(HashMap::new(), HashMap::new(), HashMap::new()))\n            .clone()\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inner_26": {
      "name": "inner",
      "type": "method",
      "start_line": 26,
      "end_line": 184,
      "content_hash": "99a68ef92b84cd099f373bf901737644a088e3ba",
      "content": "    pub fn inner(&self) -> &HashMap<usize, (FieldLookup<'a>, FieldLookup<'a>, FieldLookup<'a>)> {\n        &self.0\n    }\n}\n\npub(crate) fn build_field_lookups<'a>(src: &'a Source) -> SchemaVersionMap<'a> {\n    SchemaVersionMap(\n        src.get_schemas_in_order()\n            .iter()\n            .map(|schema| {\n                let node_fields = schema\n                    .node_schemas\n                    .iter()\n                    .map(|n| {\n                        let mut props = n\n                            .fields\n                            .iter()\n                            .map(|f| (f.name.as_str(), Cow::Borrowed(f)))\n                            .collect::<HashMap<&str, Cow<'a, Field>>>();\n                        props.insert(\n                            \"id\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"id\".to_string(),\n                                field_type: FieldType::Uuid,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"label\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"label\".to_string(),\n                                field_type: FieldType::String,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        (n.name.1.as_str(), props)\n                    })\n                    .collect();\n\n                let edge_fields = schema\n                    .edge_schemas\n                    .iter()\n                    .map(|e| {\n                        let mut props: HashMap<_, _> = e\n                            .properties\n                            .as_ref()\n                            .map(|v| {\n                                v.iter()\n                                    .map(|f| (f.name.as_str(), Cow::Borrowed(f)))\n                                    .collect()\n                            })\n                            .unwrap_or_default();\n                        props.insert(\n                            \"id\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"id\".to_string(),\n                                field_type: FieldType::Uuid,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"label\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"label\".to_string(),\n                                field_type: FieldType::String,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"from_node\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"from_node\".to_string(),\n                                field_type: FieldType::Uuid,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"to_node\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"to_node\".to_string(),\n                                field_type: FieldType::Uuid,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        (e.name.1.as_str(), props)\n                    })\n                    .collect();\n\n                let vector_fields = schema\n                    .vector_schemas\n                    .iter()\n                    .map(|v| {\n                        let mut props = v\n                            .fields\n                            .iter()\n                            .map(|f| (f.name.as_str(), Cow::Borrowed(f)))\n                            .collect::<HashMap<&str, Cow<'a, Field>>>();\n                        props.insert(\n                            \"id\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"id\".to_string(),\n                                field_type: FieldType::Uuid,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"label\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"label\".to_string(),\n                                field_type: FieldType::String,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"data\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"data\".to_string(),\n                                field_type: FieldType::Array(Box::new(FieldType::F64)),\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        props.insert(\n                            \"score\",\n                            Cow::Owned(Field {\n                                prefix: FieldPrefix::Empty,\n                                defaults: None,\n                                name: \"score\".to_string(),\n                                field_type: FieldType::F64,\n                                loc: Loc::empty(),\n                            }),\n                        );\n                        (v.name.as_str(), props)\n                    })\n                    .collect();\n\n                (schema.version.1, (node_fields, edge_fields, vector_fields))\n            })\n            .collect(),\n    )\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_check_duplicate_schema_definitions_185": {
      "name": "check_duplicate_schema_definitions",
      "type": "method",
      "start_line": 185,
      "end_line": 440,
      "content_hash": "75aef7925fe7e23662e9180174e01f88f3d60337",
      "content": "fn check_duplicate_schema_definitions(ctx: &mut Ctx) -> Result<(), ParserError> {\n    use std::collections::HashMap;\n\n    // Track seen names for each schema type\n    let mut seen_nodes: HashMap<String, (crate::helixc::parser::location::Loc, String)> =\n        HashMap::new();\n    let mut seen_edges: HashMap<String, (crate::helixc::parser::location::Loc, String)> =\n        HashMap::new();\n    let mut seen_vectors: HashMap<String, (crate::helixc::parser::location::Loc, String)> =\n        HashMap::new();\n\n    let schema = ctx.src.get_latest_schema()?;\n\n    // Check duplicate nodes and reserved names\n    for node in &schema.node_schemas {\n        // Check for reserved type names\n        if RESERVED_TYPE_NAMES.contains(&node.name.1.as_str()) {\n            push_schema_err(\n                ctx,\n                node.name.0.clone(),\n                ErrorCode::E110,\n                format!(\n                    \"`{}` is a reserved type name and cannot be used as a node name\",\n                    node.name.1\n                ),\n                Some(\"rename the node to something else\".to_string()),\n            );\n        }\n        if let Some((_first_loc, _)) = seen_nodes.get(&node.name.1) {\n            push_schema_err(\n                ctx,\n                node.name.0.clone(),\n                ErrorCode::E107,\n                format!(\"duplicate node definition `{}`\", node.name.1),\n                Some(\"rename the node or remove the duplicate definition\".to_string()),\n            );\n        } else {\n            seen_nodes.insert(\n                node.name.1.clone(),\n                (node.name.0.clone(), node.name.1.clone()),\n            );\n        }\n    }\n\n    // Check duplicate edges and reserved names\n    for edge in &schema.edge_schemas {\n        // Check for reserved type names\n        if RESERVED_TYPE_NAMES.contains(&edge.name.1.as_str()) {\n            push_schema_err(\n                ctx,\n                edge.name.0.clone(),\n                ErrorCode::E110,\n                format!(\n                    \"`{}` is a reserved type name and cannot be used as an edge name\",\n                    edge.name.1\n                ),\n                Some(\"rename the edge to something else\".to_string()),\n            );\n        }\n        if let Some((_first_loc, _)) = seen_edges.get(&edge.name.1) {\n            push_schema_err(\n                ctx,\n                edge.name.0.clone(),\n                ErrorCode::E107,\n                format!(\"duplicate edge definition `{}`\", edge.name.1),\n                Some(\"rename the edge or remove the duplicate definition\".to_string()),\n            );\n        } else {\n            seen_edges.insert(\n                edge.name.1.clone(),\n                (edge.name.0.clone(), edge.name.1.clone()),\n            );\n        }\n    }\n\n    // Check duplicate vectors and reserved names\n    for vector in &schema.vector_schemas {\n        // Check for reserved type names\n        if RESERVED_TYPE_NAMES.contains(&vector.name.as_str()) {\n            push_schema_err(\n                ctx,\n                vector.loc.clone(),\n                ErrorCode::E110,\n                format!(\n                    \"`{}` is a reserved type name and cannot be used as a vector name\",\n                    vector.name\n                ),\n                Some(\"rename the vector to something else\".to_string()),\n            );\n        }\n        if let Some((_first_loc, _)) = seen_vectors.get(&vector.name) {\n            push_schema_err(\n                ctx,\n                vector.loc.clone(),\n                ErrorCode::E107,\n                format!(\"duplicate vector definition `{}`\", vector.name),\n                Some(\"rename the vector or remove the duplicate definition\".to_string()),\n            );\n        } else {\n            seen_vectors.insert(\n                vector.name.clone(),\n                (vector.loc.clone(), vector.name.clone()),\n            );\n        }\n    }\n    Ok(())\n}\n\npub(crate) fn check_schema(ctx: &mut Ctx) -> Result<(), ParserError> {\n    // Check for duplicate schema definitions\n    check_duplicate_schema_definitions(ctx)?;\n\n    for edge in &ctx.src.get_latest_schema()?.edge_schemas {\n        if !ctx.node_set.contains(edge.from.1.as_str())\n            && !ctx.vector_set.contains(edge.from.1.as_str())\n        {\n            push_schema_err(\n                ctx,\n                edge.from.0.clone(),\n                ErrorCode::E106,\n                format!(\n                    \"use of undeclared node or vector type `{}` in schema\",\n                    edge.from.1\n                ),\n                Some(format!(\n                    \"declare `{}` in the schema before using it in an edge\",\n                    edge.from.1\n                )),\n            );\n        }\n        if !ctx.node_set.contains(edge.to.1.as_str())\n            && !ctx.vector_set.contains(edge.to.1.as_str())\n        {\n            push_schema_err(\n                ctx,\n                edge.to.0.clone(),\n                ErrorCode::E106,\n                format!(\n                    \"use of undeclared node or vector type `{}` in schema\",\n                    edge.to.1\n                ),\n                Some(format!(\n                    \"declare `{}` in the schema before using it in an edge\",\n                    edge.to.1\n                )),\n            );\n        }\n        if let Some(v) = edge.properties.as_ref() {\n            // Check for duplicate field names (case-insensitive)\n            let mut seen_fields: std::collections::HashSet<String> = std::collections::HashSet::new();\n            for f in v {\n                let lower_name = f.name.to_lowercase();\n                if !seen_fields.insert(lower_name) {\n                    push_schema_err(\n                        ctx,\n                        f.loc.clone(),\n                        ErrorCode::E109,\n                        format!(\"duplicate field `{}` in edge `{}`\", f.name, edge.name.1),\n                        Some(\"rename the field or remove the duplicate\".to_string()),\n                    );\n                }\n                if NODE_RESERVED_FIELD_NAMES.contains(&f.name.to_lowercase().as_str()) {\n                    push_schema_err(\n                        ctx,\n                        f.loc.clone(),\n                        ErrorCode::E204,\n                        format!(\"field `{}` is a reserved field name\", f.name),\n                        Some(\"rename the field\".to_string()),\n                    );\n                }\n                if !is_valid_schema_field_type(&f.field_type) {\n                    push_schema_err(\n                        ctx,\n                        f.loc.clone(),\n                        ErrorCode::E209,\n                        format!(\"invalid type in schema field: `{}`\", f.name),\n                        Some(\"use built-in types only (String, U32, etc.)\".to_string()),\n                    );\n                }\n            }\n        }\n        ctx.output.edges.push(edge.clone().into());\n    }\n    for node in &ctx.src.get_latest_schema()?.node_schemas {\n        // Check for duplicate field names (case-insensitive)\n        let mut seen_fields: std::collections::HashSet<String> = std::collections::HashSet::new();\n        for f in &node.fields {\n            let lower_name = f.name.to_lowercase();\n            if !seen_fields.insert(lower_name) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E109,\n                    format!(\"duplicate field `{}` in node `{}`\", f.name, node.name.1),\n                    Some(\"rename the field or remove the duplicate\".to_string()),\n                );\n            }\n            if EDGE_RESERVED_FIELD_NAMES.contains(&f.name.to_lowercase().as_str()) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E204,\n                    format!(\"field `{}` is a reserved field name\", f.name),\n                    Some(\"rename the field\".to_string()),\n                );\n            }\n            if !is_valid_schema_field_type(&f.field_type) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E209,\n                    format!(\"invalid type in schema field: `{}`\", f.name),\n                    Some(\"use built-in types only (String, U32, etc.)\".to_string()),\n                );\n            }\n        }\n        ctx.output.nodes.push(node.clone().into());\n    }\n    for vector in &ctx.src.get_latest_schema()?.vector_schemas {\n        // Check for duplicate field names (case-insensitive)\n        let mut seen_fields: std::collections::HashSet<String> = std::collections::HashSet::new();\n        for f in &vector.fields {\n            let lower_name = f.name.to_lowercase();\n            if !seen_fields.insert(lower_name) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E109,\n                    format!(\"duplicate field `{}` in vector `{}`\", f.name, vector.name),\n                    Some(\"rename the field or remove the duplicate\".to_string()),\n                );\n            }\n            if VEC_RESERVED_FIELD_NAMES.contains(&f.name.to_lowercase().as_str()) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E204,\n                    format!(\"field `{}` is a reserved field name\", f.name),\n                    Some(\"rename the field\".to_string()),\n                );\n            }\n            if !is_valid_schema_field_type(&f.field_type) {\n                push_schema_err(\n                    ctx,\n                    f.loc.clone(),\n                    ErrorCode::E209,\n                    format!(\"invalid type in schema field: `{}`\", f.name),\n                    Some(\"use built-in types only (String, U32, etc.)\".to_string()),\n                );\n            }\n        }\n        ctx.output.vectors.push(vector.clone().into());\n    }\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_valid_schema_field_type_441": {
      "name": "is_valid_schema_field_type",
      "type": "method",
      "start_line": 441,
      "end_line": 482,
      "content_hash": "40617b4493571e3f7347a9e7294a6032f1af828a",
      "content": "fn is_valid_schema_field_type(ft: &FieldType) -> bool {\n    match ft {\n        FieldType::Identifier(_) => false,\n        FieldType::Object(_) => false,\n        FieldType::Array(inner) => is_valid_schema_field_type(inner),\n        _ => true,\n    }\n}\n\nconst NODE_RESERVED_FIELD_NAMES: &[&str] = &[\"id\", \"label\", \"type\", \"version\"];\nconst EDGE_RESERVED_FIELD_NAMES: &[&str] =\n    &[\"id\", \"label\", \"to_node\", \"from_node\", \"type\", \"version\"];\nconst VEC_RESERVED_FIELD_NAMES: &[&str] = &[\"id\", \"label\", \"data\", \"score\", \"type\", \"version\"];\n\n/// Reserved type names that cannot be used as schema item names (node, edge, vector).\n/// These names conflict with built-in helix-db types and imports.\nconst RESERVED_TYPE_NAMES: &[&str] = &[\n    // Core graph types\n    \"Node\",\n    \"Edge\",\n    \"HVector\",\n    // Protocol and error types\n    \"Value\",\n    \"GraphError\",\n    \"VectorError\",\n    // Other commonly used types\n    \"Response\",\n    \"HandlerInput\",\n    \"Aggregate\",\n    \"AggregateItem\",\n];\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::helixc::parser::{HelixParser, write_to_temp_file};\n\n    // ============================================================================\n    // Duplicate Schema Definition Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_node_definition_483": {
      "name": "test_duplicate_node_definition",
      "type": "method",
      "start_line": 483,
      "end_line": 507,
      "content_hash": "34f1b39d2da5438cd430d3ce32ee22ca3ef48c9f",
      "content": "    fn test_duplicate_node_definition() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Person { age: U32 }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E107));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate node definition\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_edge_definition_508": {
      "name": "test_duplicate_edge_definition",
      "type": "method",
      "start_line": 508,
      "end_line": 533,
      "content_hash": "ffeab8377bde836a90d8342ddaf2639d951ea340",
      "content": "    fn test_duplicate_edge_definition() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n            E::Knows { From: Person, To: Person, Properties: { since: String } }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E107));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate edge definition\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_vector_definition_534": {
      "name": "test_duplicate_vector_definition",
      "type": "method",
      "start_line": 534,
      "end_line": 562,
      "content_hash": "6995067437e7d892d29b428547c5fa9cc8bbe889",
      "content": "    fn test_duplicate_vector_definition() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n            V::Document { title: String, embedding: [F32] }\n\n            QUERY test() =>\n                d <- V<Document>\n                RETURN d\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E107));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate vector definition\"))\n        );\n    }\n\n    // ============================================================================\n    // Undeclared Type Reference Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_references_undeclared_from_node_563": {
      "name": "test_edge_references_undeclared_from_node",
      "type": "method",
      "start_line": 563,
      "end_line": 588,
      "content_hash": "e2c2b1148ca1bbc58f1e3eeccba9b06e16d165ac",
      "content": "    fn test_edge_references_undeclared_from_node() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Works { From: Company, To: Person }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E106));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"undeclared node or vector type\")\n                    && d.message.contains(\"Company\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_references_undeclared_to_node_589": {
      "name": "test_edge_references_undeclared_to_node",
      "type": "method",
      "start_line": 589,
      "end_line": 614,
      "content_hash": "8ae7bb99a279e5ee700a6ed158584a1c554f6c91",
      "content": "    fn test_edge_references_undeclared_to_node() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Likes { From: Person, To: Product }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E106));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"undeclared node or vector type\")\n                    && d.message.contains(\"Product\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_with_valid_node_references_615": {
      "name": "test_edge_with_valid_node_references",
      "type": "method",
      "start_line": 615,
      "end_line": 635,
      "content_hash": "7c5e575552b6228b1fc848e30996ee617d0b54b9",
      "content": "    fn test_edge_with_valid_node_references() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E106));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_references_vector_type_636": {
      "name": "test_edge_references_vector_type",
      "type": "method",
      "start_line": 636,
      "end_line": 665,
      "content_hash": "dfad568738a7f58ada67e8c05592757b2bbd3c56",
      "content": "    fn test_edge_references_vector_type() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n            N::Person { name: String }\n            E::References { From: Person, To: Document }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not error - vectors can be referenced in edges\n        assert!(\n            !diagnostics\n                .iter()\n                .any(|d| d.error_code == ErrorCode::E106 && d.message.contains(\"Document\"))\n        );\n    }\n\n    // ============================================================================\n    // Reserved Field Name Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_field_name_id_in_node_666": {
      "name": "test_reserved_field_name_id_in_node",
      "type": "method",
      "start_line": 666,
      "end_line": 689,
      "content_hash": "354f1643e5a42b5e3f324f5ee8313fcd9a677ccd",
      "content": "    fn test_reserved_field_name_id_in_node() {\n        let source = r#\"\n            N::Person { id: String, name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E204));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved field name\") && d.message.contains(\"id\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_field_name_label_in_edge_690": {
      "name": "test_reserved_field_name_label_in_edge",
      "type": "method",
      "start_line": 690,
      "end_line": 714,
      "content_hash": "a93cb8c3b0a7522b30422d2f6417ce78d8e239cd",
      "content": "    fn test_reserved_field_name_label_in_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person, Properties: { label: String } }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E204));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved field name\") && d.message.contains(\"label\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_field_name_to_node_715": {
      "name": "test_reserved_field_name_to_node",
      "type": "method",
      "start_line": 715,
      "end_line": 733,
      "content_hash": "05401a444acc0f7947191d834a4e0054bbabde2d",
      "content": "    fn test_reserved_field_name_to_node() {\n        let source = r#\"\n            N::Person { to_node: ID }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E204));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_field_name_data_in_vector_734": {
      "name": "test_reserved_field_name_data_in_vector",
      "type": "method",
      "start_line": 734,
      "end_line": 752,
      "content_hash": "0f5c23f994ad21a708cd53908a70e34c2a2ba1ba",
      "content": "    fn test_reserved_field_name_data_in_vector() {\n        let source = r#\"\n            V::Document { data: String, embedding: [F32] }\n\n            QUERY test() =>\n                d <- V<Document>\n                RETURN d\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E204));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_field_name_case_insensitive_753": {
      "name": "test_reserved_field_name_case_insensitive",
      "type": "method",
      "start_line": 753,
      "end_line": 776,
      "content_hash": "035d301adf84a9f038c4355f760312c92a39d809",
      "content": "    fn test_reserved_field_name_case_insensitive() {\n        let source = r#\"\n            N::Person { ID: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Reserved field names are checked case-insensitively\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E204));\n    }\n\n    // ============================================================================\n    // Invalid Schema Field Type Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_valid_primitive_field_types_777": {
      "name": "test_valid_primitive_field_types",
      "type": "method",
      "start_line": 777,
      "end_line": 803,
      "content_hash": "e8e270d10d9087200fe03930492cf3aac70ec868",
      "content": "    fn test_valid_primitive_field_types() {\n        let source = r#\"\n            N::Person {\n                name: String,\n                age: U32,\n                score: F64,\n                active: Boolean,\n                user_id: ID,\n                created_at: Date\n            }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not have any E209 errors for these valid types\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E209));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_valid_array_field_types_804": {
      "name": "test_valid_array_field_types",
      "type": "method",
      "start_line": 804,
      "end_line": 830,
      "content_hash": "638781f6f12a3f39168eed9023e0b14ec47b38c6",
      "content": "    fn test_valid_array_field_types() {\n        let source = r#\"\n            N::Person {\n                tags: [String],\n                scores: [F64],\n                ids: [ID]\n            }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E209));\n    }\n\n    // ============================================================================\n    // Field Lookup Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_field_lookup_includes_implicit_fields_831": {
      "name": "test_field_lookup_includes_implicit_fields",
      "type": "method",
      "start_line": 831,
      "end_line": 851,
      "content_hash": "a361f785ac0578c383892259d248ee4d6dc20254",
      "content": "    fn test_field_lookup_includes_implicit_fields() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let ctx = Ctx::new(&parsed).unwrap();\n\n        // Node should have implicit 'id' and 'label' fields\n        let person_fields = ctx.node_fields.get(\"Person\").unwrap();\n        assert!(person_fields.contains_key(\"id\"));\n        assert!(person_fields.contains_key(\"label\"));\n        assert!(person_fields.contains_key(\"name\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_field_lookup_includes_implicit_fields_852": {
      "name": "test_edge_field_lookup_includes_implicit_fields",
      "type": "method",
      "start_line": 852,
      "end_line": 875,
      "content_hash": "18472fc7e3f5142d4d218ae87dbe38b9007015b5",
      "content": "    fn test_edge_field_lookup_includes_implicit_fields() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person, Properties: { since: Date } }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let ctx = Ctx::new(&parsed).unwrap();\n\n        // Edge should have implicit fields\n        let knows_fields = ctx.edge_fields.get(\"Knows\").unwrap();\n        assert!(knows_fields.contains_key(\"id\"));\n        assert!(knows_fields.contains_key(\"label\"));\n        assert!(knows_fields.contains_key(\"from_node\"));\n        assert!(knows_fields.contains_key(\"to_node\"));\n        assert!(knows_fields.contains_key(\"since\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_vector_field_lookup_includes_implicit_fields_876": {
      "name": "test_vector_field_lookup_includes_implicit_fields",
      "type": "method",
      "start_line": 876,
      "end_line": 902,
      "content_hash": "993bcc4f8da159a32c36f8585f04b83213aa25da",
      "content": "    fn test_vector_field_lookup_includes_implicit_fields() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY test() =>\n                d <- V<Document>\n                RETURN d\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let ctx = Ctx::new(&parsed).unwrap();\n\n        // Vector should have implicit fields\n        let doc_fields = ctx.vector_fields.get(\"Document\").unwrap();\n        assert!(doc_fields.contains_key(\"id\"));\n        assert!(doc_fields.contains_key(\"label\"));\n        assert!(doc_fields.contains_key(\"data\"));\n        assert!(doc_fields.contains_key(\"score\"));\n        assert!(doc_fields.contains_key(\"content\"));\n    }\n\n    // ============================================================================\n    // Complex Schema Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_multiple_edges_between_same_types_903": {
      "name": "test_multiple_edges_between_same_types",
      "type": "method",
      "start_line": 903,
      "end_line": 929,
      "content_hash": "f7c3cf9dfe5b6574d30d8da00878428c81bb09ac",
      "content": "    fn test_multiple_edges_between_same_types() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n            E::Follows { From: Person, To: Person }\n            E::Blocks { From: Person, To: Person }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not error - multiple edges between same types is valid\n        assert!(\n            !diagnostics\n                .iter()\n                .any(|d| d.error_code == ErrorCode::E106 || d.error_code == ErrorCode::E107)\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_schema_with_no_nodes_only_vectors_930": {
      "name": "test_schema_with_no_nodes_only_vectors",
      "type": "method",
      "start_line": 930,
      "end_line": 951,
      "content_hash": "0d72eaa5d5a34eb0fe5a73da72590945d545be48",
      "content": "    fn test_schema_with_no_nodes_only_vectors() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY test() =>\n                d <- V<Document>\n                RETURN d\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        // Schema with only vectors should be valid\n    }\n\n    // ============================================================================\n    // Duplicate Field Name Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_field_name_in_node_952": {
      "name": "test_duplicate_field_name_in_node",
      "type": "method",
      "start_line": 952,
      "end_line": 975,
      "content_hash": "1f03b9b1e73f1aa3bcad1f0054220ed62cc15aab",
      "content": "    fn test_duplicate_field_name_in_node() {\n        let source = r#\"\n            N::Person { name: String, age: U32, name: U32 }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E109));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate field\") && d.message.contains(\"name\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_field_name_in_edge_976": {
      "name": "test_duplicate_field_name_in_edge",
      "type": "method",
      "start_line": 976,
      "end_line": 1000,
      "content_hash": "0f9f6ab804b12f64f163298854465d84148e0b86",
      "content": "    fn test_duplicate_field_name_in_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person, Properties: { since: Date, since: String } }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E109));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate field\") && d.message.contains(\"since\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_field_name_in_vector_1001": {
      "name": "test_duplicate_field_name_in_vector",
      "type": "method",
      "start_line": 1001,
      "end_line": 1024,
      "content_hash": "a4077edd20a39644e43c90919760726abeb4cc7d",
      "content": "    fn test_duplicate_field_name_in_vector() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32], content: U32 }\n\n            QUERY test() =>\n                d <- V<Document>\n                RETURN d\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E109));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"duplicate field\") && d.message.contains(\"content\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_duplicate_field_name_case_insensitive_1025": {
      "name": "test_duplicate_field_name_case_insensitive",
      "type": "method",
      "start_line": 1025,
      "end_line": 1044,
      "content_hash": "3f8a376d8403d6b0e9fcb86e8961a6953e5e92ef",
      "content": "    fn test_duplicate_field_name_case_insensitive() {\n        let source = r#\"\n            N::Person { name: String, Name: U32 }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should detect \"Name\" as duplicate of \"name\" (case-insensitive)\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E109));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_no_duplicate_field_names_valid_schema_1045": {
      "name": "test_no_duplicate_field_names_valid_schema",
      "type": "method",
      "start_line": 1045,
      "end_line": 1066,
      "content_hash": "1e04cc5c7b78c35ace3f13d39caa9ed1e51521c7",
      "content": "    fn test_no_duplicate_field_names_valid_schema() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n            E::Knows { From: Person, To: Person, Properties: { since: Date, strength: F64 } }\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not have any E109 errors for valid schema\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E109));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_multiple_duplicate_fields_in_node_1067": {
      "name": "test_multiple_duplicate_fields_in_node",
      "type": "method",
      "start_line": 1067,
      "end_line": 1094,
      "content_hash": "b37e87e26eb15981e27db2e523d6bc70fd42e545",
      "content": "    fn test_multiple_duplicate_fields_in_node() {\n        let source = r#\"\n            N::Person { name: String, age: U32, name: U32, age: F64 }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should detect both duplicates\n        let dup_errors: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| d.error_code == ErrorCode::E109)\n            .collect();\n        assert_eq!(dup_errors.len(), 2);\n    }\n\n    // ============================================================================\n    // Reserved Type Name Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_type_name_node_1095": {
      "name": "test_reserved_type_name_node",
      "type": "method",
      "start_line": 1095,
      "end_line": 1118,
      "content_hash": "c7f331e5ace5f948bd656dc4c509346f9075e842",
      "content": "    fn test_reserved_type_name_node() {\n        let source = r#\"\n            N::Node { name: String }\n\n            QUERY test() =>\n                n <- N<Node>\n                RETURN n\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved type name\") && d.message.contains(\"Node\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_type_name_edge_1119": {
      "name": "test_reserved_type_name_edge",
      "type": "method",
      "start_line": 1119,
      "end_line": 1143,
      "content_hash": "9cbd54ea4a36f0b4bd19343617f455d80ded2c95",
      "content": "    fn test_reserved_type_name_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Edge { From: Person, To: Person }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved type name\") && d.message.contains(\"Edge\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_type_name_hvector_1144": {
      "name": "test_reserved_type_name_hvector",
      "type": "method",
      "start_line": 1144,
      "end_line": 1167,
      "content_hash": "da7c03fd1cbc78010fd209102e0545d9ae66b37e",
      "content": "    fn test_reserved_type_name_hvector() {\n        let source = r#\"\n            V::HVector { content: String, embedding: [F32] }\n\n            QUERY test() =>\n                v <- V<HVector>\n                RETURN v\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved type name\") && d.message.contains(\"HVector\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_type_name_value_1168": {
      "name": "test_reserved_type_name_value",
      "type": "method",
      "start_line": 1168,
      "end_line": 1191,
      "content_hash": "293220c6c3cadb4934caf500f1471e3b0cf7622e",
      "content": "    fn test_reserved_type_name_value() {\n        let source = r#\"\n            N::Value { data: String }\n\n            QUERY test() =>\n                v <- N<Value>\n                RETURN v\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"reserved type name\") && d.message.contains(\"Value\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_reserved_type_name_graph_error_1192": {
      "name": "test_reserved_type_name_graph_error",
      "type": "method",
      "start_line": 1192,
      "end_line": 1210,
      "content_hash": "3610500324d2a4de86475e3f877aeefd4d265ab9",
      "content": "    fn test_reserved_type_name_graph_error() {\n        let source = r#\"\n            N::GraphError { message: String }\n\n            QUERY test() =>\n                e <- N<GraphError>\n                RETURN e\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_non_reserved_type_names_valid_1211": {
      "name": "test_non_reserved_type_names_valid",
      "type": "method",
      "start_line": 1211,
      "end_line": 1232,
      "content_hash": "169c2d6666244b603f3a1e059e112df9a8e7ecba",
      "content": "    fn test_non_reserved_type_names_valid() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { title: String }\n            E::WorksAt { From: Person, To: Company }\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not have any E110 errors for valid names\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E110));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}