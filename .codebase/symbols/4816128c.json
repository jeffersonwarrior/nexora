{
  "file_path": "/work/.local/tools/modelscan/providers/providers_test.go",
  "file_hash": "67a1465cc35eaa5e08a6d3f14bd99bfd275812f9",
  "updated_at": "2025-12-26T17:34:24.428971",
  "symbols": {
    "function_TestProviderRegistration_10": {
      "name": "TestProviderRegistration",
      "type": "function",
      "start_line": 10,
      "end_line": 32,
      "content_hash": "9aaf203adc196f9b9d937504d091f471689b12a2",
      "content": "func TestProviderRegistration(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tprovider string\n\t\twantOk   bool\n\t}{\n\t\t{\"Anthropic registered\", \"anthropic\", true},\n\t\t{\"OpenAI registered\", \"openai\", true},\n\t\t{\"Google registered\", \"google\", true},\n\t\t{\"Mistral registered\", \"mistral\", true},\n\t\t{\"Unknown provider\", \"unknown\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, ok := GetProviderFactory(tt.provider)\n\t\t\tif ok != tt.wantOk {\n\t\t\t\tt.Errorf(\"GetProviderFactory(%q) = %v, want %v\", tt.provider, ok, tt.wantOk)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProviderCreation_33": {
      "name": "TestProviderCreation",
      "type": "function",
      "start_line": 33,
      "end_line": 59,
      "content_hash": "1e41dd2ecc8439282666ef3bd9b93f8cbb6838e9",
      "content": "func TestProviderCreation(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tprovider string\n\t\tapiKey   string\n\t}{\n\t\t{\"Create Anthropic\", \"anthropic\", \"test-key\"},\n\t\t{\"Create OpenAI\", \"openai\", \"test-key\"},\n\t\t{\"Create Google\", \"google\", \"test-key\"},\n\t\t{\"Create Mistral\", \"mistral\", \"test-key\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tfactory, ok := GetProviderFactory(tt.provider)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Provider %q not registered\", tt.provider)\n\t\t\t}\n\n\t\t\tprovider := factory(tt.apiKey)\n\t\t\tif provider == nil {\n\t\t\t\tt.Errorf(\"Factory returned nil provider for %q\", tt.provider)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestListProviders_60": {
      "name": "TestListProviders",
      "type": "function",
      "start_line": 60,
      "end_line": 82,
      "content_hash": "d7b5852ee55e974c30f19e556f31b38d40a1fb11",
      "content": "func TestListProviders(t *testing.T) {\n\tproviders := ListProviders()\n\n\tif len(providers) == 0 {\n\t\tt.Error(\"ListProviders() returned empty list\")\n\t}\n\n\t// Check that expected providers are in the list\n\texpectedProviders := []string{\"anthropic\", \"openai\", \"google\", \"mistral\"}\n\tfor _, expected := range expectedProviders {\n\t\tfound := false\n\t\tfor _, p := range providers {\n\t\t\tif p == expected {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Errorf(\"Expected provider %q not found in list\", expected)\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProviderInterfaces_83": {
      "name": "TestProviderInterfaces",
      "type": "function",
      "start_line": 83,
      "end_line": 126,
      "content_hash": "d084996080d5f7abd54ca4020f6e2822c42d1bfb",
      "content": "func TestProviderInterfaces(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tprovider string\n\t}{\n\t\t{\"Anthropic implements Provider\", \"anthropic\"},\n\t\t{\"OpenAI implements Provider\", \"openai\"},\n\t\t{\"Google implements Provider\", \"google\"},\n\t\t{\"Mistral implements Provider\", \"mistral\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tfactory, ok := GetProviderFactory(tt.provider)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Provider %q not registered\", tt.provider)\n\t\t\t}\n\n\t\t\tprovider := factory(\"test-key\")\n\n\t\t\t// Test that all interface methods exist\n\t\t\tctx := context.Background()\n\n\t\t\t// GetCapabilities should not panic\n\t\t\tcaps := provider.GetCapabilities()\n\t\t\tif caps.MaxTokensPerRequest == 0 {\n\t\t\t\tt.Errorf(\"GetCapabilities() returned zero MaxTokensPerRequest\")\n\t\t\t}\n\n\t\t\t// GetEndpoints should return at least one endpoint\n\t\t\tendpoints := provider.GetEndpoints()\n\t\t\tif len(endpoints) == 0 {\n\t\t\t\tt.Errorf(\"GetEndpoints() returned no endpoints\")\n\t\t\t}\n\n\t\t\t// ValidateEndpoints should not panic (but may fail due to invalid API key)\n\t\t\t_ = provider.ValidateEndpoints(ctx, false)\n\n\t\t\t// ListModels should not panic (but may fail due to invalid API key)\n\t\t\t_, _ = provider.ListModels(ctx, false)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestEndpointStructure_127": {
      "name": "TestEndpointStructure",
      "type": "function",
      "start_line": 127,
      "end_line": 154,
      "content_hash": "86de558621706ef99acaafe93fa93bc3816ea4a0",
      "content": "func TestEndpointStructure(t *testing.T) {\n\tproviders := []string{\"anthropic\", \"openai\", \"google\", \"mistral\"}\n\n\tfor _, provName := range providers {\n\t\tt.Run(provName, func(t *testing.T) {\n\t\t\tfactory, ok := GetProviderFactory(provName)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Provider %q not registered\", provName)\n\t\t\t}\n\n\t\t\tprovider := factory(\"test-key\")\n\t\t\tendpoints := provider.GetEndpoints()\n\n\t\t\tfor i, endpoint := range endpoints {\n\t\t\t\tif endpoint.Path == \"\" {\n\t\t\t\t\tt.Errorf(\"Endpoint %d has empty Path\", i)\n\t\t\t\t}\n\t\t\t\tif endpoint.Method == \"\" {\n\t\t\t\t\tt.Errorf(\"Endpoint %d has empty Method\", i)\n\t\t\t\t}\n\t\t\t\tif endpoint.Method != \"GET\" && endpoint.Method != \"POST\" && endpoint.Method != \"PUT\" && endpoint.Method != \"DELETE\" {\n\t\t\t\t\tt.Errorf(\"Endpoint %d has invalid Method: %q\", i, endpoint.Method)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCapabilitiesStructure_155": {
      "name": "TestCapabilitiesStructure",
      "type": "function",
      "start_line": 155,
      "end_line": 184,
      "content_hash": "26e14ec81aaaa3a6841df31b7a2869eef2960100",
      "content": "func TestCapabilitiesStructure(t *testing.T) {\n\tproviders := []string{\"anthropic\", \"openai\", \"google\", \"mistral\"}\n\n\tfor _, provName := range providers {\n\t\tt.Run(provName, func(t *testing.T) {\n\t\t\tfactory, ok := GetProviderFactory(provName)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Provider %q not registered\", provName)\n\t\t\t}\n\n\t\t\tprovider := factory(\"test-key\")\n\t\t\tcaps := provider.GetCapabilities()\n\n\t\t\t// All providers should support chat\n\t\t\tif !caps.SupportsChat {\n\t\t\t\tt.Errorf(\"Provider %q should support chat\", provName)\n\t\t\t}\n\n\t\t\t// Should have reasonable rate limits\n\t\t\tif caps.MaxRequestsPerMinute <= 0 {\n\t\t\t\tt.Errorf(\"Provider %q has invalid MaxRequestsPerMinute: %d\", provName, caps.MaxRequestsPerMinute)\n\t\t\t}\n\n\t\t\tif caps.MaxTokensPerRequest <= 0 {\n\t\t\t\tt.Errorf(\"Provider %q has invalid MaxTokensPerRequest: %d\", provName, caps.MaxTokensPerRequest)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelStructure_185": {
      "name": "TestModelStructure",
      "type": "function",
      "start_line": 185,
      "end_line": 215,
      "content_hash": "b0e2ba3d8091079043523ad547724d97b7e2fa70",
      "content": "func TestModelStructure(t *testing.T) {\n\tmodel := Model{\n\t\tID:             \"test-model\",\n\t\tName:           \"Test Model\",\n\t\tDescription:    \"A test model\",\n\t\tCostPer1MIn:    1.0,\n\t\tCostPer1MOut:   2.0,\n\t\tContextWindow:  8192,\n\t\tMaxTokens:      4096,\n\t\tSupportsImages: true,\n\t\tSupportsTools:  true,\n\t\tCanReason:      false,\n\t\tCanStream:      true,\n\t\tCategories:     []string{\"chat\", \"test\"},\n\t\tCapabilities:   map[string]string{\"test\": \"value\"},\n\t}\n\n\tif model.ID == \"\" {\n\t\tt.Error(\"Model ID should not be empty\")\n\t}\n\tif model.Name == \"\" {\n\t\tt.Error(\"Model Name should not be empty\")\n\t}\n\tif model.CostPer1MIn < 0 {\n\t\tt.Error(\"CostPer1MIn should not be negative\")\n\t}\n\tif model.ContextWindow <= 0 {\n\t\tt.Error(\"ContextWindow should be positive\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestEndpointStatus_216": {
      "name": "TestEndpointStatus",
      "type": "function",
      "start_line": 216,
      "end_line": 235,
      "content_hash": "73bf76768b6b3fc6f9b5e11e0d9d5ae1c6286217",
      "content": "func TestEndpointStatus(t *testing.T) {\n\ttests := []struct {\n\t\tstatus EndpointStatus\n\t\twant   string\n\t}{\n\t\t{StatusUnknown, \"unknown\"},\n\t\t{StatusWorking, \"working\"},\n\t\t{StatusFailed, \"failed\"},\n\t\t{StatusDeprecated, \"deprecated\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(string(tt.status), func(t *testing.T) {\n\t\t\tif string(tt.status) != tt.want {\n\t\t\t\tt.Errorf(\"EndpointStatus = %q, want %q\", tt.status, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOpenAIProvider_IsUsableModel_236": {
      "name": "TestOpenAIProvider_IsUsableModel",
      "type": "function",
      "start_line": 236,
      "end_line": 267,
      "content_hash": "bcd3bd8f31af79dd93a6241eace863505154ca22",
      "content": "func TestOpenAIProvider_IsUsableModel(t *testing.T) {\n\tprovider := NewOpenAIProvider(\"test-key\").(*OpenAIProvider)\n\n\ttests := []struct {\n\t\tname     string\n\t\tmodelID  string\n\t\texpected bool\n\t}{\n\t\t{\"GPT-4\", \"gpt-4\", true},\n\t\t{\"GPT-4 Turbo\", \"gpt-4-turbo\", true},\n\t\t{\"GPT-3.5\", \"gpt-3.5-turbo\", true},\n\t\t{\"Embedding model\", \"text-embedding-ada-002\", false},\n\t\t{\"Whisper\", \"whisper-1\", false},\n\t\t{\"TTS\", \"tts-1\", false},\n\t\t{\"DALL-E\", \"dall-e-3\", false},\n\t\t{\"Moderation\", \"text-moderation-latest\", false},\n\t\t{\"Old davinci\", \"text-davinci-003\", false},\n\t\t{\"Old curie\", \"text-curie-001\", false},\n\t\t{\"Old babbage\", \"text-babbage-001\", false},\n\t\t{\"Old ada\", \"text-ada-001\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := provider.isUsableModel(tt.modelID)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"isUsableModel(%q) = %v, want %v\", tt.modelID, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOpenAIProvider_FormatModelName_268": {
      "name": "TestOpenAIProvider_FormatModelName",
      "type": "function",
      "start_line": 268,
      "end_line": 294,
      "content_hash": "88be7794f96a31601627994e93ca7934a6a920c3",
      "content": "func TestOpenAIProvider_FormatModelName(t *testing.T) {\n\tprovider := NewOpenAIProvider(\"test-key\").(*OpenAIProvider)\n\n\ttests := []struct {\n\t\tname     string\n\t\tmodelID  string\n\t\tcontains string\n\t}{\n\t\t{\"GPT-4 Omni\", \"gpt-4o\", \"GPT-4 Omni\"},\n\t\t{\"GPT-4 Turbo\", \"gpt-4-turbo\", \"GPT-4 Turbo\"},\n\t\t{\"GPT-4\", \"gpt-4\", \"GPT-4:\"},\n\t\t{\"GPT-3.5\", \"gpt-3.5-turbo\", \"GPT-3.5:\"},\n\t\t{\"O1\", \"o1-preview\", \"O-Series Reasoning\"},\n\t\t{\"O3\", \"o3-mini\", \"O-Series Reasoning\"},\n\t\t{\"Unknown\", \"unknown-model\", \"unknown-model\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := provider.formatModelName(tt.modelID)\n\t\t\tif !strings.Contains(result, tt.contains) {\n\t\t\t\tt.Errorf(\"formatModelName(%q) = %q, want to contain %q\", tt.modelID, result, tt.contains)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOpenAIProvider_EnrichModelDetails_295": {
      "name": "TestOpenAIProvider_EnrichModelDetails",
      "type": "function",
      "start_line": 295,
      "end_line": 348,
      "content_hash": "4bf0fe0382549ecf9c442e4bb5977ea17fd802f0",
      "content": "func TestOpenAIProvider_EnrichModelDetails(t *testing.T) {\n\tprovider := NewOpenAIProvider(\"test-key\").(*OpenAIProvider)\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodelID       string\n\t\tcheckSupports bool\n\t\tcheckContext  bool\n\t\texpectVision  bool\n\t\texpectReason  bool\n\t}{\n\t\t{\"GPT-4\", \"gpt-4\", true, true, false, true},\n\t\t{\"GPT-4 Turbo\", \"gpt-4-turbo-preview\", true, true, true, true},\n\t\t{\"GPT-3.5\", \"gpt-3.5-turbo\", true, true, false, false},\n\t\t{\"GPT-4o\", \"gpt-4o\", true, true, true, true},\n\t\t{\"GPT-4o-mini\", \"gpt-4o-mini\", true, true, true, false},\n\t\t{\"O1\", \"o1-2024-12-17\", true, true, false, true},\n\t\t{\"O1-mini\", \"o1-mini\", true, true, false, true},\n\t\t{\"O3\", \"o3-mini\", true, true, true, true},\n\t\t{\"Unknown\", \"unknown-model\", true, false, false, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tmodel := Model{\n\t\t\t\tID: tt.modelID,\n\t\t\t}\n\n\t\t\tenriched := provider.enrichModelDetails(model)\n\n\t\t\tif tt.checkSupports {\n\t\t\t\tif !enriched.SupportsTools {\n\t\t\t\t\tt.Error(\"Expected SupportsTools to be true\")\n\t\t\t\t}\n\t\t\t\tif !enriched.CanStream {\n\t\t\t\t\tt.Error(\"Expected CanStream to be true\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tt.checkContext && enriched.ContextWindow == 0 {\n\t\t\t\tt.Error(\"Expected ContextWindow to be set\")\n\t\t\t}\n\n\t\t\t// Check vision and reasoning\n\t\t\tif enriched.SupportsImages != tt.expectVision {\n\t\t\t\tt.Errorf(\"Expected SupportsImages=%v, got %v\", tt.expectVision, enriched.SupportsImages)\n\t\t\t}\n\t\t\tif enriched.CanReason != tt.expectReason {\n\t\t\t\tt.Errorf(\"Expected CanReason=%v, got %v\", tt.expectReason, enriched.CanReason)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAnthropicProvider_EnrichModelDetails_349": {
      "name": "TestAnthropicProvider_EnrichModelDetails",
      "type": "function",
      "start_line": 349,
      "end_line": 384,
      "content_hash": "91e1ba5b7974534d812c6f98cbf59ca78d1ab568",
      "content": "func TestAnthropicProvider_EnrichModelDetails(t *testing.T) {\n\tprovider := NewAnthropicProvider(\"test-key\").(*AnthropicProvider)\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodelID       string\n\t\texpectContext bool\n\t}{\n\t\t{\"Claude 3 Opus\", \"claude-3-opus-20240229\", true},\n\t\t{\"Claude 3 Sonnet\", \"claude-3-sonnet-20240229\", true},\n\t\t{\"Claude 3.5 Sonnet\", \"claude-3-5-sonnet-20240620\", true},\n\t\t{\"Claude 2\", \"claude-2\", true},\n\t\t{\"Unknown\", \"unknown-model\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tmodel := Model{\n\t\t\t\tID: tt.modelID,\n\t\t\t}\n\n\t\t\tenriched := provider.enrichModelDetails(model)\n\n\t\t\tif tt.expectContext && enriched.ContextWindow == 0 {\n\t\t\t\tt.Errorf(\"Expected ContextWindow to be set for %s\", tt.modelID)\n\t\t\t}\n\t\t\tif !enriched.CanStream {\n\t\t\t\tt.Error(\"Expected CanStream to be true\")\n\t\t\t}\n\t\t\tif !enriched.SupportsTools {\n\t\t\t\tt.Error(\"Expected SupportsTools to be true\")\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_GetEndpoints_385": {
      "name": "TestProvider_GetEndpoints",
      "type": "function",
      "start_line": 385,
      "end_line": 412,
      "content_hash": "6ebed1e7f3cf499608bd533f18b348023f658c84",
      "content": "func TestProvider_GetEndpoints(t *testing.T) {\n\tproviders := map[string]Provider{\n\t\t\"openai\":    NewOpenAIProvider(\"test-key\"),\n\t\t\"anthropic\": NewAnthropicProvider(\"test-key\"),\n\t\t\"google\":    NewGoogleProvider(\"test-key\"),\n\t\t\"mistral\":   NewMistralProvider(\"test-key\"),\n\t}\n\n\tfor name, provider := range providers {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tendpoints := provider.GetEndpoints()\n\t\t\tif len(endpoints) == 0 {\n\t\t\t\tt.Errorf(\"%s: expected endpoints, got none\", name)\n\t\t\t}\n\n\t\t\t// Verify endpoint structure\n\t\t\tfor _, ep := range endpoints {\n\t\t\t\tif ep.Path == \"\" {\n\t\t\t\t\tt.Errorf(\"%s: endpoint has empty path\", name)\n\t\t\t\t}\n\t\t\t\tif ep.Method == \"\" {\n\t\t\t\t\tt.Errorf(\"%s: endpoint has empty method\", name)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_GetCapabilities_413": {
      "name": "TestProvider_GetCapabilities",
      "type": "function",
      "start_line": 413,
      "end_line": 437,
      "content_hash": "5ffcb648b750070ad22272007d05d1b15e0c9633",
      "content": "func TestProvider_GetCapabilities(t *testing.T) {\n\tproviders := map[string]Provider{\n\t\t\"openai\":    NewOpenAIProvider(\"test-key\"),\n\t\t\"anthropic\": NewAnthropicProvider(\"test-key\"),\n\t\t\"google\":    NewGoogleProvider(\"test-key\"),\n\t\t\"mistral\":   NewMistralProvider(\"test-key\"),\n\t}\n\n\tfor name, provider := range providers {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tcaps := provider.GetCapabilities()\n\n\t\t\t// All providers should support at least chat\n\t\t\tif !caps.SupportsChat {\n\t\t\t\tt.Errorf(\"%s: should support chat\", name)\n\t\t\t}\n\n\t\t\t// All providers should support streaming\n\t\t\tif !caps.SupportsStreaming {\n\t\t\t\tt.Errorf(\"%s: should support streaming\", name)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOpenAIProvider_SpecificEndpoints_438": {
      "name": "TestOpenAIProvider_SpecificEndpoints",
      "type": "function",
      "start_line": 438,
      "end_line": 468,
      "content_hash": "683c27cb351ff8447682522d460f2500d026fc1e",
      "content": "func TestOpenAIProvider_SpecificEndpoints(t *testing.T) {\n\tprovider := NewOpenAIProvider(\"test-key\")\n\tendpoints := provider.GetEndpoints()\n\n\t// Look for specific OpenAI endpoints\n\thasChatCompletions := false\n\thasModels := false\n\n\tfor _, ep := range endpoints {\n\t\tif strings.Contains(ep.Path, \"chat/completions\") {\n\t\t\thasChatCompletions = true\n\t\t\tif ep.Method != \"POST\" {\n\t\t\t\tt.Errorf(\"chat/completions should be POST, got %s\", ep.Method)\n\t\t\t}\n\t\t}\n\t\tif strings.Contains(ep.Path, \"models\") {\n\t\t\thasModels = true\n\t\t\tif ep.Method != \"GET\" {\n\t\t\t\tt.Errorf(\"models should be GET, got %s\", ep.Method)\n\t\t\t}\n\t\t}\n\t}\n\n\tif !hasChatCompletions {\n\t\tt.Error(\"Missing chat/completions endpoint\")\n\t}\n\tif !hasModels {\n\t\tt.Error(\"Missing models endpoint\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProviderCapabilities_Fields_469": {
      "name": "TestProviderCapabilities_Fields",
      "type": "function",
      "start_line": 469,
      "end_line": 489,
      "content_hash": "c7f4c61886b00feb8f663245fa87115ea2d11570",
      "content": "func TestProviderCapabilities_Fields(t *testing.T) {\n\t// Test that we can access capability fields\n\tcaps := ProviderCapabilities{\n\t\tSupportsChat:       true,\n\t\tSupportsStreaming:  true,\n\t\tSupportsVision:     true,\n\t\tSupportsJSONMode:   true,\n\t\tSupportsEmbeddings: true,\n\t}\n\n\tif !caps.SupportsChat {\n\t\tt.Error(\"Expected SupportsChat to be true\")\n\t}\n\tif !caps.SupportsStreaming {\n\t\tt.Error(\"Expected SupportsStreaming to be true\")\n\t}\n\tif !caps.SupportsVision {\n\t\tt.Error(\"Expected SupportsVision to be true\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_ValidateEndpoints_Structure_490": {
      "name": "TestProvider_ValidateEndpoints_Structure",
      "type": "function",
      "start_line": 490,
      "end_line": 512,
      "content_hash": "471668e8f076b6f24df97e8244f9eee7b7dbc68c",
      "content": "func TestProvider_ValidateEndpoints_Structure(t *testing.T) {\n\tproviders := map[string]Provider{\n\t\t\"openai\":    NewOpenAIProvider(\"test-key\"),\n\t\t\"anthropic\": NewAnthropicProvider(\"test-key\"),\n\t\t\"google\":    NewGoogleProvider(\"test-key\"),\n\t\t\"mistral\":   NewMistralProvider(\"test-key\"),\n\t}\n\n\tfor name, provider := range providers {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Test ValidateEndpoints with cancelled context\n\t\t\t// This will exercise the function without making real HTTP calls\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel() // Cancel immediately\n\n\t\t\terr := provider.ValidateEndpoints(ctx, false)\n\t\t\t// We expect either an error or success (depending on implementation)\n\t\t\t// The important thing is the function doesn't panic\n\t\t\t_ = err // Function executed without panic\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProvider_ListModels_WithInvalidKey_513": {
      "name": "TestProvider_ListModels_WithInvalidKey",
      "type": "function",
      "start_line": 513,
      "end_line": 541,
      "content_hash": "5532e06d6bec13f974174df2e7e05a103fa20dea",
      "content": "func TestProvider_ListModels_WithInvalidKey(t *testing.T) {\n\t// Skip this test in CI/CD environments\n\tif testing.Short() {\n\t\tt.Skip(\"Skipping integration test in short mode\")\n\t}\n\n\tproviders := map[string]Provider{\n\t\t\"openai\":    NewOpenAIProvider(\"invalid-key-test\"),\n\t\t\"anthropic\": NewAnthropicProvider(\"invalid-key-test\"),\n\t\t\"google\":    NewGoogleProvider(\"invalid-key-test\"),\n\t\t\"mistral\":   NewMistralProvider(\"invalid-key-test\"),\n\t}\n\n\tfor name, provider := range providers {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tmodels, err := provider.ListModels(ctx, false)\n\t\t\t// With invalid key, we expect an error\n\t\t\t// But the function should not panic\n\t\t\tif err == nil && len(models) == 0 {\n\t\t\t\tt.Logf(\"%s: No models returned (expected with invalid key)\", name)\n\t\t\t}\n\t\t\t// Function executed without panic\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModel_Structure_542": {
      "name": "TestModel_Structure",
      "type": "function",
      "start_line": 542,
      "end_line": 572,
      "content_hash": "a8c99fd46b08b55cdf62dc2602e0f11cf7deb569",
      "content": "func TestModel_Structure(t *testing.T) {\n\t// Test that Model struct can be created and accessed\n\tmodel := Model{\n\t\tID:             \"test-model\",\n\t\tName:           \"Test Model\",\n\t\tDescription:    \"A test model\",\n\t\tCostPer1MIn:    0.001,\n\t\tCostPer1MOut:   0.002,\n\t\tContextWindow:  4096,\n\t\tMaxTokens:      2048,\n\t\tSupportsImages: true,\n\t\tSupportsTools:  true,\n\t\tCanReason:      false,\n\t\tCanStream:      true,\n\t\tCategories:     []string{\"chat\", \"text\"},\n\t}\n\n\tif model.ID != \"test-model\" {\n\t\tt.Error(\"Model ID not set correctly\")\n\t}\n\tif model.ContextWindow != 4096 {\n\t\tt.Error(\"Model ContextWindow not set correctly\")\n\t}\n\tif !model.SupportsTools {\n\t\tt.Error(\"Model SupportsTools not set correctly\")\n\t}\n\tif len(model.Categories) != 2 {\n\t\tt.Error(\"Model Categories not set correctly\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestEndpoint_Structure_573": {
      "name": "TestEndpoint_Structure",
      "type": "function",
      "start_line": 573,
      "end_line": 593,
      "content_hash": "39ab506b040a9f31f1610b6d8d984f2a36f5d7c9",
      "content": "func TestEndpoint_Structure(t *testing.T) {\n\t// Test Endpoint struct\n\tendpoint := Endpoint{\n\t\tPath:        \"/v1/chat/completions\",\n\t\tMethod:      \"POST\",\n\t\tDescription: \"Chat completions endpoint\",\n\t\tStatus:      StatusWorking,\n\t\tLatency:     100 * time.Millisecond,\n\t}\n\n\tif endpoint.Path != \"/v1/chat/completions\" {\n\t\tt.Error(\"Endpoint Path not set correctly\")\n\t}\n\tif endpoint.Method != \"POST\" {\n\t\tt.Error(\"Endpoint Method not set correctly\")\n\t}\n\tif endpoint.Status != StatusWorking {\n\t\tt.Error(\"Endpoint Status not set correctly\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProviderMetadata_Complete_594": {
      "name": "TestProviderMetadata_Complete",
      "type": "function",
      "start_line": 594,
      "end_line": 627,
      "content_hash": "c0bd7a04e5f35bc8ebbc24e2ed6f8c6b28673bb2",
      "content": "func TestProviderMetadata_Complete(t *testing.T) {\n\tproviders := map[string]Provider{\n\t\t\"openai\":    NewOpenAIProvider(\"test-key\"),\n\t\t\"anthropic\": NewAnthropicProvider(\"test-key\"),\n\t\t\"google\":    NewGoogleProvider(\"test-key\"),\n\t\t\"mistral\":   NewMistralProvider(\"test-key\"),\n\t}\n\n\tfor name, provider := range providers {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Test GetEndpoints\n\t\t\tendpoints := provider.GetEndpoints()\n\t\t\tif len(endpoints) == 0 {\n\t\t\t\tt.Errorf(\"%s: No endpoints defined\", name)\n\t\t\t}\n\n\t\t\t// Test GetCapabilities\n\t\t\tcaps := provider.GetCapabilities()\n\n\t\t\t// Verify capabilities struct has some true fields\n\t\t\thasAnyCapability := caps.SupportsChat ||\n\t\t\t\tcaps.SupportsStreaming ||\n\t\t\t\tcaps.SupportsEmbeddings ||\n\t\t\t\tcaps.SupportsVision ||\n\t\t\t\tcaps.SupportsJSONMode ||\n\t\t\t\tcaps.SupportsFIM ||\n\t\t\t\tcaps.SupportsAgents\n\n\t\t\tif !hasAnyCapability {\n\t\t\t\tt.Errorf(\"%s: Provider has no capabilities enabled\", name)\n\t\t\t}\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}