{
  "file_path": "/work/context-engine/tests/test_integration_qdrant.py",
  "file_hash": "c048631e9b75b88f3f02e768973f915c7afe4343",
  "updated_at": "2025-12-26T17:34:21.559144",
  "symbols": {
    "class_FakeEmbedder_15": {
      "name": "FakeEmbedder",
      "type": "class",
      "start_line": 15,
      "end_line": 34,
      "content_hash": "9e376d2206e4a174ec34cb03fe7367e4ff93ed8c",
      "content": "class FakeEmbedder:\n    def __init__(self, model_name: str = \"fake\"):\n        self.model_name = model_name\n\n    class _Vec:\n        def __init__(self, arr):\n            self._arr = arr\n\n        def tolist(self):\n            return self._arr\n\n        def __len__(self):\n            return len(self._arr)\n\n    def embed(self, texts):\n        # Deterministic small vector by hashing; yields objects with .tolist()\n        for t in texts:\n            h = sum(ord(c) for c in t) % 997\n            vec = [(float((h + i) % 13) / 13.0) for i in range(32)]\n            yield self._Vec(vec)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___16": {
      "name": "__init__",
      "type": "method",
      "start_line": 16,
      "end_line": 17,
      "content_hash": "0fb67702324c29fd98072d614d7c56189685fa17",
      "content": "    def __init__(self, model_name: str = \"fake\"):\n        self.model_name = model_name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class__Vec_19": {
      "name": "_Vec",
      "type": "class",
      "start_line": 19,
      "end_line": 27,
      "content_hash": "b537fa2eb2cdaca8c80c7e196f45896491b91420",
      "content": "    class _Vec:\n        def __init__(self, arr):\n            self._arr = arr\n\n        def tolist(self):\n            return self._arr\n\n        def __len__(self):\n            return len(self._arr)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___20": {
      "name": "__init__",
      "type": "method",
      "start_line": 20,
      "end_line": 21,
      "content_hash": "1a6311791de6e83903db940df6920ca4bb3d31ed",
      "content": "        def __init__(self, arr):\n            self._arr = arr",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tolist_23": {
      "name": "tolist",
      "type": "method",
      "start_line": 23,
      "end_line": 24,
      "content_hash": "48b68fcaed05deaa04a77181edc1aff3229435e7",
      "content": "        def tolist(self):\n            return self._arr",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___len___26": {
      "name": "__len__",
      "type": "method",
      "start_line": 26,
      "end_line": 27,
      "content_hash": "4dd660df55df9f47809cea6b1f1b70260ab86436",
      "content": "        def __len__(self):\n            return len(self._arr)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_embed_29": {
      "name": "embed",
      "type": "method",
      "start_line": 29,
      "end_line": 34,
      "content_hash": "cfb3a94a03a96534a508f3604967eeba0be3acfd",
      "content": "    def embed(self, texts):\n        # Deterministic small vector by hashing; yields objects with .tolist()\n        for t in texts:\n            h = sum(ord(c) for c in t) % 997\n            vec = [(float((h + i) % 13) / 13.0) for i in range(32)]\n            yield self._Vec(vec)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_qdrant_container_38": {
      "name": "qdrant_container",
      "type": "function",
      "start_line": 38,
      "end_line": 87,
      "content_hash": "45c1b471ea3d3f790b19512a99f4bb57b7e1cea9",
      "content": "def qdrant_container():\n    os.environ.setdefault(\"TESTCONTAINERS_RYUK_DISABLED\", \"true\")\n    os.environ.setdefault(\"TESTCONTAINERS_RYUK_TIMEOUT\", \"0\")\n    try:\n        from testcontainers.core.container import DockerContainer\n    except Exception as e:  # pragma: no cover\n        pytest.skip(\"testcontainers not available\")\n    import time, urllib.request\n\n    container = DockerContainer(\"qdrant/qdrant:latest\").with_env(\n        \"TESTCONTAINERS_RYUK_DISABLED\", \"true\"\n    ).with_env(\"TESTCONTAINERS_RYUK_TIMEOUT\", \"0\").with_exposed_ports(6333)\n\n    ready = False\n    try:\n        container.start()\n        host = container.get_container_host_ip()\n        deadline = time.time() + 30\n        port = None\n        last_exc = None\n        while time.time() < deadline:\n            try:\n                port = int(container.get_exposed_port(6333))\n                break\n            except Exception as exc:\n                last_exc = exc\n                time.sleep(0.25)\n        if port is None:\n            raise RuntimeError(f\"qdrant port mapping unavailable: {last_exc}\")\n        url = f\"http://{host}:{port}\"\n\n        deadline = time.time() + 60\n        while time.time() < deadline:\n            try:\n                with urllib.request.urlopen(url + \"/readyz\", timeout=2) as r:\n                    if 200 <= r.status < 300:\n                        ready = True\n                        break\n            except Exception:\n                pass\n            time.sleep(1)\n        if not ready:\n            pytest.skip(\"Qdrant not ready in time\")\n\n        yield url\n    finally:\n        try:\n            container.stop()\n        except Exception:\n            pass",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_index_and_search_minirepo_91": {
      "name": "test_index_and_search_minirepo",
      "type": "function",
      "start_line": 91,
      "end_line": 138,
      "content_hash": "9c6ecb25eea9b7bcd508f2bcf8158fda4127a0bd",
      "content": "def test_index_and_search_minirepo(tmp_path, monkeypatch, qdrant_container):\n    # Env for services\n    os.environ[\"QDRANT_URL\"] = qdrant_container\n    os.environ[\"COLLECTION_NAME\"] = f\"test-{uuid.uuid4().hex[:8]}\"\n    os.environ[\"USE_TREE_SITTER\"] = \"0\"\n    os.environ[\"HYBRID_IN_PROCESS\"] = \"1\"\n    os.environ[\"EMBEDDING_MODEL\"] = \"fake\"\n\n    # Stub embeddings everywhere (FakeEmbedder produces 32-dim vectors)\n    monkeypatch.setattr(ing, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_model_dimension\", lambda *a, **k: 32)  # Match FakeEmbedder dim\n    monkeypatch.setattr(\n        srv, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\")\n    )\n    monkeypatch.setattr(hy, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(hy, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n\n    # Create tiny repo\n    (tmp_path / \"pkg\").mkdir()\n    f1 = tmp_path / \"pkg\" / \"a.py\"\n    f1.write_text(\"def f():\\n    return 1\\n\")\n    f2 = tmp_path / \"pkg\" / \"b.md\"\n    f2.write_text(\"hello world\\nthis is a test\\n\")\n\n    # Index via function call (no shell)\n    ing.index_repo(\n        root=tmp_path,\n        qdrant_url=qdrant_container,\n        api_key=\"\",\n        collection=os.environ[\"COLLECTION_NAME\"],\n        model_name=\"fake\",\n        recreate=True,\n    )\n\n    # Search directly via async function\n    res = srv.asyncio.get_event_loop().run_until_complete(\n        srv.repo_search(\n            queries=[\"def f\"],\n            limit=5,\n            language=\"python\",\n            include_snippet=True,\n            compact=False,\n        )\n    )\n\n    assert res.get(\"ok\", True)\n    assert any(str(f1) in (r.get(\"path\") or \"\") for r in res.get(\"results\", []))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_filters_language_and_path_142": {
      "name": "test_filters_language_and_path",
      "type": "function",
      "start_line": 142,
      "end_line": 202,
      "content_hash": "962647d72332b6ecf80b95cb77b63f4895dfecd1",
      "content": "def test_filters_language_and_path(tmp_path, monkeypatch, qdrant_container):\n    # Reuse container; set env\n    os.environ[\"QDRANT_URL\"] = qdrant_container\n    os.environ.setdefault(\"COLLECTION_NAME\", f\"test-{uuid.uuid4().hex[:8]}\")\n    os.environ[\"USE_TREE_SITTER\"] = \"0\"\n    os.environ[\"HYBRID_IN_PROCESS\"] = \"1\"\n    os.environ[\"EMBEDDING_MODEL\"] = \"fake\"\n\n    # Stub embeddings (FakeEmbedder produces 32-dim vectors)\n    monkeypatch.setattr(ing, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(embedder, \"get_model_dimension\", lambda *a, **k: 32)  # Match FakeEmbedder dim\n    monkeypatch.setattr(\n        srv, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\")\n    )\n    monkeypatch.setattr(hy, \"TextEmbedding\", lambda *a, **k: FakeEmbedder(\"fake\"))\n    monkeypatch.setattr(hy, \"_get_embedding_model\", lambda *a, **k: FakeEmbedder(\"fake\"))\n\n    # Create tiny repo again in this temp path\n    (tmp_path / \"pkg\").mkdir()\n    (tmp_path / \"pkg\" / \"a.py\").write_text(\"def f():\\n    return 1\\n\")\n    (tmp_path / \"pkg\" / \"b.md\").write_text(\"hello world\\nthis is a test\\n\")\n\n    # Ensure index exists from previous test; run a no-op ingest to be safe\n    ing.index_repo(\n        root=tmp_path,\n        qdrant_url=qdrant_container,\n        api_key=\"\",\n        collection=os.environ[\"COLLECTION_NAME\"],\n        model_name=\"fake\",\n        recreate=False,\n    )\n\n    f_py = str(tmp_path / \"pkg\" / \"a.py\")\n    f_md = str(tmp_path / \"pkg\" / \"b.md\")\n\n    # Filter by language=python should bias toward .py\n    res1 = srv.asyncio.get_event_loop().run_until_complete(\n        srv.repo_search(queries=[\"def\"], limit=5, language=\"python\", compact=False)\n    )\n    assert any(f_py in (r.get(\"path\") or \"\") for r in res1.get(\"results\", []))\n\n    # Filter by ext=txt should retrieve text file\n    res2 = srv.asyncio.get_event_loop().run_until_complete(\n        srv.repo_search(queries=[\"hello\"], limit=5, ext=\"md\", compact=False)\n    )\n    assert any(f_md in (r.get(\"path\") or \"\") for r in res2.get(\"results\", []))\n\n    # Path glob to only allow pkg/*.py\n    res3 = srv.asyncio.get_event_loop().run_until_complete(\n        srv.repo_search(\n            queries=[\"def\"],\n            limit=5,\n            path_glob=str(tmp_path / \"pkg\" / \"*.py\"),\n            compact=False,\n        )\n    )\n    assert all(\n        \"/pkg/\" in (r.get(\"path\") or \"\") and r.get(\"path\", \"\").endswith(\".py\")\n        for r in res3.get(\"results\", [])\n    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}