{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/traversal_core/ops/source/e_from_type.rs",
  "file_hash": "7747d5f97935a67f05c8bdb73592cb0373902d3d",
  "updated_at": "2025-12-26T17:34:23.440797",
  "symbols": {
    "struct_EFromType_16": {
      "name": "EFromType",
      "type": "struct",
      "start_line": 16,
      "end_line": 24,
      "content_hash": "532211bad464fd1ef9df324f631e2802decc1ff2",
      "content": "pub struct EFromType<'arena, 'txn, 's>\nwhere\n    'arena: 'txn,\n{\n    pub arena: &'arena bumpalo::Bump,\n    pub iter: heed3::RoIter<'txn, U128<BE>, heed3::types::LazyDecode<Bytes>>,\n    pub label: &'s [u8],\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_25": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 25,
      "end_line": 27,
      "content_hash": "e5da8953e3dca047b43893a83e2b96411e72e6e8",
      "content": "impl<'arena, 'txn, 's> Iterator for EFromType<'arena, 'txn, 's> {\n    type Item = Result<TraversalValue<'arena>, GraphError>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_28": {
      "name": "next",
      "type": "method",
      "start_line": 28,
      "end_line": 70,
      "content_hash": "184e5603348538b1e0dff5daa54565b79f379118",
      "content": "    fn next(&mut self) -> Option<Self::Item> {\n        for value in self.iter.by_ref() {\n            let (id, value) = value.unwrap();\n\n            match value.decode() {\n                Ok(value) => {\n                    assert!(\n                        value.len() >= LMDB_STRING_HEADER_LENGTH,\n                        \"value length does not contain header which means the `label` field was missing from the node on insertion\"\n                    );\n                    let length_of_label_in_lmdb =\n                        u64::from_le_bytes(value[..LMDB_STRING_HEADER_LENGTH].try_into().unwrap())\n                            as usize;\n\n                    println!(\"{:?}\", value);\n\n                    assert!(\n                        value.len() >= length_of_label_in_lmdb + LMDB_STRING_HEADER_LENGTH,\n                        \"value length is not at least the header length plus the label length meaning there has been a corruption on node insertion\"\n                    );\n                    let label_in_lmdb = &value[LMDB_STRING_HEADER_LENGTH\n                        ..LMDB_STRING_HEADER_LENGTH + length_of_label_in_lmdb];\n\n                    if label_in_lmdb == self.label {\n                        match Edge::<'arena>::from_bincode_bytes(id, value, self.arena) {\n                            Ok(edge) => {\n                                return Some(Ok(TraversalValue::Edge(edge)));\n                            }\n                            Err(e) => {\n                                println!(\"{} Error decoding edge: {:?}\", line!(), e);\n                                return Some(Err(GraphError::ConversionError(e.to_string())));\n                            }\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n                Err(e) => return Some(Err(GraphError::ConversionError(e.to_string()))),\n            }\n        }\n        None\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_EFromTypeAdapter_71": {
      "name": "EFromTypeAdapter",
      "type": "trait",
      "start_line": 71,
      "end_line": 73,
      "content_hash": "0e13c06014a7b90c0fffb822ba4d2f3627f3f475",
      "content": "pub trait EFromTypeAdapter<'db, 'arena, 'txn, 's>:\n    Iterator<Item = Result<TraversalValue<'arena>, GraphError>>\n{",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_e_from_type_74": {
      "name": "e_from_type",
      "type": "method",
      "start_line": 74,
      "end_line": 80,
      "content_hash": "300bd0c52560f01c3524b14683388fac37ec52e6",
      "content": "    fn e_from_type(\n        self,\n        label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_81": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 81,
      "end_line": 87,
      "content_hash": "37079dab83e7e3dd8b608e00fa3f69e056089952",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n}\nimpl<'db, 'arena, 'txn, 's, I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>>\n    EFromTypeAdapter<'db, 'arena, 'txn, 's> for RoTraversalIterator<'db, 'arena, 'txn, I>\n{\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_e_from_type_88": {
      "name": "e_from_type",
      "type": "method",
      "start_line": 88,
      "end_line": 94,
      "content_hash": "300bd0c52560f01c3524b14683388fac37ec52e6",
      "content": "    fn e_from_type(\n        self,\n        label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_95": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 95,
      "end_line": 114,
      "content_hash": "a5153a479f78fde18f3815339ecf609c45978578",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let iter = self\n            .storage\n            .edges_db\n            .lazily_decode_data()\n            .iter(self.txn)\n            .unwrap();\n        RoTraversalIterator {\n            storage: self.storage,\n            arena: self.arena,\n            txn: self.txn,\n            inner: EFromType {\n                arena: self.arena,\n                iter,\n                label: label.as_bytes(),\n            },\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}