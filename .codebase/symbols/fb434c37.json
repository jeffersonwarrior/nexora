{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/mod.rs",
  "file_hash": "28830105b1673603e7c643536ccd13b42c55459c",
  "updated_at": "2025-12-26T17:34:24.959982",
  "symbols": {
    "function_analyze_29": {
      "name": "analyze",
      "type": "function",
      "start_line": 29,
      "end_line": 61,
      "content_hash": "2e9e6e8d17c4d6084765fd50956a52e719e8bc57",
      "content": "pub fn analyze(src: &Source) -> Result<(Vec<Diagnostic>, GeneratedSource), ParserError> {\n    let mut ctx = Ctx::new(src)?;\n    ctx.check_schema()?;\n    ctx.check_schema_migrations();\n    ctx.check_queries();\n    Ok((ctx.diagnostics, ctx.output))\n}\n\npub mod diagnostic;\npub mod error_codes;\npub mod errors;\npub mod fix;\npub mod methods;\npub mod pretty;\npub mod types;\npub mod utils;\n\n\n/// Internal working context shared by all passes.\npub(crate) struct Ctx<'a> {\n    pub(super) src: &'a Source,\n    /// Quick look\u2011ups\n    pub(super) node_set: HashSet<&'a str>,\n    pub(super) vector_set: HashSet<&'a str>,\n    pub(super) edge_map: HashMap<&'a str, &'a EdgeSchema>,\n    pub(super) node_fields: HashMap<&'a str, HashMap<&'a str, Cow<'a, Field>>>,\n    pub(super) edge_fields: HashMap<&'a str, HashMap<&'a str, Cow<'a, Field>>>,\n    pub(super) vector_fields: HashMap<&'a str, HashMap<&'a str, Cow<'a, Field>>>,\n    pub(super) all_schemas: SchemaVersionMap<'a>,\n    pub(super) diagnostics: Vec<Diagnostic>,\n    pub(super) output: GeneratedSource,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ctx_62": {
      "name": "Ctx",
      "type": "impl",
      "start_line": 62,
      "end_line": 165,
      "content_hash": "76f83db7ad6a6ddc5b35a255a21256a126e74c48",
      "content": "impl<'a> Ctx<'a> {\n    pub(super) fn new(src: &'a Source) -> Result<Self, ParserError> {\n        // Build field look\u2011ups once\n        let all_schemas = build_field_lookups(src);\n        let (node_fields, edge_fields, vector_fields) = all_schemas.get_latest();\n\n        // Build secondary indices from indexed fields\n        let secondary_indices: Vec<String> = src\n            .get_latest_schema()?\n            .node_schemas\n            .iter()\n            .flat_map(|schema| {\n                schema\n                    .fields\n                    .iter()\n                    .filter(|f| f.is_indexed())\n                    .map(|f| f.name.clone())\n            })\n            .dedup()\n            .collect();\n\n        // Create the context first (without output populated)\n        let mut ctx = Self {\n            node_set: src\n                .get_latest_schema()?\n                .node_schemas\n                .iter()\n                .map(|n| n.name.1.as_str())\n                .collect(),\n            vector_set: src\n                .get_latest_schema()?\n                .vector_schemas\n                .iter()\n                .map(|v| v.name.as_str())\n                .collect(),\n            edge_map: src\n                .get_latest_schema()?\n                .edge_schemas\n                .iter()\n                .map(|e| (e.name.1.as_str(), e))\n                .collect(),\n            node_fields,\n            edge_fields,\n            vector_fields,\n            all_schemas,\n            src,\n            diagnostics: Vec::new(),\n            output: GeneratedSource {\n                src: src.source.clone(),\n                ..Default::default()\n            },\n        };\n\n        // Now build introspection data from the context\n        let introspection_data = IntrospectionData::from_schema(&ctx);\n\n        // Update the output with introspection data and secondary indices\n        ctx.output.introspection_data = Some(introspection_data);\n        ctx.output.secondary_indices = secondary_indices;\n\n        Ok(ctx)\n    }\n\n    #[allow(unused)]\n    pub(super) fn get_item_fields(\n        &self,\n        item_type: &Type,\n    ) -> Option<&HashMap<&str, Cow<'_, Field>>> {\n        match item_type {\n            Type::Node(Some(node_type)) | Type::Nodes(Some(node_type)) => {\n                self.node_fields.get(node_type.as_str())\n            }\n            Type::Edge(Some(edge_type)) | Type::Edges(Some(edge_type)) => {\n                self.edge_fields.get(edge_type.as_str())\n            }\n            Type::Vector(Some(vector_type)) | Type::Vectors(Some(vector_type)) => {\n                self.vector_fields.get(vector_type.as_str())\n            }\n            _ => None,\n        }\n    }\n\n    // ---------- Pass #1: schema --------------------------\n    /// Validate that every edge references declared node types.\n    pub(super) fn check_schema(&mut self) -> Result<(), ParserError> {\n        check_schema(self)\n    }\n\n    // ---------- Pass #1.5: schema migrations --------------------------\n    pub(super) fn check_schema_migrations(&mut self) {\n        for m in &self.src.migrations {\n            validate_migration(self, m);\n        }\n    }\n\n    // ---------- Pass #2: queries -------------------------\n    pub(super) fn check_queries(&mut self) {\n        for q in &self.src.queries {\n            validate_query(self, q);\n        }\n    }\n}\n\n#[derive(Serialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IntrospectionData_166": {
      "name": "IntrospectionData",
      "type": "struct",
      "start_line": 166,
      "end_line": 170,
      "content_hash": "aeed5820c765c9bc1904e8180c45feb5c94adb2f",
      "content": "pub struct IntrospectionData {\n    schema: SchemaData,\n    queries: Vec<QueryData>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntrospectionData_171": {
      "name": "IntrospectionData",
      "type": "impl",
      "start_line": 171,
      "end_line": 171,
      "content_hash": "0ce24327ab883cf9a80749a59572f97286c4372d",
      "content": "impl IntrospectionData {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_schema_172": {
      "name": "from_schema",
      "type": "method",
      "start_line": 172,
      "end_line": 181,
      "content_hash": "b875dcfe1a3309eef7e45e34a23fcb103948d50a",
      "content": "    fn from_schema(ctx: &Ctx) -> Self {\n        let queries = ctx.src.queries.iter().map(QueryData::from_query).collect();\n        Self {\n            schema: SchemaData::from_ctx(ctx),\n            queries,\n        }\n    }\n}\n\n#[derive(Serialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SchemaData_182": {
      "name": "SchemaData",
      "type": "struct",
      "start_line": 182,
      "end_line": 187,
      "content_hash": "4513d8d9fb918b9eb02597fd178cb59689c64bb5",
      "content": "pub struct SchemaData {\n    nodes: Vec<NodeData>,\n    vectors: Vec<NodeData>,\n    edges: Vec<EdgeData>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_SchemaData_188": {
      "name": "SchemaData",
      "type": "impl",
      "start_line": 188,
      "end_line": 188,
      "content_hash": "6e996ee9d8bf7c1c121ca058d29137b222da6f51",
      "content": "impl SchemaData {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_ctx_189": {
      "name": "from_ctx",
      "type": "method",
      "start_line": 189,
      "end_line": 202,
      "content_hash": "0b8f3cb7d8477c2734d4b0651b118c68525d1b70",
      "content": "    fn from_ctx(ctx: &Ctx) -> Self {\n        let nodes = ctx.node_fields.iter().map(NodeData::from_entry).collect();\n        let vectors = ctx.vector_fields.iter().map(NodeData::from_entry).collect();\n        let edges = ctx.edge_map.iter().map(EdgeData::from_entry).collect();\n\n        SchemaData {\n            nodes,\n            vectors,\n            edges,\n        }\n    }\n}\n\n#[derive(Serialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NodeData_203": {
      "name": "NodeData",
      "type": "struct",
      "start_line": 203,
      "end_line": 207,
      "content_hash": "ebfbb0468138898c9dc9dec49dbefcce8d56736d",
      "content": "pub struct NodeData {\n    name: String,\n    properties: HashMap<String, String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_NodeData_208": {
      "name": "NodeData",
      "type": "impl",
      "start_line": 208,
      "end_line": 208,
      "content_hash": "c24305b655b74680824deeffd7611508fca21224",
      "content": "impl NodeData {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_entry_209": {
      "name": "from_entry",
      "type": "method",
      "start_line": 209,
      "end_line": 222,
      "content_hash": "5f4ae2caabaa7cbab91f7a062fd0c57bf6a3979f",
      "content": "    fn from_entry(val: (&&str, &HashMap<&str, Cow<Field>>)) -> Self {\n        let properties = val\n            .1\n            .iter()\n            .map(|(n, f)| (n.to_string(), f.field_type.to_string()))\n            .collect();\n        NodeData {\n            name: val.0.to_string(),\n            properties,\n        }\n    }\n}\n\n#[derive(Serialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EdgeData_223": {
      "name": "EdgeData",
      "type": "struct",
      "start_line": 223,
      "end_line": 229,
      "content_hash": "814b907f79d0088853b474325e3ac6dde28428d2",
      "content": "pub struct EdgeData {\n    name: String,\n    from: String,\n    to: String,\n    properties: HashMap<String, String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_EdgeData_230": {
      "name": "EdgeData",
      "type": "impl",
      "start_line": 230,
      "end_line": 230,
      "content_hash": "1825336fa3415ffde99fb3cd060668495c88d0d4",
      "content": "impl EdgeData {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_entry_231": {
      "name": "from_entry",
      "type": "method",
      "start_line": 231,
      "end_line": 248,
      "content_hash": "1094ee4ec3c14f1e7fdbfa69930634adf8620d7e",
      "content": "    fn from_entry((name, es): (&&str, &&EdgeSchema)) -> Self {\n        let properties = es\n            .properties\n            .iter()\n            .flatten()\n            .map(|f| (f.name.to_string(), f.field_type.to_string()))\n            .collect();\n\n        EdgeData {\n            name: name.to_string(),\n            from: es.from.1.clone(),\n            to: es.to.1.clone(),\n            properties,\n        }\n    }\n}\n\n#[derive(Serialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_QueryData_249": {
      "name": "QueryData",
      "type": "struct",
      "start_line": 249,
      "end_line": 254,
      "content_hash": "6b1db38e989c8a51278040c3b666ef4798403471",
      "content": "pub struct QueryData {\n    name: String,\n    parameters: HashMap<String, String>,\n    returns: Vec<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_QueryData_255": {
      "name": "QueryData",
      "type": "impl",
      "start_line": 255,
      "end_line": 255,
      "content_hash": "c75f22b7a2d866b59fc2c0875790697f4dbe5417",
      "content": "impl QueryData {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_query_256": {
      "name": "from_query",
      "type": "method",
      "start_line": 256,
      "end_line": 285,
      "content_hash": "a23337e4b7b9dea960571b9abe5a0736f3528de8",
      "content": "    fn from_query(query: &Query) -> Self {\n        let parameters = query\n            .parameters\n            .iter()\n            .map(|p| (p.name.1.clone(), p.param_type.1.to_string()))\n            .collect();\n\n        let returns = query\n            .return_values\n            .iter()\n            .flat_map(|e| {\n                if let ReturnType::Expression(expr) = e {\n                    if let ExpressionType::Identifier(ident) = &expr.expr {\n                        Some(ident.clone())\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            })\n            .collect();\n\n        QueryData {\n            name: query.name.to_string(),\n            parameters,\n            returns,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}