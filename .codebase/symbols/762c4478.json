{
  "file_path": "/work/context-engine/scripts/toon_encoder.py",
  "file_hash": "e49241671540a2430e6f339226ecb54bce97f65d",
  "updated_at": "2025-12-26T17:34:24.010886",
  "symbols": {
    "function_is_toon_enabled_26": {
      "name": "is_toon_enabled",
      "type": "function",
      "start_line": 26,
      "end_line": 28,
      "content_hash": "1031d0936cff1b107f0e7b6c673122bc2fc6f99d",
      "content": "def is_toon_enabled() -> bool:\n    \"\"\"Check if TOON encoding is enabled via environment variable.\"\"\"\n    return os.environ.get(\"TOON_ENABLED\", \"0\").lower() in (\"1\", \"true\", \"yes\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_35": {
      "name": "encode",
      "type": "function",
      "start_line": 35,
      "end_line": 51,
      "content_hash": "08a3f6ee79dc9e314cc0dba50ecd51b5297ed26c",
      "content": "def encode(\n    data: Any,\n    delimiter: str = \",\",\n    include_length: bool = True,\n) -> str:\n    \"\"\"Encode any JSON-compatible data to TOON format using official library.\n\n    Args:\n        data: JSON-compatible data (dict, list, or primitive)\n        delimiter: Field delimiter (default: \",\")\n        include_length: Ignored (python-toon always includes length markers)\n\n    Returns:\n        TOON-formatted string\n    \"\"\"\n    options = {\"delimiter\": delimiter}\n    return toon_encode(data, options)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_object_55": {
      "name": "encode_object",
      "type": "function",
      "start_line": 55,
      "end_line": 67,
      "content_hash": "d9f2bd73adc8db3c5cd81a57b21c44c1d397ee34",
      "content": "def encode_object(\n    obj: Dict[str, Any],\n    delimiter: str = \",\",\n    indent: int = 0,\n    include_length: bool = True,\n) -> List[str]:\n    \"\"\"Encode an object to TOON format (backwards compat wrapper).\"\"\"\n    result = encode(obj, delimiter=delimiter)\n    # Add indentation if needed\n    if indent > 0:\n        prefix = \"  \" * indent\n        return [prefix + line for line in result.split(\"\\n\")]\n    return result.split(\"\\n\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_tabular_70": {
      "name": "encode_tabular",
      "type": "function",
      "start_line": 70,
      "end_line": 82,
      "content_hash": "9b3d52cdcb526cc3017a6047d601ad5d717d3a95",
      "content": "def encode_tabular(\n    key: str,\n    arr: List[Dict[str, Any]],\n    delimiter: str = \",\",\n    indent: int = 0,\n    include_length: bool = True,\n) -> List[str]:\n    \"\"\"Encode array as tabular (backwards compat wrapper).\"\"\"\n    result = encode({key: arr}, delimiter=delimiter)\n    if indent > 0:\n        prefix = \"  \" * indent\n        return [prefix + line for line in result.split(\"\\n\")]\n    return result.split(\"\\n\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_simple_array_85": {
      "name": "encode_simple_array",
      "type": "function",
      "start_line": 85,
      "end_line": 97,
      "content_hash": "6c452bcee316101366e23efba8aab7194e198593",
      "content": "def encode_simple_array(\n    key: str,\n    arr: List[Any],\n    delimiter: str = \",\",\n    indent: int = 0,\n    include_length: bool = True,\n) -> List[str]:\n    \"\"\"Encode simple array (backwards compat wrapper).\"\"\"\n    result = encode({key: arr}, delimiter=delimiter)\n    if indent > 0:\n        prefix = \"  \" * indent\n        return [prefix + line for line in result.split(\"\\n\")]\n    return result.split(\"\\n\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__looks_numeric_101": {
      "name": "_looks_numeric",
      "type": "function",
      "start_line": 101,
      "end_line": 121,
      "content_hash": "654b9541c1544a0d0ecad11ccf676163bd733da7",
      "content": "def _looks_numeric(s: str) -> bool:\n    \"\"\"Check if string looks like a number (would be parsed as numeric by TOON).\"\"\"\n    if not s:\n        return False\n    # Leading zeros like \"05\" (but not \"0\" alone)\n    if len(s) > 1 and s[0] == '0' and s[1].isdigit():\n        return True\n    # Try parsing as int/float\n    try:\n        float(s)\n        return True\n    except ValueError:\n        pass\n    # Scientific notation variants\n    if 'e' in s.lower():\n        try:\n            float(s)\n            return True\n        except ValueError:\n            pass\n    return False",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__encode_value_124": {
      "name": "_encode_value",
      "type": "function",
      "start_line": 124,
      "end_line": 149,
      "content_hash": "28e3a927d4919e910d65448345eb6ceabd0c976b",
      "content": "def _encode_value(value: Any, delimiter: str) -> str:\n    \"\"\"Encode a single value (used by search result helpers).\"\"\"\n    if value is None:\n        return \"null\"\n    if isinstance(value, bool):\n        return \"true\" if value else \"false\"\n    if isinstance(value, (int, float)):\n        return str(value)\n    if isinstance(value, str):\n        # Check if quoting needed per TOON spec\n        needs_quote = (\n            not value or\n            value[0].isspace() or value[-1].isspace() or\n            value in (\"true\", \"false\", \"null\") or\n            value == \"-\" or value.startswith(\"-\") or\n            _looks_numeric(value) or\n            any(c in value for c in (':', '\"', '\\\\', '[', ']', '{', '}', '\\n', '\\r', '\\t')) or\n            delimiter in value\n        )\n        if needs_quote:\n            escaped = value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"').replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\t', '\\\\t')\n            return f'\"{escaped}\"'\n        return value\n    # Nested objects/arrays: compact JSON\n    import json\n    return json.dumps(value, separators=(\",\", \":\"))",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__is_uniform_array_of_objects_152": {
      "name": "_is_uniform_array_of_objects",
      "type": "function",
      "start_line": 152,
      "end_line": 159,
      "content_hash": "fa08501bc151d2b7a087747c0982f2b3705bc3c3",
      "content": "def _is_uniform_array_of_objects(arr: List[Any]) -> bool:\n    \"\"\"Check if array is uniform objects (same keys).\"\"\"\n    if not arr or len(arr) < 1:\n        return False\n    if not all(isinstance(item, dict) for item in arr):\n        return False\n    first_keys = set(arr[0].keys())\n    return all(set(item.keys()) == first_keys for item in arr)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__bracket_segment_162": {
      "name": "_bracket_segment",
      "type": "function",
      "start_line": 162,
      "end_line": 173,
      "content_hash": "e8d009ea933f4b72ccc16cdfca4b47a759889fc3",
      "content": "def _bracket_segment(length: int, delimiter: str, include_length: bool) -> str:\n    \"\"\"Build bracket segment for search results.\"\"\"\n    if not include_length:\n        return \"\"\n    # python-toon uses [N,] format for comma delimiter\n    if delimiter == \",\":\n        return f\"[{length}]\"\n    elif delimiter == \"\\t\":\n        return f\"[{length}\\t]\"\n    elif delimiter == \"|\":\n        return f\"[{length}|]\"\n    return f\"[{length}]\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_search_results_180": {
      "name": "encode_search_results",
      "type": "function",
      "start_line": 180,
      "end_line": 231,
      "content_hash": "58d764f778fbd21888c29ab99e5df881932e816b",
      "content": "def encode_search_results(\n    results: List[Dict[str, Any]],\n    delimiter: str = \",\",\n    include_length: bool = True,\n    compact: bool = True,\n) -> str:\n    \"\"\"Encode search results to TOON tabular format.\n\n    Dynamically includes all fields present in results to avoid dropping data.\n    Core fields are ordered first, then any additional fields alphabetically.\n\n    Args:\n        results: List of search result dicts\n        delimiter: Field delimiter (default: \",\")\n        include_length: Include [N] markers (default: True)\n        compact: If True, only include core location fields (path/lines)\n\n    Returns:\n        TOON-formatted search results\n    \"\"\"\n    bracket = _bracket_segment(len(results), delimiter, include_length)\n\n    if not results:\n        # Empty array per spec: key[0]: (nothing after colon)\n        return f\"results{bracket}:\"\n\n    # Determine fields based on compact mode\n    if compact:\n        fields = [\"path\", \"start_line\", \"end_line\"]\n    else:\n        # Collect all unique fields from all results\n        all_fields: set = set()\n        for r in results:\n            all_fields.update(r.keys())\n\n        # Core fields ordered first, then remaining alphabetically\n        core_order = [\"path\", \"start_line\", \"end_line\", \"score\", \"symbol\", \"kind\",\n                      \"snippet\", \"information\", \"relevance_score\", \"why\"]\n        fields = [f for f in core_order if f in all_fields]\n        # Add remaining fields not in core_order\n        extra_fields = sorted(all_fields - set(core_order))\n        fields.extend(extra_fields)\n\n    # Build tabular output with delimiter in fields segment too\n    fields_part = \"{\" + delimiter.join(fields) + \"}\"\n\n    lines = [f\"results{bracket}{fields_part}:\"]\n    for r in results:\n        values = [_encode_value(r.get(f), delimiter) for f in fields]\n        lines.append(f\"  {delimiter.join(values)}\")\n\n    return \"\\n\".join(lines)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_encode_context_results_234": {
      "name": "encode_context_results",
      "type": "function",
      "start_line": 234,
      "end_line": 313,
      "content_hash": "ec7f1c71ef02bb3597757482394ac183451f9350",
      "content": "def encode_context_results(\n    results: List[Dict[str, Any]],\n    delimiter: str = \",\",\n    include_length: bool = True,\n    compact: bool = True,\n) -> str:\n    \"\"\"Encode context_search results (code + memory) to TOON format.\n\n    Dynamically includes all fields present to avoid dropping data.\n    Handles mixed result types with source-aware encoding.\n\n    Args:\n        results: List of mixed search result dicts\n        delimiter: Field delimiter (default: \",\")\n        include_length: Include [N] markers (default: True)\n        compact: If True, use minimal core fields only\n\n    Returns:\n        TOON-formatted context results with source-aware encoding\n    \"\"\"\n    bracket = _bracket_segment(len(results), delimiter, include_length)\n\n    if not results:\n        # Empty per spec: key[0]:\n        return f\"results{bracket}:\"\n\n    # Separate code and memory results\n    code_results = [r for r in results if r.get(\"source\") != \"memory\"]\n    memory_results = [r for r in results if r.get(\"source\") == \"memory\"]\n\n    lines = []\n\n    # Encode code results\n    if code_results:\n        code_bracket = _bracket_segment(len(code_results), delimiter, include_length)\n        if compact:\n            code_fields = [\"path\", \"start_line\", \"end_line\"]\n        else:\n            # Collect all fields from code results\n            all_code_fields: set = set()\n            for r in code_results:\n                all_code_fields.update(r.keys())\n            # Core order, then extras\n            core_order = [\"path\", \"start_line\", \"end_line\", \"score\", \"symbol\", \"kind\",\n                          \"snippet\", \"information\", \"relevance_score\", \"why\"]\n            code_fields = [f for f in core_order if f in all_code_fields]\n            extra = sorted(all_code_fields - set(core_order) - {\"source\"})\n            code_fields.extend(extra)\n        code_fields_part = \"{\" + delimiter.join(code_fields) + \"}\"\n        lines.append(f\"code{code_bracket}{code_fields_part}:\")\n        for r in code_results:\n            values = [_encode_value(r.get(f), delimiter) for f in code_fields]\n            lines.append(f\"  {delimiter.join(values)}\")\n\n    # Encode memory results\n    if memory_results:\n        mem_bracket = _bracket_segment(len(memory_results), delimiter, include_length)\n        if compact:\n            mem_fields = [\"content\", \"score\"]\n        else:\n            # Collect all fields from memory results\n            all_mem_fields: set = set()\n            for r in memory_results:\n                all_mem_fields.update(r.keys())\n            core_order = [\"content\", \"score\", \"id\", \"information\"]\n            mem_fields = [f for f in core_order if f in all_mem_fields]\n            extra = sorted(all_mem_fields - set(core_order) - {\"source\"})\n            mem_fields.extend(extra)\n        mem_fields_part = \"{\" + delimiter.join(mem_fields) + \"}\"\n        lines.append(f\"memory{mem_bracket}{mem_fields_part}:\")\n        for r in memory_results:\n            values = [_encode_value(r.get(f), delimiter) for f in mem_fields]\n            lines.append(f\"  {delimiter.join(values)}\")\n\n    # If no separation needed (all same type or empty), use unified format\n    if not lines:\n        # Fallback: use generic encode\n        return encode_search_results(results, delimiter, include_length, compact)\n\n    return \"\\n\".join(lines)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_estimate_tokens_320": {
      "name": "estimate_tokens",
      "type": "function",
      "start_line": 320,
      "end_line": 322,
      "content_hash": "bd0a7fc929877b0d118de769469582b7ecbae59a",
      "content": "def estimate_tokens(text: str) -> int:\n    \"\"\"Rough token estimate (chars/4 heuristic, good enough for comparison).\"\"\"\n    return len(text) // 4",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_compare_formats_325": {
      "name": "compare_formats",
      "type": "function",
      "start_line": 325,
      "end_line": 357,
      "content_hash": "afeaa17aa9b5efbd02b7d53368d9aadbb1f2e64d",
      "content": "def compare_formats(data: Any) -> Dict[str, Any]:\n    \"\"\"Compare TOON vs JSON token counts for given data.\n\n    Returns:\n        {\n            \"json_tokens\": int,\n            \"json_compact_tokens\": int,\n            \"toon_tokens\": int,\n            \"toon_tab_tokens\": int,\n            \"savings_vs_json\": float,  # percentage\n            \"savings_vs_compact\": float,\n        }\n    \"\"\"\n    import json\n\n    json_pretty = json.dumps(data, indent=2)\n    json_compact = json.dumps(data, separators=(\",\", \":\"))\n    toon_comma = encode(data, delimiter=\",\")\n    toon_tab = encode(data, delimiter=\"\\t\")\n\n    json_tokens = estimate_tokens(json_pretty)\n    json_compact_tokens = estimate_tokens(json_compact)\n    toon_tokens = estimate_tokens(toon_comma)\n    toon_tab_tokens = estimate_tokens(toon_tab)\n\n    return {\n        \"json_tokens\": json_tokens,\n        \"json_compact_tokens\": json_compact_tokens,\n        \"toon_tokens\": toon_tokens,\n        \"toon_tab_tokens\": toon_tab_tokens,\n        \"savings_vs_json\": round((1 - toon_tokens / json_tokens) * 100, 1) if json_tokens else 0,\n        \"savings_vs_compact\": round((1 - toon_tokens / json_compact_tokens) * 100, 1) if json_compact_tokens else 0,\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}