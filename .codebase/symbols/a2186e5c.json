{
  "file_path": "/work/internal/cmd/logs_test.go",
  "file_hash": "cf41d69823ba8a97b72ae7bb49f265c92a039e16",
  "updated_at": "2025-12-26T17:34:23.073847",
  "symbols": {
    "function_TestLogsCmd_9": {
      "name": "TestLogsCmd",
      "type": "function",
      "start_line": 9,
      "end_line": 32,
      "content_hash": "90be88b760c3671e7f52e0d932e09479c2128299",
      "content": "func TestLogsCmd(t *testing.T) {\n\tt.Run(\"Command has correct metadata\", func(t *testing.T) {\n\t\tassert.Equal(t, \"logs\", logsCmd.Use)\n\t\tassert.Equal(t, \"View nexora logs\", logsCmd.Short)\n\t\tassert.Contains(t, logsCmd.Long, \"logs generated by Nexora\")\n\t})\n\n\tt.Run(\"Has follow flag\", func(t *testing.T) {\n\t\tflag := logsCmd.Flags().Lookup(\"follow\")\n\t\tassert.NotNil(t, flag)\n\t\tassert.Equal(t, \"f\", flag.Shorthand)\n\t\tassert.Equal(t, \"false\", flag.DefValue)\n\t\tassert.Equal(t, \"Follow log output\", flag.Usage)\n\t})\n\n\tt.Run(\"Has tail flag with default value\", func(t *testing.T) {\n\t\tflag := logsCmd.Flags().Lookup(\"tail\")\n\t\tassert.NotNil(t, flag)\n\t\tassert.Equal(t, \"t\", flag.Shorthand)\n\t\tassert.Equal(t, \"1000\", flag.DefValue)\n\t\tassert.Contains(t, flag.Usage, \"last N lines\")\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPrintLogLine_33": {
      "name": "TestPrintLogLine",
      "type": "function",
      "start_line": 33,
      "end_line": 75,
      "content_hash": "5565870cbd0c631ea038f53988df7243d380a0df",
      "content": "func TestPrintLogLine(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\tshouldErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"Valid JSON log\",\n\t\t\tinput:     `{\"msg\":\"test message\",\"level\":\"info\",\"time\":\"2024-01-01T00:00:00Z\"}`,\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid JSON\",\n\t\t\tinput:     `not json`,\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Empty string\",\n\t\t\tinput:     ``,\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Log with source\",\n\t\t\tinput:     `{\"msg\":\"test\",\"level\":\"debug\",\"time\":\"2024-01-01T00:00:00Z\",\"source\":{\"file\":\"test.go\",\"line\":42}}`,\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Log with extra fields\",\n\t\t\tinput:     `{\"msg\":\"test\",\"level\":\"error\",\"time\":\"2024-01-01T00:00:00Z\",\"error\":\"something went wrong\",\"user\":\"test\"}`,\n\t\t\tshouldErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// printLogLine doesn't return an error, it just handles invalid input gracefully\n\t\t\t// We're testing that it doesn't panic\n\t\t\tassert.NotPanics(t, func() {\n\t\t\t\tprintLogLine(tt.input)\n\t\t\t})\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}