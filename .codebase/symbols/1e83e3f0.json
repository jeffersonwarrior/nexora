{
  "file_path": "/work/internal/agent/tools/references.go",
  "file_hash": "1c015fecdf8b97f8c8760320cfa72c299fb131a6",
  "updated_at": "2025-12-26T17:34:21.316648",
  "symbols": {
    "struct_ReferencesParams_23": {
      "name": "ReferencesParams",
      "type": "struct",
      "start_line": 23,
      "end_line": 27,
      "content_hash": "795e8ea08689925acd587d0903c65cdb6737cb64",
      "content": "type ReferencesParams struct {\n\tSymbol string `json:\"symbol\" description:\"The symbol name to search for (e.g., function name, variable name, type name)\"`\n\tPath   string `json:\"path,omitempty\" description:\"The directory to search in. Use a directory/file to narrow down the symbol search. Defaults to the current working directory.\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_referencesTool_28": {
      "name": "referencesTool",
      "type": "struct",
      "start_line": 28,
      "end_line": 36,
      "content_hash": "b3930cd0df2d84a0b98ae45c58a13a8bc25f73d1",
      "content": "type referencesTool struct {\n\tlspClients *csync.Map[string, *lsp.Client]\n}\n\nconst ReferencesToolName = \"lsp_references\"\n\n//go:embed references.md\nvar referencesDescription []byte\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewReferencesTool_37": {
      "name": "NewReferencesTool",
      "type": "function",
      "start_line": 37,
      "end_line": 89,
      "content_hash": "e10a706bf99555561e69ff179c12c59c29089059",
      "content": "func NewReferencesTool(lspClients *csync.Map[string, *lsp.Client]) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tReferencesToolName,\n\t\tstring(referencesDescription),\n\t\tfunc(ctx context.Context, params ReferencesParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\tif params.Symbol == \"\" {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"symbol is required\"), nil\n\t\t\t}\n\n\t\t\tif lspClients.Len() == 0 {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"no LSP clients available\"), nil\n\t\t\t}\n\n\t\t\tworkingDir := cmp.Or(params.Path, \".\")\n\n\t\t\tmatches, _, err := searchFiles(ctx, regexp.QuoteMeta(params.Symbol), workingDir, \"\", 100)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"failed to search for symbol: %s\", err)), nil\n\t\t\t}\n\n\t\t\tif len(matches) == 0 {\n\t\t\t\treturn fantasy.NewTextResponse(fmt.Sprintf(\"Symbol '%s' not found\", params.Symbol)), nil\n\t\t\t}\n\n\t\t\tvar allLocations []protocol.Location\n\t\t\tvar allErrs error\n\t\t\tfor _, match := range matches {\n\t\t\t\tlocations, err := find(ctx, lspClients, params.Symbol, match)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif strings.Contains(err.Error(), \"no identifier found\") {\n\t\t\t\t\t\t// grep probably matched a comment, string value, or something else that's irrelevant\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tslog.Error(\"Failed to find references\", \"error\", err, \"symbol\", params.Symbol, \"path\", match.path, \"line\", match.lineNum, \"char\", match.charNum)\n\t\t\t\t\tallErrs = errors.Join(allErrs, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tallLocations = append(allLocations, locations...)\n\t\t\t\t// XXX: should we break here or look for all results?\n\t\t\t}\n\n\t\t\tif len(allLocations) > 0 {\n\t\t\t\toutput := formatReferences(cleanupLocations(allLocations))\n\t\t\t\treturn fantasy.NewTextResponse(output), nil\n\t\t\t}\n\n\t\t\tif allErrs != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(allErrs.Error()), nil\n\t\t\t}\n\t\t\treturn fantasy.NewTextResponse(fmt.Sprintf(\"No references found for symbol '%s'\", params.Symbol)), nil\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_90": {
      "name": "Name",
      "type": "method",
      "start_line": 90,
      "end_line": 93,
      "content_hash": "2bd6f4608e806070d3fbe1f6ebc5692b102c4bef",
      "content": "func (r *referencesTool) Name() string {\n\treturn ReferencesToolName\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_find_94": {
      "name": "find",
      "type": "function",
      "start_line": 94,
      "end_line": 123,
      "content_hash": "507bec6dd681782dfae3caa3bf158cfefbc26e4e",
      "content": "func find(ctx context.Context, lspClients *csync.Map[string, *lsp.Client], symbol string, match grepMatch) ([]protocol.Location, error) {\n\tabsPath, err := filepath.Abs(match.path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get absolute path: %s\", err)\n\t}\n\n\tvar client *lsp.Client\n\tfor c := range lspClients.Seq() {\n\t\tif c.HandlesFile(absPath) {\n\t\t\tclient = c\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif client == nil {\n\t\tslog.Warn(\"No LSP clients to handle\", \"path\", match.path)\n\t\treturn nil, nil\n\t}\n\n\treturn client.FindReferences(\n\t\tctx,\n\t\tabsPath,\n\t\tmatch.lineNum,\n\t\tmatch.charNum+getSymbolOffset(symbol),\n\t\ttrue,\n\t)\n}\n\n// getSymbolOffset returns the character offset to the actual symbol name\n// in a qualified symbol (e.g., \"Bar\" in \"foo.Bar\" or \"method\" in \"Class::method\").",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getSymbolOffset_124": {
      "name": "getSymbolOffset",
      "type": "function",
      "start_line": 124,
      "end_line": 139,
      "content_hash": "f17bfc108e025d83388c8540467a94cfbd065366",
      "content": "func getSymbolOffset(symbol string) int {\n\t// Check for :: separator (Rust, C++, Ruby modules/classes, PHP static).\n\tif idx := strings.LastIndex(symbol, \"::\"); idx != -1 {\n\t\treturn idx + 2\n\t}\n\t// Check for . separator (Go, Python, JavaScript, Java, C#, Ruby methods).\n\tif idx := strings.LastIndex(symbol, \".\"); idx != -1 {\n\t\treturn idx + 1\n\t}\n\t// Check for \\ separator (PHP namespaces).\n\tif idx := strings.LastIndex(symbol, \"\\\\\"); idx != -1 {\n\t\treturn idx + 1\n\t}\n\treturn 0\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_cleanupLocations_140": {
      "name": "cleanupLocations",
      "type": "function",
      "start_line": 140,
      "end_line": 156,
      "content_hash": "9aabbaec61c17b692ec8a43c77cad09e7c68f5b8",
      "content": "func cleanupLocations(locations []protocol.Location) []protocol.Location {\n\tslices.SortFunc(locations, func(a, b protocol.Location) int {\n\t\tif a.URI != b.URI {\n\t\t\treturn strings.Compare(string(a.URI), string(b.URI))\n\t\t}\n\t\tif a.Range.Start.Line != b.Range.Start.Line {\n\t\t\treturn cmp.Compare(a.Range.Start.Line, b.Range.Start.Line)\n\t\t}\n\t\treturn cmp.Compare(a.Range.Start.Character, b.Range.Start.Character)\n\t})\n\treturn slices.CompactFunc(locations, func(a, b protocol.Location) bool {\n\t\treturn a.URI == b.URI &&\n\t\t\ta.Range.Start.Line == b.Range.Start.Line &&\n\t\t\ta.Range.Start.Character == b.Range.Start.Character\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_groupByFilename_157": {
      "name": "groupByFilename",
      "type": "function",
      "start_line": 157,
      "end_line": 169,
      "content_hash": "632c89055c296ffcc9d4c728024fa066552356d7",
      "content": "func groupByFilename(locations []protocol.Location) map[string][]protocol.Location {\n\tfiles := make(map[string][]protocol.Location)\n\tfor _, loc := range locations {\n\t\tpath, err := loc.URI.Path()\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to convert location URI to path\", \"uri\", loc.URI, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfiles[path] = append(files[path], loc)\n\t}\n\treturn files\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatReferences_170": {
      "name": "formatReferences",
      "type": "function",
      "start_line": 170,
      "end_line": 190,
      "content_hash": "ffcbd99eda49ed9f0e384f5d53e5c5ab2d6548a5",
      "content": "func formatReferences(locations []protocol.Location) string {\n\tfileRefs := groupByFilename(locations)\n\tfiles := slices.Collect(maps.Keys(fileRefs))\n\tsort.Strings(files)\n\n\tvar output strings.Builder\n\toutput.WriteString(fmt.Sprintf(\"Found %d reference(s) in %d file(s):\\n\\n\", len(locations), len(files)))\n\n\tfor _, file := range files {\n\t\trefs := fileRefs[file]\n\t\toutput.WriteString(fmt.Sprintf(\"%s (%d reference(s)):\\n\", file, len(refs)))\n\t\tfor _, ref := range refs {\n\t\t\tline := ref.Range.Start.Line + 1\n\t\t\tchar := ref.Range.Start.Character + 1\n\t\t\toutput.WriteString(fmt.Sprintf(\"  Line %d, Column %d\\n\", line, char))\n\t\t}\n\t\toutput.WriteString(\"\\n\")\n\t}\n\n\treturn output.String()\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}