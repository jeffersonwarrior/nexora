{
  "file_path": "/work/.local/tools/modelscan/sdk/cli/cli.go",
  "file_hash": "35b0993b78fcd397b3c8ee0e0a4ffa8cabb93697",
  "updated_at": "2025-12-26T17:34:23.606975",
  "symbols": {
    "struct_CLI_12": {
      "name": "CLI",
      "type": "struct",
      "start_line": 12,
      "end_line": 19,
      "content_hash": "f708efccead1ec891f3e6ab8a12e56267ad63d2a",
      "content": "type CLI struct {\n\trootCmd      *cobra.Command\n\torchestrator *Orchestrator\n\tcommands     map[string]Command\n\tinitialized  bool\n}\n\n// NewCLI creates a new CLI instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCLI_20": {
      "name": "NewCLI",
      "type": "function",
      "start_line": 20,
      "end_line": 45,
      "content_hash": "ae8f7f4b7b5f833338ec95983500258a27f132cd",
      "content": "func NewCLI() *CLI {\n\tcli := &CLI{\n\t\tcommands: make(map[string]Command),\n\t}\n\n\t// Create root command\n\tcli.rootCmd = &cobra.Command{\n\t\tUse:   \"modelscan\",\n\t\tShort: \"ModelScan - Multi-Agent LLM Framework\",\n\t\tLong: `ModelScan CLI is a powerful multi-agent orchestration system for LLM applications.\nIt manages agents, teams, tasks, and provides coordination capabilities.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn cli.runOrchestrator(args)\n\t\t},\n\t}\n\n\t// Register built-in commands\n\tcli.registerBuiltinCommands()\n\n\t// Set up command line flags\n\tcli.setupFlags()\n\n\treturn cli\n}\n\n// registerBuiltinCommands registers all built-in commands",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_registerBuiltinCommands_46": {
      "name": "registerBuiltinCommands",
      "type": "method",
      "start_line": 46,
      "end_line": 68,
      "content_hash": "edd82745de47b82e29db2b814c71e765e1f26e20",
      "content": "func (cli *CLI) registerBuiltinCommands() {\n\t// Create command instances\n\tcommands := []Command{\n\t\t&ListAgentsCommand{},\n\t\t&CreateAgentCommand{},\n\t\t&ListTeamsCommand{},\n\t\t&CreateTeamCommand{},\n\t\t&AddToTeamCommand{},\n\t\t&ListTasksCommand{},\n\t\t&StatusCommand{},\n\t\t&CleanupCommand{},\n\t}\n\n\t// Register commands\n\tfor _, cmd := range commands {\n\t\tcli.registerCommand(cmd)\n\t}\n\n\t// Register help command\n\tcli.registerCommand(NewHelpCommand(cli.commands))\n}\n\n// registerCommand registers a command with the CLI",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_registerCommand_69": {
      "name": "registerCommand",
      "type": "method",
      "start_line": 69,
      "end_line": 93,
      "content_hash": "350a6a0bbcdfe68933fa493b220032336bf03bf9",
      "content": "func (cli *CLI) registerCommand(cmd Command) {\n\t// Store command\n\tcli.commands[cmd.Name()] = cmd\n\n\t// Create cobra command\n\tcobraCmd := &cobra.Command{\n\t\tUse:   cmd.Name(),\n\t\tShort: cmd.Description(),\n\t\tArgs:  cobra.ArbitraryArgs,\n\t\tRunE: func(cobraCmd *cobra.Command, args []string) error {\n\t\t\tif !cli.initialized {\n\t\t\t\tif err := cli.initializeOrchestrator(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cmd.Execute(context.Background(), cli.orchestrator, args)\n\t\t},\n\t}\n\n\t// Add to root command\n\tcli.rootCmd.AddCommand(cobraCmd)\n}\n\n// setupFlags sets up command line flags",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupFlags_94": {
      "name": "setupFlags",
      "type": "method",
      "start_line": 94,
      "end_line": 101,
      "content_hash": "1ad4c00a86bed5fd5bef5ff323accc8a49df87de",
      "content": "func (cli *CLI) setupFlags() {\n\tcli.rootCmd.PersistentFlags().String(\"database\", \"\", \"Database file path\")\n\tcli.rootCmd.PersistentFlags().String(\"log-level\", \"info\", \"Log level (debug, info, warn, error)\")\n\tcli.rootCmd.PersistentFlags().Duration(\"retention\", 0, \"Data retention period\")\n\tcli.rootCmd.PersistentFlags().Int(\"max-concurrency\", 10, \"Maximum concurrent operations\")\n}\n\n// initializeOrchestrator initializes the orchestrator",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initializeOrchestrator_102": {
      "name": "initializeOrchestrator",
      "type": "method",
      "start_line": 102,
      "end_line": 127,
      "content_hash": "1122fbde4904f0f924098685f5fb1d777645a8b8",
      "content": "func (cli *CLI) initializeOrchestrator() error {\n\tif cli.initialized {\n\t\treturn nil\n\t}\n\n\t// Load configuration\n\tconfig := cli.loadConfig()\n\n\t// Create orchestrator\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create orchestrator: %w\", err)\n\t}\n\n\t// Start orchestrator\n\tif err := orchestrator.Start(); err != nil {\n\t\treturn fmt.Errorf(\"failed to start orchestrator: %w\", err)\n\t}\n\n\tcli.orchestrator = orchestrator\n\tcli.initialized = true\n\n\treturn nil\n}\n\n// loadConfig loads configuration from flags and defaults",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_loadConfig_128": {
      "name": "loadConfig",
      "type": "method",
      "start_line": 128,
      "end_line": 151,
      "content_hash": "65683e06ef639f2b6cd2af20b62044fd5839943f",
      "content": "func (cli *CLI) loadConfig() *Config {\n\tconfig := DefaultConfig()\n\n\t// Override with flags\n\tif dbPath, err := cli.rootCmd.PersistentFlags().GetString(\"database\"); err == nil && dbPath != \"\" {\n\t\tconfig.DatabasePath = dbPath\n\t}\n\n\tif logLevel, err := cli.rootCmd.PersistentFlags().GetString(\"log-level\"); err == nil && logLevel != \"\" {\n\t\tconfig.LogLevel = logLevel\n\t}\n\n\tif retention, err := cli.rootCmd.PersistentFlags().GetDuration(\"retention\"); err == nil && retention > 0 {\n\t\tconfig.DataRetention = retention\n\t}\n\n\tif maxConcurrency, err := cli.rootCmd.PersistentFlags().GetInt(\"max-concurrency\"); err == nil && maxConcurrency > 0 {\n\t\tconfig.MaxConcurrency = maxConcurrency\n\t}\n\n\treturn config\n}\n\n// runOrchestrator runs the orchestrator in standalone mode",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_runOrchestrator_152": {
      "name": "runOrchestrator",
      "type": "method",
      "start_line": 152,
      "end_line": 169,
      "content_hash": "6ddbc986f0ddf8608ecd8c8880017f58214c2dbf",
      "content": "func (cli *CLI) runOrchestrator(args []string) error {\n\tif !cli.initialized {\n\t\tif err := cli.initializeOrchestrator(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(args) == 0 {\n\t\t// Show status if no subcommand provided\n\t\treturn cli.commands[\"status\"].Execute(context.Background(), cli.orchestrator, []string{})\n\t}\n\n\t// Try to execute as command line\n\tinput := strings.Join(args, \" \")\n\treturn cli.executeCommandLine(input)\n}\n\n// executeCommandLine executes a command line string",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_executeCommandLine_170": {
      "name": "executeCommandLine",
      "type": "method",
      "start_line": 170,
      "end_line": 194,
      "content_hash": "40bed2bce8ad81a63a00fbc064cd882308913431",
      "content": "func (cli *CLI) executeCommandLine(input string) error {\n\tif !cli.initialized {\n\t\treturn fmt.Errorf(\"orchestrator not initialized\")\n\t}\n\n\t// Parse input\n\tparts := strings.Fields(strings.TrimSpace(input))\n\tif len(parts) == 0 {\n\t\treturn fmt.Errorf(\"empty command\")\n\t}\n\n\tcmdName := parts[0]\n\targs := parts[1:]\n\n\t// Find command\n\tcmd, exists := cli.commands[cmdName]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unknown command: %s\", cmdName)\n\t}\n\n\t// Execute command\n\treturn cmd.Execute(context.Background(), cli.orchestrator, args)\n}\n\n// Execute executes the CLI",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Execute_195": {
      "name": "Execute",
      "type": "method",
      "start_line": 195,
      "end_line": 199,
      "content_hash": "d601e32165dad7987cf4db94a638bcbb59180817",
      "content": "func (cli *CLI) Execute() error {\n\treturn cli.rootCmd.Execute()\n}\n\n// Shutdown shuts down the CLI",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Shutdown_200": {
      "name": "Shutdown",
      "type": "method",
      "start_line": 200,
      "end_line": 207,
      "content_hash": "dbb0505d533379dab061d035a416d0ababe64fcf",
      "content": "func (cli *CLI) Shutdown() error {\n\tif cli.orchestrator != nil {\n\t\treturn cli.orchestrator.Stop()\n\t}\n\treturn nil\n}\n\n// IsInitialized returns true if the orchestrator is initialized",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsInitialized_208": {
      "name": "IsInitialized",
      "type": "method",
      "start_line": 208,
      "end_line": 212,
      "content_hash": "0dcce87e95d0ff56c8f9eb65ed03d5a35a890edb",
      "content": "func (cli *CLI) IsInitialized() bool {\n\treturn cli.initialized\n}\n\n// GetOrchestrator returns the orchestrator instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetOrchestrator_213": {
      "name": "GetOrchestrator",
      "type": "method",
      "start_line": 213,
      "end_line": 217,
      "content_hash": "303697a5714d31e0edaca69b202e9da862221425",
      "content": "func (cli *CLI) GetOrchestrator() *Orchestrator {\n\treturn cli.orchestrator\n}\n\n// AddCommand adds a new command to the CLI",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_AddCommand_218": {
      "name": "AddCommand",
      "type": "method",
      "start_line": 218,
      "end_line": 222,
      "content_hash": "6fc27534e2eee03ecdffd6d30067f77dc202cc0e",
      "content": "func (cli *CLI) AddCommand(cmd Command) {\n\tcli.registerCommand(cmd)\n}\n\n// GetCommands returns all registered commands",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetCommands_223": {
      "name": "GetCommands",
      "type": "method",
      "start_line": 223,
      "end_line": 229,
      "content_hash": "1a7e7f2fae948b2bc918345d5731f28f73ac500e",
      "content": "func (cli *CLI) GetCommands() map[string]Command {\n\tresult := make(map[string]Command)\n\tfor k, v := range cli.commands {\n\t\tresult[k] = v\n\t}\n\treturn result\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}