{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/builtin/all_nodes_and_edges.rs",
  "file_hash": "a6e4e7327cbfd4863726644e6a527cf1965678df",
  "updated_at": "2025-12-26T17:34:22.349520",
  "symbols": {
    "struct_NodesEdgesQuery_32": {
      "name": "NodesEdgesQuery",
      "type": "struct",
      "start_line": 32,
      "end_line": 67,
      "content_hash": "4863a7350f3f10bc41320b161369b3d9a57f4d28",
      "content": "pub struct NodesEdgesQuery {\n    limit: Option<usize>,\n    node_label: Option<String>,\n}\n\npub async fn nodes_edges_handler(\n    State(state): State<Arc<AppState>>,\n    Query(params): Query<NodesEdgesQuery>,\n) -> axum::http::Response<Body> {\n    let mut req = protocol::request::Request {\n        name: \"nodes_edges\".to_string(),\n        req_type: RequestType::Query,\n        api_key: None,\n        body: axum::body::Bytes::new(),\n        in_fmt: protocol::Format::default(),\n        out_fmt: protocol::Format::default(),\n    };\n\n    if let Ok(params_json) = sonic_rs::to_vec(&json!({\n        \"limit\": params.limit,\n        \"node_label\": params.node_label\n    })) {\n        req.body = axum::body::Bytes::from(params_json);\n    }\n\n    let res = state.worker_pool.process(req).await;\n\n    match res {\n        Ok(r) => r.into_response(),\n        Err(e) => {\n            info!(?e, \"Got error\");\n            e.into_response()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_nodes_edges_inner_68": {
      "name": "nodes_edges_inner",
      "type": "function",
      "start_line": 68,
      "end_line": 127,
      "content_hash": "2c82d3729431fac216a9b755db4a35f33d5248b3",
      "content": "pub fn nodes_edges_inner(input: HandlerInput) -> Result<protocol::Response, GraphError> {\n    let db = Arc::clone(&input.graph.storage);\n    let txn = db.graph_env.read_txn().map_err(GraphError::from)?;\n    let arena = bumpalo::Bump::new();\n\n    let (limit, node_label) = if !input.request.body.is_empty() {\n        match sonic_rs::from_slice::<sonic_rs::Value>(&input.request.body) {\n            Ok(params) => (\n                params\n                    .get(\"limit\")\n                    .and_then(|v| v.as_u64())\n                    .map(|v| v as usize),\n                params\n                    .get(\"node_label\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| s.to_string()),\n            ),\n            Err(_) => (None, None),\n        }\n    } else {\n        (None, None)\n    };\n\n    let json_result = if limit.is_some() {\n        db.nodes_edges_to_json(&txn, limit, node_label)?\n    } else {\n        get_all_nodes_edges_json(&db, &txn, node_label, &arena)?\n    };\n\n    let db_stats = db.get_db_stats_json(&txn)?;\n\n    let vectors_result = db\n        .vectors\n        .get_all_vectors(&txn, None, &arena)\n        .map(|vecs| {\n            let vectors_json: Vec<sonic_rs::Value> = vecs\n                .iter()\n                .map(|v| {\n                    json!({\n                        \"id\": v.id.to_string(),\n                        \"level\": v.level,\n                        \"distance\": v.distance,\n                        \"data\": v.data,\n                        \"dimension\": v.data.len()\n                    })\n                })\n                .collect();\n            sonic_rs::to_string(&vectors_json).unwrap_or_else(|_| \"[]\".to_string())\n        })\n        .unwrap_or_else(|_| \"[]\".to_string());\n\n    let combined =\n        format!(r#\"{{\"data\": {json_result}, \"vectors\": {vectors_result}, \"stats\": {db_stats}}}\"#);\n\n    Ok(protocol::Response {\n        body: combined.into_bytes(),\n        fmt: Default::default(),\n    })\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_all_nodes_edges_json_128": {
      "name": "get_all_nodes_edges_json",
      "type": "function",
      "start_line": 128,
      "end_line": 212,
      "content_hash": "a8ea9f04af9b311e2a59ab5eec307e22f1bcad15",
      "content": "fn get_all_nodes_edges_json(\n    db: &Arc<crate::helix_engine::storage_core::HelixGraphStorage>,\n    txn: &RoTxn,\n    node_label: Option<String>,\n    arena: &bumpalo::Bump,\n) -> Result<String, GraphError> {\n    use sonic_rs::json;\n\n    let nodes_length = db.nodes_db.len(txn)?;\n    let mut nodes = Vec::with_capacity(nodes_length as usize);\n    let node_iter = db.nodes_db.iter(txn)?;\n    for result in node_iter {\n        let (id, value) = result?;\n        let id_str = ID::from(id).stringify();\n\n        let mut json_node = json!({\n            \"id\": id_str.clone(),\n            \"title\": id_str.clone()\n        });\n\n        if let Some(prop) = &node_label {\n            let node = Node::from_bincode_bytes(id, value, arena)?;\n            json_node[\"label\"] = json!(node.label);\n            if let Some(props) = node.properties\n                && let Some(prop_value) = props.get(prop)\n            {\n                json_node[\"label\"] = sonic_rs::to_value(&prop_value.inner_stringify())\n                    .unwrap_or_else(|_| sonic_rs::Value::from(\"\"));\n            }\n        }\n        nodes.push(json_node);\n    }\n\n    let edges_length = db.edges_db.len(txn)?;\n    let mut edges = Vec::with_capacity(edges_length as usize);\n    let edge_iter = db.edges_db.iter(txn)?;\n    for result in edge_iter {\n        let (id, value) = result?;\n        let edge = Edge::from_bincode_bytes(id, value, arena)?;\n        let id_str = ID::from(id).stringify();\n\n        edges.push(json!({\n            \"from\": ID::from(edge.from_node).stringify(),\n            \"to\": ID::from(edge.to_node).stringify(),\n            \"title\": id_str.clone(),\n            \"id\": id_str\n        }));\n    }\n\n    let result = json!({\n        \"nodes\": nodes,\n        \"edges\": edges\n    });\n\n    sonic_rs::to_string(&result).map_err(|e| GraphError::New(e.to_string()))\n}\n\ninventory::submit! {\n    HandlerSubmission(\n        Handler::new(\"nodes_edges\", nodes_edges_inner, false)\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        helix_engine::{\n            storage_core::version_info::VersionInfo,\n            traversal_core::{\n                HelixGraphEngine, HelixGraphEngineOpts,\n                config::Config,\n                ops::{\n                    g::G,\n                    source::{add_e::AddEAdapter, add_n::AddNAdapter},\n                },\n            },\n        },\n        helixc::generator::traversal_steps::EdgeType,\n        protocol::{Format, request::Request, request::RequestType},\n    };\n    use axum::body::Bytes;\n    use std::sync::Arc;\n    use tempfile::TempDir;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_test_engine_213": {
      "name": "setup_test_engine",
      "type": "function",
      "start_line": 213,
      "end_line": 225,
      "content_hash": "bc59db59deca98ae1700862874b6d2114ed21047",
      "content": "    fn setup_test_engine() -> (HelixGraphEngine, TempDir) {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().to_str().unwrap();\n        let opts = HelixGraphEngineOpts {\n            path: db_path.to_string(),\n            config: Config::default(),\n            version_info: VersionInfo::default(),\n        };\n        let engine = HelixGraphEngine::new(opts).unwrap();\n        (engine, temp_dir)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_edges_empty_database_226": {
      "name": "test_nodes_edges_empty_database",
      "type": "function",
      "start_line": 226,
      "end_line": 254,
      "content_hash": "89a3374d4af0b5235170390c3f555d95fdbd8a79",
      "content": "    fn test_nodes_edges_empty_database() {\n        let (engine, _temp_dir) = setup_test_engine();\n        let request = Request {\n            name: \"nodes_edges\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::new(),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_edges_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        assert!(!response.body.is_empty());\n\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"data\\\"\"));\n        assert!(body_str.contains(\"\\\"vectors\\\"\"));\n        assert!(body_str.contains(\"\\\"stats\\\"\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_edges_with_data_255": {
      "name": "test_nodes_edges_with_data",
      "type": "function",
      "start_line": 255,
      "end_line": 325,
      "content_hash": "ae4a49b8adc5856cc902849ad8683905e8a1d896",
      "content": "    fn test_nodes_edges_with_data() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::protocol::value::Value;\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let props1 = vec![(\"name\", Value::String(\"Alice\".to_string()))];\n        let props_map1 = ImmutablePropertiesMap::new(\n            props1.len(),\n            props1\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let node1 = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map1), None)\n            .collect_to_obj()?;\n\n        let props2 = vec![(\"name\", Value::String(\"Bob\".to_string()))];\n        let props_map2 = ImmutablePropertiesMap::new(\n            props2.len(),\n            props2\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let node2 = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map2), None)\n            .collect_to_obj()?;\n\n        let _edge = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_edge(\n                arena.alloc_str(\"knows\"),\n                None,\n                node1.id(),\n                node2.id(),\n                false,\n            )\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let request = Request {\n            name: \"nodes_edges\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::new(),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_edges_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"nodes\\\"\"));\n        assert!(body_str.contains(\"\\\"edges\\\"\"));\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_edges_with_limit_326": {
      "name": "test_nodes_edges_with_limit",
      "type": "function",
      "start_line": 326,
      "end_line": 389,
      "content_hash": "09df1ef34adb2e4ab77dda4d0b8e0926c1a998b5",
      "content": "    fn test_nodes_edges_with_limit() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::protocol::value::Value;\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let mut nodes = Vec::new();\n        for i in 0..10 {\n            let props = vec![(\"index\", Value::I64(i))];\n            let props_map = ImmutablePropertiesMap::new(\n                props.len(),\n                props\n                    .iter()\n                    .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n                &arena,\n            );\n\n            let node = G::new_mut(&engine.storage, &arena, &mut txn)\n                .add_n(arena.alloc_str(\"person\"), Some(props_map), None)\n                .collect_to_obj()?;\n            nodes.push(node);\n        }\n\n        // Add some edges to satisfy the nodes_edges_to_json method\n        for i in 0..5 {\n            let _edge = G::new_mut(&engine.storage, &arena, &mut txn)\n                .add_edge(\n                    arena.alloc_str(\"connects\"),\n                    None,\n                    nodes[i].id(),\n                    nodes[i + 1].id(),\n                    false,\n                )\n                .collect_to_obj()?;\n        }\n\n        txn.commit().unwrap();\n\n        let params_json = sonic_rs::to_vec(&json!({\"limit\": 5})).unwrap();\n        let request = Request {\n            name: \"nodes_edges\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_edges_inner(input);\n        if let Err(e) = &result {\n            eprintln!(\"Error in test_nodes_edges_with_limit: {:?}\", e);\n        }\n        assert!(result.is_ok());\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_edges_with_node_label_390": {
      "name": "test_nodes_edges_with_node_label",
      "type": "function",
      "start_line": 390,
      "end_line": 433,
      "content_hash": "7d963232dc5a580fc4644d495bfb15ea7f67d7eb",
      "content": "    fn test_nodes_edges_with_node_label() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::protocol::value::Value;\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let props = vec![(\"name\", Value::String(\"Test\".to_string()))];\n        let props_map = ImmutablePropertiesMap::new(\n            props.len(),\n            props\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let _node = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map), None)\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let params_json = sonic_rs::to_vec(&json!({\"node_label\": \"name\"})).unwrap();\n        let request = Request {\n            name: \"nodes_edges\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_edges_inner(input);\n        assert!(result.is_ok());\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_edges_stats_included_434": {
      "name": "test_nodes_edges_stats_included",
      "type": "function",
      "start_line": 434,
      "end_line": 457,
      "content_hash": "d3873090bdb2b6097f5c33594e196dee76b0ff83",
      "content": "    fn test_nodes_edges_stats_included() {\n        let (engine, _temp_dir) = setup_test_engine();\n        let request = Request {\n            name: \"nodes_edges\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::new(),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_edges_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"stats\\\"\"));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}