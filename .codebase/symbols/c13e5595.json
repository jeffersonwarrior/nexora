{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/vector_core.rs",
  "file_hash": "7355d0dc5f4800ebdd27289aa31855710a8a8349",
  "updated_at": "2025-12-26T17:34:20.167291",
  "symbols": {
    "struct_HNSWConfig_31": {
      "name": "HNSWConfig",
      "type": "struct",
      "start_line": 31,
      "end_line": 39,
      "content_hash": "cd3b1593126bad79fc1bc96eb9ddeb3f0496877d",
      "content": "pub struct HNSWConfig {\n    pub m: usize,             // max num of bi-directional links per element\n    pub m_max_0: usize,       // max num of links for lower layers\n    pub ef_construct: usize,  // size of the dynamic candidate list for construction\n    pub m_l: f64,             // level generation factor\n    pub ef: usize,            // search param, num of cands to search\n    pub min_neighbors: usize, // for get_neighbors, always 512\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HNSWConfig_40": {
      "name": "HNSWConfig",
      "type": "impl",
      "start_line": 40,
      "end_line": 47,
      "content_hash": "0a5ebeaf6978c5d5fafae9f0fe858488b8cca742",
      "content": "impl HNSWConfig {\n    /// Constructor for the configs of the HNSW vector similarity search algorithm\n    /// - m (5 <= m <= 48): max num of bi-directional links per element\n    /// - m_max_0 (2 * m): max num of links for level 0 (level that stores all vecs)\n    /// - ef_construct (40 <= ef_construct <= 512): size of the dynamic candidate list\n    ///   for construction\n    /// - m_l (ln(1/m)): level generation factor (multiplied by a random number)\n    /// - ef (10 <= ef <= 512): num of candidates to search",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_48": {
      "name": "new",
      "type": "method",
      "start_line": 48,
      "end_line": 63,
      "content_hash": "a1b0a266b7cbf3d640acf19c729205a5bc9cfece",
      "content": "    pub fn new(m: Option<usize>, ef_construct: Option<usize>, ef: Option<usize>) -> Self {\n        let m = m.unwrap_or(16).clamp(5, 48);\n        let ef_construct = ef_construct.unwrap_or(128).clamp(40, 512);\n        let ef = ef.unwrap_or(768).clamp(10, 512);\n\n        Self {\n            m,\n            m_max_0: 2 * m,\n            ef_construct,\n            m_l: 1.0 / (m as f64).ln(),\n            ef,\n            min_neighbors: 512,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_VectorCore_64": {
      "name": "VectorCore",
      "type": "struct",
      "start_line": 64,
      "end_line": 70,
      "content_hash": "f70ac2239e226ee40dacd26e7baf716a8fa5d9c9",
      "content": "pub struct VectorCore {\n    pub vectors_db: Database<Bytes, Bytes>,\n    pub vector_properties_db: Database<U128<BE>, Bytes>,\n    pub edges_db: Database<Bytes, Unit>,\n    pub config: HNSWConfig,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_VectorCore_71": {
      "name": "VectorCore",
      "type": "impl",
      "start_line": 71,
      "end_line": 71,
      "content_hash": "3040072e54193be6eb761c3bc334b1a9d849c204",
      "content": "impl VectorCore {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_72": {
      "name": "new",
      "type": "method",
      "start_line": 72,
      "end_line": 90,
      "content_hash": "b3a40549ac38cd421d01c0bced679b44ef36b9a6",
      "content": "    pub fn new(env: &Env, txn: &mut RwTxn, config: HNSWConfig) -> Result<Self, VectorError> {\n        let vectors_db = env.create_database(txn, Some(DB_VECTORS))?;\n        let vector_properties_db = env\n            .database_options()\n            .types::<U128<BE>, Bytes>()\n            .name(DB_VECTOR_DATA)\n            .create(txn)?;\n        let edges_db = env.create_database(txn, Some(DB_HNSW_EDGES))?;\n\n        Ok(Self {\n            vectors_db,\n            vector_properties_db,\n            edges_db,\n            config,\n        })\n    }\n\n    /// Vector key: [v, id, ]\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_vector_key_91": {
      "name": "vector_key",
      "type": "method",
      "start_line": 91,
      "end_line": 95,
      "content_hash": "6fbb1dc03f35f5d13aea9abd63e9f0b54e30adc9",
      "content": "    pub fn vector_key(id: u128, level: usize) -> Vec<u8> {\n        [VECTOR_PREFIX, &id.to_be_bytes(), &level.to_be_bytes()].concat()\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_edges_key_96": {
      "name": "out_edges_key",
      "type": "method",
      "start_line": 96,
      "end_line": 114,
      "content_hash": "300696cb8ec7594af18d5f7c91da8f7626985904",
      "content": "    pub fn out_edges_key(source_id: u128, level: usize, sink_id: Option<u128>) -> Vec<u8> {\n        match sink_id {\n            Some(sink_id) => [\n                source_id.to_be_bytes().as_slice(),\n                level.to_be_bytes().as_slice(),\n                sink_id.to_be_bytes().as_slice(),\n            ]\n            .concat()\n            .to_vec(),\n            None => [\n                source_id.to_be_bytes().as_slice(),\n                level.to_be_bytes().as_slice(),\n            ]\n            .concat()\n            .to_vec(),\n        }\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_new_level_115": {
      "name": "get_new_level",
      "type": "method",
      "start_line": 115,
      "end_line": 143,
      "content_hash": "e9ff03677d20322796307408f6f9c42431ef6716",
      "content": "    fn get_new_level(&self) -> usize {\n        let mut rng = rand::rng();\n        let r: f64 = rng.random::<f64>();\n        (-r.ln() * self.config.m_l).floor() as usize\n    }\n\n    #[inline]\n    fn get_entry_point<'db: 'arena, 'arena: 'txn, 'txn>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        label: &'arena str,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<HVector<'arena>, VectorError> {\n        let ep_id = self.vectors_db.get(txn, ENTRY_POINT_KEY)?;\n        if let Some(ep_id) = ep_id {\n            let mut arr = [0u8; 16];\n            let len = std::cmp::min(ep_id.len(), 16);\n            arr[..len].copy_from_slice(&ep_id[..len]);\n\n            let ep = self\n                .get_raw_vector_data(txn, u128::from_be_bytes(arr), label, arena)\n                .map_err(|_| VectorError::EntryPointNotFound)?;\n            Ok(ep)\n        } else {\n            Err(VectorError::EntryPointNotFound)\n        }\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_entry_point_144": {
      "name": "set_entry_point",
      "type": "method",
      "start_line": 144,
      "end_line": 386,
      "content_hash": "cc04df7d32eaf938e3fae0812ea30221b312d170",
      "content": "    fn set_entry_point(&self, txn: &mut RwTxn, entry: &HVector) -> Result<(), VectorError> {\n        self.vectors_db\n            .put(txn, ENTRY_POINT_KEY, &entry.id.to_be_bytes())\n            .map_err(VectorError::from)?;\n        Ok(())\n    }\n\n    #[inline(always)]\n    pub fn put_vector<'arena>(\n        &self,\n        txn: &mut RwTxn,\n        vector: &HVector<'arena>,\n    ) -> Result<(), VectorError> {\n        self.vectors_db\n            .put(\n                txn,\n                &Self::vector_key(vector.id, vector.level),\n                vector.vector_data_to_bytes()?,\n            )\n            .map_err(VectorError::from)?;\n        self.vector_properties_db\n            .put(txn, &vector.id, &bincode::serialize(&vector)?)?;\n        Ok(())\n    }\n\n    #[inline(always)]\n    fn get_neighbors<'db: 'arena, 'arena: 'txn, 'txn, F>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        label: &'arena str,\n        id: u128,\n        level: usize,\n        filter: Option<&[F]>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<bumpalo::collections::Vec<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &RoTxn<'db>) -> bool,\n    {\n        let out_key = Self::out_edges_key(id, level, None);\n        let mut neighbors = bumpalo::collections::Vec::with_capacity_in(\n            self.config.m_max_0.min(self.config.min_neighbors),\n            arena,\n        );\n\n        let iter = self\n            .edges_db\n            .lazily_decode_data()\n            .prefix_iter(txn, &out_key)?;\n\n        let prefix_len = out_key.len();\n\n        for result in iter {\n            let (key, _) = result?;\n\n            let mut arr = [0u8; 16];\n            arr[..16].copy_from_slice(&key[prefix_len..(prefix_len + 16)]);\n            let neighbor_id = u128::from_be_bytes(arr);\n\n            if neighbor_id == id {\n                continue;\n            }\n            let vector = self.get_raw_vector_data(txn, neighbor_id, label, arena)?;\n\n            let passes_filters = match filter {\n                Some(filter_slice) => filter_slice.iter().all(|f| f(&vector, txn)),\n                None => true,\n            };\n\n            if passes_filters {\n                neighbors.push(vector);\n            }\n        }\n        neighbors.shrink_to_fit();\n\n        Ok(neighbors)\n    }\n\n    #[inline(always)]\n    fn set_neighbours<'db: 'arena, 'arena: 'txn, 'txn, 's>(\n        &'db self,\n        txn: &'txn mut RwTxn<'db>,\n        id: u128,\n        neighbors: &BinaryHeap<'arena, HVector<'arena>>,\n        level: usize,\n    ) -> Result<(), VectorError> {\n        let prefix = Self::out_edges_key(id, level, None);\n\n        let mut keys_to_delete: HashSet<Vec<u8>> = self\n            .edges_db\n            .prefix_iter(txn, prefix.as_ref())?\n            .filter_map(|result| result.ok().map(|(key, _)| key.to_vec()))\n            .collect();\n\n        neighbors\n            .iter()\n            .try_for_each(|neighbor| -> Result<(), VectorError> {\n                let neighbor_id = neighbor.id;\n                if neighbor_id == id {\n                    return Ok(());\n                }\n\n                let out_key = Self::out_edges_key(id, level, Some(neighbor_id));\n                keys_to_delete.remove(&out_key);\n                self.edges_db.put(txn, &out_key, &())?;\n\n                let in_key = Self::out_edges_key(neighbor_id, level, Some(id));\n                keys_to_delete.remove(&in_key);\n                self.edges_db.put(txn, &in_key, &())?;\n\n                Ok(())\n            })?;\n\n        for key in keys_to_delete {\n            self.edges_db.delete(txn, &key)?;\n        }\n\n        Ok(())\n    }\n\n    fn select_neighbors<'db: 'arena, 'arena: 'txn, 'txn, 's, F>(\n        &'db self,\n        txn: &'txn RoTxn<'db>,\n        label: &'arena str,\n        query: &'s HVector<'arena>,\n        mut cands: BinaryHeap<'arena, HVector<'arena>>,\n        level: usize,\n        should_extend: bool,\n        filter: Option<&[F]>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<BinaryHeap<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &RoTxn<'db>) -> bool,\n    {\n        let m = self.config.m;\n\n        if !should_extend {\n            return Ok(cands.take_inord(m));\n        }\n\n        let mut visited: HashSet<u128> = HashSet::new();\n        let mut result = BinaryHeap::with_capacity(arena, m * cands.len());\n        for candidate in cands.iter() {\n            for mut neighbor in\n                self.get_neighbors(txn, label, candidate.id, level, filter, arena)?\n            {\n                if !visited.insert(neighbor.id) {\n                    continue;\n                }\n\n                neighbor.set_distance(neighbor.distance_to(query)?);\n\n                /*\n                let passes_filters = match filter {\n                    Some(filter_slice) => filter_slice.iter().all(|f| f(&neighbor, txn)),\n                    None => true,\n                };\n\n                if passes_filters {\n                    result.push(neighbor);\n                }\n                */\n\n                if filter.is_none() || filter.unwrap().iter().all(|f| f(&neighbor, txn)) {\n                    result.push(neighbor);\n                }\n            }\n        }\n\n        result.extend(cands);\n        Ok(result.take_inord(m))\n    }\n\n    fn search_level<'db: 'arena, 'arena: 'txn, 'txn, 'q, F>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        label: &'arena str,\n        query: &'q HVector<'arena>,\n        entry_point: &'q mut HVector<'arena>,\n        ef: usize,\n        level: usize,\n        filter: Option<&[F]>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<BinaryHeap<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &RoTxn<'db>) -> bool,\n    {\n        let mut visited: HashSet<u128> = HashSet::new();\n        let mut candidates: BinaryHeap<'arena, Candidate> =\n            BinaryHeap::with_capacity(arena, self.config.ef_construct);\n        let mut results: BinaryHeap<'arena, HVector<'arena>> = BinaryHeap::new(arena);\n\n        entry_point.set_distance(entry_point.distance_to(query)?);\n        candidates.push(Candidate {\n            id: entry_point.id,\n            distance: entry_point.get_distance(),\n        });\n        results.push(*entry_point);\n        visited.insert(entry_point.id);\n\n        while let Some(curr_cand) = candidates.pop() {\n            if results.len() >= ef\n                && results\n                    .get_max()\n                    .is_none_or(|f| curr_cand.distance > f.get_distance())\n            {\n                break;\n            }\n\n            let max_distance = if results.len() >= ef {\n                results.get_max().map(|f| f.get_distance())\n            } else {\n                None\n            };\n\n            self.get_neighbors(txn, label, curr_cand.id, level, filter, arena)?\n                .into_iter()\n                .filter(|neighbor| visited.insert(neighbor.id))\n                .filter_map(|mut neighbor| {\n                    let distance = neighbor.distance_to(query).ok()?;\n\n                    if max_distance.is_none_or(|max| distance < max) {\n                        neighbor.set_distance(distance);\n                        Some((neighbor, distance))\n                    } else {\n                        None\n                    }\n                })\n                .for_each(|(neighbor, distance)| {\n                    candidates.push(Candidate {\n                        id: neighbor.id,\n                        distance,\n                    });\n\n                    results.push(neighbor);\n\n                    if results.len() > ef {\n                        results = results.take_inord(ef);\n                    }\n                });\n        }\n        Ok(results)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_num_inserted_vectors_387": {
      "name": "num_inserted_vectors",
      "type": "method",
      "start_line": 387,
      "end_line": 495,
      "content_hash": "88a78c790775306138fdecb2c4fc0b53ecda92e1",
      "content": "    pub fn num_inserted_vectors(&self, txn: &RoTxn) -> Result<u64, VectorError> {\n        Ok(self.vectors_db.len(txn)?)\n    }\n\n    #[inline]\n    pub fn get_vector_properties<'db: 'arena, 'arena: 'txn, 'txn>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        id: u128,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<Option<VectorWithoutData<'arena>>, VectorError> {\n        let vector: Option<VectorWithoutData<'arena>> =\n            match self.vector_properties_db.get(txn, &id)? {\n                Some(bytes) => Some(VectorWithoutData::from_bincode_bytes(arena, bytes, id)?),\n                None => None,\n            };\n\n        if let Some(vector) = vector\n            && vector.deleted\n        {\n            return Err(VectorError::VectorDeleted);\n        }\n\n        Ok(vector)\n    }\n\n    #[inline(always)]\n    pub fn get_full_vector<'arena>(\n        &self,\n        txn: &RoTxn,\n        id: u128,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<HVector<'arena>, VectorError> {\n        let vector_data_bytes = self\n            .vectors_db\n            .get(txn, &Self::vector_key(id, 0))?\n            .ok_or(VectorError::VectorNotFound(uuid_str(id, arena).to_string()))?;\n\n        let properties_bytes = self.vector_properties_db.get(txn, &id)?;\n\n        let vector = HVector::from_bincode_bytes(arena, properties_bytes, vector_data_bytes, id)?;\n        if vector.deleted {\n            return Err(VectorError::VectorDeleted);\n        }\n        Ok(vector)\n    }\n\n    #[inline(always)]\n    pub fn get_raw_vector_data<'db: 'arena, 'arena: 'txn, 'txn>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        id: u128,\n        label: &'arena str,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<HVector<'arena>, VectorError> {\n        let vector_data_bytes = self\n            .vectors_db\n            .get(txn, &Self::vector_key(id, 0))?\n            .ok_or(VectorError::VectorNotFound(uuid_str(id, arena).to_string()))?;\n        HVector::from_raw_vector_data(arena, vector_data_bytes, label, id)\n    }\n\n    /// Get all vectors from the database, optionally filtered by level\n    pub fn get_all_vectors<'db: 'arena, 'arena: 'txn, 'txn>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        level: Option<usize>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<bumpalo::collections::Vec<'arena, HVector<'arena>>, VectorError> {\n        let mut vectors = bumpalo::collections::Vec::new_in(arena);\n\n        // Iterate over all vectors in the database\n        let prefix_iter = self.vectors_db.prefix_iter(txn, VECTOR_PREFIX)?;\n\n        for result in prefix_iter {\n            let (key, _) = result?;\n\n            // Extract id from the key: v: (2 bytes) + id (16 bytes) + level (8 bytes)\n            if key.len() < VECTOR_PREFIX.len() + 16 {\n                continue; // Skip malformed keys\n            }\n\n            let mut id_bytes = [0u8; 16];\n            id_bytes.copy_from_slice(&key[VECTOR_PREFIX.len()..VECTOR_PREFIX.len() + 16]);\n            let id = u128::from_be_bytes(id_bytes);\n\n            // Get the full vector using the existing method\n            match self.get_full_vector(txn, id, arena) {\n                Ok(vector) => {\n                    // Filter by level if specified\n                    if let Some(lvl) = level {\n                        if vector.level == lvl {\n                            vectors.push(vector);\n                        }\n                    } else {\n                        vectors.push(vector);\n                    }\n                }\n                Err(_) => {\n                    // Skip vectors that can't be loaded (e.g., deleted)\n                    continue;\n                }\n            }\n        }\n\n        Ok(vectors)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HNSW_496": {
      "name": "HNSW",
      "type": "impl",
      "start_line": 496,
      "end_line": 646,
      "content_hash": "f064ecdc422d58b48cac3b7be200b891744454cd",
      "content": "impl HNSW for VectorCore {\n    fn search<'db, 'arena, 'txn, F>(\n        &self,\n        txn: &'txn RoTxn<'db>,\n        query: &'arena [f64],\n        k: usize,\n        label: &'arena str,\n        filter: Option<&'arena [F]>,\n        should_trickle: bool,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<bumpalo::collections::Vec<'arena, HVector<'arena>>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &RoTxn<'db>) -> bool,\n        'db: 'arena,\n        'arena: 'txn,\n    {\n        let query = HVector::from_slice(label, 0, query);\n        // let temp_arena = bumpalo::Bump::new();\n\n        let mut entry_point = self.get_entry_point(txn, label, arena)?;\n\n        let ef = self.config.ef;\n        let curr_level = entry_point.level;\n        // println!(\"curr_level: {curr_level}\");\n        for level in (1..=curr_level).rev() {\n            let mut nearest = self.search_level(\n                txn,\n                label,\n                &query,\n                &mut entry_point,\n                ef,\n                level,\n                match should_trickle {\n                    true => filter,\n                    false => None,\n                },\n                arena,\n            )?;\n            if let Some(closest) = nearest.pop() {\n                entry_point = closest;\n            }\n        }\n        // println!(\"entry_point: {entry_point:?}\");\n        let candidates = self.search_level(\n            txn,\n            label,\n            &query,\n            &mut entry_point,\n            ef,\n            0,\n            match should_trickle {\n                true => filter,\n                false => None,\n            },\n            arena,\n        )?;\n        // println!(\"candidates\");\n        let results = candidates.to_vec_with_filter::<F, true>(\n            k,\n            filter,\n            label,\n            txn,\n            self.vector_properties_db,\n            arena,\n        )?;\n\n        debug_println!(\"vector search found {} results\", results.len());\n        Ok(results)\n    }\n\n    fn insert<'db, 'arena, 'txn, F>(\n        &'db self,\n        txn: &'txn mut RwTxn<'db>,\n        label: &'arena str,\n        data: &'arena [f64],\n        properties: Option<ImmutablePropertiesMap<'arena>>,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<HVector<'arena>, VectorError>\n    where\n        F: Fn(&HVector<'arena>, &RoTxn<'db>) -> bool,\n        'db: 'arena,\n        'arena: 'txn,\n    {\n        let new_level = self.get_new_level();\n\n        let mut query = HVector::from_slice(label, 0, data);\n        query.properties = properties;\n        self.put_vector(txn, &query)?;\n\n        query.level = new_level;\n\n        let entry_point = match self.get_entry_point(txn, label, arena) {\n            Ok(ep) => ep,\n            Err(_) => {\n                // TODO: use proper error handling\n                self.set_entry_point(txn, &query)?;\n                query.set_distance(0.0);\n\n                return Ok(query);\n            }\n        };\n\n        let l = entry_point.level;\n        let mut curr_ep = entry_point;\n        for level in (new_level + 1..=l).rev() {\n            let mut nearest =\n                self.search_level::<F>(txn, label, &query, &mut curr_ep, 1, level, None, arena)?;\n            curr_ep = nearest.pop().ok_or(VectorError::VectorCoreError(\n                \"emtpy search result\".to_string(),\n            ))?;\n        }\n\n        for level in (0..=l.min(new_level)).rev() {\n            let nearest = self.search_level::<F>(\n                txn,\n                label,\n                &query,\n                &mut curr_ep,\n                self.config.ef_construct,\n                level,\n                None,\n                arena,\n            )?;\n            curr_ep = *nearest.peek().ok_or(VectorError::VectorCoreError(\n                \"emtpy search result\".to_string(),\n            ))?;\n\n            let neighbors =\n                self.select_neighbors::<F>(txn, label, &query, nearest, level, true, None, arena)?;\n            self.set_neighbours(txn, query.id, &neighbors, level)?;\n\n            for e in neighbors {\n                let id = e.id;\n                let e_conns = BinaryHeap::from(\n                    arena,\n                    self.get_neighbors::<F>(txn, label, id, level, None, arena)?,\n                );\n                let e_new_conn = self\n                    .select_neighbors::<F>(txn, label, &query, e_conns, level, true, None, arena)?;\n                self.set_neighbours(txn, id, &e_new_conn, level)?;\n            }\n        }\n\n        if new_level > l {\n            self.set_entry_point(txn, &query)?;\n        }\n\n        debug_println!(\"vector inserted with id {}\", query.id);\n        Ok(query)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_delete_647": {
      "name": "delete",
      "type": "method",
      "start_line": 647,
      "end_line": 664,
      "content_hash": "65f7622cd58cd3dd91e38acbea22d996d4549ba2",
      "content": "    fn delete(&self, txn: &mut RwTxn, id: u128, arena: &bumpalo::Bump) -> Result<(), VectorError> {\n        match self.get_vector_properties(txn, id, arena)? {\n            Some(mut properties) => {\n                debug_println!(\"properties: {properties:?}\");\n                if properties.deleted {\n                    return Err(VectorError::VectorAlreadyDeleted(id.to_string()));\n                }\n\n                properties.deleted = true;\n                self.vector_properties_db\n                    .put(txn, &id, &bincode::serialize(&properties)?)?;\n                debug_println!(\"vector deleted with id {}\", &id);\n                Ok(())\n            }\n            None => Err(VectorError::VectorNotFound(id.to_string())),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}