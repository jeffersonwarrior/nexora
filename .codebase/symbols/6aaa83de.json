{
  "file_path": "/work/.local/tools/modelscan/storage/rate_limits_test.go",
  "file_hash": "76b1a8d4f3cab72d6653a5040213a423a8b51bde",
  "updated_at": "2025-12-26T17:34:22.417920",
  "symbols": {
    "function_TestCreateRateLimitTables_CreatesAllTables_11": {
      "name": "TestCreateRateLimitTables_CreatesAllTables",
      "type": "function",
      "start_line": 11,
      "end_line": 43,
      "content_hash": "bd219b38631b4be861ed1641aec7b2bd8cf7f124",
      "content": "func TestCreateRateLimitTables_CreatesAllTables(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_rate_limits.db\"\n\tdefer os.Remove(dbPath)\n\n\t// Act\n\terr := InitRateLimitDB(dbPath)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize rate limit DB: %v\", err)\n\t}\n\tdefer CloseRateLimitDB()\n\n\t// Assert - Check all 4 tables exist\n\ttables := []string{\"rate_limits\", \"plan_metadata\", \"provider_pricing\", \"pricing_history\"}\n\tfor _, table := range tables {\n\t\tvar name string\n\t\terr := GetRateLimitDB().QueryRow(\n\t\t\t\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n\t\t\ttable,\n\t\t).Scan(&name)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Table %s does not exist: %v\", table, err)\n\t\t}\n\t}\n\n\t// Assert - Check WAL mode is enabled\n\tvar walMode string\n\terr = GetRateLimitDB().QueryRow(\"PRAGMA journal_mode\").Scan(&walMode)\n\tif err != nil || walMode != \"wal\" {\n\t\tt.Errorf(\"WAL mode not enabled, got: %s\", walMode)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInsertRateLimit_UpdatesOnConflict_44": {
      "name": "TestInsertRateLimit_UpdatesOnConflict",
      "type": "function",
      "start_line": 44,
      "end_line": 89,
      "content_hash": "7965542fd662f1cdc90f4e14ce5dab1f410aa42e",
      "content": "func TestInsertRateLimit_UpdatesOnConflict(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_rate_limits_insert.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\trateLimit := RateLimit{\n\t\tProviderName:       \"openai\",\n\t\tPlanType:           \"tier-1\",\n\t\tLimitType:          \"rpm\",\n\t\tLimitValue:         500,\n\t\tBurstAllowance:     50,\n\t\tResetWindowSeconds: 60,\n\t\tAppliesTo:          \"account\",\n\t\tSourceURL:          \"https://platform.openai.com/docs/guides/rate-limits\",\n\t\tLastVerified:       time.Now(),\n\t}\n\n\t// Act - First insert\n\terr := InsertRateLimit(rateLimit)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert rate limit: %v\", err)\n\t}\n\n\t// Act - Update same rate limit (conflict)\n\trateLimit.LimitValue = 600\n\trateLimit.LastVerified = time.Now()\n\terr = InsertRateLimit(rateLimit)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to update rate limit on conflict: %v\", err)\n\t}\n\n\t// Assert - Verify updated value\n\tretrieved, err := QueryRateLimit(\"openai\", \"tier-1\", \"rpm\", \"\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to query rate limit: %v\", err)\n\t}\n\tif len(retrieved) != 1 {\n\t\tt.Fatalf(\"Expected 1 rate limit, got %d\", len(retrieved))\n\t}\n\tif retrieved[0].LimitValue != 600 {\n\t\tt.Errorf(\"Expected limit_value=600, got %d\", retrieved[0].LimitValue)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestQueryRateLimit_HandlesConcurrentReads_90": {
      "name": "TestQueryRateLimit_HandlesConcurrentReads",
      "type": "function",
      "start_line": 90,
      "end_line": 125,
      "content_hash": "a59379f662bdfa2a355bcb4d9345de0ddd5088a9",
      "content": "func TestQueryRateLimit_HandlesConcurrentReads(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_rate_limits_concurrent.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\t// Insert test data\n\tInsertRateLimit(RateLimit{\n\t\tProviderName:       \"anthropic\",\n\t\tPlanType:           \"free\",\n\t\tLimitType:          \"rpm\",\n\t\tLimitValue:         50,\n\t\tResetWindowSeconds: 60,\n\t\tAppliesTo:          \"account\",\n\t\tLastVerified:       time.Now(),\n\t})\n\n\t// Act - 10 concurrent reads\n\tdone := make(chan bool, 10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\t_, err := QueryRateLimit(\"anthropic\", \"free\", \"rpm\", \"\", \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Concurrent read failed: %v\", err)\n\t\t\t}\n\t\t\tdone <- true\n\t\t}()\n\t}\n\n\t// Assert - All reads complete successfully\n\tfor i := 0; i < 10; i++ {\n\t\t<-done\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestQueryRateLimit_FiltersByModelAndEndpoint_126": {
      "name": "TestQueryRateLimit_FiltersByModelAndEndpoint",
      "type": "function",
      "start_line": 126,
      "end_line": 168,
      "content_hash": "ec706b7c5debb17b139d87a696099b742165bb2c",
      "content": "func TestQueryRateLimit_FiltersByModelAndEndpoint(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_rate_limits_filter.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\t// Insert rate limits with different scopes\n\tInsertRateLimit(RateLimit{\n\t\tProviderName:       \"openai\",\n\t\tPlanType:           \"tier-2\",\n\t\tLimitType:          \"rpm\",\n\t\tLimitValue:         3500,\n\t\tResetWindowSeconds: 60,\n\t\tAppliesTo:          \"account\",\n\t\tLastVerified:       time.Now(),\n\t})\n\tInsertRateLimit(RateLimit{\n\t\tProviderName:       \"openai\",\n\t\tPlanType:           \"tier-2\",\n\t\tLimitType:          \"tpm\",\n\t\tLimitValue:         80000,\n\t\tResetWindowSeconds: 60,\n\t\tAppliesTo:          \"model\",\n\t\tModelID:            sql.NullString{String: \"gpt-4o\", Valid: true},\n\t\tLastVerified:       time.Now(),\n\t})\n\n\t// Act - Query for specific model\n\tresults, err := QueryRateLimit(\"openai\", \"tier-2\", \"tpm\", \"gpt-4o\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to query with model filter: %v\", err)\n\t}\n\n\t// Assert\n\tif len(results) != 1 {\n\t\tt.Fatalf(\"Expected 1 result, got %d\", len(results))\n\t}\n\tif results[0].ModelID.String != \"gpt-4o\" {\n\t\tt.Errorf(\"Expected model gpt-4o, got %s\", results[0].ModelID.String)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInsertPlanMetadata_StoresAllFields_169": {
      "name": "TestInsertPlanMetadata_StoresAllFields",
      "type": "function",
      "start_line": 169,
      "end_line": 205,
      "content_hash": "cbbf43c8f6c16fa4276490f3081c34f1e69f9a4d",
      "content": "func TestInsertPlanMetadata_StoresAllFields(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_plan_metadata.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\tplan := PlanMetadata{\n\t\tProviderName:     \"deepseek\",\n\t\tPlanType:         \"pay_per_go\",\n\t\tOfficialName:     \"Pay-as-you-go\",\n\t\tCostPerMonth:     sql.NullFloat64{Float64: 0.0, Valid: true},\n\t\tHasFreeTier:      true,\n\t\tDocumentationURL: \"https://platform.deepseek.com/api-docs/pricing/\",\n\t}\n\n\t// Act\n\terr := InsertPlanMetadata(plan)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert plan metadata: %v\", err)\n\t}\n\n\t// Assert\n\tvar retrievedName string\n\tvar hasFreeTier bool\n\terr = GetRateLimitDB().QueryRow(\n\t\t\"SELECT official_name, has_free_tier FROM plan_metadata WHERE provider_name=? AND plan_type=?\",\n\t\t\"deepseek\", \"pay_per_go\",\n\t).Scan(&retrievedName, &hasFreeTier)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to retrieve plan metadata: %v\", err)\n\t}\n\tif retrievedName != \"Pay-as-you-go\" || !hasFreeTier {\n\t\tt.Errorf(\"Plan metadata mismatch: name=%s, free_tier=%v\", retrievedName, hasFreeTier)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInsertProviderPricing_HandlesMultiplePlans_206": {
      "name": "TestInsertProviderPricing_HandlesMultiplePlans",
      "type": "function",
      "start_line": 206,
      "end_line": 253,
      "content_hash": "969ec04bf33aa872463b324c0c587b483ab14dec",
      "content": "func TestInsertProviderPricing_HandlesMultiplePlans(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_pricing.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\t// Insert pricing for free and paid plans\n\tfreePricing := ProviderPricing{\n\t\tProviderName:  \"cerebras\",\n\t\tModelID:       \"llama3.1-8b\",\n\t\tPlanType:      \"free\",\n\t\tInputCost:     0.0,\n\t\tOutputCost:    0.0,\n\t\tUnitType:      \"1M tokens\",\n\t\tCurrency:      \"USD\",\n\t\tIncludedUnits: sql.NullInt64{Int64: 1000000, Valid: true},\n\t}\n\tpaidPricing := ProviderPricing{\n\t\tProviderName: \"cerebras\",\n\t\tModelID:      \"llama3.1-70b\",\n\t\tPlanType:     \"pay_per_go\",\n\t\tInputCost:    0.60,\n\t\tOutputCost:   0.60,\n\t\tUnitType:     \"1M tokens\",\n\t\tCurrency:     \"USD\",\n\t}\n\n\t// Act\n\terr := InsertProviderPricing(freePricing)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert free pricing: %v\", err)\n\t}\n\terr = InsertProviderPricing(paidPricing)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert paid pricing: %v\", err)\n\t}\n\n\t// Assert - Check both exist\n\tvar count int\n\terr = GetRateLimitDB().QueryRow(\n\t\t\"SELECT COUNT(*) FROM provider_pricing WHERE provider_name='cerebras'\",\n\t).Scan(&count)\n\tif err != nil || count != 2 {\n\t\tt.Errorf(\"Expected 2 pricing entries, got %d\", count)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPricingHistory_RecordsChanges_254": {
      "name": "TestPricingHistory_RecordsChanges",
      "type": "function",
      "start_line": 254,
      "end_line": 290,
      "content_hash": "ad7ccdfd215108f903aaa0fa1e48b018742cd06b",
      "content": "func TestPricingHistory_RecordsChanges(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_pricing_history.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\thistory := PricingHistory{\n\t\tProviderName: \"openai\",\n\t\tModelID:      \"gpt-4o\",\n\t\tPlanType:     \"tier-3\",\n\t\tOldInputCost: 5.00,\n\t\tNewInputCost: 2.50,\n\t\tChangeDate:   time.Now(),\n\t\tChangeReason: \"Pricing reduction announced 2024-12-18\",\n\t}\n\n\t// Act\n\terr := InsertPricingHistory(history)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert pricing history: %v\", err)\n\t}\n\n\t// Assert\n\tvar changeReason string\n\terr = GetRateLimitDB().QueryRow(\n\t\t\"SELECT change_reason FROM pricing_history WHERE provider_name=? AND model_id=?\",\n\t\t\"openai\", \"gpt-4o\",\n\t).Scan(&changeReason)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to retrieve pricing history: %v\", err)\n\t}\n\tif changeReason != \"Pricing reduction announced 2024-12-18\" {\n\t\tt.Errorf(\"Change reason mismatch: %s\", changeReason)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRateLimitIndexes_ExistForPerformance_291": {
      "name": "TestRateLimitIndexes_ExistForPerformance",
      "type": "function",
      "start_line": 291,
      "end_line": 316,
      "content_hash": "4f7e194b0a7d048d411d5efa4f297398cae52dd2",
      "content": "func TestRateLimitIndexes_ExistForPerformance(t *testing.T) {\n\t// Arrange\n\tdbPath := \"/tmp/test_indexes.db\"\n\tdefer os.Remove(dbPath)\n\tInitRateLimitDB(dbPath)\n\tdefer CloseRateLimitDB()\n\n\t// Assert - Check critical indexes exist\n\tindexes := []string{\n\t\t\"idx_rate_limits_provider_plan\",\n\t\t\"idx_plan_metadata_provider\",\n\t\t\"idx_provider_pricing_model\",\n\t}\n\n\tfor _, idx := range indexes {\n\t\tvar name string\n\t\terr := GetRateLimitDB().QueryRow(\n\t\t\t\"SELECT name FROM sqlite_master WHERE type='index' AND name=?\",\n\t\t\tidx,\n\t\t).Scan(&name)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Index %s does not exist: %v\", idx, err)\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGetProviderPricing_317": {
      "name": "TestGetProviderPricing",
      "type": "function",
      "start_line": 317,
      "end_line": 369,
      "content_hash": "deaedcc4e6e2b940de0c811cfbd5e79170ac89b3",
      "content": "func TestGetProviderPricing(t *testing.T) {\n\t// Setup\n\terr := InitRateLimitDB(\"/tmp/test_rate_limits_\" + t.Name() + \".db\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize DB: %v\", err)\n\t}\n\tdefer CloseRateLimitDB()\n\tdefer os.Remove(\"/tmp/test_rate_limits_\" + t.Name() + \".db\")\n\n\t// Insert test pricing\n\tpricing := ProviderPricing{\n\t\tProviderName: \"test-provider\",\n\t\tModelID:      \"test-model\",\n\t\tPlanType:     \"pro\",\n\t\tInputCost:    0.001,\n\t\tOutputCost:   0.002,\n\t\tUnitType:     \"token\",\n\t\tCurrency:     \"USD\",\n\t}\n\n\terr = InsertProviderPricing(pricing)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert pricing: %v\", err)\n\t}\n\n\t// Test retrieval\n\tresult, err := GetProviderPricing(\"test-provider\", \"test-model\", \"pro\")\n\tif err != nil {\n\t\tt.Fatalf(\"GetProviderPricing failed: %v\", err)\n\t}\n\n\tif result == nil {\n\t\tt.Fatal(\"Expected pricing, got nil\")\n\t}\n\n\tif result.InputCost != 0.001 {\n\t\tt.Errorf(\"Expected InputCost 0.001, got %v\", result.InputCost)\n\t}\n\n\tif result.OutputCost != 0.002 {\n\t\tt.Errorf(\"Expected OutputCost 0.002, got %v\", result.OutputCost)\n\t}\n\n\t// Test non-existent pricing\n\tresult, err = GetProviderPricing(\"nonexistent\", \"model\", \"plan\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for non-existent pricing, got: %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Error(\"Expected nil for non-existent pricing\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGetAllRateLimitsForProvider_370": {
      "name": "TestGetAllRateLimitsForProvider",
      "type": "function",
      "start_line": 370,
      "end_line": 445,
      "content_hash": "968995c5e7a6496e5c0507945b9b63f31bb6a512",
      "content": "func TestGetAllRateLimitsForProvider(t *testing.T) {\n\t// Setup\n\terr := InitRateLimitDB(\"/tmp/test_rate_limits_\" + t.Name() + \".db\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize DB: %v\", err)\n\t}\n\tdefer CloseRateLimitDB()\n\tdefer os.Remove(\"/tmp/test_rate_limits_\" + t.Name() + \".db\")\n\n\t// Insert test rate limits\n\tlimits := []RateLimit{\n\t\t{\n\t\t\tProviderName: \"test-provider\",\n\t\t\tPlanType:     \"free\",\n\t\t\tLimitType:    \"rpm\",\n\t\t\tLimitValue:   60,\n\t\t},\n\t\t{\n\t\t\tProviderName: \"test-provider\",\n\t\t\tPlanType:     \"free\",\n\t\t\tLimitType:    \"tpm\",\n\t\t\tLimitValue:   10000,\n\t\t},\n\t\t{\n\t\t\tProviderName: \"other-provider\",\n\t\t\tPlanType:     \"free\",\n\t\t\tLimitType:    \"rpm\",\n\t\t\tLimitValue:   100,\n\t\t},\n\t}\n\n\tfor _, limit := range limits {\n\t\tif err := InsertRateLimit(limit); err != nil {\n\t\t\tt.Fatalf(\"Failed to insert rate limit: %v\", err)\n\t\t}\n\t}\n\n\t// Test retrieval\n\tresults, err := GetAllRateLimitsForProvider(\"test-provider\", \"free\")\n\tif err != nil {\n\t\tt.Fatalf(\"GetAllRateLimitsForProvider failed: %v\", err)\n\t}\n\n\tif len(results) != 2 {\n\t\tt.Errorf(\"Expected 2 rate limits, got %d\", len(results))\n\t}\n\n\t// Verify we got the right limits\n\thasRPM := false\n\thasTPM := false\n\tfor _, limit := range results {\n\t\tif limit.LimitType == \"rpm\" && limit.LimitValue == 60 {\n\t\t\thasRPM = true\n\t\t}\n\t\tif limit.LimitType == \"tpm\" && limit.LimitValue == 10000 {\n\t\t\thasTPM = true\n\t\t}\n\t}\n\n\tif !hasRPM {\n\t\tt.Error(\"Missing RPM limit\")\n\t}\n\tif !hasTPM {\n\t\tt.Error(\"Missing TPM limit\")\n\t}\n\n\t// Test non-existent provider\n\tresults, err = GetAllRateLimitsForProvider(\"nonexistent\", \"free\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for non-existent provider, got: %v\", err)\n\t}\n\tif len(results) != 0 {\n\t\tt.Errorf(\"Expected 0 rate limits for non-existent provider, got %d\", len(results))\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCloseDB_446": {
      "name": "TestCloseDB",
      "type": "function",
      "start_line": 446,
      "end_line": 462,
      "content_hash": "b12501b6371dfc166783df6d887558b3b99533a8",
      "content": "func TestCloseDB(t *testing.T) {\n\t// Setup\n\terr := InitRateLimitDB(\"/tmp/test_rate_limits_\" + t.Name() + \".db\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize DB: %v\", err)\n\t}\n\n\t// Test closing\n\terr = CloseDB()\n\tif err != nil {\n\t\tt.Fatalf(\"CloseDB failed: %v\", err)\n\t}\n\n\t// Verify DB is closed by trying to query (should fail)\n\t_, err = QueryRateLimit(\"test\", \"test\", \"\", \"\", \"\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInitRateLimitDB_EdgeCases_463": {
      "name": "TestInitRateLimitDB_EdgeCases",
      "type": "function",
      "start_line": 463,
      "end_line": 504,
      "content_hash": "b4c8c00b195fb9929493fe6c1b2f3f879915f77a",
      "content": "func TestInitRateLimitDB_EdgeCases(t *testing.T) {\n\t// Test with invalid path\n\terr := InitRateLimitDB(\"/invalid/path/that/does/not/exist/test.db\")\n\tif err == nil {\n\t\tt.Error(\"Expected error with invalid path\")\n\t}\n\n\t// Clean up in case it was created\n\tCloseRateLimitDB()\n\n\t// Test successful initialization\n\ttmpDir := t.TempDir()\n\tdbPath := filepath.Join(tmpDir, \"test_ratelimit.db\")\n\n\terr = InitRateLimitDB(dbPath)\n\tif err != nil {\n\t\tt.Fatalf(\"InitRateLimitDB failed: %v\", err)\n\t}\n\tdefer CloseRateLimitDB()\n\n\t// Verify database was created\n\tif _, err := os.Stat(dbPath); os.IsNotExist(err) {\n\t\tt.Error(\"Database file was not created\")\n\t}\n\n\t// Verify we can query the database\n\tdb := GetRateLimitDB()\n\tif db == nil {\n\t\tt.Fatal(\"GetRateLimitDB returned nil\")\n\t}\n\n\t// Test that tables were created\n\tvar count int\n\terr = db.QueryRow(\"SELECT COUNT(*) FROM sqlite_master WHERE type='table'\").Scan(&count)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to query tables: %v\", err)\n\t}\n\tif count == 0 {\n\t\tt.Error(\"No tables were created\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCloseRateLimitDB_Multiple_505": {
      "name": "TestCloseRateLimitDB_Multiple",
      "type": "function",
      "start_line": 505,
      "end_line": 526,
      "content_hash": "0dee055409ab0bb4bddcbcf43893b95f78a71bec",
      "content": "func TestCloseRateLimitDB_Multiple(t *testing.T) {\n\ttmpDir := t.TempDir()\n\tdbPath := filepath.Join(tmpDir, \"test_close_ratelimit.db\")\n\n\terr := InitRateLimitDB(dbPath)\n\tif err != nil {\n\t\tt.Fatalf(\"InitRateLimitDB failed: %v\", err)\n\t}\n\n\t// First close\n\terr = CloseRateLimitDB()\n\tif err != nil {\n\t\tt.Errorf(\"First CloseRateLimitDB failed: %v\", err)\n\t}\n\n\t// Second close should handle nil gracefully\n\terr = CloseRateLimitDB()\n\tif err != nil {\n\t\tt.Errorf(\"Second CloseRateLimitDB should not error, got: %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCloseRateLimitDB_WhenNil_527": {
      "name": "TestCloseRateLimitDB_WhenNil",
      "type": "function",
      "start_line": 527,
      "end_line": 537,
      "content_hash": "f529bb3b7d196763a78bbc8b7cc732d16444460a",
      "content": "func TestCloseRateLimitDB_WhenNil(t *testing.T) {\n\t// Ensure database is closed/nil\n\tCloseRateLimitDB()\n\n\t// Test closing when already nil\n\terr := CloseRateLimitDB()\n\tif err != nil {\n\t\tt.Errorf(\"CloseRateLimitDB on nil should not error, got: %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGetRateLimitDB_AfterInit_538": {
      "name": "TestGetRateLimitDB_AfterInit",
      "type": "function",
      "start_line": 538,
      "end_line": 558,
      "content_hash": "224b9c9e20fc40a0cbceddd11b84b2cdef147818",
      "content": "func TestGetRateLimitDB_AfterInit(t *testing.T) {\n\ttmpDir := t.TempDir()\n\tdbPath := filepath.Join(tmpDir, \"test_get_ratelimit.db\")\n\n\terr := InitRateLimitDB(dbPath)\n\tif err != nil {\n\t\tt.Fatalf(\"InitRateLimitDB failed: %v\", err)\n\t}\n\tdefer CloseRateLimitDB()\n\n\tdb := GetRateLimitDB()\n\tif db == nil {\n\t\tt.Fatal(\"GetRateLimitDB returned nil after successful init\")\n\t}\n\n\t// Verify we can ping the database\n\terr = db.Ping()\n\tif err != nil {\n\t\tt.Errorf(\"Database ping failed: %v\", err)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}