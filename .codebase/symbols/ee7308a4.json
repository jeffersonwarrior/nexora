{
  "file_path": "/work/context-engine/vscode-extension/context-engine-uploader/ctx_config.js",
  "file_hash": "268327d48b5ebcdb172aaf055f6ad5433ef2d73e",
  "updated_at": "2025-12-26T17:34:20.396816",
  "symbols": {
    "function_createCtxConfigManager_4": {
      "name": "createCtxConfigManager",
      "type": "function",
      "start_line": 4,
      "end_line": 415,
      "content_hash": "dd1cf1bcb7671df023f74fa7358d663a1f190834",
      "content": "function createCtxConfigManager(deps) {\n  const vscode = deps.vscode;\n  const spawnSync = deps.spawnSync;\n  const log = deps.log;\n\n  const extensionRoot = deps.extensionRoot;\n  const getEffectiveConfig = deps.getEffectiveConfig;\n  const resolveOptions = deps.resolveOptions;\n  const ensurePythonDependencies = deps.ensurePythonDependencies;\n  const buildChildEnv = deps.buildChildEnv;\n  const resolveBridgeHttpUrl = deps.resolveBridgeHttpUrl;\n\n  function dispose() {\n    // Currently no timers/processes; kept for consistent manager lifecycle.\n  }\n\n  async function writeCtxConfig() {\n    const settings = getEffectiveConfig();\n    const enabled = settings.get('scaffoldCtxConfig', true);\n    if (!enabled) {\n      vscode.window.showInformationMessage('Context Engine Uploader: ctx_config/.env scaffolding is disabled (contextEngineUploader.scaffoldCtxConfig=false).');\n      log('CTX config scaffolding skipped because scaffoldCtxConfig is false.');\n      return;\n    }\n    let options = resolveOptions();\n    if (!options) {\n      return;\n    }\n    const depsOk = await ensurePythonDependencies(options.pythonPath);\n    if (!depsOk) {\n      return;\n    }\n    options = resolveOptions() || options;\n    const collectionName = inferCollectionFromUpload(options);\n    if (!collectionName) {\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to infer collection name from upload client. Check the Output panel for details.');\n      return;\n    }\n    await scaffoldCtxConfigFiles(options.targetPath, collectionName);\n  }\n\n  function inferCollectionFromUpload(options) {\n    try {\n      const args = ['-u', options.scriptPath, '--path', options.targetPath, '--endpoint', options.endpoint, '--show-mapping'];\n      const result = spawnSync(options.pythonPath, args, {\n        cwd: options.workingDirectory,\n        env: buildChildEnv(options),\n        encoding: 'utf8'\n      });\n      if (result.error) {\n        log(`Failed to run standalone_upload_client for collection inference: ${result.error.message || String(result.error)}`);\n        return undefined;\n      }\n      const stdout = result.stdout || '';\n      const stderr = result.stderr || '';\n\n      if (stdout) {\n        log(`[ctx-config] upload client --show-mapping output:\\n${stdout}`);\n      }\n      if (stderr) {\n        log(`[ctx-config] upload client stderr:\\n${stderr}`);\n      }\n\n      const combined = `${stdout}\\n${stderr}`;\n      if (combined.trim()) {\n        const lines = combined.split(/\\r?\\n/);\n        for (const line of lines) {\n          const m = line.match(/collection_name:\\s*(.+)$/);\n          if (m && m[1]) {\n            const name = m[1].trim();\n            if (name) {\n              return name;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      log(`Error inferring collection from upload client: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    return undefined;\n  }\n\n  async function scaffoldCtxConfigFiles(workspaceDir, collectionName) {\n    try {\n      const placeholders = new Set(['', 'default-collection', 'my-collection', 'codebase']);\n\n      let uploaderSettings;\n      try {\n        uploaderSettings = getEffectiveConfig();\n      } catch (error) {\n        log(`Failed to read uploader settings: ${error instanceof Error ? error.message : String(error)}`);\n        uploaderSettings = undefined;\n      }\n\n      let decoderRuntime = 'glm';\n      let useGpuDecoderSetting = false;\n      let glmApiKey = '';\n      let glmApiBase = 'https://api.z.ai/api/coding/paas/v4/';\n      let glmModel = 'glm-4.6';\n      let gitMaxCommits = 500;\n      let gitSince = '';\n      if (uploaderSettings) {\n        try {\n          const runtimeSetting = String(uploaderSettings.get('decoderRuntime') ?? 'glm').trim().toLowerCase();\n          if (runtimeSetting === 'llamacpp') {\n            decoderRuntime = 'llamacpp';\n          }\n          useGpuDecoderSetting = !!uploaderSettings.get('useGpuDecoder', false);\n          // TODO: glmApiKey is read from settings.json (plaintext). Consider migrating API keys to VS Code SecretStorage (context.secrets) with backwards-compatible fallback.\n          const cfgKey = (uploaderSettings.get('glmApiKey') || '').trim();\n          const cfgBase = (uploaderSettings.get('glmApiBase') || '').trim();\n          const cfgModel = (uploaderSettings.get('glmModel') || '').trim();\n          if (cfgKey) {\n            glmApiKey = cfgKey;\n          }\n          if (cfgBase) {\n            glmApiBase = cfgBase;\n          }\n          if (cfgModel) {\n            glmModel = cfgModel;\n          }\n          const maxCommitsSetting = uploaderSettings.get('gitMaxCommits');\n          if (typeof maxCommitsSetting === 'number' && !Number.isNaN(maxCommitsSetting)) {\n            gitMaxCommits = maxCommitsSetting;\n          }\n          const sinceSetting = uploaderSettings.get('gitSince');\n          if (typeof sinceSetting === 'string') {\n            gitSince = sinceSetting.trim();\n          }\n        } catch (error) {\n          log(`Failed to read decoder/GLM settings from configuration: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n\n      const ctxConfigPath = path.join(workspaceDir, 'ctx_config.json');\n      let ctxConfig = {};\n      if (fs.existsSync(ctxConfigPath)) {\n        try {\n          const raw = fs.readFileSync(ctxConfigPath, 'utf8');\n          const parsed = JSON.parse(raw);\n          if (parsed && typeof parsed === 'object') {\n            ctxConfig = parsed;\n          }\n        } catch (error) {\n          log(`Failed to parse existing ctx_config.json at ${ctxConfigPath}; overwriting with minimal config. Error: ${error instanceof Error ? error.message : String(error)}`);\n          ctxConfig = {};\n        }\n      }\n      const currentDefault = typeof ctxConfig.default_collection === 'string' ? ctxConfig.default_collection.trim() : '';\n      let ctxChanged = false;\n      let notifiedDefault = false;\n      if (!currentDefault || placeholders.has(currentDefault)) {\n        ctxConfig.default_collection = collectionName;\n        ctxChanged = true;\n        notifiedDefault = true;\n      }\n      if (ctxConfig.default_mode === undefined) {\n        ctxConfig.default_mode = 'default';\n        ctxChanged = true;\n      }\n      if (ctxConfig.require_context === undefined) {\n        ctxConfig.require_context = true;\n        ctxChanged = true;\n      }\n      if (ctxConfig.surface_qdrant_collection_hint === undefined) {\n        let surfaceHintSetting = true;\n        if (uploaderSettings) {\n          try {\n            surfaceHintSetting = !!uploaderSettings.get('surfaceQdrantCollectionHint', true);\n          } catch (error) {\n            log(`Failed to read surfaceQdrantCollectionHint from configuration: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n        ctxConfig.surface_qdrant_collection_hint = surfaceHintSetting;\n        ctxChanged = true;\n      }\n      if (ctxConfig.refrag_runtime !== decoderRuntime) {\n        ctxConfig.refrag_runtime = decoderRuntime;\n        ctxChanged = true;\n      }\n      if (decoderRuntime === 'glm') {\n        if (ctxConfig.glm_api_base === undefined) {\n          ctxConfig.glm_api_base = glmApiBase;\n          ctxChanged = true;\n        }\n        if (ctxConfig.glm_model === undefined) {\n          ctxConfig.glm_model = glmModel;\n          ctxChanged = true;\n        }\n        const existingGlmKey = typeof ctxConfig.glm_api_key === 'string' ? ctxConfig.glm_api_key.trim() : '';\n        if (glmApiKey) {\n          if (!existingGlmKey) {\n            ctxConfig.glm_api_key = glmApiKey;\n            ctxChanged = true;\n          }\n        } else if (ctxConfig.glm_api_key === undefined) {\n          ctxConfig.glm_api_key = '';\n          ctxChanged = true;\n        }\n      }\n      if (decoderRuntime === 'llamacpp') {\n        if (ctxConfig.llamacpp_model === undefined) {\n          ctxConfig.llamacpp_model = 'llamacpp-4.6';\n          ctxChanged = true;\n        }\n      }\n      if (ctxChanged) {\n        fs.writeFileSync(ctxConfigPath, JSON.stringify(ctxConfig, null, 2) + '\\n', 'utf8');\n        if (notifiedDefault) {\n          vscode.window.showInformationMessage(`Context Engine Uploader: ctx_config.json updated with default_collection=${collectionName}.`);\n        } else {\n          vscode.window.showInformationMessage('Context Engine Uploader: ctx_config.json refreshed with required defaults.');\n        }\n        log(`Wrote ctx_config.json at ${ctxConfigPath}`);\n      } else {\n        log(`ctx_config.json at ${ctxConfigPath} already satisfied required values; not modified.`);\n      }\n\n      const envPath = path.join(workspaceDir, '.env');\n      let envContent = '';\n\n      const baseDir = extensionRoot || __dirname;\n      const envExamplePath = path.join(baseDir, 'env.example');\n      if (fs.existsSync(envPath)) {\n        try {\n          envContent = fs.readFileSync(envPath, 'utf8');\n        } catch (error) {\n          log(`Failed to read existing .env at ${envPath}; skipping .env update. Error: ${error instanceof Error ? error.message : String(error)}`);\n          return;\n        }\n      } else if (fs.existsSync(envExamplePath)) {\n        try {\n          envContent = fs.readFileSync(envExamplePath, 'utf8');\n          log(`Seeding new .env for ${workspaceDir} from bundled env.example.`);\n        } catch (error) {\n          log(`Failed to read bundled env.example at ${envExamplePath}; starting with minimal .env. Error: ${error instanceof Error ? error.message : String(error)}`);\n          envContent = '';\n        }\n      }\n      let envLines = envContent ? envContent.split(/\\r?\\n/) : [];\n      let envChanged = false;\n      let collectionUpdated = false;\n\n      let idx = -1;\n      for (let i = 0; i < envLines.length; i++) {\n        if (envLines[i].trim().startsWith('COLLECTION_NAME=')) {\n          idx = i;\n          break;\n        }\n      }\n      let currentEnvVal = '';\n      if (idx >= 0) {\n        const m = envLines[idx].match(/^COLLECTION_NAME=(.*)$/);\n        if (m) {\n          currentEnvVal = (m[1] || '').trim();\n        }\n      }\n      if (idx === -1 || placeholders.has(currentEnvVal)) {\n        const newLine = `COLLECTION_NAME=${collectionName}`;\n        if (idx === -1) {\n          if (envLines.length && envLines[envLines.length - 1].trim() !== '') {\n            envLines.push('');\n          }\n          envLines.push(newLine);\n        } else {\n          envLines[idx] = newLine;\n        }\n        envChanged = true;\n        collectionUpdated = true;\n        vscode.window.showInformationMessage(`Context Engine Uploader: .env updated with COLLECTION_NAME=${collectionName}.`);\n        log(`Updated .env at ${envPath}`);\n      } else {\n        log(`.env at ${envPath} already has non-placeholder COLLECTION_NAME; not modified.`);\n      }\n\n      function getEnvEntry(key) {\n        for (let i = 0; i < envLines.length; i++) {\n          const line = envLines[i];\n          if (!line || line.trim().startsWith('#')) {\n            continue;\n          }\n          const eqIndex = line.indexOf('=');\n          if (eqIndex === -1) {\n            continue;\n          }\n          const candidate = line.slice(0, eqIndex).trim();\n          if (candidate === key) {\n            return { index: i, value: line.slice(eqIndex + 1) };\n          }\n        }\n        return { index: -1, value: undefined };\n      }\n\n      function upsertEnv(key, desiredValue, options = {}) {\n        const {\n          overwrite = false,\n          treatEmptyAsUnset = false,\n          placeholderValues = [],\n          skipIfDesiredEmpty = false\n        } = options;\n        const desired = desiredValue ?? '';\n        const desiredStr = String(desired);\n        if (!desiredStr && skipIfDesiredEmpty) {\n          return false;\n        }\n        const { index, value } = getEnvEntry(key);\n        const current = typeof value === 'string' ? value.trim() : '';\n        const normalizedDesired = desiredStr.trim();\n        const placeholderSet = new Set((placeholderValues || []).map(val => (val || '').trim().toLowerCase()));\n        let shouldUpdate = false;\n\n        if (index === -1) {\n          shouldUpdate = true;\n        } else if (overwrite) {\n          if (current !== normalizedDesired) {\n            shouldUpdate = true;\n          }\n        } else if (treatEmptyAsUnset && !current) {\n          shouldUpdate = true;\n        } else if (placeholderSet.size && placeholderSet.has(current.toLowerCase())) {\n          shouldUpdate = true;\n        }\n\n        if (!shouldUpdate) {\n          return false;\n        }\n\n        const newLine = `${key}=${desiredStr}`;\n        if (index === -1) {\n          if (envLines.length && envLines[envLines.length - 1].trim() !== '') {\n            envLines.push('');\n          }\n          envLines.push(newLine);\n        } else {\n          envLines[index] = newLine;\n        }\n        envChanged = true;\n        return true;\n      }\n\n      upsertEnv('MULTI_REPO_MODE', '1', { overwrite: true });\n      upsertEnv('REFRAG_MODE', '1', { overwrite: true });\n      upsertEnv('REFRAG_DECODER', '1', { overwrite: true });\n      upsertEnv('REFRAG_RUNTIME', decoderRuntime, { overwrite: true, placeholderValues: ['llamacpp', 'glm'] });\n      upsertEnv('USE_GPU_DECODER', useGpuDecoderSetting ? '1' : '0', { overwrite: true });\n\n      upsertEnv('REFRAG_ENCODER_MODEL', 'BAAI/bge-base-en-v1.5', { treatEmptyAsUnset: true });\n      upsertEnv('REFRAG_PHI_PATH', '/work/models/refrag_phi_768_to_dmodel.bin', { treatEmptyAsUnset: true });\n      upsertEnv('REFRAG_SENSE', 'heuristic', { treatEmptyAsUnset: true });\n\n      if (decoderRuntime === 'glm') {\n        const glmKeyPlaceholders = ['YOUR_GLM_API_KEY', '\"YOUR_GLM_API_KEY\"', \"''\", '\"\"'];\n        if (glmApiKey) {\n          upsertEnv('GLM_API_KEY', glmApiKey, {\n            treatEmptyAsUnset: true,\n            placeholderValues: glmKeyPlaceholders\n          });\n        } else {\n          upsertEnv('GLM_API_KEY', '', {});\n        }\n        upsertEnv('GLM_API_BASE', glmApiBase, { treatEmptyAsUnset: true });\n        upsertEnv('GLM_MODEL', glmModel, { treatEmptyAsUnset: true });\n      }\n\n      if (uploaderSettings) {\n        try {\n          const transportModeRaw = uploaderSettings.get('mcpTransportMode') || 'sse-remote';\n          const serverModeRaw = uploaderSettings.get('mcpServerMode') || 'bridge';\n          const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n          const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n          let targetUrl = (uploaderSettings.get('ctxIndexerUrl') || 'http://localhost:8003/mcp').trim();\n          if (serverMode === 'bridge' && transportMode === 'http') {\n            const bridgeUrl = resolveBridgeHttpUrl();\n            if (bridgeUrl) {\n              targetUrl = bridgeUrl;\n            }\n          }\n          if (targetUrl) {\n            upsertEnv('MCP_INDEXER_URL', targetUrl, { treatEmptyAsUnset: true });\n          }\n        } catch (error) {\n          log(`Failed to read ctxIndexerUrl setting for MCP_INDEXER_URL: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n\n      if (typeof gitMaxCommits === 'number' && !Number.isNaN(gitMaxCommits)) {\n        upsertEnv('REMOTE_UPLOAD_GIT_MAX_COMMITS', String(gitMaxCommits), { overwrite: true });\n      }\n      if (gitSince) {\n        upsertEnv('REMOTE_UPLOAD_GIT_SINCE', gitSince, { overwrite: true, skipIfDesiredEmpty: true });\n      }\n\n      if (envChanged) {\n        fs.writeFileSync(envPath, envLines.join('\\n') + '\\n', 'utf8');\n        log(`Ensured decoder/GLM/MCP settings in .env at ${envPath}`);\n      } else {\n        log(`.env at ${envPath} already satisfied CTX defaults; not modified.`);\n      }\n\n      void collectionUpdated;\n    } catch (error) {\n      log(`Error scaffolding ctx_config/.env: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  return {\n    writeCtxConfig,\n    inferCollectionFromUpload,\n    scaffoldCtxConfigFiles,\n    dispose,\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_dispose_16": {
      "name": "dispose",
      "type": "function",
      "start_line": 16,
      "end_line": 18,
      "content_hash": "3f55ec170f87b705347f46431905567ecd61d9ec",
      "content": "  function dispose() {\n    // Currently no timers/processes; kept for consistent manager lifecycle.\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeCtxConfig_20": {
      "name": "writeCtxConfig",
      "type": "function",
      "start_line": 20,
      "end_line": 43,
      "content_hash": "2ffb8cb03d1b0209702bdcb5b182abd46906bda6",
      "content": "  async function writeCtxConfig() {\n    const settings = getEffectiveConfig();\n    const enabled = settings.get('scaffoldCtxConfig', true);\n    if (!enabled) {\n      vscode.window.showInformationMessage('Context Engine Uploader: ctx_config/.env scaffolding is disabled (contextEngineUploader.scaffoldCtxConfig=false).');\n      log('CTX config scaffolding skipped because scaffoldCtxConfig is false.');\n      return;\n    }\n    let options = resolveOptions();\n    if (!options) {\n      return;\n    }\n    const depsOk = await ensurePythonDependencies(options.pythonPath);\n    if (!depsOk) {\n      return;\n    }\n    options = resolveOptions() || options;\n    const collectionName = inferCollectionFromUpload(options);\n    if (!collectionName) {\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to infer collection name from upload client. Check the Output panel for details.');\n      return;\n    }\n    await scaffoldCtxConfigFiles(options.targetPath, collectionName);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_inferCollectionFromUpload_45": {
      "name": "inferCollectionFromUpload",
      "type": "function",
      "start_line": 45,
      "end_line": 84,
      "content_hash": "2152769c0011abc9a842379a8fba0260faa04708",
      "content": "  function inferCollectionFromUpload(options) {\n    try {\n      const args = ['-u', options.scriptPath, '--path', options.targetPath, '--endpoint', options.endpoint, '--show-mapping'];\n      const result = spawnSync(options.pythonPath, args, {\n        cwd: options.workingDirectory,\n        env: buildChildEnv(options),\n        encoding: 'utf8'\n      });\n      if (result.error) {\n        log(`Failed to run standalone_upload_client for collection inference: ${result.error.message || String(result.error)}`);\n        return undefined;\n      }\n      const stdout = result.stdout || '';\n      const stderr = result.stderr || '';\n\n      if (stdout) {\n        log(`[ctx-config] upload client --show-mapping output:\\n${stdout}`);\n      }\n      if (stderr) {\n        log(`[ctx-config] upload client stderr:\\n${stderr}`);\n      }\n\n      const combined = `${stdout}\\n${stderr}`;\n      if (combined.trim()) {\n        const lines = combined.split(/\\r?\\n/);\n        for (const line of lines) {\n          const m = line.match(/collection_name:\\s*(.+)$/);\n          if (m && m[1]) {\n            const name = m[1].trim();\n            if (name) {\n              return name;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      log(`Error inferring collection from upload client: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    return undefined;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_scaffoldCtxConfigFiles_86": {
      "name": "scaffoldCtxConfigFiles",
      "type": "function",
      "start_line": 86,
      "end_line": 407,
      "content_hash": "70b8afdccea886b15b6b1f1790295800c5829944",
      "content": "  async function scaffoldCtxConfigFiles(workspaceDir, collectionName) {\n    try {\n      const placeholders = new Set(['', 'default-collection', 'my-collection', 'codebase']);\n\n      let uploaderSettings;\n      try {\n        uploaderSettings = getEffectiveConfig();\n      } catch (error) {\n        log(`Failed to read uploader settings: ${error instanceof Error ? error.message : String(error)}`);\n        uploaderSettings = undefined;\n      }\n\n      let decoderRuntime = 'glm';\n      let useGpuDecoderSetting = false;\n      let glmApiKey = '';\n      let glmApiBase = 'https://api.z.ai/api/coding/paas/v4/';\n      let glmModel = 'glm-4.6';\n      let gitMaxCommits = 500;\n      let gitSince = '';\n      if (uploaderSettings) {\n        try {\n          const runtimeSetting = String(uploaderSettings.get('decoderRuntime') ?? 'glm').trim().toLowerCase();\n          if (runtimeSetting === 'llamacpp') {\n            decoderRuntime = 'llamacpp';\n          }\n          useGpuDecoderSetting = !!uploaderSettings.get('useGpuDecoder', false);\n          // TODO: glmApiKey is read from settings.json (plaintext). Consider migrating API keys to VS Code SecretStorage (context.secrets) with backwards-compatible fallback.\n          const cfgKey = (uploaderSettings.get('glmApiKey') || '').trim();\n          const cfgBase = (uploaderSettings.get('glmApiBase') || '').trim();\n          const cfgModel = (uploaderSettings.get('glmModel') || '').trim();\n          if (cfgKey) {\n            glmApiKey = cfgKey;\n          }\n          if (cfgBase) {\n            glmApiBase = cfgBase;\n          }\n          if (cfgModel) {\n            glmModel = cfgModel;\n          }\n          const maxCommitsSetting = uploaderSettings.get('gitMaxCommits');\n          if (typeof maxCommitsSetting === 'number' && !Number.isNaN(maxCommitsSetting)) {\n            gitMaxCommits = maxCommitsSetting;\n          }\n          const sinceSetting = uploaderSettings.get('gitSince');\n          if (typeof sinceSetting === 'string') {\n            gitSince = sinceSetting.trim();\n          }\n        } catch (error) {\n          log(`Failed to read decoder/GLM settings from configuration: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n\n      const ctxConfigPath = path.join(workspaceDir, 'ctx_config.json');\n      let ctxConfig = {};\n      if (fs.existsSync(ctxConfigPath)) {\n        try {\n          const raw = fs.readFileSync(ctxConfigPath, 'utf8');\n          const parsed = JSON.parse(raw);\n          if (parsed && typeof parsed === 'object') {\n            ctxConfig = parsed;\n          }\n        } catch (error) {\n          log(`Failed to parse existing ctx_config.json at ${ctxConfigPath}; overwriting with minimal config. Error: ${error instanceof Error ? error.message : String(error)}`);\n          ctxConfig = {};\n        }\n      }\n      const currentDefault = typeof ctxConfig.default_collection === 'string' ? ctxConfig.default_collection.trim() : '';\n      let ctxChanged = false;\n      let notifiedDefault = false;\n      if (!currentDefault || placeholders.has(currentDefault)) {\n        ctxConfig.default_collection = collectionName;\n        ctxChanged = true;\n        notifiedDefault = true;\n      }\n      if (ctxConfig.default_mode === undefined) {\n        ctxConfig.default_mode = 'default';\n        ctxChanged = true;\n      }\n      if (ctxConfig.require_context === undefined) {\n        ctxConfig.require_context = true;\n        ctxChanged = true;\n      }\n      if (ctxConfig.surface_qdrant_collection_hint === undefined) {\n        let surfaceHintSetting = true;\n        if (uploaderSettings) {\n          try {\n            surfaceHintSetting = !!uploaderSettings.get('surfaceQdrantCollectionHint', true);\n          } catch (error) {\n            log(`Failed to read surfaceQdrantCollectionHint from configuration: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n        ctxConfig.surface_qdrant_collection_hint = surfaceHintSetting;\n        ctxChanged = true;\n      }\n      if (ctxConfig.refrag_runtime !== decoderRuntime) {\n        ctxConfig.refrag_runtime = decoderRuntime;\n        ctxChanged = true;\n      }\n      if (decoderRuntime === 'glm') {\n        if (ctxConfig.glm_api_base === undefined) {\n          ctxConfig.glm_api_base = glmApiBase;\n          ctxChanged = true;\n        }\n        if (ctxConfig.glm_model === undefined) {\n          ctxConfig.glm_model = glmModel;\n          ctxChanged = true;\n        }\n        const existingGlmKey = typeof ctxConfig.glm_api_key === 'string' ? ctxConfig.glm_api_key.trim() : '';\n        if (glmApiKey) {\n          if (!existingGlmKey) {\n            ctxConfig.glm_api_key = glmApiKey;\n            ctxChanged = true;\n          }\n        } else if (ctxConfig.glm_api_key === undefined) {\n          ctxConfig.glm_api_key = '';\n          ctxChanged = true;\n        }\n      }\n      if (decoderRuntime === 'llamacpp') {\n        if (ctxConfig.llamacpp_model === undefined) {\n          ctxConfig.llamacpp_model = 'llamacpp-4.6';\n          ctxChanged = true;\n        }\n      }\n      if (ctxChanged) {\n        fs.writeFileSync(ctxConfigPath, JSON.stringify(ctxConfig, null, 2) + '\\n', 'utf8');\n        if (notifiedDefault) {\n          vscode.window.showInformationMessage(`Context Engine Uploader: ctx_config.json updated with default_collection=${collectionName}.`);\n        } else {\n          vscode.window.showInformationMessage('Context Engine Uploader: ctx_config.json refreshed with required defaults.');\n        }\n        log(`Wrote ctx_config.json at ${ctxConfigPath}`);\n      } else {\n        log(`ctx_config.json at ${ctxConfigPath} already satisfied required values; not modified.`);\n      }\n\n      const envPath = path.join(workspaceDir, '.env');\n      let envContent = '';\n\n      const baseDir = extensionRoot || __dirname;\n      const envExamplePath = path.join(baseDir, 'env.example');\n      if (fs.existsSync(envPath)) {\n        try {\n          envContent = fs.readFileSync(envPath, 'utf8');\n        } catch (error) {\n          log(`Failed to read existing .env at ${envPath}; skipping .env update. Error: ${error instanceof Error ? error.message : String(error)}`);\n          return;\n        }\n      } else if (fs.existsSync(envExamplePath)) {\n        try {\n          envContent = fs.readFileSync(envExamplePath, 'utf8');\n          log(`Seeding new .env for ${workspaceDir} from bundled env.example.`);\n        } catch (error) {\n          log(`Failed to read bundled env.example at ${envExamplePath}; starting with minimal .env. Error: ${error instanceof Error ? error.message : String(error)}`);\n          envContent = '';\n        }\n      }\n      let envLines = envContent ? envContent.split(/\\r?\\n/) : [];\n      let envChanged = false;\n      let collectionUpdated = false;\n\n      let idx = -1;\n      for (let i = 0; i < envLines.length; i++) {\n        if (envLines[i].trim().startsWith('COLLECTION_NAME=')) {\n          idx = i;\n          break;\n        }\n      }\n      let currentEnvVal = '';\n      if (idx >= 0) {\n        const m = envLines[idx].match(/^COLLECTION_NAME=(.*)$/);\n        if (m) {\n          currentEnvVal = (m[1] || '').trim();\n        }\n      }\n      if (idx === -1 || placeholders.has(currentEnvVal)) {\n        const newLine = `COLLECTION_NAME=${collectionName}`;\n        if (idx === -1) {\n          if (envLines.length && envLines[envLines.length - 1].trim() !== '') {\n            envLines.push('');\n          }\n          envLines.push(newLine);\n        } else {\n          envLines[idx] = newLine;\n        }\n        envChanged = true;\n        collectionUpdated = true;\n        vscode.window.showInformationMessage(`Context Engine Uploader: .env updated with COLLECTION_NAME=${collectionName}.`);\n        log(`Updated .env at ${envPath}`);\n      } else {\n        log(`.env at ${envPath} already has non-placeholder COLLECTION_NAME; not modified.`);\n      }\n\n      function getEnvEntry(key) {\n        for (let i = 0; i < envLines.length; i++) {\n          const line = envLines[i];\n          if (!line || line.trim().startsWith('#')) {\n            continue;\n          }\n          const eqIndex = line.indexOf('=');\n          if (eqIndex === -1) {\n            continue;\n          }\n          const candidate = line.slice(0, eqIndex).trim();\n          if (candidate === key) {\n            return { index: i, value: line.slice(eqIndex + 1) };\n          }\n        }\n        return { index: -1, value: undefined };\n      }\n\n      function upsertEnv(key, desiredValue, options = {}) {\n        const {\n          overwrite = false,\n          treatEmptyAsUnset = false,\n          placeholderValues = [],\n          skipIfDesiredEmpty = false\n        } = options;\n        const desired = desiredValue ?? '';\n        const desiredStr = String(desired);\n        if (!desiredStr && skipIfDesiredEmpty) {\n          return false;\n        }\n        const { index, value } = getEnvEntry(key);\n        const current = typeof value === 'string' ? value.trim() : '';\n        const normalizedDesired = desiredStr.trim();\n        const placeholderSet = new Set((placeholderValues || []).map(val => (val || '').trim().toLowerCase()));\n        let shouldUpdate = false;\n\n        if (index === -1) {\n          shouldUpdate = true;\n        } else if (overwrite) {\n          if (current !== normalizedDesired) {\n            shouldUpdate = true;\n          }\n        } else if (treatEmptyAsUnset && !current) {\n          shouldUpdate = true;\n        } else if (placeholderSet.size && placeholderSet.has(current.toLowerCase())) {\n          shouldUpdate = true;\n        }\n\n        if (!shouldUpdate) {\n          return false;\n        }\n\n        const newLine = `${key}=${desiredStr}`;\n        if (index === -1) {\n          if (envLines.length && envLines[envLines.length - 1].trim() !== '') {\n            envLines.push('');\n          }\n          envLines.push(newLine);\n        } else {\n          envLines[index] = newLine;\n        }\n        envChanged = true;\n        return true;\n      }\n\n      upsertEnv('MULTI_REPO_MODE', '1', { overwrite: true });\n      upsertEnv('REFRAG_MODE', '1', { overwrite: true });\n      upsertEnv('REFRAG_DECODER', '1', { overwrite: true });\n      upsertEnv('REFRAG_RUNTIME', decoderRuntime, { overwrite: true, placeholderValues: ['llamacpp', 'glm'] });\n      upsertEnv('USE_GPU_DECODER', useGpuDecoderSetting ? '1' : '0', { overwrite: true });\n\n      upsertEnv('REFRAG_ENCODER_MODEL', 'BAAI/bge-base-en-v1.5', { treatEmptyAsUnset: true });\n      upsertEnv('REFRAG_PHI_PATH', '/work/models/refrag_phi_768_to_dmodel.bin', { treatEmptyAsUnset: true });\n      upsertEnv('REFRAG_SENSE', 'heuristic', { treatEmptyAsUnset: true });\n\n      if (decoderRuntime === 'glm') {\n        const glmKeyPlaceholders = ['YOUR_GLM_API_KEY', '\"YOUR_GLM_API_KEY\"', \"''\", '\"\"'];\n        if (glmApiKey) {\n          upsertEnv('GLM_API_KEY', glmApiKey, {\n            treatEmptyAsUnset: true,\n            placeholderValues: glmKeyPlaceholders\n          });\n        } else {\n          upsertEnv('GLM_API_KEY', '', {});\n        }\n        upsertEnv('GLM_API_BASE', glmApiBase, { treatEmptyAsUnset: true });\n        upsertEnv('GLM_MODEL', glmModel, { treatEmptyAsUnset: true });\n      }\n\n      if (uploaderSettings) {\n        try {\n          const transportModeRaw = uploaderSettings.get('mcpTransportMode') || 'sse-remote';\n          const serverModeRaw = uploaderSettings.get('mcpServerMode') || 'bridge';\n          const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n          const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n          let targetUrl = (uploaderSettings.get('ctxIndexerUrl') || 'http://localhost:8003/mcp').trim();\n          if (serverMode === 'bridge' && transportMode === 'http') {\n            const bridgeUrl = resolveBridgeHttpUrl();\n            if (bridgeUrl) {\n              targetUrl = bridgeUrl;\n            }\n          }\n          if (targetUrl) {\n            upsertEnv('MCP_INDEXER_URL', targetUrl, { treatEmptyAsUnset: true });\n          }\n        } catch (error) {\n          log(`Failed to read ctxIndexerUrl setting for MCP_INDEXER_URL: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n\n      if (typeof gitMaxCommits === 'number' && !Number.isNaN(gitMaxCommits)) {\n        upsertEnv('REMOTE_UPLOAD_GIT_MAX_COMMITS', String(gitMaxCommits), { overwrite: true });\n      }\n      if (gitSince) {\n        upsertEnv('REMOTE_UPLOAD_GIT_SINCE', gitSince, { overwrite: true, skipIfDesiredEmpty: true });\n      }\n\n      if (envChanged) {\n        fs.writeFileSync(envPath, envLines.join('\\n') + '\\n', 'utf8');\n        log(`Ensured decoder/GLM/MCP settings in .env at ${envPath}`);\n      } else {\n        log(`.env at ${envPath} already satisfied CTX defaults; not modified.`);\n      }\n\n      void collectionUpdated;\n    } catch (error) {\n      log(`Error scaffolding ctx_config/.env: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getEnvEntry_279": {
      "name": "getEnvEntry",
      "type": "function",
      "start_line": 279,
      "end_line": 295,
      "content_hash": "ea4946e0044e8f6d83dfca7bb8ffe1a246404495",
      "content": "      function getEnvEntry(key) {\n        for (let i = 0; i < envLines.length; i++) {\n          const line = envLines[i];\n          if (!line || line.trim().startsWith('#')) {\n            continue;\n          }\n          const eqIndex = line.indexOf('=');\n          if (eqIndex === -1) {\n            continue;\n          }\n          const candidate = line.slice(0, eqIndex).trim();\n          if (candidate === key) {\n            return { index: i, value: line.slice(eqIndex + 1) };\n          }\n        }\n        return { index: -1, value: undefined };\n      }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_upsertEnv_297": {
      "name": "upsertEnv",
      "type": "function",
      "start_line": 297,
      "end_line": 342,
      "content_hash": "54939533cea3f459edb4ec9b1f907844c7f8536b",
      "content": "      function upsertEnv(key, desiredValue, options = {}) {\n        const {\n          overwrite = false,\n          treatEmptyAsUnset = false,\n          placeholderValues = [],\n          skipIfDesiredEmpty = false\n        } = options;\n        const desired = desiredValue ?? '';\n        const desiredStr = String(desired);\n        if (!desiredStr && skipIfDesiredEmpty) {\n          return false;\n        }\n        const { index, value } = getEnvEntry(key);\n        const current = typeof value === 'string' ? value.trim() : '';\n        const normalizedDesired = desiredStr.trim();\n        const placeholderSet = new Set((placeholderValues || []).map(val => (val || '').trim().toLowerCase()));\n        let shouldUpdate = false;\n\n        if (index === -1) {\n          shouldUpdate = true;\n        } else if (overwrite) {\n          if (current !== normalizedDesired) {\n            shouldUpdate = true;\n          }\n        } else if (treatEmptyAsUnset && !current) {\n          shouldUpdate = true;\n        } else if (placeholderSet.size && placeholderSet.has(current.toLowerCase())) {\n          shouldUpdate = true;\n        }\n\n        if (!shouldUpdate) {\n          return false;\n        }\n\n        const newLine = `${key}=${desiredStr}`;\n        if (index === -1) {\n          if (envLines.length && envLines[envLines.length - 1].trim() !== '') {\n            envLines.push('');\n          }\n          envLines.push(newLine);\n        } else {\n          envLines[index] = newLine;\n        }\n        envChanged = true;\n        return true;\n      }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}