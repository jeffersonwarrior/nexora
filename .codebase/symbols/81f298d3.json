{
  "file_path": "/work/internal/agent/state/machine_test.go",
  "file_hash": "f679f2113620eaba2cc2ccc0ac93ad3206042b6a",
  "updated_at": "2025-12-26T17:34:20.370497",
  "symbols": {
    "function_TestStateTransitions_11": {
      "name": "TestStateTransitions",
      "type": "function",
      "start_line": 11,
      "end_line": 54,
      "content_hash": "5c8a12605396f0d3d55ebe1f3e3c2a06f54776d2",
      "content": "func TestStateTransitions(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tfrom      AgentState\n\t\tto        AgentState\n\t\twantValid bool\n\t}{\n\t\t{\"Idle to Processing\", StateIdle, StateProcessingPrompt, true},\n\t\t{\"Processing to Streaming\", StateProcessingPrompt, StateStreamingResponse, true},\n\t\t{\"Streaming to Executing\", StateStreamingResponse, StateExecutingTool, true},\n\t\t{\"Executing to Streaming\", StateExecutingTool, StateStreamingResponse, true},\n\t\t{\"Streaming to ProgressCheck\", StateStreamingResponse, StateProgressCheck, true},\n\t\t{\"ProgressCheck to PhaseTransition\", StateProgressCheck, StatePhaseTransition, true},\n\t\t{\"PhaseTransition to Processing\", StatePhaseTransition, StateProcessingPrompt, true},\n\n\t\t// Invalid transitions\n\t\t{\"Idle to Executing\", StateIdle, StateExecutingTool, false},\n\t\t{\"Halted to anything\", StateHalted, StateProcessingPrompt, false},\n\t\t{\"Processing to PhaseTransition\", StateProcessingPrompt, StatePhaseTransition, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tsm := NewStateMachine(Config{\n\t\t\t\tSessionID: \"test\",\n\t\t\t\tContext:   context.Background(),\n\t\t\t})\n\n\t\t\t// Set initial state (bypass validation for test setup)\n\t\t\tsm.mu.Lock()\n\t\t\tsm.currentState = tt.from\n\t\t\tsm.mu.Unlock()\n\n\t\t\terr := sm.TransitionTo(tt.to)\n\t\t\tif tt.wantValid && err != nil {\n\t\t\t\tt.Errorf(\"expected valid transition, got error: %v\", err)\n\t\t\t}\n\t\t\tif !tt.wantValid && err == nil {\n\t\t\t\tt.Errorf(\"expected invalid transition, got no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProgressTrackerLoop_55": {
      "name": "TestProgressTrackerLoop",
      "type": "function",
      "start_line": 55,
      "end_line": 72,
      "content_hash": "1e24e27914e239822a93ac1f3ec8b0151586743f",
      "content": "func TestProgressTrackerLoop(t *testing.T) {\n\tpt := NewProgressTracker()\n\n\t// Simulate same file, same error, 5 times (new threshold)\n\tfor i := 0; i < 5; i++ {\n\t\tpt.RecordAction(\"edit\", \"test.go\", \"\", \"old_string not found\", false)\n\t}\n\n\tstuck, reason := pt.IsStuck()\n\tif !stuck {\n\t\tt.Error(\"expected stuck condition after 5 identical errors\")\n\t}\n\tif reason == \"\" {\n\t\tt.Error(\"expected reason for stuck condition\")\n\t}\n\tt.Logf(\"Stuck detected: %s\", reason)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProgressTrackerNoLoopOnProgress_73": {
      "name": "TestProgressTrackerNoLoopOnProgress",
      "type": "function",
      "start_line": 73,
      "end_line": 88,
      "content_hash": "9db9a1b493d0b1527be2838ab7b0a4934c3631ed",
      "content": "func TestProgressTrackerNoLoopOnProgress(t *testing.T) {\n\tpt := NewProgressTracker()\n\n\t// Simulate productive work: different files, successes\n\tfiles := []string{\"a.go\", \"b.go\", \"c.go\", \"d.go\", \"e.go\"}\n\tfor i := 0; i < 100; i++ {\n\t\tfile := files[i%len(files)]\n\t\tpt.RecordAction(\"edit\", file, \"\", \"\", true)\n\t}\n\n\tstuck, _ := pt.IsStuck()\n\tif stuck {\n\t\tt.Error(\"expected no stuck condition with productive work\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProgressTrackerOscillation_89": {
      "name": "TestProgressTrackerOscillation",
      "type": "function",
      "start_line": 89,
      "end_line": 107,
      "content_hash": "361dc9fb9742de50ceb1575a078ec256300ed860",
      "content": "func TestProgressTrackerOscillation(t *testing.T) {\n\tpt := NewProgressTracker()\n\n\t// Simulate A->B->A->B pattern\n\tfor i := 0; i < 4; i++ {\n\t\tif i%2 == 0 {\n\t\t\tpt.RecordAction(\"edit\", \"a.go\", \"\", \"\", false)\n\t\t} else {\n\t\t\tpt.RecordAction(\"edit\", \"b.go\", \"\", \"\", false)\n\t\t}\n\t}\n\n\tstuck, reason := pt.IsStuck()\n\tif !stuck {\n\t\tt.Error(\"expected stuck condition for oscillation\")\n\t}\n\tt.Logf(\"Oscillation detected: %s\", reason)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMessageDeduplication_108": {
      "name": "TestMessageDeduplication",
      "type": "function",
      "start_line": 108,
      "end_line": 131,
      "content_hash": "d577bcb71d91952c0c3803eaca0e69a3efb63b5b",
      "content": "func TestMessageDeduplication(t *testing.T) {\n\tpt := NewProgressTracker()\n\n\tmsg := \"same message repeated\"\n\n\t// First time - not a duplicate\n\tdup := pt.RecordMessage(msg)\n\tif dup {\n\t\tt.Error(\"first message should not be duplicate\")\n\t}\n\n\t// Second time - duplicate\n\tdup = pt.RecordMessage(msg)\n\tif !dup {\n\t\tt.Error(\"second identical message should be duplicate\")\n\t}\n\n\t// Different message - not duplicate\n\tdup = pt.RecordMessage(\"different message\")\n\tif dup {\n\t\tt.Error(\"different message should not be duplicate\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProgressReset_132": {
      "name": "TestProgressReset",
      "type": "function",
      "start_line": 132,
      "end_line": 163,
      "content_hash": "b37e23f6334e9ab6575940b34e4ec47de99ba2fa",
      "content": "func TestProgressReset(t *testing.T) {\n\tpt := NewProgressTracker()\n\n\t// Create error history\n\t// Record 5 identical errors (new threshold)\n\tfor i := 0; i < 5; i++ {\n\t\tpt.RecordAction(\"edit\", \"test.go\", \"\", \"error\", false)\n\t}\n\n\t// Should be stuck\n\tstuck, _ := pt.IsStuck()\n\tif !stuck {\n\t\tt.Error(\"expected stuck before reset\")\n\t}\n\n\t// Reset\n\tpt.Reset()\n\n\t// Should not be stuck after reset\n\tstuck, _ = pt.IsStuck()\n\tif stuck {\n\t\tt.Error(\"expected not stuck after reset\")\n\t}\n\n\t// File modifications should be preserved\n\tpt.RecordFileModification(\"test.go\", \"hash123\")\n\tpt.Reset()\n\tif len(pt.filesModified) == 0 {\n\t\tt.Error(\"file modifications should be preserved after reset\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPhaseContext_164": {
      "name": "TestPhaseContext",
      "type": "function",
      "start_line": 164,
      "end_line": 202,
      "content_hash": "2491763c190b7e7e329294fc0f7871ae2c07507b",
      "content": "func TestPhaseContext(t *testing.T) {\n\tpc := NewPhaseContext(10)\n\n\t// Start phase 1\n\tpc.StartPhase(1, \"Refactor package A\", 15*time.Minute)\n\n\tinfo := pc.GetCurrentPhaseInfo()\n\tif info.PhaseNumber != 1 {\n\t\tt.Errorf(\"expected phase 1, got %d\", info.PhaseNumber)\n\t}\n\tif info.Description != \"Refactor package A\" {\n\t\tt.Errorf(\"unexpected description: %s\", info.Description)\n\t}\n\n\t// Record some progress\n\tpc.RecordFileChange(\"a.go\")\n\tpc.RecordFileChange(\"b.go\")\n\tpc.MarkTestsPassed(true)\n\n\tinfo = pc.GetCurrentPhaseInfo()\n\tif info.FilesChanged != 2 {\n\t\tt.Errorf(\"expected 2 files changed, got %d\", info.FilesChanged)\n\t}\n\tif !info.TestsPassed {\n\t\tt.Error(\"expected tests passed\")\n\t}\n\n\t// Complete phase\n\tpc.CompletePhase(true)\n\n\tprogress := pc.GetTotalProgress()\n\tif progress.CompletedPhases != 1 {\n\t\tt.Errorf(\"expected 1 completed phase, got %d\", progress.CompletedPhases)\n\t}\n\tif progress.SuccessfulPhases != 1 {\n\t\tt.Errorf(\"expected 1 successful phase, got %d\", progress.SuccessfulPhases)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestStateMachineWithPhases_203": {
      "name": "TestStateMachineWithPhases",
      "type": "function",
      "start_line": 203,
      "end_line": 246,
      "content_hash": "ddacb9c65086f11f2c4c88a891517ae77f1db535",
      "content": "func TestStateMachineWithPhases(t *testing.T) {\n\tsm := NewStateMachine(Config{\n\t\tSessionID:   \"test-session\",\n\t\tContext:     context.Background(),\n\t\tTotalPhases: 3,\n\t})\n\n\t// Start phase 1\n\terr := sm.StartPhase(1, \"Phase 1\", 10*time.Minute)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start phase: %v\", err)\n\t}\n\n\tif sm.GetState() != StatePhaseTransition {\n\t\tt.Errorf(\"expected StatePhaseTransition, got %s\", sm.GetState())\n\t}\n\n\t// Record some work\n\tsm.RecordToolCall(\"edit\", \"test.go\", \"\", \"\", true)\n\tsm.RecordToolCall(\"bash\", \"\", \"go test\", \"\", true)\n\tsm.RecordTest(\"go test\", true, \"PASS\")\n\n\t// Don't manually complete - StartPhase for phase 2 will auto-complete phase 1\n\n\t// Start phase 2 (progress should reset)\n\terr = sm.StartPhase(2, \"Phase 2\", 10*time.Minute)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start phase 2: %v\", err)\n\t}\n\n\tstats := sm.GetProgress()\n\tif stats.ConsecutiveErrors != 0 {\n\t\tt.Errorf(\"expected errors reset after phase transition, got %d\", stats.ConsecutiveErrors)\n\t}\n\n\tprogress := sm.GetTotalProgress()\n\tif progress.CompletedPhases != 1 {\n\t\tt.Errorf(\"expected 1 completed phase, got %d\", progress.CompletedPhases)\n\t}\n\tif progress.CurrentPhase != 2 {\n\t\tt.Errorf(\"expected current phase 2, got %d\", progress.CurrentPhase)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestStateMachineCallbacks_247": {
      "name": "TestStateMachineCallbacks",
      "type": "function",
      "start_line": 247,
      "end_line": 324,
      "content_hash": "0248e3ebeaa53f3f666ffc18cdc77a31d7facd2e",
      "content": "func TestStateMachineCallbacks(t *testing.T) {\n\tvar (\n\t\tstateChanges   int\n\t\tstuckCalled    bool\n\t\tprogressCalled bool\n\t\tmu             sync.Mutex\n\t)\n\n\tsm := NewStateMachine(Config{\n\t\tSessionID: \"test\",\n\t\tContext:   context.Background(),\n\t\tOnStateChange: func(from, to AgentState) {\n\t\t\tmu.Lock()\n\t\t\tstateChanges++\n\t\t\tmu.Unlock()\n\t\t},\n\t\tOnStuck: func(reason string) {\n\t\t\tmu.Lock()\n\t\t\tstuckCalled = true\n\t\t\tmu.Unlock()\n\t\t},\n\t\tOnProgress: func(stats ProgressStats) {\n\t\t\tmu.Lock()\n\t\t\tprogressCalled = true\n\t\t\tmu.Unlock()\n\t\t},\n\t})\n\n\t// Trigger state change\n\terr := sm.TransitionTo(StateProcessingPrompt)\n\tif err != nil {\n\t\tt.Fatalf(\"transition failed: %v\", err)\n\t}\n\n\t// Give callback time to execute\n\ttime.Sleep(10 * time.Millisecond)\n\n\tmu.Lock()\n\tsc := stateChanges\n\tmu.Unlock()\n\n\tif sc == 0 {\n\t\tt.Error(\"expected state change callback to be called\")\n\t}\n\n\t// Trigger stuck condition (5 errors needed now)\n\tfor i := 0; i < 5; i++ {\n\t\tsm.RecordToolCall(\"edit\", \"test.go\", \"\", \"same error\", false)\n\t}\n\n\t// Give callback time to execute\n\ttime.Sleep(10 * time.Millisecond)\n\n\tmu.Lock()\n\tstuck := stuckCalled\n\tmu.Unlock()\n\n\tif !stuck {\n\t\tt.Error(\"expected stuck callback to be called\")\n\t}\n\n\t// Trigger progress callback (every 10 calls)\n\tfor i := 0; i < 10; i++ {\n\t\tsm.RecordToolCall(\"edit\", \"file.go\", \"\", \"\", true)\n\t}\n\n\t// Give callback time to execute\n\ttime.Sleep(10 * time.Millisecond)\n\n\tmu.Lock()\n\tprog := progressCalled\n\tmu.Unlock()\n\n\tif !prog {\n\t\tt.Error(\"expected progress callback to be called\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestStateMachineLongRunningTask_325": {
      "name": "TestStateMachineLongRunningTask",
      "type": "function",
      "start_line": 325,
      "end_line": 381,
      "content_hash": "760a069140d6ea0384a818f2f506ae3c89d84c2d",
      "content": "func TestStateMachineLongRunningTask(t *testing.T) {\n\tsm := NewStateMachine(Config{\n\t\tSessionID:   \"long-task\",\n\t\tContext:     context.Background(),\n\t\tTotalPhases: 10,\n\t})\n\n\t// Simulate 10-phase refactor with 1000 tool calls\n\tfor phase := 1; phase <= 10; phase++ {\n\t\terr := sm.StartPhase(phase, fmt.Sprintf(\"Phase %d\", phase), 15*time.Minute)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to start phase %d: %v\", phase, err)\n\t\t}\n\n\t\t// Simulate 100 tool calls per phase (1000 total)\n\t\tfor call := 0; call < 100; call++ {\n\t\t\tfileName := fmt.Sprintf(\"file_%d_%d.go\", phase, call)\n\t\t\tsm.RecordToolCall(\"edit\", fileName, \"\", \"\", true)\n\t\t}\n\n\t\t// Mark tests passed\n\t\tsm.RecordTest(\"go test ./...\", true, \"PASS\")\n\n\t\t// Note: Don't manually call CompletePhase - it will be auto-called\n\t\t// when starting the next phase (or can be called at the very end)\n\n\t\t// Should not be stuck (making progress)\n\t\tstuck, reason := sm.IsStuck()\n\t\tif stuck {\n\t\t\tt.Errorf(\"phase %d: unexpected stuck condition: %s\", phase, reason)\n\t\t}\n\t}\n\n\t// Manually complete the last phase\n\terr := sm.CompletePhase(true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to complete final phase: %v\", err)\n\t}\n\n\t// Verify final state\n\tprogress := sm.GetTotalProgress()\n\tif progress.CompletedPhases != 10 {\n\t\tt.Errorf(\"expected 10 completed phases, got %d\", progress.CompletedPhases)\n\t}\n\tif progress.SuccessfulPhases != 10 {\n\t\tt.Errorf(\"expected 10 successful phases, got %d\", progress.SuccessfulPhases)\n\t}\n\n\ttoolCalls := sm.GetToolCallCount()\n\tif toolCalls != 1000 {\n\t\tt.Errorf(\"expected 1000 tool calls, got %d\", toolCalls)\n\t}\n\n\tt.Logf(\"\u2705 Successfully completed 10-phase refactor with %d tool calls in %v\",\n\t\ttoolCalls, sm.GetElapsedTime())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestStateMachineStuckDetection_382": {
      "name": "TestStateMachineStuckDetection",
      "type": "function",
      "start_line": 382,
      "end_line": 405,
      "content_hash": "d44deaa92c6602fc01da1d03bb1d973276728ed4",
      "content": "func TestStateMachineStuckDetection(t *testing.T) {\n\tsm := NewStateMachine(Config{\n\t\tSessionID: \"stuck-test\",\n\t\tContext:   context.Background(),\n\t})\n\n\t// Simulate stuck loop: same error 5 times (new threshold)\n\tfor i := 0; i < 5; i++ {\n\t\tsm.RecordToolCall(\"edit\", \"stuck.go\", \"\", \"old_string not found\", false)\n\t}\n\n\tstuck, reason := sm.IsStuck()\n\tif !stuck {\n\t\tt.Error(\"expected stuck condition after 5 identical errors\")\n\t}\n\tt.Logf(\"\u2705 Stuck detected: %s\", reason)\n\n\t// Verify we can continue after recovery\n\tsm.progressTracker.Reset()\n\tstuck, _ = sm.IsStuck()\n\tif stuck {\n\t\tt.Error(\"expected not stuck after reset\")\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}