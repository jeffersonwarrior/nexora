{
  "file_path": "/work/.local/tools/modelscan/config/agent_env.go",
  "file_hash": "020c18c66b2b170ccb9ece6b5054c0422094095f",
  "updated_at": "2025-12-26T17:34:20.100243",
  "symbols": {
    "function_LoadFromAgentEnv_9": {
      "name": "LoadFromAgentEnv",
      "type": "function",
      "start_line": 9,
      "end_line": 89,
      "content_hash": "ec2582b64a01f5e580603ac9781ee381e2bace92",
      "content": "func LoadFromAgentEnv(config *Config) error {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn nil // It's okay if we can't find the file\n\t}\n\n\t// Parse the tab-delimited format\n\tlines := strings.Split(string(data), \"\\n\")\n\t// Skip header line\n\tfor i, line := range lines {\n\t\tif i == 0 || line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Split by tab\n\t\tparts := strings.Split(line, \"\\t\")\n\t\tif len(parts) < 5 {\n\t\t\tcontinue\n\t\t}\n\n\t\tkeyName := parts[0]\n\t\tcategory := parts[1]\n\t\tapiKey := strings.TrimSpace(parts[2])\n\n\t\t// Only process LLM/Search providers for ModelScan\n\t\tif category != \"LLM\" && category != \"LLM Router\" && category != \"Search\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip keys that are empty or just descriptive\n\t\tif apiKey == \"\" || strings.Contains(apiKey, \"\u2192\") || strings.Contains(apiKey, \" \") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Map to provider names\n\t\tproviderName := getProviderNameFromKeyName(keyName)\n\t\tif providerName == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create provider config\n\t\tproviderConfig := ProviderConfig{\n\t\t\tAPIKey:      apiKey,\n\t\t\tDescription: \"From agent.env\",\n\t\t}\n\n\t\t// Set proper endpoints\n\t\tswitch providerName {\n\t\tcase \"mistral\":\n\t\t\tproviderConfig.Endpoint = \"https://api.mistral.ai/v1\"\n\t\tcase \"openai\":\n\t\t\tproviderConfig.Endpoint = \"https://api.openai.com/v1\"\n\t\tcase \"anthropic\":\n\t\t\tproviderConfig.Endpoint = \"https://api.anthropic.com/v1\"\n\t\tcase \"xai\":\n\t\t\tproviderConfig.Endpoint = \"https://api.x.ai/v1\"\n\t\tcase \"cerebras\":\n\t\t\tproviderConfig.Endpoint = \"https://api.cerebras.ai/v1\"\n\t\tcase \"akashiverse\":\n\t\t\tproviderConfig.Endpoint = \"https://api.akashiverse.ai/v1\"\n\t\tcase \"perplexity\":\n\t\t\tproviderConfig.Endpoint = \"https://api.perplexity.ai/v1\"\n\t\tcase \"openrouter\":\n\t\t\tproviderConfig.Endpoint = \"https://openrouter.ai/api/v1\"\n\t\tcase \"gemini\":\n\t\t\tproviderConfig.Endpoint = \"https://generativelanguage.googleapis.com/v1\"\n\t\tcase \"firecrawl\":\n\t\t\tproviderConfig.Endpoint = \"https://api.firecrawl.dev/v1\"\n\t\t}\n\n\t\t// Only save if we don't already have a key from NEXORA\n\t\tif _, exists := config.Providers[providerName]; !exists {\n\t\t\tconfig.Providers[providerName] = providerConfig\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// getProviderNameFromKeyName maps key names to provider identifiers",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getProviderNameFromKeyName_90": {
      "name": "getProviderNameFromKeyName",
      "type": "function",
      "start_line": 90,
      "end_line": 147,
      "content_hash": "4f9f7865fe4aaf022cb0f5822fc1827a25fa11dc",
      "content": "func getProviderNameFromKeyName(keyName string) string {\n\tkeyMap := map[string]string{\n\t\t\"Mistral API Key\":                     \"mistral\",\n\t\t\"OpenAI service account key\":          \"openai\",\n\t\t\"OpenAI\":                              \"openai\",\n\t\t\"xAI API Key\":                         \"xai\",\n\t\t\"xAI API Key 3\":                       \"xai\",\n\t\t\"xAI API Key 4\":                       \"xai\",\n\t\t\"Anthropic API Key\":                   \"anthropic\",\n\t\t\"Anthropic OAuth Token \u2014 Claude Code\": \"anthropic\",\n\t\t\"Cere\":                                \"cerebras\",\n\t\t\"Cere max\":                            \"cerebras\",\n\t\t\"Akashiverse\":                         \"akashiverse\",\n\t\t\"Perplexity API Key\":                  \"perplexity\",\n\t\t\"Perplexity API Key 1\":                \"perplexity\",\n\t\t\"Perplexity API Key 2\":                \"perplexity\",\n\t\t\"OpenRouter API Key\":                  \"openrouter\",\n\t\t\"Firecrawl\":                           \"firecrawl\",\n\t\t\"Exa API Key 1\":                       \"exa\",\n\t\t\"Exa API Key 2\":                       \"exa\",\n\t\t\"Google\":                              \"gemini\",\n\t\t\"Vibe API Key\":                        \"vibe\",\n\t}\n\n\t// Handle numbered keys e.g., \"xAI API Key 3\"\n\tkeyBase := strings.TrimSuffix(keyName, \"1\")\n\tkeyBase = strings.TrimSuffix(keyBase, \"2\")\n\tkeyBase = strings.TrimSuffix(keyBase, \"3\")\n\tkeyBase = strings.TrimSuffix(keyBase, \"4\")\n\n\t// Remove double spaces\n\tkeyBase = strings.ReplaceAll(keyBase, \"  \", \" \")\n\n\tif provider, ok := keyMap[keyBase]; ok {\n\t\treturn provider\n\t}\n\n\t// Try exact match\n\tif provider, ok := keyMap[keyName]; ok {\n\t\treturn provider\n\t}\n\n\t// Extract from known patterns\n\tif strings.Contains(strings.ToLower(keyName), \"gemini\") {\n\t\treturn \"gemini\"\n\t}\n\tif strings.Contains(strings.ToLower(keyName), \"anthropic\") ||\n\t\tstrings.Contains(strings.ToLower(keyName), \"claude\") {\n\t\treturn \"anthropic\"\n\t}\n\tif strings.Contains(strings.ToLower(keyName), \"cere\") {\n\t\treturn \"cerebras\"\n\t}\n\n\treturn \"\"\n}\n\n// extractFromGamma extracts Gamma API key from file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFromGamma_148": {
      "name": "extractFromGamma",
      "type": "function",
      "start_line": 148,
      "end_line": 173,
      "content_hash": "a36eef6fa8b08d16dc94a670491315696cee4818",
      "content": "func extractFromGamma(config *Config) {\n\t// Look for gamma key in the agent env\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"sk-gamma-\") {\n\t\t\t// Extract the key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tgammaKey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"gamma\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      gammaKey,\n\t\t\t\t\tDescription: \"Gamma from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.gamma.ai/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractFromManus extracts Manus API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFromManus_174": {
      "name": "extractFromManus",
      "type": "function",
      "start_line": 174,
      "end_line": 199,
      "content_hash": "90b9c75b5d25a2465851b30c9a872d2104c1826c",
      "content": "func extractFromManus(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Manus\") && strings.Contains(line, \"sk-\") {\n\t\t\t// Extract Manus key\n\t\t\t// Manus uses OpenAI-compatible API\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tmanusKey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"manus\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      manusKey,\n\t\t\t\t\tDescription: \"Manus from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.manus.ai/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractFromLlamaIndex extracts LlamaIndex API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFromLlamaIndex_200": {
      "name": "extractFromLlamaIndex",
      "type": "function",
      "start_line": 200,
      "end_line": 224,
      "content_hash": "1ed208d55122c1aa62c5a23859708425c9bf842d",
      "content": "func extractFromLlamaIndex(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Llamaindex\") && strings.Contains(line, \"llx-\") {\n\t\t\t// Extract key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"llamaindex\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"Llamaindex from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.llamaindex.ai/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractFromNanoGPT extracts NanoGPT API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFromNanoGPT_225": {
      "name": "extractFromNanoGPT",
      "type": "function",
      "start_line": 225,
      "end_line": 249,
      "content_hash": "92b03863fc333acb46cb2524131cfd470825bd76",
      "content": "func extractFromNanoGPT(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Nano GPT\") {\n\t\t\t// Extract key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"nanogpt\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"NanoGPT from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.nanogpt.ai/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractYouCom extracts You.com API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractYouCom_250": {
      "name": "extractYouCom",
      "type": "function",
      "start_line": 250,
      "end_line": 274,
      "content_hash": "187048cf960891af58bd5bee6e38d269364de27e",
      "content": "func extractYouCom(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"You.com\") && strings.Contains(line, \"ydc-sk-\") {\n\t\t\t// Extract key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"you\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"You.com from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.you.com/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractMinimax extracts Minimax API key (JWT type)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractMinimax_275": {
      "name": "extractMinimax",
      "type": "function",
      "start_line": 275,
      "end_line": 299,
      "content_hash": "b0c75dd2ad6e81b3bd199bfaa9911b80d5e2b956",
      "content": "func extractMinimax(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Minimax API Key\") && strings.Contains(line, \"eyJ\") {\n\t\t\t// Extract key (it's a JWT)\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"minimax\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"Minimax from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.minimax.chat/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractKimiForCoding extracts Kimi coding API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractKimiForCoding_300": {
      "name": "extractKimiForCoding",
      "type": "function",
      "start_line": 300,
      "end_line": 324,
      "content_hash": "d6eec58973770275e831edf45ba92f63e62b20ef",
      "content": "func extractKimiForCoding(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Kimi for Coding\") {\n\t\t\t// Extract key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"kimi\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"Kimi for Coding from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.moonshot.cn/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// extractFromVibe extracts Vibe API key",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFromVibe_325": {
      "name": "extractFromVibe",
      "type": "function",
      "start_line": 325,
      "end_line": 347,
      "content_hash": "02cf8ad35a768ca2bf0c193431afd50e399c7a35",
      "content": "func extractFromVibe(config *Config) {\n\tenvPath := \"/home/agent/.env\"\n\tdata, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"Vibe API Key\") {\n\t\t\t// Extract key\n\t\t\tparts := strings.Split(line, \"\\t\")\n\t\t\tif len(parts) >= 3 {\n\t\t\t\tkey := strings.TrimSpace(parts[2])\n\t\t\t\tconfig.Providers[\"vibe\"] = ProviderConfig{\n\t\t\t\t\tAPIKey:      key,\n\t\t\t\t\tDescription: \"Vibe from agent.env\",\n\t\t\t\t\tEndpoint:    \"https://api.vibe-llm.online/v1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}