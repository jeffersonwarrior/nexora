{
  "file_path": "/work/internal/shell/command_block_test.go",
  "file_hash": "cb479127f2fc0bce199e1f0b5da2276d6b4b6880",
  "updated_at": "2025-12-26T17:34:23.256227",
  "symbols": {
    "function_TestCommandBlocking_10": {
      "name": "TestCommandBlocking",
      "type": "function",
      "start_line": 10,
      "end_line": 112,
      "content_hash": "3d5e03cc58887ae48c01370f33b5736b8d6de6fa",
      "content": "func TestCommandBlocking(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tblockFuncs  []BlockFunc\n\t\tcommand     string\n\t\tshouldBlock bool\n\t}{\n\t\t{\n\t\t\tname: \"block simple command\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tfunc(args []string) bool {\n\t\t\t\t\treturn len(args) > 0 && args[0] == \"curl\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tcommand:     \"curl https://example.com\",\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname: \"allow non-blocked command\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tfunc(args []string) bool {\n\t\t\t\t\treturn len(args) > 0 && args[0] == \"curl\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tcommand:     \"echo hello\",\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname: \"block subcommand\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tfunc(args []string) bool {\n\t\t\t\t\treturn len(args) >= 2 && args[0] == \"brew\" && args[1] == \"install\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tcommand:     \"brew install wget\",\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname: \"allow different subcommand\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tfunc(args []string) bool {\n\t\t\t\t\treturn len(args) >= 2 && args[0] == \"brew\" && args[1] == \"install\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tcommand:     \"brew list\",\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname: \"block npm global install with -g\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tArgumentsBlocker(\"npm\", []string{\"install\"}, []string{\"-g\"}),\n\t\t\t},\n\t\t\tcommand:     \"npm install -g typescript\",\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname: \"block npm global install with --global\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tArgumentsBlocker(\"npm\", []string{\"install\"}, []string{\"--global\"}),\n\t\t\t},\n\t\t\tcommand:     \"npm install --global typescript\",\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname: \"allow npm local install\",\n\t\t\tblockFuncs: []BlockFunc{\n\t\t\t\tArgumentsBlocker(\"npm\", []string{\"install\"}, []string{\"-g\"}),\n\t\t\t\tArgumentsBlocker(\"npm\", []string{\"install\"}, []string{\"--global\"}),\n\t\t\t},\n\t\t\tcommand:     \"npm install typescript\",\n\t\t\tshouldBlock: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Create a temporary directory for each test\n\t\t\ttmpDir := t.TempDir()\n\n\t\t\tshell := NewShell(&Options{\n\t\t\t\tWorkingDir: tmpDir,\n\t\t\t\tBlockFuncs: tt.blockFuncs,\n\t\t\t})\n\n\t\t\t_, _, err := shell.Exec(t.Context(), tt.command)\n\n\t\t\tif tt.shouldBlock {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected command to be blocked, but it was allowed\")\n\t\t\t\t} else if !strings.Contains(err.Error(), \"not allowed for security reasons\") {\n\t\t\t\t\tt.Errorf(\"Expected security error, got: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For non-blocked commands, we might get other errors (like command not found)\n\t\t\t\t// but we shouldn't get the security error\n\t\t\t\tif err != nil && strings.Contains(err.Error(), \"not allowed for security reasons\") {\n\t\t\t\t\tt.Errorf(\"Command was unexpectedly blocked: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestArgumentsBlocker_113": {
      "name": "TestArgumentsBlocker",
      "type": "function",
      "start_line": 113,
      "end_line": 262,
      "content_hash": "73607eab3053e6754c088dde8836eb577b592df9",
      "content": "func TestArgumentsBlocker(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tcmd         string\n\t\targs        []string\n\t\tflags       []string\n\t\tinput       []string\n\t\tshouldBlock bool\n\t}{\n\t\t// Basic command blocking\n\t\t{\n\t\t\tname:        \"block exact command match\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"npm\", \"install\", \"package\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow different command\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"yarn\", \"install\", \"package\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow different subcommand\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"npm\", \"list\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\n\t\t// Flag-based blocking\n\t\t{\n\t\t\tname:        \"block with single flag\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       []string{\"-g\"},\n\t\t\tinput:       []string{\"npm\", \"install\", \"-g\", \"typescript\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"block with flag in different position\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       []string{\"-g\"},\n\t\t\tinput:       []string{\"npm\", \"install\", \"typescript\", \"-g\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow without required flag\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       []string{\"-g\"},\n\t\t\tinput:       []string{\"npm\", \"install\", \"typescript\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"block with multiple flags\",\n\t\t\tcmd:         \"pip\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       []string{\"--user\"},\n\t\t\tinput:       []string{\"pip\", \"install\", \"--user\", \"--upgrade\", \"package\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\n\t\t// Complex argument patterns\n\t\t{\n\t\t\tname:        \"block multi-arg subcommand\",\n\t\t\tcmd:         \"yarn\",\n\t\t\targs:        []string{\"global\", \"add\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"yarn\", \"global\", \"add\", \"typescript\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow partial multi-arg match\",\n\t\t\tcmd:         \"yarn\",\n\t\t\targs:        []string{\"global\", \"add\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"yarn\", \"global\", \"list\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\n\t\t// Edge cases\n\t\t{\n\t\t\tname:        \"handle empty input\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"handle command only\",\n\t\t\tcmd:         \"npm\",\n\t\t\targs:        []string{\"install\"},\n\t\t\tflags:       nil,\n\t\t\tinput:       []string{\"npm\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"block pacman with -S flag\",\n\t\t\tcmd:         \"pacman\",\n\t\t\targs:        nil,\n\t\t\tflags:       []string{\"-S\"},\n\t\t\tinput:       []string{\"pacman\", \"-S\", \"package\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow pacman without -S flag\",\n\t\t\tcmd:         \"pacman\",\n\t\t\targs:        nil,\n\t\t\tflags:       []string{\"-S\"},\n\t\t\tinput:       []string{\"pacman\", \"-Q\", \"package\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\n\t\t// `go test -exec`\n\t\t{\n\t\t\tname:        \"go test exec\",\n\t\t\tcmd:         \"go\",\n\t\t\targs:        []string{\"test\"},\n\t\t\tflags:       []string{\"-exec\"},\n\t\t\tinput:       []string{\"go\", \"test\", \"-exec\", \"bash -c 'echo hello'\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"go test exec\",\n\t\t\tcmd:         \"go\",\n\t\t\targs:        []string{\"test\"},\n\t\t\tflags:       []string{\"-exec\"},\n\t\t\tinput:       []string{\"go\", \"test\", `-exec=\"bash -c 'echo hello'\"`},\n\t\t\tshouldBlock: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tblocker := ArgumentsBlocker(tt.cmd, tt.args, tt.flags)\n\t\t\tresult := blocker(tt.input)\n\t\t\trequire.Equal(t, tt.shouldBlock, result,\n\t\t\t\t\"Expected block=%v for input %v\", tt.shouldBlock, tt.input)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCommandsBlocker_263": {
      "name": "TestCommandsBlocker",
      "type": "function",
      "start_line": 263,
      "end_line": 311,
      "content_hash": "c53f7107afd7080b3b9f6dbb0262e03ecd4f7bbb",
      "content": "func TestCommandsBlocker(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tbanned      []string\n\t\tinput       []string\n\t\tshouldBlock bool\n\t}{\n\t\t{\n\t\t\tname:        \"block single banned command\",\n\t\t\tbanned:      []string{\"curl\"},\n\t\t\tinput:       []string{\"curl\", \"https://example.com\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"allow non-banned command\",\n\t\t\tbanned:      []string{\"curl\", \"wget\"},\n\t\t\tinput:       []string{\"echo\", \"hello\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"block from multiple banned\",\n\t\t\tbanned:      []string{\"curl\", \"wget\", \"nc\"},\n\t\t\tinput:       []string{\"wget\", \"https://example.com\"},\n\t\t\tshouldBlock: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"handle empty input\",\n\t\t\tbanned:      []string{\"curl\"},\n\t\t\tinput:       []string{},\n\t\t\tshouldBlock: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"case sensitive matching\",\n\t\t\tbanned:      []string{\"curl\"},\n\t\t\tinput:       []string{\"CURL\", \"https://example.com\"},\n\t\t\tshouldBlock: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tblocker := CommandsBlocker(tt.banned)\n\t\t\tresult := blocker(tt.input)\n\t\t\trequire.Equal(t, tt.shouldBlock, result,\n\t\t\t\t\"Expected block=%v for input %v\", tt.shouldBlock, tt.input)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSplitArgsFlags_312": {
      "name": "TestSplitArgsFlags",
      "type": "function",
      "start_line": 312,
      "end_line": 376,
      "content_hash": "f0566fa1dc58b2def247afdab18606a2e1c2b1cd",
      "content": "func TestSplitArgsFlags(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\twantArgs  []string\n\t\twantFlags []string\n\t}{\n\t\t{\n\t\t\tname:      \"only args\",\n\t\t\tinput:     []string{\"install\", \"package\", \"another\"},\n\t\t\twantArgs:  []string{\"install\", \"package\", \"another\"},\n\t\t\twantFlags: []string{},\n\t\t},\n\t\t{\n\t\t\tname:      \"only flags\",\n\t\t\tinput:     []string{\"-g\", \"--verbose\", \"-f\"},\n\t\t\twantArgs:  []string{},\n\t\t\twantFlags: []string{\"-g\", \"--verbose\", \"-f\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"mixed args and flags\",\n\t\t\tinput:     []string{\"install\", \"-g\", \"package\", \"--verbose\"},\n\t\t\twantArgs:  []string{\"install\", \"package\"},\n\t\t\twantFlags: []string{\"-g\", \"--verbose\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"empty input\",\n\t\t\tinput:     []string{},\n\t\t\twantArgs:  []string{},\n\t\t\twantFlags: []string{},\n\t\t},\n\t\t{\n\t\t\tname:      \"single dash flag\",\n\t\t\tinput:     []string{\"-S\", \"package\"},\n\t\t\twantArgs:  []string{\"package\"},\n\t\t\twantFlags: []string{\"-S\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"flag with equals sign\",\n\t\t\tinput:     []string{\"-exec=bash\", \"package\"},\n\t\t\twantArgs:  []string{\"package\"},\n\t\t\twantFlags: []string{\"-exec\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"long flag with equals sign\",\n\t\t\tinput:     []string{\"--config=/path/to/config\", \"run\"},\n\t\t\twantArgs:  []string{\"run\"},\n\t\t\twantFlags: []string{\"--config\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"flag with complex value\",\n\t\t\tinput:     []string{`-exec=\"bash -c 'echo hello'\"`, \"test\"},\n\t\t\twantArgs:  []string{\"test\"},\n\t\t\twantFlags: []string{\"-exec\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\targs, flags := splitArgsFlags(tt.input)\n\t\t\trequire.Equal(t, tt.wantArgs, args, \"args mismatch\")\n\t\t\trequire.Equal(t, tt.wantFlags, flags, \"flags mismatch\")\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}