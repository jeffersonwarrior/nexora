{
  "file_path": "/work/context-engine/ctx-mcp-bridge/src/resultPathMapping.js",
  "file_hash": "ec5be0b4b1855e843947107b8f59744ae7e1dd36",
  "updated_at": "2025-12-26T17:34:20.851786",
  "symbols": {
    "function_envTruthy_5": {
      "name": "envTruthy",
      "type": "function",
      "start_line": 5,
      "end_line": 18,
      "content_hash": "59adfd237c670a897a781dd5695f080393c8280c",
      "content": "function envTruthy(value, defaultVal = false) {\n  try {\n    if (value === undefined || value === null) {\n      return defaultVal;\n    }\n    const s = String(value).trim().toLowerCase();\n    if (!s) {\n      return defaultVal;\n    }\n    return s === \"1\" || s === \"true\" || s === \"yes\" || s === \"on\";\n  } catch {\n    return defaultVal;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__posixToNative_20": {
      "name": "_posixToNative",
      "type": "function",
      "start_line": 20,
      "end_line": 29,
      "content_hash": "980d4ea80fe6ad44da1c1f4b4d6fad6004e5cd20",
      "content": "function _posixToNative(rel) {\n  try {\n    if (!rel) {\n      return \"\";\n    }\n    return String(rel).split(\"/\").join(path.sep);\n  } catch {\n    return rel;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__nativeToPosix_31": {
      "name": "_nativeToPosix",
      "type": "function",
      "start_line": 31,
      "end_line": 40,
      "content_hash": "282d430d92201a68f9171201efa139ccb817dcf6",
      "content": "function _nativeToPosix(p) {\n  try {\n    if (!p) {\n      return \"\";\n    }\n    return String(p).split(path.sep).join(\"/\");\n  } catch {\n    return p;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__workPathToRepoRelPosix_42": {
      "name": "_workPathToRepoRelPosix",
      "type": "function",
      "start_line": 42,
      "end_line": 60,
      "content_hash": "ec8b7e9e28ae9e594a8ae3f5daa2022f5c47545b",
      "content": "function _workPathToRepoRelPosix(p) {\n  try {\n    const s = typeof p === \"string\" ? p.trim() : \"\";\n    if (!s || !s.startsWith(\"/work/\")) {\n      return null;\n    }\n    const rest = s.slice(\"/work/\".length);\n    const parts = rest.split(\"/\").filter(Boolean);\n    if (parts.length >= 2) {\n      return parts.slice(1).join(\"/\");\n    }\n    if (parts.length === 1) {\n      return parts[0];\n    }\n    return \"\";\n  } catch {\n    return null;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeToolArgPath_62": {
      "name": "normalizeToolArgPath",
      "type": "function",
      "start_line": 62,
      "end_line": 120,
      "content_hash": "0aff397214649e54e51cb0b4179f91e6d869d4ed",
      "content": "function normalizeToolArgPath(p, workspaceRoot) {\n  try {\n    const s = typeof p === \"string\" ? p.trim() : \"\";\n    if (!s) {\n      return p;\n    }\n\n    const root = typeof workspaceRoot === \"string\" ? workspaceRoot : \"\";\n    const sPosix = s.replace(/\\\\/g, \"/\");\n\n    const fromWork = _workPathToRepoRelPosix(sPosix);\n    if (typeof fromWork === \"string\" && fromWork) {\n      return fromWork;\n    }\n    if (fromWork === \"\") {\n      return p;\n    }\n\n    if (root) {\n      try {\n        const sNorm = s.replace(/\\\\/g, path.sep);\n        const rootNorm = root.replace(/\\\\/g, path.sep);\n        if (sNorm === rootNorm || sNorm.startsWith(rootNorm + path.sep)) {\n          const relNative = path.relative(rootNorm, sNorm);\n          const relPosix = _nativeToPosix(relNative);\n          if (relPosix && relPosix !== \".\" && relPosix !== \"..\" && !relPosix.startsWith(\"../\")) {\n            return relPosix;\n          }\n        }\n      } catch {\n        // ignore\n      }\n      try {\n        const base = path.posix.basename(root.replace(/\\\\/g, \"/\"));\n        if (base && sPosix.startsWith(base + \"/\")) {\n          const rest = sPosix.slice((base + \"/\").length);\n          if (rest && rest !== \".\" && rest !== \"..\" && !rest.startsWith(\"../\")) {\n            return rest;\n          }\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    if (sPosix.startsWith(\"./\")) {\n      const rest = sPosix.slice(2);\n      if (rest && rest !== \".\" && rest !== \"..\" && !rest.startsWith(\"../\")) {\n        return rest;\n      }\n    }\n    if (sPosix === \".\") {\n      return \"\";\n    }\n    return p;\n  } catch {\n    return p;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeToolArgGlob_122": {
      "name": "normalizeToolArgGlob",
      "type": "function",
      "start_line": 122,
      "end_line": 143,
      "content_hash": "1214cc8f8a85a804512dc8825722e8f96b14f9da",
      "content": "function normalizeToolArgGlob(p, workspaceRoot) {\n  try {\n    const s = typeof p === \"string\" ? p : \"\";\n    if (!s) {\n      return p;\n    }\n    // TODO(ctxce): If this becomes annoying, consider making glob normalization\n    // more conservative (e.g. only strip a repo prefix when followed by \"/\",\n    // and avoid collapsing \"<repo>/**\" into \"**\" which can broaden scope).\n    if (s.startsWith(\"!\")) {\n      const rest = s.slice(1);\n      const mapped = normalizeToolArgPath(rest, workspaceRoot);\n      if (typeof mapped === \"string\") {\n        return \"!\" + mapped;\n      }\n      return p;\n    }\n    return normalizeToolArgPath(s, workspaceRoot);\n  } catch {\n    return p;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyPathMappingToArgs_145": {
      "name": "applyPathMappingToArgs",
      "type": "function",
      "start_line": 145,
      "end_line": 187,
      "content_hash": "8a895a6dc93428bc77792e309979402909b9922c",
      "content": "function applyPathMappingToArgs(value, workspaceRoot, keyHint = \"\") {\n  try {\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    const key = typeof keyHint === \"string\" ? keyHint : \"\";\n    const lowered = key.toLowerCase();\n    const shouldMapString =\n      lowered === \"path\" ||\n      lowered === \"under\" ||\n      lowered === \"root\" ||\n      lowered === \"subdir\" ||\n      lowered === \"path_glob\" ||\n      lowered === \"not_glob\";\n\n    if (typeof value === \"string\") {\n      if (!shouldMapString) {\n        return value;\n      }\n      if (lowered === \"path_glob\" || lowered === \"not_glob\") {\n        return normalizeToolArgGlob(value, workspaceRoot);\n      }\n      return normalizeToolArgPath(value, workspaceRoot);\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((v) => applyPathMappingToArgs(v, workspaceRoot, keyHint));\n    }\n\n    if (typeof value === \"object\") {\n      const out = { ...value };\n      for (const [k, v] of Object.entries(out)) {\n        out[k] = applyPathMappingToArgs(v, workspaceRoot, k);\n      }\n      return out;\n    }\n\n    return value;\n  } catch {\n    return value;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_computeWorkspaceRelativePath_189": {
      "name": "computeWorkspaceRelativePath",
      "type": "function",
      "start_line": 189,
      "end_line": 208,
      "content_hash": "dbe49e8bd9643a0b7275a2d44d0d40d7f4e4f155",
      "content": "function computeWorkspaceRelativePath(containerPath, hostPath) {\n  try {\n    const cont = typeof containerPath === \"string\" ? containerPath.trim() : \"\";\n    const rel = _workPathToRepoRelPosix(cont);\n    if (typeof rel === \"string\" && rel) {\n      return rel;\n    }\n  } catch {\n  }\n  try {\n    const hp = typeof hostPath === \"string\" ? hostPath.trim() : \"\";\n    if (!hp) {\n      return \"\";\n    }\n    // If we don't have a container path, at least try to return a basename.\n    return path.posix.basename(hp.replace(/\\\\/g, \"/\"));\n  } catch {\n    return \"\";\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_remapRelatedPathToClient_210": {
      "name": "remapRelatedPathToClient",
      "type": "function",
      "start_line": 210,
      "end_line": 246,
      "content_hash": "134bc3358de11ee83777b9898074dd549eb4889f",
      "content": "function remapRelatedPathToClient(p, workspaceRoot) {\n  try {\n    const s = typeof p === \"string\" ? p : \"\";\n    const root = typeof workspaceRoot === \"string\" ? workspaceRoot : \"\";\n    if (!s || !root) {\n      return p;\n    }\n\n    const sNorm = s.replace(/\\\\/g, path.sep);\n    if (sNorm.startsWith(root + path.sep) || sNorm === root) {\n      return sNorm;\n    }\n\n    const rel = _workPathToRepoRelPosix(s);\n    if (typeof rel === \"string\" && rel) {\n      const relNative = _posixToNative(rel);\n      return path.join(root, relNative);\n    }\n\n    // If it's already a relative path, join it to the workspace root.\n    if (!s.startsWith(\"/\") && !s.includes(\":\") && !s.includes(\"\\\\\")) {\n      const relPosix = s.trim();\n      if (relPosix && relPosix !== \".\" && !relPosix.startsWith(\"../\") && relPosix !== \"..\") {\n        const relNative = _posixToNative(relPosix);\n        const joined = path.join(root, relNative);\n        const relCheck = path.relative(root, joined);\n        if (relCheck && !relCheck.startsWith(`..${path.sep}`) && relCheck !== \"..\") {\n          return joined;\n        }\n      }\n    }\n\n    return p;\n  } catch {\n    return p;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_remapHitPaths_248": {
      "name": "remapHitPaths",
      "type": "function",
      "start_line": 248,
      "end_line": 323,
      "content_hash": "ef8bb7695ade821b6880cb8d38da7b329e11d94d",
      "content": "function remapHitPaths(hit, workspaceRoot) {\n  if (!hit || typeof hit !== \"object\") {\n    return hit;\n  }\n  const rawPath = typeof hit.path === \"string\" ? hit.path : \"\";\n  let hostPath = typeof hit.host_path === \"string\" ? hit.host_path : \"\";\n  let containerPath = typeof hit.container_path === \"string\" ? hit.container_path : \"\";\n  if (!hostPath && rawPath) {\n    hostPath = rawPath;\n  }\n  if (!containerPath && rawPath) {\n    containerPath = rawPath;\n  }\n  const relPath = computeWorkspaceRelativePath(containerPath, hostPath);\n  const out = { ...hit };\n  if (relPath) {\n    out.rel_path = relPath;\n  }\n  // Remap related_paths nested under each hit (repo_search/hybrid_search emit this per result).\n  try {\n    if (Array.isArray(out.related_paths)) {\n      out.related_paths = out.related_paths.map((p) => remapRelatedPathToClient(p, workspaceRoot));\n    }\n  } catch {\n    // ignore\n  }\n  if (workspaceRoot && relPath) {\n    try {\n      const relNative = _posixToNative(relPath);\n      const candidate = path.join(workspaceRoot, relNative);\n      const diagnostics = envTruthy(process.env.CTXCE_BRIDGE_PATH_DIAGNOSTICS, false);\n      const strictClientPath = envTruthy(process.env.CTXCE_BRIDGE_CLIENT_PATH_STRICT, false);\n      if (strictClientPath) {\n        out.client_path = candidate;\n        if (diagnostics) {\n          out.client_path_joined = candidate;\n          out.client_path_source = \"workspace_join\";\n        }\n      } else {\n        // Prefer a host_path that is within the current bridge workspace.\n        // This keeps provenance (host_path) intact while providing a user-local\n        // absolute path even when the bridge workspace is a parent directory.\n        const hp = typeof hostPath === \"string\" ? hostPath : \"\";\n        const hpNorm = hp ? hp.replace(/\\\\/g, path.sep) : \"\";\n        if (\n          hpNorm &&\n          hpNorm.startsWith(workspaceRoot) &&\n          (!fs.existsSync(candidate) || fs.existsSync(hpNorm))\n        ) {\n          out.client_path = hpNorm;\n          if (diagnostics) {\n            out.client_path_joined = candidate;\n            out.client_path_source = \"host_path\";\n          }\n        } else {\n          out.client_path = candidate;\n          if (diagnostics) {\n            out.client_path_joined = candidate;\n            out.client_path_source = \"workspace_join\";\n          }\n        }\n      }\n    } catch {\n      // ignore\n    }\n  }\n  const overridePath = envTruthy(process.env.CTXCE_BRIDGE_OVERRIDE_PATH, true);\n  if (overridePath) {\n    if (typeof out.client_path === \"string\" && out.client_path) {\n      out.path = out.client_path;\n    } else if (relPath) {\n      out.path = relPath;\n    }\n  }\n  return out;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_remapStringPath_325": {
      "name": "remapStringPath",
      "type": "function",
      "start_line": 325,
      "end_line": 363,
      "content_hash": "cbb10d666b419ecb03530f5cd8a880127ed8ac6e",
      "content": "function remapStringPath(p, workspaceRoot) {\n  try {\n    const s = typeof p === \"string\" ? p : \"\";\n    if (!s) {\n      return p;\n    }\n    // If this is already a path within the current client workspace, rewrite to a\n    // workspace-relative string when override is enabled.\n    try {\n      const root = typeof workspaceRoot === \"string\" ? workspaceRoot : \"\";\n      if (root) {\n        const sNorm = s.replace(/\\\\/g, path.sep);\n        if (sNorm.startsWith(root + path.sep) || sNorm === root) {\n          const relNative = path.relative(root, sNorm);\n          const relPosix = String(relNative).split(path.sep).join(\"/\");\n          if (relPosix && !relPosix.startsWith(\"../\") && relPosix !== \"..\") {\n            const override = envTruthy(process.env.CTXCE_BRIDGE_OVERRIDE_PATH, true);\n            if (override) {\n              return relPosix;\n            }\n          }\n        }\n      }\n    } catch {\n      // ignore\n    }\n    const rel = _workPathToRepoRelPosix(s);\n    if (typeof rel === \"string\" && rel) {\n      const override = envTruthy(process.env.CTXCE_BRIDGE_OVERRIDE_PATH, true);\n      if (override) {\n        return rel;\n      }\n      return p;\n    }\n    return p;\n  } catch {\n    return p;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_maybeParseToolJson_365": {
      "name": "maybeParseToolJson",
      "type": "function",
      "start_line": 365,
      "end_line": 396,
      "content_hash": "9f50250f22982c6d933667f011b1f6b8525fbb96",
      "content": "function maybeParseToolJson(result) {\n  try {\n    if (\n      result &&\n      typeof result === \"object\" &&\n      result.structuredContent &&\n      typeof result.structuredContent === \"object\"\n    ) {\n      return { mode: \"structured\", value: result.structuredContent };\n    }\n  } catch {\n  }\n  try {\n    const content = result && result.content;\n    if (!Array.isArray(content)) {\n      return null;\n    }\n    const first = content.find(\n      (c) => c && c.type === \"text\" && typeof c.text === \"string\",\n    );\n    if (!first) {\n      return null;\n    }\n    const txt = String(first.text || \"\").trim();\n    if (!txt || !(txt.startsWith(\"{\") || txt.startsWith(\"[\"))) {\n      return null;\n    }\n    return { mode: \"text\", value: JSON.parse(txt) };\n  } catch {\n    return null;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyPathMappingToPayload_398": {
      "name": "applyPathMappingToPayload",
      "type": "function",
      "start_line": 398,
      "end_line": 428,
      "content_hash": "c91cdaed3b4775b0eb339aa87d9333add4a1d4c8",
      "content": "function applyPathMappingToPayload(payload, workspaceRoot) {\n  if (!payload || typeof payload !== \"object\") {\n    return payload;\n  }\n  const out = Array.isArray(payload) ? payload.slice() : { ...payload };\n\n  const mapHitsArray = (arr) => {\n    if (!Array.isArray(arr)) {\n      return arr;\n    }\n    return arr.map((h) => remapHitPaths(h, workspaceRoot));\n  };\n\n  // Common result shapes across tools\n  if (Array.isArray(out.results)) {\n    out.results = mapHitsArray(out.results);\n  }\n  if (Array.isArray(out.citations)) {\n    out.citations = mapHitsArray(out.citations);\n  }\n  if (Array.isArray(out.related_paths)) {\n    out.related_paths = out.related_paths.map((p) => remapRelatedPathToClient(p, workspaceRoot));\n  }\n\n  // Some tools nest under {result:{...}}\n  if (out.result && typeof out.result === \"object\") {\n    out.result = applyPathMappingToPayload(out.result, workspaceRoot);\n  }\n\n  return out;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_mapHitsArray_404": {
      "name": "mapHitsArray",
      "type": "function",
      "start_line": 404,
      "end_line": 409,
      "content_hash": "acec7a0a606bf81cb0b7e574bc3773fc71149d64",
      "content": "  const mapHitsArray = (arr) => {\n    if (!Array.isArray(arr)) {\n      return arr;\n    }\n    return arr.map((h) => remapHitPaths(h, workspaceRoot));\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_maybeRemapToolResult_430": {
      "name": "maybeRemapToolResult",
      "type": "function",
      "start_line": 430,
      "end_line": 481,
      "content_hash": "a6b935b0e64e4a3b31070ec6d46f9bf6a0c71b98",
      "content": "export function maybeRemapToolResult(name, result, workspaceRoot) {\n  try {\n    if (!name || !result || !workspaceRoot) {\n      return result;\n    }\n    const enabled = envTruthy(process.env.CTXCE_BRIDGE_MAP_PATHS, true);\n    if (!enabled) {\n      return result;\n    }\n    const lower = String(name).toLowerCase();\n    const shouldMap = (\n      lower === \"repo_search\" ||\n      lower === \"context_search\" ||\n      lower === \"context_answer\" ||\n      lower.endsWith(\"search_tests_for\") ||\n      lower.endsWith(\"search_config_for\") ||\n      lower.endsWith(\"search_callers_for\") ||\n      lower.endsWith(\"search_importers_for\")\n    );\n    if (!shouldMap) {\n      return result;\n    }\n\n    const parsed = maybeParseToolJson(result);\n    if (!parsed) {\n      return result;\n    }\n\n    const mapped = applyPathMappingToPayload(parsed.value, workspaceRoot);\n    let outResult = result;\n    if (parsed.mode === \"structured\") {\n      outResult = { ...result, structuredContent: mapped };\n    }\n\n    // Replace text payload for clients that only read `content[].text`\n    try {\n      const content = Array.isArray(outResult.content) ? outResult.content.slice() : [];\n      const idx = content.findIndex(\n        (c) => c && c.type === \"text\" && typeof c.text === \"string\",\n      );\n      if (idx >= 0) {\n        content[idx] = { ...content[idx], text: JSON.stringify(mapped) };\n        outResult = { ...outResult, content };\n      }\n    } catch {\n      // ignore\n    }\n    return outResult;\n  } catch {\n    return result;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_maybeRemapToolArgs_483": {
      "name": "maybeRemapToolArgs",
      "type": "function",
      "start_line": 483,
      "end_line": 499,
      "content_hash": "d2196a8b68a04dd08ab9db0bfa13cb05f133faf1",
      "content": "export function maybeRemapToolArgs(name, args, workspaceRoot) {\n  try {\n    if (!name || !workspaceRoot) {\n      return args;\n    }\n    const enabled = envTruthy(process.env.CTXCE_BRIDGE_MAP_ARGS, true);\n    if (!enabled) {\n      return args;\n    }\n    if (args === null || args === undefined || typeof args !== \"object\") {\n      return args;\n    }\n    return applyPathMappingToArgs(args, workspaceRoot, \"\");\n  } catch {\n    return args;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}