{
  "file_path": "/work/internal/tui/components/chat/editor/editor.go",
  "file_hash": "2eb36f0828c528ac78385c4d02cc39f34772958d",
  "updated_at": "2025-12-26T17:34:25.142883",
  "symbols": {
    "interface_Editor_35": {
      "name": "Editor",
      "type": "interface",
      "start_line": 35,
      "end_line": 47,
      "content_hash": "d445192f06b4c8771ec3bd217dc1427d02b7d6ff",
      "content": "type Editor interface {\n\tutil.Model\n\tcore.Sizeable\n\tcore.Focusable\n\tlayout.Help\n\tlayout.Positional\n\n\tSetSession(session session.Session) tea.Cmd\n\tIsCompletionsOpen() bool\n\tHasAttachments() bool\n\tCursor() *tea.Cursor\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FileCompletionItem_48": {
      "name": "FileCompletionItem",
      "type": "struct",
      "start_line": 48,
      "end_line": 51,
      "content_hash": "76266dec7478991822790c03169896a729caea95",
      "content": "type FileCompletionItem struct {\n\tPath string // The file path\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_editorCmp_52": {
      "name": "editorCmp",
      "type": "struct",
      "start_line": 52,
      "end_line": 91,
      "content_hash": "9c8902f3d89ac5a03394e4bda3ec1c9905d10aef",
      "content": "type editorCmp struct {\n\twidth              int\n\theight             int\n\tx, y               int\n\tapp                *app.App\n\tsession            session.Session\n\ttextarea           textarea.Model\n\tattachments        []message.Attachment\n\tdeleteMode         bool\n\treadyPlaceholder   string\n\tworkingPlaceholder string\n\n\tkeyMap EditorKeyMap\n\n\t// File path completions\n\tcurrentQuery          string\n\tcompletionsStartIndex int\n\tisCompletionsOpen     bool\n}\n\nvar DeleteKeyMaps = DeleteAttachmentKeyMaps{\n\tAttachmentDeleteMode: key.NewBinding(\n\t\tkey.WithKeys(\"ctrl+r\"),\n\t\tkey.WithHelp(\"ctrl+r+{i}\", \"delete attachment at index i\"),\n\t),\n\tEscape: key.NewBinding(\n\t\tkey.WithKeys(\"esc\", \"alt+esc\"),\n\t\tkey.WithHelp(\"esc\", \"cancel delete mode\"),\n\t),\n\tDeleteAllAttachments: key.NewBinding(\n\t\tkey.WithKeys(\"r\"),\n\t\tkey.WithHelp(\"ctrl+r+r\", \"delete all attachments\"),\n\t),\n}\n\nconst (\n\tmaxAttachments = 5\n\tmaxFileResults = 25\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OpenEditorMsg_92": {
      "name": "OpenEditorMsg",
      "type": "struct",
      "start_line": 92,
      "end_line": 95,
      "content_hash": "ffb8864cddf6b6b0b53d8863ece03ba8c53a3a76",
      "content": "type OpenEditorMsg struct {\n\tText string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_openEditor_96": {
      "name": "openEditor",
      "type": "method",
      "start_line": 96,
      "end_line": 135,
      "content_hash": "d0ce150e3b245f1bbb2a270beee2a998f794e4f8",
      "content": "func (m *editorCmp) openEditor(value string) tea.Cmd {\n\t// Context for shell execution - using background context for editor processes\n\tctx := context.Background()\n\teditor := os.Getenv(\"EDITOR\")\n\tif editor == \"\" {\n\t\t// Use platform-appropriate default editor\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\teditor = \"notepad\"\n\t\t} else {\n\t\t\teditor = \"nvim\"\n\t\t}\n\t}\n\n\ttmpfile, err := os.CreateTemp(\"\", \"msg_*.md\")\n\tif err != nil {\n\t\treturn util.ReportError(err)\n\t}\n\tdefer tmpfile.Close() //nolint:errcheck\n\tif _, err := tmpfile.WriteString(value); err != nil {\n\t\treturn util.ReportError(err)\n\t}\n\tcmdStr := editor + \" \" + tmpfile.Name()\n\treturn util.ExecShell(ctx, cmdStr, func(err error) tea.Msg {\n\t\tif err != nil {\n\t\t\treturn util.ReportError(err)\n\t\t}\n\t\tcontent, err := os.ReadFile(tmpfile.Name())\n\t\tif err != nil {\n\t\t\treturn util.ReportError(err)\n\t\t}\n\t\tif len(content) == 0 {\n\t\t\treturn util.ReportWarn(\"Message is empty\")\n\t\t}\n\t\tos.Remove(tmpfile.Name())\n\t\treturn OpenEditorMsg{\n\t\t\tText: strings.TrimSpace(string(content)),\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_136": {
      "name": "Init",
      "type": "method",
      "start_line": 136,
      "end_line": 139,
      "content_hash": "cca6d28d4ee6e00240b7d0d4a47e79c8e0fa0cb4",
      "content": "func (m *editorCmp) Init() tea.Cmd {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_send_140": {
      "name": "send",
      "type": "method",
      "start_line": 140,
      "end_line": 168,
      "content_hash": "3b32bf784c89dd5fc1a29a8b562d9fee8e5e4870",
      "content": "func (m *editorCmp) send() tea.Cmd {\n\tvalue := m.textarea.Value()\n\tvalue = strings.TrimSpace(value)\n\n\tswitch value {\n\tcase \"exit\", \"quit\":\n\t\tm.textarea.Reset()\n\t\treturn util.CmdHandler(dialogs.OpenDialogMsg{Model: quit.NewQuitDialog()})\n\t}\n\n\tm.textarea.Reset()\n\tattachments := m.attachments\n\n\tm.attachments = nil\n\tif value == \"\" {\n\t\treturn nil\n\t}\n\n\t// Change the placeholder when sending a new message.\n\tm.randomizePlaceholders()\n\n\treturn tea.Batch(\n\t\tutil.CmdHandler(chat.SendMsg{\n\t\t\tText:        value,\n\t\t\tAttachments: attachments,\n\t\t}),\n\t)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_repositionCompletions_169": {
      "name": "repositionCompletions",
      "type": "method",
      "start_line": 169,
      "end_line": 173,
      "content_hash": "25ba63fb24f72eded0cb327ff741a9137b5228ae",
      "content": "func (m *editorCmp) repositionCompletions() tea.Msg {\n\tx, y := m.completionsPosition()\n\treturn completions.RepositionCompletionsMsg{X: x, Y: y}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_174": {
      "name": "Update",
      "type": "method",
      "start_line": 174,
      "end_line": 371,
      "content_hash": "8ee7c363a6071f08a8cd6a3ace1812201091b801",
      "content": "func (m *editorCmp) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tvar cmds []tea.Cmd\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\treturn m, m.repositionCompletions\n\tcase filepicker.FilePickedMsg:\n\t\tif len(m.attachments) >= maxAttachments {\n\t\t\treturn m, util.ReportError(fmt.Errorf(\"cannot add more than %d images\", maxAttachments))\n\t\t}\n\t\tm.attachments = append(m.attachments, msg.Attachment)\n\t\treturn m, nil\n\tcase completions.CompletionsOpenedMsg:\n\t\tm.isCompletionsOpen = true\n\tcase completions.CompletionsClosedMsg:\n\t\tm.isCompletionsOpen = false\n\t\tm.currentQuery = \"\"\n\t\tm.completionsStartIndex = 0\n\tcase completions.SelectCompletionMsg:\n\t\tif !m.isCompletionsOpen {\n\t\t\treturn m, nil\n\t\t}\n\t\tif item, ok := msg.Value.(FileCompletionItem); ok {\n\t\t\tword := m.textarea.Word()\n\t\t\t// If the selected item is a file, insert its path into the textarea\n\t\t\tvalue := m.textarea.Value()\n\t\t\tvalue = value[:m.completionsStartIndex] + // Remove the current query\n\t\t\t\titem.Path + // Insert the file path\n\t\t\t\tvalue[m.completionsStartIndex+len(word):] // Append the rest of the value\n\t\t\t// XXX: This will always move the cursor to the end of the textarea.\n\t\t\tm.textarea.SetValue(value)\n\t\t\tm.textarea.MoveToEnd()\n\t\t\tif !msg.Insert {\n\t\t\t\tm.isCompletionsOpen = false\n\t\t\t\tm.currentQuery = \"\"\n\t\t\t\tm.completionsStartIndex = 0\n\t\t\t}\n\t\t}\n\n\tcase commands.OpenExternalEditorMsg:\n\t\tif m.app.AgentCoordinator.IsSessionBusy(m.session.ID) {\n\t\t\treturn m, util.ReportWarn(\"Agent is working, please wait...\")\n\t\t}\n\t\treturn m, m.openEditor(m.textarea.Value())\n\tcase OpenEditorMsg:\n\t\tm.textarea.SetValue(msg.Text)\n\t\tm.textarea.MoveToEnd()\n\tcase tea.PasteMsg:\n\t\tpath := strings.ReplaceAll(msg.Content, \"\\\\ \", \" \")\n\t\t// try to get an image\n\t\tpath, err := filepath.Abs(strings.TrimSpace(path))\n\t\tif err != nil {\n\t\t\tm.textarea, cmd = m.textarea.Update(msg)\n\t\t\treturn m, cmd\n\t\t}\n\t\tisAllowedType := false\n\t\tfor _, ext := range filepicker.AllowedTypes {\n\t\t\tif strings.HasSuffix(path, ext) {\n\t\t\t\tisAllowedType = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isAllowedType {\n\t\t\tm.textarea, cmd = m.textarea.Update(msg)\n\t\t\treturn m, cmd\n\t\t}\n\t\ttooBig, _ := filepicker.IsFileTooBig(path, filepicker.MaxAttachmentSize)\n\t\tif tooBig {\n\t\t\tm.textarea, cmd = m.textarea.Update(msg)\n\t\t\treturn m, cmd\n\t\t}\n\n\t\tcontent, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\tm.textarea, cmd = m.textarea.Update(msg)\n\t\t\treturn m, cmd\n\t\t}\n\t\tmimeBufferSize := min(512, len(content))\n\t\tmimeType := http.DetectContentType(content[:mimeBufferSize])\n\t\tfileName := filepath.Base(path)\n\t\tattachment := message.Attachment{FilePath: path, FileName: fileName, MimeType: mimeType, Content: content}\n\t\treturn m, util.CmdHandler(filepicker.FilePickedMsg{\n\t\t\tAttachment: attachment,\n\t\t})\n\n\tcase commands.ToggleYoloModeMsg:\n\t\tm.setEditorPrompt()\n\t\treturn m, nil\n\tcase tea.KeyPressMsg:\n\t\tcur := m.textarea.Cursor()\n\t\tcurIdx := m.textarea.Width()*cur.Y + cur.X\n\t\tswitch {\n\t\t// Open command palette when \"/\" is pressed on empty prompt\n\t\tcase msg.String() == \"/\" && len(strings.TrimSpace(m.textarea.Value())) == 0:\n\t\t\treturn m, util.CmdHandler(dialogs.OpenDialogMsg{\n\t\t\t\tModel: commands.NewCommandDialog(m.session.ID),\n\t\t\t})\n\t\t// Completions\n\t\tcase msg.String() == \"@\" && !m.isCompletionsOpen &&\n\t\t\t// only show if beginning of prompt, or if previous char is a space or newline:\n\t\t\t(len(m.textarea.Value()) == 0 || unicode.IsSpace(rune(m.textarea.Value()[len(m.textarea.Value())-1]))):\n\t\t\tm.isCompletionsOpen = true\n\t\t\tm.currentQuery = \"\"\n\t\t\tm.completionsStartIndex = curIdx\n\t\t\tcmds = append(cmds, m.startCompletions)\n\t\tcase m.isCompletionsOpen && curIdx <= m.completionsStartIndex:\n\t\t\tcmds = append(cmds, util.CmdHandler(completions.CloseCompletionsMsg{}))\n\t\t}\n\t\tif key.Matches(msg, DeleteKeyMaps.AttachmentDeleteMode) {\n\t\t\tm.deleteMode = true\n\t\t\treturn m, nil\n\t\t}\n\t\tif key.Matches(msg, DeleteKeyMaps.DeleteAllAttachments) && m.deleteMode {\n\t\t\tm.deleteMode = false\n\t\t\tm.attachments = nil\n\t\t\treturn m, nil\n\t\t}\n\t\trune := msg.Code\n\t\tif m.deleteMode && unicode.IsDigit(rune) {\n\t\t\tnum := int(rune - '0')\n\t\t\tm.deleteMode = false\n\t\t\tif num < 10 && len(m.attachments) > num {\n\t\t\t\tif num == 0 {\n\t\t\t\t\tm.attachments = m.attachments[num+1:]\n\t\t\t\t} else {\n\t\t\t\t\tm.attachments = slices.Delete(m.attachments, num, num+1)\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\t\tif key.Matches(msg, m.keyMap.OpenEditor) {\n\t\t\tif m.app.AgentCoordinator.IsSessionBusy(m.session.ID) {\n\t\t\t\treturn m, util.ReportWarn(\"Agent is working, please wait...\")\n\t\t\t}\n\t\t\treturn m, m.openEditor(m.textarea.Value())\n\t\t}\n\t\tif key.Matches(msg, DeleteKeyMaps.Escape) {\n\t\t\tm.deleteMode = false\n\t\t\treturn m, nil\n\t\t}\n\t\tif key.Matches(msg, m.keyMap.Newline) {\n\t\t\tm.textarea.InsertRune('\\n')\n\t\t\tcmds = append(cmds, util.CmdHandler(completions.CloseCompletionsMsg{}))\n\t\t}\n\t\t// Handle Enter key\n\t\tif m.textarea.Focused() && key.Matches(msg, m.keyMap.SendMessage) {\n\t\t\tvalue := m.textarea.Value()\n\t\t\tif strings.HasSuffix(value, \"\\\\\") {\n\t\t\t\t// If the last character is a backslash, remove it and add a newline.\n\t\t\t\tm.textarea.SetValue(strings.TrimSuffix(value, \"\\\\\"))\n\t\t\t} else {\n\t\t\t\t// Otherwise, send the message\n\t\t\t\treturn m, m.send()\n\t\t\t}\n\t\t}\n\t}\n\n\tm.textarea, cmd = m.textarea.Update(msg)\n\tcmds = append(cmds, cmd)\n\n\tif m.textarea.Focused() {\n\t\tkp, ok := msg.(tea.KeyPressMsg)\n\t\tif ok {\n\t\t\tif kp.String() == \"space\" || m.textarea.Value() == \"\" {\n\t\t\t\tm.isCompletionsOpen = false\n\t\t\t\tm.currentQuery = \"\"\n\t\t\t\tm.completionsStartIndex = 0\n\t\t\t\tcmds = append(cmds, util.CmdHandler(completions.CloseCompletionsMsg{}))\n\t\t\t} else {\n\t\t\t\tword := m.textarea.Word()\n\t\t\t\tif strings.HasPrefix(word, \"@\") {\n\t\t\t\t\t// XXX: wont' work if editing in the middle of the field.\n\t\t\t\t\tm.completionsStartIndex = strings.LastIndex(m.textarea.Value(), word)\n\t\t\t\t\tm.currentQuery = word[1:]\n\t\t\t\t\tx, y := m.completionsPosition()\n\t\t\t\t\tx -= len(m.currentQuery)\n\t\t\t\t\tm.isCompletionsOpen = true\n\t\t\t\t\tcmds = append(cmds,\n\t\t\t\t\t\tutil.CmdHandler(completions.FilterCompletionsMsg{\n\t\t\t\t\t\t\tQuery:  m.currentQuery,\n\t\t\t\t\t\t\tReopen: m.isCompletionsOpen,\n\t\t\t\t\t\t\tX:      x,\n\t\t\t\t\t\t\tY:      y,\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t} else if m.isCompletionsOpen {\n\t\t\t\t\tm.isCompletionsOpen = false\n\t\t\t\t\tm.currentQuery = \"\"\n\t\t\t\t\tm.completionsStartIndex = 0\n\t\t\t\t\tcmds = append(cmds, util.CmdHandler(completions.CloseCompletionsMsg{}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn m, tea.Batch(cmds...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setEditorPrompt_372": {
      "name": "setEditorPrompt",
      "type": "method",
      "start_line": 372,
      "end_line": 379,
      "content_hash": "cbc0fd723bf9e7a79164d7e2f4d6026e8dee3f84",
      "content": "func (m *editorCmp) setEditorPrompt() {\n\tif m.app.Permissions.SkipRequests() {\n\t\tm.textarea.SetPromptFunc(4, yoloPromptFunc)\n\t\treturn\n\t}\n\tm.textarea.SetPromptFunc(4, normalPromptFunc)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_completionsPosition_380": {
      "name": "completionsPosition",
      "type": "method",
      "start_line": 380,
      "end_line": 389,
      "content_hash": "1497a81359630390697860a412fefef6c0861226",
      "content": "func (m *editorCmp) completionsPosition() (int, int) {\n\tcur := m.textarea.Cursor()\n\tif cur == nil {\n\t\treturn m.x, m.y + 1 // adjust for padding\n\t}\n\tx := cur.X + m.x\n\ty := cur.Y + m.y + 1 // adjust for padding\n\treturn x, y\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Cursor_390": {
      "name": "Cursor",
      "type": "method",
      "start_line": 390,
      "end_line": 414,
      "content_hash": "59e48ffb269e8750fd5e7b5a9e49de8411942433",
      "content": "func (m *editorCmp) Cursor() *tea.Cursor {\n\tcursor := m.textarea.Cursor()\n\tif cursor != nil {\n\t\tcursor.X = cursor.X + m.x + 1\n\t\tcursor.Y = cursor.Y + m.y + 1 // adjust for padding\n\t}\n\treturn cursor\n}\n\nvar readyPlaceholders = [...]string{\n\t\"Ready!\",\n\t\"Ready...\",\n\t\"Ready?\",\n\t\"Ready for instructions\",\n}\n\nvar workingPlaceholders = [...]string{\n\t\"Working!\",\n\t\"Working...\",\n\t\"Brrrrr...\",\n\t\"Prrrrrrrr...\",\n\t\"Processing...\",\n\t\"Thinking...\",\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_randomizePlaceholders_415": {
      "name": "randomizePlaceholders",
      "type": "method",
      "start_line": 415,
      "end_line": 419,
      "content_hash": "1fbd6da98d56d0d7abfae06ad9762e22df8f6923",
      "content": "func (m *editorCmp) randomizePlaceholders() {\n\tm.workingPlaceholder = workingPlaceholders[rand.Intn(len(workingPlaceholders))]\n\tm.readyPlaceholder = readyPlaceholders[rand.Intn(len(readyPlaceholders))]\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_420": {
      "name": "View",
      "type": "method",
      "start_line": 420,
      "end_line": 445,
      "content_hash": "acbf7b51450ced04d37c3cadfd0fc74875c22bcf",
      "content": "func (m *editorCmp) View() string {\n\tt := styles.CurrentTheme()\n\t// Update placeholder\n\tif m.app.AgentCoordinator != nil && m.app.AgentCoordinator.IsBusy() {\n\t\tm.textarea.Placeholder = m.workingPlaceholder\n\t} else {\n\t\tm.textarea.Placeholder = m.readyPlaceholder\n\t}\n\tif m.app.Permissions.SkipRequests() {\n\t\tm.textarea.Placeholder = \"Yolo mode!\"\n\t}\n\tif len(m.attachments) == 0 {\n\t\tcontent := t.S().Base.Padding(1).Render(\n\t\t\tm.textarea.View(),\n\t\t)\n\t\treturn content\n\t}\n\tcontent := t.S().Base.Padding(0, 1, 1, 1).Render(\n\t\tlipgloss.JoinVertical(lipgloss.Top,\n\t\t\tm.attachmentsContent(),\n\t\t\tm.textarea.View(),\n\t\t),\n\t)\n\treturn content\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_446": {
      "name": "SetSize",
      "type": "method",
      "start_line": 446,
      "end_line": 453,
      "content_hash": "0af041559efb9a0721d20cee458376ddb94bd9a2",
      "content": "func (m *editorCmp) SetSize(width, height int) tea.Cmd {\n\tm.width = width\n\tm.height = height\n\tm.textarea.SetWidth(width - 2)   // adjust for padding\n\tm.textarea.SetHeight(height - 2) // adjust for padding\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_454": {
      "name": "GetSize",
      "type": "method",
      "start_line": 454,
      "end_line": 457,
      "content_hash": "666a93c7bb1d11bd5364e104661bcf6ec941feaa",
      "content": "func (m *editorCmp) GetSize() (int, int) {\n\treturn m.textarea.Width(), m.textarea.Height()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_attachmentsContent_458": {
      "name": "attachmentsContent",
      "type": "method",
      "start_line": 458,
      "end_line": 480,
      "content_hash": "00707e08df7eab787b3afce7958f356197f63431",
      "content": "func (m *editorCmp) attachmentsContent() string {\n\tvar styledAttachments []string\n\tt := styles.CurrentTheme()\n\tattachmentStyles := t.S().Base.\n\t\tMarginLeft(1).\n\t\tBackground(t.FgMuted).\n\t\tForeground(t.FgBase)\n\tfor i, attachment := range m.attachments {\n\t\tvar filename string\n\t\tif len(attachment.FileName) > 10 {\n\t\t\tfilename = fmt.Sprintf(\" %s %s...\", styles.DocumentIcon, attachment.FileName[0:7])\n\t\t} else {\n\t\t\tfilename = fmt.Sprintf(\" %s %s\", styles.DocumentIcon, attachment.FileName)\n\t\t}\n\t\tif m.deleteMode {\n\t\t\tfilename = fmt.Sprintf(\"%d%s\", i, filename)\n\t\t}\n\t\tstyledAttachments = append(styledAttachments, attachmentStyles.Render(filename))\n\t}\n\tcontent := lipgloss.JoinHorizontal(lipgloss.Left, styledAttachments...)\n\treturn content\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetPosition_481": {
      "name": "SetPosition",
      "type": "method",
      "start_line": 481,
      "end_line": 486,
      "content_hash": "e89e98b581bf0b2c9cac578ce2dc771713bb7f95",
      "content": "func (m *editorCmp) SetPosition(x, y int) tea.Cmd {\n\tm.x = x\n\tm.y = y\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startCompletions_487": {
      "name": "startCompletions",
      "type": "method",
      "start_line": 487,
      "end_line": 512,
      "content_hash": "f9415be8c83ded102632f329a047b1ceb63fd738",
      "content": "func (m *editorCmp) startCompletions() tea.Msg {\n\tls := m.app.Config().Options.TUI.Completions\n\tdepth, limit := ls.Limits()\n\tfiles, _, _ := fsext.ListDirectory(\".\", nil, depth, limit)\n\tslices.Sort(files)\n\tcompletionItems := make([]completions.Completion, 0, len(files))\n\tfor _, file := range files {\n\t\tfile = strings.TrimPrefix(file, \"./\")\n\t\tcompletionItems = append(completionItems, completions.Completion{\n\t\t\tTitle: file,\n\t\t\tValue: FileCompletionItem{\n\t\t\t\tPath: file,\n\t\t\t},\n\t\t})\n\t}\n\n\tx, y := m.completionsPosition()\n\treturn completions.OpenCompletionsMsg{\n\t\tCompletions: completionItems,\n\t\tX:           x,\n\t\tY:           y,\n\t\tMaxResults:  maxFileResults,\n\t}\n}\n\n// Blur implements Container.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Blur_513": {
      "name": "Blur",
      "type": "method",
      "start_line": 513,
      "end_line": 518,
      "content_hash": "56934843eec265d2081d1c53d67258a1a5c1e2f0",
      "content": "func (c *editorCmp) Blur() tea.Cmd {\n\tc.textarea.Blur()\n\treturn nil\n}\n\n// Focus implements Container.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Focus_519": {
      "name": "Focus",
      "type": "method",
      "start_line": 519,
      "end_line": 523,
      "content_hash": "bb4f3dca15893dc8383b5451465c25eac02a82ad",
      "content": "func (c *editorCmp) Focus() tea.Cmd {\n\treturn c.textarea.Focus()\n}\n\n// IsFocused implements Container.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsFocused_524": {
      "name": "IsFocused",
      "type": "method",
      "start_line": 524,
      "end_line": 528,
      "content_hash": "734f0df78b655393d8ad56f7ddeb0b38222f32c1",
      "content": "func (c *editorCmp) IsFocused() bool {\n\treturn c.textarea.Focused()\n}\n\n// Bindings implements Container.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Bindings_529": {
      "name": "Bindings",
      "type": "method",
      "start_line": 529,
      "end_line": 534,
      "content_hash": "90e31a123f9afdd728447f909bb5c3ec1bea29a9",
      "content": "func (c *editorCmp) Bindings() []key.Binding {\n\treturn c.keyMap.KeyBindings()\n}\n\n// Session dependency - managed at page level rather than component level\n// Component focuses on editing functionality, session moved to parent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSession_535": {
      "name": "SetSession",
      "type": "method",
      "start_line": 535,
      "end_line": 539,
      "content_hash": "63a4490732fecc8bd7ccd6d2fcde330d9fb0953a",
      "content": "func (c *editorCmp) SetSession(session session.Session) tea.Cmd {\n\tc.session = session\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsCompletionsOpen_540": {
      "name": "IsCompletionsOpen",
      "type": "method",
      "start_line": 540,
      "end_line": 543,
      "content_hash": "c93915ee117fe16c78c4e9a48f735604d9e069f3",
      "content": "func (c *editorCmp) IsCompletionsOpen() bool {\n\treturn c.isCompletionsOpen\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HasAttachments_544": {
      "name": "HasAttachments",
      "type": "method",
      "start_line": 544,
      "end_line": 547,
      "content_hash": "2d9acac805aa4734d0a83885816f8e5dcc304e2c",
      "content": "func (c *editorCmp) HasAttachments() bool {\n\treturn len(c.attachments) > 0\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalPromptFunc_548": {
      "name": "normalPromptFunc",
      "type": "function",
      "start_line": 548,
      "end_line": 558,
      "content_hash": "5f0e0960ce23742ed7f54abbd3eaa37ef7b75fc6",
      "content": "func normalPromptFunc(info textarea.PromptInfo) string {\n\tt := styles.CurrentTheme()\n\tif info.LineNumber == 0 {\n\t\treturn \"  > \"\n\t}\n\tif info.Focused {\n\t\treturn t.S().Base.Foreground(t.GreenDark).Render(\"::: \")\n\t}\n\treturn t.S().Muted.Render(\"::: \")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_yoloPromptFunc_559": {
      "name": "yoloPromptFunc",
      "type": "function",
      "start_line": 559,
      "end_line": 573,
      "content_hash": "97fdaee22a6f54e6a085782bb1f3f485334583dd",
      "content": "func yoloPromptFunc(info textarea.PromptInfo) string {\n\tt := styles.CurrentTheme()\n\tif info.LineNumber == 0 {\n\t\tif info.Focused {\n\t\t\treturn fmt.Sprintf(\"%s \", t.YoloIconFocused)\n\t\t} else {\n\t\t\treturn fmt.Sprintf(\"%s \", t.YoloIconBlurred)\n\t\t}\n\t}\n\tif info.Focused {\n\t\treturn fmt.Sprintf(\"%s \", t.YoloDotsFocused)\n\t}\n\treturn fmt.Sprintf(\"%s \", t.YoloDotsBlurred)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_574": {
      "name": "New",
      "type": "function",
      "start_line": 574,
      "end_line": 595,
      "content_hash": "ea06c983fd6f7016761b022f4dd89b41a19fa4b6",
      "content": "func New(app *app.App) Editor {\n\tt := styles.CurrentTheme()\n\tta := textarea.New()\n\tta.SetStyles(t.S().TextArea)\n\tta.ShowLineNumbers = false\n\tta.CharLimit = -1\n\tta.SetVirtualCursor(false)\n\tta.Focus()\n\te := &editorCmp{\n\t\t// Component independence - removing app dependency for better architecture\n\t\t// Component manages editor state without direct app coupling\n\t\tapp:      app,\n\t\ttextarea: ta,\n\t\tkeyMap:   DefaultEditorKeyMap(),\n\t}\n\te.setEditorPrompt()\n\n\te.randomizePlaceholders()\n\te.textarea.Placeholder = e.readyPlaceholder\n\n\treturn e\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}