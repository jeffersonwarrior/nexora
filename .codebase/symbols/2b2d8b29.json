{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/graph_step_validation.rs",
  "file_hash": "e32dc5c591b2b89af5850843307b4ffff3245313",
  "updated_at": "2025-12-26T17:34:21.031077",
  "symbols": {
    "function_test_out_edge_correct_direction_779": {
      "name": "test_out_edge_correct_direction",
      "type": "function",
      "start_line": 779,
      "end_line": 799,
      "content_hash": "cf615e46b090a70192498e563b7c01e76462b8b7",
      "content": "    fn test_out_edge_correct_direction() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                friends <- person::Out<Knows>\n                RETURN friends\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_edge_correct_direction_800": {
      "name": "test_in_edge_correct_direction",
      "type": "function",
      "start_line": 800,
      "end_line": 820,
      "content_hash": "7988dca78bea33d0cb87e27066f5bf8e76b1b5a9",
      "content": "    fn test_in_edge_correct_direction() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Follows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                followers <- person::In<Follows>\n                RETURN followers\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_wrong_node_type_821": {
      "name": "test_out_edge_wrong_node_type",
      "type": "function",
      "start_line": 821,
      "end_line": 846,
      "content_hash": "5a16e2d7ab6e5608e5d064dd07ebf57162b373f6",
      "content": "    fn test_out_edge_wrong_node_type() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test(id: ID) =>\n                company <- N<Company>(id)\n                employees <- company::Out<WorksAt>\n                RETURN employees\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E207));\n    }\n\n    // ============================================================================\n    // Edge-to-Node Conversion Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_to_target_node_847": {
      "name": "test_out_edge_to_target_node",
      "type": "function",
      "start_line": 847,
      "end_line": 869,
      "content_hash": "a38ad92de6f7a3b08852b80257f7818f65317e5c",
      "content": "    fn test_out_edge_to_target_node() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<WorksAt>\n                companies <- edges::ToN\n                RETURN companies\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_edge_to_source_node_870": {
      "name": "test_out_edge_to_source_node",
      "type": "function",
      "start_line": 870,
      "end_line": 892,
      "content_hash": "9380b6860e9e3858f41288e12433e5be825b173d",
      "content": "    fn test_out_edge_to_source_node() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<WorksAt>\n                source <- edges::FromN\n                RETURN source\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_edge_to_source_node_893": {
      "name": "test_in_edge_to_source_node",
      "type": "function",
      "start_line": 893,
      "end_line": 918,
      "content_hash": "33d5b4f51213e1e1a2b7164091c7f320d653b09d",
      "content": "    fn test_in_edge_to_source_node() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Follows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::InE<Follows>\n                followers <- edges::FromN\n                RETURN followers\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    // ============================================================================\n    // Multi-Type Graph Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_multi_type_traversal_919": {
      "name": "test_multi_type_traversal",
      "type": "function",
      "start_line": 919,
      "end_line": 942,
      "content_hash": "35611dbef923a02510752911da4015041fb455a7",
      "content": "    fn test_multi_type_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n            E::LocatedIn { From: Company, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                companies <- person::Out<WorksAt>\n                locations <- companies::Out<LocatedIn>\n                RETURN locations\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_bidirectional_edges_943": {
      "name": "test_bidirectional_edges",
      "type": "function",
      "start_line": 943,
      "end_line": 968,
      "content_hash": "766766b1b493702098a8aeab612c298932eba137",
      "content": "    fn test_bidirectional_edges() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                outgoing <- person::Out<Knows>\n                incoming <- person::In<Knows>\n                RETURN outgoing, incoming\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    // ============================================================================\n    // Edge Type Validation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_undeclared_edge_in_out_traversal_969": {
      "name": "test_undeclared_edge_in_out_traversal",
      "type": "function",
      "start_line": 969,
      "end_line": 988,
      "content_hash": "aa94260a7db937a9919f117ccf00b5e704ec4d1b",
      "content": "    fn test_undeclared_edge_in_out_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                related <- person::Out<UndeclaredEdge>\n                RETURN related\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E102));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_undeclared_edge_in_out_e_traversal_989": {
      "name": "test_undeclared_edge_in_out_e_traversal",
      "type": "function",
      "start_line": 989,
      "end_line": 1012,
      "content_hash": "4362ae64aa5a782154646db62e3d52bc1fd2875e",
      "content": "    fn test_undeclared_edge_in_out_e_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<UndeclaredEdge>\n                RETURN edges\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E102));\n    }\n\n    // ============================================================================\n    // Complex Traversal Pattern Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_chain_from_to_1013": {
      "name": "test_edge_chain_from_to",
      "type": "function",
      "start_line": 1013,
      "end_line": 1037,
      "content_hash": "67bef1609509803eba223a728d7537262c32ef99",
      "content": "    fn test_edge_chain_from_to() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test(personId: ID, companyId: ID) =>\n                person <- N<Person>(personId)\n                company <- N<Company>(companyId)\n                personEdges <- person::OutE<WorksAt>\n                companyEdges <- company::InE<WorksAt>\n                personCompanies <- personEdges::ToN\n                companyPeople <- companyEdges::FromN\n                RETURN personCompanies, companyPeople\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}