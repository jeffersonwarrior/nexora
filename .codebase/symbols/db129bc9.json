{
  "file_path": "/work/internal/cmd/root_test.go",
  "file_hash": "b6b723c494710660b286943ef6a6f3d2c95e408d",
  "updated_at": "2025-12-26T17:34:23.283699",
  "symbols": {
    "function_TestResolveCwd_14": {
      "name": "TestResolveCwd",
      "type": "function",
      "start_line": 14,
      "end_line": 55,
      "content_hash": "c1c64240ffb09999cf7ca7dd0f9320ffd8635d37",
      "content": "func TestResolveCwd(t *testing.T) {\n\t// Save original directory\n\toriginalDir, err := os.Getwd()\n\trequire.NoError(t, err)\n\tdefer os.Chdir(originalDir)\n\n\tt.Run(\"Returns current directory when no cwd flag\", func(t *testing.T) {\n\t\tcmd := &cobra.Command{}\n\t\tcmd.Flags().String(\"cwd\", \"\", \"\")\n\n\t\tcwd, err := ResolveCwd(cmd)\n\t\trequire.NoError(t, err)\n\t\tassert.NotEmpty(t, cwd)\n\t})\n\n\tt.Run(\"Changes to specified directory\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\t\tcmd := &cobra.Command{}\n\t\tcmd.Flags().String(\"cwd\", \"\", \"\")\n\t\tcmd.Flags().Set(\"cwd\", tmpDir)\n\n\t\tcwd, err := ResolveCwd(cmd)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tmpDir, cwd)\n\n\t\t// Verify we're actually in that directory\n\t\tcurrentDir, err := os.Getwd()\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tmpDir, currentDir)\n\t})\n\n\tt.Run(\"Returns error for non-existent directory\", func(t *testing.T) {\n\t\tcmd := &cobra.Command{}\n\t\tcmd.Flags().String(\"cwd\", \"\", \"\")\n\t\tcmd.Flags().Set(\"cwd\", \"/non/existent/path/12345\")\n\n\t\t_, err := ResolveCwd(cmd)\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"failed to change directory\")\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCreateDotNexoraDir_56": {
      "name": "TestCreateDotNexoraDir",
      "type": "function",
      "start_line": 56,
      "end_line": 105,
      "content_hash": "31c836f7ba6d2b5d0e3806be124633ee5a8d2b44",
      "content": "func TestCreateDotNexoraDir(t *testing.T) {\n\tt.Run(\"Creates directory successfully\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\t\tnexoraDir := filepath.Join(tmpDir, \".nexora\")\n\n\t\terr := createDotNexoraDir(nexoraDir)\n\t\trequire.NoError(t, err)\n\n\t\t// Verify directory exists\n\t\tinfo, err := os.Stat(nexoraDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, info.IsDir())\n\t})\n\n\tt.Run(\"Creates .gitignore file\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\t\tnexoraDir := filepath.Join(tmpDir, \".nexora\")\n\n\t\terr := createDotNexoraDir(nexoraDir)\n\t\trequire.NoError(t, err)\n\n\t\t// Verify .gitignore exists\n\t\tgitignorePath := filepath.Join(nexoraDir, \".gitignore\")\n\t\tcontent, err := os.ReadFile(gitignorePath)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"*\\n\", string(content))\n\t})\n\n\tt.Run(\"Does not overwrite existing .gitignore\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\t\tnexoraDir := filepath.Join(tmpDir, \".nexora\")\n\n\t\t// Create directory and custom .gitignore\n\t\terr := os.MkdirAll(nexoraDir, 0o700)\n\t\trequire.NoError(t, err)\n\t\tgitignorePath := filepath.Join(nexoraDir, \".gitignore\")\n\t\terr = os.WriteFile(gitignorePath, []byte(\"custom\\n\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Call createDotNexoraDir\n\t\terr = createDotNexoraDir(nexoraDir)\n\t\trequire.NoError(t, err)\n\n\t\t// Verify .gitignore wasn't overwritten\n\t\tcontent, err := os.ReadFile(gitignorePath)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"custom\\n\", string(content))\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestShouldQueryTerminalVersion_106": {
      "name": "TestShouldQueryTerminalVersion",
      "type": "function",
      "start_line": 106,
      "end_line": 156,
      "content_hash": "f6d2c3fbdd6a8d1b23ad940586ef071f81dbcd0d",
      "content": "func TestShouldQueryTerminalVersion(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tenv      []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"No TERM_PROGRAM and no SSH_TTY\",\n\t\t\tenv:      []string{\"TERM=xterm\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Apple Terminal\",\n\t\t\tenv:      []string{\"TERM_PROGRAM=Apple_Terminal\", \"TERM=xterm\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"SSH session\",\n\t\t\tenv:      []string{\"SSH_TTY=/dev/pts/0\", \"TERM=xterm\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Kitty terminal\",\n\t\t\tenv:      []string{\"TERM=xterm-kitty\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Alacritty terminal\",\n\t\t\tenv:      []string{\"TERM=alacritty\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"WezTerm terminal\",\n\t\t\tenv:      []string{\"TERM=wezterm\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Ghostty terminal\",\n\t\t\tenv:      []string{\"TERM=xterm-ghostty\"},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tenv := uv.Environ(tt.env)\n\t\t\tresult := shouldQueryTerminalVersion(env)\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}