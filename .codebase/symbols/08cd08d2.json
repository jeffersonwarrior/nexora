{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/edge_case_tests.rs",
  "file_hash": "aad4f90b4cd71d86df84de1a45611a5d809d69d2",
  "updated_at": "2025-12-26T17:34:23.050850",
  "symbols": {
    "function_test_node_with_100_properties_27": {
      "name": "test_node_with_100_properties",
      "type": "function",
      "start_line": 27,
      "end_line": 48,
      "content_hash": "b475820112242ff85ae3f9eae43892ba886bac2c",
      "content": "    fn test_node_with_100_properties() {\n        let arena = Bump::new();\n        let id = 11111u128;\n\n        let props: Vec<(&str, Value)> = (0..100)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"property_{}\", i));\n                (key, Value::I32(i))\n            })\n            .collect();\n\n        let node = create_arena_node(&arena, id, \"many_props\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.properties.unwrap().len(), 100);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_200_properties_49": {
      "name": "test_edge_with_200_properties",
      "type": "function",
      "start_line": 49,
      "end_line": 69,
      "content_hash": "85d35b1780df4615798afb909bc64e0c35877671",
      "content": "    fn test_edge_with_200_properties() {\n        let arena = Bump::new();\n        let id = 22222u128;\n\n        let props: Vec<(&str, Value)> = (0..200)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"edge_prop_{}\", i));\n                (key, Value::String(format!(\"value_{}\", i)))\n            })\n            .collect();\n\n        let edge = create_arena_edge(&arena, id, \"many_props\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().properties.unwrap().len(), 200);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_500_properties_70": {
      "name": "test_vector_with_500_properties",
      "type": "function",
      "start_line": 70,
      "end_line": 92,
      "content_hash": "42a8884928142c73db5edb3995f98d11cab2bfdb",
      "content": "    fn test_vector_with_500_properties() {\n        let arena = Bump::new();\n        let id = 33333u128;\n        let data = vec![1.0, 2.0, 3.0];\n\n        let props: Vec<(&str, Value)> = (0..500)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"vec_prop_{}\", i));\n                (key, Value::U64(i as u64))\n            })\n            .collect();\n\n        let vector = create_arena_vector(&arena, id, \"many_props\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().properties.unwrap().len(), 500);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_1000_properties_93": {
      "name": "test_node_with_1000_properties",
      "type": "function",
      "start_line": 93,
      "end_line": 117,
      "content_hash": "292b4ab9a003c8b224ea00df8fa2cf610f8c0357",
      "content": "    fn test_node_with_1000_properties() {\n        let arena = Bump::new();\n        let id = 44444u128;\n\n        let props: Vec<(&str, Value)> = (0..1000)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"k{}\", i));\n                (key, Value::I64(i as i64))\n            })\n            .collect();\n\n        let node = create_arena_node(&arena, id, \"stress\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().properties.unwrap().len(), 1000);\n    }\n\n    // ========================================================================\n    // VERY LONG STRINGS AND LABELS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_1kb_label_118": {
      "name": "test_node_with_1kb_label",
      "type": "function",
      "start_line": 118,
      "end_line": 132,
      "content_hash": "6e8a66e53d2089b782552ca8edec2f0d90d5c2f3",
      "content": "    fn test_node_with_1kb_label() {\n        let arena = Bump::new();\n        let id = 55555u128;\n        let long_label = \"x\".repeat(1024);\n\n        let node = create_simple_node(&arena, id, &long_label);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label.len(), 1024);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_10kb_label_133": {
      "name": "test_edge_with_10kb_label",
      "type": "function",
      "start_line": 133,
      "end_line": 147,
      "content_hash": "363ad0ed6325b3c63baf49cae60ba453c9917f2a",
      "content": "    fn test_edge_with_10kb_label() {\n        let arena = Bump::new();\n        let id = 66666u128;\n        let very_long_label = \"EdgeLabel\".repeat(1142); // ~10KB\n\n        let edge = create_simple_edge(&arena, id, &very_long_label, 1, 2);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert!(result.unwrap().label.len() > 10000);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_long_label_148": {
      "name": "test_vector_with_long_label",
      "type": "function",
      "start_line": 148,
      "end_line": 164,
      "content_hash": "1fa26016480b18980e5043d197d7fc838a792784",
      "content": "    fn test_vector_with_long_label() {\n        let arena = Bump::new();\n        let id = 77777u128;\n        let long_label = \"Vector\".repeat(500);\n        let data = vec![1.0, 2.0];\n\n        let vector = create_simple_vector(&arena, id, &long_label, &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n        assert!(result.unwrap().label.len() > 2000);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_very_long_property_value_165": {
      "name": "test_node_with_very_long_property_value",
      "type": "function",
      "start_line": 165,
      "end_line": 179,
      "content_hash": "1242d15ced9fb80fc36bbf629c7e86d88bb7edb0",
      "content": "    fn test_node_with_very_long_property_value() {\n        let arena = Bump::new();\n        let id = 88888u128;\n        let long_value = \"PropertyValue\".repeat(1000); // ~13KB\n\n        let props = vec![(\"data\", Value::String(long_value.clone()))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_multiple_long_strings_180": {
      "name": "test_edge_with_multiple_long_strings",
      "type": "function",
      "start_line": 180,
      "end_line": 202,
      "content_hash": "7a98d5f37bfb54cccccad78f9b6738507ea5874e",
      "content": "    fn test_edge_with_multiple_long_strings() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        let props = vec![\n            (\"str1\", Value::String(\"A\".repeat(5000))),\n            (\"str2\", Value::String(\"B\".repeat(5000))),\n            (\"str3\", Value::String(\"C\".repeat(5000))),\n        ];\n\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // UNICODE AND SPECIAL CHARACTERS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_emoji_label_203": {
      "name": "test_node_with_emoji_label",
      "type": "function",
      "start_line": 203,
      "end_line": 216,
      "content_hash": "37d49c888f2d5edcde56287b70c7324845e5df70",
      "content": "    fn test_node_with_emoji_label() {\n        let arena = Bump::new();\n        let id = 111000u128;\n\n        let node = create_simple_node(&arena, id, \"\ud83d\ude80\ud83d\udd25\ud83d\udcaf\ud83c\udf89\u2b50\");\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label, \"\ud83d\ude80\ud83d\udd25\ud83d\udcaf\ud83c\udf89\u2b50\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_mixed_unicode_217": {
      "name": "test_edge_with_mixed_unicode",
      "type": "function",
      "start_line": 217,
      "end_line": 231,
      "content_hash": "f900a36b284eec898ace87ed359879b6c3d27436",
      "content": "    fn test_edge_with_mixed_unicode() {\n        let arena = Bump::new();\n        let id = 222000u128;\n\n        let mixed = \"Hello\u4e16\u754c\u041f\u0440\u0438\u0432\u0435\u0442\ud83c\udf0d\u0645\u0631\u062d\u0628\u0627\";\n        let edge = create_simple_edge(&arena, id, mixed, 1, 2);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label, mixed);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_unicode_properties_232": {
      "name": "test_vector_with_unicode_properties",
      "type": "function",
      "start_line": 232,
      "end_line": 252,
      "content_hash": "29a0addd66ca46cb691b99483c4cfbf6313f8969",
      "content": "    fn test_vector_with_unicode_properties() {\n        let arena = Bump::new();\n        let id = 333000u128;\n        let data = vec![1.0];\n\n        let props = vec![\n            (\"\u540d\u524d\", Value::String(\"\u5024\".to_string())),\n            (\"emoji_key\ud83d\udd11\", Value::String(\"emoji_value\ud83c\udfaf\".to_string())),\n            (\"\u041a\u043b\u044e\u0447\", Value::String(\"\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435\".to_string())),\n        ];\n\n        let vector = create_arena_vector(&arena, id, \"unicode\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_all_whitespace_label_253": {
      "name": "test_node_with_all_whitespace_label",
      "type": "function",
      "start_line": 253,
      "end_line": 267,
      "content_hash": "d6cdee05e51559bf70fd4092337d83654cf3477a",
      "content": "    fn test_node_with_all_whitespace_label() {\n        let arena = Bump::new();\n        let id = 444000u128;\n\n        let whitespace = \"   \\t\\n\\r   \";\n        let node = create_simple_node(&arena, id, whitespace);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label, whitespace);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_special_characters_268": {
      "name": "test_edge_with_special_characters",
      "type": "function",
      "start_line": 268,
      "end_line": 282,
      "content_hash": "3231eaa882c16d521eb535106044a8946d5bfd21",
      "content": "    fn test_edge_with_special_characters() {\n        let arena = Bump::new();\n        let id = 555000u128;\n\n        let special = r#\"!@#$%^&*()[]{}|\\\\;:'\",.<>?/~`\"#;\n        let edge = create_simple_edge(&arena, id, special, 1, 2);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label, special);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_null_char_in_string_283": {
      "name": "test_node_with_null_char_in_string",
      "type": "function",
      "start_line": 283,
      "end_line": 301,
      "content_hash": "c3654cd6ec443b05dfba8b5ac8a50addaff06dbf",
      "content": "    fn test_node_with_null_char_in_string() {\n        let arena = Bump::new();\n        let id = 666000u128;\n\n        let with_null = \"before\\0after\";\n        let node = create_simple_node(&arena, id, with_null);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().label, with_null);\n    }\n\n    // ========================================================================\n    // DEEPLY NESTED VALUES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_deeply_nested_arrays_302": {
      "name": "test_node_with_deeply_nested_arrays",
      "type": "function",
      "start_line": 302,
      "end_line": 321,
      "content_hash": "0dcbe8f47bd45df3890e09701a9d6524b8a1d739",
      "content": "    fn test_node_with_deeply_nested_arrays() {\n        let arena = Bump::new();\n        let id = 777000u128;\n\n        // Create 10-level nested array\n        let mut nested = Value::I32(42);\n        for _ in 0..10 {\n            nested = Value::Array(vec![nested]);\n        }\n\n        let props = vec![(\"deep\", nested)];\n        let node = create_arena_node(&arena, id, \"nested\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_deeply_nested_objects_322": {
      "name": "test_edge_with_deeply_nested_objects",
      "type": "function",
      "start_line": 322,
      "end_line": 343,
      "content_hash": "ad0cade6beed46511539ca401566a22246c7ab38",
      "content": "    fn test_edge_with_deeply_nested_objects() {\n        let arena = Bump::new();\n        let id = 888000u128;\n\n        // Create nested objects\n        let mut nested = Value::String(\"deep_value\".to_string());\n        for i in 0..10 {\n            let mut map = HashMap::new();\n            map.insert(format!(\"level_{}\", i), nested);\n            nested = Value::Object(map);\n        }\n\n        let props = vec![(\"nested_obj\", nested)];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_mixed_nested_structures_344": {
      "name": "test_vector_with_mixed_nested_structures",
      "type": "function",
      "start_line": 344,
      "end_line": 377,
      "content_hash": "be55cb64263d496fd019e112cd5ed529ca587d78",
      "content": "    fn test_vector_with_mixed_nested_structures() {\n        let arena = Bump::new();\n        let id = 999000u128;\n        let data = vec![1.0];\n\n        // Mix of arrays and objects\n        let mut map = HashMap::new();\n        map.insert(\n            \"array_in_object\".to_string(),\n            Value::Array(vec![\n                Value::I32(1),\n                Value::Object({\n                    let mut inner = HashMap::new();\n                    inner.insert(\"inner_key\".to_string(), Value::String(\"inner_value\".to_string()));\n                    inner\n                }),\n            ]),\n        );\n\n        let props = vec![(\"complex\", Value::Object(map))];\n        let vector = create_arena_vector(&arena, id, \"complex\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // EMPTY AND NULL EDGE CASES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_empty_label_empty_properties_378": {
      "name": "test_node_empty_label_empty_properties",
      "type": "function",
      "start_line": 378,
      "end_line": 393,
      "content_hash": "32aabee384e387f26addfc142b48d3652627e93c",
      "content": "    fn test_node_empty_label_empty_properties() {\n        let arena = Bump::new();\n        let id = 100100u128;\n\n        let node = create_simple_node(&arena, id, \"\");\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.label, \"\");\n        assert!(deserialized.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_zero_node_ids_394": {
      "name": "test_edge_zero_node_ids",
      "type": "function",
      "start_line": 394,
      "end_line": 409,
      "content_hash": "e0de83ce38ccc8c93b20e728dafdd382e89842e9",
      "content": "    fn test_edge_zero_node_ids() {\n        let arena = Bump::new();\n        let id = 200200u128;\n\n        let edge = create_simple_edge(&arena, id, \"test\", 0, 0);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.from_node, 0);\n        assert_eq!(deserialized.to_node, 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_empty_value_410": {
      "name": "test_node_with_empty_value",
      "type": "function",
      "start_line": 410,
      "end_line": 428,
      "content_hash": "949ecc4571262c39ef3f867ba66e56c3e6ce2b75",
      "content": "    fn test_node_with_empty_value() {\n        let arena = Bump::new();\n        let id = 300300u128;\n\n        let props = vec![\n            (\"empty1\", Value::Empty),\n            (\"empty2\", Value::Empty),\n            (\"normal\", Value::I32(42)),\n        ];\n\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_empty_array_property_429": {
      "name": "test_edge_with_empty_array_property",
      "type": "function",
      "start_line": 429,
      "end_line": 442,
      "content_hash": "3e16423ba46e102543dbf278359c60c599f27383",
      "content": "    fn test_edge_with_empty_array_property() {\n        let arena = Bump::new();\n        let id = 400400u128;\n\n        let props = vec![(\"empty_array\", Value::Array(vec![]))];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_empty_object_property_443": {
      "name": "test_vector_with_empty_object_property",
      "type": "function",
      "start_line": 443,
      "end_line": 462,
      "content_hash": "7365e4bf3536e853752687a449fc50962869ee1a",
      "content": "    fn test_vector_with_empty_object_property() {\n        let arena = Bump::new();\n        let id = 500500u128;\n        let data = vec![1.0];\n\n        let props = vec![(\"empty_obj\", Value::Object(HashMap::new()))];\n        let vector = create_arena_vector(&arena, id, \"test\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // NUMERIC PRECISION AND BOUNDARY TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_all_numeric_extremes_463": {
      "name": "test_node_with_all_numeric_extremes",
      "type": "function",
      "start_line": 463,
      "end_line": 491,
      "content_hash": "c3b8b62cd2b359638a1187f972fe634bbcc7e646",
      "content": "    fn test_node_with_all_numeric_extremes() {\n        let arena = Bump::new();\n        let id = 600600u128;\n\n        let props = vec![\n            (\"i8_min\", Value::I8(i8::MIN)),\n            (\"i8_max\", Value::I8(i8::MAX)),\n            (\"i16_min\", Value::I16(i16::MIN)),\n            (\"i16_max\", Value::I16(i16::MAX)),\n            (\"i32_min\", Value::I32(i32::MIN)),\n            (\"i32_max\", Value::I32(i32::MAX)),\n            (\"i64_min\", Value::I64(i64::MIN)),\n            (\"i64_max\", Value::I64(i64::MAX)),\n            (\"u8_max\", Value::U8(u8::MAX)),\n            (\"u16_max\", Value::U16(u16::MAX)),\n            (\"u32_max\", Value::U32(u32::MAX)),\n            (\"u64_max\", Value::U64(u64::MAX)),\n            (\"u128_max\", Value::U128(u128::MAX)),\n        ];\n\n        let node = create_arena_node(&arena, id, \"numeric_extremes\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_floating_point_extremes_492": {
      "name": "test_edge_with_floating_point_extremes",
      "type": "function",
      "start_line": 492,
      "end_line": 513,
      "content_hash": "4dc849ad56d092cf331aedb7711cf02f5c94bcd9",
      "content": "    fn test_edge_with_floating_point_extremes() {\n        let arena = Bump::new();\n        let id = 700700u128;\n\n        let props = vec![\n            (\"f32_min\", Value::F32(f32::MIN)),\n            (\"f32_max\", Value::F32(f32::MAX)),\n            (\"f32_epsilon\", Value::F32(f32::EPSILON)),\n            (\"f64_min\", Value::F64(f64::MIN)),\n            (\"f64_max\", Value::F64(f64::MAX)),\n            (\"f64_epsilon\", Value::F64(f64::EPSILON)),\n        ];\n\n        let edge = create_arena_edge(&arena, id, \"float_extremes\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_subnormal_numbers_514": {
      "name": "test_vector_with_subnormal_numbers",
      "type": "function",
      "start_line": 514,
      "end_line": 535,
      "content_hash": "59ab4fb1de8d25ffb9da7247337f800d01d181ec",
      "content": "    fn test_vector_with_subnormal_numbers() {\n        let arena = Bump::new();\n        let id = 800800u128;\n\n        // Subnormal (denormalized) numbers\n        let data = vec![\n            f64::MIN_POSITIVE,\n            f64::MIN_POSITIVE / 2.0,\n            1e-308,\n            1e-320,\n        ];\n\n        let vector = create_simple_vector(&arena, id, \"subnormal\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_zero_positive_and_negative_536": {
      "name": "test_vector_with_zero_positive_and_negative",
      "type": "function",
      "start_line": 536,
      "end_line": 554,
      "content_hash": "4ce1410f8e2192d29d24dcd52a3a6a72fd8939fc",
      "content": "    fn test_vector_with_zero_positive_and_negative() {\n        let arena = Bump::new();\n        let id = 900900u128;\n\n        let data = vec![0.0, -0.0, 0.0, -0.0];\n        let vector = create_simple_vector(&arena, id, \"zeros\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // PROPERTY KEY EDGE CASES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_single_char_property_keys_555": {
      "name": "test_node_with_single_char_property_keys",
      "type": "function",
      "start_line": 555,
      "end_line": 574,
      "content_hash": "f53cdaad6e2f7a9650cda72763d62fb646730f9e",
      "content": "    fn test_node_with_single_char_property_keys() {\n        let arena = Bump::new();\n        let id = 101101u128;\n\n        let props = vec![\n            (\"a\", Value::I32(1)),\n            (\"b\", Value::I32(2)),\n            (\"c\", Value::I32(3)),\n            (\"d\", Value::I32(4)),\n        ];\n\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_very_long_property_keys_575": {
      "name": "test_edge_with_very_long_property_keys",
      "type": "function",
      "start_line": 575,
      "end_line": 593,
      "content_hash": "a7af82bc2b02ef599734f99ea31e6faffbe017a0",
      "content": "    fn test_edge_with_very_long_property_keys() {\n        let arena = Bump::new();\n        let id = 202202u128;\n\n        let long_key = \"property_key_\".repeat(100); // ~1.3KB key\n        let key_ref: &str = arena.alloc_str(&long_key);\n        let props = vec![\n            (key_ref, Value::String(\"value\".to_string())),\n        ];\n\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_numeric_string_keys_594": {
      "name": "test_vector_with_numeric_string_keys",
      "type": "function",
      "start_line": 594,
      "end_line": 618,
      "content_hash": "200b10bb32d3cbc12e3902fb302f24ff991fdfb5",
      "content": "    fn test_vector_with_numeric_string_keys() {\n        let arena = Bump::new();\n        let id = 303303u128;\n        let data = vec![1.0];\n\n        let props = vec![\n            (\"0\", Value::String(\"zero\".to_string())),\n            (\"1\", Value::String(\"one\".to_string())),\n            (\"123\", Value::String(\"one-two-three\".to_string())),\n        ];\n\n        let vector = create_arena_vector(&arena, id, \"numeric_keys\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // LARGE ARRAY PROPERTY VALUES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_large_array_property_619": {
      "name": "test_node_with_large_array_property",
      "type": "function",
      "start_line": 619,
      "end_line": 636,
      "content_hash": "86eac4744b974b141936c20d720b90ddc580038d",
      "content": "    fn test_node_with_large_array_property() {\n        let arena = Bump::new();\n        let id = 404404u128;\n\n        let large_array = Value::Array(\n            (0..1000).map(|i| Value::I32(i)).collect()\n        );\n\n        let props = vec![(\"big_array\", large_array)];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_array_of_strings_637": {
      "name": "test_edge_with_array_of_strings",
      "type": "function",
      "start_line": 637,
      "end_line": 656,
      "content_hash": "30570e54479d75eece5c14fe5bde8320ff26602a",
      "content": "    fn test_edge_with_array_of_strings() {\n        let arena = Bump::new();\n        let id = 505505u128;\n\n        let string_array = Value::Array(\n            (0..100)\n                .map(|i| Value::String(format!(\"string_{}\", i)))\n                .collect()\n        );\n\n        let props = vec![(\"strings\", string_array)];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_mixed_type_array_657": {
      "name": "test_vector_with_mixed_type_array",
      "type": "function",
      "start_line": 657,
      "end_line": 685,
      "content_hash": "ffd1548097cf22fd38afeb1a4ff3255695a55b65",
      "content": "    fn test_vector_with_mixed_type_array() {\n        let arena = Bump::new();\n        let id = 606606u128;\n        let data = vec![1.0];\n\n        let mixed_array = Value::Array(vec![\n            Value::String(\"text\".to_string()),\n            Value::I32(42),\n            Value::F64(3.14),\n            Value::Boolean(true),\n            Value::Empty,\n            Value::Array(vec![Value::I32(1), Value::I32(2)]),\n        ]);\n\n        let props = vec![(\"mixed\", mixed_array)];\n        let vector = create_arena_vector(&arena, id, \"test\", 1, false, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n\n    // ========================================================================\n    // VECTOR DIMENSION EDGE CASES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_8192_dimensions_686": {
      "name": "test_vector_with_8192_dimensions",
      "type": "function",
      "start_line": 686,
      "end_line": 701,
      "content_hash": "a4237818c7b171f69cb7b187e77c83ce71d61633",
      "content": "    fn test_vector_with_8192_dimensions() {\n        let arena = Bump::new();\n        let id = 707707u128;\n        let data: Vec<f64> = (0..8192).map(|i| (i as f64) * 0.0001).collect();\n\n        let vector = create_simple_vector(&arena, id, \"8k_dims\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().data.len(), 8192);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_all_zero_data_702": {
      "name": "test_vector_with_all_zero_data",
      "type": "function",
      "start_line": 702,
      "end_line": 718,
      "content_hash": "8e104d34f4be462e16c2725c0589b52611aed9d5",
      "content": "    fn test_vector_with_all_zero_data() {\n        let arena = Bump::new();\n        let id = 808808u128;\n        let data = vec![0.0; 1536];\n\n        let vector = create_simple_vector(&arena, id, \"zeros\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert!(deserialized.data.iter().all(|&v| v == 0.0));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_all_same_value_719": {
      "name": "test_vector_with_all_same_value",
      "type": "function",
      "start_line": 719,
      "end_line": 739,
      "content_hash": "767a296d7cd563d5960e7a314bb922c08f1076ae",
      "content": "    fn test_vector_with_all_same_value() {\n        let arena = Bump::new();\n        let id = 909909u128;\n        let data = vec![42.42; 512];\n\n        let vector = create_simple_vector(&arena, id, \"constant\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert!(deserialized.data.iter().all(|&v| (v - 42.42).abs() < 1e-10));\n    }\n\n    // ========================================================================\n    // COMBINATION EDGE CASES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_max_everything_740": {
      "name": "test_node_max_everything",
      "type": "function",
      "start_line": 740,
      "end_line": 759,
      "content_hash": "134c20b52dd0398e2e0e47d4f618652887bb9606",
      "content": "    fn test_node_max_everything() {\n        let arena = Bump::new();\n        let id = u128::MAX;\n\n        let props: Vec<(&str, Value)> = (0..500)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"property_{}\", i));\n                (key, Value::String(format!(\"value_{}\", i).repeat(10)))\n            })\n            .collect();\n\n        let node = create_arena_node(&arena, id, &\"Label\".repeat(100), 255, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_max_everything_760": {
      "name": "test_edge_max_everything",
      "type": "function",
      "start_line": 760,
      "end_line": 787,
      "content_hash": "6a54a777dfa2b4a15d66fdd92549eee8a3637576",
      "content": "    fn test_edge_max_everything() {\n        let arena = Bump::new();\n        let id = u128::MAX;\n\n        let props: Vec<(&str, Value)> = (0..300)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"k{}\", i));\n                (key, Value::I64(i64::MAX - i as i64))\n            })\n            .collect();\n\n        let edge = create_arena_edge(\n            &arena,\n            id,\n            &\"E\".repeat(500),\n            255,\n            u128::MAX - 1,\n            u128::MAX - 2,\n            props,\n        );\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_max_complexity_788": {
      "name": "test_vector_max_complexity",
      "type": "function",
      "start_line": 788,
      "end_line": 808,
      "content_hash": "2c4781c6d6745aa7763fb44fbf61846531c8f529",
      "content": "    fn test_vector_max_complexity() {\n        let arena = Bump::new();\n        let id = u128::MAX;\n        let data: Vec<f64> = (0..2048).map(|i| (i as f64).sin()).collect();\n\n        let props: Vec<(&str, Value)> = (0..200)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"prop_{}\", i));\n                (key, Value::String(format!(\"\ud83d\ude80{}\", i).repeat(20)))\n            })\n            .collect();\n\n        let vector = create_arena_vector(&arena, id, &\"Vec\".repeat(200), 255, true, 0, &data, props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}