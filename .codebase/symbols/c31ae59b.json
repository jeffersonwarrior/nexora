{
  "file_path": "/work/internal/agent/agent_test.go",
  "file_hash": "3891249c55972319ac1a1cf832509676ff502f88",
  "updated_at": "2025-12-26T17:34:20.262809",
  "symbols": {
    "function_getModels_27": {
      "name": "getModels",
      "type": "function",
      "start_line": 27,
      "end_line": 34,
      "content_hash": "29f7104182238e45a6e03b304ab78f4e36021b4e",
      "content": "func getModels(t *testing.T, r *vcr.Recorder, pair modelPair) (fantasy.LanguageModel, fantasy.LanguageModel) {\n\tlarge, err := pair.largeModel(t, r)\n\trequire.NoError(t, err)\n\tsmall, err := pair.smallModel(t, r)\n\trequire.NoError(t, err)\n\treturn large, small\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setupAgent_35": {
      "name": "setupAgent",
      "type": "function",
      "start_line": 35,
      "end_line": 45,
      "content_hash": "7c97b528aed657bf9165758d63a672500031717f",
      "content": "func setupAgent(t *testing.T, pair modelPair) (SessionAgent, fakeEnv) {\n\tr := vcr.NewRecorder(t)\n\tlarge, small := getModels(t, r, pair)\n\tenv := testEnv(t)\n\n\tcreateSimpleGoProject(t, env.workingDir)\n\tagent, err := coderAgent(r, env, large, small)\n\trequire.NoError(t, err)\n\treturn agent, env\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_hasAPIKey_46": {
      "name": "hasAPIKey",
      "type": "function",
      "start_line": 46,
      "end_line": 55,
      "content_hash": "ec444671b0a8afea3342652a0c6b44d8862c392f",
      "content": "func hasAPIKey(provider string) bool {\n\tkeys := map[string]string{\n\t\t\"anthropic\":   os.Getenv(\"NEXORA_ANTHROPIC_API_KEY\"),\n\t\t\"openai\":      os.Getenv(\"NEXORA_OPENAI_API_KEY\"),\n\t\t\"openrouter\":   os.Getenv(\"NEXORA_OPENROUTER_API_KEY\"),\n\t\t\"zai\":         os.Getenv(\"NEXORA_ZAI_API_KEY\"),\n\t}\n\treturn keys[provider] != \"\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCoderAgent_56": {
      "name": "TestCoderAgent",
      "type": "function",
      "start_line": 56,
      "end_line": 633,
      "content_hash": "72c1b0cb106d19a9cc31d2752b4fc686ec95e340",
      "content": "func TestCoderAgent(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"skipping on windows for now\")\n\t}\n\n\t// Check if at least one provider has API keys\n\thasAnyKey := hasAPIKey(\"anthropic\") || hasAPIKey(\"openai\") || hasAPIKey(\"openrouter\") || hasAPIKey(\"zai\")\n\tif !hasAnyKey {\n\t\tt.Skip(\"Agent tests skipped - no API keys set (set NEXORA_ANTHROPIC_API_KEY, NEXORA_OPENAI_API_KEY, etc.)\")\n\t}\n\n\tfor _, pair := range modelPairs {\n\t\tt.Run(pair.name, func(t *testing.T) {\n\t\t\tt.Run(\"simple test\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"Hello\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t// Should have the agent and user message\n\t\t\t\tassert.Equal(t, len(msgs), 2)\n\t\t\t})\n\t\t\tt.Run(\"read a file\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"Read the go mod\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tfoundFile := false\n\t\t\t\tvar tcID string\n\t\t\tout:\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.ViewToolName {\n\t\t\t\t\t\t\t\ttcID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == tcID {\n\t\t\t\t\t\t\t\tif strings.Contains(tr.Content, \"module example.com/testproject\") {\n\t\t\t\t\t\t\t\t\tfoundFile = true\n\t\t\t\t\t\t\t\t\tbreak out\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trequire.True(t, foundFile)\n\t\t\t})\n\t\t\tt.Run(\"update a file\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"update the main.go file by changing the print to say hello from nexora\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundRead := false\n\t\t\t\tfoundWrite := false\n\t\t\t\tvar readTCID, writeTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.ViewToolName {\n\t\t\t\t\t\t\t\treadTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tc.Name == tools.EditToolName || tc.Name == tools.WriteToolName {\n\t\t\t\t\t\t\t\twriteTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == readTCID {\n\t\t\t\t\t\t\t\tfoundRead = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tr.ToolCallID == writeTCID {\n\t\t\t\t\t\t\t\tfoundWrite = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundRead, \"Expected to find a read operation\")\n\t\t\t\trequire.True(t, foundWrite, \"Expected to find a write operation\")\n\n\t\t\t\tmainGoPath := filepath.Join(env.workingDir, \"main.go\")\n\t\t\t\tcontent, err := os.ReadFile(mainGoPath)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Contains(t, strings.ToLower(string(content)), \"hello from nexora\")\n\t\t\t})\n\t\t\tt.Run(\"bash tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use bash to create a file named test.txt with content 'hello bash'. do not print its timestamp\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundBash := false\n\t\t\t\tvar bashTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.BashToolName {\n\t\t\t\t\t\t\t\tbashTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == bashTCID {\n\t\t\t\t\t\t\t\tfoundBash = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundBash, \"Expected to find a bash operation\")\n\n\t\t\t\ttestFilePath := filepath.Join(env.workingDir, \"test.txt\")\n\t\t\t\tcontent, err := os.ReadFile(testFilePath)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Contains(t, string(content), \"hello bash\")\n\t\t\t})\n\t\t\tt.Run(\"download tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"download the file from https://example-files.online-convert.com/document/txt/example.txt and save it as example.txt\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundDownload := false\n\t\t\t\tvar downloadTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.DownloadToolName {\n\t\t\t\t\t\t\t\tdownloadTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == downloadTCID {\n\t\t\t\t\t\t\t\tfoundDownload = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundDownload, \"Expected to find a download operation\")\n\n\t\t\t\texamplePath := filepath.Join(env.workingDir, \"example.txt\")\n\t\t\t\t_, err = os.Stat(examplePath)\n\t\t\t\trequire.NoError(t, err, \"Expected example.txt file to exist\")\n\t\t\t})\n\t\t\tt.Run(\"fetch tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"fetch the content from https://example-files.online-convert.com/website/html/example.html and tell me if it contains the word 'John Doe'\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundFetch := false\n\t\t\t\tvar fetchTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.FetchToolName {\n\t\t\t\t\t\t\t\tfetchTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == fetchTCID {\n\t\t\t\t\t\t\t\tfoundFetch = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundFetch, \"Expected to find a fetch operation\")\n\t\t\t})\n\t\t\tt.Run(\"glob tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use glob to find all .go files in the current directory\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundGlob := false\n\t\t\t\tvar globTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.GlobToolName {\n\t\t\t\t\t\t\t\tglobTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == globTCID {\n\t\t\t\t\t\t\t\tfoundGlob = true\n\t\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"main.go\", \"Expected glob to find main.go\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundGlob, \"Expected to find a glob operation\")\n\t\t\t})\n\t\t\tt.Run(\"grep tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use grep to search for the word 'package' in go files\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundGrep := false\n\t\t\t\tvar grepTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.GrepToolName {\n\t\t\t\t\t\t\t\tgrepTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == grepTCID {\n\t\t\t\t\t\t\t\tfoundGrep = true\n\t\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"main.go\", \"Expected grep to find main.go\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundGrep, \"Expected to find a grep operation\")\n\t\t\t})\n\t\t\tt.Run(\"ls tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use ls to list the files in the current directory\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundLS := false\n\t\t\t\tvar lsTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.LSToolName {\n\t\t\t\t\t\t\t\tlsTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == lsTCID {\n\t\t\t\t\t\t\t\tfoundLS = true\n\t\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"main.go\", \"Expected ls to list main.go\")\n\t\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"go.mod\", \"Expected ls to list go.mod\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundLS, \"Expected to find an ls operation\")\n\t\t\t})\n\t\t\tt.Run(\"multiedit tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use multiedit to change 'Hello, World!' to 'Hello, Nexora!' and add a comment '// Greeting' above the fmt.Println line in main.go\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundMultiEdit := false\n\t\t\t\tvar multiEditTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.MultiEditToolName {\n\t\t\t\t\t\t\t\tmultiEditTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == multiEditTCID {\n\t\t\t\t\t\t\t\tfoundMultiEdit = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundMultiEdit, \"Expected to find a multiedit operation\")\n\n\t\t\t\tmainGoPath := filepath.Join(env.workingDir, \"main.go\")\n\t\t\t\tcontent, err := os.ReadFile(mainGoPath)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Contains(t, string(content), \"Hello, Nexora!\", \"Expected file to contain 'Hello, Nexora!'\")\n\t\t\t})\n\t\t\tt.Run(\"sourcegraph tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use sourcegraph to search for 'func main' in Go repositories\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundSourcegraph := false\n\t\t\t\tvar sourcegraphTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.SourcegraphToolName {\n\t\t\t\t\t\t\t\tsourcegraphTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == sourcegraphTCID {\n\t\t\t\t\t\t\t\tfoundSourcegraph = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundSourcegraph, \"Expected to find a sourcegraph operation\")\n\t\t\t})\n\t\t\tt.Run(\"write tool\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use write to create a new file called config.json with content '{\\\"name\\\": \\\"test\\\", \\\"version\\\": \\\"1.0.0\\\"}'\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfoundWrite := false\n\t\t\t\tvar writeTCID string\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant {\n\t\t\t\t\t\tfor _, tc := range msg.ToolCalls() {\n\t\t\t\t\t\t\tif tc.Name == tools.WriteToolName {\n\t\t\t\t\t\t\t\twriteTCID = tc.ID\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\t\tif tr.ToolCallID == writeTCID {\n\t\t\t\t\t\t\t\tfoundWrite = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundWrite, \"Expected to find a write operation\")\n\n\t\t\t\tconfigPath := filepath.Join(env.workingDir, \"config.json\")\n\t\t\t\tcontent, err := os.ReadFile(configPath)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Contains(t, string(content), \"test\", \"Expected config.json to contain 'test'\")\n\t\t\t\trequire.Contains(t, string(content), \"1.0.0\", \"Expected config.json to contain '1.0.0'\")\n\t\t\t})\n\t\t\tt.Run(\"parallel tool calls\", func(t *testing.T) {\n\t\t\t\tagent, env := setupAgent(t, pair)\n\n\t\t\t\tsession, err := env.sessions.Create(t.Context(), \"New Session\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tres, err := agent.Run(t.Context(), SessionAgentCall{\n\t\t\t\t\tPrompt:          \"use glob to find all .go files and use ls to list the current directory, it is very important that you run both tool calls in parallel\",\n\t\t\t\t\tSessionID:       session.ID,\n\t\t\t\t\tMaxOutputTokens: 10000,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, res)\n\n\t\t\t\tmsgs, err := env.messages.List(t.Context(), session.ID)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tvar assistantMsg *message.Message\n\t\t\t\tvar toolMsgs []message.Message\n\n\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\tif msg.Role == message.Assistant && len(msg.ToolCalls()) > 0 {\n\t\t\t\t\t\tassistantMsg = &msg\n\t\t\t\t\t}\n\t\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\t\ttoolMsgs = append(toolMsgs, msg)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.NotNil(t, assistantMsg, \"Expected to find an assistant message with tool calls\")\n\t\t\t\trequire.NotNil(t, toolMsgs, \"Expected to find a tool message\")\n\n\t\t\t\ttoolCalls := assistantMsg.ToolCalls()\n\t\t\t\trequire.GreaterOrEqual(t, len(toolCalls), 2, \"Expected at least 2 tool calls in parallel\")\n\n\t\t\t\tfoundGlob := false\n\t\t\t\tfoundLS := false\n\t\t\t\tvar globTCID, lsTCID string\n\n\t\t\t\tfor _, tc := range toolCalls {\n\t\t\t\t\tif tc.Name == tools.GlobToolName {\n\t\t\t\t\t\tfoundGlob = true\n\t\t\t\t\t\tglobTCID = tc.ID\n\t\t\t\t\t}\n\t\t\t\t\tif tc.Name == tools.LSToolName {\n\t\t\t\t\t\tfoundLS = true\n\t\t\t\t\t\tlsTCID = tc.ID\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundGlob, \"Expected to find a glob tool call\")\n\t\t\t\trequire.True(t, foundLS, \"Expected to find an ls tool call\")\n\n\t\t\t\trequire.GreaterOrEqual(t, len(toolMsgs), 2, \"Expected at least 2 tool results in the same message\")\n\n\t\t\t\tfoundGlobResult := false\n\t\t\t\tfoundLSResult := false\n\n\t\t\t\tfor _, msg := range toolMsgs {\n\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\tif tr.ToolCallID == globTCID {\n\t\t\t\t\t\t\tfoundGlobResult = true\n\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"main.go\", \"Expected glob result to contain main.go\")\n\t\t\t\t\t\t\trequire.False(t, tr.IsError, \"Expected glob result to not be an error\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif tr.ToolCallID == lsTCID {\n\t\t\t\t\t\t\tfoundLSResult = true\n\t\t\t\t\t\t\trequire.Contains(t, tr.Content, \"main.go\", \"Expected ls result to contain main.go\")\n\t\t\t\t\t\t\trequire.False(t, tr.IsError, \"Expected ls result to not be an error\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trequire.True(t, foundGlobResult, \"Expected to find glob tool result\")\n\t\t\t\trequire.True(t, foundLSResult, \"Expected to find ls tool result\")\n\t\t\t})\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}