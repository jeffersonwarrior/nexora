{
  "file_path": "/work/internal/fsext/owner_test.go",
  "file_hash": "079beef031da08758bc848b622e316ecf65305ad",
  "updated_at": "2025-12-26T17:34:21.273879",
  "symbols": {
    "function_TestOwner_10": {
      "name": "TestOwner",
      "type": "function",
      "start_line": 10,
      "end_line": 77,
      "content_hash": "6bd95e1b9e2056a4d7de75a41b1b65ed2319be8b",
      "content": "func TestOwner(t *testing.T) {\n\t// Create a temporary file for testing\n\ttmpDir := t.TempDir()\n\ttmpFile := filepath.Join(tmpDir, \"test.txt\")\n\n\terr := os.WriteFile(tmpFile, []byte(\"test\"), 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t}\n\n\tt.Run(\"valid file\", func(t *testing.T) {\n\t\tuid, err := Owner(tmpFile)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Owner() error = %v\", err)\n\t\t}\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\t// On Windows, should return -1\n\t\t\tif uid != -1 {\n\t\t\t\tt.Errorf(\"Owner() on Windows = %d, want -1\", uid)\n\t\t\t}\n\t\t} else {\n\t\t\t// On Unix-like systems, should return a valid UID\n\t\t\t// The UID should be non-negative\n\t\t\tif uid < 0 {\n\t\t\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t\t\t}\n\n\t\t\t// Should match current user's UID\n\t\t\tcurrentUID := os.Getuid()\n\t\t\tif uid != currentUID {\n\t\t\t\tt.Logf(\"Owner() = %d, current UID = %d (may differ if running as different user)\", uid, currentUID)\n\t\t\t}\n\t\t}\n\n\t\tt.Logf(\"Platform: %s, Owner UID: %d\", runtime.GOOS, uid)\n\t})\n\n\tt.Run(\"valid directory\", func(t *testing.T) {\n\t\tuid, err := Owner(tmpDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Owner() error = %v\", err)\n\t\t}\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tif uid != -1 {\n\t\t\t\tt.Errorf(\"Owner() on Windows = %d, want -1\", uid)\n\t\t\t}\n\t\t} else {\n\t\t\tif uid < 0 {\n\t\t\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"nonexistent file\", func(t *testing.T) {\n\t\tnonexistent := filepath.Join(tmpDir, \"does-not-exist.txt\")\n\t\t_, err := Owner(nonexistent)\n\t\tif err == nil {\n\t\t\tt.Error(\"Owner() for nonexistent file should return error\")\n\t\t}\n\n\t\tif !os.IsNotExist(err) {\n\t\t\tt.Errorf(\"Owner() error should be IsNotExist, got: %v\", err)\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerCurrentDirectory_78": {
      "name": "TestOwnerCurrentDirectory",
      "type": "function",
      "start_line": 78,
      "end_line": 99,
      "content_hash": "9579caf94612391462b7fe80323d69a40fb8e9e1",
      "content": "func TestOwnerCurrentDirectory(t *testing.T) {\n\t// Test with current directory\n\tuid, err := Owner(\".\")\n\tif err != nil {\n\t\tt.Fatalf(\"Owner('.') error = %v\", err)\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tif uid != -1 {\n\t\t\tt.Errorf(\"Owner() on Windows = %d, want -1\", uid)\n\t\t}\n\t} else {\n\t\tif uid < 0 {\n\t\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t\t}\n\n\t\t// Should be owned by current user (in most cases)\n\t\tcurrentUID := os.Getuid()\n\t\tt.Logf(\"Current directory owner: %d, current user: %d\", uid, currentUID)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerRootDirectory_100": {
      "name": "TestOwnerRootDirectory",
      "type": "function",
      "start_line": 100,
      "end_line": 127,
      "content_hash": "ddd25ae730ae5cb8ca4441a52c594e2ba0727b47",
      "content": "func TestOwnerRootDirectory(t *testing.T) {\n\t// Test with root directory\n\tvar rootDir string\n\tif runtime.GOOS == \"windows\" {\n\t\trootDir = \"C:\\\\\"\n\t} else {\n\t\trootDir = \"/\"\n\t}\n\n\tuid, err := Owner(rootDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Owner('%s') error = %v\", rootDir, err)\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tif uid != -1 {\n\t\t\tt.Errorf(\"Owner() on Windows = %d, want -1\", uid)\n\t\t}\n\t} else {\n\t\t// On Unix, root directory is typically owned by root (UID 0)\n\t\t// But we don't enforce this as it could be different in containers\n\t\tif uid < 0 {\n\t\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t\t}\n\t\tt.Logf(\"Root directory owner UID: %d\", uid)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerSymlink_128": {
      "name": "TestOwnerSymlink",
      "type": "function",
      "start_line": 128,
      "end_line": 161,
      "content_hash": "93d0de49cebbabaea2ee65c7ab3a40a0f8ddf2d6",
      "content": "func TestOwnerSymlink(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Symlink test skipped on Windows (requires admin privileges)\")\n\t}\n\n\ttmpDir := t.TempDir()\n\ttargetFile := filepath.Join(tmpDir, \"target.txt\")\n\tsymlinkFile := filepath.Join(tmpDir, \"symlink.txt\")\n\n\t// Create target file\n\terr := os.WriteFile(targetFile, []byte(\"test\"), 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create target file: %v\", err)\n\t}\n\n\t// Create symlink\n\terr = os.Symlink(targetFile, symlinkFile)\n\tif err != nil {\n\t\tt.Skipf(\"Failed to create symlink (may not be supported): %v\", err)\n\t}\n\n\t// Get owner of symlink (should follow the link)\n\tuid, err := Owner(symlinkFile)\n\tif err != nil {\n\t\tt.Fatalf(\"Owner() error = %v\", err)\n\t}\n\n\tif uid < 0 {\n\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t}\n\n\tt.Logf(\"Symlink owner UID: %d\", uid)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerPermissions_162": {
      "name": "TestOwnerPermissions",
      "type": "function",
      "start_line": 162,
      "end_line": 200,
      "content_hash": "bdc1d95ba95eda152a213b89a9bbb1325f79a541",
      "content": "func TestOwnerPermissions(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\ttests := []struct {\n\t\tname string\n\t\tperm os.FileMode\n\t}{\n\t\t{\"readable\", 0644},\n\t\t{\"writable\", 0666},\n\t\t{\"executable\", 0755},\n\t\t{\"restricted\", 0600},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttestFile := filepath.Join(tmpDir, tt.name+\".txt\")\n\t\t\terr := os.WriteFile(testFile, []byte(\"test\"), tt.perm)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create file: %v\", err)\n\t\t\t}\n\n\t\t\tuid, err := Owner(testFile)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Owner() error = %v\", err)\n\t\t\t}\n\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tif uid != -1 {\n\t\t\t\t\tt.Errorf(\"Owner() on Windows = %d, want -1\", uid)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif uid < 0 {\n\t\t\t\t\tt.Errorf(\"Owner() = %d, want non-negative UID\", uid)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerSpecialPaths_201": {
      "name": "TestOwnerSpecialPaths",
      "type": "function",
      "start_line": 201,
      "end_line": 229,
      "content_hash": "dca0646c7bc4d3bd8141f884b2779d0e314b8aaf",
      "content": "func TestOwnerSpecialPaths(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tpath    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty path\",\n\t\t\tpath:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid path\",\n\t\t\tpath:    \"/this/path/should/not/exist/hopefully\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := Owner(tt.path)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Owner() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestOwnerPlatformBehavior documents platform-specific behavior",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOwnerPlatformBehavior_230": {
      "name": "TestOwnerPlatformBehavior",
      "type": "function",
      "start_line": 230,
      "end_line": 254,
      "content_hash": "1dac10d9f1eece6efbfb41d099516502a3fddb44",
      "content": "func TestOwnerPlatformBehavior(t *testing.T) {\n\tt.Run(\"platform documentation\", func(t *testing.T) {\n\t\ttmpFile := filepath.Join(t.TempDir(), \"test.txt\")\n\t\tos.WriteFile(tmpFile, []byte(\"test\"), 0644)\n\n\t\tuid, _ := Owner(tmpFile)\n\n\t\tswitch runtime.GOOS {\n\t\tcase \"windows\":\n\t\t\tt.Log(\"Windows: Owner() always returns -1 (UID not applicable)\")\n\t\t\tif uid != -1 {\n\t\t\t\tt.Errorf(\"Expected -1 on Windows, got %d\", uid)\n\t\t\t}\n\t\tcase \"linux\", \"darwin\", \"freebsd\":\n\t\t\tt.Logf(\"%s: Owner() returns actual UID from file stats\", runtime.GOOS)\n\t\t\tif uid < 0 {\n\t\t\t\tt.Errorf(\"Expected non-negative UID on Unix-like systems, got %d\", uid)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Logf(\"Unknown platform: %s, UID: %d\", runtime.GOOS, uid)\n\t\t}\n\t})\n}\n\n// BenchmarkOwner tests performance of Owner function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkOwner_255": {
      "name": "BenchmarkOwner",
      "type": "function",
      "start_line": 255,
      "end_line": 264,
      "content_hash": "2ab292e73a007e8f75d9dd77129264a6f11f3bc6",
      "content": "func BenchmarkOwner(b *testing.B) {\n\ttmpDir := b.TempDir()\n\ttmpFile := filepath.Join(tmpDir, \"bench.txt\")\n\tos.WriteFile(tmpFile, []byte(\"test\"), 0644)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tOwner(tmpFile)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}