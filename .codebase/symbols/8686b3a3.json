{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/traversal_tests/count_tests.rs",
  "file_hash": "7dced7439389250b80589485cef0f1ac53154046",
  "updated_at": "2025-12-26T17:34:22.959257",
  "symbols": {
    "function_setup_test_db_25": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 25,
      "end_line": 37,
      "content_hash": "08bb0f06064d2277b5cf43aecf3c82469d11003e",
      "content": "fn setup_test_db() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let storage = HelixGraphStorage::new(\n        db_path,\n        crate::helix_engine::traversal_core::config::Config::default(),\n        Default::default(),\n    )\n    .unwrap();\n    (temp_dir, Arc::new(storage))\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_count_single_node_38": {
      "name": "test_count_single_node",
      "type": "function",
      "start_line": 38,
      "end_line": 55,
      "content_hash": "53f0aaf4f70a972465b010b653be89a934236cf5",
      "content": "fn test_count_single_node() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let person = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let person = person.first().unwrap();\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let count = G::new(&storage, &txn, &arena)\n        .n_from_id(&person.id())\n        .count();\n\n    assert_eq!(count, 1);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_count_node_array_56": {
      "name": "test_count_node_array",
      "type": "function",
      "start_line": 56,
      "end_line": 78,
      "content_hash": "28c6ef7106c9d026845f54726407098af65a247f",
      "content": "fn test_count_node_array() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let _ = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    txn.commit().unwrap();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let count = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\") // Get all nodes\n        .count();\n    assert_eq!(count, 3);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_count_mixed_steps_79": {
      "name": "test_count_mixed_steps",
      "type": "function",
      "start_line": 79,
      "end_line": 128,
      "content_hash": "a79fa6e146730dda13c03b107b51e2ad624c570b",
      "content": "fn test_count_mixed_steps() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    // Create a graph with multiple paths\n    let person1 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let person1 = person1.first().unwrap();\n    let person2 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let person2 = person2.first().unwrap();\n    let person3 = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    let person3 = person3.first().unwrap();\n\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"knows\",\n            None,\n            person1.id(),\n            person2.id(),\n            false,\n        )\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"knows\",\n            None,\n            person1.id(),\n            person3.id(),\n            false,\n        )\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    txn.commit().unwrap();\n    println!(\"person1: {person1:?},\\nperson2: {person2:?},\\nperson3: {person3:?}\");\n\n    let txn = storage.graph_env.read_txn().unwrap();\n    let count = G::new(&storage, &txn, &arena)\n        .n_from_id(&person1.id())\n        .out_node(\"knows\")\n        .count();\n\n    assert_eq!(count, 2);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_count_empty_129": {
      "name": "test_count_empty",
      "type": "function",
      "start_line": 129,
      "end_line": 141,
      "content_hash": "f75c46908e9c8e6a1502c7e0dc25e12e4ec82321",
      "content": "fn test_count_empty() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let count = G::new(&storage, &txn, &arena)\n        .n_from_type(\"person\") // Get all nodes\n        .range(0, 0) // Take first 3 nodes\n        .count();\n\n    assert_eq!(count, 0);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_count_filter_ref_142": {
      "name": "test_count_filter_ref",
      "type": "function",
      "start_line": 142,
      "end_line": 203,
      "content_hash": "d1f064ece4dccc44878a957ec1c65c000e39fbc8",
      "content": "fn test_count_filter_ref() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let mut nodes = Vec::new();\n    for _ in 0..100 {\n        let node = G::new_mut(&storage, &arena, &mut txn)\n            .add_n(\"Country\", None, None)\n            .collect_to_obj().unwrap();\n        nodes.push(node);\n    }\n    let mut num_countries = 0;\n    for node in nodes {\n        let rand_num = rand::rng().random_range(0..100);\n        for _ in 0..rand_num {\n            let city = G::new_mut(&storage, &arena, &mut txn)\n                .add_n(\"City\", None, None)\n                .collect_to_obj().unwrap();\n            G::new_mut(&storage, &arena, &mut txn)\n                .add_edge(\n                    \"Country_to_City\",\n                    None,\n                    node.id(),\n                    city.id(),\n                    false,\n                )\n                .collect::<Result<Vec<_>,_>>().unwrap();\n            // sleep for one microsecond\n            std::thread::sleep(Duration::from_micros(1));\n        }\n        if rand_num > 10 {\n            num_countries += 1;\n        }\n    }\n\n    let count = G::new(&storage, &txn, &arena)\n        .n_from_type(\"Country\")\n        .filter_ref(|val, txn| {\n            if let Ok(val) = val {\n                let val_id = val.id();\n                Ok(G::new(&storage, &txn, &arena)\n                    .n_from_id(&val_id)\n                    .out_node(\"Country_to_City\")\n                    .count_to_val()\n                    .map_value_or(false, |v| {\n                        println!(\n                            \"v: {v:?}, res: {:?}\",\n                            *v > 10.clone()\n                        );\n                        *v > 10.clone()\n                    })?)\n            } else {\n                Ok(false)\n            }\n        })\n        .collect::<Result<Vec<_>,_>>().unwrap();\n\n    println!(\"count: {count:?}, num_countries: {num_countries}\");\n\n    assert_eq!(count.len(), num_countries);\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}