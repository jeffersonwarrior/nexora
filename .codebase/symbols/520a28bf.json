{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/commands/dashboard.rs",
  "file_hash": "a7c6eccec570f60503669cbf45deee4c9822d268",
  "updated_at": "2025-12-26T17:34:24.444537",
  "symbols": {
    "struct_DisplayInfo_24": {
      "name": "DisplayInfo",
      "type": "struct",
      "start_line": 24,
      "end_line": 117,
      "content_hash": "7d6d78acdbb4ccdfa5e19b001f9ae33f86a7822e",
      "content": "struct DisplayInfo {\n    host: String,\n    helix_port: u16,\n    instance_name: Option<String>,\n    mode: String,\n}\n\npub async fn run(action: DashboardAction) -> Result<()> {\n    match action {\n        DashboardAction::Start {\n            instance,\n            port,\n            host,\n            helix_port,\n            attach,\n            restart,\n        } => start(instance, port, host, helix_port, attach, restart).await,\n        DashboardAction::Stop => stop(),\n        DashboardAction::Status => status(),\n    }\n}\n\nasync fn start(\n    instance: Option<String>,\n    port: u16,\n    host: Option<String>,\n    helix_port: u16,\n    attach: bool,\n    restart: bool,\n) -> Result<()> {\n    // Detect runtime (works without project)\n    let runtime = detect_runtime()?;\n\n    // Check Docker/Podman availability\n    DockerManager::check_runtime_available(runtime)?;\n\n    // Check if dashboard is already running\n    if is_dashboard_running(runtime)? {\n        if restart {\n            print_status(\"DASHBOARD\", \"Stopping existing dashboard...\");\n            stop_dashboard_container(runtime)?;\n        } else {\n            print_warning(\"Dashboard is already running\");\n            if let Ok(existing_port) = get_dashboard_port(runtime) {\n                print_info(&format!(\"Access it at: http://localhost:{existing_port}\"));\n            }\n            print_info(\"Use 'helix dashboard stop' to stop it, or '--restart' to restart\");\n            return Ok(());\n        }\n    }\n\n    // Warn if --helix-port is specified without --host\n    if host.is_none() && helix_port != DEFAULT_HELIX_PORT {\n        print_warning(\"--helix-port is ignored without --host; using project config or defaults\");\n    }\n\n    // Prepare environment variables based on connection mode\n    let (env_vars, display_info) = if let Some(host) = host {\n        // Direct connection mode - no project needed\n        prepare_direct_env_vars(&host, helix_port, runtime)?\n    } else {\n        // Try to use project config, or fall back to defaults\n        prepare_env_vars_from_context(instance, runtime).await?\n    };\n\n    // Pull the dashboard image\n    pull_dashboard_image(runtime)?;\n\n    // Start the dashboard container\n    start_dashboard_container(runtime, port, &env_vars, attach)?;\n\n    if !attach {\n        let url = format!(\"http://localhost:{port}\");\n\n        print_success(\"Dashboard started successfully\");\n        print_field(\"URL\", &url);\n        print_field(\"Helix Host\", &display_info.host);\n        print_field(\"Helix Port\", &display_info.helix_port.to_string());\n        if let Some(instance_name) = &display_info.instance_name {\n            print_field(\"Instance\", instance_name);\n        }\n        print_field(\"Mode\", &display_info.mode);\n        print_newline();\n        print_info(\"Run 'helix dashboard stop' to stop the dashboard\");\n\n        // Open the dashboard in the default browser\n        if let Err(e) = open::that(&url) {\n            print_warning(&format!(\"Could not open browser: {e}\"));\n        }\n    }\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prepare_direct_env_vars_118": {
      "name": "prepare_direct_env_vars",
      "type": "function",
      "start_line": 118,
      "end_line": 419,
      "content_hash": "cfaf522af176d74fc59f88fcdbf4d2f50cd6c339",
      "content": "fn prepare_direct_env_vars(\n    host: &str,\n    helix_port: u16,\n    runtime: ContainerRuntime,\n) -> Result<(Vec<String>, DisplayInfo)> {\n    // Use host.docker.internal for Docker, host.containers.internal for Podman\n    // when connecting to localhost\n    let docker_host = if host == \"localhost\" || host == \"127.0.0.1\" {\n        match runtime {\n            ContainerRuntime::Docker => \"host.docker.internal\",\n            ContainerRuntime::Podman => \"host.containers.internal\",\n        }\n    } else {\n        host\n    };\n\n    let env_vars = vec![\n        format!(\"HELIX_HOST={docker_host}\"),\n        format!(\"HELIX_PORT={helix_port}\"),\n    ];\n\n    let display_info = DisplayInfo {\n        host: host.to_string(),\n        helix_port,\n        instance_name: None,\n        mode: \"Direct\".to_string(),\n    };\n\n    Ok((env_vars, display_info))\n}\n\nasync fn prepare_env_vars_from_context(\n    instance: Option<String>,\n    runtime: ContainerRuntime,\n) -> Result<(Vec<String>, DisplayInfo)> {\n    // Try to load project context\n    match ProjectContext::find_and_load(None) {\n        Ok(project) => {\n            // Resolve instance from project (with interactive selection if needed)\n            let (instance_name, instance_config) = resolve_instance(&project, instance)?;\n\n            // Check if instance is in dev mode (required for dashboard)\n            check_dev_mode_requirement(&project, &instance_name, &instance_config).await?;\n\n            // For local instances, check if the instance is running\n            if instance_config.is_local() {\n                check_instance_running(&project, &instance_name).await?;\n            }\n\n            let env_vars =\n                prepare_environment_vars(&project, &instance_name, &instance_config).await?;\n\n            let (host, helix_port, mode) = if instance_config.is_local() {\n                let port = instance_config.port().unwrap_or(DEFAULT_HELIX_PORT);\n                (\"localhost\".to_string(), port, \"Local\".to_string())\n            } else {\n                (\"cloud\".to_string(), 443, \"Cloud\".to_string())\n            };\n\n            let display_info = DisplayInfo {\n                host,\n                helix_port,\n                instance_name: Some(instance_name),\n                mode,\n            };\n\n            Ok((env_vars, display_info))\n        }\n        Err(_) => {\n            // No project found - use defaults\n            print_info(&format!(\n                \"No helix.toml found, using default connection (localhost:{DEFAULT_HELIX_PORT})\"\n            ));\n            prepare_direct_env_vars(\"localhost\", DEFAULT_HELIX_PORT, runtime)\n        }\n    }\n}\n\nfn resolve_instance<'a>(\n    project: &'a ProjectContext,\n    instance: Option<String>,\n) -> Result<(String, InstanceInfo<'a>)> {\n    match instance {\n        Some(name) => {\n            let config = project.config.get_instance(&name)?;\n            Ok((name, config))\n        }\n        None => {\n            // Get all instances for interactive selection\n            let instances = project.config.list_instances_with_types();\n\n            if instances.is_empty() {\n                return Err(eyre!(\"No instances configured in helix.toml\"));\n            }\n\n            // If interactive terminal, prompt user to select instance\n            let name = if prompts::is_interactive() {\n                prompts::select_instance(&instances)?\n            } else {\n                // Non-interactive: use first local instance, or first cloud instance\n                let local_instances: Vec<_> = project.config.local.keys().collect();\n                if !local_instances.is_empty() {\n                    let name = local_instances[0].clone();\n                    print_info(&format!(\"Using local instance: {name}\"));\n                    name\n                } else {\n                    let cloud_instances: Vec<_> = project.config.cloud.keys().collect();\n                    let name = cloud_instances[0].clone();\n                    print_info(&format!(\"Using cloud instance: {name}\"));\n                    name\n                }\n            };\n\n            let config = project.config.get_instance(&name)?;\n            Ok((name, config))\n        }\n    }\n}\n\n/// Check if the instance is in dev mode. If not, prompt user to redeploy in dev mode.\n/// The dashboard requires dev mode to access internal debugging endpoints.\nasync fn check_dev_mode_requirement(\n    project: &ProjectContext,\n    instance_name: &str,\n    instance_config: &InstanceInfo<'_>,\n) -> Result<()> {\n    let build_mode = instance_config.build_mode();\n\n    if build_mode == BuildMode::Dev {\n        // Already in dev mode, nothing to do\n        return Ok(());\n    }\n\n    // Not in dev mode - warn the user\n    print_warning(&format!(\n        \"Instance '{}' is currently in {:?} mode, not dev mode.\",\n        instance_name, build_mode\n    ));\n    print_warning(\"The dashboard requires dev mode to access internal debugging endpoints.\");\n\n    // If not interactive, just fail\n    if !prompts::is_interactive() {\n        return Err(eyre!(\n            \"Instance '{}' must be in dev mode for the dashboard. \\\n            Redeploy with 'helix push {} --dev' or update build_mode to 'dev' in helix.toml.\",\n            instance_name,\n            instance_name\n        ));\n    }\n\n    // Ask user if they want to redeploy in dev mode\n    println!();\n    print_warning(\"\u26a0\ufe0f  WARNING: Redeploying in dev mode will:\");\n    print_warning(\"   - Restart the running instance\");\n    print_warning(\"   - Expose internal debug and dashboard endpoints\");\n    print_warning(\"   - This should NOT be used with production workloads\");\n    println!();\n\n    let should_redeploy = prompts::confirm(&format!(\n        \"Do you want to redeploy '{}' in dev mode?\",\n        instance_name\n    ))?;\n\n    if !should_redeploy {\n        return Err(eyre!(\n            \"Dashboard requires dev mode. Update build_mode to 'dev' in helix.toml or use --host flag to connect directly.\"\n        ));\n    }\n\n    // Redeploy the instance in dev mode\n    print_status(\n        \"REDEPLOY\",\n        &format!(\"Redeploying '{}' in dev mode...\", instance_name),\n    );\n\n    // Update the config to use dev mode and redeploy\n    let metrics_sender = MetricsSender::new()?;\n\n    if instance_config.is_local() {\n        // For local instances, we need to rebuild with dev mode\n        // First update the config file\n        let mut config = project.config.clone();\n        if let Some(local_config) = config.local.get_mut(instance_name) {\n            local_config.build_mode = BuildMode::Dev;\n        }\n        let config_path = project.root.join(\"helix.toml\");\n        config.save_to_file(&config_path)?;\n\n        // Reload the project context and push\n        crate::commands::push::run(Some(instance_name.to_string()), false, &metrics_sender).await?;\n    } else {\n        // For cloud instances, use the --dev flag\n        crate::commands::push::run(Some(instance_name.to_string()), true, &metrics_sender).await?;\n    }\n\n    print_success(&format!(\n        \"Instance '{}' redeployed in dev mode\",\n        instance_name\n    ));\n    Ok(())\n}\n\n/// Check if a local instance is running. If not, prompt user to start or push it.\nasync fn check_instance_running(project: &ProjectContext, instance_name: &str) -> Result<()> {\n    let docker = DockerManager::new(project);\n\n    // Check if Docker/Podman is available\n    DockerManager::check_runtime_available(docker.runtime)?;\n\n    // Get container status\n    let statuses = docker.get_project_status()?;\n    let container_prefix = format!(\"helix-{}-{}\", project.config.project.name, instance_name);\n\n    // Find the container for this instance\n    let container_status = statuses\n        .iter()\n        .find(|s| s.container_name.starts_with(&container_prefix));\n\n    // Check if container is running\n    let is_running = container_status\n        .map(|s| s.status.to_lowercase().starts_with(\"up\"))\n        .unwrap_or(false);\n\n    if is_running {\n        // Instance is running, nothing to do\n        return Ok(());\n    }\n\n    // If not interactive, just fail with instructions\n    if !prompts::is_interactive() {\n        return Err(eyre!(\n            \"Instance '{}' is not running. Start it with 'helix push {}'\",\n            instance_name,\n            instance_name\n        ));\n    }\n\n    // Interactive mode - prompt user\n    print_warning(&format!(\"Instance '{}' is not running.\", instance_name));\n\n    let should_push = prompts::confirm(&format!(\"Do you want to start '{}'?\", instance_name))?;\n\n    if !should_push {\n        return Err(eyre!(\n            \"Dashboard requires a running instance. Build and start it with 'helix push {}'\",\n            instance_name\n        ));\n    }\n\n    // Push (build and start) the instance\n    print_status(\n        \"PUSH\",\n        &format!(\"Building and starting instance '{}'...\", instance_name),\n    );\n    let metrics_sender = MetricsSender::new()?;\n    crate::commands::push::run(Some(instance_name.to_string()), false, &metrics_sender).await?;\n    print_success(&format!(\"Instance '{}' built and started\", instance_name));\n\n    Ok(())\n}\n\nasync fn prepare_environment_vars(\n    project: &ProjectContext,\n    instance_name: &str,\n    instance_config: &InstanceInfo<'_>,\n) -> Result<Vec<String>> {\n    let mut env_vars = Vec::new();\n\n    if instance_config.is_local() {\n        // Local instance - connect via Docker host networking\n        let port = instance_config.port().unwrap_or(DEFAULT_HELIX_PORT);\n\n        // Use host.docker.internal for Docker, host.containers.internal for Podman\n        let host = match project.config.project.container_runtime {\n            ContainerRuntime::Docker => \"host.docker.internal\",\n            ContainerRuntime::Podman => \"host.containers.internal\",\n        };\n\n        env_vars.push(format!(\"HELIX_HOST={host}\"));\n        env_vars.push(format!(\"HELIX_PORT={port}\"));\n        env_vars.push(format!(\"HELIX_INSTANCE={instance_name}\"));\n    } else {\n        // Cloud instance - use cloud URL and API key\n        let credentials = require_auth().await?;\n\n        // Get cloud URL based on instance type\n        let cloud_url = get_cloud_url(instance_config)?;\n\n        env_vars.push(format!(\"HELIX_CLOUD_URL={cloud_url}\"));\n        env_vars.push(format!(\"HELIX_API_KEY={}\", credentials.helix_admin_key));\n        env_vars.push(format!(\"HELIX_USER_ID={}\", credentials.user_id));\n        env_vars.push(format!(\"HELIX_INSTANCE={instance_name}\"));\n\n        // Add cluster ID for Helix Cloud instances\n        if let Some(cluster_id) = instance_config.cluster_id() {\n            env_vars.push(format!(\"HELIX_CLUSTER_ID={cluster_id}\"));\n        }\n    }\n\n    Ok(env_vars)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_cloud_url_420": {
      "name": "get_cloud_url",
      "type": "function",
      "start_line": 420,
      "end_line": 435,
      "content_hash": "ba5cc00f3b7eb911f22fcbbbc67d234cde7d614a",
      "content": "fn get_cloud_url(instance_config: &InstanceInfo) -> Result<String> {\n    match instance_config {\n        InstanceInfo::Helix(config) => Ok(format!(\n            \"https://{}/clusters/{}\",\n            *CLOUD_AUTHORITY, config.cluster_id\n        )),\n        InstanceInfo::FlyIo(_) => Err(eyre!(\n            \"Fly.io instances are not yet supported for the dashboard\"\n        )),\n        InstanceInfo::Ecr(_) => Err(eyre!(\n            \"ECR instances are not yet supported for the dashboard\"\n        )),\n        InstanceInfo::Local(_) => Err(eyre!(\"Local instances should not call get_cloud_url\")),\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_is_dashboard_running_436": {
      "name": "is_dashboard_running",
      "type": "function",
      "start_line": 436,
      "end_line": 449,
      "content_hash": "8db1c66030763dec940527c3ac3ff75f7facebe9",
      "content": "fn is_dashboard_running(runtime: ContainerRuntime) -> Result<bool> {\n    let output = Command::new(runtime.binary())\n        .args([\n            \"ps\",\n            \"-q\",\n            \"-f\",\n            &format!(\"name={DASHBOARD_CONTAINER_NAME}\"),\n        ])\n        .output()\n        .map_err(|e| eyre!(\"Failed to check dashboard status: {e}\"))?;\n\n    Ok(!String::from_utf8_lossy(&output.stdout).trim().is_empty())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_dashboard_port_450": {
      "name": "get_dashboard_port",
      "type": "function",
      "start_line": 450,
      "end_line": 465,
      "content_hash": "b4545345e1d211a0f58e2e061ac40fedd7d2611b",
      "content": "fn get_dashboard_port(runtime: ContainerRuntime) -> Result<u16> {\n    let output = Command::new(runtime.binary())\n        .args([\"port\", DASHBOARD_CONTAINER_NAME, \"3000\"])\n        .output()\n        .map_err(|e| eyre!(\"Failed to get dashboard port: {e}\"))?;\n\n    let port_mapping = String::from_utf8_lossy(&output.stdout);\n    // Parse \"0.0.0.0:3000\" format\n    port_mapping\n        .trim()\n        .split(':')\n        .next_back()\n        .and_then(|p| p.parse().ok())\n        .ok_or_else(|| eyre!(\"Failed to parse dashboard port\"))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_pull_dashboard_image_466": {
      "name": "pull_dashboard_image",
      "type": "function",
      "start_line": 466,
      "end_line": 487,
      "content_hash": "864ed72c78d2eea68d57de313d6bd949143a5481",
      "content": "fn pull_dashboard_image(runtime: ContainerRuntime) -> Result<()> {\n    print_status(\"DASHBOARD\", \"Pulling dashboard image...\");\n\n    let _ = Command::new(runtime.binary())\n        .args([\"logout\", \"public.ecr.aws\"])\n        .output();\n\n    let image = format!(\"{DASHBOARD_IMAGE}:{DASHBOARD_TAG}\");\n    let output = Command::new(runtime.binary())\n        .args([\"pull\", &image])\n        .output()\n        .map_err(|e| eyre!(\"Failed to pull dashboard image: {e}\"))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(&output.stderr);\n        return Err(eyre!(\"Failed to pull dashboard image:\\n{stderr}\"));\n    }\n\n    print_status(\"DASHBOARD\", \"Image pulled successfully\");\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_start_dashboard_container_488": {
      "name": "start_dashboard_container",
      "type": "function",
      "start_line": 488,
      "end_line": 548,
      "content_hash": "5f67f8f253168571ae0101bf1181ec1b59d9b661",
      "content": "fn start_dashboard_container(\n    runtime: ContainerRuntime,\n    port: u16,\n    env_vars: &[String],\n    attach: bool,\n) -> Result<()> {\n    print_status(\"DASHBOARD\", \"Starting dashboard container...\");\n\n    let image = format!(\"{DASHBOARD_IMAGE}:{DASHBOARD_TAG}\");\n\n    let mut args = vec![\n        \"run\".to_string(),\n        \"--name\".to_string(),\n        DASHBOARD_CONTAINER_NAME.to_string(),\n        \"-p\".to_string(),\n        format!(\"{port}:3000\"),\n        \"--rm\".to_string(),\n    ];\n\n    // Add detach flag if not attaching\n    if !attach {\n        args.push(\"-d\".to_string());\n    }\n\n    // Add environment variables\n    for env in env_vars {\n        args.push(\"-e\".to_string());\n        args.push(env.clone());\n    }\n\n    // Add the image name\n    args.push(image);\n\n    let args_refs: Vec<&str> = args.iter().map(|s| s.as_str()).collect();\n\n    if attach {\n        // Run in foreground - use spawn and wait\n        let status = Command::new(runtime.binary())\n            .args(&args_refs)\n            .status()\n            .map_err(|e| eyre!(\"Failed to start dashboard: {e}\"))?;\n\n        if !status.success() {\n            return Err(eyre!(\"Dashboard exited with error\"));\n        }\n    } else {\n        // Run detached\n        let output = Command::new(runtime.binary())\n            .args(&args_refs)\n            .output()\n            .map_err(|e| eyre!(\"Failed to start dashboard: {e}\"))?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to start dashboard:\\n{stderr}\"));\n        }\n    }\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stop_dashboard_container_549": {
      "name": "stop_dashboard_container",
      "type": "function",
      "start_line": 549,
      "end_line": 565,
      "content_hash": "31ec016e589a956c6a1971ef410b55a01e804c00",
      "content": "fn stop_dashboard_container(runtime: ContainerRuntime) -> Result<()> {\n    let output = Command::new(runtime.binary())\n        .args([\"stop\", DASHBOARD_CONTAINER_NAME])\n        .output()\n        .map_err(|e| eyre!(\"Failed to stop dashboard: {e}\"))?;\n\n    if !output.status.success() {\n        // Container might already be stopped, which is fine\n        let stderr = String::from_utf8_lossy(&output.stderr);\n        if !stderr.contains(\"No such container\") && !stderr.contains(\"no such container\") {\n            return Err(eyre!(\"Failed to stop dashboard:\\n{stderr}\"));\n        }\n    }\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stop_566": {
      "name": "stop",
      "type": "function",
      "start_line": 566,
      "end_line": 581,
      "content_hash": "e177ef066c56717f3ef184fd2fe26537085386ce",
      "content": "fn stop() -> Result<()> {\n    // Detect runtime - try to load project config, fallback to checking available runtimes\n    let runtime = detect_runtime()?;\n\n    if !is_dashboard_running(runtime)? {\n        print_info(\"Dashboard is not running\");\n        return Ok(());\n    }\n\n    print_status(\"DASHBOARD\", \"Stopping dashboard...\");\n    stop_dashboard_container(runtime)?;\n    print_success(\"Dashboard stopped\");\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detect_runtime_582": {
      "name": "detect_runtime",
      "type": "function",
      "start_line": 582,
      "end_line": 603,
      "content_hash": "36f04d3d969f8608a2f1ac5f3f4ba11ce65f617b",
      "content": "fn detect_runtime() -> Result<ContainerRuntime> {\n    // Try to load project config for runtime preference\n    if let Ok(project) = ProjectContext::find_and_load(None) {\n        return Ok(project.config.project.container_runtime);\n    }\n\n    // Fallback: check if Docker is available, then Podman\n    if let Ok(output) = Command::new(\"docker\").arg(\"--version\").output()\n        && output.status.success()\n    {\n        return Ok(ContainerRuntime::Docker);\n    }\n\n    if let Ok(output) = Command::new(\"podman\").arg(\"--version\").output()\n        && output.status.success()\n    {\n        return Ok(ContainerRuntime::Podman);\n    }\n\n    Err(eyre!(\"Neither Docker nor Podman is available\"))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_status_604": {
      "name": "status",
      "type": "function",
      "start_line": 604,
      "end_line": 652,
      "content_hash": "a43e9962bcafe7fea31df9291fb3de8f09c49010",
      "content": "fn status() -> Result<()> {\n    let runtime = detect_runtime()?;\n\n    print_header(\"Dashboard Status\");\n\n    if !is_dashboard_running(runtime)? {\n        print_field(\"Status\", \"Not running\");\n        return Ok(());\n    }\n\n    print_field(\"Status\", \"Running\");\n\n    // Get port\n    if let Ok(port) = get_dashboard_port(runtime) {\n        print_field(\"URL\", &format!(\"http://localhost:{port}\"));\n    }\n\n    // Get container info\n    let output = Command::new(runtime.binary())\n        .args([\n            \"inspect\",\n            DASHBOARD_CONTAINER_NAME,\n            \"--format\",\n            \"{{range .Config.Env}}{{println .}}{{end}}\",\n        ])\n        .output();\n\n    if let Ok(output) = output {\n        let env_output = String::from_utf8_lossy(&output.stdout);\n\n        // Extract connection info from environment\n        for line in env_output.lines() {\n            if let Some(instance) = line.strip_prefix(\"HELIX_INSTANCE=\") {\n                print_field(\"Instance\", instance);\n            }\n            if let Some(host) = line.strip_prefix(\"HELIX_HOST=\") {\n                print_field(\"Helix Host\", host);\n            }\n            if let Some(port) = line.strip_prefix(\"HELIX_PORT=\") {\n                print_field(\"Helix Port\", port);\n            }\n            if line.starts_with(\"HELIX_CLOUD_URL=\") {\n                print_field(\"Mode\", \"Cloud\");\n            }\n        }\n    }\n\n    Ok(())\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}