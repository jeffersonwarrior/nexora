{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/traversal_validation.rs",
  "file_hash": "005655bf40b947cbe5d8012508c1d74725d2e96c",
  "updated_at": "2025-12-26T17:34:23.282440",
  "symbols": {
    "function_get_reserved_property_type_44": {
      "name": "get_reserved_property_type",
      "type": "function",
      "start_line": 44,
      "end_line": 103,
      "content_hash": "dfe2e9e205f97f64b59473dcf2f6b26b9e3e3964",
      "content": "fn get_reserved_property_type(prop_name: &str, item_type: &Type) -> Option<FieldType> {\n    match prop_name {\n        \"id\" | \"ID\" | \"Id\" => Some(FieldType::Uuid),\n        \"label\" | \"Label\" => Some(FieldType::String),\n        \"version\" | \"Version\" => Some(FieldType::I8),\n        \"from_node\" | \"fromNode\" | \"FromNode\" => {\n            // Only valid for edges\n            match item_type {\n                Type::Edge(_) | Type::Edges(_) => Some(FieldType::Uuid),\n                _ => None,\n            }\n        }\n        \"to_node\" | \"toNode\" | \"ToNode\" => {\n            // Only valid for edges\n            match item_type {\n                Type::Edge(_) | Type::Edges(_) => Some(FieldType::Uuid),\n                _ => None,\n            }\n        }\n        \"deleted\" | \"Deleted\" => {\n            // Only valid for vectors\n            match item_type {\n                Type::Vector(_) | Type::Vectors(_) => Some(FieldType::Boolean),\n                _ => None,\n            }\n        }\n        \"level\" | \"Level\" => {\n            // Only valid for vectors\n            match item_type {\n                Type::Vector(_) | Type::Vectors(_) => Some(FieldType::U64),\n                _ => None,\n            }\n        }\n        \"distance\" | \"Distance\" => {\n            // Only valid for vectors\n            match item_type {\n                Type::Vector(_) | Type::Vectors(_) => Some(FieldType::F64),\n                _ => None,\n            }\n        }\n        \"data\" | \"Data\" => {\n            // Only valid for vectors\n            match item_type {\n                Type::Vector(_) | Type::Vectors(_) => {\n                    Some(FieldType::Array(Box::new(FieldType::F64)))\n                }\n                _ => None,\n            }\n        }\n        _ => None,\n    }\n}\n\n/// Checks if a traversal is a \"simple\" property access (no graph navigation steps)\n/// and returns the variable name and property name if so.\n///\n/// A simple traversal is one that only accesses properties on an already-bound variable,\n/// without any graph navigation (Out, In, etc.). For example: `toUser::{login}`\n///\n/// Returns: Some((variable_name, property_name)) if simple, None otherwise",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_is_simple_property_traversal_104": {
      "name": "is_simple_property_traversal",
      "type": "function",
      "start_line": 104,
      "end_line": 1967,
      "content_hash": "246607568d63aaee63559a7bb0d5e639be7facf1",
      "content": "fn is_simple_property_traversal(tr: &Traversal) -> Option<(String, String)> {\n    // Check if the start is an identifier (not a type-based query)\n    let var_name = match &tr.start {\n        StartNode::Identifier(id) => id.clone(),\n        _ => return None,\n    };\n\n    // Check if there's exactly one step and it's an Object (property access)\n    if tr.steps.len() != 1 {\n        return None;\n    }\n\n    // Check if the single step is an Object step (property access like {login})\n    match &tr.steps[0].step {\n        StepType::Object(obj) => {\n            // Check if it's a simple property fetch (single field, no spread)\n            if obj.fields.len() == 1 && !obj.should_spread {\n                let field = &obj.fields[0];\n                // Check if it's a simple field selection (Empty or Identifier, not a complex expression)\n                match &field.value.value {\n                    FieldValueType::Empty | FieldValueType::Identifier(_) => {\n                        return Some((var_name, field.key.clone()));\n                    }\n                    _ => return None,\n                }\n            }\n            None\n        }\n        _ => None,\n    }\n}\n\n/// Validates the traversal and returns the end type of the traversal\n///\n/// This method also builds the generated traversal (`gen_traversal`) as it analyzes the traversal\n///\n/// - `gen_query`: is used to set the query to being a mutating query if necessary.\n///   This is then used to determine the transaction type to use.\n///\n/// - `parent_ty`: is used with anonymous traversals to keep track of the parent type that the anonymous traversal is nested in.\npub(crate) fn validate_traversal<'a>(\n    ctx: &mut Ctx<'a>,\n    tr: &'a Traversal,\n    scope: &mut HashMap<&'a str, VariableInfo>,\n    original_query: &'a Query,\n    parent_ty: Option<Type>,\n    gen_traversal: &mut GeneratedTraversal,\n    gen_query: &mut GeneratedQuery,\n) -> Option<Type> {\n    let mut previous_step = None;\n    let mut cur_ty = match &tr.start {\n        StartNode::Node { node_type, ids } => {\n            if !ctx.node_set.contains(node_type.as_str()) {\n                generate_error!(ctx, original_query, tr.loc.clone(), E101, node_type);\n                return None;\n            }\n            if let Some(ids) = ids {\n                assert!(ids.len() == 1, \"multiple ids not supported yet\");\n                // check id exists in scope\n                match ids.first().cloned() {\n                    Some(id) => {\n                        match id {\n                            IdType::ByIndex { index, value, loc } => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    loc.clone(),\n                                    index.to_string().as_str(),\n                                );\n                                let corresponding_field = ctx\n                                    .node_fields\n                                    .get(node_type.as_str())\n                                    .cloned()\n                                    .ok_or_else(|| {\n                                        generate_error!(\n                                            ctx,\n                                            original_query,\n                                            loc.clone(),\n                                            E201,\n                                            node_type\n                                        );\n                                    })\n                                    .unwrap_or_else(|_| {\n                                        generate_error!(\n                                            ctx,\n                                            original_query,\n                                            loc.clone(),\n                                            E201,\n                                            node_type\n                                        );\n                                        HashMap::default()\n                                    });\n\n                                match corresponding_field\n                                    .iter()\n                                    .find(|(name, _)| name.to_string() == *index.to_string())\n                                {\n                                    Some((_, field)) => {\n                                        if !field.is_indexed() {\n                                            generate_error!(\n                                                ctx,\n                                                original_query,\n                                                loc.clone(),\n                                                E208,\n                                                [&index.to_string(), node_type],\n                                                [node_type]\n                                            );\n                                        } else if let ValueType::Literal { ref value, ref loc } =\n                                            *value\n                                            && !field.field_type.eq(value)\n                                        {\n                                            generate_error!(\n                                                ctx,\n                                                original_query,\n                                                loc.clone(),\n                                                E205,\n                                                &value.inner_stringify(),\n                                                &value.to_variant_string(),\n                                                &field.field_type.to_string(),\n                                                \"node\",\n                                                node_type\n                                            );\n                                        }\n                                    }\n                                    None => {\n                                        generate_error!(\n                                            ctx,\n                                            original_query,\n                                            loc.clone(),\n                                            E208,\n                                            [&index.to_string(), node_type],\n                                            [node_type]\n                                        );\n                                    }\n                                };\n                                gen_traversal.source_step =\n                                    Separator::Period(SourceStep::NFromIndex(NFromIndex {\n                                        label: GenRef::Literal(node_type.clone()),\n                                        index: GenRef::Literal(match *index {\n                                            IdType::Identifier { value, loc: _ } => value,\n                                            // would be caught by the parser\n                                            _ => unreachable!(),\n                                        }),\n                                        key: match *value {\n                                            ValueType::Identifier { value, loc } => {\n                                                if is_valid_identifier(\n                                                    ctx,\n                                                    original_query,\n                                                    loc.clone(),\n                                                    value.as_str(),\n                                                ) && !scope.contains_key(value.as_str())\n                                                {\n                                                    generate_error!(\n                                                        ctx,\n                                                        original_query,\n                                                        loc.clone(),\n                                                        E301,\n                                                        value.as_str()\n                                                    );\n                                                }\n                                                gen_identifier_or_param(\n                                                    original_query,\n                                                    value.as_str(),\n                                                    true,\n                                                    false,\n                                                )\n                                            }\n                                            ValueType::Literal { value, loc: _ } => {\n                                                GeneratedValue::Primitive(GenRef::Ref(\n                                                    match value {\n                                                        Value::String(s) => format!(\"\\\"{s}\\\"\"),\n                                                        other => other.inner_stringify(),\n                                                    },\n                                                ))\n                                            }\n                                            _ => unreachable!(),\n                                        },\n                                    }));\n                                gen_traversal.should_collect = ShouldCollect::ToObj;\n                                gen_traversal.traversal_type = TraversalType::Ref;\n                                Type::Node(Some(node_type.to_string()))\n                            }\n                            IdType::Identifier { value: i, loc } => {\n                                gen_traversal.source_step =\n                                    Separator::Period(SourceStep::NFromID(NFromID {\n                                        id: {\n                                            is_valid_identifier(\n                                                ctx,\n                                                original_query,\n                                                loc.clone(),\n                                                i.as_str(),\n                                            );\n                                            let _ = type_in_scope(\n                                                ctx,\n                                                original_query,\n                                                loc.clone(),\n                                                scope,\n                                                i.as_str(),\n                                            );\n                                            let value = gen_identifier_or_param(\n                                                original_query,\n                                                i.as_str(),\n                                                true,\n                                                false,\n                                            );\n                                            check_identifier_is_fieldtype(\n                                                ctx,\n                                                original_query,\n                                                loc.clone(),\n                                                scope,\n                                                i.as_str(),\n                                                FieldType::Uuid,\n                                            )?;\n                                            value.inner().clone()\n                                        },\n                                        label: GenRef::Literal(node_type.clone()),\n                                    }));\n                                gen_traversal.traversal_type = TraversalType::Ref;\n                                gen_traversal.should_collect = ShouldCollect::ToObj;\n                                Type::Node(Some(node_type.to_string()))\n                            }\n                            IdType::Literal { value: s, loc: _ } => {\n                                gen_traversal.source_step =\n                                    Separator::Period(SourceStep::NFromID(NFromID {\n                                        id: GenRef::Ref(s.clone()),\n                                        label: GenRef::Literal(node_type.clone()),\n                                    }));\n                                gen_traversal.traversal_type = TraversalType::Ref;\n                                gen_traversal.should_collect = ShouldCollect::ToObj;\n                                Type::Node(Some(node_type.to_string()))\n                            }\n                        }\n                    }\n                    None => {\n                        generate_error!(ctx, original_query, tr.loc.clone(), E601, \"missing id\");\n                        Type::Unknown\n                    }\n                }\n            } else {\n                gen_traversal.source_step = Separator::Period(SourceStep::NFromType(NFromType {\n                    label: GenRef::Literal(node_type.clone()),\n                }));\n                gen_traversal.traversal_type = TraversalType::Ref;\n                Type::Nodes(Some(node_type.to_string()))\n            }\n        }\n        StartNode::Edge { edge_type, ids } => {\n            if !ctx.edge_map.contains_key(edge_type.as_str()) {\n                generate_error!(ctx, original_query, tr.loc.clone(), E102, edge_type);\n            }\n            if let Some(ids) = ids {\n                assert!(ids.len() == 1, \"multiple ids not supported yet\");\n                gen_traversal.source_step = Separator::Period(SourceStep::EFromID(EFromID {\n                    id: match ids.first().cloned() {\n                        Some(id) => match id {\n                            IdType::Identifier { value: i, loc } => {\n                                is_valid_identifier(ctx, original_query, loc.clone(), i.as_str());\n                                let _ = type_in_scope(\n                                    ctx,\n                                    original_query,\n                                    loc.clone(),\n                                    scope,\n                                    i.as_str(),\n                                );\n                                let value = gen_identifier_or_param(\n                                    original_query,\n                                    i.as_str(),\n                                    true,\n                                    false,\n                                );\n                                value.inner().clone()\n                            }\n                            IdType::Literal { value: s, loc: _ } => GenRef::Std(s),\n                            _ => unreachable!(),\n                        },\n                        None => {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                tr.loc.clone(),\n                                E601,\n                                \"missing id\"\n                            );\n                            GenRef::Unknown\n                        }\n                    },\n                    label: GenRef::Literal(edge_type.clone()),\n                }));\n                gen_traversal.traversal_type = TraversalType::Ref;\n                gen_traversal.should_collect = ShouldCollect::ToObj;\n                Type::Edge(Some(edge_type.to_string()))\n            } else {\n                gen_traversal.source_step = Separator::Period(SourceStep::EFromType(EFromType {\n                    label: GenRef::Literal(edge_type.clone()),\n                }));\n                gen_traversal.traversal_type = TraversalType::Ref;\n                Type::Edges(Some(edge_type.to_string()))\n            }\n        }\n        StartNode::Vector { vector_type, ids } => {\n            if !ctx.vector_set.contains(vector_type.as_str()) {\n                generate_error!(ctx, original_query, tr.loc.clone(), E103, vector_type);\n            }\n            if let Some(ids) = ids {\n                assert!(ids.len() == 1, \"multiple ids not supported yet\");\n                gen_traversal.source_step = Separator::Period(SourceStep::VFromID(VFromID {\n                    get_vector_data: false,\n                    id: match ids.first().cloned() {\n                        Some(id) => match id {\n                            IdType::Identifier { value: i, loc } => {\n                                is_valid_identifier(ctx, original_query, loc.clone(), i.as_str());\n                                let _ = type_in_scope(\n                                    ctx,\n                                    original_query,\n                                    loc.clone(),\n                                    scope,\n                                    i.as_str(),\n                                );\n                                let value = gen_identifier_or_param(\n                                    original_query,\n                                    i.as_str(),\n                                    true,\n                                    false,\n                                );\n                                value.inner().clone()\n                            }\n                            IdType::Literal { value: s, loc: _ } => GenRef::Std(s),\n                            _ => unreachable!(),\n                        },\n                        None => {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                tr.loc.clone(),\n                                E601,\n                                \"missing id\"\n                            );\n                            GenRef::Unknown\n                        }\n                    },\n                    label: GenRef::Literal(vector_type.clone()),\n                }));\n                gen_traversal.traversal_type = TraversalType::Ref;\n                gen_traversal.should_collect = ShouldCollect::ToObj;\n                Type::Vector(Some(vector_type.to_string()))\n            } else {\n                gen_traversal.source_step = Separator::Period(SourceStep::VFromType(VFromType {\n                    label: GenRef::Literal(vector_type.clone()),\n                    get_vector_data: false,\n                }));\n                gen_traversal.traversal_type = TraversalType::Ref;\n                Type::Vectors(Some(vector_type.to_string()))\n            }\n        }\n\n        StartNode::Identifier(identifier) => {\n            match is_valid_identifier(ctx, original_query, tr.loc.clone(), identifier.as_str()) {\n                true => {\n                    // Increment reference count for this variable\n                    if let Some(var_info) = scope.get_mut(identifier.as_str()) {\n                        var_info.increment_reference();\n\n                        // Mark traversal as reused if referenced more than once\n                        if var_info.reference_count > 1 {\n                            gen_traversal.is_reused_variable = true;\n                        }\n\n                        gen_traversal.traversal_type = if var_info.is_single {\n                            TraversalType::FromSingle(GenRef::Std(identifier.clone()))\n                        } else {\n                            TraversalType::FromIter(GenRef::Std(identifier.clone()))\n                        };\n                        gen_traversal.source_step = Separator::Empty(SourceStep::Identifier(\n                            GenRef::Std(identifier.clone()),\n                        ));\n                        var_info.ty.clone()\n                    } else {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            tr.loc.clone(),\n                            E301,\n                            identifier.as_str()\n                        );\n                        Type::Unknown\n                    }\n                }\n                false => Type::Unknown,\n            }\n        }\n        // anonymous will be the traversal type rather than the start type\n        StartNode::Anonymous => {\n            let parent = parent_ty.clone().unwrap();\n            gen_traversal.traversal_type =\n                TraversalType::FromSingle(GenRef::Std(DEFAULT_VAR_NAME.to_string()));\n            gen_traversal.source_step = Separator::Empty(SourceStep::Anonymous);\n            parent\n        }\n        StartNode::SearchVector(sv) => {\n            if let Some(ref ty) = sv.vector_type\n                && !ctx.vector_set.contains(ty.as_str())\n            {\n                generate_error!(ctx, original_query, sv.loc.clone(), E103, ty.as_str());\n            }\n            let vec: VecData = match &sv.data {\n                Some(VectorData::Vector(v)) => {\n                    VecData::Standard(GeneratedValue::Literal(GenRef::Ref(format!(\n                        \"[{}]\",\n                        v.iter()\n                            .map(|f| f.to_string())\n                            .collect::<Vec<String>>()\n                            .join(\",\")\n                    ))))\n                }\n                Some(VectorData::Identifier(i)) => {\n                    is_valid_identifier(ctx, original_query, sv.loc.clone(), i.as_str());\n                    // if is in params then use data.\n                    let _ = type_in_scope(ctx, original_query, sv.loc.clone(), scope, i.as_str());\n                    VecData::Standard(gen_identifier_or_param(\n                        original_query,\n                        i.as_str(),\n                        true,\n                        false,\n                    ))\n                }\n                Some(VectorData::Embed(e)) => {\n                    let embed_data = match &e.value {\n                        EvaluatesToString::Identifier(i) => {\n                            type_in_scope(ctx, original_query, sv.loc.clone(), scope, i.as_str());\n                            EmbedData {\n                                data: gen_identifier_or_param(\n                                    original_query,\n                                    i.as_str(),\n                                    true,\n                                    false,\n                                ),\n                                model_name: gen_query.embedding_model_to_use.clone(),\n                            }\n                        }\n                        EvaluatesToString::StringLiteral(s) => EmbedData {\n                            data: GeneratedValue::Literal(GenRef::Ref(s.clone())),\n                            model_name: gen_query.embedding_model_to_use.clone(),\n                        },\n                    };\n\n                    VecData::Hoisted(gen_query.add_hoisted_embed(embed_data))\n                }\n                _ => {\n                    generate_error!(\n                        ctx,\n                        original_query,\n                        sv.loc.clone(),\n                        E305,\n                        [\"vector_data\", \"SearchV\"],\n                        [\"vector_data\"]\n                    );\n                    VecData::Unknown\n                }\n            };\n            let k = match &sv.k {\n                Some(k) => match &k.value {\n                    EvaluatesToNumberType::I8(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::I16(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::I32(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::I64(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n\n                    EvaluatesToNumberType::U8(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::U16(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::U32(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::U64(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::U128(i) => {\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                    }\n                    EvaluatesToNumberType::Identifier(i) => {\n                        is_valid_identifier(ctx, original_query, sv.loc.clone(), i.as_str());\n                        type_in_scope(ctx, original_query, sv.loc.clone(), scope, i.as_str());\n                        gen_identifier_or_param(original_query, i, false, true)\n                    }\n                    _ => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            sv.loc.clone(),\n                            E305,\n                            [\"k\", \"SearchV\"],\n                            [\"k\"]\n                        );\n                        GeneratedValue::Unknown\n                    }\n                },\n                None => {\n                    generate_error!(ctx, original_query, sv.loc.clone(), E601, &sv.loc.span);\n                    GeneratedValue::Unknown\n                }\n            };\n\n            // let pre_filter: Option<Vec<BoExp>> = match &sv.pre_filter {\n            //     Some(expr) => {\n            //         let (_, stmt) = infer_expr_type(\n            //             ctx,\n            //             expr,\n            //             scope,\n            //             original_query,\n            //             Some(Type::Vector(sv.vector_type.clone())),\n            //             gen_query,\n            //         );\n            //         // Where/boolean ops don't change the element type,\n            //         // so `cur_ty` stays the same.\n            //         assert!(stmt.is_some());\n            //         let stmt = stmt.unwrap();\n            //         let mut gen_traversal = GeneratedTraversal {\n            //             traversal_type: TraversalType::NestedFrom(GenRef::Std(\"v\".to_string())),\n            //             steps: vec![],\n            //             should_collect: ShouldCollect::ToVec,\n            //             source_step: Separator::Empty(SourceStep::Anonymous),\n            //         };\n            //         match stmt {\n            //             GeneratedStatement::Traversal(tr) => {\n            //                 gen_traversal\n            //                     .steps\n            //                     .push(Separator::Period(GeneratedStep::Where(Where::Ref(\n            //                         WhereRef {\n            //                             expr: BoExp::Expr(tr),\n            //                         },\n            //                     ))));\n            //             }\n            //             GeneratedStatement::BoExp(expr) => {\n            //                 gen_traversal\n            //                     .steps\n            //                     .push(Separator::Period(GeneratedStep::Where(match expr {\n            //                         BoExp::Exists(mut traversal) => {\n            //                             traversal.should_collect = ShouldCollect::No;\n            //                             Where::Ref(WhereRef {\n            //                                 expr: BoExp::Exists(traversal),\n            //                             })\n            //                         }\n            //                         _ => Where::Ref(WhereRef { expr }),\n            //                     })));\n            //             }\n            //             _ => unreachable!(),\n            //         }\n            //         Some(vec![BoExp::Expr(gen_traversal)])\n            //     }\n            //     None => None,\n            // };\n            let pre_filter = None;\n\n            gen_traversal.traversal_type = TraversalType::Ref;\n            gen_traversal.should_collect = ShouldCollect::ToVec;\n            gen_traversal.source_step = Separator::Period(SourceStep::SearchVector(SearchVector {\n                label: GenRef::Literal(sv.vector_type.clone().unwrap()),\n                vec,\n                k,\n                pre_filter,\n            }));\n            // Search returns nodes that contain the vectors\n            Type::Vectors(sv.vector_type.clone())\n        }\n    };\n\n    // Track excluded fields for property validation\n    let mut excluded: HashMap<&str, Loc> = HashMap::new();\n\n    // Stream through the steps\n    let number_of_steps = match tr.steps.len() {\n        0 => 0,\n        n => n - 1,\n    };\n\n    for (i, graph_step) in tr.steps.iter().enumerate() {\n        let step = &graph_step.step;\n        match step {\n            StepType::Node(gs) | StepType::Edge(gs) => {\n                match apply_graph_step(\n                    ctx,\n                    gs,\n                    &cur_ty,\n                    original_query,\n                    gen_traversal,\n                    scope,\n                    gen_query,\n                ) {\n                    Some(new_ty) => {\n                        cur_ty = new_ty;\n                    }\n                    None => { /* error already recorded */ }\n                }\n                excluded.clear(); // Traversal to a new element resets exclusions\n            }\n            StepType::First => {\n                cur_ty = cur_ty.clone().into_single();\n                excluded.clear();\n                gen_traversal.should_collect = ShouldCollect::ToObj;\n            }\n\n            StepType::Count => {\n                cur_ty = Type::Scalar(FieldType::I64);\n                excluded.clear();\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::Count));\n                gen_traversal.should_collect = ShouldCollect::No;\n            }\n\n            StepType::Exclude(ex) => {\n                // checks if exclude is either the last step or the step before an object remapping or closure\n                // i.e. you cant have `N<Type>::!{field1}::Out<Label>`\n                if !(i == number_of_steps\n                    || (i != number_of_steps - 1\n                        && (!matches!(tr.steps[i + 1].step, StepType::Closure(_))\n                            || !matches!(tr.steps[i + 1].step, StepType::Object(_)))))\n                {\n                    generate_error!(ctx, original_query, ex.loc.clone(), E644);\n                }\n                validate_exclude(ctx, &cur_ty, tr, ex, &excluded, original_query);\n                for (_, key) in &ex.fields {\n                    excluded.insert(key.as_str(), ex.loc.clone());\n                    gen_traversal.excluded_fields.push(key.clone());\n                }\n            }\n\n            StepType::Object(obj) => {\n                // For intermediate object steps, we don't track fields for return values\n                // Fields are only tracked when this traversal is used in a RETURN statement\n                let mut fields_out = vec![];\n                cur_ty = validate_object(\n                    ctx,\n                    &cur_ty,\n                    obj,\n                    original_query,\n                    gen_traversal,\n                    &mut fields_out,\n                    scope,\n                    gen_query,\n                )\n                .ok()?;\n            }\n\n            StepType::Where(expr) => {\n                let (_, stmt) = infer_expr_type(\n                    ctx,\n                    expr,\n                    scope,\n                    original_query,\n                    Some(cur_ty.clone()),\n                    gen_query,\n                );\n                // Where/boolean ops don't change the element type,\n                // so `cur_ty` stays the same.\n                if stmt.is_none() {\n                    return Some(cur_ty.clone());\n                }\n                let stmt = stmt.unwrap();\n                match stmt {\n                    GeneratedStatement::Traversal(tr) => {\n                        gen_traversal\n                            .steps\n                            .push(Separator::Period(GeneratedStep::Where(Where::Ref(\n                                WhereRef {\n                                    expr: BoExp::Expr(tr),\n                                },\n                            ))));\n                    }\n                    GeneratedStatement::BoExp(expr) => {\n                        // if Not(Exists()) or Exits() need to modify the traversal to not collect\n                        // else return where as normal\n                        let where_expr = match expr {\n                            BoExp::Not(inner_expr) => {\n                                if let BoExp::Exists(mut traversal) = *inner_expr {\n                                    traversal.should_collect = ShouldCollect::No;\n                                    Where::Ref(WhereRef {\n                                        expr: BoExp::Not(Box::new(BoExp::Exists(traversal))),\n                                    })\n                                } else {\n                                    Where::Ref(WhereRef {\n                                        // expr gets moved at start of match to allow for box dereference so need to move back\n                                        expr: BoExp::Not(inner_expr),\n                                    })\n                                }\n                            }\n                            BoExp::Exists(mut traversal) => {\n                                traversal.should_collect = ShouldCollect::No;\n                                Where::Ref(WhereRef {\n                                    expr: BoExp::Exists(traversal),\n                                })\n                            }\n                            _ => Where::Ref(WhereRef { expr }),\n                        };\n\n                        gen_traversal\n                            .steps\n                            .push(Separator::Period(GeneratedStep::Where(where_expr)));\n                    }\n                    _ => unreachable!(),\n                }\n            }\n            StepType::BooleanOperation(b_op) => {\n                let step = previous_step.unwrap();\n                let property_type = match &b_op.op {\n                    BooleanOpType::LessThanOrEqual(expr)\n                    | BooleanOpType::LessThan(expr)\n                    | BooleanOpType::GreaterThanOrEqual(expr)\n                    | BooleanOpType::GreaterThan(expr)\n                    | BooleanOpType::Equal(expr)\n                    | BooleanOpType::NotEqual(expr)\n                    | BooleanOpType::Contains(expr) => {\n                        match infer_expr_type(\n                            ctx,\n                            expr,\n                            scope,\n                            original_query,\n                            Some(cur_ty.clone()),\n                            gen_query,\n                        ) {\n                            (Type::Scalar(ft), _) => ft.clone(),\n                            (Type::Boolean, _) => FieldType::Boolean,\n                            (field_type, _) => {\n                                generate_error!(\n                                    ctx,\n                                    original_query,\n                                    b_op.loc.clone(),\n                                    E621,\n                                    &b_op.loc.span,\n                                    field_type.kind_str()\n                                );\n                                return Some(field_type);\n                            }\n                        }\n                    }\n                    BooleanOpType::IsIn(expr) => {\n                        // IS_IN expects an array argument\n                        match infer_expr_type(\n                            ctx,\n                            expr,\n                            scope,\n                            original_query,\n                            Some(cur_ty.clone()),\n                            gen_query,\n                        ) {\n                            (Type::Array(boxed_ty), _) => match *boxed_ty {\n                                Type::Scalar(ft) => ft,\n                                _ => {\n                                    generate_error!(\n                                        ctx,\n                                        original_query,\n                                        b_op.loc.clone(),\n                                        E621,\n                                        &b_op.loc.span,\n                                        \"non-scalar array elements\"\n                                    );\n                                    return Some(Type::Unknown);\n                                }\n                            },\n                            (field_type, _) => {\n                                generate_error!(\n                                    ctx,\n                                    original_query,\n                                    b_op.loc.clone(),\n                                    E621,\n                                    &b_op.loc.span,\n                                    field_type.kind_str()\n                                );\n                                return Some(field_type);\n                            }\n                        }\n                    }\n                    _ => return Some(cur_ty.clone()),\n                };\n\n                // get type of field name\n                let field_name = match step {\n                    StepType::Object(obj) => {\n                        let fields = obj.fields;\n                        assert!(fields.len() == 1);\n                        Some(fields[0].value.value.clone())\n                    }\n                    _ => None,\n                };\n                if let Some(FieldValueType::Identifier(field_name)) = &field_name {\n                    is_valid_identifier(ctx, original_query, b_op.loc.clone(), field_name.as_str());\n                    match &cur_ty {\n                        Type::Scalar(ft) => {\n                            if ft != &property_type {\n                                generate_error!(\n                                    ctx,\n                                    original_query,\n                                    b_op.loc.clone(),\n                                    E622,\n                                    field_name,\n                                    cur_ty.kind_str(),\n                                    &cur_ty.get_type_name(),\n                                    &ft.to_string(),\n                                    &property_type.to_string()\n                                );\n                            }\n                        }\n                        Type::Nodes(Some(node_ty)) | Type::Node(Some(node_ty)) => {\n                            // Check if this is a reserved property first\n                            if let Some(reserved_type) =\n                                get_reserved_property_type(field_name.as_str(), &cur_ty)\n                            {\n                                // Validate the type matches\n                                if let FieldType::Array(inner_type) = &property_type {\n                                    if reserved_type != **inner_type {\n                                        generate_error!(\n                                            ctx,\n                                            original_query,\n                                            b_op.loc.clone(),\n                                            E622,\n                                            field_name,\n                                            cur_ty.kind_str(),\n                                            &cur_ty.get_type_name(),\n                                            &reserved_type.to_string(),\n                                            &property_type.to_string()\n                                        );\n                                    }\n                                } else if reserved_type != property_type {\n                                    generate_error!(\n                                        ctx,\n                                        original_query,\n                                        b_op.loc.clone(),\n                                        E622,\n                                        field_name,\n                                        cur_ty.kind_str(),\n                                        &cur_ty.get_type_name(),\n                                        &reserved_type.to_string(),\n                                        &property_type.to_string()\n                                    );\n                                }\n                            } else {\n                                // Not a reserved property, check schema fields\n                                let field_set = ctx.node_fields.get(node_ty.as_str()).cloned();\n                                if let Some(field_set) = field_set {\n                                    match field_set.get(field_name.as_str()) {\n                                        Some(field) => {\n                                            if let FieldType::Array(inner_type) = &property_type {\n                                                if field.field_type != **inner_type {\n                                                    generate_error!(\n                                                        ctx,\n                                                        original_query,\n                                                        b_op.loc.clone(),\n                                                        E622,\n                                                        field_name,\n                                                        cur_ty.kind_str(),\n                                                        &cur_ty.get_type_name(),\n                                                        &field.field_type.to_string(),\n                                                        &property_type.to_string()\n                                                    );\n                                                }\n                                            } else if field.field_type != property_type {\n                                                generate_error!(\n                                                    ctx,\n                                                    original_query,\n                                                    b_op.loc.clone(),\n                                                    E622,\n                                                    field_name,\n                                                    cur_ty.kind_str(),\n                                                    &cur_ty.get_type_name(),\n                                                    &field.field_type.to_string(),\n                                                    &property_type.to_string()\n                                                );\n                                            }\n                                        }\n                                        None => {\n                                            generate_error!(\n                                                ctx,\n                                                original_query,\n                                                b_op.loc.clone(),\n                                                E202,\n                                                field_name,\n                                                cur_ty.kind_str(),\n                                                node_ty\n                                            );\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        Type::Edges(Some(edge_ty)) | Type::Edge(Some(edge_ty)) => {\n                            // Check if this is a reserved property first\n                            if let Some(reserved_type) =\n                                get_reserved_property_type(field_name.as_str(), &cur_ty)\n                            {\n                                // Validate the type matches\n                                if reserved_type != property_type {\n                                    generate_error!(\n                                        ctx,\n                                        original_query,\n                                        b_op.loc.clone(),\n                                        E622,\n                                        field_name,\n                                        cur_ty.kind_str(),\n                                        &cur_ty.get_type_name(),\n                                        &reserved_type.to_string(),\n                                        &property_type.to_string()\n                                    );\n                                }\n                            } else {\n                                // Not a reserved property, check schema fields\n                                let field_set = ctx.edge_fields.get(edge_ty.as_str()).cloned();\n                                if let Some(field_set) = field_set {\n                                    match field_set.get(field_name.as_str()) {\n                                        Some(field) => {\n                                            if field.field_type != property_type {\n                                                generate_error!(\n                                                    ctx,\n                                                    original_query,\n                                                    b_op.loc.clone(),\n                                                    E622,\n                                                    field_name,\n                                                    cur_ty.kind_str(),\n                                                    &cur_ty.get_type_name(),\n                                                    &field.field_type.to_string(),\n                                                    &property_type.to_string()\n                                                );\n                                            }\n                                        }\n                                        None => {\n                                            generate_error!(\n                                                ctx,\n                                                original_query,\n                                                b_op.loc.clone(),\n                                                E202,\n                                                field_name,\n                                                cur_ty.kind_str(),\n                                                edge_ty\n                                            );\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        Type::Vectors(Some(sv)) | Type::Vector(Some(sv)) => {\n                            // Check if this is a reserved property first\n                            if let Some(reserved_type) =\n                                get_reserved_property_type(field_name.as_str(), &cur_ty)\n                            {\n                                // Validate the type matches\n                                if reserved_type != property_type {\n                                    generate_error!(\n                                        ctx,\n                                        original_query,\n                                        b_op.loc.clone(),\n                                        E622,\n                                        field_name,\n                                        cur_ty.kind_str(),\n                                        &cur_ty.get_type_name(),\n                                        &reserved_type.to_string(),\n                                        &property_type.to_string()\n                                    );\n                                }\n                            } else {\n                                // Not a reserved property, check schema fields\n                                let field_set = ctx.vector_fields.get(sv.as_str()).cloned();\n                                if let Some(field_set) = field_set {\n                                    match field_set.get(field_name.as_str()) {\n                                        Some(field) => {\n                                            if field.field_type != property_type {\n                                                generate_error!(\n                                                    ctx,\n                                                    original_query,\n                                                    b_op.loc.clone(),\n                                                    E622,\n                                                    field_name,\n                                                    cur_ty.kind_str(),\n                                                    &cur_ty.get_type_name(),\n                                                    &field.field_type.to_string(),\n                                                    &property_type.to_string()\n                                                );\n                                            }\n                                        }\n                                        None => {\n                                            generate_error!(\n                                                ctx,\n                                                original_query,\n                                                b_op.loc.clone(),\n                                                E202,\n                                                field_name,\n                                                cur_ty.kind_str(),\n                                                sv\n                                            );\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        _ => {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                b_op.loc.clone(),\n                                E621,\n                                &b_op.loc.span,\n                                cur_ty.kind_str()\n                            );\n                        }\n                    }\n                }\n\n                // ctx.infer_expr_type(expr, scope, q);\n                // Where/boolean ops don't change the element type,\n                // so `cur_ty` stays the same.\n                let op = match &b_op.op {\n                    BooleanOpType::LessThanOrEqual(expr) => {\n                        // assert!()\n                        let v = match &expr.expr {\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::Lte(Lte {\n                            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                            right: v,\n                        })\n                    }\n                    BooleanOpType::LessThan(expr) => {\n                        let v = match &expr.expr {\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::Lt(Lt {\n                            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                            right: v,\n                        })\n                    }\n                    BooleanOpType::GreaterThanOrEqual(expr) => {\n                        let v = match &expr.expr {\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::Gte(Gte {\n                            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                            right: v,\n                        })\n                    }\n                    BooleanOpType::GreaterThan(expr) => {\n                        let v = match &expr.expr {\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::Gt(Gt {\n                            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                            right: v,\n                        })\n                    }\n                    BooleanOpType::Equal(expr) => {\n                        // Check if the right-hand side is a simple property traversal\n                        if let ExpressionType::Traversal(traversal) = &expr.expr {\n                            if let Some((var, property)) = is_simple_property_traversal(traversal) {\n                                // Use PropertyEq for simple traversals to avoid unnecessary G::from_iter\n                                BoolOp::PropertyEq(PropertyEq { var, property })\n                            } else {\n                                // Complex traversal - parse normally\n                                let mut gen_traversal = GeneratedTraversal::default();\n                                validate_traversal(\n                                    ctx,\n                                    traversal,\n                                    scope,\n                                    original_query,\n                                    parent_ty.clone(),\n                                    &mut gen_traversal,\n                                    gen_query,\n                                );\n                                gen_traversal.should_collect = ShouldCollect::ToValue;\n                                let v = GeneratedValue::Traversal(Box::new(gen_traversal));\n                                BoolOp::Eq(Eq {\n                                    left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                                    right: v,\n                                })\n                            }\n                        } else {\n                            let v = match &expr.expr {\n                            ExpressionType::BooleanLiteral(b) => {\n                                GeneratedValue::Primitive(GenRef::Std(b.to_string()))\n                            }\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::StringLiteral(s) => {\n                                GeneratedValue::Primitive(GenRef::Literal(s.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => {\n                                unreachable!(\"Cannot reach here\");\n                            }\n                        };\n                            BoolOp::Eq(Eq {\n                                left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                                right: v,\n                            })\n                        }\n                    }\n                    BooleanOpType::NotEqual(expr) => {\n                        // Check if the right-hand side is a simple property traversal\n                        if let ExpressionType::Traversal(traversal) = &expr.expr {\n                            if let Some((var, property)) = is_simple_property_traversal(traversal) {\n                                // Use PropertyNeq for simple traversals to avoid unnecessary G::from_iter\n                                BoolOp::PropertyNeq(PropertyNeq { var, property })\n                            } else {\n                                // Complex traversal - parse normally\n                                let mut gen_traversal = GeneratedTraversal::default();\n                                validate_traversal(\n                                    ctx,\n                                    traversal,\n                                    scope,\n                                    original_query,\n                                    parent_ty.clone(),\n                                    &mut gen_traversal,\n                                    gen_query,\n                                );\n                                gen_traversal.should_collect = ShouldCollect::ToValue;\n                                let v = GeneratedValue::Traversal(Box::new(gen_traversal));\n                                BoolOp::Neq(Neq {\n                                    left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                                    right: v,\n                                })\n                            }\n                        } else {\n                            let v = match &expr.expr {\n                            ExpressionType::BooleanLiteral(b) => {\n                                GeneratedValue::Primitive(GenRef::Std(b.to_string()))\n                            }\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::StringLiteral(s) => {\n                                GeneratedValue::Primitive(GenRef::Literal(s.to_string()))\n                            }\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), false, true)\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                            BoolOp::Neq(Neq {\n                                left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n                                right: v,\n                            })\n                        }\n                    }\n                    BooleanOpType::Contains(expr) => {\n                        let v = match &expr.expr {\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), true, false)\n                            }\n                            ExpressionType::BooleanLiteral(b) => {\n                                GeneratedValue::Primitive(GenRef::Std(b.to_string()))\n                            }\n                            ExpressionType::IntegerLiteral(i) => {\n                                GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                            }\n                            ExpressionType::FloatLiteral(f) => {\n                                GeneratedValue::Primitive(GenRef::Std(f.to_string()))\n                            }\n                            ExpressionType::StringLiteral(s) => {\n                                GeneratedValue::Primitive(GenRef::Literal(s.to_string()))\n                            }\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::Contains(Contains { value: v })\n                    }\n                    BooleanOpType::IsIn(expr) => {\n                        let v = match &expr.expr {\n                            ExpressionType::Identifier(i) => {\n                                is_valid_identifier(\n                                    ctx,\n                                    original_query,\n                                    expr.loc.clone(),\n                                    i.as_str(),\n                                );\n                                type_in_scope(ctx, original_query, expr.loc.clone(), scope, i.as_str());\n                                gen_identifier_or_param(original_query, i.as_str(), true, false)\n                            }\n                            ExpressionType::ArrayLiteral(a) => GeneratedValue::Array(GenRef::Std(\n                                a.iter()\n                                    .map(|e| {\n                                        let v = match &e.expr {\n                                            ExpressionType::BooleanLiteral(b) => {\n                                                GeneratedValue::Primitive(GenRef::Std(\n                                                    b.to_string(),\n                                                ))\n                                            }\n                                            ExpressionType::IntegerLiteral(i) => {\n                                                GeneratedValue::Primitive(GenRef::Std(\n                                                    i.to_string(),\n                                                ))\n                                            }\n                                            ExpressionType::FloatLiteral(f) => {\n                                                GeneratedValue::Primitive(GenRef::Std(\n                                                    f.to_string(),\n                                                ))\n                                            }\n                                            ExpressionType::StringLiteral(s) => {\n                                                GeneratedValue::Primitive(GenRef::Literal(\n                                                    s.to_string(),\n                                                ))\n                                            }\n                                            _ => unreachable!(\"Cannot reach here\"),\n                                        };\n                                        v.to_string()\n                                    })\n                                    .collect::<Vec<_>>()\n                                    .join(\", \"),\n                            )),\n                            _ => unreachable!(\"Cannot reach here\"),\n                        };\n                        BoolOp::IsIn(IsIn { value: v })\n                    }\n                    _ => unreachable!(\"shouldve been caught earlier\"),\n                };\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::BoolOp(op)));\n                gen_traversal.should_collect = ShouldCollect::No;\n            }\n            StepType::Aggregate(aggr) => {\n                let properties = aggr\n                    .properties\n                    .iter()\n                    .map(|p| GenRef::Std(format!(\"\\\"{}\\\".to_string()\", p.clone())))\n                    .collect::<Vec<_>>();\n                let should_count = matches!(previous_step, Some(StepType::Count));\n                let _ = gen_traversal.steps.pop();\n\n                // Capture aggregate metadata before replacing cur_ty\n                let property_names = aggr.properties.clone();\n                cur_ty = Type::Aggregate(AggregateInfo {\n                    source_type: Box::new(cur_ty.clone()),\n                    properties: property_names,\n                    is_count: should_count,\n                    is_group_by: false, // This is AGGREGATE_BY\n                });\n\n                gen_traversal.should_collect = ShouldCollect::Try;\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::AggregateBy(AggregateBy {\n                        properties,\n                        should_count,\n                    })))\n            }\n            StepType::GroupBy(gb) => {\n                let properties = gb\n                    .properties\n                    .iter()\n                    .map(|p| GenRef::Std(format!(\"\\\"{}\\\".to_string()\", p.clone())))\n                    .collect::<Vec<_>>();\n                let should_count = matches!(previous_step, Some(StepType::Count));\n                let _ = gen_traversal.steps.pop();\n\n                // Capture aggregate metadata before replacing cur_ty\n                let property_names = gb.properties.clone();\n                cur_ty = Type::Aggregate(AggregateInfo {\n                    source_type: Box::new(cur_ty.clone()),\n                    properties: property_names,\n                    is_count: should_count,\n                    is_group_by: true, // This is GROUP_BY\n                });\n\n                gen_traversal.should_collect = ShouldCollect::Try;\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::GroupBy(GroupBy {\n                        properties,\n                        should_count,\n                    })))\n            }\n            StepType::Update(update) => {\n                // if type == node, edge, vector then update is valid\n                // otherwise it is invalid\n\n                // Update returns the same type (nodes/edges) it started with.\n\n                match &cur_ty {\n                    Type::Node(Some(ty))\n                    | Type::Nodes(Some(ty))\n                    | Type::Edge(Some(ty))\n                    | Type::Edges(Some(ty)) => {\n                        field_exists_on_item_type(\n                            ctx,\n                            original_query,\n                            Type::Node(Some(ty.clone())),\n                            update\n                                .fields\n                                .iter()\n                                .map(|field| (field.key.as_str(), &field.loc))\n                                .collect(),\n                        );\n                    }\n                    other => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            update.loc.clone(),\n                            E604,\n                            &other.get_type_name()\n                        );\n                        return Some(cur_ty.clone());\n                    }\n                }\n                gen_traversal.traversal_type = TraversalType::Update(Some(\n                    update\n                        .fields\n                        .iter()\n                        .map(|field| {\n                            (\n                                field.key.clone(),\n                                match &field.value.value {\n                                    FieldValueType::Identifier(i) => {\n                                        is_valid_identifier(\n                                            ctx,\n                                            original_query,\n                                            field.value.loc.clone(),\n                                            i.as_str(),\n                                        );\n                                        type_in_scope(ctx, original_query, field.value.loc.clone(), scope, i.as_str());\n                                        gen_identifier_or_param(\n                                            original_query,\n                                            i.as_str(),\n                                            true,\n                                            true,\n                                        )\n                                    }\n                                    FieldValueType::Literal(l) => match l {\n                                        Value::String(s) => {\n                                            GeneratedValue::Literal(GenRef::Literal(s.clone()))\n                                        }\n                                        other => GeneratedValue::Primitive(GenRef::Std(\n                                            other.inner_stringify(),\n                                        )),\n                                    },\n                                    FieldValueType::Expression(e) => match &e.expr {\n                                        ExpressionType::Identifier(i) => {\n                                            is_valid_identifier(\n                                                ctx,\n                                                original_query,\n                                                e.loc.clone(),\n                                                i.as_str(),\n                                            );\n                                            type_in_scope(ctx, original_query, e.loc.clone(), scope, i.as_str());\n                                            gen_identifier_or_param(\n                                                original_query,\n                                                i.as_str(),\n                                                true,\n                                                true,\n                                            )\n                                        }\n                                        ExpressionType::StringLiteral(i) => {\n                                            GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                                        }\n\n                                        ExpressionType::IntegerLiteral(i) => {\n                                            GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                                        }\n                                        ExpressionType::FloatLiteral(i) => {\n                                            GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                                        }\n                                        ExpressionType::BooleanLiteral(i) => {\n                                            GeneratedValue::Primitive(GenRef::Std(i.to_string()))\n                                        }\n                                        other => {\n                                            generate_error!(ctx, original_query, e.loc.clone(), E206, &format!(\"{:?}\", other));\n                                            GeneratedValue::Unknown\n                                        }\n                                    },\n                                    other => {\n                                        generate_error!(ctx, original_query, field.value.loc.clone(), E206, &format!(\"{:?}\", other));\n                                        GeneratedValue::Unknown\n                                    }\n                                },\n                            )\n                        })\n                        .collect(),\n                ));\n                cur_ty = cur_ty.into_single();\n                gen_traversal.should_collect = ShouldCollect::No;\n                excluded.clear();\n            }\n\n            StepType::AddEdge(add) => {\n                if let Some(ref ty) = add.edge_type\n                    && !ctx.edge_map.contains_key(ty.as_str())\n                {\n                    generate_error!(ctx, original_query, add.loc.clone(), E102, ty);\n                }\n                cur_ty = Type::Edges(add.edge_type.clone());\n                excluded.clear();\n            }\n\n            StepType::Range((start, end)) => {\n                let (start, end) = match (&start.expr, &end.expr) {\n                    (ExpressionType::Identifier(i), ExpressionType::Identifier(j)) => {\n                        is_valid_identifier(ctx, original_query, start.loc.clone(), i.as_str());\n                        is_valid_identifier(ctx, original_query, end.loc.clone(), j.as_str());\n\n                        let ty = type_in_scope(\n                            ctx,\n                            original_query,\n                            start.loc.clone(),\n                            scope,\n                            i.as_str(),\n                        );\n                        if let Some(ty) = ty\n                            && !ty.is_integer()\n                        {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                start.loc.clone(),\n                                E633,\n                                [&start.loc.span, &ty.get_type_name()],\n                                [i.as_str()]\n                            );\n                            return Some(cur_ty.clone()); // Not sure if this should be here\n                        };\n                        let ty =\n                            type_in_scope(ctx, original_query, end.loc.clone(), scope, j.as_str());\n                        if let Some(ty) = ty\n                            && !ty.is_integer()\n                        {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                end.loc.clone(),\n                                E633,\n                                [&end.loc.span, &ty.get_type_name()],\n                                [j.as_str()]\n                            );\n                            return Some(cur_ty.clone()); // Not sure if this should be here\n                        }\n                        (\n                            gen_identifier_or_param(original_query, i.as_str(), false, true),\n                            gen_identifier_or_param(original_query, j.as_str(), false, true),\n                        )\n                    }\n                    (ExpressionType::IntegerLiteral(i), ExpressionType::IntegerLiteral(j)) => (\n                        GeneratedValue::Primitive(GenRef::Std(i.to_string())),\n                        GeneratedValue::Primitive(GenRef::Std(j.to_string())),\n                    ),\n                    (ExpressionType::Identifier(i), ExpressionType::IntegerLiteral(j)) => {\n                        is_valid_identifier(ctx, original_query, start.loc.clone(), i.as_str());\n\n                        let ty = type_in_scope(\n                            ctx,\n                            original_query,\n                            start.loc.clone(),\n                            scope,\n                            i.as_str(),\n                        );\n                        if let Some(ty) = ty\n                            && !ty.is_integer()\n                        {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                start.loc.clone(),\n                                E633,\n                                [&start.loc.span, &ty.get_type_name()],\n                                [i.as_str()]\n                            );\n                            return Some(cur_ty.clone()); // Not sure if this should be here\n                        }\n\n                        (\n                            gen_identifier_or_param(original_query, i.as_str(), false, true),\n                            GeneratedValue::Primitive(GenRef::Std(j.to_string())),\n                        )\n                    }\n                    (ExpressionType::IntegerLiteral(i), ExpressionType::Identifier(j)) => {\n                        is_valid_identifier(ctx, original_query, end.loc.clone(), j.as_str());\n                        let ty =\n                            type_in_scope(ctx, original_query, end.loc.clone(), scope, j.as_str());\n                        if let Some(ty) = ty\n                            && !ty.is_integer()\n                        {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                end.loc.clone(),\n                                E633,\n                                [&end.loc.span, &ty.get_type_name()],\n                                [j.as_str()]\n                            );\n                            return Some(cur_ty.clone());\n                        }\n                        (\n                            GeneratedValue::Primitive(GenRef::Std(i.to_string())),\n                            gen_identifier_or_param(original_query, j.as_str(), false, true),\n                        )\n                    }\n                    (ExpressionType::Identifier(_) | ExpressionType::IntegerLiteral(_), other) => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            start.loc.clone(),\n                            E633,\n                            [&start.loc.span, &other.to_string()],\n                            [&other.to_string()]\n                        );\n                        return Some(cur_ty.clone());\n                    }\n                    (other, ExpressionType::Identifier(_) | ExpressionType::IntegerLiteral(_)) => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            start.loc.clone(),\n                            E633,\n                            [&start.loc.span, &other.to_string()],\n                            [&other.to_string()]\n                        );\n                        return Some(cur_ty.clone());\n                    }\n                    _ => unreachable!(\"shouldve been caught eariler\"),\n                };\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::Range(Range {\n                        start,\n                        end,\n                    })));\n            }\n            StepType::OrderBy(order_by) => {\n                // verify property access\n                let (_, stmt) = infer_expr_type(\n                    ctx,\n                    &order_by.expression,\n                    scope,\n                    original_query,\n                    Some(cur_ty.clone()),\n                    gen_query,\n                );\n\n                if stmt.is_none() {\n                    return Some(cur_ty.clone());\n                }\n                match stmt.unwrap() {\n                    GeneratedStatement::Traversal(traversal) => {\n                        let property = match &traversal.steps.last() {\n                            Some(step) => match &step.inner() {\n                                GeneratedStep::PropertyFetch(property) => property.clone(),\n                                _ => unreachable!(\"Cannot reach here\"),\n                            },\n                            None => unreachable!(\"Cannot reach here\"),\n                        };\n                        gen_traversal\n                            .steps\n                            .push(Separator::Period(GeneratedStep::OrderBy(OrderBy {\n                                property,\n                                order: match order_by.order_by_type {\n                                    OrderByType::Asc => Order::Asc,\n                                    OrderByType::Desc => Order::Desc,\n                                },\n                            })));\n                        gen_traversal.should_collect = ShouldCollect::ToVec;\n                    }\n                    _ => unreachable!(\"Cannot reach here\"),\n                }\n            }\n            StepType::Closure(cl) => {\n                if i != number_of_steps {\n                    generate_error!(ctx, original_query, cl.loc.clone(), E641);\n                }\n                // Add identifier to a temporary scope so inner uses pass\n                // For closures iterating over collections, singularize the type\n                let was_collection =\n                    matches!(cur_ty, Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_));\n                let closure_param_type = match &cur_ty {\n                    Type::Nodes(label) => Type::Node(label.clone()),\n                    Type::Edges(label) => Type::Edge(label.clone()),\n                    Type::Vectors(label) => Type::Vector(label.clone()),\n                    other => other.clone(),\n                };\n\n                // Extract the source variable name from the current traversal\n                let closure_source_var = match &gen_traversal.source_step {\n                    Separator::Empty(SourceStep::Identifier(var))\n                    | Separator::Period(SourceStep::Identifier(var))\n                    | Separator::Newline(SourceStep::Identifier(var)) => var.inner().clone(),\n                    _ => {\n                        // For other source types, try to extract from traversal_type\n                        match &gen_traversal.traversal_type {\n                            TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                var.inner().clone()\n                            }\n                            _ => String::new(),\n                        }\n                    }\n                };\n\n                // Closure parameters are always singular (they represent individual items during iteration)\n                scope.insert(\n                    cl.identifier.as_str(),\n                    VariableInfo::new_with_source(\n                        closure_param_type.clone(),\n                        true,\n                        closure_source_var.clone(),\n                    ),\n                );\n                let obj = &cl.object;\n                let mut fields_out = vec![];\n                // Pass the singular type to validate_object so nested traversals use the correct type\n                cur_ty = validate_object(\n                    ctx,\n                    &closure_param_type,\n                    obj,\n                    original_query,\n                    gen_traversal,\n                    &mut fields_out,\n                    scope,\n                    gen_query,\n                )\n                .ok()?;\n\n                // Tag all nested traversals with closure context\n                for (_field_name, nested_info) in gen_traversal.nested_traversals.iter_mut() {\n                    nested_info.closure_param_name = Some(cl.identifier.clone());\n                    nested_info.closure_source_var = Some(closure_source_var.clone());\n                }\n\n                // If we were iterating over a collection, ensure should_collect stays as ToVec\n                // validate_object may have set it to ToObj because we passed a singular type\n                if was_collection {\n                    gen_traversal.should_collect = ShouldCollect::ToVec;\n                    // Also convert the return type back to collection type\n                    // This ensures is_collection flag is set correctly in query_validation.rs\n                    cur_ty = match cur_ty {\n                        Type::Node(label) => Type::Nodes(label),\n                        Type::Edge(label) => Type::Edges(label),\n                        Type::Vector(label) => Type::Vectors(label),\n                        other => other,\n                    };\n                }\n\n                scope.remove(cl.identifier.as_str());\n            }\n            StepType::RerankRRF(rerank_rrf) => {\n                // Generate k parameter if provided\n                let k = rerank_rrf.k.as_ref().map(|k_expr| match &k_expr.expr {\n                    ExpressionType::Identifier(id) => {\n                        is_valid_identifier(ctx, original_query, k_expr.loc.clone(), id.as_str());\n                        type_in_scope(ctx, original_query, k_expr.loc.clone(), scope, id.as_str());\n                        gen_identifier_or_param(original_query, id.as_str(), false, true)\n                    }\n                    ExpressionType::IntegerLiteral(val) => {\n                        GeneratedValue::Primitive(GenRef::Std(val.to_string()))\n                    }\n                    ExpressionType::FloatLiteral(val) => {\n                        GeneratedValue::Primitive(GenRef::Std(val.to_string()))\n                    }\n                    _ => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            k_expr.loc.clone(),\n                            E206,\n                            &k_expr.expr.to_string()\n                        );\n                        GeneratedValue::Unknown\n                    }\n                });\n\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::RerankRRF(\n                        crate::helixc::generator::traversal_steps::RerankRRF { k },\n                    )));\n            }\n            StepType::RerankMMR(rerank_mmr) => {\n                // Generate lambda parameter\n                let lambda = match &rerank_mmr.lambda.expr {\n                    ExpressionType::Identifier(id) => {\n                        is_valid_identifier(\n                            ctx,\n                            original_query,\n                            rerank_mmr.lambda.loc.clone(),\n                            id.as_str(),\n                        );\n                        type_in_scope(\n                            ctx,\n                            original_query,\n                            rerank_mmr.lambda.loc.clone(),\n                            scope,\n                            id.as_str(),\n                        );\n                        Some(gen_identifier_or_param(\n                            original_query,\n                            id.as_str(),\n                            false,\n                            true,\n                        ))\n                    }\n                    ExpressionType::FloatLiteral(val) => {\n                        Some(GeneratedValue::Primitive(GenRef::Std(val.to_string())))\n                    }\n                    ExpressionType::IntegerLiteral(val) => {\n                        Some(GeneratedValue::Primitive(GenRef::Std(val.to_string())))\n                    }\n                    _ => {\n                        generate_error!(\n                            ctx,\n                            original_query,\n                            rerank_mmr.lambda.loc.clone(),\n                            E206,\n                            &rerank_mmr.lambda.expr.to_string()\n                        );\n                        None\n                    }\n                };\n\n                // Generate distance parameter if provided\n                let distance = if let Some(MMRDistance::Identifier(id)) = &rerank_mmr.distance {\n                    is_valid_identifier(ctx, original_query, rerank_mmr.loc.clone(), id.as_str());\n                    type_in_scope(ctx, original_query, rerank_mmr.loc.clone(), scope, id.as_str());\n                    Some(\n                        crate::helixc::generator::traversal_steps::MMRDistanceMethod::Identifier(\n                            id.clone(),\n                        ),\n                    )\n                } else {\n                    rerank_mmr.distance.as_ref().map(|d| match d {\n                        MMRDistance::Cosine => {\n                            crate::helixc::generator::traversal_steps::MMRDistanceMethod::Cosine\n                        }\n                        MMRDistance::Euclidean => {\n                            crate::helixc::generator::traversal_steps::MMRDistanceMethod::Euclidean\n                        }\n                        MMRDistance::DotProduct => {\n                            crate::helixc::generator::traversal_steps::MMRDistanceMethod::DotProduct\n                        }\n                        MMRDistance::Identifier(_) => unreachable!(),\n                    })\n                };\n\n                gen_traversal\n                    .steps\n                    .push(Separator::Period(GeneratedStep::RerankMMR(\n                        crate::helixc::generator::traversal_steps::RerankMMR { lambda, distance },\n                    )));\n            }\n        }\n        previous_step = Some(step.clone());\n    }\n    match gen_traversal.traversal_type {\n        TraversalType::Mut | TraversalType::Update(_) => {\n            gen_query.is_mut = true;\n        }\n        _ => {}\n    }\n    Some(cur_ty)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::helixc::analyzer::error_codes::ErrorCode;\n    use crate::helixc::parser::{HelixParser, write_to_temp_file};\n\n    // ============================================================================\n    // Start Node Validation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_undeclared_node_type_1968": {
      "name": "test_undeclared_node_type",
      "type": "function",
      "start_line": 1968,
      "end_line": 1986,
      "content_hash": "0458871c7cb1d71b138e9df19f950e2571660c61",
      "content": "    fn test_undeclared_node_type() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                company <- N<Company>\n                RETURN company\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E101));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_undeclared_edge_type_1987": {
      "name": "test_undeclared_edge_type",
      "type": "function",
      "start_line": 1987,
      "end_line": 2007,
      "content_hash": "2ddfcd1fd706a7627cef82b1f1b879d1137b5396",
      "content": "    fn test_undeclared_edge_type() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<WorksAt>\n                RETURN edges\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E102));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_undeclared_vector_type_2008": {
      "name": "test_undeclared_vector_type",
      "type": "function",
      "start_line": 2008,
      "end_line": 2026,
      "content_hash": "df47f58ab203c91faa33cb0fccb200d267778391",
      "content": "    fn test_undeclared_vector_type() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                docs <- V<Document>\n                RETURN docs\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E103));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_id_parameter_2027": {
      "name": "test_node_with_id_parameter",
      "type": "function",
      "start_line": 2027,
      "end_line": 2045,
      "content_hash": "502c09d314a6291b795bce887c328868b95c9505",
      "content": "    fn test_node_with_id_parameter() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_undefined_id_variable_2046": {
      "name": "test_node_with_undefined_id_variable",
      "type": "function",
      "start_line": 2046,
      "end_line": 2064,
      "content_hash": "54ab6ab34d8a38350ad96da1df1b91d957f09596",
      "content": "    fn test_node_with_undefined_id_variable() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                person <- N<Person>(unknownId)\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_without_id_2065": {
      "name": "test_node_without_id",
      "type": "function",
      "start_line": 2065,
      "end_line": 2083,
      "content_hash": "07e0102d1fbfb2ff5cd226b2cd77ecdae232feaf",
      "content": "    fn test_node_without_id() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                people <- N<Person>\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_identifier_start_node_2084": {
      "name": "test_identifier_start_node",
      "type": "function",
      "start_line": 2084,
      "end_line": 2103,
      "content_hash": "178d4ae1b28bff83dd42e95b218fca965f0cd308",
      "content": "    fn test_identifier_start_node() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                person <- N<Person>\n                samePerson <- person\n                RETURN samePerson\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_identifier_not_in_scope_2104": {
      "name": "test_identifier_not_in_scope",
      "type": "function",
      "start_line": 2104,
      "end_line": 2126,
      "content_hash": "b0bc71c9f60bd5c384559a577da69b9f8cebc936",
      "content": "    fn test_identifier_not_in_scope() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                person <- unknownVariable\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    // ============================================================================\n    // Traversal Step Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_valid_out_traversal_2127": {
      "name": "test_valid_out_traversal",
      "type": "function",
      "start_line": 2127,
      "end_line": 2147,
      "content_hash": "1e100408fdf58d3f6da8cae5975e80f9ae7b9078",
      "content": "    fn test_valid_out_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                friends <- person::Out<Knows>\n                RETURN friends\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_property_access_2148": {
      "name": "test_property_access",
      "type": "function",
      "start_line": 2148,
      "end_line": 2174,
      "content_hash": "eaa0c4c5ca1f11a769b4ecaff9faeea18cb25624",
      "content": "    fn test_property_access() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                name <- person::{name}\n                RETURN name\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    // Note: Property errors are caught during object validation, not traversal validation\n    // Removing test_property_not_exists as it requires different assertion approach\n\n    // ============================================================================\n    // Where Clause Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_where_with_property_equals_2175": {
      "name": "test_where_with_property_equals",
      "type": "function",
      "start_line": 2175,
      "end_line": 2193,
      "content_hash": "252e87f53f1ef8a929834e9f30416483b98fbc7f",
      "content": "    fn test_where_with_property_equals() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(targetAge: U32) =>\n                people <- N<Person>::WHERE(_::{age}::EQ(targetAge))\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_where_with_property_greater_than_2194": {
      "name": "test_where_with_property_greater_than",
      "type": "function",
      "start_line": 2194,
      "end_line": 2219,
      "content_hash": "0817d8ab867b48c2aab70b05345c3b0b06bfae2f",
      "content": "    fn test_where_with_property_greater_than() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(minAge: U32) =>\n                people <- N<Person>::WHERE(_::{age}::GT(minAge))\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    // Note: Removed tests for UPDATE, Range, and property errors as they require\n    // different syntax or validation approaches than initially assumed\n\n    // ============================================================================\n    // Chained Traversal Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_chained_edge_traversal_2220": {
      "name": "test_chained_edge_traversal",
      "type": "function",
      "start_line": 2220,
      "end_line": 2241,
      "content_hash": "f4d122df2fbaaeab43bfb1b47e3ada2e3bf55c18",
      "content": "    fn test_chained_edge_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<Knows>\n                targets <- edges::ToN\n                RETURN targets\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_multi_hop_traversal_2242": {
      "name": "test_multi_hop_traversal",
      "type": "function",
      "start_line": 2242,
      "end_line": 2266,
      "content_hash": "756a302bfcc9f00be0211ca06889032c43cfea86",
      "content": "    fn test_multi_hop_traversal() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                friends <- N<Person>(id)::Out<Knows>\n                friendsOfFriends <- friends::Out<Knows>\n                RETURN friendsOfFriends\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    // ============================================================================\n    // Complex Query Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_complex_query_with_multiple_steps_2267": {
      "name": "test_complex_query_with_multiple_steps",
      "type": "function",
      "start_line": 2267,
      "end_line": 2287,
      "content_hash": "5e3a1f61565b398401dd2c012a4c547e9c20d06d",
      "content": "    fn test_complex_query_with_multiple_steps() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID, minAge: U32) =>\n                person <- N<Person>(id)\n                friends <- person::Out<Knows>::WHERE(_::{age}::GT(minAge))\n                names <- friends::{name}\n                RETURN names\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}