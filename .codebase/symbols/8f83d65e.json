{
  "file_path": "/work/internal/agent/coordinator.go",
  "file_hash": "ed843d407072a432451237d5d3e0e77c70ed66ce",
  "updated_at": "2025-12-26T17:34:25.014777",
  "symbols": {
    "interface_Coordinator_55": {
      "name": "Coordinator",
      "type": "interface",
      "start_line": 55,
      "end_line": 70,
      "content_hash": "ff25ca84b2032842dc369e0d27f0d39f4529e312",
      "content": "type Coordinator interface {\n\t// INFO: (kujtim) this is not used yet we will use this when we have multiple agents\n\t// SetMainAgent(string)\n\tRun(ctx context.Context, sessionID, prompt string, attachments ...message.Attachment) (*fantasy.AgentResult, error)\n\tCancel(sessionID string)\n\tCancelAll()\n\tIsSessionBusy(sessionID string) bool\n\tIsBusy() bool\n\tQueuedPrompts(sessionID string) int\n\tClearQueue(sessionID string)\n\tSummarize(context.Context, string) error\n\tModel() Model\n\tUpdateModels(ctx context.Context) error\n}\n\n// timeoutWrappedTool is a tool that wraps another tool with timeout enforcement",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_timeoutWrappedTool_71": {
      "name": "timeoutWrappedTool",
      "type": "struct",
      "start_line": 71,
      "end_line": 77,
      "content_hash": "55aee889688483e3c7e9ac705e27c87df88b1f8b",
      "content": "type timeoutWrappedTool struct {\n\toriginal fantasy.AgentTool\n\ttimeout  time.Duration\n\tinfo     fantasy.ToolInfo\n}\n\n// Info returns the original tool info",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Info_78": {
      "name": "Info",
      "type": "method",
      "start_line": 78,
      "end_line": 82,
      "content_hash": "7f729d004921b5158a5497182a702a2e1da19faf",
      "content": "func (t *timeoutWrappedTool) Info() fantasy.ToolInfo {\n\treturn t.info\n}\n\n// Run executes the original tool with timeout enforcement",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Run_83": {
      "name": "Run",
      "type": "method",
      "start_line": 83,
      "end_line": 88,
      "content_hash": "623d154d246c269f848db8ff88f4c9f0aa24e03b",
      "content": "func (t *timeoutWrappedTool) Run(ctx context.Context, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t// Create timeout context\n\ttimeoutCtx, cancel := context.WithTimeout(ctx, t.timeout)\n\tdefer cancel()\n\n\t// Channel to capture result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_result_89": {
      "name": "result",
      "type": "struct",
      "start_line": 89,
      "end_line": 110,
      "content_hash": "73417fa1a036f7c271888325cf9d2fb63c135f54",
      "content": "\ttype result struct {\n\t\tresp fantasy.ToolResponse\n\t\terr  error\n\t}\n\tresultChan := make(chan result, 1)\n\n\t// Execute original tool in goroutine\n\tgo func() {\n\t\tresp, err := t.original.Run(timeoutCtx, call)\n\t\tresultChan <- result{resp: resp, err: err}\n\t}()\n\n\t// Wait for result or timeout\n\tselect {\n\tcase res := <-resultChan:\n\t\treturn res.resp, res.err\n\tcase <-timeoutCtx.Done():\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"tool timed out after %v\", t.timeout)), timeoutCtx.Err()\n\t}\n}\n\n// ProviderOptions returns the original tool's provider options",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ProviderOptions_111": {
      "name": "ProviderOptions",
      "type": "method",
      "start_line": 111,
      "end_line": 115,
      "content_hash": "9a8848c92a0c3ab916df59a5c9ff321603bd598e",
      "content": "func (t *timeoutWrappedTool) ProviderOptions() fantasy.ProviderOptions {\n\treturn t.original.ProviderOptions()\n}\n\n// SetProviderOptions sets the provider options on the original tool",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetProviderOptions_116": {
      "name": "SetProviderOptions",
      "type": "method",
      "start_line": 116,
      "end_line": 119,
      "content_hash": "a9488a116eb66c10a4bd4d535c969235898b57c5",
      "content": "func (t *timeoutWrappedTool) SetProviderOptions(opts fantasy.ProviderOptions) {\n\tt.original.SetProviderOptions(opts)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_coordinator_120": {
      "name": "coordinator",
      "type": "struct",
      "start_line": 120,
      "end_line": 136,
      "content_hash": "f6604bf95222ef106dbfb25489c0bd4bd98e84eb",
      "content": "type coordinator struct {\n\tcfg             *config.Config\n\tsessions        session.Service\n\tmessages        message.Service\n\tpermissions     permission.Service\n\thistory         history.Service\n\tlspClients      *csync.Map[string, *lsp.Client]\n\taiops           aiops.Ops\n\tsessionLog      *sessionlog.Manager\n\tresourceMonitor *resources.Monitor\n\n\tcurrentAgent SessionAgent\n\tagents       map[string]SessionAgent\n\n\treadyWg errgroup.Group\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCoordinator_137": {
      "name": "NewCoordinator",
      "type": "function",
      "start_line": 137,
      "end_line": 182,
      "content_hash": "c26269fee6c962af25ea9e4f2daf0dc8d21ebcbe",
      "content": "func NewCoordinator(\n\tctx context.Context,\n\tcfg *config.Config,\n\tsessions session.Service,\n\tmessages message.Service,\n\tpermissions permission.Service,\n\thistory history.Service,\n\tlspClients *csync.Map[string, *lsp.Client],\n\taiops aiops.Ops,\n\tsessionLog *sessionlog.Manager,\n\tresourceMonitor *resources.Monitor,\n) (Coordinator, error) {\n\tc := &coordinator{\n\t\tcfg:             cfg,\n\t\tsessions:        sessions,\n\t\tmessages:        messages,\n\t\tpermissions:     permissions,\n\t\thistory:         history,\n\t\tlspClients:      lspClients,\n\t\taiops:           aiops,\n\t\tsessionLog:      sessionLog,\n\t\tresourceMonitor: resourceMonitor,\n\t\tagents:          make(map[string]SessionAgent),\n\t}\n\n\tagentCfg, ok := cfg.Agents[config.AgentCoder]\n\tif !ok {\n\t\treturn nil, errors.New(\"coder agent not configured\")\n\t}\n\n\t// TODO: make this dynamic when we support multiple agents\n\tprompt, err := coderPrompt(prompt.WithWorkingDir(c.cfg.WorkingDir()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tagent, err := c.buildAgent(ctx, prompt, agentCfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.currentAgent = agent\n\tc.agents[config.AgentCoder] = agent\n\treturn c, nil\n}\n\n// Run implements Coordinator.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Run_183": {
      "name": "Run",
      "type": "method",
      "start_line": 183,
      "end_line": 246,
      "content_hash": "82be38b9c6e4b5d926dc8106cac2aec744837700",
      "content": "func (c *coordinator) Run(ctx context.Context, sessionID string, prompt string, attachments ...message.Attachment) (*fantasy.AgentResult, error) {\n\tif err := c.readyWg.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodel := c.currentAgent.Model()\n\tmaxTokens := model.CatwalkCfg.DefaultMaxTokens\n\tif model.ModelCfg.MaxTokens != 0 {\n\t\tmaxTokens = model.ModelCfg.MaxTokens\n\t}\n\n\t// Ensure maxTokens is at least 1 to satisfy API requirements\n\t// Anthropic and other providers require max_tokens >= 1\n\tif maxTokens == 0 {\n\t\t// Fallback to a reasonable default based on context window\n\t\tif model.CatwalkCfg.ContextWindow > 100000 {\n\t\t\tmaxTokens = 8000 // For large context models\n\t\t} else {\n\t\t\tmaxTokens = 4096 // Standard default\n\t\t}\n\t\tslog.Debug(\"MaxTokens was 0, using fallback\",\n\t\t\t\"model\", model.ModelCfg.Model,\n\t\t\t\"fallback_max_tokens\", maxTokens)\n\t}\n\n\tif !model.CatwalkCfg.SupportsImages && attachments != nil {\n\t\tattachments = nil\n\t}\n\n\tproviderCfg, ok := c.cfg.Providers.Get(model.ModelCfg.Provider)\n\tif !ok {\n\t\treturn nil, errors.New(\"model provider not configured\")\n\t}\n\n\tmergedOptions, temp, topP, topK, freqPenalty, presPenalty := mergeCallOptions(model, providerCfg)\n\n\tif providerCfg.OAuthToken != nil && providerCfg.OAuthToken.IsExpired() {\n\t\tslog.Info(\"Detected expired OAuth token, attempting refresh\", \"provider\", providerCfg.ID)\n\t\tif refreshErr := c.cfg.RefreshOAuthToken(ctx, providerCfg.ID); refreshErr != nil {\n\t\t\tslog.Error(\"Failed to refresh OAuth token\", \"provider\", providerCfg.ID, \"error\", refreshErr)\n\t\t\treturn nil, refreshErr\n\t\t}\n\n\t\t// Rebuild models with refreshed token\n\t\tif updateErr := c.UpdateModels(ctx); updateErr != nil {\n\t\t\tslog.Error(\"Failed to update models after token refresh\", \"error\", updateErr)\n\t\t\treturn nil, updateErr\n\t\t}\n\t}\n\tresult, err := c.currentAgent.Run(ctx, SessionAgentCall{\n\t\tSessionID:        sessionID,\n\t\tPrompt:           prompt,\n\t\tAttachments:      attachments,\n\t\tMaxOutputTokens:  maxTokens,\n\t\tProviderOptions:  mergedOptions,\n\t\tTemperature:      temp,\n\t\tTopP:             topP,\n\t\tTopK:             topK,\n\t\tFrequencyPenalty: freqPenalty,\n\t\tPresencePenalty:  presPenalty,\n\t})\n\treturn result, err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getProviderOptions_247": {
      "name": "getProviderOptions",
      "type": "function",
      "start_line": 247,
      "end_line": 366,
      "content_hash": "2cd303a9f162726b1871d24c9593496ab581ebbe",
      "content": "func getProviderOptions(model Model, providerCfg config.ProviderConfig) fantasy.ProviderOptions {\n\toptions := fantasy.ProviderOptions{}\n\n\tcfgOpts := []byte(\"{}\")\n\tproviderCfgOpts := []byte(\"{}\")\n\tcatwalkOpts := []byte(\"{}\")\n\n\tif model.ModelCfg.ProviderOptions != nil {\n\t\tdata, err := json.Marshal(model.ModelCfg.ProviderOptions)\n\t\tif err == nil {\n\t\t\tcfgOpts = data\n\t\t}\n\t}\n\n\tif providerCfg.ProviderOptions != nil {\n\t\tdata, err := json.Marshal(providerCfg.ProviderOptions)\n\t\tif err == nil {\n\t\t\tproviderCfgOpts = data\n\t\t}\n\t}\n\n\tif model.CatwalkCfg.Options.ProviderOptions != nil {\n\t\tdata, err := json.Marshal(model.CatwalkCfg.Options.ProviderOptions)\n\t\tif err == nil {\n\t\t\tcatwalkOpts = data\n\t\t}\n\t}\n\n\treaders := []io.Reader{\n\t\tbytes.NewReader(catwalkOpts),\n\t\tbytes.NewReader(providerCfgOpts),\n\t\tbytes.NewReader(cfgOpts),\n\t}\n\n\tgot, err := jsons.Merge(readers)\n\tif err != nil {\n\t\tslog.Error(\"Could not merge call config\", \"err\", err)\n\t\treturn options\n\t}\n\n\tmergedOptions := make(map[string]any)\n\n\terr = json.Unmarshal([]byte(got), &mergedOptions)\n\tif err != nil {\n\t\tslog.Error(\"Could not create config for call\", \"err\", err)\n\t\treturn options\n\t}\n\n\tswitch providerCfg.Type {\n\tcase openai.Name, azure.Name:\n\t\t_, hasReasoningEffort := mergedOptions[\"reasoning_effort\"]\n\t\tif !hasReasoningEffort && model.ModelCfg.ReasoningEffort != \"\" {\n\t\t\tmergedOptions[\"reasoning_effort\"] = model.ModelCfg.ReasoningEffort\n\t\t}\n\t\tif openai.IsResponsesModel(model.CatwalkCfg.ID) {\n\t\t\tif openai.IsResponsesReasoningModel(model.CatwalkCfg.ID) {\n\t\t\t\tmergedOptions[\"reasoning_summary\"] = \"auto\"\n\t\t\t\tmergedOptions[\"include\"] = []openai.IncludeType{openai.IncludeReasoningEncryptedContent}\n\t\t\t}\n\t\t\tparsed, err := openai.ParseResponsesOptions(mergedOptions)\n\t\t\tif err == nil {\n\t\t\t\toptions[openai.Name] = parsed\n\t\t\t}\n\t\t} else {\n\t\t\tparsed, err := openai.ParseOptions(mergedOptions)\n\t\t\tif err == nil {\n\t\t\t\toptions[openai.Name] = parsed\n\t\t\t}\n\t\t}\n\tcase anthropic.Name:\n\t\t_, hasThink := mergedOptions[\"thinking\"]\n\t\tif !hasThink && model.ModelCfg.Think {\n\t\t\tmergedOptions[\"thinking\"] = map[string]any{\n\t\t\t\t// TODO: kujtim see if we need to make this dynamic\n\t\t\t\t\"budget_tokens\": 2000,\n\t\t\t}\n\t\t}\n\t\tparsed, err := anthropic.ParseOptions(mergedOptions)\n\t\tif err == nil {\n\t\t\toptions[anthropic.Name] = parsed\n\t\t}\n\n\tcase openrouter.Name:\n\t\t_, hasReasoning := mergedOptions[\"reasoning\"]\n\t\tif !hasReasoning && model.ModelCfg.ReasoningEffort != \"\" {\n\t\t\tmergedOptions[\"reasoning\"] = map[string]any{\n\t\t\t\t\"enabled\": true,\n\t\t\t\t\"effort\":  model.ModelCfg.ReasoningEffort,\n\t\t\t}\n\t\t}\n\t\tparsed, err := openrouter.ParseOptions(mergedOptions)\n\t\tif err == nil {\n\t\t\toptions[openrouter.Name] = parsed\n\t\t}\n\tcase google.Name:\n\t\t_, hasReasoning := mergedOptions[\"thinking_config\"]\n\t\tif !hasReasoning {\n\t\t\tmergedOptions[\"thinking_config\"] = map[string]any{\n\t\t\t\t\"thinking_budget\":  2000,\n\t\t\t\t\"include_thoughts\": true,\n\t\t\t}\n\t\t}\n\t\tparsed, err := google.ParseOptions(mergedOptions)\n\t\tif err == nil {\n\t\t\toptions[google.Name] = parsed\n\t\t}\n\tcase openaicompat.Name:\n\t\t_, hasReasoningEffort := mergedOptions[\"reasoning_effort\"]\n\t\tif !hasReasoningEffort && model.ModelCfg.ReasoningEffort != \"\" {\n\t\t\tmergedOptions[\"reasoning_effort\"] = model.ModelCfg.ReasoningEffort\n\t\t}\n\t\tparsed, err := openaicompat.ParseOptions(mergedOptions)\n\t\tif err == nil {\n\t\t\toptions[openaicompat.Name] = parsed\n\t\t}\n\t}\n\n\treturn options\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_mergeCallOptions_367": {
      "name": "mergeCallOptions",
      "type": "function",
      "start_line": 367,
      "end_line": 376,
      "content_hash": "c07172bacd1a463636468adb78bbd54f527ced36",
      "content": "func mergeCallOptions(model Model, cfg config.ProviderConfig) (fantasy.ProviderOptions, *float64, *float64, *int64, *float64, *float64) {\n\tmodelOptions := getProviderOptions(model, cfg)\n\ttemp := cmp.Or(model.ModelCfg.Temperature, model.CatwalkCfg.Options.Temperature)\n\ttopP := cmp.Or(model.ModelCfg.TopP, model.CatwalkCfg.Options.TopP)\n\ttopK := cmp.Or(model.ModelCfg.TopK, model.CatwalkCfg.Options.TopK)\n\tfreqPenalty := cmp.Or(model.ModelCfg.FrequencyPenalty, model.CatwalkCfg.Options.FrequencyPenalty)\n\tpresPenalty := cmp.Or(model.ModelCfg.PresencePenalty, model.CatwalkCfg.Options.PresencePenalty)\n\treturn modelOptions, temp, topP, topK, freqPenalty, presPenalty\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildAgent_377": {
      "name": "buildAgent",
      "type": "method",
      "start_line": 377,
      "end_line": 419,
      "content_hash": "8c4da06e1a19ff5f7d1c76130a9cec3ffae16c2c",
      "content": "func (c *coordinator) buildAgent(ctx context.Context, prompt *prompt.Prompt, agent config.Agent) (SessionAgent, error) {\n\tlarge, small, err := c.buildAgentModels(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsystemPrompt, err := prompt.Build(ctx, large.Model.Provider(), large.Model.Model(), *c.cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlargeProviderCfg, _ := c.cfg.Providers.Get(large.ModelCfg.Provider)\n\tresult := NewSessionAgent(SessionAgentOptions{\n\t\tLargeModel:         large,\n\t\tSmallModel:         small,\n\t\tSystemPromptPrefix: largeProviderCfg.SystemPromptPrefix,\n\t\tSystemPrompt:       systemPrompt,\n\t\tSessions:           c.sessions,\n\t\tMessages:           c.messages,\n\n\t\tTools:           nil,\n\t\tAIOPS:           c.aiops,\n\t\tResourceMonitor: c.resourceMonitor,\n\t})\n\tc.readyWg.Go(func() error {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tslog.Error(\"Panic caught while building tools\", \"error\", r)\n\t\t\t}\n\t\t}()\n\n\t\ttools, err := c.buildTools(ctx, agent)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresult.SetTools(tools)\n\t\treturn nil\n\t})\n\n\treturn result, nil\n}\n\n// safeCreateTool safely creates a tool and catches any panics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_safeCreateTool_420": {
      "name": "safeCreateTool",
      "type": "method",
      "start_line": 420,
      "end_line": 451,
      "content_hash": "7f4f68e37e8a99cf57dca39cd6d5c6a05f6b0010",
      "content": "func (c *coordinator) safeCreateTool(createFunc func() fantasy.AgentTool) fantasy.AgentTool {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tslog.Error(\"Panic caught during tool creation\", \"error\", r)\n\t\t}\n\t}()\n\n\ttool := createFunc()\n\tif tool == nil {\n\t\tslog.Warn(\"Tool creation returned nil\")\n\t\treturn nil\n\t}\n\n\t// Validate the tool can at least return basic info (still inside panic protection)\n\tvar info fantasy.ToolInfo\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tslog.Error(\"Panic caught while getting tool info during validation\", \"error\", r)\n\t\t\t}\n\t\t}()\n\t\tinfo = tool.Info()\n\t}()\n\n\tif info.Name == \"\" {\n\t\tslog.Warn(\"Tool has empty name, skipping\")\n\t\treturn nil\n\t}\n\n\treturn tool\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildTools_452": {
      "name": "buildTools",
      "type": "method",
      "start_line": 452,
      "end_line": 624,
      "content_hash": "364159a57e479c8492fb25ff93a7d13e29816e4a",
      "content": "func (c *coordinator) buildTools(ctx context.Context, agent config.Agent) ([]fantasy.AgentTool, error) {\n\tvar allTools []fantasy.AgentTool\n\tif slices.Contains(agent.AllowedTools, AgentToolName) {\n\t\tagentTool, err := c.agentTool(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif agentTool != nil {\n\t\t\tallTools = append(allTools, agentTool)\n\t\t}\n\t}\n\n\tif slices.Contains(agent.AllowedTools, tools.AgenticFetchToolName) {\n\t\tagenticFetchTool, err := c.agenticFetchTool(ctx, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif agenticFetchTool != nil {\n\t\t\tallTools = append(allTools, agenticFetchTool)\n\t\t}\n\t}\n\n\t// Get the model name for the agent\n\tmodelName := \"\"\n\tif modelCfg, ok := c.cfg.Models[agent.Model]; ok {\n\t\tif model := c.cfg.GetModel(modelCfg.Provider, modelCfg.Model); model != nil {\n\t\t\tmodelName = model.Name\n\t\t}\n\t}\n\n\tallTools = append(allTools,\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewBashTool(c.permissions, c.cfg.WorkingDir(), c.cfg.Options.Attribution, modelName)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewJobOutputTool()\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewJobKillTool()\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewDownloadTool(c.permissions, c.cfg.WorkingDir(), nil)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewEditTool(c.lspClients, c.permissions, c.history, c.cfg.WorkingDir(), c.aiops)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewMultiEditTool(c.lspClients, c.permissions, c.history, c.cfg.WorkingDir(), c.aiops)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewFetchTool(c.permissions, c.cfg.WorkingDir(), nil)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewGlobTool(c.cfg.WorkingDir())\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewGrepTool(c.cfg.WorkingDir())\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewLsTool(c.permissions, c.cfg.WorkingDir(), c.cfg.Tools.Ls)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewSourcegraphTool(nil)\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewViewTool(c.lspClients, c.permissions, c.cfg.WorkingDir())\n\t\t}),\n\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\treturn tools.NewWriteTool(c.lspClients, c.permissions, c.history, c.cfg.WorkingDir())\n\t\t}),\n\t)\n\n\tif len(c.cfg.LSP) > 0 {\n\t\tallTools = append(allTools,\n\t\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\t\treturn tools.NewDiagnosticsTool(c.lspClients)\n\t\t\t}),\n\t\t\tc.safeCreateTool(func() fantasy.AgentTool {\n\t\t\t\treturn tools.NewReferencesTool(c.lspClients)\n\t\t\t}),\n\t\t)\n\t}\n\n\tvar filteredTools []fantasy.AgentTool\n\tfor _, tool := range allTools {\n\t\tif tool == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Safely get tool info\n\t\tinfo := tool.Info()\n\t\tif info.Name == \"\" {\n\t\t\tslog.Warn(\"Skipping tool with empty name\")\n\t\t\tcontinue\n\t\t}\n\n\t\tif slices.Contains(agent.AllowedTools, info.Name) {\n\t\t\tfilteredTools = append(filteredTools, tool)\n\t\t}\n\t}\n\n\t// Apply timeout enforcement to all tools with safety checks\n\tsafeTools := make([]fantasy.AgentTool, 0, len(filteredTools))\n\tfor _, tool := range filteredTools {\n\t\tif tool == nil {\n\t\t\tslog.Warn(\"Skipping nil tool during timeout wrapping\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Safely wrap tool and catch any panics\n\t\twrappedTool := c.wrapToolWithTimeout(tool)\n\t\tif wrappedTool != nil {\n\t\t\tsafeTools = append(safeTools, wrappedTool)\n\t\t} else {\n\t\t\tslog.Warn(\"Tool wrapping returned nil, skipping\", \"tool\", tool.Info().Name)\n\t\t}\n\t}\n\n\t// Replace filtered tools with safe ones\n\tfilteredTools = safeTools\n\n\tfor _, tool := range tools.GetMCPTools(c.permissions, c.cfg.WorkingDir()) {\n\t\tif tool == nil {\n\t\t\tslog.Warn(\"Skipping nil MCP tool\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Safely get MCP tool info\n\t\tif toolName := tool.Name(); toolName == \"\" {\n\t\t\tslog.Warn(\"Skipping MCP tool with empty name\")\n\t\t\tcontinue\n\t\t}\n\n\t\tif agent.AllowedMCP == nil {\n\t\t\t// No MCP restrictions\n\t\t\tfilteredTools = append(filteredTools, tool)\n\t\t\tcontinue\n\t\t}\n\t\tif len(agent.AllowedMCP) == 0 {\n\t\t\t// No MCPs allowed\n\t\t\tslog.Debug(\"no MCPs allowed\", \"tool\", tool.Name(), \"agent\", agent.Name)\n\t\t\tbreak\n\t\t}\n\n\t\tfor mcp, toolList := range agent.AllowedMCP {\n\t\t\tif mcp != tool.MCP() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(toolList) == 0 || slices.Contains(toolList, tool.MCPToolName()) {\n\t\t\t\tfilteredTools = append(filteredTools, tool)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif agent.AllowedMCP != nil {\n\t\t\tslog.Debug(\"MCP not allowed\", \"tool\", tool.Name(), \"agent\", agent.Name)\n\t\t}\n\t}\n\tslices.SortFunc(filteredTools, func(a, b fantasy.AgentTool) int {\n\t\tif a == nil || b == nil {\n\t\t\treturn 0\n\t\t}\n\t\taInfo := a.Info()\n\t\tbInfo := b.Info()\n\t\tif aInfo.Name == \"\" || bInfo.Name == \"\" {\n\t\t\treturn 0\n\t\t}\n\t\treturn strings.Compare(aInfo.Name, bInfo.Name)\n\t})\n\treturn filteredTools, nil\n}\n\n// SequentialEditSolver reorders multiedit operations by line numbers to prevent conflicts\n// When multiple edits target the same file, this ensures they're applied in correct order",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SequentialEditSolver_625": {
      "name": "SequentialEditSolver",
      "type": "struct",
      "start_line": 625,
      "end_line": 627,
      "content_hash": "b7080a2dd489f48fcb2cf49ccf6578b3dbc73e86",
      "content": "type SequentialEditSolver struct{}\n\n// NewSequentialEditSolver creates a new sequential edit solver",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewSequentialEditSolver_628": {
      "name": "NewSequentialEditSolver",
      "type": "function",
      "start_line": 628,
      "end_line": 632,
      "content_hash": "6feb15876d0f91bd4877c6e92cffe4ea5d640785",
      "content": "func NewSequentialEditSolver() *SequentialEditSolver {\n\treturn &SequentialEditSolver{}\n}\n\n// EditLocation represents line position of an edit operation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EditLocation_633": {
      "name": "EditLocation",
      "type": "struct",
      "start_line": 633,
      "end_line": 639,
      "content_hash": "f4a23304dfe2e1e79cd935b3f57a02e003de89fd",
      "content": "type EditLocation struct {\n\tStartLine int\n\tEndLine   int\n\tFilePath  string\n}\n\n// ExtractEditLocation extracts line numbers from old_string to determine edit position",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ExtractEditLocation_640": {
      "name": "ExtractEditLocation",
      "type": "method",
      "start_line": 640,
      "end_line": 669,
      "content_hash": "31b48a4b9c43cf051bfeb15321300f27c180cb79",
      "content": "func (s *SequentialEditSolver) ExtractEditLocation(oldString string) EditLocation {\n\tlines := strings.Split(oldString, \"\\n\")\n\tstartLine := 0\n\tendLine := 0\n\n\t// Try to extract line numbers from context strings (if available)\n\t// Format: \"file.go:line\" or \"file.go:start-end\"\n\tre := regexp.MustCompile(`:(\\d+)(?:-(\\d+))?`)\n\tmatches := re.FindStringSubmatch(oldString)\n\tif len(matches) >= 2 {\n\t\tstartLine, _ = strconv.Atoi(matches[1])\n\t\tif len(matches) >= 3 && matches[2] != \"\" {\n\t\t\tendLine, _ = strconv.Atoi(matches[2])\n\t\t} else {\n\t\t\tendLine = startLine\n\t\t}\n\t} else {\n\t\t// If no line numbers found, estimate based on content\n\t\tstartLine = 1 // Default to start\n\t\tendLine = len(lines)\n\t}\n\n\treturn EditLocation{\n\t\tStartLine: startLine,\n\t\tEndLine:   endLine,\n\t\tFilePath:  \"\", // Will be filled by caller\n\t}\n}\n\n// OrderEdits sorts multiedit operations by line number to prevent conflicts",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_OrderEdits_670": {
      "name": "OrderEdits",
      "type": "method",
      "start_line": 670,
      "end_line": 675,
      "content_hash": "a319517a38e5be6cc0ef816c47a0e42b73352a6a",
      "content": "func (s *SequentialEditSolver) OrderEdits(edits []tools.EditParams, filePath string) []tools.EditParams {\n\tif len(edits) <= 1 {\n\t\treturn edits\n\t}\n\n\t// Create sortable edits with location info",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_sortableEdit_676": {
      "name": "sortableEdit",
      "type": "struct",
      "start_line": 676,
      "end_line": 708,
      "content_hash": "862c5406ee092c7651d13c5a1af43178a3dc78f8",
      "content": "\ttype sortableEdit struct {\n\t\tEdit     tools.EditParams\n\t\tLocation EditLocation\n\t}\n\n\tsortableEdits := make([]sortableEdit, len(edits))\n\tfor i, edit := range edits {\n\t\tlocation := s.ExtractEditLocation(edit.OldString)\n\t\tlocation.FilePath = filePath\n\t\tsortableEdits[i] = sortableEdit{\n\t\t\tEdit:     edit,\n\t\t\tLocation: location,\n\t\t}\n\t}\n\n\t// Sort by line number (ascending)\n\tslices.SortFunc(sortableEdits, func(a, b sortableEdit) int {\n\t\tif a.Location.StartLine != b.Location.StartLine {\n\t\t\treturn cmp.Compare(a.Location.StartLine, b.Location.StartLine)\n\t\t}\n\t\treturn cmp.Compare(a.Location.EndLine, b.Location.EndLine)\n\t})\n\n\t// Extract ordered edits\n\torderedEdits := make([]tools.EditParams, len(edits))\n\tfor i, sortable := range sortableEdits {\n\t\torderedEdits[i] = sortable.Edit\n\t}\n\n\treturn orderedEdits\n}\n\n// wrapToolWithTimeout wraps a tool function with timeout enforcement",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_wrapToolWithTimeout_709": {
      "name": "wrapToolWithTimeout",
      "type": "method",
      "start_line": 709,
      "end_line": 745,
      "content_hash": "5b09c64803ef2e0278786335bb430b7fffb63401",
      "content": "func (c *coordinator) wrapToolWithTimeout(tool fantasy.AgentTool) fantasy.AgentTool {\n\t// Defensive: check if tool is nil to prevent panic\n\tif tool == nil {\n\t\tslog.Error(\"Attempted to wrap nil tool\")\n\t\treturn nil\n\t}\n\n\t// Get tool info safely with panic protection\n\tvar info fantasy.ToolInfo\n\tpanicked := true\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tslog.Error(\"Panic caught while getting tool info\", \"error\", r)\n\t\t\t}\n\t\t}()\n\t\tinfo = tool.Info()\n\t\tpanicked = false\n\t}()\n\n\tif panicked || info.Name == \"\" {\n\t\tslog.Error(\"Tool has empty name or panicked\", \"tool\", tool)\n\t\treturn nil\n\t}\n\n\t// Create timeout wrapper\n\ttimeout := c.getToolTimeout(info.Name)\n\n\t// Return a new tool that wraps the original with timeout logic\n\treturn &timeoutWrappedTool{\n\t\toriginal: tool,\n\t\ttimeout:  timeout,\n\t\tinfo:     info,\n\t}\n}\n\n// getToolTimeout returns the appropriate timeout for a tool based on its name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getToolTimeout_746": {
      "name": "getToolTimeout",
      "type": "method",
      "start_line": 746,
      "end_line": 766,
      "content_hash": "74a1b819bfa842bb9fdcf945edc2d73d0129c302",
      "content": "func (c *coordinator) getToolTimeout(toolName string) time.Duration {\n\tswitch toolName {\n\tcase \"bash\":\n\t\t// Bash commands can run longer, especially for builds/tests\n\t\treturn criticalToolTimeout\n\tcase \"agentic_fetch\", \"fetch\":\n\t\t// Network operations need longer timeouts\n\t\treturn criticalToolTimeout\n\tcase \"view\", \"grep\", \"ls\", \"glob\":\n\t\t// Read-only operations are fast\n\t\treturn defaultToolTimeout\n\tcase \"edit\", \"multiedit\", \"write\":\n\t\t// File operations can take some time for large files\n\t\treturn 2 * time.Minute\n\tdefault:\n\t\treturn defaultToolTimeout\n\t}\n}\n\n// TODO: when we support multiple agents we need to change this so that we pass in the agent specific model config\n// TODO: enhance agent execution by implementing: 1) Execution-first prompting that prioritizes tool usage over explanations, 2) Incremental execution pipeline with immediate tool calls after analysis, 3) Self-correction loops that retry failed actions instead of stopping, 4) Tool-chain orchestration for multi-step operations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildAgentModels_767": {
      "name": "buildAgentModels",
      "type": "method",
      "start_line": 767,
      "end_line": 894,
      "content_hash": "8e0c378666c4facd4b1d5d3d2234c8b63b968459",
      "content": "func (c *coordinator) buildAgentModels(ctx context.Context) (Model, Model, error) {\n\tlargeModelCfg, ok := c.cfg.Models[config.SelectedModelTypeLarge]\n\tif !ok {\n\t\treturn Model{}, Model{}, errors.New(\"large model not selected\")\n\t}\n\tsmallModelCfg, ok := c.cfg.Models[config.SelectedModelTypeSmall]\n\tif !ok {\n\t\treturn Model{}, Model{}, errors.New(\"small model not selected\")\n\t}\n\n\tlargeProviderCfg, ok := c.cfg.Providers.Get(largeModelCfg.Provider)\n\tif !ok {\n\t\treturn Model{}, Model{}, errors.New(\"large model provider not configured\")\n\t}\n\n\tlargeProvider, err := c.buildProvider(largeProviderCfg, largeModelCfg)\n\tif err != nil {\n\t\treturn Model{}, Model{}, err\n\t}\n\n\tsmallProviderCfg, ok := c.cfg.Providers.Get(smallModelCfg.Provider)\n\tif !ok {\n\t\treturn Model{}, Model{}, errors.New(\"small model provider not configured\")\n\t}\n\n\tsmallProvider, err := c.buildProvider(smallProviderCfg, smallModelCfg)\n\tif err != nil {\n\t\treturn Model{}, Model{}, err\n\t}\n\n\tvar largeCatwalkModel *catwalk.Model\n\tvar smallCatwalkModel *catwalk.Model\n\n\tfor _, m := range largeProviderCfg.Models {\n\t\tif m.ID == largeModelCfg.Model {\n\t\t\tlargeCatwalkModel = &m\n\t\t}\n\t}\n\tfor _, m := range smallProviderCfg.Models {\n\t\tif m.ID == smallModelCfg.Model {\n\t\t\tsmallCatwalkModel = &m\n\t\t}\n\t}\n\n\t// Fall back to catwalk known providers if not found in provider config\n\tknownProviders, err := config.Providers(c.cfg)\n\tif err == nil {\n\t\tif largeCatwalkModel == nil {\n\t\t\tfor _, p := range knownProviders {\n\t\t\t\tif string(p.ID) == largeModelCfg.Provider {\n\t\t\t\t\tfor i, m := range p.Models {\n\t\t\t\t\t\tif m.ID == largeModelCfg.Model {\n\t\t\t\t\t\t\tlargeCatwalkModel = &p.Models[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif smallCatwalkModel == nil {\n\t\t\tfor _, p := range knownProviders {\n\t\t\t\tif string(p.ID) == smallModelCfg.Provider {\n\t\t\t\t\tfor i, m := range p.Models {\n\t\t\t\t\t\tif m.ID == smallModelCfg.Model {\n\t\t\t\t\t\t\tsmallCatwalkModel = &p.Models[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif largeCatwalkModel == nil {\n\t\treturn Model{}, Model{}, fmt.Errorf(\"large model %s not found for provider %s\", largeModelCfg.Model, largeModelCfg.Provider)\n\t}\n\n\tif smallCatwalkModel == nil {\n\t\treturn Model{}, Model{}, fmt.Errorf(\"small model %s not found for provider %s\", smallModelCfg.Model, smallModelCfg.Provider)\n\t}\n\n\t// Log detected models with their context windows\n\tslog.Info(\"Models successfully initialized\",\n\t\t\"large_model\", map[string]any{\n\t\t\t\"id\":             largeModelCfg.Model,\n\t\t\t\"provider\":       largeModelCfg.Provider,\n\t\t\t\"context_window\": largeCatwalkModel.ContextWindow,\n\t\t},\n\t\t\"small_model\", map[string]any{\n\t\t\t\"id\":             smallModelCfg.Model,\n\t\t\t\"provider\":       smallModelCfg.Provider,\n\t\t\t\"context_window\": smallCatwalkModel.ContextWindow,\n\t\t})\n\n\tlargeModelID := largeModelCfg.Model\n\tsmallModelID := smallModelCfg.Model\n\n\tif largeModelCfg.Provider == openrouter.Name && isExactoSupported(largeModelID) {\n\t\tlargeModelID += \":exacto\"\n\t}\n\n\tif smallModelCfg.Provider == openrouter.Name && isExactoSupported(smallModelID) {\n\t\tsmallModelID += \":exacto\"\n\t}\n\n\t// Legacy GPT-OSS-120B mappings removed - DeepSeek Coder 2 is default\n\t// Special handling for Cerebras no longer needed\n\n\tlargeModel, err := largeProvider.LanguageModel(ctx, largeModelID)\n\tif err != nil {\n\t\treturn Model{}, Model{}, err\n\t}\n\tsmallModel, err := smallProvider.LanguageModel(ctx, smallModelID)\n\tif err != nil {\n\t\treturn Model{}, Model{}, err\n\t}\n\n\treturn Model{\n\t\t\tModel:      largeModel,\n\t\t\tCatwalkCfg: *largeCatwalkModel,\n\t\t\tModelCfg:   largeModelCfg,\n\t\t}, Model{\n\t\t\tModel:      smallModel,\n\t\t\tCatwalkCfg: *smallCatwalkModel,\n\t\t\tModelCfg:   smallModelCfg,\n\t\t}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildAnthropicProvider_895": {
      "name": "buildAnthropicProvider",
      "type": "method",
      "start_line": 895,
      "end_line": 931,
      "content_hash": "2f05b0fa2fe14b949cc169bb2c14f73c70bbafce",
      "content": "func (c *coordinator) buildAnthropicProvider(baseURL, apiKey string, headers map[string]string) (fantasy.Provider, error) {\n\tvar opts []anthropic.Option\n\n\t// MiniMax uses JWT tokens\n\tif strings.HasPrefix(apiKey, \"Bearer \") {\n\t\t// NOTE: Prevent the SDK from picking up the API key from env.\n\t\tos.Setenv(\"ANTHROPIC_API_KEY\", \"\")\n\n\t\theaders[\"Authorization\"] = apiKey\n\t} else if strings.HasPrefix(apiKey, \"eyJ\") { // JWT token (MiniMax)\n\t\t// NOTE: Prevent the SDK from picking up the API key from env.\n\t\tos.Setenv(\"ANTHROPIC_API_KEY\", \"\")\n\n\t\t// Use the JWT as the API key and set Authorization\n\t\topts = append(opts, anthropic.WithAPIKey(apiKey))\n\t\theaders[\"Authorization\"] = \"Bearer \" + apiKey\n\t} else if apiKey != \"\" {\n\t\t// X-Api-Key header\n\t\topts = append(opts, anthropic.WithAPIKey(apiKey))\n\t}\n\n\tif len(headers) > 0 {\n\t\topts = append(opts, anthropic.WithHeaders(headers))\n\t}\n\n\tif baseURL != \"\" {\n\t\topts = append(opts, anthropic.WithBaseURL(baseURL))\n\t}\n\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, anthropic.WithHTTPClient(httpClient))\n\t}\n\n\treturn anthropic.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildOpenaiProvider_932": {
      "name": "buildOpenaiProvider",
      "type": "method",
      "start_line": 932,
      "end_line": 949,
      "content_hash": "94edaabec67a92008a65537f5b1cf383ef9984e9",
      "content": "func (c *coordinator) buildOpenaiProvider(baseURL, apiKey string, headers map[string]string) (fantasy.Provider, error) {\n\topts := []openai.Option{\n\t\topenai.WithAPIKey(apiKey),\n\t\topenai.WithUseResponsesAPI(),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, openai.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, openai.WithHeaders(headers))\n\t}\n\tif baseURL != \"\" {\n\t\topts = append(opts, openai.WithBaseURL(baseURL))\n\t}\n\treturn openai.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildOpenrouterProvider_950": {
      "name": "buildOpenrouterProvider",
      "type": "method",
      "start_line": 950,
      "end_line": 963,
      "content_hash": "43dd5ca123183299bf0371c274c25ace982392b5",
      "content": "func (c *coordinator) buildOpenrouterProvider(_, apiKey string, headers map[string]string) (fantasy.Provider, error) {\n\topts := []openrouter.Option{\n\t\topenrouter.WithAPIKey(apiKey),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, openrouter.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, openrouter.WithHeaders(headers))\n\t}\n\treturn openrouter.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildMinimaxProvider_964": {
      "name": "buildMinimaxProvider",
      "type": "method",
      "start_line": 964,
      "end_line": 977,
      "content_hash": "a11698d35a7216d56b57ed1f58323b624b33195b",
      "content": "func (c *coordinator) buildMinimaxProvider(baseURL, apiKey string) (fantasy.Provider, error) {\n\t// Custom MiniMax provider using anthropic SDK with JWT as API key\n\topts := []anthropic.Option{\n\t\tanthropic.WithAPIKey(apiKey),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, anthropic.WithHTTPClient(httpClient))\n\t}\n\topts = append(opts, anthropic.WithBaseURL(baseURL))\n\n\treturn anthropic.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildOpenaiCompatProvider_978": {
      "name": "buildOpenaiCompatProvider",
      "type": "method",
      "start_line": 978,
      "end_line": 997,
      "content_hash": "4f145a3bf9011193164b27a592d26fbb5ff207a3",
      "content": "func (c *coordinator) buildOpenaiCompatProvider(baseURL, apiKey string, headers map[string]string, extraBody map[string]any) (fantasy.Provider, error) {\n\topts := []openaicompat.Option{\n\t\topenaicompat.WithBaseURL(baseURL),\n\t\topenaicompat.WithAPIKey(apiKey),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, openaicompat.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, openaicompat.WithHeaders(headers))\n\t}\n\n\tfor extraKey, extraValue := range extraBody {\n\t\topts = append(opts, openaicompat.WithSDKOptions(openaisdk.WithJSONSet(extraKey, extraValue)))\n\t}\n\n\treturn openaicompat.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildAzureProvider_998": {
      "name": "buildAzureProvider",
      "type": "method",
      "start_line": 998,
      "end_line": 1020,
      "content_hash": "8a5c763449682f8f6e122181a273c6d0e71e42f0",
      "content": "func (c *coordinator) buildAzureProvider(baseURL, apiKey string, headers map[string]string, options map[string]string) (fantasy.Provider, error) {\n\topts := []azure.Option{\n\t\tazure.WithBaseURL(baseURL),\n\t\tazure.WithAPIKey(apiKey),\n\t\tazure.WithUseResponsesAPI(),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, azure.WithHTTPClient(httpClient))\n\t}\n\tif options == nil {\n\t\toptions = make(map[string]string)\n\t}\n\tif apiVersion, ok := options[\"apiVersion\"]; ok {\n\t\topts = append(opts, azure.WithAPIVersion(apiVersion))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, azure.WithHeaders(headers))\n\t}\n\n\treturn azure.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildBedrockProvider_1021": {
      "name": "buildBedrockProvider",
      "type": "method",
      "start_line": 1021,
      "end_line": 1036,
      "content_hash": "d4af621c01978c8deab98320ab69b363751b1909",
      "content": "func (c *coordinator) buildBedrockProvider(headers map[string]string) (fantasy.Provider, error) {\n\tvar opts []bedrock.Option\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, bedrock.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, bedrock.WithHeaders(headers))\n\t}\n\tbearerToken := os.Getenv(\"AWS_BEARER_TOKEN_BEDROCK\")\n\tif bearerToken != \"\" {\n\t\topts = append(opts, bedrock.WithAPIKey(bearerToken))\n\t}\n\treturn bedrock.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildGoogleProvider_1037": {
      "name": "buildGoogleProvider",
      "type": "method",
      "start_line": 1037,
      "end_line": 1051,
      "content_hash": "69226b74a839afdb62aa1de090cc455299ed97ed",
      "content": "func (c *coordinator) buildGoogleProvider(baseURL, apiKey string, headers map[string]string) (fantasy.Provider, error) {\n\topts := []google.Option{\n\t\tgoogle.WithBaseURL(baseURL),\n\t\tgoogle.WithGeminiAPIKey(apiKey),\n\t}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, google.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, google.WithHeaders(headers))\n\t}\n\treturn google.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildGoogleVertexProvider_1052": {
      "name": "buildGoogleVertexProvider",
      "type": "method",
      "start_line": 1052,
      "end_line": 1069,
      "content_hash": "6a06035d50ec874a0d8d3be80a55eda0bfd27bd2",
      "content": "func (c *coordinator) buildGoogleVertexProvider(headers map[string]string, options map[string]string) (fantasy.Provider, error) {\n\topts := []google.Option{}\n\tif c.cfg.Options.Debug {\n\t\thttpClient := log.NewHTTPClient()\n\t\topts = append(opts, google.WithHTTPClient(httpClient))\n\t}\n\tif len(headers) > 0 {\n\t\topts = append(opts, google.WithHeaders(headers))\n\t}\n\n\tproject := options[\"project\"]\n\tlocation := options[\"location\"]\n\n\topts = append(opts, google.WithVertex(project, location))\n\n\treturn google.New(opts...)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isAnthropicThinking_1070": {
      "name": "isAnthropicThinking",
      "type": "method",
      "start_line": 1070,
      "end_line": 1088,
      "content_hash": "6bd8f2608973e8215630911d2b5c32f021df1fa8",
      "content": "func (c *coordinator) isAnthropicThinking(model config.SelectedModel) bool {\n\tif model.Think {\n\t\treturn true\n\t}\n\n\tif model.ProviderOptions == nil {\n\t\treturn false\n\t}\n\n\topts, err := anthropic.ParseOptions(model.ProviderOptions)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif opts.Thinking != nil {\n\t\treturn true\n\t}\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildProvider_1089": {
      "name": "buildProvider",
      "type": "method",
      "start_line": 1089,
      "end_line": 1137,
      "content_hash": "a2c40459dfd726737ca22f2f54e84cf588ff3b7b",
      "content": "func (c *coordinator) buildProvider(providerCfg config.ProviderConfig, model config.SelectedModel) (fantasy.Provider, error) {\n\theaders := maps.Clone(providerCfg.ExtraHeaders)\n\tif headers == nil {\n\t\theaders = make(map[string]string)\n\t}\n\n\t// handle special headers for anthropic\n\tif providerCfg.Type == anthropic.Name && c.isAnthropicThinking(model) {\n\t\tif v, ok := headers[\"anthropic-beta\"]; ok {\n\t\t\theaders[\"anthropic-beta\"] = v + \",interleaved-thinking-2025-05-14\"\n\t\t} else {\n\t\t\theaders[\"anthropic-beta\"] = \"interleaved-thinking-2025-05-14\"\n\t\t}\n\t}\n\n\tapiKey, _ := c.cfg.Resolve(providerCfg.APIKey)\n\tbaseURL, _ := c.cfg.Resolve(providerCfg.BaseURL)\n\n\tswitch providerCfg.Type {\n\tcase openai.Name:\n\t\treturn c.buildOpenaiProvider(baseURL, apiKey, headers)\n\tcase anthropic.Name:\n\t\tif providerCfg.ID == \"minimax\" {\n\t\t\treturn c.buildMinimaxProvider(baseURL, apiKey)\n\t\t}\n\t\treturn c.buildAnthropicProvider(baseURL, apiKey, headers)\n\tcase openrouter.Name:\n\t\treturn c.buildOpenrouterProvider(baseURL, apiKey, headers)\n\tcase azure.Name:\n\t\treturn c.buildAzureProvider(baseURL, apiKey, headers, providerCfg.ExtraParams)\n\tcase bedrock.Name:\n\t\treturn c.buildBedrockProvider(headers)\n\tcase google.Name:\n\t\treturn c.buildGoogleProvider(baseURL, apiKey, headers)\n\tcase \"google-vertex\":\n\t\treturn c.buildGoogleVertexProvider(headers, providerCfg.ExtraParams)\n\tcase openaicompat.Name:\n\t\tif providerCfg.ID == string(catwalk.InferenceProviderZAI) {\n\t\t\tif providerCfg.ExtraBody == nil {\n\t\t\t\tproviderCfg.ExtraBody = map[string]any{}\n\t\t\t}\n\t\t\tproviderCfg.ExtraBody[\"tool_stream\"] = true\n\t\t}\n\t\treturn c.buildOpenaiCompatProvider(baseURL, apiKey, headers, providerCfg.ExtraBody)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"provider type not supported: %q\", providerCfg.Type)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isExactoSupported_1138": {
      "name": "isExactoSupported",
      "type": "function",
      "start_line": 1138,
      "end_line": 1149,
      "content_hash": "f311a05fb66f04f24eeba028eda7f4a3acfbdb4e",
      "content": "func isExactoSupported(modelID string) bool {\n\tsupportedModels := []string{\n\t\t\"moonshotai/kimi-k2-0905\",\n\t\t\"deepseek/deepseek-v3.1-terminus\",\n\t\t\"z-ai/glm-4.6\",\n\t\t\"openai/gpt-oss-120b\",\n\t\t\"qwen/qwen3-coder\",\n\t\t\"deepseek-coder-2\", // Cerebras DeepSeek default\n\t}\n\treturn slices.Contains(supportedModels, modelID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Cancel_1150": {
      "name": "Cancel",
      "type": "method",
      "start_line": 1150,
      "end_line": 1153,
      "content_hash": "18ace6646973d91e4b9bbe87b6634051d097a400",
      "content": "func (c *coordinator) Cancel(sessionID string) {\n\tc.currentAgent.Cancel(sessionID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CancelAll_1154": {
      "name": "CancelAll",
      "type": "method",
      "start_line": 1154,
      "end_line": 1157,
      "content_hash": "43df1768a31584322a41953881bb731d87e78117",
      "content": "func (c *coordinator) CancelAll() {\n\tc.currentAgent.CancelAll()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ClearQueue_1158": {
      "name": "ClearQueue",
      "type": "method",
      "start_line": 1158,
      "end_line": 1161,
      "content_hash": "1a1368547531e9327beb76885fc6d033a0aa341d",
      "content": "func (c *coordinator) ClearQueue(sessionID string) {\n\tc.currentAgent.ClearQueue(sessionID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsBusy_1162": {
      "name": "IsBusy",
      "type": "method",
      "start_line": 1162,
      "end_line": 1165,
      "content_hash": "497bc79d6a82c8a6190ace444da81ea87cecb59a",
      "content": "func (c *coordinator) IsBusy() bool {\n\treturn c.currentAgent.IsBusy()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsSessionBusy_1166": {
      "name": "IsSessionBusy",
      "type": "method",
      "start_line": 1166,
      "end_line": 1169,
      "content_hash": "1514fcabb5803f46119452a777eef1581049f4ea",
      "content": "func (c *coordinator) IsSessionBusy(sessionID string) bool {\n\treturn c.currentAgent.IsSessionBusy(sessionID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Model_1170": {
      "name": "Model",
      "type": "method",
      "start_line": 1170,
      "end_line": 1173,
      "content_hash": "8f4a8fdb7b041c67f0f68e9d7f42f9573c3ed01a",
      "content": "func (c *coordinator) Model() Model {\n\treturn c.currentAgent.Model()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_UpdateModels_1174": {
      "name": "UpdateModels",
      "type": "method",
      "start_line": 1174,
      "end_line": 1194,
      "content_hash": "be637f54702aa7cce7e16fcc3b85d901c57f8e37",
      "content": "func (c *coordinator) UpdateModels(ctx context.Context) error {\n\t// build the models again so we make sure we get the latest config\n\tlarge, small, err := c.buildAgentModels(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.currentAgent.SetModels(large, small)\n\n\tagentCfg, ok := c.cfg.Agents[config.AgentCoder]\n\tif !ok {\n\t\treturn errors.New(\"coder agent not configured\")\n\t}\n\n\ttools, err := c.buildTools(ctx, agentCfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.currentAgent.SetTools(tools)\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_QueuedPrompts_1195": {
      "name": "QueuedPrompts",
      "type": "method",
      "start_line": 1195,
      "end_line": 1198,
      "content_hash": "e54690c14e67417fd364ef09a65e0e9707bdc1be",
      "content": "func (c *coordinator) QueuedPrompts(sessionID string) int {\n\treturn c.currentAgent.QueuedPrompts(sessionID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Summarize_1199": {
      "name": "Summarize",
      "type": "method",
      "start_line": 1199,
      "end_line": 1205,
      "content_hash": "7b7fbd1f7cc2b01d601758f30fad2613a0b0f140",
      "content": "func (c *coordinator) Summarize(ctx context.Context, sessionID string) error {\n\tproviderCfg, ok := c.cfg.Providers.Get(c.currentAgent.Model().ModelCfg.Provider)\n\tif !ok {\n\t\treturn errors.New(\"model provider not configured\")\n\t}\n\treturn c.currentAgent.Summarize(ctx, sessionID, getProviderOptions(c.currentAgent.Model(), providerCfg))\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}