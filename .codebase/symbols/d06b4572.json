{
  "file_path": "/work/context-engine/tests/test_language_coverage.py",
  "file_hash": "9c473f0b4480397f6e18da702d6328eb919346b5",
  "updated_at": "2025-12-26T17:34:24.471632",
  "symbols": {
    "class_TestImportExtraction_22": {
      "name": "TestImportExtraction",
      "type": "class",
      "start_line": 22,
      "end_line": 230,
      "content_hash": "1f9fa630e406e5b4bf241b52f8d19a40bca08d0a",
      "content": "class TestImportExtraction:\n    \"\"\"Test import extraction for all supported languages.\"\"\"\n    \n    @pytest.fixture\n    def extract_imports(self):\n        \"\"\"Return the import extraction function.\"\"\"\n        from scripts.ingest.metadata import _extract_imports\n        return _extract_imports\n    \n    def test_python_imports(self, extract_imports):\n        \"\"\"Test Python import extraction.\"\"\"\n        code = '''\nimport os\nimport sys\nfrom pathlib import Path\nfrom collections.abc import Mapping\nimport numpy as np\nfrom . import local_module\n'''\n        imports = extract_imports(\"python\", code)\n        assert \"os\" in imports\n        assert \"sys\" in imports\n        assert \"pathlib\" in imports\n        assert \"collections.abc\" in imports\n        assert \"numpy\" in imports\n        assert \".\" in imports\n    \n    def test_javascript_imports(self, extract_imports):\n        \"\"\"Test JavaScript import extraction.\"\"\"\n        code = '''\nimport React from 'react';\nimport { useState, useEffect } from 'react';\nimport * as lodash from 'lodash';\nconst fs = require('fs');\nrequire('dotenv').config();\n'''\n        imports = extract_imports(\"javascript\", code)\n        assert \"react\" in imports\n        assert \"lodash\" in imports\n        assert \"fs\" in imports\n        assert \"dotenv\" in imports\n    \n    def test_typescript_imports(self, extract_imports):\n        \"\"\"Test TypeScript import extraction.\"\"\"\n        code = '''\nimport { Component } from '@angular/core';\nimport type { User } from './types';\nimport axios from 'axios';\n'''\n        imports = extract_imports(\"typescript\", code)\n        assert \"@angular/core\" in imports\n        assert \"./types\" in imports\n        assert \"axios\" in imports\n    \n    def test_go_imports(self, extract_imports):\n        \"\"\"Test Go import extraction.\"\"\"\n        code = '''\npackage main\n\nimport \"fmt\"\nimport (\n    \"os\"\n    \"strings\"\n    \"github.com/gin-gonic/gin\"\n)\n'''\n        imports = extract_imports(\"go\", code)\n        assert \"fmt\" in imports\n        assert \"os\" in imports\n        assert \"strings\" in imports\n        assert \"github.com/gin-gonic/gin\" in imports\n    \n    def test_rust_imports(self, extract_imports):\n        \"\"\"Test Rust import extraction.\"\"\"\n        code = '''\nuse std::collections::HashMap;\nuse tokio::sync::Mutex;\nuse crate::utils::helper;\nuse super::parent_module;\n'''\n        imports = extract_imports(\"rust\", code)\n        assert \"std::collections::HashMap\" in imports\n        assert \"tokio::sync::Mutex\" in imports\n        assert \"crate::utils::helper\" in imports\n        assert \"super::parent_module\" in imports\n    \n    def test_java_imports(self, extract_imports):\n        \"\"\"Test Java import extraction.\"\"\"\n        code = '''\npackage com.example;\n\nimport java.util.*;\nimport java.io.IOException;\nimport com.google.common.collect.ImmutableList;\n'''\n        imports = extract_imports(\"java\", code)\n        assert \"java.util.*\" in imports\n        assert \"java.io.IOException\" in imports\n        assert \"com.google.common.collect.ImmutableList\" in imports\n    \n    def test_c_includes(self, extract_imports):\n        \"\"\"Test C #include extraction.\"\"\"\n        code = '''\n#include <stdio.h>\n#include <stdlib.h>\n#include \"myheader.h\"\n#include \"../utils/helper.h\"\n'''\n        imports = extract_imports(\"c\", code)\n        assert \"stdio.h\" in imports\n        assert \"stdlib.h\" in imports\n        assert \"myheader.h\" in imports\n        assert \"../utils/helper.h\" in imports\n    \n    def test_cpp_includes(self, extract_imports):\n        \"\"\"Test C++ #include extraction.\"\"\"\n        code = '''\n#include <iostream>\n#include <vector>\n#include <memory>\n#include \"config.hpp\"\n'''\n        imports = extract_imports(\"cpp\", code)\n        assert \"iostream\" in imports\n        assert \"vector\" in imports\n        assert \"memory\" in imports\n        assert \"config.hpp\" in imports\n    \n    def test_ruby_requires(self, extract_imports):\n        \"\"\"Test Ruby require extraction.\"\"\"\n        code = '''\nrequire 'json'\nrequire 'net/http'\nrequire_relative 'lib/helper'\nload 'config.rb'\n'''\n        imports = extract_imports(\"ruby\", code)\n        assert \"json\" in imports\n        assert \"net/http\" in imports\n        assert \"lib/helper\" in imports\n        assert \"config.rb\" in imports\n    \n    def test_kotlin_imports(self, extract_imports):\n        \"\"\"Test Kotlin import extraction.\"\"\"\n        code = '''\npackage com.example\n\nimport kotlin.collections.List\nimport kotlinx.coroutines.*\nimport com.google.gson.Gson\n'''\n        imports = extract_imports(\"kotlin\", code)\n        assert \"kotlin.collections.List\" in imports\n        assert \"kotlinx.coroutines.*\" in imports\n        assert \"com.google.gson.Gson\" in imports\n    \n    def test_swift_imports(self, extract_imports):\n        \"\"\"Test Swift import extraction.\"\"\"\n        code = '''\nimport Foundation\nimport UIKit\nimport SwiftUI\n'''\n        imports = extract_imports(\"swift\", code)\n        assert \"Foundation\" in imports\n        assert \"UIKit\" in imports\n        assert \"SwiftUI\" in imports\n    \n    def test_scala_imports(self, extract_imports):\n        \"\"\"Test Scala import extraction.\"\"\"\n        code = '''\nimport scala.collection.mutable\nimport akka.actor.{Actor, Props}\nimport java.util._\n'''\n        imports = extract_imports(\"scala\", code)\n        assert \"scala.collection.mutable\" in imports\n        assert any(\"akka.actor\" in imp for imp in imports)\n        assert \"java.util._\" in imports\n    \n    def test_csharp_usings(self, extract_imports):\n        \"\"\"Test C# using extraction.\"\"\"\n        code = '''\nusing System;\nusing System.Collections.Generic;\nusing static System.Math;\nusing Alias = System.Text;\n'''\n        imports = extract_imports(\"csharp\", code)\n        assert \"System\" in imports\n        assert \"System.Collections.Generic\" in imports\n        assert \"System.Math\" in imports\n        # Alias form\n        assert \"System.Text\" in imports\n    \n    def test_php_usings(self, extract_imports):\n        \"\"\"Test PHP use/require extraction.\"\"\"\n        code = '''\n<?php\nuse App\\\\Models\\\\User;\nuse Illuminate\\\\Http\\\\Request;\nrequire 'vendor/autoload.php';\ninclude_once 'config.php';\n'''\n        imports = extract_imports(\"php\", code)\n        assert any(\"App\" in imp and \"Models\" in imp for imp in imports)\n        assert any(\"Illuminate\" in imp for imp in imports)\n        assert \"vendor/autoload.php\" in imports\n        assert \"config.php\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_imports_26": {
      "name": "extract_imports",
      "type": "method",
      "start_line": 26,
      "end_line": 29,
      "content_hash": "951cc75c36baac53930a8062ec7d599c2b70119d",
      "content": "    def extract_imports(self):\n        \"\"\"Return the import extraction function.\"\"\"\n        from scripts.ingest.metadata import _extract_imports\n        return _extract_imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_python_imports_31": {
      "name": "test_python_imports",
      "type": "method",
      "start_line": 31,
      "end_line": 47,
      "content_hash": "c88ff56abbc5bf3ed453cc66ebedd3856ba2c566",
      "content": "    def test_python_imports(self, extract_imports):\n        \"\"\"Test Python import extraction.\"\"\"\n        code = '''\nimport os\nimport sys\nfrom pathlib import Path\nfrom collections.abc import Mapping\nimport numpy as np\nfrom . import local_module\n'''\n        imports = extract_imports(\"python\", code)\n        assert \"os\" in imports\n        assert \"sys\" in imports\n        assert \"pathlib\" in imports\n        assert \"collections.abc\" in imports\n        assert \"numpy\" in imports\n        assert \".\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_javascript_imports_49": {
      "name": "test_javascript_imports",
      "type": "method",
      "start_line": 49,
      "end_line": 62,
      "content_hash": "fd3d34d3058741927153395b4e790fd598ae50f6",
      "content": "    def test_javascript_imports(self, extract_imports):\n        \"\"\"Test JavaScript import extraction.\"\"\"\n        code = '''\nimport React from 'react';\nimport { useState, useEffect } from 'react';\nimport * as lodash from 'lodash';\nconst fs = require('fs');\nrequire('dotenv').config();\n'''\n        imports = extract_imports(\"javascript\", code)\n        assert \"react\" in imports\n        assert \"lodash\" in imports\n        assert \"fs\" in imports\n        assert \"dotenv\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_typescript_imports_64": {
      "name": "test_typescript_imports",
      "type": "method",
      "start_line": 64,
      "end_line": 74,
      "content_hash": "19ecfa384e20712f1f5ecd718619c6ad9ff68dd2",
      "content": "    def test_typescript_imports(self, extract_imports):\n        \"\"\"Test TypeScript import extraction.\"\"\"\n        code = '''\nimport { Component } from '@angular/core';\nimport type { User } from './types';\nimport axios from 'axios';\n'''\n        imports = extract_imports(\"typescript\", code)\n        assert \"@angular/core\" in imports\n        assert \"./types\" in imports\n        assert \"axios\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_go_imports_76": {
      "name": "test_go_imports",
      "type": "method",
      "start_line": 76,
      "end_line": 92,
      "content_hash": "d29c88236e9ae014786cdff92a73f1024cb6912d",
      "content": "    def test_go_imports(self, extract_imports):\n        \"\"\"Test Go import extraction.\"\"\"\n        code = '''\npackage main\n\nimport \"fmt\"\nimport (\n    \"os\"\n    \"strings\"\n    \"github.com/gin-gonic/gin\"\n)\n'''\n        imports = extract_imports(\"go\", code)\n        assert \"fmt\" in imports\n        assert \"os\" in imports\n        assert \"strings\" in imports\n        assert \"github.com/gin-gonic/gin\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rust_imports_94": {
      "name": "test_rust_imports",
      "type": "method",
      "start_line": 94,
      "end_line": 106,
      "content_hash": "8ea1108b237ad7263cce69c58b079acdd1ec0fcf",
      "content": "    def test_rust_imports(self, extract_imports):\n        \"\"\"Test Rust import extraction.\"\"\"\n        code = '''\nuse std::collections::HashMap;\nuse tokio::sync::Mutex;\nuse crate::utils::helper;\nuse super::parent_module;\n'''\n        imports = extract_imports(\"rust\", code)\n        assert \"std::collections::HashMap\" in imports\n        assert \"tokio::sync::Mutex\" in imports\n        assert \"crate::utils::helper\" in imports\n        assert \"super::parent_module\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_java_imports_108": {
      "name": "test_java_imports",
      "type": "method",
      "start_line": 108,
      "end_line": 120,
      "content_hash": "a6bdad98125042d19b55358107e765636a5c0d3e",
      "content": "    def test_java_imports(self, extract_imports):\n        \"\"\"Test Java import extraction.\"\"\"\n        code = '''\npackage com.example;\n\nimport java.util.*;\nimport java.io.IOException;\nimport com.google.common.collect.ImmutableList;\n'''\n        imports = extract_imports(\"java\", code)\n        assert \"java.util.*\" in imports\n        assert \"java.io.IOException\" in imports\n        assert \"com.google.common.collect.ImmutableList\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_c_includes_122": {
      "name": "test_c_includes",
      "type": "method",
      "start_line": 122,
      "end_line": 134,
      "content_hash": "ab5fd03b7e947463d09b1505859e59b1cd45338c",
      "content": "    def test_c_includes(self, extract_imports):\n        \"\"\"Test C #include extraction.\"\"\"\n        code = '''\n#include <stdio.h>\n#include <stdlib.h>\n#include \"myheader.h\"\n#include \"../utils/helper.h\"\n'''\n        imports = extract_imports(\"c\", code)\n        assert \"stdio.h\" in imports\n        assert \"stdlib.h\" in imports\n        assert \"myheader.h\" in imports\n        assert \"../utils/helper.h\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cpp_includes_136": {
      "name": "test_cpp_includes",
      "type": "method",
      "start_line": 136,
      "end_line": 148,
      "content_hash": "ea4a21134e84a151b407e6da9a1e3662df8923c8",
      "content": "    def test_cpp_includes(self, extract_imports):\n        \"\"\"Test C++ #include extraction.\"\"\"\n        code = '''\n#include <iostream>\n#include <vector>\n#include <memory>\n#include \"config.hpp\"\n'''\n        imports = extract_imports(\"cpp\", code)\n        assert \"iostream\" in imports\n        assert \"vector\" in imports\n        assert \"memory\" in imports\n        assert \"config.hpp\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_ruby_requires_150": {
      "name": "test_ruby_requires",
      "type": "method",
      "start_line": 150,
      "end_line": 162,
      "content_hash": "d94bf6ef055d3b6fe4e35d0af9bc96f673c8ef1a",
      "content": "    def test_ruby_requires(self, extract_imports):\n        \"\"\"Test Ruby require extraction.\"\"\"\n        code = '''\nrequire 'json'\nrequire 'net/http'\nrequire_relative 'lib/helper'\nload 'config.rb'\n'''\n        imports = extract_imports(\"ruby\", code)\n        assert \"json\" in imports\n        assert \"net/http\" in imports\n        assert \"lib/helper\" in imports\n        assert \"config.rb\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_kotlin_imports_164": {
      "name": "test_kotlin_imports",
      "type": "method",
      "start_line": 164,
      "end_line": 176,
      "content_hash": "876632245dd7581920cc49624b45b15563532b21",
      "content": "    def test_kotlin_imports(self, extract_imports):\n        \"\"\"Test Kotlin import extraction.\"\"\"\n        code = '''\npackage com.example\n\nimport kotlin.collections.List\nimport kotlinx.coroutines.*\nimport com.google.gson.Gson\n'''\n        imports = extract_imports(\"kotlin\", code)\n        assert \"kotlin.collections.List\" in imports\n        assert \"kotlinx.coroutines.*\" in imports\n        assert \"com.google.gson.Gson\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_swift_imports_178": {
      "name": "test_swift_imports",
      "type": "method",
      "start_line": 178,
      "end_line": 188,
      "content_hash": "0a5e338178b6ab96061772647b5448ced86eed92",
      "content": "    def test_swift_imports(self, extract_imports):\n        \"\"\"Test Swift import extraction.\"\"\"\n        code = '''\nimport Foundation\nimport UIKit\nimport SwiftUI\n'''\n        imports = extract_imports(\"swift\", code)\n        assert \"Foundation\" in imports\n        assert \"UIKit\" in imports\n        assert \"SwiftUI\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_scala_imports_190": {
      "name": "test_scala_imports",
      "type": "method",
      "start_line": 190,
      "end_line": 200,
      "content_hash": "80f83a6924a7336b633c4f634eb1d341a0ea9c23",
      "content": "    def test_scala_imports(self, extract_imports):\n        \"\"\"Test Scala import extraction.\"\"\"\n        code = '''\nimport scala.collection.mutable\nimport akka.actor.{Actor, Props}\nimport java.util._\n'''\n        imports = extract_imports(\"scala\", code)\n        assert \"scala.collection.mutable\" in imports\n        assert any(\"akka.actor\" in imp for imp in imports)\n        assert \"java.util._\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_csharp_usings_202": {
      "name": "test_csharp_usings",
      "type": "method",
      "start_line": 202,
      "end_line": 215,
      "content_hash": "ae29898eaed9afdcb6bea0f9f56af210ca9d2b0c",
      "content": "    def test_csharp_usings(self, extract_imports):\n        \"\"\"Test C# using extraction.\"\"\"\n        code = '''\nusing System;\nusing System.Collections.Generic;\nusing static System.Math;\nusing Alias = System.Text;\n'''\n        imports = extract_imports(\"csharp\", code)\n        assert \"System\" in imports\n        assert \"System.Collections.Generic\" in imports\n        assert \"System.Math\" in imports\n        # Alias form\n        assert \"System.Text\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_php_usings_217": {
      "name": "test_php_usings",
      "type": "method",
      "start_line": 217,
      "end_line": 230,
      "content_hash": "6144fec8808e1d0fb6c6e4ddbf762b294a5f56fa",
      "content": "    def test_php_usings(self, extract_imports):\n        \"\"\"Test PHP use/require extraction.\"\"\"\n        code = '''\n<?php\nuse App\\\\Models\\\\User;\nuse Illuminate\\\\Http\\\\Request;\nrequire 'vendor/autoload.php';\ninclude_once 'config.php';\n'''\n        imports = extract_imports(\"php\", code)\n        assert any(\"App\" in imp and \"Models\" in imp for imp in imports)\n        assert any(\"Illuminate\" in imp for imp in imports)\n        assert \"vendor/autoload.php\" in imports\n        assert \"config.php\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestCallExtraction_237": {
      "name": "TestCallExtraction",
      "type": "class",
      "start_line": 237,
      "end_line": 311,
      "content_hash": "67d37736898e14a637dc0b63ffa60b8d9fcfb6e3",
      "content": "class TestCallExtraction:\n    \"\"\"Test call extraction for all supported languages.\"\"\"\n    \n    @pytest.fixture\n    def extract_calls(self):\n        \"\"\"Return the call extraction function.\"\"\"\n        from scripts.ingest.metadata import _extract_calls\n        return _extract_calls\n    \n    @pytest.fixture\n    def get_imports_calls(self):\n        \"\"\"Return the combined imports/calls function.\"\"\"\n        from scripts.ingest.metadata import _get_imports_calls\n        return _get_imports_calls\n    \n    def test_python_calls_regex(self, extract_calls):\n        \"\"\"Test Python call extraction with regex fallback.\"\"\"\n        code = '''\ndef main():\n    print(\"hello\")\n    result = calculate(x, y)\n    obj.method()\n    helper_func(arg1, arg2)\n'''\n        calls = extract_calls(\"python\", code)\n        assert \"print\" in calls\n        assert \"calculate\" in calls\n        assert \"method\" in calls\n        assert \"helper_func\" in calls\n        # Keywords should be excluded\n        assert \"def\" not in calls\n    \n    def test_javascript_calls_regex(self, extract_calls):\n        \"\"\"Test JavaScript call extraction with regex fallback.\"\"\"\n        code = '''\nfunction main() {\n    console.log(\"hello\");\n    const data = fetchData(url);\n    arr.map(x => x * 2);\n    if (condition) {\n        process();\n    }\n}\n'''\n        calls = extract_calls(\"javascript\", code)\n        assert \"log\" in calls\n        assert \"fetchData\" in calls\n        assert \"map\" in calls\n        assert \"process\" in calls\n        # Keywords should be excluded\n        assert \"if\" not in calls\n        assert \"function\" not in calls\n    \n    def test_go_calls_regex(self, extract_calls):\n        \"\"\"Test Go call extraction with regex fallback.\"\"\"\n        code = '''\nfunc main() {\n    fmt.Println(\"hello\")\n    result := calculate(x, y)\n    if err != nil {\n        log.Fatal(err)\n    }\n    for i := 0; i < 10; i++ {\n        process(i)\n    }\n}\n'''\n        calls = extract_calls(\"go\", code)\n        assert \"Println\" in calls\n        assert \"calculate\" in calls\n        assert \"Fatal\" in calls\n        assert \"process\" in calls\n        # Keywords should be excluded\n        assert \"func\" not in calls\n        assert \"for\" not in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_calls_241": {
      "name": "extract_calls",
      "type": "method",
      "start_line": 241,
      "end_line": 244,
      "content_hash": "dbd97c60d97e9d4df57ab3d6674aa8d2ff1a3be2",
      "content": "    def extract_calls(self):\n        \"\"\"Return the call extraction function.\"\"\"\n        from scripts.ingest.metadata import _extract_calls\n        return _extract_calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_imports_calls_247": {
      "name": "get_imports_calls",
      "type": "method",
      "start_line": 247,
      "end_line": 250,
      "content_hash": "46ff5a2f826d52923617f6ac4e6359abd5eb9444",
      "content": "    def get_imports_calls(self):\n        \"\"\"Return the combined imports/calls function.\"\"\"\n        from scripts.ingest.metadata import _get_imports_calls\n        return _get_imports_calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_python_calls_regex_252": {
      "name": "test_python_calls_regex",
      "type": "method",
      "start_line": 252,
      "end_line": 267,
      "content_hash": "631f44cb63c39292aaa69a1b85aef4d4f8aa4812",
      "content": "    def test_python_calls_regex(self, extract_calls):\n        \"\"\"Test Python call extraction with regex fallback.\"\"\"\n        code = '''\ndef main():\n    print(\"hello\")\n    result = calculate(x, y)\n    obj.method()\n    helper_func(arg1, arg2)\n'''\n        calls = extract_calls(\"python\", code)\n        assert \"print\" in calls\n        assert \"calculate\" in calls\n        assert \"method\" in calls\n        assert \"helper_func\" in calls\n        # Keywords should be excluded\n        assert \"def\" not in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_javascript_calls_regex_269": {
      "name": "test_javascript_calls_regex",
      "type": "method",
      "start_line": 269,
      "end_line": 288,
      "content_hash": "3dd26fe685a8b36077f47bcb5a91d8addbcd28d5",
      "content": "    def test_javascript_calls_regex(self, extract_calls):\n        \"\"\"Test JavaScript call extraction with regex fallback.\"\"\"\n        code = '''\nfunction main() {\n    console.log(\"hello\");\n    const data = fetchData(url);\n    arr.map(x => x * 2);\n    if (condition) {\n        process();\n    }\n}\n'''\n        calls = extract_calls(\"javascript\", code)\n        assert \"log\" in calls\n        assert \"fetchData\" in calls\n        assert \"map\" in calls\n        assert \"process\" in calls\n        # Keywords should be excluded\n        assert \"if\" not in calls\n        assert \"function\" not in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_go_calls_regex_290": {
      "name": "test_go_calls_regex",
      "type": "method",
      "start_line": 290,
      "end_line": 311,
      "content_hash": "1c9dd9e87c760a90392a273d9fea4cb8e4805918",
      "content": "    def test_go_calls_regex(self, extract_calls):\n        \"\"\"Test Go call extraction with regex fallback.\"\"\"\n        code = '''\nfunc main() {\n    fmt.Println(\"hello\")\n    result := calculate(x, y)\n    if err != nil {\n        log.Fatal(err)\n    }\n    for i := 0; i < 10; i++ {\n        process(i)\n    }\n}\n'''\n        calls = extract_calls(\"go\", code)\n        assert \"Println\" in calls\n        assert \"calculate\" in calls\n        assert \"Fatal\" in calls\n        assert \"process\" in calls\n        # Keywords should be excluded\n        assert \"func\" not in calls\n        assert \"for\" not in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestTreeSitterCallExtraction_318": {
      "name": "TestTreeSitterCallExtraction",
      "type": "class",
      "start_line": 318,
      "end_line": 388,
      "content_hash": "d31559a649b35b2e2f1a70e601d3f8c6475a7b67",
      "content": "class TestTreeSitterCallExtraction:\n    \"\"\"Test tree-sitter based call extraction for supported languages.\"\"\"\n    \n    @pytest.fixture\n    def ts_extract_calls(self):\n        \"\"\"Return the tree-sitter call extraction function.\"\"\"\n        from scripts.ingest.metadata import _ts_extract_calls_generic\n        return _ts_extract_calls_generic\n    \n    @pytest.fixture\n    def ts_languages(self):\n        \"\"\"Return dict of available tree-sitter languages.\"\"\"\n        try:\n            from scripts.ingest.tree_sitter import _TS_LANGUAGES, _TS_AVAILABLE\n            return _TS_LANGUAGES if _TS_AVAILABLE else {}\n        except ImportError:\n            return {}\n    \n    def test_javascript_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test JavaScript call extraction with tree-sitter.\"\"\"\n        if \"javascript\" not in ts_languages:\n            pytest.skip(\"tree-sitter javascript parser not available\")\n        \n        code = '''\nfunction main() {\n    console.log(\"hello\");\n    const data = fetchData(url);\n    arr.map(x => x * 2);\n    process();\n}\n'''\n        calls = ts_extract_calls(\"javascript\", code)\n        # Should find meaningful calls\n        assert len(calls) > 0\n        assert \"process\" in calls or \"log\" in calls or \"fetchData\" in calls or \"map\" in calls\n    \n    def test_go_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test Go call extraction with tree-sitter.\"\"\"\n        if \"go\" not in ts_languages:\n            pytest.skip(\"tree-sitter go parser not available\")\n        \n        code = '''\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n    result := calculate(10, 20)\n    process(result)\n}\n'''\n        calls = ts_extract_calls(\"go\", code)\n        # Should find function calls\n        assert len(calls) >= 0  # May be empty if parser not available\n    \n    def test_rust_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test Rust call extraction with tree-sitter.\"\"\"\n        if \"rust\" not in ts_languages:\n            pytest.skip(\"tree-sitter rust parser not available\")\n        \n        code = '''\nfn main() {\n    println!(\"hello\");\n    let result = calculate(10, 20);\n    process(result);\n}\n'''\n        calls = ts_extract_calls(\"rust\", code)\n        # Should find function calls (including macros)\n        assert len(calls) >= 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ts_extract_calls_322": {
      "name": "ts_extract_calls",
      "type": "method",
      "start_line": 322,
      "end_line": 325,
      "content_hash": "31d95b938ded5ae1f2f914189e345c4fde181d0e",
      "content": "    def ts_extract_calls(self):\n        \"\"\"Return the tree-sitter call extraction function.\"\"\"\n        from scripts.ingest.metadata import _ts_extract_calls_generic\n        return _ts_extract_calls_generic",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ts_languages_328": {
      "name": "ts_languages",
      "type": "method",
      "start_line": 328,
      "end_line": 334,
      "content_hash": "06ce7dda71fc0bc53c54493c5b7b408d00205b67",
      "content": "    def ts_languages(self):\n        \"\"\"Return dict of available tree-sitter languages.\"\"\"\n        try:\n            from scripts.ingest.tree_sitter import _TS_LANGUAGES, _TS_AVAILABLE\n            return _TS_LANGUAGES if _TS_AVAILABLE else {}\n        except ImportError:\n            return {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_javascript_ts_calls_336": {
      "name": "test_javascript_ts_calls",
      "type": "method",
      "start_line": 336,
      "end_line": 352,
      "content_hash": "9124d2a5cd51655be3e4a1d180cc34820851e102",
      "content": "    def test_javascript_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test JavaScript call extraction with tree-sitter.\"\"\"\n        if \"javascript\" not in ts_languages:\n            pytest.skip(\"tree-sitter javascript parser not available\")\n        \n        code = '''\nfunction main() {\n    console.log(\"hello\");\n    const data = fetchData(url);\n    arr.map(x => x * 2);\n    process();\n}\n'''\n        calls = ts_extract_calls(\"javascript\", code)\n        # Should find meaningful calls\n        assert len(calls) > 0\n        assert \"process\" in calls or \"log\" in calls or \"fetchData\" in calls or \"map\" in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_go_ts_calls_354": {
      "name": "test_go_ts_calls",
      "type": "method",
      "start_line": 354,
      "end_line": 372,
      "content_hash": "687106ffc09a6a9a6e37274b973e813369ca7ffe",
      "content": "    def test_go_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test Go call extraction with tree-sitter.\"\"\"\n        if \"go\" not in ts_languages:\n            pytest.skip(\"tree-sitter go parser not available\")\n        \n        code = '''\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n    result := calculate(10, 20)\n    process(result)\n}\n'''\n        calls = ts_extract_calls(\"go\", code)\n        # Should find function calls\n        assert len(calls) >= 0  # May be empty if parser not available",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rust_ts_calls_374": {
      "name": "test_rust_ts_calls",
      "type": "method",
      "start_line": 374,
      "end_line": 388,
      "content_hash": "83dbbae5e25bdc7263204a39b62e9b9395855554",
      "content": "    def test_rust_ts_calls(self, ts_extract_calls, ts_languages):\n        \"\"\"Test Rust call extraction with tree-sitter.\"\"\"\n        if \"rust\" not in ts_languages:\n            pytest.skip(\"tree-sitter rust parser not available\")\n        \n        code = '''\nfn main() {\n    println!(\"hello\");\n    let result = calculate(10, 20);\n    process(result);\n}\n'''\n        calls = ts_extract_calls(\"rust\", code)\n        # Should find function calls (including macros)\n        assert len(calls) >= 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestASTAnalyzer_395": {
      "name": "TestASTAnalyzer",
      "type": "class",
      "start_line": 395,
      "end_line": 627,
      "content_hash": "aa94c0c7ccc577cc2b5456aa2f24118e1902c620",
      "content": "class TestASTAnalyzer:\n    \"\"\"Test the AST analyzer for all supported languages.\"\"\"\n    \n    @pytest.fixture\n    def analyzer(self):\n        \"\"\"Return an AST analyzer instance.\"\"\"\n        from scripts.ast_analyzer import ASTAnalyzer\n        return ASTAnalyzer()\n    \n    def test_python_analysis(self, analyzer):\n        \"\"\"Test Python AST analysis.\"\"\"\n        code = '''\nimport os\nfrom pathlib import Path\n\nclass MyClass:\n    \"\"\"A sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value\n    \n    def process(self):\n        return self.value * 2\n\ndef standalone_func(x, y):\n    result = calculate(x, y)\n    return result\n'''\n        result = analyzer.analyze_file(\"test.py\", \"python\", code)\n        \n        # Check symbols\n        symbols = result.get(\"symbols\", [])\n        symbol_names = [s.name for s in symbols]\n        assert \"MyClass\" in symbol_names\n        assert \"__init__\" in symbol_names or \"process\" in symbol_names\n        assert \"standalone_func\" in symbol_names\n        \n        # Check imports\n        imports = result.get(\"imports\", [])\n        assert len(imports) > 0\n    \n    def test_javascript_analysis(self, analyzer):\n        \"\"\"Test JavaScript AST analysis.\"\"\"\n        code = '''\nimport React from 'react';\n\nclass MyComponent {\n    constructor() {\n        this.state = {};\n    }\n    \n    render() {\n        return null;\n    }\n}\n\nfunction helperFunc() {\n    return 42;\n}\n'''\n        result = analyzer.analyze_file(\"test.js\", \"javascript\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        symbol_names = [s.name for s in symbols]\n        # Should find class and functions\n        assert len(symbol_names) >= 1\n    \n    def test_go_analysis(self, analyzer):\n        \"\"\"Test Go AST analysis.\"\"\"\n        code = '''\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype Server struct {\n    Host string\n    Port int\n}\n\nfunc (s *Server) Start() error {\n    fmt.Println(\"Starting server\")\n    return nil\n}\n\nfunc NewServer(host string, port int) *Server {\n    return &Server{Host: host, Port: port}\n}\n'''\n        result = analyzer.analyze_file(\"test.go\", \"go\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find struct and functions\n            assert \"Server\" in symbol_names or \"NewServer\" in symbol_names or \"Start\" in symbol_names\n    \n    def test_rust_analysis(self, analyzer):\n        \"\"\"Test Rust AST analysis.\"\"\"\n        code = '''\nuse std::collections::HashMap;\n\nstruct Config {\n    host: String,\n    port: u16,\n}\n\nimpl Config {\n    fn new(host: String, port: u16) -> Self {\n        Config { host, port }\n    }\n    \n    fn start(&self) {\n        println!(\"Starting on {}:{}\", self.host, self.port);\n    }\n}\n\nfn main() {\n    let config = Config::new(\"localhost\".into(), 8080);\n    config.start();\n}\n'''\n        result = analyzer.analyze_file(\"test.rs\", \"rust\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find struct and functions\n            assert len(symbol_names) >= 1\n    \n    def test_java_analysis(self, analyzer):\n        \"\"\"Test Java AST analysis.\"\"\"\n        code = '''\npackage com.example;\n\nimport java.util.List;\n\npublic class UserService {\n    private final Database database;\n    \n    public UserService(Database database) {\n        this.database = database;\n    }\n    \n    public User findById(long id) {\n        return database.query(id);\n    }\n    \n    public void save(User user) {\n        database.insert(user);\n    }\n}\n'''\n        result = analyzer.analyze_file(\"UserService.java\", \"java\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class and methods\n            assert \"UserService\" in symbol_names or \"findById\" in symbol_names or \"save\" in symbol_names\n    \n    def test_cpp_analysis(self, analyzer):\n        \"\"\"Test C++ AST analysis.\"\"\"\n        code = '''\n#include <iostream>\n#include <vector>\n\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    int multiply(int a, int b) {\n        return a * b;\n    }\n};\n\nint main() {\n    Calculator calc;\n    std::cout << calc.add(2, 3) << std::endl;\n    return 0;\n}\n'''\n        result = analyzer.analyze_file(\"test.cpp\", \"cpp\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class and functions\n            assert len(symbol_names) >= 1\n        \n        imports = result.get(\"imports\", [])\n        # Check includes\n        if imports:\n            import_modules = [i.module for i in imports]\n            assert \"iostream\" in import_modules or \"vector\" in import_modules\n    \n    def test_ruby_analysis(self, analyzer):\n        \"\"\"Test Ruby AST analysis.\"\"\"\n        code = '''\nrequire 'json'\nrequire_relative 'lib/helper'\n\nclass UserController\n  def initialize(service)\n    @service = service\n  end\n  \n  def index\n    @service.all\n  end\n  \n  def show(id)\n    @service.find(id)\n  end\nend\n\nmodule Helpers\n  def format_date(date)\n    date.strftime(\"%Y-%m-%d\")\n  end\nend\n'''\n        result = analyzer.analyze_file(\"test.rb\", \"ruby\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class, module, and methods\n            assert len(symbol_names) >= 1",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_analyzer_399": {
      "name": "analyzer",
      "type": "method",
      "start_line": 399,
      "end_line": 402,
      "content_hash": "d2abd77b7fb96dd483bc290d16b2bb46012aaf9c",
      "content": "    def analyzer(self):\n        \"\"\"Return an AST analyzer instance.\"\"\"\n        from scripts.ast_analyzer import ASTAnalyzer\n        return ASTAnalyzer()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_python_analysis_404": {
      "name": "test_python_analysis",
      "type": "method",
      "start_line": 404,
      "end_line": 434,
      "content_hash": "93590910ce772ff94b99a1619432f7c5c0923986",
      "content": "    def test_python_analysis(self, analyzer):\n        \"\"\"Test Python AST analysis.\"\"\"\n        code = '''\nimport os\nfrom pathlib import Path\n\nclass MyClass:\n    \"\"\"A sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value\n    \n    def process(self):\n        return self.value * 2\n\ndef standalone_func(x, y):\n    result = calculate(x, y)\n    return result\n'''\n        result = analyzer.analyze_file(\"test.py\", \"python\", code)\n        \n        # Check symbols\n        symbols = result.get(\"symbols\", [])\n        symbol_names = [s.name for s in symbols]\n        assert \"MyClass\" in symbol_names\n        assert \"__init__\" in symbol_names or \"process\" in symbol_names\n        assert \"standalone_func\" in symbol_names\n        \n        # Check imports\n        imports = result.get(\"imports\", [])\n        assert len(imports) > 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_javascript_analysis_436": {
      "name": "test_javascript_analysis",
      "type": "method",
      "start_line": 436,
      "end_line": 460,
      "content_hash": "0c3456ea3b44722c35acee19e6ca7ca700284c16",
      "content": "    def test_javascript_analysis(self, analyzer):\n        \"\"\"Test JavaScript AST analysis.\"\"\"\n        code = '''\nimport React from 'react';\n\nclass MyComponent {\n    constructor() {\n        this.state = {};\n    }\n    \n    render() {\n        return null;\n    }\n}\n\nfunction helperFunc() {\n    return 42;\n}\n'''\n        result = analyzer.analyze_file(\"test.js\", \"javascript\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        symbol_names = [s.name for s in symbols]\n        # Should find class and functions\n        assert len(symbol_names) >= 1",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_go_analysis_462": {
      "name": "test_go_analysis",
      "type": "method",
      "start_line": 462,
      "end_line": 492,
      "content_hash": "647dc0eca43cdd5065348a68309416262c3049d0",
      "content": "    def test_go_analysis(self, analyzer):\n        \"\"\"Test Go AST analysis.\"\"\"\n        code = '''\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype Server struct {\n    Host string\n    Port int\n}\n\nfunc (s *Server) Start() error {\n    fmt.Println(\"Starting server\")\n    return nil\n}\n\nfunc NewServer(host string, port int) *Server {\n    return &Server{Host: host, Port: port}\n}\n'''\n        result = analyzer.analyze_file(\"test.go\", \"go\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find struct and functions\n            assert \"Server\" in symbol_names or \"NewServer\" in symbol_names or \"Start\" in symbol_names",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rust_analysis_494": {
      "name": "test_rust_analysis",
      "type": "method",
      "start_line": 494,
      "end_line": 525,
      "content_hash": "3274f11d267cab51367490041b0d6df9f94df715",
      "content": "    def test_rust_analysis(self, analyzer):\n        \"\"\"Test Rust AST analysis.\"\"\"\n        code = '''\nuse std::collections::HashMap;\n\nstruct Config {\n    host: String,\n    port: u16,\n}\n\nimpl Config {\n    fn new(host: String, port: u16) -> Self {\n        Config { host, port }\n    }\n    \n    fn start(&self) {\n        println!(\"Starting on {}:{}\", self.host, self.port);\n    }\n}\n\nfn main() {\n    let config = Config::new(\"localhost\".into(), 8080);\n    config.start();\n}\n'''\n        result = analyzer.analyze_file(\"test.rs\", \"rust\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find struct and functions\n            assert len(symbol_names) >= 1",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_java_analysis_527": {
      "name": "test_java_analysis",
      "type": "method",
      "start_line": 527,
      "end_line": 556,
      "content_hash": "280d90c3e1f493aabace634f85a679e033f2095b",
      "content": "    def test_java_analysis(self, analyzer):\n        \"\"\"Test Java AST analysis.\"\"\"\n        code = '''\npackage com.example;\n\nimport java.util.List;\n\npublic class UserService {\n    private final Database database;\n    \n    public UserService(Database database) {\n        this.database = database;\n    }\n    \n    public User findById(long id) {\n        return database.query(id);\n    }\n    \n    public void save(User user) {\n        database.insert(user);\n    }\n}\n'''\n        result = analyzer.analyze_file(\"UserService.java\", \"java\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class and methods\n            assert \"UserService\" in symbol_names or \"findById\" in symbol_names or \"save\" in symbol_names",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cpp_analysis_558": {
      "name": "test_cpp_analysis",
      "type": "method",
      "start_line": 558,
      "end_line": 593,
      "content_hash": "d62e0656a59e2b195eed3299ed10343555380f2c",
      "content": "    def test_cpp_analysis(self, analyzer):\n        \"\"\"Test C++ AST analysis.\"\"\"\n        code = '''\n#include <iostream>\n#include <vector>\n\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    int multiply(int a, int b) {\n        return a * b;\n    }\n};\n\nint main() {\n    Calculator calc;\n    std::cout << calc.add(2, 3) << std::endl;\n    return 0;\n}\n'''\n        result = analyzer.analyze_file(\"test.cpp\", \"cpp\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class and functions\n            assert len(symbol_names) >= 1\n        \n        imports = result.get(\"imports\", [])\n        # Check includes\n        if imports:\n            import_modules = [i.module for i in imports]\n            assert \"iostream\" in import_modules or \"vector\" in import_modules",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_ruby_analysis_595": {
      "name": "test_ruby_analysis",
      "type": "method",
      "start_line": 595,
      "end_line": 627,
      "content_hash": "b2f44a68cf2a0921dcca54663c8a366ddc8b4637",
      "content": "    def test_ruby_analysis(self, analyzer):\n        \"\"\"Test Ruby AST analysis.\"\"\"\n        code = '''\nrequire 'json'\nrequire_relative 'lib/helper'\n\nclass UserController\n  def initialize(service)\n    @service = service\n  end\n  \n  def index\n    @service.all\n  end\n  \n  def show(id)\n    @service.find(id)\n  end\nend\n\nmodule Helpers\n  def format_date(date)\n    date.strftime(\"%Y-%m-%d\")\n  end\nend\n'''\n        result = analyzer.analyze_file(\"test.rb\", \"ruby\", code)\n        \n        symbols = result.get(\"symbols\", [])\n        if symbols:  # Only check if tree-sitter is available\n            symbol_names = [s.name for s in symbols]\n            # Should find class, module, and methods\n            assert len(symbol_names) >= 1",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestLanguageCoverageIntegration_634": {
      "name": "TestLanguageCoverageIntegration",
      "type": "class",
      "start_line": 634,
      "end_line": 742,
      "content_hash": "aac920de3637b0d8ecafc683656da20a7ece3245",
      "content": "class TestLanguageCoverageIntegration:\n    \"\"\"Integration tests for the full import/call extraction pipeline.\"\"\"\n    \n    @pytest.fixture\n    def get_imports_calls(self):\n        \"\"\"Return the combined imports/calls function.\"\"\"\n        from scripts.ingest.metadata import _get_imports_calls\n        return _get_imports_calls\n    \n    def test_python_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Python full extraction pipeline.\"\"\"\n        code = '''\nimport os\nfrom pathlib import Path\n\ndef process_file(path):\n    content = Path(path).read_text()\n    result = parse(content)\n    return transform(result)\n'''\n        imports, calls = get_imports_calls(\"python\", code)\n        \n        assert \"os\" in imports\n        assert \"pathlib\" in imports\n        # Calls may include parse, transform\n        assert len(calls) >= 0\n    \n    def test_go_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Go full extraction pipeline.\"\"\"\n        code = '''\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n}\n'''\n        imports, calls = get_imports_calls(\"go\", code)\n        \n        assert \"fmt\" in imports\n    \n    def test_rust_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Rust full extraction pipeline.\"\"\"\n        code = '''\nuse std::io::Read;\n\nfn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_to_string(&mut buffer);\n    println!(\"{}\", buffer);\n}\n'''\n        imports, calls = get_imports_calls(\"rust\", code)\n        \n        assert \"std::io::Read\" in imports\n    \n    def test_java_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Java full extraction pipeline.\"\"\"\n        code = '''\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = new ArrayList<>();\n        items.add(\"hello\");\n        System.out.println(items);\n    }\n}\n'''\n        imports, calls = get_imports_calls(\"java\", code)\n        \n        assert \"java.util.List\" in imports\n        assert \"java.util.ArrayList\" in imports\n    \n    def test_cpp_full_pipeline(self, get_imports_calls):\n        \"\"\"Test C++ full extraction pipeline.\"\"\"\n        code = '''\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string name = \"World\";\n    std::cout << \"Hello, \" << name << std::endl;\n    return 0;\n}\n'''\n        imports, calls = get_imports_calls(\"cpp\", code)\n        \n        assert \"iostream\" in imports\n        assert \"string\" in imports\n    \n    def test_ruby_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Ruby full extraction pipeline.\"\"\"\n        code = '''\nrequire 'json'\nrequire 'net/http'\n\ndef fetch_data(url)\n  uri = URI.parse(url)\n  response = Net::HTTP.get(uri)\n  JSON.parse(response)\nend\n'''\n        imports, calls = get_imports_calls(\"ruby\", code)\n        \n        assert \"json\" in imports\n        assert \"net/http\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_imports_calls_638": {
      "name": "get_imports_calls",
      "type": "method",
      "start_line": 638,
      "end_line": 641,
      "content_hash": "46ff5a2f826d52923617f6ac4e6359abd5eb9444",
      "content": "    def get_imports_calls(self):\n        \"\"\"Return the combined imports/calls function.\"\"\"\n        from scripts.ingest.metadata import _get_imports_calls\n        return _get_imports_calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_python_full_pipeline_643": {
      "name": "test_python_full_pipeline",
      "type": "method",
      "start_line": 643,
      "end_line": 659,
      "content_hash": "022eb69a9686dea67c17cd2d05b2d588ad2ad9a4",
      "content": "    def test_python_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Python full extraction pipeline.\"\"\"\n        code = '''\nimport os\nfrom pathlib import Path\n\ndef process_file(path):\n    content = Path(path).read_text()\n    result = parse(content)\n    return transform(result)\n'''\n        imports, calls = get_imports_calls(\"python\", code)\n        \n        assert \"os\" in imports\n        assert \"pathlib\" in imports\n        # Calls may include parse, transform\n        assert len(calls) >= 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_go_full_pipeline_661": {
      "name": "test_go_full_pipeline",
      "type": "method",
      "start_line": 661,
      "end_line": 674,
      "content_hash": "f1756dca39af5a1e4fedf63c5fa77414f8f4d924",
      "content": "    def test_go_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Go full extraction pipeline.\"\"\"\n        code = '''\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n}\n'''\n        imports, calls = get_imports_calls(\"go\", code)\n        \n        assert \"fmt\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rust_full_pipeline_676": {
      "name": "test_rust_full_pipeline",
      "type": "method",
      "start_line": 676,
      "end_line": 689,
      "content_hash": "e506415d0ba3ea94547976b200ac37bb099853cc",
      "content": "    def test_rust_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Rust full extraction pipeline.\"\"\"\n        code = '''\nuse std::io::Read;\n\nfn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_to_string(&mut buffer);\n    println!(\"{}\", buffer);\n}\n'''\n        imports, calls = get_imports_calls(\"rust\", code)\n        \n        assert \"std::io::Read\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_java_full_pipeline_691": {
      "name": "test_java_full_pipeline",
      "type": "method",
      "start_line": 691,
      "end_line": 708,
      "content_hash": "f6bfe1aa9fda7ec2dcbfb4ba305368cdcf17c6c0",
      "content": "    def test_java_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Java full extraction pipeline.\"\"\"\n        code = '''\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = new ArrayList<>();\n        items.add(\"hello\");\n        System.out.println(items);\n    }\n}\n'''\n        imports, calls = get_imports_calls(\"java\", code)\n        \n        assert \"java.util.List\" in imports\n        assert \"java.util.ArrayList\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cpp_full_pipeline_710": {
      "name": "test_cpp_full_pipeline",
      "type": "method",
      "start_line": 710,
      "end_line": 725,
      "content_hash": "9273f0c36ec1ae49c79f047a92279bbef02b334f",
      "content": "    def test_cpp_full_pipeline(self, get_imports_calls):\n        \"\"\"Test C++ full extraction pipeline.\"\"\"\n        code = '''\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string name = \"World\";\n    std::cout << \"Hello, \" << name << std::endl;\n    return 0;\n}\n'''\n        imports, calls = get_imports_calls(\"cpp\", code)\n        \n        assert \"iostream\" in imports\n        assert \"string\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_ruby_full_pipeline_727": {
      "name": "test_ruby_full_pipeline",
      "type": "method",
      "start_line": 727,
      "end_line": 742,
      "content_hash": "e719c7eeb6961ad9fbb51f224c691ca3cdb2dbf3",
      "content": "    def test_ruby_full_pipeline(self, get_imports_calls):\n        \"\"\"Test Ruby full extraction pipeline.\"\"\"\n        code = '''\nrequire 'json'\nrequire 'net/http'\n\ndef fetch_data(url)\n  uri = URI.parse(url)\n  response = Net::HTTP.get(uri)\n  JSON.parse(response)\nend\n'''\n        imports, calls = get_imports_calls(\"ruby\", code)\n        \n        assert \"json\" in imports\n        assert \"net/http\" in imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestEdgeCases_749": {
      "name": "TestEdgeCases",
      "type": "class",
      "start_line": 749,
      "end_line": 792,
      "content_hash": "206a701d86b31dee98340e93ed21d27f4704d97b",
      "content": "class TestEdgeCases:\n    \"\"\"Test edge cases and error handling.\"\"\"\n    \n    @pytest.fixture\n    def extract_imports(self):\n        from scripts.ingest.metadata import _extract_imports\n        return _extract_imports\n    \n    @pytest.fixture\n    def extract_calls(self):\n        from scripts.ingest.metadata import _extract_calls\n        return _extract_calls\n    \n    def test_empty_code(self, extract_imports, extract_calls):\n        \"\"\"Test extraction from empty code.\"\"\"\n        assert extract_imports(\"python\", \"\") == []\n        assert extract_calls(\"python\", \"\") == []\n    \n    def test_unknown_language(self, extract_imports, extract_calls):\n        \"\"\"Test extraction for unknown language.\"\"\"\n        code = \"some random code here\"\n        assert extract_imports(\"unknown_lang\", code) == []\n        # Calls should still use regex fallback - the pattern needs word boundary\n        calls = extract_calls(\"unknown_lang\", \"result = someFunc(arg)\")\n        assert \"someFunc\" in calls\n    \n    def test_malformed_code(self, extract_imports):\n        \"\"\"Test extraction from malformed code.\"\"\"\n        # Should not crash\n        malformed = \"import ,,, from ... what???\"\n        result = extract_imports(\"python\", malformed)\n        assert isinstance(result, list)\n    \n    def test_large_file_limit(self, extract_imports, extract_calls):\n        \"\"\"Test that extraction respects the 200 item limit.\"\"\"\n        # Generate code with many imports\n        imports = \"\\n\".join([f\"import module{i}\" for i in range(300)])\n        result = extract_imports(\"python\", imports)\n        assert len(result) <= 200\n        \n        # Generate code with many calls\n        calls = \" \".join([f\"func{i}()\" for i in range(300)])\n        result = extract_calls(\"python\", calls)\n        assert len(result) <= 200",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_imports_753": {
      "name": "extract_imports",
      "type": "method",
      "start_line": 753,
      "end_line": 755,
      "content_hash": "3638be7b8a36cd3b51eac3b951e75245f279c5bf",
      "content": "    def extract_imports(self):\n        from scripts.ingest.metadata import _extract_imports\n        return _extract_imports",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extract_calls_758": {
      "name": "extract_calls",
      "type": "method",
      "start_line": 758,
      "end_line": 760,
      "content_hash": "dc2ffa000f51f8a1a59ccbc3abc44c7f4324ecf1",
      "content": "    def extract_calls(self):\n        from scripts.ingest.metadata import _extract_calls\n        return _extract_calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_empty_code_762": {
      "name": "test_empty_code",
      "type": "method",
      "start_line": 762,
      "end_line": 765,
      "content_hash": "8fc31c3f9b3cd1597ba8ff5bdb23eebe13e43e3f",
      "content": "    def test_empty_code(self, extract_imports, extract_calls):\n        \"\"\"Test extraction from empty code.\"\"\"\n        assert extract_imports(\"python\", \"\") == []\n        assert extract_calls(\"python\", \"\") == []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_unknown_language_767": {
      "name": "test_unknown_language",
      "type": "method",
      "start_line": 767,
      "end_line": 773,
      "content_hash": "06a6da9f6867ec4325fe7e475b1da3812fd26c66",
      "content": "    def test_unknown_language(self, extract_imports, extract_calls):\n        \"\"\"Test extraction for unknown language.\"\"\"\n        code = \"some random code here\"\n        assert extract_imports(\"unknown_lang\", code) == []\n        # Calls should still use regex fallback - the pattern needs word boundary\n        calls = extract_calls(\"unknown_lang\", \"result = someFunc(arg)\")\n        assert \"someFunc\" in calls",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_malformed_code_775": {
      "name": "test_malformed_code",
      "type": "method",
      "start_line": 775,
      "end_line": 780,
      "content_hash": "265419a2a80d037b134182d4e19c51287eb6d3c7",
      "content": "    def test_malformed_code(self, extract_imports):\n        \"\"\"Test extraction from malformed code.\"\"\"\n        # Should not crash\n        malformed = \"import ,,, from ... what???\"\n        result = extract_imports(\"python\", malformed)\n        assert isinstance(result, list)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_large_file_limit_782": {
      "name": "test_large_file_limit",
      "type": "method",
      "start_line": 782,
      "end_line": 792,
      "content_hash": "ca26a0a3d26c27881304803211a9268fc1bd7134",
      "content": "    def test_large_file_limit(self, extract_imports, extract_calls):\n        \"\"\"Test that extraction respects the 200 item limit.\"\"\"\n        # Generate code with many imports\n        imports = \"\\n\".join([f\"import module{i}\" for i in range(300)])\n        result = extract_imports(\"python\", imports)\n        assert len(result) <= 200\n        \n        # Generate code with many calls\n        calls = \" \".join([f\"func{i}()\" for i in range(300)])\n        result = extract_calls(\"python\", calls)\n        assert len(result) <= 200",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}