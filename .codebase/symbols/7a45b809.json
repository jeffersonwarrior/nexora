{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/creation_step_parse_methods.rs",
  "file_hash": "69b4458d3dd5dedade5d5f048581a8565e75d5f6",
  "updated_at": "2025-12-26T17:34:25.147546",
  "symbols": {
    "impl_HelixParser_9": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 9,
      "end_line": 161,
      "content_hash": "0a8ced111e9eac8e1922cb6a9f2cfc9594cbb14a",
      "content": "impl HelixParser {\n    pub(super) fn parse_add_vector(&self, pair: Pair<Rule>) -> Result<AddVector, ParserError> {\n        let mut vector_type = None;\n        let mut data = None;\n        let mut fields = None;\n\n        for p in pair.clone().into_inner() {\n            match p.as_rule() {\n                Rule::identifier_upper => {\n                    vector_type = Some(p.as_str().to_string());\n                }\n                Rule::vector_data => {\n                    let vector_data = p.clone().try_inner_next()?;\n                    match vector_data.as_rule() {\n                        Rule::identifier => {\n                            data = Some(VectorData::Identifier(p.as_str().to_string()));\n                        }\n                        Rule::vec_literal => {\n                            data = Some(VectorData::Vector(self.parse_vec_literal(p)?));\n                        }\n                        Rule::embed_method => {\n                            let inner = vector_data.clone().try_inner_next()?;\n                            data = Some(VectorData::Embed(Embed {\n                                loc: vector_data.loc(),\n                                value: match inner.as_rule() {\n                                    Rule::identifier => {\n                                        EvaluatesToString::Identifier(inner.as_str().to_string())\n                                    }\n                                    Rule::string_literal => {\n                                        EvaluatesToString::StringLiteral(inner.as_str().to_string())\n                                    }\n                                    _ => {\n                                        return Err(ParserError::from(format!(\n                                            \"Unexpected rule in SearchV: {:?} => {:?}\",\n                                            inner.as_rule(),\n                                            inner,\n                                        )));\n                                    }\n                                },\n                            }));\n                        }\n                        _ => {\n                            return Err(ParserError::from(format!(\n                                \"Unexpected rule in SearchV: {:?} => {:?}\",\n                                vector_data.as_rule(),\n                                vector_data,\n                            )));\n                        }\n                    }\n                }\n                Rule::create_field => {\n                    fields = Some(self.parse_property_assignments(p)?);\n                }\n                _ => {\n                    return Err(ParserError::from(format!(\n                        \"Unexpected rule in AddV: {:?} => {:?}\",\n                        p.as_rule(),\n                        p,\n                    )));\n                }\n            }\n        }\n\n        Ok(AddVector {\n            vector_type,\n            data,\n            fields,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_add_node(&self, pair: Pair<Rule>) -> Result<AddNode, ParserError> {\n        let mut node_type = None;\n        let mut fields = None;\n\n        for p in pair.clone().into_inner() {\n            match p.as_rule() {\n                Rule::identifier_upper => {\n                    node_type = Some(p.as_str().to_string());\n                }\n                Rule::create_field => {\n                    fields = Some(self.parse_property_assignments(p)?);\n                }\n                _ => {\n                    return Err(ParserError::from(format!(\n                        \"Unexpected rule in AddV: {:?} => {:?}\",\n                        p.as_rule(),\n                        p,\n                    )));\n                }\n            }\n        }\n\n        Ok(AddNode {\n            node_type,\n            fields,\n            loc: pair.loc(),\n        })\n    }\n\n    pub(super) fn parse_add_edge(\n        &self,\n        pair: Pair<Rule>,\n        from_identifier: bool,\n    ) -> Result<AddEdge, ParserError> {\n        let mut edge_type = None;\n        let mut fields = None;\n        let mut connection = None;\n\n        for p in pair.clone().into_inner() {\n            match p.as_rule() {\n                Rule::identifier_upper => {\n                    edge_type = Some(p.as_str().to_string());\n                }\n                Rule::create_field => {\n                    fields = Some(self.parse_property_assignments(p)?);\n                }\n                Rule::to_from => {\n                    connection = Some(self.parse_to_from(p)?);\n                }\n                _ => {\n                    return Err(ParserError::from(format!(\n                        \"Unexpected rule in AddE: {:?}\",\n                        p.as_rule()\n                    )));\n                }\n            }\n        }\n        if edge_type.is_none() {\n            return Err(ParserError::from(\"Missing edge type\"));\n        }\n        if connection.is_none() {\n            return Err(ParserError::from(\"Missing edge connection\"));\n        }\n        Ok(AddEdge {\n            edge_type,\n            fields,\n            connection: connection.ok_or_else(|| ParserError::from(\"Missing edge connection\"))?,\n            from_identifier,\n            loc: pair.loc(),\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::helixc::parser::{write_to_temp_file, HelixParser};\n\n    // ============================================================================\n    // AddNode Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_basic_162": {
      "name": "test_parse_add_node_basic",
      "type": "method",
      "start_line": 162,
      "end_line": 176,
      "content_hash": "6e31f60e606b1ce01224e992c9f6941dcaf9bee2",
      "content": "    fn test_parse_add_node_basic() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY createPerson(name: String) =>\n                person <- AddN<Person>({name: name})\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_empty_fields_177": {
      "name": "test_parse_add_node_empty_fields",
      "type": "method",
      "start_line": 177,
      "end_line": 191,
      "content_hash": "81f5a8ddf79156883fa0feed7041b06204a0a238",
      "content": "    fn test_parse_add_node_empty_fields() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY createPerson() =>\n                person <- AddN<Person>()\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_multiple_fields_192": {
      "name": "test_parse_add_node_multiple_fields",
      "type": "method",
      "start_line": 192,
      "end_line": 206,
      "content_hash": "2d91e2c52174891235ef05e90829634ed6346686",
      "content": "    fn test_parse_add_node_multiple_fields() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY createPerson(name: String, age: U32, email: String) =>\n                person <- AddN<Person>({name: name, age: age, email: email})\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_with_literal_values_207": {
      "name": "test_parse_add_node_with_literal_values",
      "type": "method",
      "start_line": 207,
      "end_line": 225,
      "content_hash": "bf96d85828432da1c265658c00e17ae95642cfbd",
      "content": "    fn test_parse_add_node_with_literal_values() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY createPerson() =>\n                person <- AddN<Person>({name: \"Alice\", age: 30})\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // AddEdge Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_edge_basic_226": {
      "name": "test_parse_add_edge_basic",
      "type": "method",
      "start_line": 226,
      "end_line": 243,
      "content_hash": "41cf79c2f237065d13e6c9b4dbb30ec987270df6",
      "content": "    fn test_parse_add_edge_basic() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY createFriendship(id1: ID, id2: ID) =>\n                person1 <- N<Person>(id1)\n                person2 <- N<Person>(id2)\n                AddE<Knows>::From(person1)::To(person2)\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_edge_with_properties_244": {
      "name": "test_parse_add_edge_with_properties",
      "type": "method",
      "start_line": 244,
      "end_line": 261,
      "content_hash": "79979ce6b8b901eca336934d99c526746732e1eb",
      "content": "    fn test_parse_add_edge_with_properties() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person, Properties: { since: String } }\n\n            QUERY createFriendship(id1: ID, id2: ID, since: String) =>\n                person1 <- N<Person>(id1)\n                person2 <- N<Person>(id2)\n                AddE<Knows>({since: since})::From(person1)::To(person2)\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_edge_from_to_order_262": {
      "name": "test_parse_add_edge_from_to_order",
      "type": "method",
      "start_line": 262,
      "end_line": 279,
      "content_hash": "a325ff71e90c12d5b54794d1604e50545d6568bf",
      "content": "    fn test_parse_add_edge_from_to_order() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY createFriendship(id1: ID, id2: ID) =>\n                person1 <- N<Person>(id1)\n                person2 <- N<Person>(id2)\n                AddE<Knows>::To(person2)::From(person1)\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_edge_with_id_literals_280": {
      "name": "test_parse_add_edge_with_id_literals",
      "type": "method",
      "start_line": 280,
      "end_line": 300,
      "content_hash": "3a8b12880822186bc5916eb1c1da844dc9220c58",
      "content": "    fn test_parse_add_edge_with_id_literals() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY createFriendship(fromId: ID) =>\n                person <- N<Person>(fromId)\n                AddE<Knows>::From(person)::To(fromId)\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // AddVector Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_vector_with_identifier_301": {
      "name": "test_parse_add_vector_with_identifier",
      "type": "method",
      "start_line": 301,
      "end_line": 315,
      "content_hash": "f0d95e5e284ff3c83edf4856bf25fe39d8e24c57",
      "content": "    fn test_parse_add_vector_with_identifier() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY addDoc(vector: [F32], content: String) =>\n                doc <- AddV<Document>(vector, {content: content})\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_vector_with_embed_316": {
      "name": "test_parse_add_vector_with_embed",
      "type": "method",
      "start_line": 316,
      "end_line": 330,
      "content_hash": "46e9c362b156e96df4175055f3838ea5a678641f",
      "content": "    fn test_parse_add_vector_with_embed() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY addDoc(text: String) =>\n                doc <- AddV<Document>(Embed(text), {content: text})\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_vector_with_string_embed_331": {
      "name": "test_parse_add_vector_with_string_embed",
      "type": "method",
      "start_line": 331,
      "end_line": 345,
      "content_hash": "1560f3b99f97da21be3464554daa4093ef3c664a",
      "content": "    fn test_parse_add_vector_with_string_embed() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            QUERY addDoc() =>\n                doc <- AddV<Document>(Embed(\"hello world\"), {content: \"hello world\"})\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_vector_multiple_fields_346": {
      "name": "test_parse_add_vector_multiple_fields",
      "type": "method",
      "start_line": 346,
      "end_line": 364,
      "content_hash": "16df2123580fed5e3529c8616ddde9a03b321c08",
      "content": "    fn test_parse_add_vector_multiple_fields() {\n        let source = r#\"\n            V::Document { content: String, title: String, embedding: [F32] }\n\n            QUERY addDoc(vec: [F32], content: String, title: String) =>\n                doc <- AddV<Document>(vec, {content: content, title: title})\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Complex Creation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_create_node_and_edge_365": {
      "name": "test_parse_create_node_and_edge",
      "type": "method",
      "start_line": 365,
      "end_line": 382,
      "content_hash": "1e3ba6b86e4336ffbf39084d82ebeb91dbae1b9d",
      "content": "    fn test_parse_create_node_and_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY createRelationship(name1: String, name2: String) =>\n                person1 <- AddN<Person>({name: name1})\n                person2 <- AddN<Person>({name: name2})\n                AddE<Knows>::From(person1)::To(person2)\n                RETURN person1\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_multiple_node_creations_383": {
      "name": "test_parse_multiple_node_creations",
      "type": "method",
      "start_line": 383,
      "end_line": 399,
      "content_hash": "c5c7c535e9e6542502b3f8a9636fe2d93085202b",
      "content": "    fn test_parse_multiple_node_creations() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY createPeople() =>\n                p1 <- AddN<Person>({name: \"Alice\"})\n                p2 <- AddN<Person>({name: \"Bob\"})\n                p3 <- AddN<Person>({name: \"Charlie\"})\n                RETURN p1\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_with_object_type_field_400": {
      "name": "test_parse_add_node_with_object_type_field",
      "type": "method",
      "start_line": 400,
      "end_line": 418,
      "content_hash": "0873dfdf6bffcfde2f678f7aa7af2612728c402a",
      "content": "    fn test_parse_add_node_with_object_type_field() {\n        let source = r#\"\n            N::Person { name: String, details: {age: U32, city: String} }\n\n            QUERY createPerson(name: String, age: U32, city: String) =>\n                person <- AddN<Person>({name: name})\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    // ============================================================================\n    // Edge Cases\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_node_empty_type_419": {
      "name": "test_parse_add_node_empty_type",
      "type": "method",
      "start_line": 419,
      "end_line": 433,
      "content_hash": "efe7967090b8e2dd9594abdd0742fdd5ceddd513",
      "content": "    fn test_parse_add_node_empty_type() {\n        let source = r#\"\n            N::EmptyNode {}\n\n            QUERY createEmpty() =>\n                node <- AddN<EmptyNode>()\n                RETURN node\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_creation_with_traversal_result_434": {
      "name": "test_parse_creation_with_traversal_result",
      "type": "method",
      "start_line": 434,
      "end_line": 451,
      "content_hash": "d1afccd063afc18d16c689e238dcfa3f1647ff4b",
      "content": "    fn test_parse_creation_with_traversal_result() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY addEdgeFromQuery(id: ID) =>\n                person <- N<Person>(id)\n                friend <- N<Person>\n                AddE<Knows>::From(person)::To(friend)\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_parse_add_vector_no_extra_fields_452": {
      "name": "test_parse_add_vector_no_extra_fields",
      "type": "method",
      "start_line": 452,
      "end_line": 465,
      "content_hash": "ee4eed3bce8691b4e8909134b97fb5e27e34ba9c",
      "content": "    fn test_parse_add_vector_no_extra_fields() {\n        let source = r#\"\n            V::Document { embedding: [F32] }\n\n            QUERY addDoc(vec: [F32]) =>\n                doc <- AddV<Document>(vec)\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let result = HelixParser::parse_source(&content);\n        assert!(result.is_ok());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}