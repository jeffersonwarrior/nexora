{
  "file_path": "/work/context-engine/scripts/ingest/symbols.py",
  "file_hash": "ced9631c2e0c92d37a9c7dc5153096d7a2b29612",
  "updated_at": "2025-12-26T17:34:19.911245",
  "symbols": {
    "class__Sym_27": {
      "name": "_Sym",
      "type": "class",
      "start_line": 27,
      "end_line": 29,
      "content_hash": "67d2f8a2ee2dc8c852b232b40fc940a03615dabf",
      "content": "class _Sym(dict):\n    \"\"\"Symbol dict with attribute-style access.\"\"\"\n    __getattr__ = dict.get",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_python_35": {
      "name": "_extract_symbols_python",
      "type": "function",
      "start_line": 35,
      "end_line": 62,
      "content_hash": "b576cdac2848c64bbc621c2de580b38fa5281e86",
      "content": "def _extract_symbols_python(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from Python code using the ast module.\"\"\"\n    try:\n        tree = ast.parse(text)\n    except Exception:\n        return []\n    out: List[_Sym] = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            out.append(\n                _Sym(\n                    kind=\"function\",\n                    name=node.name,\n                    start=getattr(node, \"lineno\", 0),\n                    end=getattr(node, \"end_lineno\", getattr(node, \"lineno\", 0)),\n                )\n            )\n        elif isinstance(node, ast.ClassDef):\n            out.append(\n                _Sym(\n                    kind=\"class\",\n                    name=node.name,\n                    start=getattr(node, \"lineno\", 0),\n                    end=getattr(node, \"end_lineno\", getattr(node, \"lineno\", 0)),\n                )\n            )\n    # Filter invalid\n    return [s for s in out if s.start and s.end and s.end >= s.start]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_js_like_77": {
      "name": "_extract_symbols_js_like",
      "type": "function",
      "start_line": 77,
      "end_line": 99,
      "content_hash": "0afea8928d8f4899ea10652431a4eced03ae81c1",
      "content": "def _extract_symbols_js_like(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from JavaScript/TypeScript using regex.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        for pat in _JS_CLASS_PATTERNS:\n            m = re.match(pat, line)\n            if m:\n                syms.append(_Sym(kind=\"class\", name=m.group(1), start=idx, end=idx))\n                break\n        for pat in _JS_FUNC_PATTERNS:\n            m = re.match(pat, line)\n            if m:\n                syms.append(_Sym(kind=\"function\", name=m.group(1), start=idx, end=idx))\n                break\n    # Approximate end by next symbol start-1\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        if i + 1 < len(syms):\n            syms[i][\"end\"] = max(syms[i].start, syms[i + 1].start - 1)\n        else:\n            syms[i][\"end\"] = max(syms[i].start, len(lines))\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_go_102": {
      "name": "_extract_symbols_go",
      "type": "function",
      "start_line": 102,
      "end_line": 137,
      "content_hash": "cff79b9319343e5b2855ac7e055bbbe6d02e3c90",
      "content": "def _extract_symbols_go(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from Go source code.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        m = re.match(r\"^\\s*type\\s+([A-Za-z_][\\w]*)\\s+struct\\b\", line)\n        if m:\n            syms.append(_Sym(kind=\"struct\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*type\\s+([A-Za-z_][\\w]*)\\s+interface\\b\", line)\n        if m:\n            syms.append(_Sym(kind=\"interface\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(\n            r\"^\\s*func\\s*\\(\\s*[^)]+\\s+\\*?([A-Za-z_][\\w]*)\\s*\\)\\s*([A-Za-z_][\\w]*)\\s*\\(\",\n            line,\n        )\n        if m:\n            syms.append(\n                _Sym(\n                    kind=\"method\",\n                    name=m.group(2),\n                    path=f\"{m.group(1)}.{m.group(2)}\",\n                    start=idx,\n                    end=idx,\n                )\n            )\n            continue\n        m = re.match(r\"^\\s*func\\s+([A-Za-z_][\\w]*)\\s*\\(\", line)\n        if m:\n            syms.append(_Sym(kind=\"function\", name=m.group(1), start=idx, end=idx))\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_java_140": {
      "name": "_extract_symbols_java",
      "type": "function",
      "start_line": 140,
      "end_line": 166,
      "content_hash": "2f890aa2156bf04016d2fd7bd6e007fe7480a9f0",
      "content": "def _extract_symbols_java(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from Java source code.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    current_class = None\n    for idx, line in enumerate(lines, 1):\n        m = re.match(\n            r\"^\\s*(?:public|protected|private)?\\s*(?:final\\s+|abstract\\s+)?class\\s+([A-Za-z_][\\w]*)\\b\",\n            line,\n        )\n        if m:\n            current_class = m.group(1)\n            syms.append(_Sym(kind=\"class\", name=current_class, start=idx, end=idx))\n            continue\n        m = re.match(\n            r\"^\\s*(?:public|protected|private)?\\s*(?:static\\s+)?[A-Za-z_<>,\\[\\]]+\\s+([A-Za-z_][\\w]*)\\s*\\(\",\n            line,\n        )\n        if m:\n            name = m.group(1)\n            path = f\"{current_class}.{name}\" if current_class else name\n            syms.append(_Sym(kind=\"method\", name=name, path=path, start=idx, end=idx))\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_csharp_169": {
      "name": "_extract_symbols_csharp",
      "type": "function",
      "start_line": 169,
      "end_line": 193,
      "content_hash": "bc90b9aba9e5f141a035a69f0c1cd069ea366295",
      "content": "def _extract_symbols_csharp(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from C# source code.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    current_type = None\n    for idx, line in enumerate(lines, 1):\n        # class / interface / struct / enum\n        m = re.match(r\"^\\s*(?:public|protected|private|internal)?\\s*(?:abstract\\s+|sealed\\s+|static\\s+)?(class|interface|struct|enum)\\s+([A-Za-z_][\\w]*)\\b\", line)\n        if m:\n            kind, name = m.group(1), m.group(2)\n            current_type = name\n            kind_map = {\"class\": \"class\", \"interface\": \"interface\", \"struct\": \"struct\", \"enum\": \"enum\"}\n            syms.append(_Sym(kind=kind_map.get(kind, \"type\"), name=name, start=idx, end=idx))\n            continue\n        # method (very heuristic)\n        m = re.match(r\"^\\s*(?:public|protected|private|internal)?\\s*(?:static\\s+|virtual\\s+|override\\s+|async\\s+)?[A-Za-z_<>,\\[\\]\\.]+\\s+([A-Za-z_][\\w]*)\\s*\\(\", line)\n        if m:\n            name = m.group(1)\n            path = f\"{current_type}.{name}\" if current_type else name\n            syms.append(_Sym(kind=\"method\", name=name, path=path, start=idx, end=idx))\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_php_196": {
      "name": "_extract_symbols_php",
      "type": "function",
      "start_line": 196,
      "end_line": 231,
      "content_hash": "bdd8ad7abff348d90c3c14bb54019884cdcbb4e0",
      "content": "def _extract_symbols_php(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from PHP source code.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    current_type = None\n    depth = 0\n    for idx, line in enumerate(lines, 1):\n        # track simple brace depth to reset current_type when leaving class\n        depth += line.count(\"{\")\n        depth -= line.count(\"}\")\n        if depth <= 0:\n            current_type = None\n        # namespace declaration (optional informational anchor)\n        m = re.match(r\"^\\s*namespace\\s+([A-Za-z_][A-Za-z0-9_\\\\\\\\]*)\\s*;\", line)\n        if m:\n            ns = m.group(1).replace(\"\\\\\\\\\", \"\\\\\")\n            syms.append(_Sym(kind=\"namespace\", name=ns, start=idx, end=idx))\n            continue\n        # class/interface/trait\n        m = re.match(r\"^\\s*(?:final\\s+|abstract\\s+)?(class|interface|trait)\\s+([A-Za-z_][\\w]*)\\b\", line)\n        if m:\n            kind, name = m.group(1), m.group(2)\n            current_type = name\n            syms.append(_Sym(kind=kind, name=name, start=idx, end=idx))\n            continue\n        # methods or functions\n        m = re.match(r\"^\\s*(?:public|private|protected)?\\s*(?:static\\s+)?function\\s+([A-Za-z_][\\w]*)\\s*\\(\", line)\n        if m:\n            name = m.group(1)\n            path = f\"{current_type}.{name}\" if current_type else name\n            syms.append(_Sym(kind=\"method\" if current_type else \"function\", name=name, path=path, start=idx, end=idx))\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_shell_234": {
      "name": "_extract_symbols_shell",
      "type": "function",
      "start_line": 234,
      "end_line": 247,
      "content_hash": "c4d30473ce943067fca4d5118eab37ff77f1dea1",
      "content": "def _extract_symbols_shell(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from shell scripts.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        m = re.match(r\"^\\s*([A-Za-z_][\\w]*)\\s*\\(\\)\\s*\\{\", line)\n        if m:\n            syms.append(_Sym(kind=\"function\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*function\\s+([A-Za-z_][\\w]*)\\s*\\{\", line)\n        if m:\n            syms.append(_Sym(kind=\"function\", name=m.group(1), start=idx, end=idx))\n            continue\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_yaml_250": {
      "name": "_extract_symbols_yaml",
      "type": "function",
      "start_line": 250,
      "end_line": 261,
      "content_hash": "e0c0e7fedc4b7faf8e990c46a5443b102171d07c",
      "content": "def _extract_symbols_yaml(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from YAML files (headings).\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        # treat Markdown-style headings in YAML files as anchors\n        m = re.match(r\"^#\\s+(.+)$\", line)\n        if m:\n            syms.append(\n                _Sym(kind=\"heading\", name=m.group(1).strip(), start=idx, end=idx)\n            )\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_powershell_264": {
      "name": "_extract_symbols_powershell",
      "type": "function",
      "start_line": 264,
      "end_line": 283,
      "content_hash": "2f4d54307e2596bf38f4fd3005051eb7ef3b5fa4",
      "content": "def _extract_symbols_powershell(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from PowerShell scripts.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        if re.match(\n            r\"^\\s*function\\s+([A-Za-z_][\\w-]*)\\s*\\{\", line, flags=re.IGNORECASE\n        ):\n            name = (\n                re.sub(r\"^\\s*function\\s+\", \"\", line, flags=re.IGNORECASE)\n                .split(\"{\")[0]\n                .strip()\n            )\n            syms.append(_Sym(kind=\"function\", name=name, start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*class\\s+([A-Za-z_][\\w-]*)\\s*\\{\", line, flags=re.IGNORECASE)\n        if m:\n            syms.append(_Sym(kind=\"class\", name=m.group(1), start=idx, end=idx))\n            continue\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_rust_286": {
      "name": "_extract_symbols_rust",
      "type": "function",
      "start_line": 286,
      "end_line": 319,
      "content_hash": "f91a25e6fad1e23d970840e709b38876f5895689",
      "content": "def _extract_symbols_rust(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from Rust source code.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    current_impl = None\n    for idx, line in enumerate(lines, 1):\n        m = re.match(r\"^\\s*impl(?:\\s*<[^>]+>)?\\s*([A-Za-z_][\\w:]*)\", line)\n        if m:\n            current_impl = m.group(1)\n            syms.append(_Sym(kind=\"impl\", name=current_impl, start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*(?:pub\\s+)?struct\\s+([A-Za-z_][\\w]*)\\b\", line)\n        if m:\n            syms.append(_Sym(kind=\"struct\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*(?:pub\\s+)?enum\\s+([A-Za-z_][\\w]*)\\b\", line)\n        if m:\n            syms.append(_Sym(kind=\"enum\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*(?:pub\\s+)?trait\\s+([A-Za-z_][\\w]*)\\b\", line)\n        if m:\n            syms.append(_Sym(kind=\"trait\", name=m.group(1), start=idx, end=idx))\n            continue\n        m = re.match(r\"^\\s*(?:pub\\s+)?fn\\s+([A-Za-z_][\\w]*)\\s*\\(\", line)\n        if m:\n            name = m.group(1)\n            path = f\"{current_impl}::{name}\" if current_impl else name\n            kind = \"method\" if current_impl else \"function\"\n            syms.append(_Sym(kind=kind, name=name, path=path, start=idx, end=idx))\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_terraform_322": {
      "name": "_extract_symbols_terraform",
      "type": "function",
      "start_line": 322,
      "end_line": 390,
      "content_hash": "03ff951bc70e3c6c43388b13dc139df5857306aa",
      "content": "def _extract_symbols_terraform(text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from Terraform files.\"\"\"\n    lines = text.splitlines()\n    syms: List[_Sym] = []\n    for idx, line in enumerate(lines, 1):\n        m = re.match(r\"^\\s*(resource)\\s+\\\"([^\\\"]+)\\\"\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            t, name = m.group(2), m.group(3)\n            syms.append(\n                _Sym(kind=\"resource\", name=name, path=f\"{t}.{name}\", start=idx, end=idx)\n            )\n            continue\n        m = re.match(r\"^\\s*(data)\\s+\\\"([^\\\"]+)\\\"\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            t, name = m.group(2), m.group(3)\n            syms.append(\n                _Sym(\n                    kind=\"data\", name=name, path=f\"data.{t}.{name}\", start=idx, end=idx\n                )\n            )\n            continue\n        m = re.match(r\"^\\s*(module)\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            name = m.group(2)\n            syms.append(\n                _Sym(\n                    kind=\"module\", name=name, path=f\"module.{name}\", start=idx, end=idx\n                )\n            )\n            continue\n        m = re.match(r\"^\\s*(variable)\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            name = m.group(2)\n            syms.append(\n                _Sym(kind=\"variable\", name=name, path=f\"var.{name}\", start=idx, end=idx)\n            )\n            continue\n        m = re.match(r\"^\\s*(output)\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            name = m.group(2)\n            syms.append(\n                _Sym(\n                    kind=\"output\", name=name, path=f\"output.{name}\", start=idx, end=idx\n                )\n            )\n            continue\n        m = re.match(r\"^\\s*(provider)\\s+\\\"([^\\\"]+)\\\"\\s*\\{\", line)\n        if m:\n            name = m.group(2)\n            syms.append(\n                _Sym(\n                    kind=\"provider\",\n                    name=name,\n                    path=f\"provider.{name}\",\n                    start=idx,\n                    end=idx,\n                )\n            )\n            continue\n        m = re.match(r\"^\\s*(locals)\\s*\\{\", line)\n        if m:\n            syms.append(\n                _Sym(kind=\"locals\", name=\"locals\", path=\"locals\", start=idx, end=idx)\n            )\n            continue\n    syms.sort(key=lambda s: s.start)\n    for i in range(len(syms)):\n        syms[i][\"end\"] = (syms[i + 1].start - 1) if (i + 1 < len(syms)) else len(lines)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_symbols_python_396": {
      "name": "_ts_extract_symbols_python",
      "type": "function",
      "start_line": 396,
      "end_line": 448,
      "content_hash": "ed692e8dad4e7855b53f10a800adaa79b28984d2",
      "content": "def _ts_extract_symbols_python(text: str) -> List[_Sym]:\n    \"\"\"Extract Python symbols using tree-sitter.\"\"\"\n    parser = _ts_parser(\"python\")\n    if not parser:\n        return []\n    try:\n        tree = parser.parse(text.encode(\"utf-8\"))\n        if tree is None:\n            return []\n        root = tree.root_node\n    except (ValueError, Exception) as e:\n        print(f\"[WARN] Tree-sitter parse failed for Python: {e}\")\n        return []\n    syms: List[_Sym] = []\n\n    def node_text(n):\n        return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n            \"utf-8\", errors=\"ignore\"\n        )\n\n    class_stack: List[str] = []\n\n    def walk(n):\n        t = n.type\n        if t == \"class_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            cls = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n            class_stack.append(cls)\n            # Walk body\n            for c in n.children:\n                walk(c)\n            class_stack.pop()\n            return\n        if t == \"function_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            fn = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            if class_stack:\n                path = f\"{class_stack[-1]}.{fn}\"\n                syms.append(\n                    _Sym(kind=\"method\", name=fn, path=path, start=start, end=end)\n                )\n            else:\n                syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n        for c in n.children:\n            walk(c)\n\n    walk(root)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_text_411": {
      "name": "node_text",
      "type": "function",
      "start_line": 411,
      "end_line": 414,
      "content_hash": "fc04ec458a2ec8e2c52d6baedfb13251921fe0e6",
      "content": "    def node_text(n):\n        return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n            \"utf-8\", errors=\"ignore\"\n        )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_418": {
      "name": "walk",
      "type": "function",
      "start_line": 418,
      "end_line": 445,
      "content_hash": "1361eb21e7f7df0462324b24bc17cb4db1ffd3a5",
      "content": "    def walk(n):\n        t = n.type\n        if t == \"class_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            cls = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n            class_stack.append(cls)\n            # Walk body\n            for c in n.children:\n                walk(c)\n            class_stack.pop()\n            return\n        if t == \"function_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            fn = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            if class_stack:\n                path = f\"{class_stack[-1]}.{fn}\"\n                syms.append(\n                    _Sym(kind=\"method\", name=fn, path=path, start=start, end=end)\n                )\n            else:\n                syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n        for c in n.children:\n            walk(c)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_symbols_js_451": {
      "name": "_ts_extract_symbols_js",
      "type": "function",
      "start_line": 451,
      "end_line": 518,
      "content_hash": "ada57f7bd366a6eba223f270fa02b2393c4a0d85",
      "content": "def _ts_extract_symbols_js(text: str) -> List[_Sym]:\n    \"\"\"Extract JavaScript symbols using tree-sitter.\"\"\"\n    parser = _ts_parser(\"javascript\")\n    if not parser:\n        return []\n    try:\n        tree = parser.parse(text.encode(\"utf-8\"))\n        if tree is None:\n            return []\n        root = tree.root_node\n    except (ValueError, Exception) as e:\n        print(f\"[WARN] Tree-sitter parse failed for JavaScript/TypeScript: {e}\")\n        return []\n    syms: List[_Sym] = []\n\n    def node_text(n):\n        return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n            \"utf-8\", errors=\"ignore\"\n        )\n\n    class_stack: List[str] = []\n\n    def walk(n):\n        t = n.type\n        if t == \"class_declaration\":\n            name_node = n.child_by_field_name(\"name\")\n            cls = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n            class_stack.append(cls)\n            for c in n.children:\n                walk(c)\n            class_stack.pop()\n            return\n        if t in (\"function_declaration\",):\n            name_node = n.child_by_field_name(\"name\")\n            fn = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n        if t == \"method_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            m = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            path = f\"{class_stack[-1]}.{m}\" if class_stack else m\n            syms.append(_Sym(kind=\"method\", name=m, path=path, start=start, end=end))\n        # Handle variable declarations with function expressions or arrow functions\n        if t == \"variable_declarator\":\n            name_node = None\n            value_node = None\n            for c in n.children:\n                if c.type == \"identifier\" and name_node is None:\n                    name_node = c\n                elif c.type in (\"function_expression\", \"arrow_function\"):\n                    value_node = c\n            if name_node and value_node:\n                fn = node_text(name_node)\n                start = n.start_point[0] + 1\n                end = n.end_point[0] + 1\n                syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                return\n        for c in n.children:\n            walk(c)\n\n    walk(root)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_text_466": {
      "name": "node_text",
      "type": "function",
      "start_line": 466,
      "end_line": 469,
      "content_hash": "fc04ec458a2ec8e2c52d6baedfb13251921fe0e6",
      "content": "    def node_text(n):\n        return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n            \"utf-8\", errors=\"ignore\"\n        )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_473": {
      "name": "walk",
      "type": "function",
      "start_line": 473,
      "end_line": 515,
      "content_hash": "4e09cdfe2616f03fc336c5c90cc8667e207a7e97",
      "content": "    def walk(n):\n        t = n.type\n        if t == \"class_declaration\":\n            name_node = n.child_by_field_name(\"name\")\n            cls = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n            class_stack.append(cls)\n            for c in n.children:\n                walk(c)\n            class_stack.pop()\n            return\n        if t in (\"function_declaration\",):\n            name_node = n.child_by_field_name(\"name\")\n            fn = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n        if t == \"method_definition\":\n            name_node = n.child_by_field_name(\"name\")\n            m = node_text(name_node) if name_node else \"\"\n            start = n.start_point[0] + 1\n            end = n.end_point[0] + 1\n            path = f\"{class_stack[-1]}.{m}\" if class_stack else m\n            syms.append(_Sym(kind=\"method\", name=m, path=path, start=start, end=end))\n        # Handle variable declarations with function expressions or arrow functions\n        if t == \"variable_declarator\":\n            name_node = None\n            value_node = None\n            for c in n.children:\n                if c.type == \"identifier\" and name_node is None:\n                    name_node = c\n                elif c.type in (\"function_expression\", \"arrow_function\"):\n                    value_node = c\n            if name_node and value_node:\n                fn = node_text(name_node)\n                start = n.start_point[0] + 1\n                end = n.end_point[0] + 1\n                syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                return\n        for c in n.children:\n            walk(c)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_symbols_yaml_521": {
      "name": "_ts_extract_symbols_yaml",
      "type": "function",
      "start_line": 521,
      "end_line": 588,
      "content_hash": "8337e400e48858bd0ea30b91fff180a50daf0896",
      "content": "def _ts_extract_symbols_yaml(text: str) -> List[_Sym]:\n    \"\"\"Tree-sitter based YAML symbol extraction.\"\"\"\n    parser = _ts_parser(\"yaml\")\n    if not parser:\n        return []\n    try:\n        tree = parser.parse(text.encode(\"utf-8\"))\n        if tree is None:\n            return []\n        root = tree.root_node\n    except (ValueError, Exception):\n        return []\n\n    syms: List[_Sym] = []\n    text_bytes = text.encode(\"utf-8\")\n\n    def _node_text(node) -> str:\n        return text_bytes[node.start_byte:node.end_byte].decode(\"utf-8\", errors=\"replace\")\n\n    def walk(node, path: list[str] | None = None):\n        path = path or []\n        ntype = node.type if hasattr(node, \"type\") else \"\"\n\n        if ntype == \"block_mapping_pair\":\n            key_node = None\n            for child in node.children:\n                if hasattr(child, \"type\") and child.type == \"flow_node\":\n                    key_node = child\n                    break\n                if hasattr(child, \"type\") and child.type in (\n                    \"plain_scalar\",\n                    \"double_quote_scalar\",\n                    \"single_quote_scalar\",\n                ):\n                    key_node = child\n                    break\n            if key_node:\n                key = _node_text(key_node).strip().strip('\"').strip(\"'\")\n                if key:\n                    full_path = \".\".join(path + [key])\n                    syms.append(\n                        _Sym(\n                            kind=\"key\",\n                            name=full_path,\n                            start=node.start_point[0] + 1,\n                            end=node.end_point[0] + 1,\n                        )\n                    )\n                    for child in node.children:\n                        walk(child, path + [key])\n                    return\n\n        if ntype in (\"anchor\", \"alias\"):\n            name = _node_text(node)\n            syms.append(\n                _Sym(\n                    kind=\"anchor\" if ntype == \"anchor\" else \"alias\",\n                    name=name,\n                    start=node.start_point[0] + 1,\n                    end=node.end_point[0] + 1,\n                )\n            )\n\n        for child in node.children:\n            walk(child, path)\n\n    walk(root)\n    return syms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__node_text_537": {
      "name": "_node_text",
      "type": "function",
      "start_line": 537,
      "end_line": 538,
      "content_hash": "6ddba1ffdf095d7e5c3b7fd3be9157fb989b6bfb",
      "content": "    def _node_text(node) -> str:\n        return text_bytes[node.start_byte:node.end_byte].decode(\"utf-8\", errors=\"replace\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_540": {
      "name": "walk",
      "type": "function",
      "start_line": 540,
      "end_line": 585,
      "content_hash": "57515d2457a1a19f6e35f2a98c2fe65ce439ce47",
      "content": "    def walk(node, path: list[str] | None = None):\n        path = path or []\n        ntype = node.type if hasattr(node, \"type\") else \"\"\n\n        if ntype == \"block_mapping_pair\":\n            key_node = None\n            for child in node.children:\n                if hasattr(child, \"type\") and child.type == \"flow_node\":\n                    key_node = child\n                    break\n                if hasattr(child, \"type\") and child.type in (\n                    \"plain_scalar\",\n                    \"double_quote_scalar\",\n                    \"single_quote_scalar\",\n                ):\n                    key_node = child\n                    break\n            if key_node:\n                key = _node_text(key_node).strip().strip('\"').strip(\"'\")\n                if key:\n                    full_path = \".\".join(path + [key])\n                    syms.append(\n                        _Sym(\n                            kind=\"key\",\n                            name=full_path,\n                            start=node.start_point[0] + 1,\n                            end=node.end_point[0] + 1,\n                        )\n                    )\n                    for child in node.children:\n                        walk(child, path + [key])\n                    return\n\n        if ntype in (\"anchor\", \"alias\"):\n            name = _node_text(node)\n            syms.append(\n                _Sym(\n                    kind=\"anchor\" if ntype == \"anchor\" else \"alias\",\n                    name=name,\n                    start=node.start_point[0] + 1,\n                    end=node.end_point[0] + 1,\n                )\n            )\n\n        for child in node.children:\n            walk(child, path)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_symbols_591": {
      "name": "_ts_extract_symbols",
      "type": "function",
      "start_line": 591,
      "end_line": 670,
      "content_hash": "280a79a301692e11b3b8ba0cbd4900cda74529ae",
      "content": "def _ts_extract_symbols(language: str, text: str) -> List[_Sym]:\n    \"\"\"Extract symbols using tree-sitter for supported languages.\"\"\"\n    if language == \"python\":\n        return _ts_extract_symbols_python(text)\n    if language == \"javascript\":\n        return _ts_extract_symbols_js(text)\n    if language == \"typescript\":\n        if \"typescript\" in _TS_LANGUAGES:\n            parser = _ts_parser(\"typescript\")\n            if parser:\n                try:\n                    tree = parser.parse(text.encode(\"utf-8\"))\n                    if tree is None:\n                        return []\n                    root = tree.root_node\n                except (ValueError, Exception) as e:\n                    print(f\"[WARN] Tree-sitter parse failed for TypeScript: {e}\")\n                    return []\n\n                syms: List[_Sym] = []\n\n                def node_text(n):\n                    return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n                        \"utf-8\", errors=\"ignore\"\n                    )\n\n                class_stack: List[str] = []\n\n                def walk(n):\n                    t = n.type\n                    if t == \"class_declaration\":\n                        name_node = n.child_by_field_name(\"name\")\n                        cls = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n                        class_stack.append(cls)\n                        for c in n.children:\n                            walk(c)\n                        class_stack.pop()\n                        return\n                    if t in (\"function_declaration\",):\n                        name_node = n.child_by_field_name(\"name\")\n                        fn = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                    if t == \"method_definition\":\n                        name_node = n.child_by_field_name(\"name\")\n                        m = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        path = f\"{class_stack[-1]}.{m}\" if class_stack else m\n                        syms.append(_Sym(kind=\"method\", name=m, path=path, start=start, end=end))\n                    if t == \"variable_declarator\":\n                        name_node = None\n                        value_node = None\n                        for c in n.children:\n                            if c.type == \"identifier\" and name_node is None:\n                                name_node = c\n                            elif c.type in (\"function_expression\", \"arrow_function\"):\n                                value_node = c\n                        if name_node and value_node:\n                            fn = node_text(name_node)\n                            start = n.start_point[0] + 1\n                            end = n.end_point[0] + 1\n                            syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                            return\n                    for c in n.children:\n                        walk(c)\n\n                walk(root)\n                return syms\n\n        return _ts_extract_symbols_js(text)\n\n    if language == \"yaml\":\n        return _ts_extract_symbols_yaml(text)\n\n    return []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_text_612": {
      "name": "node_text",
      "type": "function",
      "start_line": 612,
      "end_line": 615,
      "content_hash": "07b0d2be5afe9a080334b3852e65fd0ef14b73e3",
      "content": "                def node_text(n):\n                    return text.encode(\"utf-8\")[n.start_byte : n.end_byte].decode(\n                        \"utf-8\", errors=\"ignore\"\n                    )",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_619": {
      "name": "walk",
      "type": "function",
      "start_line": 619,
      "end_line": 660,
      "content_hash": "974954ce1508d049822e99ee691ce1351f54486f",
      "content": "                def walk(n):\n                    t = n.type\n                    if t == \"class_declaration\":\n                        name_node = n.child_by_field_name(\"name\")\n                        cls = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        syms.append(_Sym(kind=\"class\", name=cls, start=start, end=end))\n                        class_stack.append(cls)\n                        for c in n.children:\n                            walk(c)\n                        class_stack.pop()\n                        return\n                    if t in (\"function_declaration\",):\n                        name_node = n.child_by_field_name(\"name\")\n                        fn = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                    if t == \"method_definition\":\n                        name_node = n.child_by_field_name(\"name\")\n                        m = node_text(name_node) if name_node else \"\"\n                        start = n.start_point[0] + 1\n                        end = n.end_point[0] + 1\n                        path = f\"{class_stack[-1]}.{m}\" if class_stack else m\n                        syms.append(_Sym(kind=\"method\", name=m, path=path, start=start, end=end))\n                    if t == \"variable_declarator\":\n                        name_node = None\n                        value_node = None\n                        for c in n.children:\n                            if c.type == \"identifier\" and name_node is None:\n                                name_node = c\n                            elif c.type in (\"function_expression\", \"arrow_function\"):\n                                value_node = c\n                        if name_node and value_node:\n                            fn = node_text(name_node)\n                            start = n.start_point[0] + 1\n                            end = n.end_point[0] + 1\n                            syms.append(_Sym(kind=\"function\", name=fn, start=start, end=end))\n                            return\n                    for c in n.children:\n                        walk(c)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_symbols_676": {
      "name": "_extract_symbols",
      "type": "function",
      "start_line": 676,
      "end_line": 707,
      "content_hash": "5ad8537b535a8b1644d6e36b96a9c81d95c5c60b",
      "content": "def _extract_symbols(language: str, text: str) -> List[_Sym]:\n    \"\"\"Extract symbols from source code.\n    \n    Prefers tree-sitter when enabled and supported; falls back to regex extractors.\n    \"\"\"\n    if _use_tree_sitter():\n        ts_syms = _ts_extract_symbols(language, text)\n        if ts_syms:\n            return ts_syms\n    if language == \"python\":\n        return _extract_symbols_python(text)\n    if language in (\"javascript\", \"typescript\"):\n        return _extract_symbols_js_like(text)\n    if language == \"go\":\n        return _extract_symbols_go(text)\n    if language == \"java\":\n        return _extract_symbols_java(text)\n    if language == \"rust\":\n        return _extract_symbols_rust(text)\n    if language == \"terraform\":\n        return _extract_symbols_terraform(text)\n    if language == \"shell\":\n        return _extract_symbols_shell(text)\n    if language == \"yaml\":\n        return _extract_symbols_yaml(text)\n    if language == \"powershell\":\n        return _extract_symbols_powershell(text)\n    if language == \"csharp\":\n        return _extract_symbols_csharp(text)\n    if language == \"php\":\n        return _extract_symbols_php(text)\n    return []",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__choose_symbol_for_chunk_710": {
      "name": "_choose_symbol_for_chunk",
      "type": "function",
      "start_line": 710,
      "end_line": 728,
      "content_hash": "42735481d4e7674f9684ca8c612925a4dc3e4631",
      "content": "def _choose_symbol_for_chunk(start: int, end: int, symbols: List[_Sym]):\n    \"\"\"Choose the most relevant symbol for a given chunk range.\"\"\"\n    if not symbols:\n        return \"\", \"\", \"\"\n    overlaps = [s for s in symbols if s.start <= end and s.end >= start]\n\n    def pick(sym):\n        name = sym.get(\"name\") or \"\"\n        path = sym.get(\"path\") or name\n        return sym.get(\"kind\") or \"\", name, path\n\n    if overlaps:\n        overlaps.sort(key=lambda s: (-(s.start), (s.end - s.start)))\n        return pick(overlaps[0])\n    preceding = [s for s in symbols if s.start <= end]\n    if preceding:\n        s = max(preceding, key=lambda x: x.start)\n        return pick(s)\n    return \"\", \"\", \"\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_pick_716": {
      "name": "pick",
      "type": "function",
      "start_line": 716,
      "end_line": 719,
      "content_hash": "4e562c8e3f0ef453074bb05b3abe941e21c3708f",
      "content": "    def pick(sym):\n        name = sym.get(\"name\") or \"\"\n        path = sym.get(\"path\") or name\n        return sym.get(\"kind\") or \"\", name, path",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extract_symbols_with_tree_sitter_734": {
      "name": "extract_symbols_with_tree_sitter",
      "type": "function",
      "start_line": 734,
      "end_line": 776,
      "content_hash": "837941128fb9d61aa9eca8924b8dd33a53c15576",
      "content": "def extract_symbols_with_tree_sitter(file_path: str) -> dict:\n    \"\"\"Extract functions, classes, methods from file using tree-sitter or fallback.\n\n    Returns:\n        dict: {symbol_id: {name, type, start_line, end_line, content_hash, pseudo, tags}}\n    \"\"\"\n    from scripts.ingest.pipeline import detect_language\n    \n    try:\n        # Read file content\n        text = Path(file_path).read_text(encoding=\"utf-8\", errors=\"ignore\")\n        language = detect_language(Path(file_path))\n\n        # Use existing symbol extraction infrastructure\n        symbols_list = _extract_symbols(language, text)\n\n        # Convert to our expected dict format\n        symbols = {}\n        for sym in symbols_list:\n            symbol_id = f\"{sym['kind']}_{sym['name']}_{sym['start']}\"\n\n            # Extract actual content for hashing\n            content_lines = text.split(\"\\n\")[sym[\"start\"] - 1 : sym[\"end\"]]\n            content = \"\\n\".join(content_lines)\n            content_hash = hashlib.sha1(content.encode(\"utf-8\", errors=\"ignore\")).hexdigest()\n\n            symbols[symbol_id] = {\n                \"name\": sym[\"name\"],\n                \"type\": sym[\"kind\"],\n                \"start_line\": sym[\"start\"],\n                \"end_line\": sym[\"end\"],\n                \"content_hash\": content_hash,\n                \"content\": content,\n                \"pseudo\": \"\",\n                \"tags\": [],\n                \"qdrant_ids\": [],\n            }\n\n        return symbols\n\n    except Exception as e:\n        print(f\"[SYMBOL_EXTRACTION] Failed to extract symbols from {file_path}: {e}\")\n        return {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}