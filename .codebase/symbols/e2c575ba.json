{
  "file_path": "/work/external-deps/claude-swarm/dist/dashboard/server.js",
  "file_hash": "8fed0d89666657fac4fac723567d6ddab000a538",
  "updated_at": "2025-12-26T17:34:24.059621",
  "symbols": {
    "function_startDashboardServer_23": {
      "name": "startDashboardServer",
      "type": "function",
      "start_line": 23,
      "end_line": 657,
      "content_hash": "59411f67d3fbe41475ba79ea339e20fa5edad470",
      "content": "export async function startDashboardServer(getStateManager, options = {}) {\n    const port = options.port || 3456;\n    const host = options.host || \"127.0.0.1\";\n    const app = express();\n    // SSE client management\n    const sseClients = [];\n    let lastSnapshot = null;\n    let ssePollingInterval = null;\n    // Generate unique client ID\n    const generateClientId = () => `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    // Send SSE event to all connected clients\n    const broadcastSSE = (eventType, data) => {\n        const message = `event: ${eventType}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n        sseClients.forEach((client) => {\n            try {\n                client.res.write(message);\n            }\n            catch (err) {\n                // Client disconnected, will be cleaned up\n            }\n        });\n    };\n    // Create a snapshot of current state for change detection\n    const createSnapshot = (state) => {\n        if (!state) {\n            return {\n                status: null,\n                features: new Map(),\n                logCount: 0,\n                workerCount: 0,\n            };\n        }\n        const features = new Map();\n        let workerCount = 0;\n        for (const f of state.features) {\n            features.set(f.id, f.status);\n            if (f.status === \"in_progress\" && f.workerId) {\n                workerCount++;\n            }\n        }\n        return {\n            status: state.status,\n            features,\n            logCount: state.progressLog.length,\n            workerCount,\n        };\n    };\n    // Helper to get current state manager\n    const getState = () => {\n        const sm = getStateManager();\n        return sm ? sm.load() : null;\n    };\n    // Detect and broadcast changes between snapshots\n    const detectAndBroadcastChanges = (oldSnap, newSnap, state) => {\n        // Status change\n        if (!oldSnap || oldSnap.status !== newSnap.status) {\n            broadcastSSE(\"status\", {\n                status: newSnap.status,\n                projectDir: state?.projectDir,\n                taskDescription: state?.taskDescription,\n                startTime: state?.startTime,\n                lastUpdated: state?.lastUpdated,\n            });\n        }\n        // Feature changes\n        if (state) {\n            for (const feature of state.features) {\n                const oldStatus = oldSnap?.features.get(feature.id);\n                const newStatus = newSnap.features.get(feature.id);\n                if (oldStatus !== newStatus) {\n                    broadcastSSE(\"feature\", {\n                        id: feature.id,\n                        description: feature.description,\n                        status: feature.status,\n                        attempts: feature.attempts,\n                        workerId: feature.workerId,\n                        startedAt: feature.startedAt,\n                        completedAt: feature.completedAt,\n                        lastError: feature.lastError,\n                        notes: feature.notes,\n                    });\n                }\n            }\n        }\n        // New log entries\n        if (state && oldSnap && newSnap.logCount > oldSnap.logCount) {\n            const newLogs = state.progressLog.slice(oldSnap.logCount);\n            for (const log of newLogs) {\n                const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n                broadcastSSE(\"log\", {\n                    timestamp: match ? match[1] : new Date().toISOString(),\n                    message: match ? match[2] : log,\n                    raw: log,\n                });\n            }\n        }\n        // Worker count change\n        if (!oldSnap || oldSnap.workerCount !== newSnap.workerCount) {\n            broadcastSSE(\"worker\", {\n                activeCount: newSnap.workerCount,\n            });\n        }\n    };\n    // Start polling for state changes (called when first SSE client connects)\n    const startSSEPolling = () => {\n        if (ssePollingInterval)\n            return;\n        ssePollingInterval = setInterval(() => {\n            if (sseClients.length === 0) {\n                // No clients, stop polling\n                if (ssePollingInterval) {\n                    clearInterval(ssePollingInterval);\n                    ssePollingInterval = null;\n                }\n                return;\n            }\n            const state = getState();\n            const newSnapshot = createSnapshot(state);\n            detectAndBroadcastChanges(lastSnapshot, newSnapshot, state);\n            lastSnapshot = newSnapshot;\n        }, 1000); // Check every 1 second\n    };\n    // CORS middleware for local development\n    app.use((req, res, next) => {\n        res.header(\"Access-Control-Allow-Origin\", \"*\");\n        res.header(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\");\n        res.header(\"Access-Control-Allow-Headers\", \"Content-Type\");\n        if (req.method === \"OPTIONS\") {\n            res.sendStatus(200);\n            return;\n        }\n        next();\n    });\n    // Serve static files from the public directory\n    // In dev: src/dashboard/public, in dist: dist/dashboard/public\n    const publicPath = path.join(__dirname, \"public\");\n    app.use(express.static(publicPath));\n    // Serve index.html for root path\n    app.get(\"/\", (req, res) => {\n        res.sendFile(path.join(publicPath, \"index.html\"));\n    });\n    // JSON response helper\n    const sendJson = (res, data) => {\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.json(data);\n    };\n    // Error handling wrapper\n    const asyncHandler = (fn) => {\n        return (req, res, next) => {\n            Promise.resolve(fn(req, res)).catch(next);\n        };\n    };\n    // ============================================================================\n    // GET /api/status - Session status overview\n    // ============================================================================\n    app.get(\"/api/status\", asyncHandler(async (req, res) => {\n        const state = getState();\n        if (!state) {\n            sendJson(res, {\n                active: false,\n                message: \"No active orchestration session\",\n            });\n            return;\n        }\n        const completed = state.features.filter((f) => f.status === \"completed\").length;\n        const failed = state.features.filter((f) => f.status === \"failed\").length;\n        const inProgress = state.features.filter((f) => f.status === \"in_progress\").length;\n        const pending = state.features.filter((f) => f.status === \"pending\").length;\n        const startTime = new Date(state.startTime);\n        const now = new Date();\n        const elapsedMs = now.getTime() - startTime.getTime();\n        const elapsed = formatDuration(startTime, now);\n        // Calculate success rate\n        const totalFinished = completed + failed;\n        const successRate = totalFinished > 0 ? completed / totalFinished : 0;\n        sendJson(res, {\n            active: true,\n            projectDir: state.projectDir,\n            status: state.status,\n            taskDescription: state.taskDescription,\n            startTime: state.startTime,\n            lastUpdated: state.lastUpdated,\n            completedAt: state.completedAt,\n            elapsed,\n            elapsedMs,\n            summary: {\n                total: state.features.length,\n                completed,\n                failed,\n                inProgress,\n                pending,\n                successRate: formatPercent(successRate),\n                successRateRaw: successRate,\n            },\n        });\n    }));\n    // ============================================================================\n    // GET /api/features - Feature list with details\n    // ============================================================================\n    app.get(\"/api/features\", asyncHandler(async (req, res) => {\n        const state = getState();\n        if (!state) {\n            sendJson(res, {\n                features: [],\n                message: \"No active orchestration session\",\n            });\n            return;\n        }\n        // Optional status filter\n        const statusFilter = req.query.status;\n        let features = state.features;\n        if (statusFilter) {\n            features = features.filter((f) => f.status === statusFilter);\n        }\n        const featureData = features.map((f) => ({\n            id: f.id,\n            description: f.description,\n            status: f.status,\n            attempts: f.attempts,\n            workerId: f.workerId,\n            startedAt: f.startedAt,\n            completedAt: f.completedAt,\n            lastError: f.lastError,\n            notes: f.notes,\n            dependsOn: f.dependsOn,\n        }));\n        sendJson(res, {\n            features: featureData,\n            total: state.features.length,\n            filtered: featureData.length,\n        });\n    }));\n    // ============================================================================\n    // GET /api/workers - Worker statuses\n    // ============================================================================\n    app.get(\"/api/workers\", asyncHandler(async (req, res) => {\n        const state = getState();\n        if (!state) {\n            sendJson(res, {\n                workers: [],\n                message: \"No active orchestration session\",\n            });\n            return;\n        }\n        // Create a temporary WorkerManager to check worker statuses\n        const sm = getStateManager();\n        if (!sm) {\n            sendJson(res, {\n                workers: [],\n                message: \"No state manager available\",\n            });\n            return;\n        }\n        const workerManager = new WorkerManager(sm.projectDir, sm);\n        const workerStatuses = await workerManager.checkAllWorkers();\n        const workerData = workerStatuses.map((w) => {\n            const feature = state.features.find((f) => f.id === w.featureId);\n            return {\n                sessionName: w.sessionName,\n                featureId: w.featureId,\n                featureDescription: feature?.description,\n                status: w.status,\n                startedAt: w.startedAt,\n                lastChecked: w.lastChecked,\n            };\n        });\n        // Summary counts\n        const running = workerData.filter((w) => w.status === \"running\").length;\n        const completed = workerData.filter((w) => w.status === \"completed\").length;\n        const crashed = workerData.filter((w) => w.status === \"crashed\").length;\n        sendJson(res, {\n            workers: workerData,\n            summary: {\n                total: workerData.length,\n                running,\n                completed,\n                crashed,\n            },\n        });\n    }));\n    // ============================================================================\n    // GET /api/workers/:featureId/output - Stream worker terminal output via SSE\n    // ============================================================================\n    app.get(\"/api/workers/:featureId/output\", asyncHandler(async (req, res) => {\n        const featureId = req.params.featureId;\n        const state = getState();\n        if (!state) {\n            res.status(404).json({\n                error: \"No active orchestration session\",\n            });\n            return;\n        }\n        // Find the feature\n        const feature = state.features.find((f) => f.id === featureId);\n        if (!feature) {\n            res.status(404).json({\n                error: `Feature not found: ${featureId}`,\n            });\n            return;\n        }\n        // Check if feature has an active worker\n        if (!feature.workerId) {\n            res.status(404).json({\n                error: `No active worker for feature: ${featureId}`,\n            });\n            return;\n        }\n        // Set SSE headers\n        res.setHeader(\"Content-Type\", \"text/event-stream\");\n        res.setHeader(\"Cache-Control\", \"no-cache\");\n        res.setHeader(\"Connection\", \"keep-alive\");\n        res.setHeader(\"X-Accel-Buffering\", \"no\");\n        res.flushHeaders();\n        // Send initial output\n        const sendOutput = async () => {\n            try {\n                // Get the worker output using tmux capture-pane (100 lines)\n                const { execFile } = await import(\"child_process\");\n                const { promisify } = await import(\"util\");\n                const execFileAsync = promisify(execFile);\n                try {\n                    const { stdout } = await execFileAsync(\"tmux\", [\n                        \"capture-pane\",\n                        \"-t\",\n                        feature.workerId,\n                        \"-p\",\n                        \"-S\",\n                        \"-100\", // Last 100 lines\n                    ]);\n                    res.write(`event: output\\ndata: ${JSON.stringify({\n                        featureId,\n                        output: stdout,\n                        timestamp: new Date().toISOString(),\n                    })}\\n\\n`);\n                }\n                catch (tmuxError) {\n                    // Session might have ended\n                    res.write(`event: ended\\ndata: ${JSON.stringify({\n                        featureId,\n                        message: \"Worker session ended or not found\",\n                        timestamp: new Date().toISOString(),\n                    })}\\n\\n`);\n                    clearInterval(outputInterval);\n                    res.end();\n                }\n            }\n            catch (error) {\n                res.write(`event: error\\ndata: ${JSON.stringify({\n                    featureId,\n                    error: error.message,\n                    timestamp: new Date().toISOString(),\n                })}\\n\\n`);\n            }\n        };\n        // Send initial output immediately\n        await sendOutput();\n        // Stream updates every 2 seconds\n        const outputInterval = setInterval(async () => {\n            // Check if feature still has active worker\n            const currentState = getState();\n            const currentFeature = currentState?.features.find((f) => f.id === featureId);\n            if (!currentFeature || !currentFeature.workerId) {\n                res.write(`event: ended\\ndata: ${JSON.stringify({\n                    featureId,\n                    message: \"Worker completed or stopped\",\n                    timestamp: new Date().toISOString(),\n                })}\\n\\n`);\n                clearInterval(outputInterval);\n                res.end();\n                return;\n            }\n            await sendOutput();\n        }, 2000);\n        // Handle client disconnect\n        req.on(\"close\", () => {\n            clearInterval(outputInterval);\n        });\n    }));\n    // ============================================================================\n    // GET /api/logs - Progress log entries\n    // ============================================================================\n    app.get(\"/api/logs\", asyncHandler(async (req, res) => {\n        const state = getState();\n        if (!state) {\n            sendJson(res, {\n                logs: [],\n                message: \"No active orchestration session\",\n            });\n            return;\n        }\n        // Optional limit parameter\n        const limitParam = req.query.limit;\n        const limit = limitParam ? parseInt(limitParam, 10) : undefined;\n        let logs = state.progressLog;\n        if (limit && limit > 0) {\n            logs = logs.slice(-limit);\n        }\n        // Parse logs into structured format\n        const parsedLogs = logs.map((log) => {\n            const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n            if (match) {\n                return {\n                    timestamp: match[1],\n                    message: match[2],\n                    raw: log,\n                };\n            }\n            return {\n                timestamp: null,\n                message: log,\n                raw: log,\n            };\n        });\n        sendJson(res, {\n            logs: parsedLogs,\n            total: state.progressLog.length,\n            returned: parsedLogs.length,\n        });\n    }));\n    // ============================================================================\n    // GET /api/stats - Session statistics\n    // ============================================================================\n    app.get(\"/api/stats\", asyncHandler(async (req, res) => {\n        const state = getState();\n        if (!state) {\n            sendJson(res, {\n                stats: null,\n                message: \"No active orchestration session\",\n            });\n            return;\n        }\n        const completed = state.features.filter((f) => f.status === \"completed\");\n        const failed = state.features.filter((f) => f.status === \"failed\");\n        // Calculate completion times\n        const completionTimes = [];\n        for (const feature of completed) {\n            if (feature.startedAt && feature.completedAt) {\n                const startTime = new Date(feature.startedAt).getTime();\n                const endTime = new Date(feature.completedAt).getTime();\n                if (startTime > 0 && endTime > startTime) {\n                    completionTimes.push(endTime - startTime);\n                }\n            }\n        }\n        const avgCompletionTimeMs = calculateAverage(completionTimes);\n        const minCompletionTimeMs = completionTimes.length > 0 ? Math.min(...completionTimes) : 0;\n        const maxCompletionTimeMs = completionTimes.length > 0 ? Math.max(...completionTimes) : 0;\n        // Attempt statistics\n        const attemptCounts = state.features.map((f) => f.attempts);\n        const totalAttempts = attemptCounts.reduce((sum, val) => sum + val, 0);\n        const avgAttempts = calculateAverage(attemptCounts);\n        const maxAttempts = attemptCounts.length > 0 ? Math.max(...attemptCounts) : 0;\n        // Success rate\n        const totalFinished = completed.length + failed.length;\n        const successRate = totalFinished > 0 ? completed.length / totalFinished : 0;\n        // Total elapsed time\n        const startTime = new Date(state.startTime);\n        const now = new Date();\n        const totalElapsedMs = now.getTime() - startTime.getTime();\n        sendJson(res, {\n            stats: {\n                time: {\n                    totalElapsedMs,\n                    totalElapsed: formatDuration(startTime, now),\n                    avgCompletionTimeMs,\n                    avgCompletionTime: avgCompletionTimeMs > 0 ? formatDurationMs(avgCompletionTimeMs) : null,\n                    minCompletionTimeMs,\n                    minCompletionTime: minCompletionTimeMs > 0 ? formatDurationMs(minCompletionTimeMs) : null,\n                    maxCompletionTimeMs,\n                    maxCompletionTime: maxCompletionTimeMs > 0 ? formatDurationMs(maxCompletionTimeMs) : null,\n                },\n                success: {\n                    rate: successRate,\n                    rateFormatted: formatPercent(successRate),\n                    completed: completed.length,\n                    failed: failed.length,\n                    total: state.features.length,\n                },\n                attempts: {\n                    total: totalAttempts,\n                    average: avgAttempts,\n                    max: maxAttempts,\n                },\n            },\n        });\n    }));\n    // ============================================================================\n    // GET /api/events - Server-Sent Events for real-time updates\n    // ============================================================================\n    app.get(\"/api/events\", (req, res) => {\n        // Set SSE headers\n        res.setHeader(\"Content-Type\", \"text/event-stream\");\n        res.setHeader(\"Cache-Control\", \"no-cache\");\n        res.setHeader(\"Connection\", \"keep-alive\");\n        res.setHeader(\"X-Accel-Buffering\", \"no\"); // Disable nginx buffering\n        res.flushHeaders();\n        // Create client\n        const clientId = generateClientId();\n        const client = { id: clientId, res };\n        sseClients.push(client);\n        console.log(`SSE client connected: ${clientId} (total: ${sseClients.length})`);\n        // Send initial connection event\n        res.write(`event: connected\\ndata: ${JSON.stringify({ clientId, timestamp: new Date().toISOString() })}\\n\\n`);\n        // Send current state immediately\n        const state = getState();\n        if (state) {\n            // Send full status\n            res.write(`event: status\\ndata: ${JSON.stringify({\n                status: state.status,\n                projectDir: state.projectDir,\n                taskDescription: state.taskDescription,\n                startTime: state.startTime,\n                lastUpdated: state.lastUpdated,\n            })}\\n\\n`);\n            // Send all features\n            for (const feature of state.features) {\n                res.write(`event: feature\\ndata: ${JSON.stringify({\n                    id: feature.id,\n                    description: feature.description,\n                    status: feature.status,\n                    attempts: feature.attempts,\n                    workerId: feature.workerId,\n                    startedAt: feature.startedAt,\n                    completedAt: feature.completedAt,\n                    lastError: feature.lastError,\n                    notes: feature.notes,\n                })}\\n\\n`);\n            }\n            // Initialize snapshot with current state\n            lastSnapshot = createSnapshot(state);\n        }\n        // Start SSE polling if not already running\n        startSSEPolling();\n        // Send heartbeat every 30 seconds to keep connection alive\n        const heartbeatInterval = setInterval(() => {\n            try {\n                res.write(`event: heartbeat\\ndata: ${JSON.stringify({ timestamp: new Date().toISOString() })}\\n\\n`);\n            }\n            catch (err) {\n                clearInterval(heartbeatInterval);\n            }\n        }, 30000);\n        // Handle client disconnect\n        req.on(\"close\", () => {\n            clearInterval(heartbeatInterval);\n            const index = sseClients.findIndex((c) => c.id === clientId);\n            if (index !== -1) {\n                sseClients.splice(index, 1);\n            }\n            console.log(`SSE client disconnected: ${clientId} (remaining: ${sseClients.length})`);\n        });\n    });\n    // ============================================================================\n    // GET /health - Health check endpoint\n    // ============================================================================\n    app.get(\"/health\", (req, res) => {\n        sendJson(res, {\n            status: \"ok\",\n            timestamp: new Date().toISOString(),\n        });\n    });\n    // ============================================================================\n    // Error handling middleware\n    // ============================================================================\n    app.use((err, req, res, next) => {\n        console.error(\"Dashboard server error:\", err);\n        res.status(500).json({\n            error: \"Internal server error\",\n            message: err.message,\n        });\n    });\n    // ============================================================================\n    // 404 handler\n    // ============================================================================\n    app.use((req, res) => {\n        res.status(404).json({\n            error: \"Not found\",\n            path: req.path,\n            availableEndpoints: [\n                \"GET /api/status\",\n                \"GET /api/features\",\n                \"GET /api/features?status=pending|in_progress|completed|failed\",\n                \"GET /api/workers\",\n                \"GET /api/workers/:featureId/output (SSE)\",\n                \"GET /api/logs\",\n                \"GET /api/logs?limit=N\",\n                \"GET /api/stats\",\n                \"GET /api/events (SSE)\",\n                \"GET /health\",\n            ],\n        });\n    });\n    // Start the server\n    return new Promise((resolve, reject) => {\n        const server = app.listen(port, host, () => {\n            console.log(`Dashboard server running at http://${host}:${port}`);\n            const dashboardServer = {\n                app,\n                server,\n                port,\n                close: async () => {\n                    // Clean up SSE resources\n                    if (ssePollingInterval) {\n                        clearInterval(ssePollingInterval);\n                        ssePollingInterval = null;\n                    }\n                    // Close all SSE client connections\n                    for (const client of sseClients) {\n                        try {\n                            client.res.end();\n                        }\n                        catch (err) {\n                            // Ignore errors during cleanup\n                        }\n                    }\n                    sseClients.length = 0;\n                    return new Promise((resolveClose, rejectClose) => {\n                        server.close((err) => {\n                            if (err) {\n                                rejectClose(err);\n                            }\n                            else {\n                                resolveClose();\n                            }\n                        });\n                    });\n                },\n            };\n            resolve(dashboardServer);\n        });\n        server.on(\"error\", (err) => {\n            reject(err);\n        });\n    });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateClientId_32": {
      "name": "generateClientId",
      "type": "function",
      "start_line": 32,
      "end_line": 32,
      "content_hash": "666735152d8542aca4b35b3e75e7b6a95455bb31",
      "content": "    const generateClientId = () => `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_broadcastSSE_34": {
      "name": "broadcastSSE",
      "type": "function",
      "start_line": 34,
      "end_line": 44,
      "content_hash": "f94634bb09ca8b92c104195ef57d59097148a077",
      "content": "    const broadcastSSE = (eventType, data) => {\n        const message = `event: ${eventType}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n        sseClients.forEach((client) => {\n            try {\n                client.res.write(message);\n            }\n            catch (err) {\n                // Client disconnected, will be cleaned up\n            }\n        });\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createSnapshot_46": {
      "name": "createSnapshot",
      "type": "function",
      "start_line": 46,
      "end_line": 69,
      "content_hash": "c604d77bee1f6ee6eee754cd4621e0fc0f226567",
      "content": "    const createSnapshot = (state) => {\n        if (!state) {\n            return {\n                status: null,\n                features: new Map(),\n                logCount: 0,\n                workerCount: 0,\n            };\n        }\n        const features = new Map();\n        let workerCount = 0;\n        for (const f of state.features) {\n            features.set(f.id, f.status);\n            if (f.status === \"in_progress\" && f.workerId) {\n                workerCount++;\n            }\n        }\n        return {\n            status: state.status,\n            features,\n            logCount: state.progressLog.length,\n            workerCount,\n        };\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getState_71": {
      "name": "getState",
      "type": "function",
      "start_line": 71,
      "end_line": 74,
      "content_hash": "4ec33ab7729ec0754d37a4439aa67a423905a094",
      "content": "    const getState = () => {\n        const sm = getStateManager();\n        return sm ? sm.load() : null;\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectAndBroadcastChanges_76": {
      "name": "detectAndBroadcastChanges",
      "type": "function",
      "start_line": 76,
      "end_line": 125,
      "content_hash": "15791682c6f36c96984b872f0c4e86709cfa361f",
      "content": "    const detectAndBroadcastChanges = (oldSnap, newSnap, state) => {\n        // Status change\n        if (!oldSnap || oldSnap.status !== newSnap.status) {\n            broadcastSSE(\"status\", {\n                status: newSnap.status,\n                projectDir: state?.projectDir,\n                taskDescription: state?.taskDescription,\n                startTime: state?.startTime,\n                lastUpdated: state?.lastUpdated,\n            });\n        }\n        // Feature changes\n        if (state) {\n            for (const feature of state.features) {\n                const oldStatus = oldSnap?.features.get(feature.id);\n                const newStatus = newSnap.features.get(feature.id);\n                if (oldStatus !== newStatus) {\n                    broadcastSSE(\"feature\", {\n                        id: feature.id,\n                        description: feature.description,\n                        status: feature.status,\n                        attempts: feature.attempts,\n                        workerId: feature.workerId,\n                        startedAt: feature.startedAt,\n                        completedAt: feature.completedAt,\n                        lastError: feature.lastError,\n                        notes: feature.notes,\n                    });\n                }\n            }\n        }\n        // New log entries\n        if (state && oldSnap && newSnap.logCount > oldSnap.logCount) {\n            const newLogs = state.progressLog.slice(oldSnap.logCount);\n            for (const log of newLogs) {\n                const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n                broadcastSSE(\"log\", {\n                    timestamp: match ? match[1] : new Date().toISOString(),\n                    message: match ? match[2] : log,\n                    raw: log,\n                });\n            }\n        }\n        // Worker count change\n        if (!oldSnap || oldSnap.workerCount !== newSnap.workerCount) {\n            broadcastSSE(\"worker\", {\n                activeCount: newSnap.workerCount,\n            });\n        }\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_startSSEPolling_127": {
      "name": "startSSEPolling",
      "type": "function",
      "start_line": 127,
      "end_line": 144,
      "content_hash": "fe02d50f3d4e2a1679be09f935ab695a243448bd",
      "content": "    const startSSEPolling = () => {\n        if (ssePollingInterval)\n            return;\n        ssePollingInterval = setInterval(() => {\n            if (sseClients.length === 0) {\n                // No clients, stop polling\n                if (ssePollingInterval) {\n                    clearInterval(ssePollingInterval);\n                    ssePollingInterval = null;\n                }\n                return;\n            }\n            const state = getState();\n            const newSnapshot = createSnapshot(state);\n            detectAndBroadcastChanges(lastSnapshot, newSnapshot, state);\n            lastSnapshot = newSnapshot;\n        }, 1000); // Check every 1 second\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_sendJson_165": {
      "name": "sendJson",
      "type": "function",
      "start_line": 165,
      "end_line": 168,
      "content_hash": "37a27c322d744469b4799f7b7ce2127863d57138",
      "content": "    const sendJson = (res, data) => {\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.json(data);\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_asyncHandler_170": {
      "name": "asyncHandler",
      "type": "function",
      "start_line": 170,
      "end_line": 174,
      "content_hash": "7359f9d072c4fea0a82f6f2fd25785f18d32190f",
      "content": "    const asyncHandler = (fn) => {\n        return (req, res, next) => {\n            Promise.resolve(fn(req, res)).catch(next);\n        };\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_sendOutput_337": {
      "name": "sendOutput",
      "type": "function",
      "start_line": 337,
      "end_line": 376,
      "content_hash": "8bf98b21eecbeab6fca5623f83e037842fec474b",
      "content": "        const sendOutput = async () => {\n            try {\n                // Get the worker output using tmux capture-pane (100 lines)\n                const { execFile } = await import(\"child_process\");\n                const { promisify } = await import(\"util\");\n                const execFileAsync = promisify(execFile);\n                try {\n                    const { stdout } = await execFileAsync(\"tmux\", [\n                        \"capture-pane\",\n                        \"-t\",\n                        feature.workerId,\n                        \"-p\",\n                        \"-S\",\n                        \"-100\", // Last 100 lines\n                    ]);\n                    res.write(`event: output\\ndata: ${JSON.stringify({\n                        featureId,\n                        output: stdout,\n                        timestamp: new Date().toISOString(),\n                    })}\\n\\n`);\n                }\n                catch (tmuxError) {\n                    // Session might have ended\n                    res.write(`event: ended\\ndata: ${JSON.stringify({\n                        featureId,\n                        message: \"Worker session ended or not found\",\n                        timestamp: new Date().toISOString(),\n                    })}\\n\\n`);\n                    clearInterval(outputInterval);\n                    res.end();\n                }\n            }\n            catch (error) {\n                res.write(`event: error\\ndata: ${JSON.stringify({\n                    featureId,\n                    error: error.message,\n                    timestamp: new Date().toISOString(),\n                })}\\n\\n`);\n            }\n        };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}