{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/reranker/fusion/mmr.rs",
  "file_hash": "650a23823e0ed8d1fb2ec8e4cb3e2d079db7db69",
  "updated_at": "2025-12-26T17:34:19.681220",
  "symbols": {
    "enum_DistanceMethod_26": {
      "name": "DistanceMethod",
      "type": "enum",
      "start_line": 26,
      "end_line": 35,
      "content_hash": "5ba65bc1eb21eafce3f90194708e320f31f26f26",
      "content": "pub enum DistanceMethod {\n    Cosine,\n    Euclidean,\n    DotProduct,\n}\n\n/// Maximal Marginal Relevance reranker.\n///\n/// Selects items that maximize the trade-off between relevance and diversity.\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MMRReranker_36": {
      "name": "MMRReranker",
      "type": "struct",
      "start_line": 36,
      "end_line": 48,
      "content_hash": "3b33dc0a07b78527b8424529f109515ae06c6685",
      "content": "pub struct MMRReranker {\n    /// Lambda parameter: controls relevance vs diversity trade-off\n    /// Higher values (closer to 1.0) favor relevance\n    /// Lower values (closer to 0.0) favor diversity\n    lambda: f64,\n\n    /// Distance metric for similarity calculation\n    distance_method: DistanceMethod,\n\n    /// Optional query vector for relevance calculation\n    query_vector: Option<Vec<f64>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_MMRReranker_49": {
      "name": "MMRReranker",
      "type": "impl",
      "start_line": 49,
      "end_line": 50,
      "content_hash": "511cdf97bb0814c10f71ad163f5a9d5dca724ef8",
      "content": "impl MMRReranker {\n    /// Create a new MMR reranker with default lambda=0.7 (favoring relevance).",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_51": {
      "name": "new",
      "type": "method",
      "start_line": 51,
      "end_line": 65,
      "content_hash": "028913a40a4361c7a42c2b2fcee2b38e33994a1d",
      "content": "    pub fn new(lambda: f64) -> RerankerResult<Self> {\n        if !(0.0..=1.0).contains(&lambda) {\n            return Err(RerankerError::InvalidParameter(\n                \"lambda must be between 0.0 and 1.0\".to_string(),\n            ));\n        }\n\n        Ok(Self {\n            lambda,\n            distance_method: DistanceMethod::Cosine,\n            query_vector: None,\n        })\n    }\n\n    /// Create an MMR reranker with a custom distance metric.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_distance_66": {
      "name": "with_distance",
      "type": "method",
      "start_line": 66,
      "end_line": 80,
      "content_hash": "ab7bebc317bbbed64aacdf258662ba71615cfcd3",
      "content": "    pub fn with_distance(lambda: f64, distance_method: DistanceMethod) -> RerankerResult<Self> {\n        if !(0.0..=1.0).contains(&lambda) {\n            return Err(RerankerError::InvalidParameter(\n                \"lambda must be between 0.0 and 1.0\".to_string(),\n            ));\n        }\n\n        Ok(Self {\n            lambda,\n            distance_method,\n            query_vector: None,\n        })\n    }\n\n    /// Set the query vector for relevance calculation.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_query_vector_81": {
      "name": "with_query_vector",
      "type": "method",
      "start_line": 81,
      "end_line": 97,
      "content_hash": "5f4558c2320e668743f7825d0e12899cbe36d7b4",
      "content": "    pub fn with_query_vector(mut self, query: Vec<f64>) -> Self {\n        self.query_vector = Some(query);\n        self\n    }\n\n    /// Extract vector data from a TraversalValue.\n    /// Note: This requires an arena to convert VectorPrecisionData to f64 slice\n    fn extract_vector_data<'a>(&self, item: &'a TraversalValue<'a>, _arena: &'a bumpalo::Bump) -> RerankerResult<&'a [f64]> {\n        match item {\n            TraversalValue::Vector(v) => Ok(v.data),\n            _ => Err(RerankerError::TextExtractionError(\n                \"Cannot extract vector from this item type (only Vector supported for MMR)\".to_string(),\n            )),\n        }\n    }\n\n    /// Calculate similarity between two items.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculate_similarity_98": {
      "name": "calculate_similarity",
      "type": "method",
      "start_line": 98,
      "end_line": 212,
      "content_hash": "8e913d8da0668b2c3451767e1d0cfaa2625fef60",
      "content": "    fn calculate_similarity(&self, item1: &[f64], item2: &[f64]) -> RerankerResult<f64> {\n        if item1.len() != item2.len() {\n            return Err(RerankerError::InvalidParameter(\n                \"Vector dimensions must match\".to_string(),\n            ));\n        }\n\n        let distance = match self.distance_method {\n            DistanceMethod::Cosine => {\n                // Calculate cosine similarity (1 - cosine distance)\n                let dot_product: f64 = item1.iter().zip(item2.iter()).map(|(a, b)| a * b).sum();\n                let norm1: f64 = item1.iter().map(|x| x * x).sum::<f64>().sqrt();\n                let norm2: f64 = item2.iter().map(|x| x * x).sum::<f64>().sqrt();\n\n                if norm1 == 0.0 || norm2 == 0.0 {\n                    0.0\n                } else {\n                    dot_product / (norm1 * norm2)\n                }\n            }\n            DistanceMethod::Euclidean => {\n                // Convert Euclidean distance to similarity (using negative exponential)\n                let dist_sq: f64 = item1\n                    .iter()\n                    .zip(item2.iter())\n                    .map(|(a, b)| (a - b).powi(2))\n                    .sum();\n                (-dist_sq.sqrt()).exp()\n            }\n            DistanceMethod::DotProduct => {\n                // Dot product as similarity\n                item1.iter().zip(item2.iter()).map(|(a, b)| a * b).sum()\n            }\n        };\n\n        Ok(distance)\n    }\n\n    /// Perform MMR selection on the given items.\n    fn mmr_select<'arena>(&self, items: Vec<TraversalValue<'arena>>) -> RerankerResult<Vec<TraversalValue<'arena>>> {\n        // Create a temporary arena for vector conversions\n        let arena = bumpalo::Bump::new();\n        if items.is_empty() {\n            return Err(RerankerError::EmptyInput);\n        }\n\n        let n = items.len();\n        let mut selected: Vec<TraversalValue<'arena>> = Vec::with_capacity(n);\n        let mut remaining: Vec<(TraversalValue<'arena>, f64)> = Vec::with_capacity(n);\n\n        // Extract original scores and prepare remaining items\n        for item in items {\n            let score = extract_score(&item)?;\n            remaining.push((item, score));\n        }\n\n        // Cache for similarity calculations\n        let mut similarity_cache: HashMap<(usize, usize), f64> = HashMap::new();\n\n        // Select first item (highest original score)\n        remaining.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n        let first = remaining.remove(0);\n        selected.push(first.0);\n\n        // Iteratively select remaining items\n        while !remaining.is_empty() {\n            let mut best_idx = 0;\n            let mut best_mmr_score = f64::NEG_INFINITY;\n\n            for (idx, (item, relevance_score)) in remaining.iter().enumerate() {\n                let item_vec = self.extract_vector_data(item, &arena)?;\n\n                // Calculate relevance term\n                let relevance = if let Some(query) = &self.query_vector {\n                    self.calculate_similarity(item_vec, query)?\n                } else {\n                    *relevance_score // Use original score as relevance\n                };\n\n                // Calculate diversity term (max similarity to selected items)\n                let mut max_similarity: f64 = 0.0;\n                for (sel_idx, selected_item) in selected.iter().enumerate() {\n                    // Check cache first\n                    let cache_key = (idx, sel_idx);\n                    let similarity = if let Some(&cached) = similarity_cache.get(&cache_key) {\n                        cached\n                    } else {\n                        let sel_vec = self.extract_vector_data(selected_item, &arena)?;\n                        let sim = self.calculate_similarity(item_vec, sel_vec)?;\n                        similarity_cache.insert(cache_key, sim);\n                        sim\n                    };\n\n                    max_similarity = max_similarity.max(similarity);\n                }\n\n                // Calculate MMR score\n                let mmr_score = self.lambda * relevance - (1.0 - self.lambda) * max_similarity;\n\n                if mmr_score > best_mmr_score {\n                    best_mmr_score = mmr_score;\n                    best_idx = idx;\n                }\n            }\n\n            // Add the best item to selected\n            let (mut best_item, _) = remaining.remove(best_idx);\n            update_score(&mut best_item, best_mmr_score)?;\n            selected.push(best_item);\n        }\n\n        Ok(selected)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Reranker_213": {
      "name": "Reranker",
      "type": "impl",
      "start_line": 213,
      "end_line": 221,
      "content_hash": "9db564a3aac9606bf74e5e58a272f0e0c07cda84",
      "content": "impl Reranker for MMRReranker {\n    fn rerank<'arena, I>(&self, items: I, _query: Option<&str>) -> RerankerResult<Vec<TraversalValue<'arena>>>\n    where\n        I: Iterator<Item = TraversalValue<'arena>>,\n    {\n        let items_vec: Vec<_> = items.collect();\n        self.mmr_select(items_vec)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_name_222": {
      "name": "name",
      "type": "method",
      "start_line": 222,
      "end_line": 238,
      "content_hash": "5fe3059372338a57a0ff664f5128a043b5daa039",
      "content": "    fn name(&self) -> &str {\n        \"MMR\"\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::helix_engine::vector_core::vector::HVector;\n    use bumpalo::Bump;\n\n    fn alloc_vector<'a>(arena: &'a Bump, data: &[f64]) -> HVector<'a> {\n        let slice = arena.alloc_slice_copy(data);\n        HVector::from_slice(\"test_vector\", 0, slice)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_creation_239": {
      "name": "test_mmr_creation",
      "type": "method",
      "start_line": 239,
      "end_line": 250,
      "content_hash": "7cf0c75f739a02d719854f89ce443c04d3422126",
      "content": "    fn test_mmr_creation() {\n        let mmr = MMRReranker::new(0.7).unwrap();\n        assert_eq!(mmr.lambda, 0.7);\n\n        let mmr_invalid = MMRReranker::new(1.5);\n        assert!(mmr_invalid.is_err());\n\n        let mmr_invalid = MMRReranker::new(-0.1);\n        assert!(mmr_invalid.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_diversity_251": {
      "name": "test_mmr_diversity",
      "type": "method",
      "start_line": 251,
      "end_line": 293,
      "content_hash": "dccbcc6a02a5115d5186aff2d640044f913fe947",
      "content": "    fn test_mmr_diversity() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap(); // Equal weight to relevance and diversity\n\n        // Create vectors: two very similar, one different\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0, 0.0]);\n                v.distance = Some(0.9);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.99, 0.01, 0.0]); // Very similar to first\n                v.distance = Some(0.85);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0, 0.0]); // Different\n                v.distance = Some(0.7);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        assert_eq!(results.len(), 3);\n\n        // First should be the highest scored (id=1)\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n\n        // Second should be the diverse one (id=3), not the similar one (id=2)\n        // because MMR should prefer diversity\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.id, 3);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_high_lambda_favors_relevance_294": {
      "name": "test_mmr_high_lambda_favors_relevance",
      "type": "method",
      "start_line": 294,
      "end_line": 330,
      "content_hash": "427f8ce06e5b7273b1ccb084aafed817f797c3d5",
      "content": "    fn test_mmr_high_lambda_favors_relevance() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.99).unwrap(); // Strongly favor relevance\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.99, 0.01]); // Similar but lower score\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]); // Different but much lower score\n                v.distance = Some(0.5);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // With high lambda, should maintain roughly original order by relevance\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.id, 2); // Similar item selected second despite similarity\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_empty_input_331": {
      "name": "test_mmr_empty_input",
      "type": "method",
      "start_line": 331,
      "end_line": 338,
      "content_hash": "7e625349a1efe16703003f259247d92dca74d2a1",
      "content": "    fn test_mmr_empty_input() {\n        let mmr = MMRReranker::new(0.7).unwrap();\n        let empty: Vec<TraversalValue> = vec![];\n        let result = mmr.rerank(empty.into_iter(), None);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_with_query_vector_339": {
      "name": "test_mmr_with_query_vector",
      "type": "method",
      "start_line": 339,
      "end_line": 373,
      "content_hash": "ef4bb1c9bfbf7e44309918bef0c70ff666d8143c",
      "content": "    fn test_mmr_with_query_vector() {\n        let arena = Bump::new();\n        let query = vec![1.0, 0.0, 0.0];\n        let mmr = MMRReranker::new(0.7)\n            .unwrap()\n            .with_query_vector(query);\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[0.9, 0.1, 0.0]);\n                v.distance = Some(0.9); // Higher original score\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.1, 0.9, 0.0]);\n                v.distance = Some(0.5); // Lower original score\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // MMR first selects highest scored item (id=1)\n        // With query vector [1,0,0], id=1 with vector [0.9,0.1,0] is also more similar\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n\n        // Verify we got all items\n        assert_eq!(results.len(), 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_low_lambda_favors_diversity_374": {
      "name": "test_mmr_low_lambda_favors_diversity",
      "type": "method",
      "start_line": 374,
      "end_line": 428,
      "content_hash": "710519b66836d8bc8d8a68edc2546c14a238be3b",
      "content": "    fn test_mmr_low_lambda_favors_diversity() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.1).unwrap(); // Strongly favor diversity\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.99, 0.01, 0.0]); // Very similar to first\n                v.distance = Some(0.95);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0, 0.0]); // Orthogonal\n                v.distance = Some(0.8);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 0.0, 1.0]); // Also orthogonal\n                v.distance = Some(0.75);\n                v.id = 4;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // First should be highest scored\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n\n        // Second should be diverse (id=3), not similar (id=2)\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.id, 3);\n        }\n\n        // Third should be another diverse one (id=4)\n        if let TraversalValue::Vector(v) = &results[2] {\n            assert_eq!(v.id, 4);\n        }\n\n        // Last should be the similar one (id=2)\n        if let TraversalValue::Vector(v) = &results[3] {\n            assert_eq!(v.id, 2);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_boundary_lambda_zero_429": {
      "name": "test_mmr_boundary_lambda_zero",
      "type": "method",
      "start_line": 429,
      "end_line": 460,
      "content_hash": "880bf90e605832739bf340f9b8bbd0c5f1dd7095",
      "content": "    fn test_mmr_boundary_lambda_zero() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.0).unwrap(); // Pure diversity\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.9, 0.1]);\n                v.distance = Some(0.5);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]);\n                v.distance = Some(0.3);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // With lambda=0, should maximize diversity regardless of original scores\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_boundary_lambda_one_461": {
      "name": "test_mmr_boundary_lambda_one",
      "type": "method",
      "start_line": 461,
      "end_line": 500,
      "content_hash": "fb4fa83972c458e51353f3150f099ebfd6633007",
      "content": "    fn test_mmr_boundary_lambda_one() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(1.0).unwrap(); // Pure relevance\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.99, 0.01]); // Very similar\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]); // Different\n                v.distance = Some(0.5);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // With lambda=1, should maintain relevance order\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.id, 2);\n        }\n        if let TraversalValue::Vector(v) = &results[2] {\n            assert_eq!(v.id, 3);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_with_euclidean_distance_501": {
      "name": "test_mmr_with_euclidean_distance",
      "type": "method",
      "start_line": 501,
      "end_line": 535,
      "content_hash": "281a4ec9485f24893dfc155cdf23e862180199cd",
      "content": "    fn test_mmr_with_euclidean_distance() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::with_distance(0.5, DistanceMethod::Euclidean).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[1.1, 0.0]); // Close in Euclidean space\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]); // Far\n                v.distance = Some(0.8);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle Euclidean distance correctly\n        assert_eq!(results.len(), 3);\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_with_dot_product_536": {
      "name": "test_mmr_with_dot_product",
      "type": "method",
      "start_line": 536,
      "end_line": 567,
      "content_hash": "c1155bfb116df58e3e8c196477f754a1673fef0c",
      "content": "    fn test_mmr_with_dot_product() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::with_distance(0.5, DistanceMethod::DotProduct).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.9, 0.0]);\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]);\n                v.distance = Some(0.8);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle dot product correctly\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_single_item_568": {
      "name": "test_mmr_single_item",
      "type": "method",
      "start_line": 568,
      "end_line": 588,
      "content_hash": "e9f034696b4fc4266c89d502efeb1b21651828e0",
      "content": "    fn test_mmr_single_item() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![{\n            let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n            v.distance = Some(1.0);\n            v.id = 1;\n            TraversalValue::Vector(v)\n        }];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Single item should be returned as-is\n        assert_eq!(results.len(), 1);\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_identical_vectors_589": {
      "name": "test_mmr_identical_vectors",
      "type": "method",
      "start_line": 589,
      "end_line": 609,
      "content_hash": "1e1c6291a80bc57a2cb1ff546ec88d402cf8ded5",
      "content": "    fn test_mmr_identical_vectors() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        // All identical vectors\n        let vectors: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle identical vectors without error\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_zero_vectors_610": {
      "name": "test_mmr_zero_vectors",
      "type": "method",
      "start_line": 610,
      "end_line": 635,
      "content_hash": "a9cb15c08ff7243df533fa504d1581ffd093c434",
      "content": "    fn test_mmr_zero_vectors() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 0.0]);\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle zero vectors gracefully\n        assert_eq!(results.len(), 2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_large_dataset_636": {
      "name": "test_mmr_large_dataset",
      "type": "method",
      "start_line": 636,
      "end_line": 662,
      "content_hash": "f4f95653f5ac1031acda53729543173d8a0a254d",
      "content": "    fn test_mmr_large_dataset() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        // Create 100 vectors\n        let vectors: Vec<TraversalValue> = (0..100)\n            .map(|i| {\n                let angle = (i as f64) * 0.1;\n                let mut v = alloc_vector(&arena, &[angle.cos(), angle.sin()]);\n                v.distance = Some(1.0 - i as f64 / 100.0);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle large datasets\n        assert_eq!(results.len(), 100);\n\n        // First should be highest scored\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 0);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_preserves_vector_data_663": {
      "name": "test_mmr_preserves_vector_data",
      "type": "method",
      "start_line": 663,
      "end_line": 693,
      "content_hash": "d7a2f47ed781d3cb4ae0e3792cfef9530f35eb19",
      "content": "    fn test_mmr_preserves_vector_data() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.5, 2.5, 3.5]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[4.5, 5.5, 6.5]);\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Verify vector data is preserved\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.data, &[1.5, 2.5, 3.5]);\n        }\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert_eq!(v.data, &[4.5, 5.5, 6.5]);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_score_updates_694": {
      "name": "test_mmr_score_updates",
      "type": "method",
      "start_line": 694,
      "end_line": 718,
      "content_hash": "6c8dd45c4cb88a02b427f914ab0218881c78507d",
      "content": "    fn test_mmr_score_updates() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.7).unwrap();\n\n        let vectors: Vec<TraversalValue> = (0..3)\n            .map(|i| {\n                let mut v = alloc_vector(&arena, &[1.0 * i as f64, 0.0]);\n                v.distance = Some(1.0 - i as f64 * 0.1);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Verify that scores have been updated by MMR\n        for result in &results {\n            if let TraversalValue::Vector(v) = result {\n                // MMR scores should be different from original scores\n                assert!(v.distance.is_some());\n            }\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_with_query_vector_relevance_719": {
      "name": "test_mmr_with_query_vector_relevance",
      "type": "method",
      "start_line": 719,
      "end_line": 758,
      "content_hash": "664019aa534ace2980da7a5a43fb2647a6e9c54a",
      "content": "    fn test_mmr_with_query_vector_relevance() {\n        let arena = Bump::new();\n        let query = vec![1.0, 0.0];\n        let mmr = MMRReranker::new(0.9)\n            .unwrap()\n            .with_query_vector(query);\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[0.5, 0.0]); // Less similar to query\n                v.distance = Some(1.0); // But highest original score\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.95, 0.0]); // More similar to query\n                v.distance = Some(0.5); // Lower original score\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]); // Orthogonal to query\n                v.distance = Some(0.7);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // With high lambda and query vector, should prefer items similar to query\n        // First selected should still be highest scored (id=1)\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_high_dimensional_vectors_759": {
      "name": "test_mmr_high_dimensional_vectors",
      "type": "method",
      "start_line": 759,
      "end_line": 780,
      "content_hash": "4f119ed81e2e1717bdf4f052a07696bc59c4cccd",
      "content": "    fn test_mmr_high_dimensional_vectors() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        let vectors: Vec<TraversalValue> = (0..5)\n            .map(|i| {\n                let data: Vec<f64> = (0..100).map(|j| if j == i { 1.0 } else { 0.0 }).collect();\n                let mut v = alloc_vector(&arena, &data);\n                v.distance = Some(1.0 - i as f64 * 0.1);\n                v.id = i as u128;\n                TraversalValue::Vector(v)\n            })\n            .collect();\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle high-dimensional vectors\n        assert_eq!(results.len(), 5);\n        // Vectors are orthogonal, so diversity should be maximized\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_name_781": {
      "name": "test_mmr_name",
      "type": "method",
      "start_line": 781,
      "end_line": 786,
      "content_hash": "6180058179d823fc969dc91f1ce9016ae30a2871",
      "content": "    fn test_mmr_name() {\n        let mmr = MMRReranker::new(0.5).unwrap();\n        assert_eq!(mmr.name(), \"MMR\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_mixed_positive_negative_scores_787": {
      "name": "test_mmr_mixed_positive_negative_scores",
      "type": "method",
      "start_line": 787,
      "end_line": 818,
      "content_hash": "e28570f0e2a1511d43643d5c9e002f76ed589f2f",
      "content": "    fn test_mmr_mixed_positive_negative_scores() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.5, 0.5]);\n                v.distance = Some(-0.5); // Negative score\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0]);\n                v.distance = Some(0.0); // Zero score\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // Should handle mixed positive/negative/zero scores\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mmr_cosine_similarity_properties_819": {
      "name": "test_mmr_cosine_similarity_properties",
      "type": "method",
      "start_line": 819,
      "end_line": 866,
      "content_hash": "4147f02993911496548151faae27bf4449284a4d",
      "content": "    fn test_mmr_cosine_similarity_properties() {\n        let arena = Bump::new();\n        let mmr = MMRReranker::new(0.5).unwrap();\n\n        // Create vectors with known cosine similarities\n        let vectors: Vec<TraversalValue> = vec![\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0, 0.0]);\n                v.distance = Some(1.0);\n                v.id = 1;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[1.0, 0.0, 0.0]); // Identical (cos=1.0)\n                v.distance = Some(0.9);\n                v.id = 2;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[0.0, 1.0, 0.0]); // Orthogonal (cos=0.0)\n                v.distance = Some(0.8);\n                v.id = 3;\n                TraversalValue::Vector(v)\n            },\n            {\n                let mut v = alloc_vector(&arena, &[-1.0, 0.0, 0.0]); // Opposite (cos=-1.0)\n                v.distance = Some(0.7);\n                v.id = 4;\n                TraversalValue::Vector(v)\n            },\n        ];\n\n        let results = mmr.rerank(vectors.into_iter(), None).unwrap();\n\n        // First should be highest scored (id=1)\n        if let TraversalValue::Vector(v) = &results[0] {\n            assert_eq!(v.id, 1);\n        }\n\n        // Second should prefer diverse over identical\n        // Either orthogonal (id=3) or opposite (id=4), not identical (id=2)\n        if let TraversalValue::Vector(v) = &results[1] {\n            assert!(v.id == 3 || v.id == 4);\n        }\n\n        assert_eq!(results.len(), 4);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}