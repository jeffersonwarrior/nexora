{
  "file_path": "/work/internal/config/load.go",
  "file_hash": "0fc69a7b216d000498ca9496c6ce0808f840c3b2",
  "updated_at": "2025-12-26T17:34:22.158336",
  "symbols": {
    "function_LoadReader_33": {
      "name": "LoadReader",
      "type": "function",
      "start_line": 33,
      "end_line": 47,
      "content_hash": "9465ebcaafeeee6729e8a4c4679ff3a73a929e97",
      "content": "func LoadReader(fd io.Reader) (*Config, error) {\n\tdata, err := io.ReadAll(fd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar config Config\n\terr = json.Unmarshal(data, &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &config, err\n}\n\n// Load loads the configuration from the default paths.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Load_48": {
      "name": "Load",
      "type": "function",
      "start_line": 48,
      "end_line": 131,
      "content_hash": "ef050a88f32f01b13f39452c153b78bde86f7872",
      "content": "func Load(workingDir, dataDir string, debug bool) (*Config, error) {\n\tconfigPaths := lookupConfigs(workingDir)\n\n\tcfg, err := loadFromConfigPaths(configPaths)\n\tif err != nil {\n\t\t// Check if this is a configuration format error and attempt repair\n\t\terrStr := err.Error()\n\t\tif strings.Contains(errStr, \"type mismatch\") || strings.Contains(errStr, \"field 'providers'\") || strings.Contains(errStr, \"expect\") {\n\t\t\t// Try to create a basic config and attempt repair\n\t\t\tbasicCfg := &Config{}\n\t\t\tbasicCfg.dataConfigDir = GlobalConfigData()\n\t\t\tbasicCfg.setDefaults(workingDir, dataDir)\n\n\t\t\t// Attempt to repair the config by initializing basic structure\n\t\t\t// and marking as needing setup\n\t\t\tbasicCfg.modelsNeedSetup = true\n\n\t\t\treturn basicCfg, nil\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"failed to load config from paths %v: %w\", configPaths, err)\n\t\t}\n\t}\n\n\tcfg.dataConfigDir = GlobalConfigData()\n\n\tcfg.setDefaults(workingDir, dataDir)\n\n\tif debug {\n\t\tcfg.Options.Debug = true\n\t}\n\n\t// Setup logs\n\tlog.Setup(\n\t\tfilepath.Join(cfg.Options.DataDirectory, \"logs\", fmt.Sprintf(\"%s.log\", appName)),\n\t\tcfg.Options.Debug,\n\t)\n\n\tif !isInsideWorktree() {\n\t\tconst depth = 2\n\t\tconst items = 100\n\t\tslog.Warn(\"No git repository detected in working directory, will limit file walk operations\", \"depth\", depth, \"items\", items)\n\t\tassignIfNil(&cfg.Tools.Ls.MaxDepth, depth)\n\t\tassignIfNil(&cfg.Tools.Ls.MaxItems, items)\n\t\tassignIfNil(&cfg.Options.TUI.Completions.MaxDepth, depth)\n\t\tassignIfNil(&cfg.Options.TUI.Completions.MaxItems, items)\n\t}\n\n\t// Load known providers, this loads the config from catwalk\n\tproviders, err := Providers(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcfg.knownProviders = providers\n\n\tenv := env.New()\n\t// Configure providers\n\tvalueResolver := NewShellVariableResolver(env)\n\tcfg.resolver = valueResolver\n\tif err := cfg.configureProviders(env, valueResolver, cfg.knownProviders); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to configure providers: %w\", err)\n\t}\n\n\tif !cfg.IsConfigured() {\n\t\tslog.Warn(\"No providers configured\")\n\t\treturn cfg, nil\n\t}\n\n\tif err := cfg.configureSelectedModels(cfg.knownProviders); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to configure selected models: %w\", err)\n\t}\n\n\t// Validate and fallback to recent models if current models are invalid\n\tmodelsValid, err := cfg.ValidateAndFallbackModels()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to validate models: %w\", err)\n\t}\n\n\t// Mark if models need TUI setup\n\tcfg.modelsNeedSetup = !modelsValid || !cfg.AreModelsConfigured()\n\n\tcfg.SetupAgents()\n\treturn cfg, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_PushPopNexoraEnv_132": {
      "name": "PushPopNexoraEnv",
      "type": "function",
      "start_line": 132,
      "end_line": 163,
      "content_hash": "4c106c46aecd56042af408220fc56c83b0a971fc",
      "content": "func PushPopNexoraEnv() func() {\n\tfound := []string{}\n\tfor _, ev := range os.Environ() {\n\t\tif strings.HasPrefix(ev, \"NEXORA_\") {\n\t\t\tpair := strings.SplitN(ev, \"=\", 2)\n\t\t\tif len(pair) != 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfound = append(found, strings.TrimPrefix(pair[0], \"NEXORA_\"))\n\t\t}\n\t}\n\tbackups := make(map[string]string)\n\tfor _, ev := range found {\n\t\tbackups[ev] = os.Getenv(ev)\n\t}\n\n\tfor _, ev := range found {\n\t\tos.Setenv(ev, os.Getenv(\"NEXORA_\"+ev))\n\t}\n\n\trestore := func() {\n\t\tfor k, v := range backups {\n\t\t\tos.Setenv(k, v)\n\t\t}\n\t}\n\treturn restore\n}\n\n// applyEnvironmentVariables applies environment variable overrides to provider configuration\n// Supported environment variables:\n// - NEXORA_MCP_HEADER_{KEY}=value for HTTP headers (e.g., NEXORA_MCP_HEADER_AUTHORIZATION='Bearer token')\n// - NEXORA_PROVIDER_BASE_URL=value for provider base URL override",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyEnvironmentVariables_164": {
      "name": "applyEnvironmentVariables",
      "type": "function",
      "start_line": 164,
      "end_line": 187,
      "content_hash": "0ff621c3e1c5094a0c2fc94963db4aa88acbaf02",
      "content": "func applyEnvironmentVariables(config *ProviderConfig) {\n\t// Apply environment variable headers\n\tfor _, env := range os.Environ() {\n\t\tif strings.HasPrefix(env, \"NEXORA_MCP_HEADER_\") || strings.HasPrefix(env, \"NEXORA_PROVIDER_HEADER_\") {\n\t\t\tparts := strings.SplitN(env, \"=\", 2)\n\t\t\tif len(parts) == 2 {\n\t\t\t\theaderName := strings.TrimPrefix(parts[0], \"NEXORA_MCP_HEADER_\")\n\t\t\t\theaderName = strings.TrimPrefix(headerName, \"NEXORA_PROVIDER_HEADER_\")\n\t\t\t\t// Convert to lowercase and replace underscores with hyphens for standard HTTP headers\n\t\t\t\theaderName = strings.ToLower(strings.ReplaceAll(headerName, \"_\", \"-\"))\n\t\t\t\tif config.ExtraHeaders == nil {\n\t\t\t\t\tconfig.ExtraHeaders = make(map[string]string)\n\t\t\t\t}\n\t\t\t\tconfig.ExtraHeaders[headerName] = parts[1]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply base URL override\n\tif baseURL := os.Getenv(\"NEXORA_PROVIDER_BASE_URL\"); baseURL != \"\" {\n\t\tconfig.BaseURL = baseURL\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_configureProviders_188": {
      "name": "configureProviders",
      "type": "method",
      "start_line": 188,
      "end_line": 391,
      "content_hash": "77a30ab9b5369f51f15383cbf35399346e471fb2",
      "content": "func (c *Config) configureProviders(env env.Env, resolver VariableResolver, knownProviders []catwalk.Provider) error {\n\t// Context for provider configuration - using background context for network operations\n\tctx := context.Background()\n\tknownProviderNames := make(map[string]bool)\n\trestore := PushPopNexoraEnv()\n\tdefer restore()\n\n\tfor _, p := range knownProviders {\n\t\tknownProviderNames[string(p.ID)] = true\n\t\tconfig, configExists := c.Providers.Get(string(p.ID))\n\t\t// if the user configured a known provider we need to allow it to override a couple of parameters\n\t\tif configExists {\n\t\t\tif config.BaseURL != \"\" {\n\t\t\t\tp.APIEndpoint = config.BaseURL\n\t\t\t}\n\t\t\tif config.APIKey != \"\" {\n\t\t\t\tp.APIKey = config.APIKey\n\t\t\t}\n\t\t\tif len(config.Models) > 0 {\n\t\t\t\tmodels := []catwalk.Model{}\n\t\t\t\tseen := make(map[string]bool)\n\n\t\t\t\tfor _, model := range config.Models {\n\t\t\t\t\tif seen[model.ID] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tseen[model.ID] = true\n\t\t\t\t\tif model.Name == \"\" {\n\t\t\t\t\t\tmodel.Name = model.ID\n\t\t\t\t\t}\n\t\t\t\t\tmodels = append(models, model)\n\t\t\t\t}\n\t\t\t\tfor _, model := range p.Models {\n\t\t\t\t\tif seen[model.ID] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tseen[model.ID] = true\n\t\t\t\t\tif model.Name == \"\" {\n\t\t\t\t\t\tmodel.Name = model.ID\n\t\t\t\t\t}\n\t\t\t\t\tmodels = append(models, model)\n\t\t\t\t}\n\n\t\t\t\tp.Models = models\n\t\t\t}\n\t\t}\n\n\t\theaders := map[string]string{}\n\t\tif len(p.DefaultHeaders) > 0 {\n\t\t\tmaps.Copy(headers, p.DefaultHeaders)\n\t\t}\n\t\tif len(config.ExtraHeaders) > 0 {\n\t\t\tmaps.Copy(headers, config.ExtraHeaders)\n\t\t}\n\t\tprepared := ProviderConfig{\n\t\t\tID:                 string(p.ID),\n\t\t\tName:               p.Name,\n\t\t\tBaseURL:            p.APIEndpoint,\n\t\t\tAPIKey:             p.APIKey,\n\t\t\tOAuthToken:         config.OAuthToken,\n\t\t\tType:               p.Type,\n\t\t\tDisable:            config.Disable,\n\t\t\tSystemPromptPrefix: config.SystemPromptPrefix,\n\t\t\tExtraHeaders:       headers,\n\t\t\tExtraBody:          config.ExtraBody,\n\t\t\tExtraParams:        make(map[string]string),\n\t\t\tModels:             p.Models,\n\t\t}\n\n\t\t// Apply environment variable overrides after base configuration\n\t\tapplyEnvironmentVariables(&prepared)\n\n\t\tif p.ID == catwalk.InferenceProviderAnthropic && config.OAuthToken != nil {\n\t\t\tif config.OAuthToken.IsExpired() {\n\t\t\t\tnewToken, err := claude.RefreshToken(ctx, config.OAuthToken.RefreshToken)\n\t\t\t\tif err == nil {\n\t\t\t\t\tslog.Info(\"Successfully refreshed Anthropic OAuth token\")\n\t\t\t\t\tconfig.OAuthToken = newToken\n\t\t\t\t\tprepared.OAuthToken = newToken\n\t\t\t\t\tif err := cmp.Or(\n\t\t\t\t\t\tc.SetConfigField(\"providers.anthropic.api_key\", newToken.AccessToken),\n\t\t\t\t\t\tc.SetConfigField(\"providers.anthropic.oauth\", newToken),\n\t\t\t\t\t); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tslog.Error(\"Failed to refresh Anthropic OAuth token\", \"error\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslog.Info(\"Using existing non-expired Anthropic OAuth token\")\n\t\t\t}\n\t\t\tprepared.SetupClaudeCode()\n\t\t}\n\n\t\tswitch p.ID {\n\t\t// Handle specific providers that require additional configuration\n\t\t// Removed nexora local provider case (Devstral-2 proxy hack)\n\t\tcase catwalk.InferenceProviderVertexAI:\n\t\t\tif !hasVertexCredentials(env) {\n\t\t\t\tif configExists {\n\t\t\t\t\tslog.Warn(\"Skipping Vertex AI provider due to missing credentials\")\n\t\t\t\t\tc.Providers.Del(string(p.ID))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprepared.ExtraParams[\"project\"] = env.Get(\"VERTEXAI_PROJECT\")\n\t\t\tprepared.ExtraParams[\"location\"] = env.Get(\"VERTEXAI_LOCATION\")\n\t\tcase catwalk.InferenceProviderAzure:\n\t\t\tendpoint, err := resolver.ResolveValue(p.APIEndpoint)\n\t\t\tif err != nil || endpoint == \"\" {\n\t\t\t\tif configExists {\n\t\t\t\t\tslog.Warn(\"Skipping Azure provider due to missing API endpoint\", \"provider\", p.ID, \"error\", err)\n\t\t\t\t\tc.Providers.Del(string(p.ID))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprepared.BaseURL = endpoint\n\t\t\tprepared.ExtraParams[\"apiVersion\"] = env.Get(\"AZURE_OPENAI_API_VERSION\")\n\t\tcase catwalk.InferenceProviderBedrock:\n\t\t\tif !hasAWSCredentials(env) {\n\t\t\t\tif configExists {\n\t\t\t\t\tslog.Warn(\"Skipping Bedrock provider due to missing AWS credentials\")\n\t\t\t\t\tc.Providers.Del(string(p.ID))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprepared.ExtraParams[\"region\"] = env.Get(\"AWS_REGION\")\n\t\t\tif prepared.ExtraParams[\"region\"] == \"\" {\n\t\t\t\tprepared.ExtraParams[\"region\"] = env.Get(\"AWS_DEFAULT_REGION\")\n\t\t\t}\n\t\t\tfor _, model := range p.Models {\n\t\t\t\tif !strings.HasPrefix(model.ID, \"anthropic.\") {\n\t\t\t\t\treturn fmt.Errorf(\"bedrock provider only supports anthropic models for now, found: %s\", model.ID)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\t// if the provider api or endpoint are missing we skip them\n\t\t\tv, err := resolver.ResolveValue(p.APIKey)\n\t\t\tif v == \"\" || err != nil {\n\t\t\t\tif configExists {\n\t\t\t\t\tslog.Warn(\"Skipping provider due to missing API key\", \"provider\", p.ID)\n\t\t\t\t\tc.Providers.Del(string(p.ID))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tc.Providers.Set(string(p.ID), prepared)\n\t}\n\n\t// validate the custom providers\n\tfor id, providerConfig := range c.Providers.Seq2() {\n\t\tif knownProviderNames[id] {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make sure the provider ID is set\n\t\tproviderConfig.ID = id\n\t\tif providerConfig.Name == \"\" {\n\t\t\tproviderConfig.Name = id // Use ID as name if not set\n\t\t}\n\t\t// default to OpenAI if not set\n\t\tif providerConfig.Type == \"\" {\n\t\t\tproviderConfig.Type = catwalk.TypeOpenAICompat\n\t\t}\n\t\tif !slices.Contains(catwalk.KnownProviderTypes(), providerConfig.Type) {\n\t\t\tslog.Warn(\"Skipping custom provider due to unsupported provider type\", \"provider\", id)\n\t\t\tc.Providers.Del(id)\n\t\t\tcontinue\n\t\t}\n\n\t\tif providerConfig.Disable {\n\t\t\tslog.Debug(\"Skipping custom provider due to disable flag\", \"provider\", id)\n\t\t\tc.Providers.Del(id)\n\t\t\tcontinue\n\t\t}\n\t\tif providerConfig.APIKey == \"\" {\n\t\t\tslog.Warn(\"Provider is missing API key, this might be OK for local providers\", \"provider\", id)\n\t\t}\n\t\tif providerConfig.BaseURL == \"\" {\n\t\t\tslog.Warn(\"Skipping custom provider due to missing API endpoint\", \"provider\", id)\n\t\t\tc.Providers.Del(id)\n\t\t\tcontinue\n\t\t}\n\t\tif len(providerConfig.Models) == 0 {\n\t\t\tslog.Warn(\"Skipping custom provider because the provider has no models\", \"provider\", id)\n\t\t\tc.Providers.Del(id)\n\t\t\tcontinue\n\t\t}\n\t\tapiKey, err := resolver.ResolveValue(providerConfig.APIKey)\n\t\tif apiKey == \"\" || err != nil {\n\t\t\tslog.Warn(\"Provider is missing API key, this might be OK for local providers\", \"provider\", id)\n\t\t}\n\t\tbaseURL, err := resolver.ResolveValue(providerConfig.BaseURL)\n\t\tif baseURL == \"\" || err != nil {\n\t\t\tslog.Warn(\"Skipping custom provider due to missing API endpoint\", \"provider\", id, \"error\", err)\n\t\t\tc.Providers.Del(id)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Providers.Set(id, providerConfig)\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setDefaults_392": {
      "name": "setDefaults",
      "type": "method",
      "start_line": 392,
      "end_line": 506,
      "content_hash": "56739ad425640170d98d904e3cc51d3e89b2ae1b",
      "content": "func (c *Config) setDefaults(workingDir, dataDir string) {\n\tc.workingDir = workingDir\n\tif c.Options == nil {\n\t\tc.Options = &Options{}\n\t}\n\tif c.Options.TUI == nil {\n\t\tc.Options.TUI = &TUIOptions{}\n\t}\n\tif c.Options.ContextPaths == nil {\n\t\tc.Options.ContextPaths = []string{}\n\t}\n\tif dataDir != \"\" {\n\t\tc.Options.DataDirectory = dataDir\n\t} else if c.Options.DataDirectory == \"\" {\n\t\tif path, ok := fsext.LookupClosest(workingDir, defaultDataDirectory); ok {\n\t\t\tc.Options.DataDirectory = path\n\t\t} else {\n\t\t\tc.Options.DataDirectory = filepath.Join(workingDir, defaultDataDirectory)\n\t\t}\n\t}\n\tif c.Providers == nil {\n\t\tc.Providers = csync.NewMap[string, ProviderConfig]()\n\t}\n\tif c.Models == nil {\n\t\tc.Models = make(map[SelectedModelType]SelectedModel)\n\t}\n\tif c.RecentModels == nil {\n\t\tc.RecentModels = make(map[SelectedModelType][]SelectedModel)\n\t}\n\tif c.MCP == nil {\n\t\tc.MCP = make(map[string]MCPConfig)\n\t}\n\tif c.LSP == nil {\n\t\tc.LSP = make(map[string]LSPConfig)\n\t}\n\n\t// Add z.ai MCP tools if not present (when Z.AI API key is available)\n\tif IsZAIAvailable() {\n\t\tzaiAPIKey := os.Getenv(\"ZAI_API_KEY\")\n\t\tif zaiAPIKey == \"\" {\n\t\t\tzaiAPIKey = os.Getenv(\"NEXORA_ZAI_API_KEY\")\n\t\t}\n\t\tzaiAuthHeader := fmt.Sprintf(\"Bearer %s\", zaiAPIKey)\n\n\t\tif _, exists := c.MCP[\"web-reader\"]; !exists {\n\t\t\tc.MCP[\"web-reader\"] = MCPConfig{\n\t\t\t\tURL:     \"https://api.z.ai/api/mcp/web_reader/mcp\",\n\t\t\t\tType:    MCPHttp,\n\t\t\t\tTimeout: 30,\n\t\t\t\tHeaders: map[string]string{\n\t\t\t\t\t\"Authorization\": zaiAuthHeader,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif _, exists := c.MCP[\"web-search-prime\"]; !exists {\n\t\t\tc.MCP[\"web-search-prime\"] = MCPConfig{\n\t\t\t\tURL:     \"https://api.z.ai/api/mcp/web_search_prime/mcp\",\n\t\t\t\tType:    MCPHttp,\n\t\t\t\tTimeout: 30,\n\t\t\t\tHeaders: map[string]string{\n\t\t\t\t\t\"Authorization\": zaiAuthHeader,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif _, exists := c.MCP[\"vision\"]; !exists {\n\t\t\tc.MCP[\"vision\"] = MCPConfig{\n\t\t\t\tType:    MCPStdio,\n\t\t\t\tCommand: \"npx\",\n\t\t\t\tArgs:    []string{\"-y\", \"@z_ai/mcp-server@latest\"},\n\t\t\t\tEnv: map[string]string{\n\t\t\t\t\t\"Z_AI_MODE\":    \"ZAI\",\n\t\t\t\t\t\"Z_AI_API_KEY\": zaiAPIKey,\n\t\t\t\t},\n\t\t\t\tTimeout: 30,\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply defaults to LSP configurations\n\tc.applyLSPDefaults()\n\n\t// Add the default context paths if they are not already present\n\tc.Options.ContextPaths = append(defaultContextPaths, c.Options.ContextPaths...)\n\tslices.Sort(c.Options.ContextPaths)\n\tc.Options.ContextPaths = slices.Compact(c.Options.ContextPaths)\n\n\tif str, ok := os.LookupEnv(\"NEXORA_DISABLE_PROVIDER_AUTO_UPDATE\"); ok {\n\t\tc.Options.DisableProviderAutoUpdate, _ = strconv.ParseBool(str)\n\t}\n\n\tif c.Options.Attribution == nil {\n\t\tc.Options.Attribution = &Attribution{\n\t\t\tTrailerStyle:  TrailerStyleAssistedBy,\n\t\t\tGeneratedWith: true,\n\t\t}\n\t} else if c.Options.Attribution.TrailerStyle == \"\" {\n\t\t// Migrate deprecated co_authored_by or apply default\n\t\tif c.Options.Attribution.CoAuthoredBy != nil {\n\t\t\tif *c.Options.Attribution.CoAuthoredBy {\n\t\t\t\tc.Options.Attribution.TrailerStyle = TrailerStyleCoAuthoredBy\n\t\t\t} else {\n\t\t\t\tc.Options.Attribution.TrailerStyle = TrailerStyleNone\n\t\t\t}\n\t\t} else {\n\t\t\tc.Options.Attribution.TrailerStyle = TrailerStyleAssistedBy\n\t\t}\n\t}\n\tif c.Options.InitializeAs == \"\" {\n\t\tc.Options.InitializeAs = defaultInitializeAs\n\t}\n}\n\n// applyLSPDefaults applies default values from powernap to LSP configurations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_applyLSPDefaults_507": {
      "name": "applyLSPDefaults",
      "type": "method",
      "start_line": 507,
      "end_line": 547,
      "content_hash": "2a5898e6894928fe1319c07b2a510a4ac1fc294f",
      "content": "func (c *Config) applyLSPDefaults() {\n\t// Get powernap's default configuration\n\tconfigManager := powernapConfig.NewManager()\n\tconfigManager.LoadDefaults()\n\n\t// Apply defaults to each LSP configuration\n\tfor name, cfg := range c.LSP {\n\t\t// Try to get defaults from powernap based on name or command name.\n\t\tbase, ok := configManager.GetServer(name)\n\t\tif !ok {\n\t\t\tbase, ok = configManager.GetServer(cfg.Command)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif cfg.Options == nil {\n\t\t\tcfg.Options = base.Settings\n\t\t}\n\t\tif cfg.InitOptions == nil {\n\t\t\tcfg.InitOptions = base.InitOptions\n\t\t}\n\t\tif len(cfg.FileTypes) == 0 {\n\t\t\tcfg.FileTypes = base.FileTypes\n\t\t}\n\t\tif len(cfg.RootMarkers) == 0 {\n\t\t\tcfg.RootMarkers = base.RootMarkers\n\t\t}\n\t\tif cfg.Command == \"\" {\n\t\t\tcfg.Command = base.Command\n\t\t}\n\t\tif len(cfg.Args) == 0 {\n\t\t\tcfg.Args = base.Args\n\t\t}\n\t\tif len(cfg.Env) == 0 {\n\t\t\tcfg.Env = base.Environment\n\t\t}\n\t\t// Update the config in the map\n\t\tc.LSP[name] = cfg\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_defaultModelSelection_548": {
      "name": "defaultModelSelection",
      "type": "method",
      "start_line": 548,
      "end_line": 616,
      "content_hash": "c61931421699fe0db8c096ddf8d25475d8d7c41d",
      "content": "func (c *Config) defaultModelSelection(knownProviders []catwalk.Provider) (largeModel SelectedModel, smallModel SelectedModel, err error) {\n\tif len(knownProviders) == 0 && c.Providers.Len() == 0 {\n\t\terr = fmt.Errorf(\"no providers configured, please configure at least one provider\")\n\t\treturn largeModel, smallModel, err\n\t}\n\n\t// Use the first provider enabled based on the known providers order\n\t// if no provider found that is known use the first provider configured\n\tfor _, p := range knownProviders {\n\t\tproviderConfig, ok := c.Providers.Get(string(p.ID))\n\t\tif !ok || providerConfig.Disable {\n\t\t\tcontinue\n\t\t}\n\t\tdefaultLargeModel := c.GetModel(string(p.ID), p.DefaultLargeModelID)\n\t\tif defaultLargeModel == nil {\n\t\t\terr = fmt.Errorf(\"default large model %s not found for provider %s\", p.DefaultLargeModelID, p.ID)\n\t\t\treturn largeModel, smallModel, err\n\t\t}\n\t\tlargeModel = SelectedModel{\n\t\t\tProvider:        string(p.ID),\n\t\t\tModel:           defaultLargeModel.ID,\n\t\t\tMaxTokens:       defaultLargeModel.DefaultMaxTokens,\n\t\t\tReasoningEffort: defaultLargeModel.DefaultReasoningEffort,\n\t\t}\n\n\t\tdefaultSmallModel := c.GetModel(string(p.ID), p.DefaultSmallModelID)\n\t\tif defaultSmallModel == nil {\n\t\t\terr = fmt.Errorf(\"default small model %s not found for provider %s\", p.DefaultSmallModelID, p.ID)\n\t\t\treturn largeModel, smallModel, err\n\t\t}\n\t\tsmallModel = SelectedModel{\n\t\t\tProvider:        string(p.ID),\n\t\t\tModel:           defaultSmallModel.ID,\n\t\t\tMaxTokens:       defaultSmallModel.DefaultMaxTokens,\n\t\t\tReasoningEffort: defaultSmallModel.DefaultReasoningEffort,\n\t\t}\n\t\treturn largeModel, smallModel, err\n\t}\n\n\tenabledProviders := c.EnabledProviders()\n\tslices.SortFunc(enabledProviders, func(a, b ProviderConfig) int {\n\t\treturn strings.Compare(a.ID, b.ID)\n\t})\n\n\tif len(enabledProviders) == 0 {\n\t\terr = fmt.Errorf(\"no providers configured, please configure at least one provider\")\n\t\treturn largeModel, smallModel, err\n\t}\n\n\tproviderConfig := enabledProviders[0]\n\tif len(providerConfig.Models) == 0 {\n\t\terr = fmt.Errorf(\"provider %s has no models configured\", providerConfig.ID)\n\t\treturn largeModel, smallModel, err\n\t}\n\tdefaultLargeModel := c.GetModel(providerConfig.ID, providerConfig.Models[0].ID)\n\tlargeModel = SelectedModel{\n\t\tProvider:  providerConfig.ID,\n\t\tModel:     defaultLargeModel.ID,\n\t\tMaxTokens: defaultLargeModel.DefaultMaxTokens,\n\t}\n\tdefaultSmallModel := c.GetModel(providerConfig.ID, providerConfig.Models[0].ID)\n\tsmallModel = SelectedModel{\n\t\tProvider:  providerConfig.ID,\n\t\tModel:     defaultSmallModel.ID,\n\t\tMaxTokens: defaultSmallModel.DefaultMaxTokens,\n\t}\n\treturn largeModel, smallModel, err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_configureSelectedModels_617": {
      "name": "configureSelectedModels",
      "type": "method",
      "start_line": 617,
      "end_line": 718,
      "content_hash": "d7d2a38a5712a701126a47006e44fdb3d26fddad",
      "content": "func (c *Config) configureSelectedModels(knownProviders []catwalk.Provider) error {\n\tdefaultLarge, defaultSmall, err := c.defaultModelSelection(knownProviders)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to select default models: %w\", err)\n\t}\n\tlarge, small := defaultLarge, defaultSmall\n\n\tlargeModelSelected, largeModelConfigured := c.Models[SelectedModelTypeLarge]\n\tif largeModelConfigured {\n\t\tif largeModelSelected.Model != \"\" {\n\t\t\tlarge.Model = largeModelSelected.Model\n\t\t}\n\t\tif largeModelSelected.Provider != \"\" {\n\t\t\tlarge.Provider = largeModelSelected.Provider\n\t\t}\n\t\tmodel := c.GetModel(large.Provider, large.Model)\n\t\tif model == nil {\n\t\t\tlarge = defaultLarge\n\t\t\t// Override the model type to large without recording as recent.\n\t\t\t// This is initialization fallback, not a user selection.\n\t\t\tc.Models[SelectedModelTypeLarge] = large\n\t\t\tif err := c.SetConfigField(fmt.Sprintf(\"models.%s\", SelectedModelTypeLarge), large); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to update preferred large model: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif largeModelSelected.MaxTokens > 0 {\n\t\t\t\tlarge.MaxTokens = largeModelSelected.MaxTokens\n\t\t\t} else {\n\t\t\t\tlarge.MaxTokens = model.DefaultMaxTokens\n\t\t\t}\n\t\t\tif largeModelSelected.ReasoningEffort != \"\" {\n\t\t\t\tlarge.ReasoningEffort = largeModelSelected.ReasoningEffort\n\t\t\t}\n\t\t\tlarge.Think = largeModelSelected.Think\n\t\t\tif largeModelSelected.Temperature != nil {\n\t\t\t\tlarge.Temperature = largeModelSelected.Temperature\n\t\t\t}\n\t\t\tif largeModelSelected.TopP != nil {\n\t\t\t\tlarge.TopP = largeModelSelected.TopP\n\t\t\t}\n\t\t\tif largeModelSelected.TopK != nil {\n\t\t\t\tlarge.TopK = largeModelSelected.TopK\n\t\t\t}\n\t\t\tif largeModelSelected.FrequencyPenalty != nil {\n\t\t\t\tlarge.FrequencyPenalty = largeModelSelected.FrequencyPenalty\n\t\t\t}\n\t\t\tif largeModelSelected.PresencePenalty != nil {\n\t\t\t\tlarge.PresencePenalty = largeModelSelected.PresencePenalty\n\t\t\t}\n\t\t}\n\t}\n\tsmallModelSelected, smallModelConfigured := c.Models[SelectedModelTypeSmall]\n\tif smallModelConfigured {\n\t\tif smallModelSelected.Model != \"\" {\n\t\t\tsmall.Model = smallModelSelected.Model\n\t\t}\n\t\tif smallModelSelected.Provider != \"\" {\n\t\t\tsmall.Provider = smallModelSelected.Provider\n\t\t}\n\n\t\tmodel := c.GetModel(small.Provider, small.Model)\n\t\tif model == nil {\n\t\t\tsmall = defaultSmall\n\t\t\t// Override the model type to small without recording as recent.\n\t\t\t// This is initialization fallback, not a user selection.\n\t\t\tc.Models[SelectedModelTypeSmall] = small\n\t\t\tif err := c.SetConfigField(fmt.Sprintf(\"models.%s\", SelectedModelTypeSmall), small); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to update preferred small model: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif smallModelSelected.MaxTokens > 0 {\n\t\t\t\tsmall.MaxTokens = smallModelSelected.MaxTokens\n\t\t\t} else {\n\t\t\t\tsmall.MaxTokens = model.DefaultMaxTokens\n\t\t\t}\n\t\t\tif smallModelSelected.ReasoningEffort != \"\" {\n\t\t\t\tsmall.ReasoningEffort = smallModelSelected.ReasoningEffort\n\t\t\t}\n\t\t\tif smallModelSelected.Temperature != nil {\n\t\t\t\tsmall.Temperature = smallModelSelected.Temperature\n\t\t\t}\n\t\t\tif smallModelSelected.TopP != nil {\n\t\t\t\tsmall.TopP = smallModelSelected.TopP\n\t\t\t}\n\t\t\tif smallModelSelected.TopK != nil {\n\t\t\t\tsmall.TopK = smallModelSelected.TopK\n\t\t\t}\n\t\t\tif smallModelSelected.FrequencyPenalty != nil {\n\t\t\t\tsmall.FrequencyPenalty = smallModelSelected.FrequencyPenalty\n\t\t\t}\n\t\t\tif smallModelSelected.PresencePenalty != nil {\n\t\t\t\tsmall.PresencePenalty = smallModelSelected.PresencePenalty\n\t\t\t}\n\t\t\tsmall.Think = smallModelSelected.Think\n\t\t}\n\t}\n\tc.Models[SelectedModelTypeLarge] = large\n\tc.Models[SelectedModelTypeSmall] = small\n\treturn nil\n}\n\n// lookupConfigs searches config files recursively from CWD up to FS root",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_lookupConfigs_719": {
      "name": "lookupConfigs",
      "type": "function",
      "start_line": 719,
      "end_line": 728,
      "content_hash": "fc78684514043e20f02085b273b3b954fd91eea2",
      "content": "func lookupConfigs(cwd string) []string {\n\t// Only use global config paths - no more per-project config\n\tconfigPaths := []string{\n\t\tGlobalConfig(),\n\t\tGlobalConfigData(),\n\t}\n\n\treturn configPaths\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loadFromConfigPaths_729": {
      "name": "loadFromConfigPaths",
      "type": "function",
      "start_line": 729,
      "end_line": 747,
      "content_hash": "5fad85f9026d91c8171e047a438c35ed5fe11806",
      "content": "func loadFromConfigPaths(configPaths []string) (*Config, error) {\n\tvar configs []io.Reader\n\n\tfor _, path := range configPaths {\n\t\tfd, err := os.Open(path)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"failed to open config file %s: %w\", path, err)\n\t\t}\n\t\tdefer fd.Close()\n\n\t\tconfigs = append(configs, fd)\n\t}\n\n\treturn loadFromReaders(configs)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loadFromReaders_748": {
      "name": "loadFromReaders",
      "type": "function",
      "start_line": 748,
      "end_line": 760,
      "content_hash": "359b74707f8c9b0c589acb7c26b52e25a7ebbacf",
      "content": "func loadFromReaders(readers []io.Reader) (*Config, error) {\n\tif len(readers) == 0 {\n\t\treturn &Config{}, nil\n\t}\n\n\tmerged, err := Merge(readers)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to merge configuration readers: %w\", err)\n\t}\n\n\treturn LoadReader(merged)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_hasVertexCredentials_761": {
      "name": "hasVertexCredentials",
      "type": "function",
      "start_line": 761,
      "end_line": 766,
      "content_hash": "f7560d7b31fa1c63f70155e79dfe8bdb5ca5b7c1",
      "content": "func hasVertexCredentials(env env.Env) bool {\n\thasProject := env.Get(\"VERTEXAI_PROJECT\") != \"\"\n\thasLocation := env.Get(\"VERTEXAI_LOCATION\") != \"\"\n\treturn hasProject && hasLocation\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_hasAWSCredentials_767": {
      "name": "hasAWSCredentials",
      "type": "function",
      "start_line": 767,
      "end_line": 796,
      "content_hash": "73dd3958b03bdb011bb4679bcd7c325721550d1a",
      "content": "func hasAWSCredentials(env env.Env) bool {\n\tif env.Get(\"AWS_BEARER_TOKEN_BEDROCK\") != \"\" {\n\t\treturn true\n\t}\n\n\tif env.Get(\"AWS_ACCESS_KEY_ID\") != \"\" && env.Get(\"AWS_SECRET_ACCESS_KEY\") != \"\" {\n\t\treturn true\n\t}\n\n\tif env.Get(\"AWS_PROFILE\") != \"\" || env.Get(\"AWS_DEFAULT_PROFILE\") != \"\" {\n\t\treturn true\n\t}\n\n\tif env.Get(\"AWS_REGION\") != \"\" || env.Get(\"AWS_DEFAULT_REGION\") != \"\" {\n\t\treturn true\n\t}\n\n\tif env.Get(\"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\") != \"\" ||\n\t\tenv.Get(\"AWS_CONTAINER_CREDENTIALS_FULL_URI\") != \"\" {\n\t\treturn true\n\t}\n\n\tif _, err := os.Stat(filepath.Join(home.Dir(), \".aws/credentials\")); err == nil {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// GlobalConfig returns the global configuration file path for the application.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GlobalConfig_797": {
      "name": "GlobalConfig",
      "type": "function",
      "start_line": 797,
      "end_line": 807,
      "content_hash": "9bfdcfc4375973c7588ae2e8d0b7cde872a64f72",
      "content": "func GlobalConfig() string {\n\txdgConfigHome := os.Getenv(\"XDG_CONFIG_HOME\")\n\tif xdgConfigHome != \"\" {\n\t\treturn filepath.Join(xdgConfigHome, appName, fmt.Sprintf(\"%s.json\", appName))\n\t}\n\n\treturn filepath.Join(home.Dir(), \".config\", appName, fmt.Sprintf(\"%s.json\", appName))\n}\n\n// GlobalConfigData returns the path to the main data directory for the application.\n// this config is used when the app overrides configurations instead of updating the global config.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GlobalConfigData_808": {
      "name": "GlobalConfigData",
      "type": "function",
      "start_line": 808,
      "end_line": 833,
      "content_hash": "f4b6e8a73d0583ba594f59ccaceabbba33167075",
      "content": "func GlobalConfigData() string {\n\txdgDataHome := os.Getenv(\"XDG_DATA_HOME\")\n\tif xdgDataHome != \"\" {\n\t\treturn filepath.Join(xdgDataHome, appName, fmt.Sprintf(\"%s.json\", appName))\n\t}\n\n\t// return the path to the main data directory\n\t// for windows, it should be in `%LOCALAPPDATA%/nexora/`\n\t// for linux and macOS, it should be in `$HOME/.local/share/nexora/`\n\tif runtime.GOOS == \"windows\" {\n\t\tlocalAppData := os.Getenv(\"LOCALAPPDATA\")\n\t\tif localAppData == \"\" {\n\t\t\tlocalAppData = filepath.Join(os.Getenv(\"USERPROFILE\"), \"AppData\", \"Local\")\n\t\t}\n\t\treturn filepath.Join(localAppData, appName, fmt.Sprintf(\"%s.json\", appName))\n\t}\n\n\treturn filepath.Join(home.Dir(), \".local\", \"share\", appName, fmt.Sprintf(\"%s.json\", appName))\n}\n\nfunc assignIfNil[T any](ptr **T, val T) {\n\tif *ptr == nil {\n\t\t*ptr = &val\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isInsideWorktree_834": {
      "name": "isInsideWorktree",
      "type": "function",
      "start_line": 834,
      "end_line": 841,
      "content_hash": "f773bc56e990192c50455972a85c7d1264adf003",
      "content": "func isInsideWorktree() bool {\n\tbts, err := exec.CommandContext(\n\t\tcontext.Background(),\n\t\t\"git\", \"rev-parse\",\n\t\t\"--is-inside-work-tree\",\n\t).CombinedOutput()\n\treturn err == nil && strings.TrimSpace(string(bts)) == \"true\"\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}