{
  "file_path": "/work/internal/agent/tools/ls_test.go",
  "file_hash": "fd48951c3a6b6054b59bf40322568a0f07138893",
  "updated_at": "2025-12-26T17:34:24.030247",
  "symbols": {
    "function_TestLsTool_16": {
      "name": "TestLsTool",
      "type": "function",
      "start_line": 16,
      "end_line": 25,
      "content_hash": "e178e075c0d6df1fdd9042b1f6507e4914d22db8",
      "content": "func TestLsTool(t *testing.T) {\n\ttmpDir := t.TempDir()\n\tmockPerms := &mockPermissionService{}\n\tlsConfig := config.ToolLs{}\n\n\ttool := NewLsTool(mockPerms, tmpDir, lsConfig)\n\tassert.NotNil(t, tool)\n\tassert.Equal(t, LSToolName, tool.Info().Name)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestLsTool_ListCurrentDirectory_26": {
      "name": "TestLsTool_ListCurrentDirectory",
      "type": "function",
      "start_line": 26,
      "end_line": 58,
      "content_hash": "f97fa9e22707a5bf95754f9a109b55fe8d310d47",
      "content": "func TestLsTool_ListCurrentDirectory(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\t// Create test structure\n\tos.WriteFile(filepath.Join(tmpDir, \"file1.txt\"), []byte(\"test\"), 0644)\n\tos.WriteFile(filepath.Join(tmpDir, \"file2.txt\"), []byte(\"test\"), 0644)\n\tos.Mkdir(filepath.Join(tmpDir, \"subdir\"), 0755)\n\tos.WriteFile(filepath.Join(tmpDir, \"subdir\", \"nested.txt\"), []byte(\"test\"), 0644)\n\n\tmockPerms := &mockPermissionService{}\n\tlsConfig := config.ToolLs{}\n\ttool := NewLsTool(mockPerms, tmpDir, lsConfig)\n\n\tctx := context.Background()\n\tparams := LSParams{}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test\",\n\t\tName:  LSToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\tresp, err := tool.Run(ctx, toolCall)\n\n\trequire.NoError(t, err)\n\tassert.False(t, resp.IsError)\n\n\toutput := resp.Content\n\tassert.Contains(t, output, \"file1.txt\")\n\tassert.Contains(t, output, \"file2.txt\")\n\tassert.Contains(t, output, \"subdir/\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestLsTool_NonExistentDirectory_59": {
      "name": "TestLsTool_NonExistentDirectory",
      "type": "function",
      "start_line": 59,
      "end_line": 82,
      "content_hash": "f177fe6093df36e826d55650c57e7f6a469a65e2",
      "content": "func TestLsTool_NonExistentDirectory(t *testing.T) {\n\ttmpDir := t.TempDir()\n\tmockPerms := &mockPermissionService{}\n\tlsConfig := config.ToolLs{}\n\ttool := NewLsTool(mockPerms, tmpDir, lsConfig)\n\n\tctx := context.Background()\n\tparams := LSParams{\n\t\tPath: filepath.Join(tmpDir, \"nonexistent\"),\n\t}\n\tparamsJSON, _ := json.Marshal(params)\n\ttoolCall := fantasy.ToolCall{\n\t\tID:    \"test\",\n\t\tName:  LSToolName,\n\t\tInput: string(paramsJSON),\n\t}\n\n\t_, err := tool.Run(ctx, toolCall)\n\n\t// The tool returns an error for non-existent directories\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"does not exist\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestListDirectoryTree_83": {
      "name": "TestListDirectoryTree",
      "type": "function",
      "start_line": 83,
      "end_line": 97,
      "content_hash": "c256622075f4921d4c232971dd3e5c53fed480bf",
      "content": "func TestListDirectoryTree(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\t// Create test structure\n\tos.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"test\"), 0644)\n\tos.Mkdir(filepath.Join(tmpDir, \"dir\"), 0755)\n\tos.WriteFile(filepath.Join(tmpDir, \"dir\", \"nested.txt\"), []byte(\"test\"), 0644)\n\n\toutput, metadata, err := ListDirectoryTree(tmpDir, LSParams{}, config.ToolLs{})\n\n\trequire.NoError(t, err)\n\tassert.Greater(t, metadata.NumberOfFiles, 0)\n\tassert.Contains(t, output, \"file.txt\")\n\tassert.Contains(t, output, \"dir/\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}