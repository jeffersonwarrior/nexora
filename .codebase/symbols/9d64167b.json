{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/update.rs",
  "file_hash": "7814fc19a4b31663c3327341223f0875f8f49c32",
  "updated_at": "2025-12-26T17:34:20.459761",
  "symbols": {
    "struct_GitHubRelease_15": {
      "name": "GitHubRelease",
      "type": "struct",
      "start_line": 15,
      "end_line": 21,
      "content_hash": "a9e5f766b29de4f555ec6270cb650f9583a0047c",
      "content": "struct GitHubRelease {\n    tag_name: String,\n    name: String,\n    html_url: String,\n}\n\n#[derive(Serialize, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_UpdateCache_22": {
      "name": "UpdateCache",
      "type": "struct",
      "start_line": 22,
      "end_line": 26,
      "content_hash": "6ba34dc06bcee7926e0ef41efd54d22776b4b2f4",
      "content": "struct UpdateCache {\n    last_check: u64,\n    latest_version: Option<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_update_cache_path_27": {
      "name": "get_update_cache_path",
      "type": "function",
      "start_line": 27,
      "end_line": 61,
      "content_hash": "7134eabc29ff467322cb9a345d7c73c887ebaaa9",
      "content": "fn get_update_cache_path() -> Result<PathBuf> {\n    let home = home_dir().ok_or_else(|| eyre!(\"Cannot find home directory\"))?;\n    let helix_dir = home.join(\".helix\");\n\n    // Ensure .helix directory exists\n    fs::create_dir_all(&helix_dir)?;\n\n    Ok(helix_dir.join(\"update_cache.toml\"))\n}\n\nasync fn fetch_latest_version() -> Result<String> {\n    let client = Client::builder()\n        .user_agent(format!(\"helix-cli/{CURRENT_VERSION}\"))\n        .timeout(Duration::from_secs(10))\n        .build()?;\n\n    let response = client.get(GITHUB_API_URL).send().await?;\n\n    if !response.status().is_success() {\n        return Err(eyre!(\n            \"Failed to fetch latest version: HTTP {}\",\n            response.status()\n        ));\n    }\n\n    let release: GitHubRelease = response.json().await?;\n\n    // Remove 'v' prefix if present\n    let version = release\n        .tag_name\n        .strip_prefix('v')\n        .unwrap_or(&release.tag_name);\n    Ok(version.to_string())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_should_check_for_updates_62": {
      "name": "should_check_for_updates",
      "type": "function",
      "start_line": 62,
      "end_line": 77,
      "content_hash": "eada14506ac301485b3a3fed066125b1bf844b26",
      "content": "fn should_check_for_updates() -> Result<bool> {\n    let cache_path = get_update_cache_path()?;\n\n    if !cache_path.exists() {\n        return Ok(true);\n    }\n\n    let cache_content = fs::read_to_string(&cache_path)?;\n    let update_cache: UpdateCache = toml::from_str(&cache_content)?;\n\n    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();\n    let time_since_check = now.saturating_sub(update_cache.last_check);\n\n    Ok(time_since_check >= UPDATE_CHECK_INTERVAL)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_save_update_check_78": {
      "name": "save_update_check",
      "type": "function",
      "start_line": 78,
      "end_line": 92,
      "content_hash": "584337abef4ee19b1f537d037b69eaa83d12bed7",
      "content": "fn save_update_check(latest_version: Option<String>) -> Result<()> {\n    let cache_path = get_update_cache_path()?;\n    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();\n\n    let update_cache = UpdateCache {\n        last_check: now,\n        latest_version,\n    };\n\n    let cache_content = toml::to_string_pretty(&update_cache)?;\n    fs::write(&cache_path, cache_content)?;\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_is_newer_version_93": {
      "name": "is_newer_version",
      "type": "function",
      "start_line": 93,
      "end_line": 153,
      "content_hash": "cd6c375f806d7d6a0ead6e0daf5bf8e325ec082b",
      "content": "fn is_newer_version(current: &str, latest: &str) -> bool {\n    // Simple version comparison - assumes semantic versioning but is robust against missing zeros\n    let current_parts = current\n        .split('.')\n        .filter_map(|s| s.parse().ok())\n        .chain([0].into_iter().cycle())\n        .take(3);\n    let latest_parts = latest\n        .split('.')\n        .filter_map(|s| s.parse().ok())\n        .chain([0].into_iter().cycle())\n        .take(3);\n\n    for (current_part, latest_part) in current_parts.zip(latest_parts) {\n        match latest_part.cmp(&current_part) {\n            std::cmp::Ordering::Greater => return true,\n            std::cmp::Ordering::Less => return false,\n            std::cmp::Ordering::Equal => continue,\n        }\n    }\n\n    false\n}\n\npub async fn check_for_updates() -> Result<()> {\n    // Skip update check if not needed (to avoid slowing down every command)\n    if !should_check_for_updates().unwrap_or(true) {\n        // Still check cache for any previously found updates\n        let cache_path = get_update_cache_path()?;\n        let cache_content = fs::read_to_string(&cache_path)?;\n        let update_cache: UpdateCache = toml::from_str(&cache_content)?;\n\n        let Some(latest) = update_cache.latest_version else {\n            return Ok(());\n        };\n\n        if is_newer_version(CURRENT_VERSION, &latest) {\n            print_update_available(&latest);\n        }\n        return Ok(());\n    }\n\n    // Perform actual update check\n    match fetch_latest_version().await {\n        Ok(latest_version) => {\n            if is_newer_version(CURRENT_VERSION, &latest_version) {\n                print_update_available(&latest_version);\n                save_update_check(Some(latest_version))?;\n            } else {\n                save_update_check(Some(latest_version))?;\n            }\n        }\n        Err(_) => {\n            // Silently fail - don't block CLI usage due to network issues\n            save_update_check(None)?;\n        }\n    }\n\n    Ok(())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_print_update_available_154": {
      "name": "print_update_available",
      "type": "function",
      "start_line": 154,
      "end_line": 158,
      "content_hash": "a121847229ea18b36189d52501c7a660c068b40b",
      "content": "fn print_update_available(latest_version: &str) {\n    eprintln!(\"[UPDATE] New version available: v{CURRENT_VERSION} -> v{latest_version}\",);\n    eprintln!(\"         Run 'helix update' to upgrade\");\n    eprintln!();\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}