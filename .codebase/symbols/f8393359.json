{
  "file_path": "/work/context-engine/vscode-extension/context-engine-uploader/mcp_config.js",
  "file_hash": "4cad72fa9f9189f19136cc8ebfa3cc74173c7067",
  "updated_at": "2025-12-26T17:34:23.138894",
  "symbols": {
    "function_getDefaultWindsurfMcpPath_5": {
      "name": "getDefaultWindsurfMcpPath",
      "type": "function",
      "start_line": 5,
      "end_line": 10,
      "content_hash": "c9097bb92b1f8e3cd03fbf83b67bfa9e32c78445",
      "content": "function getDefaultWindsurfMcpPath() {\n  const home = (process.platform === 'win32')\n    ? (process.env.USERPROFILE || os.homedir())\n    : os.homedir();\n  return path.join(home, '.codeium', 'windsurf', 'mcp_config.json');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getDefaultAugmentMcpPath_12": {
      "name": "getDefaultAugmentMcpPath",
      "type": "function",
      "start_line": 12,
      "end_line": 14,
      "content_hash": "f1631748f622b691259bc372810f21c66d5b62f9",
      "content": "function getDefaultAugmentMcpPath() {\n  return path.join(os.homedir(), '.augment', 'settings.json');\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createMcpConfigManager_16": {
      "name": "createMcpConfigManager",
      "type": "function",
      "start_line": 16,
      "end_line": 766,
      "content_hash": "8145e3343a297b93351bca374e194c750ef3cbec",
      "content": "function createMcpConfigManager(deps) {\n  const vscode = deps.vscode;\n  const log = deps.log;\n\n  const extensionRoot = deps.extensionRoot;\n  const getEffectiveConfig = deps.getEffectiveConfig;\n  const getWorkspaceFolderPath = deps.getWorkspaceFolderPath;\n  const resolveBridgeWorkspacePath = deps.resolveBridgeWorkspacePath;\n  const normalizeBridgeUrl = deps.normalizeBridgeUrl;\n  const normalizeWorkspaceForBridge = deps.normalizeWorkspaceForBridge;\n  const resolveBridgeCliInvocation = deps.resolveBridgeCliInvocation;\n\n  const resolveBridgeHttpUrl = deps.resolveBridgeHttpUrl;\n  const requiresHttpBridge = deps.requiresHttpBridge;\n  const ensureHttpBridgeReadyForConfigs = deps.ensureHttpBridgeReadyForConfigs;\n  const getBridgeIsRunning = deps.getBridgeIsRunning;\n\n  const writeCtxConfig = deps.writeCtxConfig;\n\n  let pendingBridgeConfigTimer;\n\n  function dispose() {\n    try {\n      if (pendingBridgeConfigTimer) {\n        clearTimeout(pendingBridgeConfigTimer);\n        pendingBridgeConfigTimer = undefined;\n      }\n    } catch (_) {\n      // ignore\n    }\n  }\n\n  function getClaudeHookCommand() {\n    const isLinux = process.platform === 'linux';\n    if (!isLinux) {\n      return '';\n    }\n    if (!extensionRoot) {\n      log('Claude hook command resolution failed: extensionRoot is undefined.');\n      return '';\n    }\n    try {\n      const embeddedPath = path.join(extensionRoot, 'ctx-hook-simple.sh');\n      if (fs.existsSync(embeddedPath)) {\n        log(`Using embedded Claude hook at ${embeddedPath}`);\n        return embeddedPath;\n      }\n      log(`Claude hook command resolution failed: ctx-hook-simple.sh not found at ${embeddedPath}`);\n    } catch (error) {\n      log(`Failed to resolve embedded Claude hook path: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    return '';\n  }\n\n  function buildBridgeServerConfig(workspacePath, indexerUrl, memoryUrl) {\n    const invocation = resolveBridgeCliInvocation();\n    const args = [...invocation.args, 'mcp-serve'];\n    if (workspacePath) {\n      args.push('--workspace', normalizeWorkspaceForBridge(workspacePath));\n    }\n    if (indexerUrl) {\n      args.push('--indexer-url', indexerUrl);\n    }\n    if (memoryUrl) {\n      args.push('--memory-url', memoryUrl);\n    }\n    return {\n      command: invocation.command,\n      args,\n      env: {},\n    };\n  }\n\n  function loadJsonConfigOrDefault(configPath, defaultConfig, invalidUserMessage, invalidLogPrefix) {\n    let config = defaultConfig;\n    if (fs.existsSync(configPath)) {\n      try {\n        const raw = fs.readFileSync(configPath, 'utf8');\n        const parsed = JSON.parse(raw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          config = parsed;\n        }\n      } catch (error) {\n        if (invalidUserMessage) {\n          vscode.window.showErrorMessage(invalidUserMessage);\n        }\n        if (invalidLogPrefix) {\n          log(`${invalidLogPrefix}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        return undefined;\n      }\n    }\n    if (!config || typeof config !== 'object' || Array.isArray(config)) {\n      config = defaultConfig;\n    }\n    return config;\n  }\n\n  function ensureMcpServersObject(config) {\n    if (!config.mcpServers || typeof config.mcpServers !== 'object') {\n      config.mcpServers = {};\n    }\n    return config.mcpServers;\n  }\n\n  function writeJsonConfig(configPath, config, successMessage, successLogPrefix, failureUserMessage, failureLogPrefix) {\n    try {\n      const json = JSON.stringify(config, null, 2) + '\\n';\n      fs.writeFileSync(configPath, json, 'utf8');\n      if (successMessage) {\n        vscode.window.showInformationMessage(successMessage);\n      }\n      if (successLogPrefix) {\n        log(`${successLogPrefix} ${configPath}`);\n      }\n      return true;\n    } catch (error) {\n      if (failureUserMessage) {\n        vscode.window.showErrorMessage(failureUserMessage);\n      }\n      if (failureLogPrefix) {\n        log(`${failureLogPrefix}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n      return false;\n    }\n  }\n\n  function makeMcpRemoteServer(url, options = {}) {\n    const isWindows = process.platform === 'win32';\n    const allowHttpForNonLocal = !!options.allowHttpForNonLocal;\n    const useCmdOnWindows = !!options.useCmdOnWindows;\n\n    const args = ['mcp-remote', url, '--transport', 'sse-only'];\n    if (allowHttpForNonLocal) {\n      try {\n        const u = new URL(url);\n        const isLocalHost =\n          u.hostname === 'localhost' ||\n          u.hostname === '127.0.0.1' ||\n          u.hostname === '::1';\n        if (u.protocol === 'http:' && !isLocalHost) {\n          args.push('--allow-http');\n        }\n      } catch (_) {\n      }\n    }\n\n    if (isWindows && useCmdOnWindows) {\n      return {\n        command: 'cmd',\n        args: ['/c', 'npx', ...args],\n        env: {},\n      };\n    }\n\n    return {\n      command: 'npx',\n      args,\n      env: {},\n    };\n  }\n\n  function applyMcpServersUpdate(servers, options) {\n    const serverMode = options && typeof options.serverMode === 'string' ? options.serverMode : 'bridge';\n    const mode = options && typeof options.transportMode === 'string' ? options.transportMode : 'sse-remote';\n    const indexerUrl = options ? options.indexerUrl : undefined;\n    const memoryUrl = options ? options.memoryUrl : undefined;\n\n    if (serverMode === 'bridge') {\n      const bridgeWorkspace = options && options.bridgeWorkspace ? options.bridgeWorkspace : '';\n      if (mode === 'http') {\n        const bridgeUrl = options && typeof options.bridgeHttpUrl === 'function' ? options.bridgeHttpUrl() : '';\n        if (bridgeUrl) {\n          servers['context-engine'] = options && typeof options.makeBridgeHttpServer === 'function'\n            ? options.makeBridgeHttpServer(bridgeUrl)\n            : { type: 'http', url: bridgeUrl };\n        } else {\n          servers['context-engine'] = buildBridgeServerConfig(bridgeWorkspace, indexerUrl, memoryUrl);\n        }\n      } else {\n        servers['context-engine'] = buildBridgeServerConfig(bridgeWorkspace, indexerUrl, memoryUrl);\n      }\n      delete servers['qdrant-indexer'];\n      delete servers.memory;\n      return;\n    }\n\n    if (mode === 'http') {\n      if (options && options.deleteContextEngineInDirect) {\n        delete servers['context-engine'];\n      }\n      // Note: if indexerUrl or memoryUrl are blank/falsey, we intentionally do\n      // not delete existing entries here. This preserves prior working config\n      // during partial/invalid configuration edits. We can revisit later if we\n      // want blank URLs to mean \"delete this server entry\".\n      if (indexerUrl) {\n        servers['qdrant-indexer'] = options && typeof options.makeDirectHttpServer === 'function'\n          ? options.makeDirectHttpServer(indexerUrl)\n          : { type: 'http', url: indexerUrl };\n      }\n      if (memoryUrl) {\n        servers.memory = options && typeof options.makeDirectHttpServer === 'function'\n          ? options.makeDirectHttpServer(memoryUrl)\n          : { type: 'http', url: memoryUrl };\n      }\n      return;\n    }\n\n    if (options && options.deleteContextEngineInDirect) {\n      delete servers['context-engine'];\n    }\n    const makeRemote = options && typeof options.makeRemoteSseServer === 'function'\n      ? options.makeRemoteSseServer\n      : (url) => makeMcpRemoteServer(url);\n    // Note: same behavior as HTTP above: falsey URLs do not remove existing\n    // entries. See comment in the HTTP branch about possibly changing this.\n    if (indexerUrl) {\n      servers['qdrant-indexer'] = makeRemote(indexerUrl);\n    }\n    if (memoryUrl) {\n      servers.memory = makeRemote(memoryUrl);\n    }\n  }\n\n  async function removeContextEngineFromWindsurfConfig() {\n    try {\n      const settings = getEffectiveConfig();\n      const customPath = (settings.get('windsurfMcpPath') || '').trim();\n      const configPath = customPath || getDefaultWindsurfMcpPath();\n      if (!configPath) {\n        return;\n      }\n      if (!fs.existsSync(configPath)) {\n        // Nothing to remove yet.\n        return;\n      }\n      const config = loadJsonConfigOrDefault(\n        configPath,\n        { mcpServers: {} },\n        undefined,\n        'Context Engine Uploader: failed to parse Windsurf mcp_config.json when removing context-engine'\n      );\n      if (!config) {\n        return;\n      }\n      if (!config.mcpServers || typeof config.mcpServers !== 'object') {\n        return;\n      }\n      if (!config.mcpServers['context-engine']) {\n        return;\n      }\n      delete config.mcpServers['context-engine'];\n      try {\n        const json = JSON.stringify(config, null, 2) + '\\n';\n        fs.writeFileSync(configPath, json, 'utf8');\n        log(`Context Engine Uploader: removed context-engine server from Windsurf MCP config at ${configPath} before HTTP bridge restart.`);\n      } catch (error) {\n        log(`Context Engine Uploader: failed to write Windsurf mcp_config.json when removing context-engine: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    } catch (error) {\n      log(`Context Engine Uploader: error while removing context-engine from Windsurf MCP config: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  function scheduleMcpConfigRefreshAfterBridge(delayMs = 1500) {\n    try {\n      if (pendingBridgeConfigTimer) {\n        clearTimeout(pendingBridgeConfigTimer);\n        pendingBridgeConfigTimer = undefined;\n      }\n      // For bridge-http mode started by the extension, Windsurf needs the\n      // \"context-engine\" MCP server entry removed and then re-added once the\n      // HTTP bridge is ready. Best-effort removal happens immediately here;\n      // writeMcpConfig() below will re-write configs after the bridge comes up.\n      try {\n        const settings = getEffectiveConfig();\n        const windsurfEnabled = settings.get('mcpWindsurfEnabled', false);\n        const transportModeRaw = settings.get('mcpTransportMode') || 'sse-remote';\n        const serverModeRaw = settings.get('mcpServerMode') || 'bridge';\n        const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n        const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n        if (windsurfEnabled && serverMode === 'bridge' && transportMode === 'http') {\n          removeContextEngineFromWindsurfConfig().catch(error => {\n            log(`Context Engine Uploader: failed to remove context-engine from Windsurf MCP config before HTTP bridge restart: ${error instanceof Error ? error.message : String(error)}`);\n          });\n        }\n      } catch (error) {\n        log(`Context Engine Uploader: failed to prepare Windsurf MCP removal before HTTP bridge restart: ${error instanceof Error ? error.message : String(error)}`);\n      }\n      pendingBridgeConfigTimer = setTimeout(() => {\n        pendingBridgeConfigTimer = undefined;\n        log('Context Engine Uploader: HTTP bridge ready; refreshing MCP configs.');\n        writeMcpConfig().catch(error => {\n          log(`Context Engine Uploader: MCP config refresh after bridge start failed: ${error instanceof Error ? error.message : String(error)}`);\n        });\n      }, delayMs);\n    } catch (error) {\n      log(`Context Engine Uploader: failed to schedule MCP config refresh: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async function writeClaudeMcpServers(root, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge') {\n    const bridgeWorkspace = resolveBridgeWorkspacePath();\n    const configPath = path.join(bridgeWorkspace || root, '.mcp.json');\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      { mcpServers: {} },\n      'Context Engine Uploader: existing .mcp.json is invalid JSON; not modified.',\n      'Failed to parse .mcp.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n    log(`Preparing to write .mcp.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    if (serverMode !== 'bridge' && mode === 'http') {\n      // Direct HTTP MCP endpoints for Claude (.mcp.json)\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    } else if (serverMode !== 'bridge') {\n      // Legacy/default: stdio via mcp-remote SSE bridge\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    } else {\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    }\n    return writeJsonConfig(\n      configPath,\n      config,\n      'Context Engine Uploader: .mcp.json updated for Context Engine MCP servers.',\n      'Wrote .mcp.json at',\n      'Context Engine Uploader: failed to write .mcp.json.',\n      'Failed to write .mcp.json'\n    );\n  }\n\n  async function writeAugmentMcpServers(configPath, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge', workspaceHint) {\n    try {\n      fs.mkdirSync(path.dirname(configPath), { recursive: true });\n    } catch (error) {\n      log(`Failed to ensure Augment MCP directory: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to prepare Augment MCP directory.');\n      return false;\n    }\n\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      {},\n      'Context Engine Uploader: existing Augment settings.json is invalid JSON; not modified.',\n      'Failed to parse Augment settings.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    log(`Preparing to write Augment settings.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n\n    applyMcpServersUpdate(servers, {\n      serverMode,\n      transportMode: mode,\n      indexerUrl,\n      memoryUrl,\n      bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n      bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n      makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n      makeDirectHttpServer: (url) => ({ type: 'http', url }),\n      makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: true, useCmdOnWindows: true }),\n      deleteContextEngineInDirect: true,\n    });\n\n    return writeJsonConfig(\n      configPath,\n      config,\n      `Context Engine Uploader: Augment MCP config updated at ${configPath}.`,\n      'Wrote Augment settings.json at',\n      'Context Engine Uploader: failed to write Augment settings.json.',\n      'Failed to write Augment settings.json'\n    );\n  }\n\n  async function writeWindsurfMcpServers(configPath, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge', workspaceHint) {\n    try {\n      fs.mkdirSync(path.dirname(configPath), { recursive: true });\n    } catch (error) {\n      log(`Failed to ensure Windsurf MCP directory: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to prepare Windsurf MCP directory.');\n      return false;\n    }\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      { mcpServers: {} },\n      'Context Engine Uploader: existing Windsurf mcp_config.json is invalid JSON; not modified.',\n      'Failed to parse Windsurf mcp_config.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n    log(`Preparing to write Windsurf mcp_config.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    if (serverMode !== 'bridge' && mode === 'http') {\n      // Direct HTTP MCP endpoints for Windsurf mcp_config.json\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        deleteContextEngineInDirect: true,\n      });\n    } else if (serverMode !== 'bridge') {\n      // Legacy/default: use mcp-remote SSE bridge\n      const makeServer = url => {\n        // Default args for local/HTTPS endpoints\n        const args = ['mcp-remote', url, '--transport', 'sse-only'];\n        try {\n          const u = new URL(url);\n          const isLocalHost =\n            u.hostname === 'localhost' ||\n            u.hostname === '127.0.0.1' ||\n            u.hostname === '::1';\n          // For non-local HTTP URLs, mcp-remote requires --allow-http\n          if (u.protocol === 'http:' && !isLocalHost) {\n            args.push('--allow-http');\n          }\n        } catch (e) {\n          // If URL parsing fails, fall back to default args without additional flags\n        }\n        return {\n          command: 'npx',\n          args,\n          env: {},\n        };\n      };\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeServer(url),\n        deleteContextEngineInDirect: true,\n      });\n    } else {\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        deleteContextEngineInDirect: true,\n      });\n    }\n    return writeJsonConfig(\n      configPath,\n      config,\n      `Context Engine Uploader: Windsurf MCP config updated at ${configPath}.`,\n      'Wrote Windsurf mcp_config.json at',\n      'Context Engine Uploader: failed to write Windsurf mcp_config.json.',\n      'Failed to write Windsurf mcp_config.json'\n    );\n  }\n\n  async function writeClaudeHookConfig(root, commandPath) {\n    try {\n      const claudeDir = path.join(root, '.claude');\n      fs.mkdirSync(claudeDir, { recursive: true });\n      const settingsPath = path.join(claudeDir, 'settings.local.json');\n      let config = {};\n      if (fs.existsSync(settingsPath)) {\n        try {\n          const raw = fs.readFileSync(settingsPath, 'utf8');\n          const parsed = JSON.parse(raw);\n          if (parsed && typeof parsed === 'object') {\n            config = parsed;\n          }\n        } catch (error) {\n          vscode.window.showErrorMessage('Context Engine Uploader: existing .claude/settings.local.json is invalid JSON; not modified.');\n          log(`Failed to parse .claude/settings.local.json: ${error instanceof Error ? error.message : String(error)}`);\n          return false;\n        }\n      }\n      if (!config.permissions || typeof config.permissions !== 'object') {\n        config.permissions = { allow: [], deny: [], ask: [] };\n      } else {\n        config.permissions.allow = config.permissions.allow || [];\n        config.permissions.deny = config.permissions.deny || [];\n        config.permissions.ask = config.permissions.ask || [];\n      }\n      if (!config.enabledMcpjsonServers) {\n        config.enabledMcpjsonServers = [];\n      }\n      if (!config.hooks || typeof config.hooks !== 'object') {\n        config.hooks = {};\n      }\n      // Derive CTX workspace directory for the hook from extension settings.\n      // Collection hint behavior is now driven by ctx_config.json, not hook env.\n      let hookEnv;\n      try {\n        const resolvedTarget = resolveBridgeWorkspacePath ? resolveBridgeWorkspacePath() : undefined;\n        if (resolvedTarget) {\n          hookEnv = { CTX_WORKSPACE_DIR: resolvedTarget };\n        }\n      } catch (error) {\n        // Best-effort only; if anything fails, fall back to no extra env\n        hookEnv = undefined;\n      }\n\n      const hook = {\n        type: 'command',\n        command: commandPath,\n      };\n      if (hookEnv) {\n        hook.env = hookEnv;\n      }\n\n      // Append or update our hook under UserPromptSubmit without clobbering existing hooks\n      let userPromptHooks = config.hooks['UserPromptSubmit'];\n      if (!Array.isArray(userPromptHooks)) {\n        userPromptHooks = [];\n      }\n\n      const normalizeCommand = value => {\n        if (!value) return '';\n        const resolved = path.resolve(value);\n        return resolved.replace(/context-engine\\.context-engine-uploader-[0-9.]+/, 'context-engine.context-engine-uploader');\n      };\n\n      const normalizedNewCommand = normalizeCommand(commandPath);\n      let updated = false;\n\n      for (const entry of userPromptHooks) {\n        if (!entry || !Array.isArray(entry.hooks)) {\n          continue;\n        }\n        for (const existing of entry.hooks) {\n          if (!existing || existing.type !== 'command') {\n            continue;\n          }\n          const normalizedExisting = normalizeCommand(existing.command);\n          if (normalizedExisting === normalizedNewCommand) {\n            existing.command = commandPath;\n            if (!existing.env) {\n              existing.env = {};\n            }\n            if (hookEnv) {\n              existing.env = { ...existing.env, ...hookEnv };\n            }\n            updated = true;\n          }\n        }\n      }\n\n      if (!updated) {\n        userPromptHooks.push({ hooks: [hook] });\n      }\n\n      // Deduplicate any accidental double entries for the same command\n      const seenCommands = new Set();\n      for (const entry of userPromptHooks) {\n        if (!entry || !Array.isArray(entry.hooks)) {\n          continue;\n        }\n        entry.hooks = entry.hooks.filter(existing => {\n          if (!existing || existing.type !== 'command') {\n            return true;\n          }\n          const normalized = normalizeCommand(existing.command);\n          if (seenCommands.has(normalized)) {\n            return false;\n          }\n          seenCommands.add(normalized);\n          return true;\n        });\n      }\n\n      config.hooks['UserPromptSubmit'] = userPromptHooks.filter(entry => Array.isArray(entry.hooks) && entry.hooks.length);\n      fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2) + '\\n', 'utf8');\n      vscode.window.showInformationMessage('Context Engine Uploader: .claude/settings.local.json updated with Claude hook.');\n      log(`Wrote Claude hook config at ${settingsPath}`);\n      return true;\n    } catch (error) {\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to write .claude/settings.local.json.');\n      log(`Failed to write .claude/settings.local.json: ${error instanceof Error ? error.message : String(error)}`);\n      return false;\n    }\n  }\n\n  async function writeMcpConfig(options = {}) {\n    const settings = getEffectiveConfig();\n    const claudeEnabled = settings.get('mcpClaudeEnabled', true);\n    const windsurfEnabled = settings.get('mcpWindsurfEnabled', false);\n    const augmentEnabled = settings.get('mcpAugmentEnabled', false);\n    const claudeHookEnabled = settings.get('claudeHookEnabled', false);\n    const isLinux = process.platform === 'linux';\n\n    const targets = options && Array.isArray(options.targets) ? options.targets : undefined;\n    const wantsClaude = targets ? targets.includes('claude') : claudeEnabled;\n    const wantsWindsurf = targets ? targets.includes('windsurf') : windsurfEnabled;\n    const wantsAugment = targets ? targets.includes('augment') : augmentEnabled;\n\n    if (!wantsClaude && !wantsWindsurf && !wantsAugment && !claudeHookEnabled) {\n      vscode.window.showInformationMessage('Context Engine Uploader: MCP config writing is disabled in settings.');\n      return;\n    }\n    const transportModeRaw = (settings.get('mcpTransportMode') || 'sse-remote');\n    const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n    const serverModeRaw = (settings.get('mcpServerMode') || 'bridge');\n    const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n    const needsHttpBridge = requiresHttpBridge(serverMode, transportMode);\n    const bridgeWasRunning = !!(typeof getBridgeIsRunning === 'function' && getBridgeIsRunning());\n    if (needsHttpBridge) {\n      const ready = await ensureHttpBridgeReadyForConfigs();\n      if (!ready) {\n        vscode.window.showErrorMessage('Context Engine Uploader: HTTP MCP bridge failed to start; MCP config not updated.');\n        return;\n      }\n      const bridgeNowRunning = !!(typeof getBridgeIsRunning === 'function' && getBridgeIsRunning());\n      if (!bridgeWasRunning && bridgeNowRunning) {\n        log('Context Engine Uploader: HTTP MCP bridge launching; delaying MCP config write until bridge signals ready.');\n        return;\n      }\n    }\n    const effectiveMode =\n      serverMode === 'bridge'\n        ? (transportMode === 'http' ? 'bridge-http' : 'bridge-stdio')\n        : (transportMode === 'http' ? 'direct-http' : 'direct-sse');\n    log(`Context Engine Uploader: MCP wiring mode=${effectiveMode} (serverMode=${serverMode}, transportMode=${transportMode}).`);\n    if (effectiveMode === 'bridge-http') {\n      const bridgeUrl = resolveBridgeHttpUrl();\n      if (bridgeUrl) {\n        log(`Context Engine Uploader: bridge HTTP endpoint ${bridgeUrl}`);\n      }\n    }\n\n    let indexerUrl = (settings.get('mcpIndexerUrl') || 'http://localhost:8003/mcp').trim();\n    let memoryUrl = (settings.get('mcpMemoryUrl') || 'http://localhost:8002/mcp').trim();\n    if (serverMode === 'bridge') {\n      indexerUrl = normalizeBridgeUrl(indexerUrl);\n      memoryUrl = normalizeBridgeUrl(memoryUrl);\n    }\n    let wroteAny = false;\n    let hookWrote = false;\n    if (wantsClaude) {\n      const root = getWorkspaceFolderPath();\n      if (!root) {\n        vscode.window.showErrorMessage('Context Engine Uploader: open a folder before writing .mcp.json.');\n      } else {\n        const result = await writeClaudeMcpServers(root, indexerUrl, memoryUrl, transportMode, serverMode);\n        wroteAny = wroteAny || result;\n      }\n    }\n    if (wantsWindsurf) {\n      const customPath = (settings.get('windsurfMcpPath') || '').trim();\n      const windsPath = customPath || getDefaultWindsurfMcpPath();\n      const workspaceHint = getWorkspaceFolderPath();\n      const result = await writeWindsurfMcpServers(windsPath, indexerUrl, memoryUrl, transportMode, serverMode, workspaceHint);\n      wroteAny = wroteAny || result;\n    }\n    if (wantsAugment) {\n      const customPath = (settings.get('augmentMcpPath') || '').trim();\n      const augPath = customPath || getDefaultAugmentMcpPath();\n      const workspaceHint = getWorkspaceFolderPath();\n      const result = await writeAugmentMcpServers(augPath, indexerUrl, memoryUrl, transportMode, serverMode, workspaceHint);\n      wroteAny = wroteAny || result;\n    }\n    if (claudeHookEnabled) {\n      const root = getWorkspaceFolderPath();\n      if (!root) {\n        vscode.window.showErrorMessage('Context Engine Uploader: open a folder before writing Claude hook config.');\n      } else if (!isLinux) {\n        vscode.window.showWarningMessage('Context Engine Uploader: Claude hook auto-config is only wired for Linux/dev-remote at this time.');\n      } else {\n        const commandPath = getClaudeHookCommand();\n        if (!commandPath) {\n          vscode.window.showErrorMessage('Context Engine Uploader: embedded Claude hook script not found in extension; .claude/settings.local.json was not updated.');\n          log('Claude hook config skipped because embedded ctx-hook-simple.sh could not be resolved.');\n        } else {\n          const result = await writeClaudeHookConfig(root, commandPath);\n          hookWrote = hookWrote || result;\n        }\n      }\n    }\n    if (settings.get('scaffoldCtxConfig', true)) {\n      try {\n        await writeCtxConfig();\n      } catch (error) {\n        log(`CTX config auto-scaffolding failed: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    if (!wroteAny && !hookWrote) {\n      // noop\n    }\n  }\n\n  return {\n    scheduleMcpConfigRefreshAfterBridge,\n    writeMcpConfig,\n    dispose,\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_dispose_37": {
      "name": "dispose",
      "type": "function",
      "start_line": 37,
      "end_line": 46,
      "content_hash": "0318da51f10eea71895afc252a10a980509e9ad9",
      "content": "  function dispose() {\n    try {\n      if (pendingBridgeConfigTimer) {\n        clearTimeout(pendingBridgeConfigTimer);\n        pendingBridgeConfigTimer = undefined;\n      }\n    } catch (_) {\n      // ignore\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getClaudeHookCommand_48": {
      "name": "getClaudeHookCommand",
      "type": "function",
      "start_line": 48,
      "end_line": 68,
      "content_hash": "1c536b32c0f0618f0f2be72ec5c99eca9ee1d417",
      "content": "  function getClaudeHookCommand() {\n    const isLinux = process.platform === 'linux';\n    if (!isLinux) {\n      return '';\n    }\n    if (!extensionRoot) {\n      log('Claude hook command resolution failed: extensionRoot is undefined.');\n      return '';\n    }\n    try {\n      const embeddedPath = path.join(extensionRoot, 'ctx-hook-simple.sh');\n      if (fs.existsSync(embeddedPath)) {\n        log(`Using embedded Claude hook at ${embeddedPath}`);\n        return embeddedPath;\n      }\n      log(`Claude hook command resolution failed: ctx-hook-simple.sh not found at ${embeddedPath}`);\n    } catch (error) {\n      log(`Failed to resolve embedded Claude hook path: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    return '';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_buildBridgeServerConfig_70": {
      "name": "buildBridgeServerConfig",
      "type": "function",
      "start_line": 70,
      "end_line": 87,
      "content_hash": "8bb60455e7f5aec28f8cd9ac9878b651f0e8bf48",
      "content": "  function buildBridgeServerConfig(workspacePath, indexerUrl, memoryUrl) {\n    const invocation = resolveBridgeCliInvocation();\n    const args = [...invocation.args, 'mcp-serve'];\n    if (workspacePath) {\n      args.push('--workspace', normalizeWorkspaceForBridge(workspacePath));\n    }\n    if (indexerUrl) {\n      args.push('--indexer-url', indexerUrl);\n    }\n    if (memoryUrl) {\n      args.push('--memory-url', memoryUrl);\n    }\n    return {\n      command: invocation.command,\n      args,\n      env: {},\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_loadJsonConfigOrDefault_89": {
      "name": "loadJsonConfigOrDefault",
      "type": "function",
      "start_line": 89,
      "end_line": 112,
      "content_hash": "9b07287424ab30b9d8b2c7ebb83cc81c9274a179",
      "content": "  function loadJsonConfigOrDefault(configPath, defaultConfig, invalidUserMessage, invalidLogPrefix) {\n    let config = defaultConfig;\n    if (fs.existsSync(configPath)) {\n      try {\n        const raw = fs.readFileSync(configPath, 'utf8');\n        const parsed = JSON.parse(raw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          config = parsed;\n        }\n      } catch (error) {\n        if (invalidUserMessage) {\n          vscode.window.showErrorMessage(invalidUserMessage);\n        }\n        if (invalidLogPrefix) {\n          log(`${invalidLogPrefix}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        return undefined;\n      }\n    }\n    if (!config || typeof config !== 'object' || Array.isArray(config)) {\n      config = defaultConfig;\n    }\n    return config;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensureMcpServersObject_114": {
      "name": "ensureMcpServersObject",
      "type": "function",
      "start_line": 114,
      "end_line": 119,
      "content_hash": "e60398b165e190ee73de0169bc26ee39972ef56b",
      "content": "  function ensureMcpServersObject(config) {\n    if (!config.mcpServers || typeof config.mcpServers !== 'object') {\n      config.mcpServers = {};\n    }\n    return config.mcpServers;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeJsonConfig_121": {
      "name": "writeJsonConfig",
      "type": "function",
      "start_line": 121,
      "end_line": 141,
      "content_hash": "31a2559308339a1a3223bd2bb9f7211fcc5d1b9e",
      "content": "  function writeJsonConfig(configPath, config, successMessage, successLogPrefix, failureUserMessage, failureLogPrefix) {\n    try {\n      const json = JSON.stringify(config, null, 2) + '\\n';\n      fs.writeFileSync(configPath, json, 'utf8');\n      if (successMessage) {\n        vscode.window.showInformationMessage(successMessage);\n      }\n      if (successLogPrefix) {\n        log(`${successLogPrefix} ${configPath}`);\n      }\n      return true;\n    } catch (error) {\n      if (failureUserMessage) {\n        vscode.window.showErrorMessage(failureUserMessage);\n      }\n      if (failureLogPrefix) {\n        log(`${failureLogPrefix}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n      return false;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_makeMcpRemoteServer_143": {
      "name": "makeMcpRemoteServer",
      "type": "function",
      "start_line": 143,
      "end_line": 176,
      "content_hash": "90dd2190c5366ad287b82f78995dc56e54cdf18e",
      "content": "  function makeMcpRemoteServer(url, options = {}) {\n    const isWindows = process.platform === 'win32';\n    const allowHttpForNonLocal = !!options.allowHttpForNonLocal;\n    const useCmdOnWindows = !!options.useCmdOnWindows;\n\n    const args = ['mcp-remote', url, '--transport', 'sse-only'];\n    if (allowHttpForNonLocal) {\n      try {\n        const u = new URL(url);\n        const isLocalHost =\n          u.hostname === 'localhost' ||\n          u.hostname === '127.0.0.1' ||\n          u.hostname === '::1';\n        if (u.protocol === 'http:' && !isLocalHost) {\n          args.push('--allow-http');\n        }\n      } catch (_) {\n      }\n    }\n\n    if (isWindows && useCmdOnWindows) {\n      return {\n        command: 'cmd',\n        args: ['/c', 'npx', ...args],\n        env: {},\n      };\n    }\n\n    return {\n      command: 'npx',\n      args,\n      env: {},\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyMcpServersUpdate_178": {
      "name": "applyMcpServersUpdate",
      "type": "function",
      "start_line": 178,
      "end_line": 238,
      "content_hash": "398962a771fc51c77ed117f2de2da22a3fb38bf8",
      "content": "  function applyMcpServersUpdate(servers, options) {\n    const serverMode = options && typeof options.serverMode === 'string' ? options.serverMode : 'bridge';\n    const mode = options && typeof options.transportMode === 'string' ? options.transportMode : 'sse-remote';\n    const indexerUrl = options ? options.indexerUrl : undefined;\n    const memoryUrl = options ? options.memoryUrl : undefined;\n\n    if (serverMode === 'bridge') {\n      const bridgeWorkspace = options && options.bridgeWorkspace ? options.bridgeWorkspace : '';\n      if (mode === 'http') {\n        const bridgeUrl = options && typeof options.bridgeHttpUrl === 'function' ? options.bridgeHttpUrl() : '';\n        if (bridgeUrl) {\n          servers['context-engine'] = options && typeof options.makeBridgeHttpServer === 'function'\n            ? options.makeBridgeHttpServer(bridgeUrl)\n            : { type: 'http', url: bridgeUrl };\n        } else {\n          servers['context-engine'] = buildBridgeServerConfig(bridgeWorkspace, indexerUrl, memoryUrl);\n        }\n      } else {\n        servers['context-engine'] = buildBridgeServerConfig(bridgeWorkspace, indexerUrl, memoryUrl);\n      }\n      delete servers['qdrant-indexer'];\n      delete servers.memory;\n      return;\n    }\n\n    if (mode === 'http') {\n      if (options && options.deleteContextEngineInDirect) {\n        delete servers['context-engine'];\n      }\n      // Note: if indexerUrl or memoryUrl are blank/falsey, we intentionally do\n      // not delete existing entries here. This preserves prior working config\n      // during partial/invalid configuration edits. We can revisit later if we\n      // want blank URLs to mean \"delete this server entry\".\n      if (indexerUrl) {\n        servers['qdrant-indexer'] = options && typeof options.makeDirectHttpServer === 'function'\n          ? options.makeDirectHttpServer(indexerUrl)\n          : { type: 'http', url: indexerUrl };\n      }\n      if (memoryUrl) {\n        servers.memory = options && typeof options.makeDirectHttpServer === 'function'\n          ? options.makeDirectHttpServer(memoryUrl)\n          : { type: 'http', url: memoryUrl };\n      }\n      return;\n    }\n\n    if (options && options.deleteContextEngineInDirect) {\n      delete servers['context-engine'];\n    }\n    const makeRemote = options && typeof options.makeRemoteSseServer === 'function'\n      ? options.makeRemoteSseServer\n      : (url) => makeMcpRemoteServer(url);\n    // Note: same behavior as HTTP above: falsey URLs do not remove existing\n    // entries. See comment in the HTTP branch about possibly changing this.\n    if (indexerUrl) {\n      servers['qdrant-indexer'] = makeRemote(indexerUrl);\n    }\n    if (memoryUrl) {\n      servers.memory = makeRemote(memoryUrl);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_removeContextEngineFromWindsurfConfig_240": {
      "name": "removeContextEngineFromWindsurfConfig",
      "type": "function",
      "start_line": 240,
      "end_line": 278,
      "content_hash": "8bc53b605efcf5067cc45295291e1dc8fc0763bb",
      "content": "  async function removeContextEngineFromWindsurfConfig() {\n    try {\n      const settings = getEffectiveConfig();\n      const customPath = (settings.get('windsurfMcpPath') || '').trim();\n      const configPath = customPath || getDefaultWindsurfMcpPath();\n      if (!configPath) {\n        return;\n      }\n      if (!fs.existsSync(configPath)) {\n        // Nothing to remove yet.\n        return;\n      }\n      const config = loadJsonConfigOrDefault(\n        configPath,\n        { mcpServers: {} },\n        undefined,\n        'Context Engine Uploader: failed to parse Windsurf mcp_config.json when removing context-engine'\n      );\n      if (!config) {\n        return;\n      }\n      if (!config.mcpServers || typeof config.mcpServers !== 'object') {\n        return;\n      }\n      if (!config.mcpServers['context-engine']) {\n        return;\n      }\n      delete config.mcpServers['context-engine'];\n      try {\n        const json = JSON.stringify(config, null, 2) + '\\n';\n        fs.writeFileSync(configPath, json, 'utf8');\n        log(`Context Engine Uploader: removed context-engine server from Windsurf MCP config at ${configPath} before HTTP bridge restart.`);\n      } catch (error) {\n        log(`Context Engine Uploader: failed to write Windsurf mcp_config.json when removing context-engine: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    } catch (error) {\n      log(`Context Engine Uploader: error while removing context-engine from Windsurf MCP config: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_scheduleMcpConfigRefreshAfterBridge_280": {
      "name": "scheduleMcpConfigRefreshAfterBridge",
      "type": "function",
      "start_line": 280,
      "end_line": 315,
      "content_hash": "cd1f3be556c8f206d7bd715830c4dfec23b67811",
      "content": "  function scheduleMcpConfigRefreshAfterBridge(delayMs = 1500) {\n    try {\n      if (pendingBridgeConfigTimer) {\n        clearTimeout(pendingBridgeConfigTimer);\n        pendingBridgeConfigTimer = undefined;\n      }\n      // For bridge-http mode started by the extension, Windsurf needs the\n      // \"context-engine\" MCP server entry removed and then re-added once the\n      // HTTP bridge is ready. Best-effort removal happens immediately here;\n      // writeMcpConfig() below will re-write configs after the bridge comes up.\n      try {\n        const settings = getEffectiveConfig();\n        const windsurfEnabled = settings.get('mcpWindsurfEnabled', false);\n        const transportModeRaw = settings.get('mcpTransportMode') || 'sse-remote';\n        const serverModeRaw = settings.get('mcpServerMode') || 'bridge';\n        const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n        const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n        if (windsurfEnabled && serverMode === 'bridge' && transportMode === 'http') {\n          removeContextEngineFromWindsurfConfig().catch(error => {\n            log(`Context Engine Uploader: failed to remove context-engine from Windsurf MCP config before HTTP bridge restart: ${error instanceof Error ? error.message : String(error)}`);\n          });\n        }\n      } catch (error) {\n        log(`Context Engine Uploader: failed to prepare Windsurf MCP removal before HTTP bridge restart: ${error instanceof Error ? error.message : String(error)}`);\n      }\n      pendingBridgeConfigTimer = setTimeout(() => {\n        pendingBridgeConfigTimer = undefined;\n        log('Context Engine Uploader: HTTP bridge ready; refreshing MCP configs.');\n        writeMcpConfig().catch(error => {\n          log(`Context Engine Uploader: MCP config refresh after bridge start failed: ${error instanceof Error ? error.message : String(error)}`);\n        });\n      }, delayMs);\n    } catch (error) {\n      log(`Context Engine Uploader: failed to schedule MCP config refresh: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeClaudeMcpServers_317": {
      "name": "writeClaudeMcpServers",
      "type": "function",
      "start_line": 317,
      "end_line": 384,
      "content_hash": "1dbd0efef1bfac582b92600698ad54ed34e45dd7",
      "content": "  async function writeClaudeMcpServers(root, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge') {\n    const bridgeWorkspace = resolveBridgeWorkspacePath();\n    const configPath = path.join(bridgeWorkspace || root, '.mcp.json');\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      { mcpServers: {} },\n      'Context Engine Uploader: existing .mcp.json is invalid JSON; not modified.',\n      'Failed to parse .mcp.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n    log(`Preparing to write .mcp.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    if (serverMode !== 'bridge' && mode === 'http') {\n      // Direct HTTP MCP endpoints for Claude (.mcp.json)\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    } else if (serverMode !== 'bridge') {\n      // Legacy/default: stdio via mcp-remote SSE bridge\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    } else {\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: bridgeWorkspace || root,\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: false, useCmdOnWindows: true }),\n        deleteContextEngineInDirect: true,\n      });\n    }\n    return writeJsonConfig(\n      configPath,\n      config,\n      'Context Engine Uploader: .mcp.json updated for Context Engine MCP servers.',\n      'Wrote .mcp.json at',\n      'Context Engine Uploader: failed to write .mcp.json.',\n      'Failed to write .mcp.json'\n    );\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeAugmentMcpServers_386": {
      "name": "writeAugmentMcpServers",
      "type": "function",
      "start_line": 386,
      "end_line": 432,
      "content_hash": "9e6a56695bc4064f0ccba4e746baee3b3add3387",
      "content": "  async function writeAugmentMcpServers(configPath, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge', workspaceHint) {\n    try {\n      fs.mkdirSync(path.dirname(configPath), { recursive: true });\n    } catch (error) {\n      log(`Failed to ensure Augment MCP directory: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to prepare Augment MCP directory.');\n      return false;\n    }\n\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      {},\n      'Context Engine Uploader: existing Augment settings.json is invalid JSON; not modified.',\n      'Failed to parse Augment settings.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    log(`Preparing to write Augment settings.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n\n    applyMcpServersUpdate(servers, {\n      serverMode,\n      transportMode: mode,\n      indexerUrl,\n      memoryUrl,\n      bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n      bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n      makeBridgeHttpServer: (url) => ({ type: 'http', url }),\n      makeDirectHttpServer: (url) => ({ type: 'http', url }),\n      makeRemoteSseServer: (url) => makeMcpRemoteServer(url, { allowHttpForNonLocal: true, useCmdOnWindows: true }),\n      deleteContextEngineInDirect: true,\n    });\n\n    return writeJsonConfig(\n      configPath,\n      config,\n      `Context Engine Uploader: Augment MCP config updated at ${configPath}.`,\n      'Wrote Augment settings.json at',\n      'Context Engine Uploader: failed to write Augment settings.json.',\n      'Failed to write Augment settings.json'\n    );\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeWindsurfMcpServers_434": {
      "name": "writeWindsurfMcpServers",
      "type": "function",
      "start_line": 434,
      "end_line": 526,
      "content_hash": "6e5cbf8fe68df60d2a19b51bb07589e52daf47a0",
      "content": "  async function writeWindsurfMcpServers(configPath, indexerUrl, memoryUrl, transportMode, serverMode = 'bridge', workspaceHint) {\n    try {\n      fs.mkdirSync(path.dirname(configPath), { recursive: true });\n    } catch (error) {\n      log(`Failed to ensure Windsurf MCP directory: ${error instanceof Error ? error.message : String(error)}`);\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to prepare Windsurf MCP directory.');\n      return false;\n    }\n    const config = loadJsonConfigOrDefault(\n      configPath,\n      { mcpServers: {} },\n      'Context Engine Uploader: existing Windsurf mcp_config.json is invalid JSON; not modified.',\n      'Failed to parse Windsurf mcp_config.json'\n    );\n    if (!config) {\n      return false;\n    }\n    ensureMcpServersObject(config);\n    log(`Preparing to write Windsurf mcp_config.json at ${configPath} with indexerUrl=${indexerUrl || '\"\"'} memoryUrl=${memoryUrl || '\"\"'}`);\n    const servers = config.mcpServers;\n    const mode = (typeof transportMode === 'string' ? transportMode.trim() : 'sse-remote') || 'sse-remote';\n\n    if (serverMode !== 'bridge' && mode === 'http') {\n      // Direct HTTP MCP endpoints for Windsurf mcp_config.json\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        deleteContextEngineInDirect: true,\n      });\n    } else if (serverMode !== 'bridge') {\n      // Legacy/default: use mcp-remote SSE bridge\n      const makeServer = url => {\n        // Default args for local/HTTPS endpoints\n        const args = ['mcp-remote', url, '--transport', 'sse-only'];\n        try {\n          const u = new URL(url);\n          const isLocalHost =\n            u.hostname === 'localhost' ||\n            u.hostname === '127.0.0.1' ||\n            u.hostname === '::1';\n          // For non-local HTTP URLs, mcp-remote requires --allow-http\n          if (u.protocol === 'http:' && !isLocalHost) {\n            args.push('--allow-http');\n          }\n        } catch (e) {\n          // If URL parsing fails, fall back to default args without additional flags\n        }\n        return {\n          command: 'npx',\n          args,\n          env: {},\n        };\n      };\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        makeRemoteSseServer: (url) => makeServer(url),\n        deleteContextEngineInDirect: true,\n      });\n    } else {\n      applyMcpServersUpdate(servers, {\n        serverMode,\n        transportMode: mode,\n        indexerUrl,\n        memoryUrl,\n        bridgeWorkspace: resolveBridgeWorkspacePath() || workspaceHint || '',\n        bridgeHttpUrl: () => resolveBridgeHttpUrl(),\n        makeBridgeHttpServer: (url) => ({ serverUrl: url }),\n        makeDirectHttpServer: (url) => ({ type: 'http', url }),\n        deleteContextEngineInDirect: true,\n      });\n    }\n    return writeJsonConfig(\n      configPath,\n      config,\n      `Context Engine Uploader: Windsurf MCP config updated at ${configPath}.`,\n      'Wrote Windsurf mcp_config.json at',\n      'Context Engine Uploader: failed to write Windsurf mcp_config.json.',\n      'Failed to write Windsurf mcp_config.json'\n    );\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_makeServer_471": {
      "name": "makeServer",
      "type": "function",
      "start_line": 471,
      "end_line": 492,
      "content_hash": "552957b1801979f3d2a6d2b2182a06c80f6ce2e1",
      "content": "      const makeServer = url => {\n        // Default args for local/HTTPS endpoints\n        const args = ['mcp-remote', url, '--transport', 'sse-only'];\n        try {\n          const u = new URL(url);\n          const isLocalHost =\n            u.hostname === 'localhost' ||\n            u.hostname === '127.0.0.1' ||\n            u.hostname === '::1';\n          // For non-local HTTP URLs, mcp-remote requires --allow-http\n          if (u.protocol === 'http:' && !isLocalHost) {\n            args.push('--allow-http');\n          }\n        } catch (e) {\n          // If URL parsing fails, fall back to default args without additional flags\n        }\n        return {\n          command: 'npx',\n          args,\n          env: {},\n        };\n      };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeClaudeHookConfig_528": {
      "name": "writeClaudeHookConfig",
      "type": "function",
      "start_line": 528,
      "end_line": 651,
      "content_hash": "adf2ca2cbf4947a386bc6565ad5530135640fd98",
      "content": "  async function writeClaudeHookConfig(root, commandPath) {\n    try {\n      const claudeDir = path.join(root, '.claude');\n      fs.mkdirSync(claudeDir, { recursive: true });\n      const settingsPath = path.join(claudeDir, 'settings.local.json');\n      let config = {};\n      if (fs.existsSync(settingsPath)) {\n        try {\n          const raw = fs.readFileSync(settingsPath, 'utf8');\n          const parsed = JSON.parse(raw);\n          if (parsed && typeof parsed === 'object') {\n            config = parsed;\n          }\n        } catch (error) {\n          vscode.window.showErrorMessage('Context Engine Uploader: existing .claude/settings.local.json is invalid JSON; not modified.');\n          log(`Failed to parse .claude/settings.local.json: ${error instanceof Error ? error.message : String(error)}`);\n          return false;\n        }\n      }\n      if (!config.permissions || typeof config.permissions !== 'object') {\n        config.permissions = { allow: [], deny: [], ask: [] };\n      } else {\n        config.permissions.allow = config.permissions.allow || [];\n        config.permissions.deny = config.permissions.deny || [];\n        config.permissions.ask = config.permissions.ask || [];\n      }\n      if (!config.enabledMcpjsonServers) {\n        config.enabledMcpjsonServers = [];\n      }\n      if (!config.hooks || typeof config.hooks !== 'object') {\n        config.hooks = {};\n      }\n      // Derive CTX workspace directory for the hook from extension settings.\n      // Collection hint behavior is now driven by ctx_config.json, not hook env.\n      let hookEnv;\n      try {\n        const resolvedTarget = resolveBridgeWorkspacePath ? resolveBridgeWorkspacePath() : undefined;\n        if (resolvedTarget) {\n          hookEnv = { CTX_WORKSPACE_DIR: resolvedTarget };\n        }\n      } catch (error) {\n        // Best-effort only; if anything fails, fall back to no extra env\n        hookEnv = undefined;\n      }\n\n      const hook = {\n        type: 'command',\n        command: commandPath,\n      };\n      if (hookEnv) {\n        hook.env = hookEnv;\n      }\n\n      // Append or update our hook under UserPromptSubmit without clobbering existing hooks\n      let userPromptHooks = config.hooks['UserPromptSubmit'];\n      if (!Array.isArray(userPromptHooks)) {\n        userPromptHooks = [];\n      }\n\n      const normalizeCommand = value => {\n        if (!value) return '';\n        const resolved = path.resolve(value);\n        return resolved.replace(/context-engine\\.context-engine-uploader-[0-9.]+/, 'context-engine.context-engine-uploader');\n      };\n\n      const normalizedNewCommand = normalizeCommand(commandPath);\n      let updated = false;\n\n      for (const entry of userPromptHooks) {\n        if (!entry || !Array.isArray(entry.hooks)) {\n          continue;\n        }\n        for (const existing of entry.hooks) {\n          if (!existing || existing.type !== 'command') {\n            continue;\n          }\n          const normalizedExisting = normalizeCommand(existing.command);\n          if (normalizedExisting === normalizedNewCommand) {\n            existing.command = commandPath;\n            if (!existing.env) {\n              existing.env = {};\n            }\n            if (hookEnv) {\n              existing.env = { ...existing.env, ...hookEnv };\n            }\n            updated = true;\n          }\n        }\n      }\n\n      if (!updated) {\n        userPromptHooks.push({ hooks: [hook] });\n      }\n\n      // Deduplicate any accidental double entries for the same command\n      const seenCommands = new Set();\n      for (const entry of userPromptHooks) {\n        if (!entry || !Array.isArray(entry.hooks)) {\n          continue;\n        }\n        entry.hooks = entry.hooks.filter(existing => {\n          if (!existing || existing.type !== 'command') {\n            return true;\n          }\n          const normalized = normalizeCommand(existing.command);\n          if (seenCommands.has(normalized)) {\n            return false;\n          }\n          seenCommands.add(normalized);\n          return true;\n        });\n      }\n\n      config.hooks['UserPromptSubmit'] = userPromptHooks.filter(entry => Array.isArray(entry.hooks) && entry.hooks.length);\n      fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2) + '\\n', 'utf8');\n      vscode.window.showInformationMessage('Context Engine Uploader: .claude/settings.local.json updated with Claude hook.');\n      log(`Wrote Claude hook config at ${settingsPath}`);\n      return true;\n    } catch (error) {\n      vscode.window.showErrorMessage('Context Engine Uploader: failed to write .claude/settings.local.json.');\n      log(`Failed to write .claude/settings.local.json: ${error instanceof Error ? error.message : String(error)}`);\n      return false;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeCommand_587": {
      "name": "normalizeCommand",
      "type": "function",
      "start_line": 587,
      "end_line": 591,
      "content_hash": "7c728bd3f54ef98e54071e3fef0ef1548f961b8c",
      "content": "      const normalizeCommand = value => {\n        if (!value) return '';\n        const resolved = path.resolve(value);\n        return resolved.replace(/context-engine\\.context-engine-uploader-[0-9.]+/, 'context-engine.context-engine-uploader');\n      };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_writeMcpConfig_653": {
      "name": "writeMcpConfig",
      "type": "function",
      "start_line": 653,
      "end_line": 759,
      "content_hash": "7e1db10ecadfcf9a9f07584cbfac9db3b0c4d26c",
      "content": "  async function writeMcpConfig(options = {}) {\n    const settings = getEffectiveConfig();\n    const claudeEnabled = settings.get('mcpClaudeEnabled', true);\n    const windsurfEnabled = settings.get('mcpWindsurfEnabled', false);\n    const augmentEnabled = settings.get('mcpAugmentEnabled', false);\n    const claudeHookEnabled = settings.get('claudeHookEnabled', false);\n    const isLinux = process.platform === 'linux';\n\n    const targets = options && Array.isArray(options.targets) ? options.targets : undefined;\n    const wantsClaude = targets ? targets.includes('claude') : claudeEnabled;\n    const wantsWindsurf = targets ? targets.includes('windsurf') : windsurfEnabled;\n    const wantsAugment = targets ? targets.includes('augment') : augmentEnabled;\n\n    if (!wantsClaude && !wantsWindsurf && !wantsAugment && !claudeHookEnabled) {\n      vscode.window.showInformationMessage('Context Engine Uploader: MCP config writing is disabled in settings.');\n      return;\n    }\n    const transportModeRaw = (settings.get('mcpTransportMode') || 'sse-remote');\n    const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n    const serverModeRaw = (settings.get('mcpServerMode') || 'bridge');\n    const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n    const needsHttpBridge = requiresHttpBridge(serverMode, transportMode);\n    const bridgeWasRunning = !!(typeof getBridgeIsRunning === 'function' && getBridgeIsRunning());\n    if (needsHttpBridge) {\n      const ready = await ensureHttpBridgeReadyForConfigs();\n      if (!ready) {\n        vscode.window.showErrorMessage('Context Engine Uploader: HTTP MCP bridge failed to start; MCP config not updated.');\n        return;\n      }\n      const bridgeNowRunning = !!(typeof getBridgeIsRunning === 'function' && getBridgeIsRunning());\n      if (!bridgeWasRunning && bridgeNowRunning) {\n        log('Context Engine Uploader: HTTP MCP bridge launching; delaying MCP config write until bridge signals ready.');\n        return;\n      }\n    }\n    const effectiveMode =\n      serverMode === 'bridge'\n        ? (transportMode === 'http' ? 'bridge-http' : 'bridge-stdio')\n        : (transportMode === 'http' ? 'direct-http' : 'direct-sse');\n    log(`Context Engine Uploader: MCP wiring mode=${effectiveMode} (serverMode=${serverMode}, transportMode=${transportMode}).`);\n    if (effectiveMode === 'bridge-http') {\n      const bridgeUrl = resolveBridgeHttpUrl();\n      if (bridgeUrl) {\n        log(`Context Engine Uploader: bridge HTTP endpoint ${bridgeUrl}`);\n      }\n    }\n\n    let indexerUrl = (settings.get('mcpIndexerUrl') || 'http://localhost:8003/mcp').trim();\n    let memoryUrl = (settings.get('mcpMemoryUrl') || 'http://localhost:8002/mcp').trim();\n    if (serverMode === 'bridge') {\n      indexerUrl = normalizeBridgeUrl(indexerUrl);\n      memoryUrl = normalizeBridgeUrl(memoryUrl);\n    }\n    let wroteAny = false;\n    let hookWrote = false;\n    if (wantsClaude) {\n      const root = getWorkspaceFolderPath();\n      if (!root) {\n        vscode.window.showErrorMessage('Context Engine Uploader: open a folder before writing .mcp.json.');\n      } else {\n        const result = await writeClaudeMcpServers(root, indexerUrl, memoryUrl, transportMode, serverMode);\n        wroteAny = wroteAny || result;\n      }\n    }\n    if (wantsWindsurf) {\n      const customPath = (settings.get('windsurfMcpPath') || '').trim();\n      const windsPath = customPath || getDefaultWindsurfMcpPath();\n      const workspaceHint = getWorkspaceFolderPath();\n      const result = await writeWindsurfMcpServers(windsPath, indexerUrl, memoryUrl, transportMode, serverMode, workspaceHint);\n      wroteAny = wroteAny || result;\n    }\n    if (wantsAugment) {\n      const customPath = (settings.get('augmentMcpPath') || '').trim();\n      const augPath = customPath || getDefaultAugmentMcpPath();\n      const workspaceHint = getWorkspaceFolderPath();\n      const result = await writeAugmentMcpServers(augPath, indexerUrl, memoryUrl, transportMode, serverMode, workspaceHint);\n      wroteAny = wroteAny || result;\n    }\n    if (claudeHookEnabled) {\n      const root = getWorkspaceFolderPath();\n      if (!root) {\n        vscode.window.showErrorMessage('Context Engine Uploader: open a folder before writing Claude hook config.');\n      } else if (!isLinux) {\n        vscode.window.showWarningMessage('Context Engine Uploader: Claude hook auto-config is only wired for Linux/dev-remote at this time.');\n      } else {\n        const commandPath = getClaudeHookCommand();\n        if (!commandPath) {\n          vscode.window.showErrorMessage('Context Engine Uploader: embedded Claude hook script not found in extension; .claude/settings.local.json was not updated.');\n          log('Claude hook config skipped because embedded ctx-hook-simple.sh could not be resolved.');\n        } else {\n          const result = await writeClaudeHookConfig(root, commandPath);\n          hookWrote = hookWrote || result;\n        }\n      }\n    }\n    if (settings.get('scaffoldCtxConfig', true)) {\n      try {\n        await writeCtxConfig();\n      } catch (error) {\n        log(`CTX config auto-scaffolding failed: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    if (!wroteAny && !hookWrote) {\n      // noop\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}