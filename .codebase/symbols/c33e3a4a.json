{
  "file_path": "/work/internal/sessionlog/manager.go",
  "file_hash": "cfe21ae9e3d5e38c4e5537bd6130f57a35ecf3f1",
  "updated_at": "2025-12-26T17:34:23.433114",
  "symbols": {
    "struct_Config_12": {
      "name": "Config",
      "type": "struct",
      "start_line": 12,
      "end_line": 25,
      "content_hash": "5353c00c3e19e564fedd5a3de572461d15136dec",
      "content": "type Config struct {\n\t// PostgreSQL connection string\n\tPostgresConnStr string\n\t// Instance ID for this Nexora instance\n\tInstanceID string\n\t// Enable logging (default: true)\n\tEnabled bool\n\t// Batch size for async writes (default: 50)\n\tBatchSize int\n\t// Batch timeout (default: 100ms)\n\tBatchTimeout time.Duration\n}\n\n// Manager manages session logging across PostgreSQL and SQLite",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Manager_26": {
      "name": "Manager",
      "type": "struct",
      "start_line": 26,
      "end_line": 38,
      "content_hash": "5a66d47b8fc8b4e73af41b5fe619c18f20121907",
      "content": "type Manager struct {\n\tconfig     Config\n\tpgLogger   *PostgreSQLLogger\n\tsessionID  string\n\tinstanceID string\n\tmu         sync.Mutex\n\teditQueue  []EditOperationLog\n\tviewQueue  []ViewOperationLog\n\tcloseChan  chan struct{}\n\twg         sync.WaitGroup\n}\n\n// NewManager creates a new session log manager",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewManager_39": {
      "name": "NewManager",
      "type": "function",
      "start_line": 39,
      "end_line": 76,
      "content_hash": "281f4b65e766684af9c86d879a37704dc36b0322",
      "content": "func NewManager(config Config) (*Manager, error) {\n\tif !config.Enabled {\n\t\treturn &Manager{config: config, closeChan: make(chan struct{})}, nil\n\t}\n\n\tif config.BatchSize == 0 {\n\t\tconfig.BatchSize = 50\n\t}\n\tif config.BatchTimeout == 0 {\n\t\tconfig.BatchTimeout = 100 * time.Millisecond\n\t}\n\n\tpgLogger, err := NewPostgreSQLLogger(config.PostgresConnStr)\n\tif err != nil {\n\t\tslog.Warn(\"Failed to initialize PostgreSQL logger\", \"error\", err)\n\t\t// Don't fail completely if PG is unavailable\n\t\tpgLogger = nil\n\t}\n\n\tm := &Manager{\n\t\tconfig:     config,\n\t\tpgLogger:   pgLogger,\n\t\tinstanceID: config.InstanceID,\n\t\tcloseChan:  make(chan struct{}),\n\t\teditQueue:  make([]EditOperationLog, 0, config.BatchSize),\n\t\tviewQueue:  make([]ViewOperationLog, 0, config.BatchSize),\n\t}\n\n\t// Start background flusher\n\tif pgLogger != nil {\n\t\tm.wg.Add(1)\n\t\tgo m.flusherLoop()\n\t}\n\n\treturn m, nil\n}\n\n// StartSession starts a new session",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StartSession_77": {
      "name": "StartSession",
      "type": "method",
      "start_line": 77,
      "end_line": 86,
      "content_hash": "eeb91784414c470def33033e46fc74ccf3e696c7",
      "content": "func (m *Manager) StartSession(ctx context.Context, sessionID string, metadata map[string]interface{}) error {\n\tif !m.config.Enabled || m.pgLogger == nil {\n\t\treturn nil\n\t}\n\n\tm.sessionID = sessionID\n\treturn m.pgLogger.SessionStart(ctx, sessionID, m.instanceID, metadata)\n}\n\n// EndSession ends the current session",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_EndSession_87": {
      "name": "EndSession",
      "type": "method",
      "start_line": 87,
      "end_line": 98,
      "content_hash": "d809dbf0548e0ea1dbb218a2fd47f8101ef07efd",
      "content": "func (m *Manager) EndSession(ctx context.Context, status string, errorCount, toolCount int) error {\n\tif !m.config.Enabled || m.pgLogger == nil {\n\t\treturn nil\n\t}\n\n\t// Flush any pending operations\n\tm.flush(ctx)\n\n\treturn m.pgLogger.SessionEnd(ctx, m.sessionID, status, errorCount, toolCount)\n}\n\n// LogEditOperation logs an edit operation asynchronously",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_LogEditOperation_99": {
      "name": "LogEditOperation",
      "type": "method",
      "start_line": 99,
      "end_line": 114,
      "content_hash": "a631fe3a41ea0c30a7d86f85cf8eef752ff0d4db",
      "content": "func (m *Manager) LogEditOperation(ctx context.Context, edit EditOperationLog) {\n\tif !m.config.Enabled || m.pgLogger == nil {\n\t\treturn\n\t}\n\n\tm.mu.Lock()\n\tm.editQueue = append(m.editQueue, edit)\n\tshouldFlush := len(m.editQueue) >= m.config.BatchSize\n\tm.mu.Unlock()\n\n\tif shouldFlush {\n\t\tm.flush(ctx)\n\t}\n}\n\n// LogViewOperation logs a view operation asynchronously",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_LogViewOperation_115": {
      "name": "LogViewOperation",
      "type": "method",
      "start_line": 115,
      "end_line": 130,
      "content_hash": "79dec697a3ae80ea0055d6818a23b4992ab0f134",
      "content": "func (m *Manager) LogViewOperation(ctx context.Context, view ViewOperationLog) {\n\tif !m.config.Enabled || m.pgLogger == nil {\n\t\treturn\n\t}\n\n\tm.mu.Lock()\n\tm.viewQueue = append(m.viewQueue, view)\n\tshouldFlush := len(m.viewQueue) >= m.config.BatchSize\n\tm.mu.Unlock()\n\n\tif shouldFlush {\n\t\tm.flush(ctx)\n\t}\n}\n\n// flush writes queued operations to PostgreSQL",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_flush_131": {
      "name": "flush",
      "type": "method",
      "start_line": 131,
      "end_line": 164,
      "content_hash": "3e4d22d6bab2869f3944ac3f846ca60848909d09",
      "content": "func (m *Manager) flush(ctx context.Context) {\n\tm.mu.Lock()\n\tedits := make([]EditOperationLog, len(m.editQueue))\n\tviews := make([]ViewOperationLog, len(m.viewQueue))\n\tcopy(edits, m.editQueue)\n\tcopy(views, m.viewQueue)\n\tm.editQueue = m.editQueue[:0]\n\tm.viewQueue = m.viewQueue[:0]\n\tm.mu.Unlock()\n\n\tif len(edits) == 0 && len(views) == 0 {\n\t\treturn\n\t}\n\n\t// Write to PostgreSQL in background\n\tgo func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\tfor _, edit := range edits {\n\t\t\tif err := m.pgLogger.EditOperation(ctx, edit); err != nil {\n\t\t\t\tslog.Error(\"Failed to log edit operation\", \"error\", err, \"file\", edit.FilePath)\n\t\t\t}\n\t\t}\n\n\t\tfor _, view := range views {\n\t\t\tif err := m.pgLogger.ViewOperation(ctx, view); err != nil {\n\t\t\t\tslog.Error(\"Failed to log view operation\", \"error\", err, \"file\", view.FilePath)\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// flusherLoop periodically flushes queued operations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_flusherLoop_165": {
      "name": "flusherLoop",
      "type": "method",
      "start_line": 165,
      "end_line": 181,
      "content_hash": "d1e127a04d4a8c1faae3ede353fbcb8bc5f02850",
      "content": "func (m *Manager) flusherLoop() {\n\tdefer m.wg.Done()\n\n\tticker := time.NewTicker(m.config.BatchTimeout)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-m.closeChan:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tm.flush(context.Background())\n\t\t}\n\t}\n}\n\n// Close closes the logger and flushes any pending operations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_182": {
      "name": "Close",
      "type": "method",
      "start_line": 182,
      "end_line": 195,
      "content_hash": "75d0a602eb2842aa49ca6fd111e273edf986a538",
      "content": "func (m *Manager) Close(ctx context.Context) error {\n\tclose(m.closeChan)\n\tm.wg.Wait()\n\n\t// Final flush\n\tm.flush(ctx)\n\n\tif m.pgLogger != nil {\n\t\treturn m.pgLogger.Close()\n\t}\n\treturn nil\n}\n\n// DefaultConfig returns a default configuration",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_DefaultConfig_196": {
      "name": "DefaultConfig",
      "type": "function",
      "start_line": 196,
      "end_line": 205,
      "content_hash": "691acf1352f93173ec4ddfa594bc7c5c5c427b68",
      "content": "func DefaultConfig() Config {\n\thostname, _ := os.Hostname()\n\treturn Config{\n\t\tPostgresConnStr: \"user=postgres dbname=nexora_sessions host=localhost sslmode=disable\",\n\t\tInstanceID:      hostname,\n\t\tEnabled:         true,\n\t\tBatchSize:       50,\n\t\tBatchTimeout:    100 * time.Millisecond,\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}