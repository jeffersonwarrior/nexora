{
  "file_path": "/work/internal/tui/components/chat/messages/messages.go",
  "file_hash": "a1833c53a44254b2b400bef2414d863ee8d8e0d3",
  "updated_at": "2025-12-26T17:34:23.425535",
  "symbols": {
    "interface_MessageCmp_35": {
      "name": "MessageCmp",
      "type": "interface",
      "start_line": 35,
      "end_line": 47,
      "content_hash": "ff4d983e144bb5ea136d4e423fe9427c19bd7d98",
      "content": "type MessageCmp interface {\n\tutil.Model                      // Basic Bubble util.Model interface\n\tcore.Sizeable                   // Width/height management\n\tcore.Focusable                  // Focus state management\n\tGetMessage() message.Message    // Access to underlying message data\n\tSetMessage(msg message.Message) // Update the message content\n\tSpinning() bool                 // Animation state for loading messages\n\tID() string\n}\n\n// messageCmp implements the MessageCmp interface for displaying chat messages.\n// It handles rendering of user and assistant messages with proper styling,\n// animations, and state management.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_messageCmp_48": {
      "name": "messageCmp",
      "type": "struct",
      "start_line": 48,
      "end_line": 65,
      "content_hash": "083d1802b2e059ff700891d5bf7c310b7a13d288",
      "content": "type messageCmp struct {\n\twidth   int  // Component width for text wrapping\n\tfocused bool // Focus state for border styling\n\n\t// Core message data and state\n\tmessage  message.Message // The underlying message content\n\tspinning bool            // Whether to show loading animation\n\tanim     *anim.Anim      // Animation component for loading states\n\n\t// Thinking viewport for displaying reasoning content\n\tthinkingViewport viewport.Model\n}\n\nvar focusedMessageBorder = lipgloss.Border{\n\tLeft: \"\u258c\",\n}\n\n// NewMessageCmp creates a new message component with the given message and options",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMessageCmp_66": {
      "name": "NewMessageCmp",
      "type": "function",
      "start_line": 66,
      "end_line": 87,
      "content_hash": "584bcbf4e53f57f3671aca45b14bd1c643fb8790",
      "content": "func NewMessageCmp(msg message.Message) MessageCmp {\n\tt := styles.CurrentTheme()\n\n\tthinkingViewport := viewport.New()\n\tthinkingViewport.SetHeight(1)\n\tthinkingViewport.KeyMap = viewport.KeyMap{}\n\n\tm := &messageCmp{\n\t\tmessage: msg,\n\t\tanim: anim.New(anim.Settings{\n\t\t\tSize:        15,\n\t\t\tGradColorA:  t.Primary,\n\t\t\tGradColorB:  t.Secondary,\n\t\t\tCycleColors: true,\n\t\t}),\n\t\tthinkingViewport: thinkingViewport,\n\t}\n\treturn m\n}\n\n// Init initializes the message component and starts animations if needed.\n// Returns a command to start the animation for spinning messages.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_88": {
      "name": "Init",
      "type": "method",
      "start_line": 88,
      "end_line": 94,
      "content_hash": "34d1de1ad05dc9def976f9dccaece3ba180c9603",
      "content": "func (m *messageCmp) Init() tea.Cmd {\n\tm.spinning = m.shouldSpin()\n\treturn m.anim.Init()\n}\n\n// Update handles incoming messages and updates the component state.\n// Manages animation updates for spinning messages and stops animation when appropriate.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_95": {
      "name": "Update",
      "type": "method",
      "start_line": 95,
      "end_line": 120,
      "content_hash": "c77d3194070b5991dabc57f3ea0e3c2f3a4f5708",
      "content": "func (m *messageCmp) Update(msg tea.Msg) (util.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase anim.StepMsg:\n\t\tm.spinning = m.shouldSpin()\n\t\tif m.spinning {\n\t\t\tu, cmd := m.anim.Update(msg)\n\t\t\tm.anim = u.(*anim.Anim)\n\t\t\treturn m, cmd\n\t\t}\n\tcase tea.KeyPressMsg:\n\t\tif key.Matches(msg, CopyKey) {\n\t\t\treturn m, tea.Sequence(\n\t\t\t\ttea.SetClipboard(m.message.Content().Text),\n\t\t\t\tfunc() tea.Msg {\n\t\t\t\t\t_ = clipboard.WriteAll(m.message.Content().Text)\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tutil.ReportInfo(\"Message copied to clipboard\"),\n\t\t\t)\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the message component based on its current state.\n// Returns different views for spinning, user, and assistant messages.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_121": {
      "name": "View",
      "type": "method",
      "start_line": 121,
      "end_line": 140,
      "content_hash": "bd4f875f9440c80ee7f5c5b1584614b2db5d804b",
      "content": "func (m *messageCmp) View() string {\n\tif m.spinning && m.message.ReasoningContent().Thinking == \"\" {\n\t\tif m.message.IsSummaryMessage {\n\t\t\tm.anim.SetLabel(\"Summarizing\")\n\t\t}\n\t\treturn m.style().PaddingLeft(1).Render(m.anim.View())\n\t}\n\tif m.message.ID != \"\" {\n\t\t// this is a user or assistant message\n\t\tswitch m.message.Role {\n\t\tcase message.User:\n\t\t\treturn m.renderUserMessage()\n\t\tdefault:\n\t\t\treturn m.renderAssistantMessage()\n\t\t}\n\t}\n\treturn m.style().Render(\"No message content\")\n}\n\n// GetMessage returns the underlying message data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetMessage_141": {
      "name": "GetMessage",
      "type": "method",
      "start_line": 141,
      "end_line": 144,
      "content_hash": "43256a115c45eac0fc76fcd08570266b3b66a762",
      "content": "func (m *messageCmp) GetMessage() message.Message {\n\treturn m.message\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetMessage_145": {
      "name": "SetMessage",
      "type": "method",
      "start_line": 145,
      "end_line": 150,
      "content_hash": "d537f6a86b148285f1087ef0874ca611702c8703",
      "content": "func (m *messageCmp) SetMessage(msg message.Message) {\n\tm.message = msg\n}\n\n// textWidth calculates the available width for text content,\n// accounting for borders and padding",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_textWidth_151": {
      "name": "textWidth",
      "type": "method",
      "start_line": 151,
      "end_line": 156,
      "content_hash": "79d374be49f4411c36a53788f2b803e6bf8fb422",
      "content": "func (m *messageCmp) textWidth() int {\n\treturn m.width - 2 // take into account the border and/or padding\n}\n\n// style returns the lipgloss style for the message component.\n// Applies different border colors and styles based on message role and focus state.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_style_157": {
      "name": "style",
      "type": "method",
      "start_line": 157,
      "end_line": 178,
      "content_hash": "3d89d539de5ce50ae344570c61e493eb10116c56",
      "content": "func (msg *messageCmp) style() lipgloss.Style {\n\tt := styles.CurrentTheme()\n\tborderStyle := lipgloss.NormalBorder()\n\tif msg.focused {\n\t\tborderStyle = focusedMessageBorder\n\t}\n\n\tstyle := t.S().Text\n\tif msg.message.Role == message.User {\n\t\tstyle = style.PaddingLeft(1).BorderLeft(true).BorderStyle(borderStyle).BorderForeground(t.Primary)\n\t} else {\n\t\tif msg.focused {\n\t\t\tstyle = style.PaddingLeft(1).BorderLeft(true).BorderStyle(borderStyle).BorderForeground(t.GreenDark)\n\t\t} else {\n\t\t\tstyle = style.PaddingLeft(2)\n\t\t}\n\t}\n\treturn style\n}\n\n// renderAssistantMessage renders assistant messages with optional footer information.\n// Shows model name, response time, and finish reason when the message is complete.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_renderAssistantMessage_179": {
      "name": "renderAssistantMessage",
      "type": "method",
      "start_line": 179,
      "end_line": 221,
      "content_hash": "d634f7f232549550f6cf62f59ec882e314f8a5fd",
      "content": "func (m *messageCmp) renderAssistantMessage() string {\n\tt := styles.CurrentTheme()\n\tparts := []string{}\n\tcontent := strings.TrimSpace(m.message.Content().String())\n\tthinking := m.message.IsThinking()\n\tthinkingContent := strings.TrimSpace(m.message.ReasoningContent().Thinking)\n\tfinished := m.message.IsFinished()\n\tfinishedData := m.message.FinishPart()\n\n\tif thinking || thinkingContent != \"\" {\n\t\tm.anim.SetLabel(\"Thinking\")\n\t\tthinkingContent = m.renderThinkingContent()\n\t} else if finished && content == \"\" && finishedData.Reason == message.FinishReasonEndTurn {\n\t\t// Don't render empty assistant messages with EndTurn\n\t\treturn \"\"\n\t} else if finished && content == \"\" && finishedData.Reason == message.FinishReasonCanceled {\n\t\tcontent = \"*Canceled*\"\n\t} else if finished && content == \"\" && finishedData.Reason == message.FinishReasonError {\n\t\terrTag := t.S().Base.Padding(0, 1).Background(t.Red).Foreground(t.White).Render(\"ERROR\")\n\t\ttruncated := ansi.Truncate(finishedData.Message, m.textWidth()-2-lipgloss.Width(errTag), \"...\")\n\t\ttitle := fmt.Sprintf(\"%s %s\", errTag, t.S().Base.Foreground(t.FgHalfMuted).Render(truncated))\n\t\tdetails := t.S().Base.Foreground(t.FgSubtle).Width(m.textWidth() - 2).Render(finishedData.Details)\n\t\terrorContent := fmt.Sprintf(\"%s\\n\\n%s\", title, details)\n\t\treturn m.style().Render(errorContent)\n\t}\n\n\tif thinkingContent != \"\" {\n\t\tparts = append(parts, thinkingContent)\n\t}\n\n\tif content != \"\" {\n\t\tif thinkingContent != \"\" {\n\t\t\tparts = append(parts, \"\")\n\t\t}\n\t\tparts = append(parts, m.toMarkdown(content))\n\t}\n\n\tjoined := lipgloss.JoinVertical(lipgloss.Left, parts...)\n\treturn m.style().Render(joined)\n}\n\n// renderUserMessage renders user messages with file attachments. It displays\n// message content and any attached files with appropriate icons.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_renderUserMessage_222": {
      "name": "renderUserMessage",
      "type": "method",
      "start_line": 222,
      "end_line": 251,
      "content_hash": "16d426fb571ab057f0c3bd45e29673003a387df9",
      "content": "func (m *messageCmp) renderUserMessage() string {\n\tt := styles.CurrentTheme()\n\tparts := []string{\n\t\tm.toMarkdown(m.message.Content().String()),\n\t}\n\n\tattachmentStyles := t.S().Text.\n\t\tMarginLeft(1).\n\t\tBackground(t.BgSubtle)\n\n\tattachments := make([]string, len(m.message.BinaryContent()))\n\tfor i, attachment := range m.message.BinaryContent() {\n\t\tconst maxFilenameWidth = 10\n\t\tfilename := filepath.Base(attachment.Path)\n\t\tattachments[i] = attachmentStyles.Render(fmt.Sprintf(\n\t\t\t\" %s %s \",\n\t\t\tstyles.DocumentIcon,\n\t\t\tansi.Truncate(filename, maxFilenameWidth, \"...\"),\n\t\t))\n\t}\n\n\tif len(attachments) > 0 {\n\t\tparts = append(parts, \"\", strings.Join(attachments, \"\"))\n\t}\n\n\tjoined := lipgloss.JoinVertical(lipgloss.Left, parts...)\n\treturn m.style().Render(joined)\n}\n\n// toMarkdown converts text content to rendered markdown using the configured renderer",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_toMarkdown_252": {
      "name": "toMarkdown",
      "type": "method",
      "start_line": 252,
      "end_line": 257,
      "content_hash": "aa93330b4c88410acd4026dd09af7ea8fea20a92",
      "content": "func (m *messageCmp) toMarkdown(content string) string {\n\tr := styles.GetMarkdownRenderer(m.textWidth())\n\trendered, _ := r.Render(content)\n\treturn strings.TrimSuffix(rendered, \"\\n\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_renderThinkingContent_258": {
      "name": "renderThinkingContent",
      "type": "method",
      "start_line": 258,
      "end_line": 320,
      "content_hash": "48e46f99b04a5cc359bc68ae63adcc8283db1e78",
      "content": "func (m *messageCmp) renderThinkingContent() string {\n\tt := styles.CurrentTheme()\n\treasoningContent := m.message.ReasoningContent()\n\tif strings.TrimSpace(reasoningContent.Thinking) == \"\" {\n\t\treturn \"\"\n\t}\n\n\twidth := m.textWidth() - 2\n\twidth = min(width, 120)\n\n\trenderer := styles.GetPlainMarkdownRenderer(width - 1)\n\trendered, err := renderer.Render(reasoningContent.Thinking)\n\tif err != nil {\n\t\tlines := strings.Split(reasoningContent.Thinking, \"\\n\")\n\t\tvar content strings.Builder\n\t\tlineStyle := t.S().Subtle.Background(t.BgBaseLighter)\n\t\tfor i, line := range lines {\n\t\t\tif line == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcontent.WriteString(lineStyle.Width(width).Render(line))\n\t\t\tif i < len(lines)-1 {\n\t\t\t\tcontent.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\t\trendered = content.String()\n\t}\n\n\tfullContent := strings.TrimSpace(rendered)\n\theight := ordered.Clamp(lipgloss.Height(fullContent), 1, 10)\n\tm.thinkingViewport.SetHeight(height)\n\tm.thinkingViewport.SetWidth(m.textWidth())\n\tm.thinkingViewport.SetContent(fullContent)\n\tm.thinkingViewport.GotoBottom()\n\tfinishReason := m.message.FinishPart()\n\tvar footer string\n\tif reasoningContent.StartedAt > 0 {\n\t\tduration := m.message.ThinkingDuration()\n\t\tif reasoningContent.FinishedAt > 0 {\n\t\t\tm.anim.SetLabel(\"\")\n\t\t\topts := core.StatusOpts{\n\t\t\t\tTitle:       \"Thought for\",\n\t\t\t\tDescription: duration.String(),\n\t\t\t}\n\t\t\tif duration.String() != \"0s\" {\n\t\t\t\tfooter = t.S().Base.PaddingLeft(1).Render(core.Status(opts, m.textWidth()-1))\n\t\t\t}\n\t\t} else if finishReason != nil && finishReason.Reason == message.FinishReasonCanceled {\n\t\t\tfooter = t.S().Base.PaddingLeft(1).Render(m.toMarkdown(\"*Canceled*\"))\n\t\t} else {\n\t\t\tfooter = m.anim.View()\n\t\t}\n\t}\n\tlineStyle := t.S().Subtle.Background(t.BgBaseLighter)\n\tresult := lineStyle.Width(m.textWidth()).Padding(0, 1).Render(m.thinkingViewport.View())\n\tif footer != \"\" {\n\t\tresult += \"\\n\\n\" + footer\n\t}\n\treturn result\n}\n\n// shouldSpin determines whether the message should show a loading animation.\n// Only assistant messages without content that aren't finished should spin.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldSpin_321": {
      "name": "shouldSpin",
      "type": "method",
      "start_line": 321,
      "end_line": 339,
      "content_hash": "d35a79baf8a3a024a4d3d1b0461f8a68a19db072",
      "content": "func (m *messageCmp) shouldSpin() bool {\n\tif m.message.Role != message.Assistant {\n\t\treturn false\n\t}\n\n\tif m.message.IsFinished() {\n\t\treturn false\n\t}\n\n\tif strings.TrimSpace(m.message.Content().Text) != \"\" {\n\t\treturn false\n\t}\n\tif len(m.message.ToolCalls()) > 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Blur removes focus from the message component",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Blur_340": {
      "name": "Blur",
      "type": "method",
      "start_line": 340,
      "end_line": 345,
      "content_hash": "7710c0febd2e7a40ccf6b43a06798978bcafe5b2",
      "content": "func (m *messageCmp) Blur() tea.Cmd {\n\tm.focused = false\n\treturn nil\n}\n\n// Focus sets focus on the message component",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Focus_346": {
      "name": "Focus",
      "type": "method",
      "start_line": 346,
      "end_line": 351,
      "content_hash": "4e80fa8cc16633ee75b0dd719da376ccb1f347fc",
      "content": "func (m *messageCmp) Focus() tea.Cmd {\n\tm.focused = true\n\treturn nil\n}\n\n// IsFocused returns whether the message component is currently focused",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsFocused_352": {
      "name": "IsFocused",
      "type": "method",
      "start_line": 352,
      "end_line": 358,
      "content_hash": "bd6b9e654062788ce6bc1431689137fdb19bca50",
      "content": "func (m *messageCmp) IsFocused() bool {\n\treturn m.focused\n}\n\n// Size management methods\n\n// GetSize returns the current dimensions of the message component",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_359": {
      "name": "GetSize",
      "type": "method",
      "start_line": 359,
      "end_line": 363,
      "content_hash": "79588c2c19047ce35713e293496f62010378efc1",
      "content": "func (m *messageCmp) GetSize() (int, int) {\n\treturn m.width, 0\n}\n\n// SetSize updates the width of the message component for text wrapping",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_364": {
      "name": "SetSize",
      "type": "method",
      "start_line": 364,
      "end_line": 370,
      "content_hash": "90da3cd8b93c22896d8985f0058f3cb840a930a5",
      "content": "func (m *messageCmp) SetSize(width int, height int) tea.Cmd {\n\tm.width = ordered.Clamp(width, 1, 120)\n\tm.thinkingViewport.SetWidth(m.width - 4)\n\treturn nil\n}\n\n// Spinning returns whether the message is currently showing a loading animation",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Spinning_371": {
      "name": "Spinning",
      "type": "method",
      "start_line": 371,
      "end_line": 374,
      "content_hash": "cc2221ae81013b61018f503f604bf35e9a62fcf9",
      "content": "func (m *messageCmp) Spinning() bool {\n\treturn m.spinning\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_AssistantSection_375": {
      "name": "AssistantSection",
      "type": "interface",
      "start_line": 375,
      "end_line": 378,
      "content_hash": "5c5850de86ccd441ab3e75dd5f1eed1efbf6001d",
      "content": "type AssistantSection interface {\n\tlist.Item\n\tcore.Sizeable\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_assistantSectionModel_379": {
      "name": "assistantSectionModel",
      "type": "struct",
      "start_line": 379,
      "end_line": 386,
      "content_hash": "57716ff91a7d5cdb2874683df730ae7441213dd1",
      "content": "type assistantSectionModel struct {\n\twidth               int\n\tid                  string\n\tmessage             message.Message\n\tlastUserMessageTime time.Time\n}\n\n// ID implements AssistantSection.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ID_387": {
      "name": "ID",
      "type": "method",
      "start_line": 387,
      "end_line": 390,
      "content_hash": "6cff6ab2a3d38ca1e521349c9da7107742935aa9",
      "content": "func (m *assistantSectionModel) ID() string {\n\treturn m.id\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewAssistantSection_391": {
      "name": "NewAssistantSection",
      "type": "function",
      "start_line": 391,
      "end_line": 399,
      "content_hash": "d7ec901e973cc073ce8d61b846f0e11623d7107e",
      "content": "func NewAssistantSection(message message.Message, lastUserMessageTime time.Time) AssistantSection {\n\treturn &assistantSectionModel{\n\t\twidth:               0,\n\t\tid:                  uuid.NewString(),\n\t\tmessage:             message,\n\t\tlastUserMessageTime: lastUserMessageTime,\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_400": {
      "name": "Init",
      "type": "method",
      "start_line": 400,
      "end_line": 403,
      "content_hash": "6197b7f338c56f13dbf3eb041a20b5be7b03ccad",
      "content": "func (m *assistantSectionModel) Init() tea.Cmd {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_404": {
      "name": "Update",
      "type": "method",
      "start_line": 404,
      "end_line": 407,
      "content_hash": "7705981f747fdb638ced565223b71b61b5b3815f",
      "content": "func (m *assistantSectionModel) Update(tea.Msg) (util.Model, tea.Cmd) {\n\treturn m, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_408": {
      "name": "View",
      "type": "method",
      "start_line": 408,
      "end_line": 440,
      "content_hash": "cd8c5a00d6ead7931801934eb6fff02b71b08c2f",
      "content": "func (m *assistantSectionModel) View() string {\n\tt := styles.CurrentTheme()\n\tfinishData := m.message.FinishPart()\n\tfinishTime := time.Unix(finishData.Time, 0)\n\tduration := finishTime.Sub(m.lastUserMessageTime)\n\tinfoMsg := t.S().Subtle.Render(duration.String())\n\ticon := t.S().Subtle.Render(styles.ModelIcon)\n\tmodel := config.Get().GetModel(m.message.Provider, m.message.Model)\n\n\tvar modelName string\n\tif model != nil {\n\t\t// Found model in config - use its display name\n\t\tmodelName = model.Name\n\t} else if m.message.Provider != \"\" && m.message.Model != \"\" {\n\t\t// Model not found in config (e.g., local model), show raw provider/model\n\t\t// Format: \"Provider/Model\" or just \"Model\" if provider is generic\n\t\tif m.message.Provider == \"local\" || m.message.Provider == \"openai-compat\" {\n\t\t\tmodelName = m.message.Model // Just show model name for local providers\n\t\t} else {\n\t\t\tmodelName = fmt.Sprintf(\"%s/%s\", m.message.Provider, m.message.Model)\n\t\t}\n\t} else {\n\t\t// No provider/model info available\n\t\tmodelName = \"Unknown Model\"\n\t}\n\n\tmodelFormatted := t.S().Muted.Render(modelName)\n\tassistant := fmt.Sprintf(\"%s %s %s\", icon, modelFormatted, infoMsg)\n\treturn t.S().Base.PaddingLeft(2).Render(\n\t\tcore.Section(assistant, m.width-2),\n\t)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_441": {
      "name": "GetSize",
      "type": "method",
      "start_line": 441,
      "end_line": 444,
      "content_hash": "de29e7209bc7487c5bc69451bcb0046c973d35a0",
      "content": "func (m *assistantSectionModel) GetSize() (int, int) {\n\treturn m.width, 1\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_445": {
      "name": "SetSize",
      "type": "method",
      "start_line": 445,
      "end_line": 449,
      "content_hash": "846cbfc7c1c32711149cd19adc585f1851f0b57b",
      "content": "func (m *assistantSectionModel) SetSize(width int, height int) tea.Cmd {\n\tm.width = width\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsSectionHeader_450": {
      "name": "IsSectionHeader",
      "type": "method",
      "start_line": 450,
      "end_line": 453,
      "content_hash": "48cc383f376a75cc41a88a47cf5e225369825266",
      "content": "func (m *assistantSectionModel) IsSectionHeader() bool {\n\treturn true\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ID_454": {
      "name": "ID",
      "type": "method",
      "start_line": 454,
      "end_line": 456,
      "content_hash": "f123d2b49fb09762bc89220ba8367aecadbb2c4f",
      "content": "func (m *messageCmp) ID() string {\n\treturn m.message.ID\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}