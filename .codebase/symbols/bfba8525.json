{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/generator/queries.rs",
  "file_hash": "fd16647f84a473fd1f0b9bb45d56ed6901ce5eb9",
  "updated_at": "2025-12-26T17:34:23.736445",
  "symbols": {
    "struct_Query_9": {
      "name": "Query",
      "type": "struct",
      "start_line": 9,
      "end_line": 22,
      "content_hash": "72a01884eab94b4ce4cef30f876a56b3584217a1",
      "content": "pub struct Query {\n    pub embedding_model_to_use: Option<String>,\n    pub mcp_handler: Option<String>,\n    pub name: String,\n    pub statements: Vec<Statement>,\n    pub parameters: Vec<Parameter>, // iterate through and print each one\n    pub sub_parameters: Vec<(String, Vec<Parameter>)>,\n    pub return_values: Vec<(String, ReturnValue)>, // Legacy approach\n    pub return_structs: Vec<ReturnValueStruct>,    // New struct-based approach\n    pub use_struct_returns: bool,                  // Flag to use new vs old approach\n    pub is_mut: bool,\n    pub hoisted_embedding_calls: Vec<EmbedData>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Query_23": {
      "name": "Query",
      "type": "impl",
      "start_line": 23,
      "end_line": 23,
      "content_hash": "c6917d5bd3578e55a007c380e491a9dd2194c3dc",
      "content": "impl Query {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_handler_24": {
      "name": "print_handler",
      "type": "method",
      "start_line": 24,
      "end_line": 31,
      "content_hash": "28362b1cc6c7023227f190ff491a651f313d7e2d",
      "content": "    fn print_handler(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.is_mut {\n            writeln!(f, \"#[handler(is_write)]\")\n        } else {\n            writeln!(f, \"#[handler]\")\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_parameters_32": {
      "name": "print_parameters",
      "type": "method",
      "start_line": 32,
      "end_line": 43,
      "content_hash": "8ce7b294d70f30db099ff108a0b629a764e64808",
      "content": "    fn print_parameters(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for (name, parameters) in &self.sub_parameters {\n            writeln!(f, \"#[derive(Serialize, Deserialize, Clone)]\")?;\n            writeln!(f, \"pub struct {name} {{\")?;\n            for parameter in parameters {\n                writeln!(f, \"    pub {}: {},\", parameter.name, parameter.field_type)?;\n            }\n            writeln!(f, \"}}\")?;\n        }\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_return_values_44": {
      "name": "print_return_values",
      "type": "method",
      "start_line": 44,
      "end_line": 55,
      "content_hash": "6812353817f668bfd8af930f5055552001fba002",
      "content": "    fn print_return_values(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.use_struct_returns {\n            // Generate struct definitions for new approach (including nested structs)\n            for struct_def in &self.return_structs {\n                write!(f, \"{}\", struct_def.generate_all_struct_defs())?;\n                writeln!(f)?;\n            }\n        }\n        // Legacy approach doesn't need struct generation (uses json! macro)\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_input_struct_56": {
      "name": "print_input_struct",
      "type": "method",
      "start_line": 56,
      "end_line": 71,
      "content_hash": "8c9adc33cf173e2609fea3033f890f8271f8dc49",
      "content": "    fn print_input_struct(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        writeln!(f, \"#[derive(Serialize, Deserialize, Clone)]\")?;\n        writeln!(f, \"pub struct {}Input {{\\n\", self.name)?;\n        write!(\n            f,\n            \"{}\",\n            self.parameters\n                .iter()\n                .map(|p| format!(\"{p}\"))\n                .collect::<Vec<_>>()\n                .join(\",\\n\")\n        )?;\n        write!(f, \"\\n}}\\n\")?;\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_hoisted_embedding_calls_72": {
      "name": "print_hoisted_embedding_calls",
      "type": "method",
      "start_line": 72,
      "end_line": 98,
      "content_hash": "c58e6b816fa588b08d93cbab1e99e6edd6e5af66",
      "content": "    fn print_hoisted_embedding_calls(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if !self.hoisted_embedding_calls.is_empty() {\n            writeln!(\n                f,\n                \"Err(IoContFn::create_err(move |__internal_cont_tx, __internal_ret_chan| Box::pin(async move {{\"\n            )?;\n            // ((({ })))\n\n            for (i, embed) in self.hoisted_embedding_calls.iter().enumerate() {\n                let name = EmbedData::name_from_index(i);\n                writeln!(f, \"let {name} = {embed};\")?;\n            }\n\n            writeln!(\n                f,\n                \"__internal_cont_tx.send_async((__internal_ret_chan, Box::new(move || {{\"\n            )?;\n            // ((({ }))).await.expect(\"Cont Channel should be alive\")\n\n            for (i, _) in self.hoisted_embedding_calls.iter().enumerate() {\n                let name = EmbedData::name_from_index(i);\n                writeln!(f, \"let {name}: Vec<f64> = {name}?;\")?;\n            }\n        }\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_txn_commit_99": {
      "name": "print_txn_commit",
      "type": "method",
      "start_line": 99,
      "end_line": 105,
      "content_hash": "02ba7bdebeab4711ffb182099fb21a7eaed8c8de",
      "content": "    fn print_txn_commit(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        writeln!(\n            f,\n            \"txn.commit().map_err(|e| GraphError::New(format!(\\\"Failed to commit transaction: {{:?}}\\\", e)))?;\"\n        )\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_query_106": {
      "name": "print_query",
      "type": "method",
      "start_line": 106,
      "end_line": 807,
      "content_hash": "7f7c21fb0a83cd2ae90d3f02baa413680d5af70c",
      "content": "    fn print_query(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // prints the function signature\n        if !self.parameters.is_empty() {\n            self.print_input_struct(f)?;\n            self.print_parameters(f)?;\n        }\n        if !self.return_values.is_empty() {\n            self.print_return_values(f)?;\n        }\n\n        self.print_handler(f)?;\n        writeln!(\n            f,\n            \"pub fn {} (input: HandlerInput) -> Result<Response, GraphError> {{\",\n            self.name\n        )?;\n\n        // print the db boilerplate\n        writeln!(f, \"let db = Arc::clone(&input.graph.storage);\")?;\n        if !self.parameters.is_empty() {\n            match self.hoisted_embedding_calls.is_empty() {\n                true => writeln!(\n                    f,\n                    \"let data = input.request.in_fmt.deserialize::<{}Input>(&input.request.body)?;\",\n                    self.name\n                )?,\n                false => writeln!(\n                    f,\n                    \"let data = input.request.in_fmt.deserialize::<{}Input>(&input.request.body)?.into_owned();\",\n                    self.name\n                )?,\n            }\n        }\n\n        // print embedding calls\n        self.print_hoisted_embedding_calls(f)?;\n        writeln!(f, \"let arena = Bump::new();\")?;\n\n        match self.is_mut {\n            true => writeln!(\n                f,\n                \"let mut txn = db.graph_env.write_txn().map_err(|e| GraphError::New(format!(\\\"Failed to start write transaction: {{:?}}\\\", e)))?;\"\n            )?,\n            false => writeln!(\n                f,\n                \"let txn = db.graph_env.read_txn().map_err(|e| GraphError::New(format!(\\\"Failed to start read transaction: {{:?}}\\\", e)))?;\"\n            )?,\n        }\n\n        // prints each statement\n        for statement in &self.statements {\n            writeln!(f, \"    {statement};\")?;\n        }\n\n        // Generate return value\n        if self.use_struct_returns && !self.return_structs.is_empty() {\n            // New struct-based approach - map during response construction\n            write!(f, \"let response = json!({{\")?;\n            for (i, struct_def) in self.return_structs.iter().enumerate() {\n                if i > 0 {\n                    write!(f, \",\")?;\n                }\n                writeln!(f)?;\n\n                if struct_def.is_aggregate {\n                    // Aggregate/GroupBy - return the enum directly (it already implements Serialize)\n                    writeln!(\n                        f,\n                        \"    \\\"{}\\\": {}\",\n                        struct_def.source_variable,\n                        struct_def.source_variable\n                    )?;\n                } else if struct_def.source_variable.is_empty() {\n                    // Object literal - construct from multiple sources\n                    // Generate each field from the object literal\n                    for (field_idx, field) in struct_def.fields.iter().enumerate() {\n                        if field_idx > 0 {\n                            write!(f, \",\")?;\n                            writeln!(f)?;\n                        }\n\n                        let field_info = &struct_def.field_infos[field_idx];\n\n                        // Determine how to construct this field based on its source\n                        let field_value = match &field_info.source {\n                            crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                closure_source_var: Some(source_var),\n                                accessed_field_name: Some(prop_name),\n                                nested_struct_name: None,\n                                ..\n                            } => {\n                                // Simple property access like app::{name}\n                                if prop_name == \"id\" {\n                                    format!(\"uuid_str({}.id(), &arena)\", source_var)\n                                } else if prop_name == \"label\" {\n                                    format!(\"{}.label()\", source_var)\n                                } else {\n                                    format!(\"{}.get_property(\\\"{}\\\")\", source_var, prop_name)\n                                }\n                            }\n                            _ if matches!(\n                                field_info.field_type,\n                                crate::helixc::generator::return_values::ReturnFieldType::Nested(_)\n                            ) => {\n                                // Nested struct or object - need to construct recursively\n                                let nested_fields = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(fields) = &field_info.field_type {\n                                    fields\n                                } else {\n                                    panic!(\"Expected nested field type\");\n                                };\n\n                                // Extract nested struct name and source var from field info\n                                let (nested_struct_name, source_var) = match &field_info.source {\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        closure_source_var: Some(src),\n                                        nested_struct_name: Some(name),\n                                        ..\n                                    } => (Some(name.clone()), Some(src.clone())),\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        closure_source_var: Some(src),\n                                        ..\n                                    } => (None, Some(src.clone())),\n                                    _ => (None, None),\n                                };\n\n                                // Check if this is a collection (Vec)\n                                let is_vec = field.field_type.starts_with(\"Vec<\");\n\n                                if is_vec {\n                                    // Generate construction for each element\n                                    if let Some(src_var) = source_var {\n                                        let struct_name = nested_struct_name.as_deref().unwrap_or(\"UnknownStruct\");\n\n                                        format!(\"vec![{}].into_iter().map(|item| {} {{\\n{}            \\n}}).collect::<Vec<_>>()\",\n                                            src_var,\n                                            struct_name,\n                                            nested_fields.iter().map(|f| {\n                                                let val = if f.name == \"id\" {\n                                                    \"uuid_str(item.id(), &arena)\".to_string()\n                                                } else if f.name == \"label\" {\n                                                    \"item.label()\".to_string()\n                                                } else {\n                                                    format!(\"item.get_property(\\\"{}\\\")\", f.name)\n                                                };\n                                                format!(\"                {}: {},\", f.name, val)\n                                            }).collect::<Vec<_>>().join(\"\\n\")\n                                        )\n                                    } else {\n                                        \"Vec::new()\".to_string()\n                                    }\n                                } else {\n                                    // Single nested object\n                                    if let (Some(struct_name), Some(src_var)) = (nested_struct_name.as_ref(), source_var.as_ref()) {\n                                        format!(\"{} {{\\n{}            \\n}}\",\n                                            struct_name,\n                                            nested_fields.iter().map(|f| {\n                                                let val = if f.name == \"id\" {\n                                                    format!(\"uuid_str({}.id(), &arena)\", src_var)\n                                                } else if f.name == \"label\" {\n                                                    format!(\"{}.label()\", src_var)\n                                                } else {\n                                                    format!(\"{}.get_property(\\\"{}\\\")\", src_var, f.name)\n                                                };\n                                                format!(\"                {}: {},\", f.name, val)\n                                            }).collect::<Vec<_>>().join(\"\\n\")\n                                        )\n                                    } else {\n                                        \"serde_json::Value::Null\".to_string()\n                                    }\n                                }\n                            }\n                            _ => {\n                                // Fallback\n                                \"serde_json::Value::Null\".to_string()\n                            }\n                        };\n\n                        write!(f, \"    \\\"{}\\\": {}\", field.name, field_value)?;\n                    }\n                } else if struct_def.is_collection {\n                    // Collection - generate mapping code\n                    let singular_var = struct_def.source_variable.trim_end_matches('s');\n                    // Check if any field is a nested traversal (needs Result handling)\n                    let has_nested = struct_def.fields.iter().any(|f| f.is_nested_traversal);\n\n                    if has_nested {\n                        writeln!(\n                            f,\n                            \"    \\\"{}\\\": {}.iter().map(|{}| Ok::<_, GraphError>({} {{\",\n                            struct_def.source_variable,\n                            struct_def.source_variable,\n                            singular_var,\n                            struct_def.name\n                        )?;\n                    } else {\n                        writeln!(\n                            f,\n                            \"    \\\"{}\\\": {}.iter().map(|{}| {} {{\",\n                            struct_def.source_variable,\n                            struct_def.source_variable,\n                            singular_var,\n                            struct_def.name\n                        )?;\n                    }\n\n                    // Generate field assignments\n                    for (field_idx, field) in struct_def.fields.iter().enumerate() {\n                        let field_value = if field.is_nested_traversal {\n                            // Get the nested traversal info from field_infos\n                            let field_info = &struct_def.field_infos[field_idx];\n\n                            // Handle scalar nested traversals with closure parameters (e.g., username: u::{name})\n                            // or anonymous traversals (e.g., creatorID: _::In<Created>::ID)\n                            if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                closure_source_var: Some(closure_var),\n                                accessed_field_name: accessed_field,\n                                nested_struct_name: None,\n                                ..\n                            } = &field_info.source {\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let resolved_var = if closure_var == \"_\" || closure_var == \"val\" {\n                                    singular_var\n                                } else {\n                                    closure_var.as_str()\n                                };\n\n                                // This is a scalar field accessing a closure parameter or anonymous variable\n                                let field_to_access = accessed_field.as_ref()\n                                    .map(|s| s.as_str())\n                                    .unwrap_or(field.name.as_str());\n\n                                if field_to_access == \"id\" || field_to_access == \"ID\" {\n                                    format!(\"uuid_str({}.id(), &arena)\", resolved_var)\n                                } else if field_to_access == \"label\" || field_to_access == \"Label\" {\n                                    format!(\"{}.label()\", resolved_var)\n                                } else {\n                                    format!(\"{}.get_property(\\\"{}\\\")\", resolved_var, field_to_access)\n                                }\n                            } else if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                traversal_code: Some(trav_code),\n                                nested_struct_name: Some(nested_name),\n                                traversal_type,\n                                closure_source_var,\n                                closure_param_name,\n                                own_closure_param,\n                                ..\n                            } = &field_info.source {\n                                // Generate nested traversal code\n                                let nested_fields = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(fields) = &field_info.field_type {\n                                    fields\n                                } else {\n                                    panic!(\"Nested traversal must have Nested field type\");\n                                };\n\n                                // Extract the actual source variable from the traversal type\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let (source_var, is_single_source) = if let Some(trav_type) = traversal_type {\n                                    use crate::helixc::generator::traversal_steps::TraversalType;\n                                    match trav_type {\n                                        TraversalType::FromSingle(var) => {\n                                            let v = var.inner();\n                                            // Resolve placeholders: both \"_\" and \"val\" should use the iteration variable\n                                            let resolved = if v == \"_\" || v == \"val\" { singular_var } else { v.as_str() };\n                                            (resolved.to_string(), true)\n                                        }\n                                        TraversalType::FromIter(var) => {\n                                            let v = var.inner();\n                                            // Resolve placeholders: both \"_\" and \"val\" should use the iteration variable\n                                            let resolved = if v == \"_\" || v == \"val\" { singular_var } else { v.as_str() };\n                                            (resolved.to_string(), false)\n                                        }\n                                        _ => {\n                                            (singular_var.to_string(), false)\n                                        }\n                                    }\n                                } else {\n                                    (singular_var.to_string(), false)\n                                };\n\n                                // Determine if we need iter().cloned() or std::iter::once()\n                                let iterator_expr = if is_single_source {\n                                    format!(\"std::iter::once({}.clone())\", source_var)\n                                } else {\n                                    format!(\"{}.iter().cloned()\", source_var)\n                                };\n\n                                // Determine the closure parameter name to use in .map(|param| ...)\n                                // Prefer own_closure_param (this traversal's closure), otherwise use closure_param_name (parent context)\n                                let closure_param = own_closure_param.as_ref()\n                                    .or(closure_param_name.as_ref())\n                                    .map(|s| s.as_str())\n                                    .filter(|s| !s.is_empty() && *s != \"_\" && *s != \"val\")\n                                    .unwrap_or(\"item\");\n\n                                // Generate field assignments for nested struct\n                                // Check if we're in a closure context, resolve \"_\" placeholder\n                                let _closure_context_var = closure_source_var.as_ref()\n                                    .map(|s| if s == \"_\" { singular_var } else { s.as_str() })\n                                    .unwrap_or(singular_var);\n\n                                let mut nested_field_assigns = String::new();\n                                for nested_field in nested_fields {\n                                    // Check if this nested field is itself a nested traversal with a nested struct\n                                    let nested_val = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        traversal_code: Some(inner_trav_code),\n                                        nested_struct_name: Some(inner_nested_name),\n                                        traversal_type: inner_traversal_type,\n                                        ..\n                                    } = &nested_field.source {\n                                        // This is a deeply nested traversal - generate nested traversal code\n\n                                        // Extract the source variable for this deeply nested traversal\n                                        let inner_source_var = if let Some(inner_trav_type) = inner_traversal_type {\n                                            use crate::helixc::generator::traversal_steps::TraversalType;\n                                            match inner_trav_type {\n                                                TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                                    let v = var.inner();\n                                                    // Resolve placeholders: \"_\" and \"val\" should use \"item\" in nested context\n                                                    if v == \"_\" || v == \"val\" { \"item\" } else { v }\n                                                }\n                                                _ => \"item\"\n                                            }\n                                        } else {\n                                            \"item\"\n                                        };\n\n                                        // Get the nested fields if available\n                                        let inner_fields_str = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(inner_fields) = &nested_field.field_type {\n                                            // Generate field assignments for the deeply nested struct\n                                            let mut inner_assigns = String::new();\n                                            for inner_f in inner_fields {\n                                                let inner_val = if inner_f.name == \"id\" {\n                                                    \"uuid_str(inner_item.id(), &arena)\".to_string()\n                                                } else if inner_f.name == \"label\" {\n                                                    \"inner_item.label()\".to_string()\n                                                } else {\n                                                    format!(\"inner_item.get_property(\\\"{}\\\")\", inner_f.name)\n                                                };\n                                                inner_assigns.push_str(&format!(\"\\n{}: {},\", inner_f.name, inner_val));\n                                            }\n                                            format!(\".map(|inner_item| inner_item.map(|inner_item| {} {{{}\\n}})).collect::<Result<Vec<_>, _>>()?\", inner_nested_name, inner_assigns)\n                                        } else {\n                                            \".collect::<Vec<_>>()\".to_string()\n                                        };\n                                        format!(\"G::from_iter(&db, &txn, std::iter::once({}.clone()), &arena){}{}\", inner_source_var, inner_trav_code, inner_fields_str)\n                                    } else {\n                                        // Check if this field itself is a nested traversal that accesses the closure parameter\n                                        // Extract both the access variable and the actual field being accessed\n                                        let (access_var, accessed_field_name) = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                            closure_source_var: Some(closure_var),\n                                            accessed_field_name: accessed_field,\n                                            ..\n                                        } = &nested_field.source {\n                                            // Use the accessed_field_name from the metadata if available,\n                                            // otherwise fall back to the field name\n                                            let field_to_access = accessed_field.as_ref()\n                                                .map(|s| s.as_str())\n                                                .unwrap_or(nested_field.name.as_str());\n                                            (closure_var.as_str(), field_to_access)\n                                        } else {\n                                            (closure_param, nested_field.name.as_str())\n                                        };\n\n                                        if accessed_field_name == \"id\" || accessed_field_name == \"ID\" {\n                                            format!(\"uuid_str({}.id(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"label\" || accessed_field_name == \"Label\" {\n                                            format!(\"{}.label()\", access_var)\n                                        } else if accessed_field_name == \"from_node\" {\n                                            format!(\"uuid_str({}.from_node(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"to_node\" {\n                                            format!(\"uuid_str({}.to_node(), &arena)\", access_var)\n                                        } else {\n                                            format!(\"{}.get_property(\\\"{}\\\")\", access_var, accessed_field_name)\n                                        }\n                                    };\n                                    nested_field_assigns.push_str(&format!(\"\\n                        {}: {},\", nested_field.name, nested_val));\n                                }\n\n                                // Check if any nested field is a deeply nested traversal that needs error handling\n                                let has_deeply_nested = nested_fields.iter().any(|f| matches!(\n                                    f.source,\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        nested_struct_name: Some(_),\n                                        ..\n                                    }\n                                ));\n\n                                if has_deeply_nested {\n                                    // Use and_then so the closure can return Result and use ?\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.and_then(|{}| Ok({} {{{}\\n                    }}))).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                } else {\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.map(|{}| {} {{{}\\n                    }})).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                }\n                            } else {\n                                \"Vec::new()\".to_string()\n                            }\n                        } else if field.name == \"id\" {\n                            format!(\"uuid_str({}.id(), &arena)\", singular_var)\n                        } else if field.name == \"label\" {\n                            format!(\"{}.label()\", singular_var)\n                        } else if field.name == \"from_node\" {\n                            format!(\"uuid_str({}.from_node(), &arena)\", singular_var)\n                        } else if field.name == \"to_node\" {\n                            format!(\"uuid_str({}.to_node(), &arena)\", singular_var)\n                        } else if field.name == \"data\" {\n                            format!(\"{}.data()\", singular_var)\n                        } else if field.name == \"score\" {\n                            format!(\"{}.score()\", singular_var)\n                        } else {\n                            // Regular schema field\n                            format!(\"{}.get_property(\\\"{}\\\")\", singular_var, field.name)\n                        };\n                        writeln!(f, \"        {}: {},\", field.name, field_value)?;\n                    }\n\n                    // Check if any field is a nested traversal (needs Result handling)\n                    let has_nested = struct_def.fields.iter().any(|f| f.is_nested_traversal);\n                    if has_nested {\n                        write!(f, \"    }})).collect::<Result<Vec<_>, GraphError>>()?\")\n                    } else {\n                        write!(f, \"    }}).collect::<Vec<_>>()\")\n                    }?;\n                } else {\n                    // Single item - direct struct construction\n                    // For anonymous traversals, use the source variable directly as the \"item\"\n                    let singular_var = struct_def.source_variable.as_str();\n\n                    writeln!(\n                        f,\n                        \"    \\\"{}\\\": {} {{\",\n                        struct_def.source_variable, struct_def.name\n                    )?;\n\n                    for (field_idx, field) in struct_def.fields.iter().enumerate() {\n                        let field_value = if field.is_nested_traversal {\n                            // Same nested traversal logic as collection case\n                            let field_info = &struct_def.field_infos[field_idx];\n\n                            // Handle scalar nested traversals with closure parameters (e.g., username: u::{name})\n                            // or anonymous traversals (e.g., creatorID: _::In<Created>::ID)\n                            if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                closure_source_var: Some(closure_var),\n                                accessed_field_name: accessed_field,\n                                nested_struct_name: None,\n                                ..\n                            } = &field_info.source {\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let resolved_var = if closure_var == \"_\" || closure_var == \"val\" {\n                                    singular_var\n                                } else {\n                                    closure_var.as_str()\n                                };\n\n                                // This is a scalar field accessing a closure parameter or anonymous variable\n                                let field_to_access = accessed_field.as_ref()\n                                    .map(|s| s.as_str())\n                                    .unwrap_or(field.name.as_str());\n\n                                if field_to_access == \"id\" || field_to_access == \"ID\" {\n                                    format!(\"uuid_str({}.id(), &arena)\", resolved_var)\n                                } else if field_to_access == \"label\" || field_to_access == \"Label\" {\n                                    format!(\"{}.label()\", resolved_var)\n                                } else {\n                                    format!(\"{}.get_property(\\\"{}\\\")\", resolved_var, field_to_access)\n                                }\n                            } else if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                traversal_code: Some(trav_code),\n                                nested_struct_name: Some(nested_name),\n                                traversal_type,\n                                closure_source_var,\n                                closure_param_name,\n                                own_closure_param,\n                                ..\n                            } = &field_info.source {\n                                let nested_fields = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(fields) = &field_info.field_type {\n                                    fields\n                                } else {\n                                    panic!(\"Nested traversal must have Nested field type\");\n                                };\n\n                                // Extract the actual source variable from the traversal type\n                                let source_var = if let Some(trav_type) = traversal_type {\n                                    use crate::helixc::generator::traversal_steps::TraversalType;\n                                    match trav_type {\n                                        TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                            var.inner().clone()\n                                        }\n                                        _ => {\n                                            struct_def.source_variable.clone()\n                                        }\n                                    }\n                                } else {\n                                    struct_def.source_variable.clone()\n                                };\n\n                                // Determine if we need iter().cloned() or std::iter::once()\n                                let iterator_expr = format!(\"{}.iter().cloned()\", source_var);\n\n                                // Determine the closure parameter name to use in .map(|param| ...)\n                                // Prefer own_closure_param (this traversal's closure), otherwise use closure_param_name (parent context)\n                                let closure_param = own_closure_param.as_ref()\n                                    .or(closure_param_name.as_ref())\n                                    .map(|s| s.as_str())\n                                    .filter(|s| !s.is_empty() && *s != \"_\" && *s != \"val\")\n                                    .unwrap_or(\"item\");\n\n                                // Check if we're in a closure context\n                                let _closure_context_var = closure_source_var.as_ref().map(|s| s.as_str()).unwrap_or(&struct_def.source_variable);\n\n                                let mut nested_field_assigns = String::new();\n                                for nested_field in nested_fields {\n                                    // Check if this nested field is itself a nested traversal with a nested struct\n                                    let nested_val = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        traversal_code: Some(inner_trav_code),\n                                        nested_struct_name: Some(inner_nested_name),\n                                        traversal_type: inner_traversal_type,\n                                        ..\n                                    } = &nested_field.source {\n                                        // This is a deeply nested traversal - generate nested traversal code\n\n                                        // Extract the source variable for this deeply nested traversal\n                                        let inner_source_var = if let Some(inner_trav_type) = inner_traversal_type {\n                                            use crate::helixc::generator::traversal_steps::TraversalType;\n                                            match inner_trav_type {\n                                                TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                                    let v = var.inner();\n                                                    // Resolve placeholders: \"_\" and \"val\" should use \"item\" in nested context\n                                                    if v == \"_\" || v == \"val\" { \"item\" } else { v }\n                                                }\n                                                _ => \"item\"\n                                            }\n                                        } else {\n                                            \"item\"\n                                        };\n\n                                        // Get the nested fields if available\n                                        let inner_fields_str = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(inner_fields) = &nested_field.field_type {\n                                            // Generate field assignments for the deeply nested struct\n                                            let mut inner_assigns = String::new();\n                                            for inner_f in inner_fields {\n                                                let inner_val = if inner_f.name == \"id\" {\n                                                    \"uuid_str(inner_item.id(), &arena)\".to_string()\n                                                } else if inner_f.name == \"label\" {\n                                                    \"inner_item.label()\".to_string()\n                                                } else {\n                                                    format!(\"inner_item.get_property(\\\"{}\\\")\", inner_f.name)\n                                                };\n                                                inner_assigns.push_str(&format!(\"\\n{}: {},\", inner_f.name, inner_val));\n                                            }\n                                            format!(\".map(|inner_item| inner_item.map(|inner_item| {} {{{}\\n}})).collect::<Result<Vec<_>, _>>()?\", inner_nested_name, inner_assigns)\n                                        } else {\n                                            \".collect::<Vec<_>>()\".to_string()\n                                        };\n                                        format!(\"G::from_iter(&db, &txn, std::iter::once({}.clone()), &arena){}{}\", inner_source_var, inner_trav_code, inner_fields_str)\n                                    } else {\n                                        // Check if this field itself is a nested traversal that accesses the closure parameter\n                                        // Extract both the access variable and the actual field being accessed\n                                        let (access_var, accessed_field_name) = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                            closure_source_var: Some(closure_var),\n                                            accessed_field_name: accessed_field,\n                                            ..\n                                        } = &nested_field.source {\n                                            // Use the accessed_field_name from the metadata if available,\n                                            // otherwise fall back to the field name\n                                            let field_to_access = accessed_field.as_ref()\n                                                .map(|s| s.as_str())\n                                                .unwrap_or(nested_field.name.as_str());\n                                            (closure_var.as_str(), field_to_access)\n                                        } else {\n                                            (closure_param, nested_field.name.as_str())\n                                        };\n\n                                        if accessed_field_name == \"id\" || accessed_field_name == \"ID\" {\n                                            format!(\"uuid_str({}.id(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"label\" || accessed_field_name == \"Label\" {\n                                            format!(\"{}.label()\", access_var)\n                                        } else if accessed_field_name == \"from_node\" {\n                                            format!(\"uuid_str({}.from_node(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"to_node\" {\n                                            format!(\"uuid_str({}.to_node(), &arena)\", access_var)\n                                        } else {\n                                            format!(\"{}.get_property(\\\"{}\\\")\", access_var, accessed_field_name)\n                                        }\n                                    };\n                                    nested_field_assigns.push_str(&format!(\"\\n                        {}: {},\", nested_field.name, nested_val));\n                                }\n\n                                // Check if any nested field is a deeply nested traversal that needs error handling\n                                let has_deeply_nested = nested_fields.iter().any(|f| matches!(\n                                    f.source,\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        nested_struct_name: Some(_),\n                                        ..\n                                    }\n                                ));\n\n                                if has_deeply_nested {\n                                    // Use and_then so the closure can return Result and use ?\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.and_then(|{}| Ok({} {{{}\\n                    }}))).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                } else {\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.map(|{}| {} {{{}\\n                    }})).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                }\n                            } else {\n                                \"Vec::new()\".to_string()\n                            }\n                        } else if field.name == \"id\" {\n                            format!(\"uuid_str({}.id(), &arena)\", struct_def.source_variable)\n                        } else if field.name == \"label\" {\n                            format!(\"{}.label()\", struct_def.source_variable)\n                        } else if field.name == \"from_node\" {\n                            format!(\n                                \"uuid_str({}.from_node(), &arena)\",\n                                struct_def.source_variable\n                            )\n                        } else if field.name == \"to_node\" {\n                            format!(\"uuid_str({}.to_node(), &arena)\", struct_def.source_variable)\n                        } else if field.name == \"data\" {\n                            format!(\"{}.data()\", struct_def.source_variable)\n                        } else if field.name == \"score\" {\n                            format!(\"{}.score()\", struct_def.source_variable)\n                        } else {\n                            format!(\n                                \"{}.get_property(\\\"{}\\\")\",\n                                struct_def.source_variable, field.name\n                            )\n                        };\n                        writeln!(f, \"        {}: {},\", field.name, field_value)?;\n                    }\n\n                    write!(f, \"    }}\")?;\n                }\n            }\n            writeln!(f)?;\n            writeln!(f, \"}});\")?;\n            self.print_txn_commit(f)?;\n            writeln!(f, \"Ok(input.request.out_fmt.create_response(&response))\")?;\n        } else if !self.return_values.is_empty() {\n            // Legacy json! macro approach\n            write!(f, \"let response = json!({{\")?;\n            for (i, (field_name, ret_val)) in self.return_values.iter().enumerate() {\n                if i > 0 {\n                    write!(f, \",\")?;\n                }\n                writeln!(f)?;\n\n                // If this return value has schema fields, extract them into json\n                if !ret_val.fields.is_empty() {\n                    write!(f, \"    \\\"{}\\\": json!({{\", field_name)?;\n                    for (j, field) in ret_val.fields.iter().enumerate() {\n                        if j > 0 {\n                            write!(f, \",\")?;\n                        }\n                        writeln!(f)?;\n                        if field.name == \"id\" {\n                            write!(\n                                f,\n                                \"        \\\"{}\\\": uuid_str({}.id(), &arena)\",\n                                field.name, field_name\n                            )?;\n                        } else if field.name == \"label\" {\n                            write!(f, \"        \\\"{}\\\": {}.label()\", field.name, field_name)?;\n                        } else {\n                            write!(\n                                f,\n                                \"        \\\"{}\\\": {}.get_property(\\\"{}\\\").unwrap()\",\n                                field.name, field_name, field.name\n                            )?;\n                        }\n                    }\n                    writeln!(f)?;\n                    write!(f, \"    }})\")?;\n                } else {\n                    // For scalar or other types, serialize directly\n                    // If there's a literal value, use it directly\n                    if let Some(ref lit) = ret_val.literal_value {\n                        write!(f, \"    \\\"{}\\\": {}\", field_name, lit)?;\n                    } else {\n                        write!(f, \"    \\\"{}\\\": {}\", field_name, field_name)?;\n                    }\n                }\n            }\n            writeln!(f)?;\n            writeln!(f, \"}});\")?;\n            self.print_txn_commit(f)?;\n            writeln!(f, \"Ok(input.request.out_fmt.create_response(&response))\")?;\n        } else {\n            self.print_txn_commit(f)?;\n            writeln!(f, \"Ok(input.request.out_fmt.create_response(&()))\")?;\n        }\n\n        if !self.hoisted_embedding_calls.is_empty() {\n            writeln!(f, r#\"}}))).await.expect(\"Cont Channel should be alive\")\"#)?;\n            writeln!(f, \"}})))\")?;\n        }\n        writeln!(f, \"}}\")?;\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_print_mcp_808": {
      "name": "print_mcp",
      "type": "method",
      "start_line": 808,
      "end_line": 1441,
      "content_hash": "eb1a9ca7980b596b1f79e6a32cd3822cf448f026",
      "content": "    fn print_mcp(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.mcp_handler.is_none() {\n            return Ok(());\n        }\n\n        let struct_name = format!(\"{}Input\", self.name);\n        let mcp_struct_name = format!(\"{}McpInput\", self.name);\n        let mcp_function_name = format!(\"{}Mcp\", self.name);\n\n        writeln!(f, \"#[derive(Deserialize, Clone)]\")?;\n        writeln!(f, \"pub struct {mcp_struct_name} {{\")?;\n        writeln!(f, \"    connection_id: String,\")?;\n        if !self.parameters.is_empty() {\n            writeln!(f, \"    data: {struct_name},\")?;\n        } else {\n            writeln!(f, \"    data: serde_json::Value,\")?;\n        }\n        writeln!(f, \"}}\")?;\n\n        writeln!(f, \"#[mcp_handler]\")?;\n        writeln!(\n            f,\n            \"pub fn {mcp_function_name}(input: &mut MCPToolInput) -> Result<Response, GraphError> {{\"\n        )?;\n\n        match self.hoisted_embedding_calls.is_empty() {\n            true => writeln!(\n                f,\n                \"let data = input.request.in_fmt.deserialize::<{mcp_struct_name}>(&input.request.body)?;\"\n            )?,\n            false => writeln!(\n                f,\n                \"let data = input.request.in_fmt.deserialize::<{mcp_struct_name}>(&input.request.body)?.into_owned();\"\n            )?,\n        }\n\n        writeln!(\n            f,\n            \"let mut connections = input.mcp_connections.lock().map_err(|_| GraphError::Default)?;\"\n        )?;\n        writeln!(\n            f,\n            \"let mut connection = match connections.remove_connection(&data.connection_id) {{\"\n        )?;\n        writeln!(f, \"    Some(conn) => conn,\")?;\n        writeln!(f, \"    None => return Err(GraphError::Default),\")?;\n        writeln!(f, \"}};\")?;\n        writeln!(f, \"drop(connections);\")?;\n        // print the db boilerplate\n        writeln!(f, \"let db = Arc::clone(&input.mcp_backend.db);\")?;\n        writeln!(f, \"let arena = Bump::new();\")?;\n        match self.hoisted_embedding_calls.is_empty() {\n            true => writeln!(f, \"let data = &data.data;\")?,\n            false => writeln!(f, \"let data = data.data;\")?,\n        }\n        writeln!(f, \"let connections = Arc::clone(&input.mcp_connections);\")?;\n\n        self.print_hoisted_embedding_calls(f)?;\n        writeln!(f, \"let arena = Bump::new();\")?;\n\n        match self.is_mut {\n            true => writeln!(\n                f,\n                \"let mut txn = db.graph_env.write_txn().map_err(|e| GraphError::New(format!(\\\"Failed to start write transaction: {{:?}}\\\", e)))?;\"\n            )?,\n            false => writeln!(\n                f,\n                \"let txn = db.graph_env.read_txn().map_err(|e| GraphError::New(format!(\\\"Failed to start read transaction: {{:?}}\\\", e)))?;\"\n            )?,\n        }\n\n        for statement in &self.statements {\n            writeln!(f, \"    {statement};\")?;\n        }\n\n        // Generate return value - same logic as regular handler\n        if self.use_struct_returns && !self.return_structs.is_empty() {\n            // New struct-based approach - map during response construction\n            write!(f, \"let response = json!({{\")?;\n            for (i, struct_def) in self.return_structs.iter().enumerate() {\n                if i > 0 {\n                    write!(f, \",\")?;\n                }\n                writeln!(f)?;\n\n                if struct_def.is_aggregate {\n                    // Aggregate/GroupBy - return the enum directly (it already implements Serialize)\n                    writeln!(\n                        f,\n                        \"    \\\"{}\\\": {}\",\n                        struct_def.source_variable,\n                        struct_def.source_variable\n                    )?;\n                } else if struct_def.is_collection {\n                    // Collection - generate mapping code\n                    let singular_var = struct_def.source_variable.trim_end_matches('s');\n                    // Check if any field is a nested traversal (needs Result handling)\n                    let has_nested = struct_def.fields.iter().any(|f| f.is_nested_traversal);\n\n                    if has_nested {\n                        writeln!(\n                            f,\n                            \"    \\\"{}\\\": {}.iter().map(|{}| Ok::<_, GraphError>({} {{\",\n                            struct_def.source_variable,\n                            struct_def.source_variable,\n                            singular_var,\n                            struct_def.name\n                        )?;\n                    } else {\n                        writeln!(\n                            f,\n                            \"    \\\"{}\\\": {}.iter().map(|{}| {} {{\",\n                            struct_def.source_variable,\n                            struct_def.source_variable,\n                            singular_var,\n                            struct_def.name\n                        )?;\n                    }\n\n                    // Generate field assignments\n                    for (field_idx, field) in struct_def.fields.iter().enumerate() {\n                        let field_value = if field.is_nested_traversal {\n                            // Get the nested traversal info from field_infos\n                            let field_info = &struct_def.field_infos[field_idx];\n\n                            // Handle scalar nested traversals with closure parameters (e.g., username: u::{name})\n                            // or anonymous traversals (e.g., creatorID: _::In<Created>::ID)\n                            if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                closure_source_var: Some(closure_var),\n                                accessed_field_name: accessed_field,\n                                nested_struct_name: None,\n                                ..\n                            } = &field_info.source {\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let resolved_var = if closure_var == \"_\" || closure_var == \"val\" {\n                                    singular_var\n                                } else {\n                                    closure_var.as_str()\n                                };\n\n                                // This is a scalar field accessing a closure parameter or anonymous variable\n                                let field_to_access = accessed_field.as_ref()\n                                    .map(|s| s.as_str())\n                                    .unwrap_or(field.name.as_str());\n\n                                if field_to_access == \"id\" || field_to_access == \"ID\" {\n                                    format!(\"uuid_str({}.id(), &arena)\", resolved_var)\n                                } else if field_to_access == \"label\" || field_to_access == \"Label\" {\n                                    format!(\"{}.label()\", resolved_var)\n                                } else {\n                                    format!(\"{}.get_property(\\\"{}\\\")\", resolved_var, field_to_access)\n                                }\n                            } else if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                traversal_code: Some(trav_code),\n                                nested_struct_name: Some(nested_name),\n                                traversal_type,\n                                closure_source_var,\n                                closure_param_name,\n                                own_closure_param,\n                                ..\n                            } = &field_info.source {\n                                // Generate nested traversal code\n                                let nested_fields = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(fields) = &field_info.field_type {\n                                    fields\n                                } else {\n                                    panic!(\"Nested traversal must have Nested field type\");\n                                };\n\n                                // Extract the actual source variable from the traversal type\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let (source_var, is_single_source) = if let Some(trav_type) = traversal_type {\n                                    use crate::helixc::generator::traversal_steps::TraversalType;\n                                    match trav_type {\n                                        TraversalType::FromSingle(var) => {\n                                            let v = var.inner();\n                                            // Resolve placeholders: both \"_\" and \"val\" should use the iteration variable\n                                            let resolved = if v == \"_\" || v == \"val\" { singular_var } else { v.as_str() };\n                                            (resolved.to_string(), true)\n                                        }\n                                        TraversalType::FromIter(var) => {\n                                            let v = var.inner();\n                                            // Resolve placeholders: both \"_\" and \"val\" should use the iteration variable\n                                            let resolved = if v == \"_\" || v == \"val\" { singular_var } else { v.as_str() };\n                                            (resolved.to_string(), false)\n                                        }\n                                        _ => {\n                                            (singular_var.to_string(), false)\n                                        }\n                                    }\n                                } else {\n                                    (singular_var.to_string(), false)\n                                };\n\n                                // Determine if we need iter().cloned() or std::iter::once()\n                                let iterator_expr = if is_single_source {\n                                    format!(\"std::iter::once({}.clone())\", source_var)\n                                } else {\n                                    format!(\"{}.iter().cloned()\", source_var)\n                                };\n\n                                // Determine the closure parameter name to use in .map(|param| ...)\n                                // Prefer own_closure_param (this traversal's closure), otherwise use closure_param_name (parent context)\n                                let closure_param = own_closure_param.as_ref()\n                                    .or(closure_param_name.as_ref())\n                                    .map(|s| s.as_str())\n                                    .filter(|s| !s.is_empty() && *s != \"_\" && *s != \"val\")\n                                    .unwrap_or(\"item\");\n\n                                // Generate field assignments for nested struct\n                                // Check if we're in a closure context, resolve \"_\" placeholder\n                                let _closure_context_var = closure_source_var.as_ref()\n                                    .map(|s| if s == \"_\" { singular_var } else { s.as_str() })\n                                    .unwrap_or(singular_var);\n\n                                let mut nested_field_assigns = String::new();\n                                for nested_field in nested_fields {\n                                    // Check if this nested field is itself a nested traversal with a nested struct\n                                    let nested_val = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        traversal_code: Some(inner_trav_code),\n                                        nested_struct_name: Some(inner_nested_name),\n                                        traversal_type: inner_traversal_type,\n                                        ..\n                                    } = &nested_field.source {\n                                        // This is a deeply nested traversal - generate nested traversal code\n\n                                        // Extract the source variable for this deeply nested traversal\n                                        let inner_source_var = if let Some(inner_trav_type) = inner_traversal_type {\n                                            use crate::helixc::generator::traversal_steps::TraversalType;\n                                            match inner_trav_type {\n                                                TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                                    let v = var.inner();\n                                                    // Resolve placeholders: \"_\" and \"val\" should use \"item\" in nested context\n                                                    if v == \"_\" || v == \"val\" { \"item\" } else { v }\n                                                }\n                                                _ => \"item\"\n                                            }\n                                        } else {\n                                            \"item\"\n                                        };\n\n                                        // Get the nested fields if available\n                                        let inner_fields_str = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(inner_fields) = &nested_field.field_type {\n                                            // Generate field assignments for the deeply nested struct\n                                            let mut inner_assigns = String::new();\n                                            for inner_f in inner_fields {\n                                                let inner_val = if inner_f.name == \"id\" {\n                                                    \"uuid_str(inner_item.id(), &arena)\".to_string()\n                                                } else if inner_f.name == \"label\" {\n                                                    \"inner_item.label()\".to_string()\n                                                } else {\n                                                    format!(\"inner_item.get_property(\\\"{}\\\")\", inner_f.name)\n                                                };\n                                                inner_assigns.push_str(&format!(\"\\n{}: {},\", inner_f.name, inner_val));\n                                            }\n                                            format!(\".map(|inner_item| inner_item.map(|inner_item| {} {{{}\\n}})).collect::<Result<Vec<_>, _>>()?\", inner_nested_name, inner_assigns)\n                                        } else {\n                                            \".collect::<Vec<_>>()\".to_string()\n                                        };\n                                        format!(\"G::from_iter(&db, &txn, std::iter::once({}.clone()), &arena){}{}\", inner_source_var, inner_trav_code, inner_fields_str)\n                                    } else {\n                                        // Check if this field itself is a nested traversal that accesses the closure parameter\n                                        // Extract both the access variable and the actual field being accessed\n                                        let (access_var, accessed_field_name) = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                            closure_source_var: Some(closure_var),\n                                            accessed_field_name: accessed_field,\n                                            ..\n                                        } = &nested_field.source {\n                                            // Use the accessed_field_name from the metadata if available,\n                                            // otherwise fall back to the field name\n                                            let field_to_access = accessed_field.as_ref()\n                                                .map(|s| s.as_str())\n                                                .unwrap_or(nested_field.name.as_str());\n                                            (closure_var.as_str(), field_to_access)\n                                        } else {\n                                            (closure_param, nested_field.name.as_str())\n                                        };\n\n                                        if accessed_field_name == \"id\" || accessed_field_name == \"ID\" {\n                                            format!(\"uuid_str({}.id(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"label\" || accessed_field_name == \"Label\" {\n                                            format!(\"{}.label()\", access_var)\n                                        } else if accessed_field_name == \"from_node\" {\n                                            format!(\"uuid_str({}.from_node(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"to_node\" {\n                                            format!(\"uuid_str({}.to_node(), &arena)\", access_var)\n                                        } else {\n                                            format!(\"{}.get_property(\\\"{}\\\")\", access_var, accessed_field_name)\n                                        }\n                                    };\n                                    nested_field_assigns.push_str(&format!(\"\\n                        {}: {},\", nested_field.name, nested_val));\n                                }\n\n                                // Check if any nested field is a deeply nested traversal that needs error handling\n                                let has_deeply_nested = nested_fields.iter().any(|f| matches!(\n                                    f.source,\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        nested_struct_name: Some(_),\n                                        ..\n                                    }\n                                ));\n\n                                if has_deeply_nested {\n                                    // Use and_then so the closure can return Result and use ?\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.and_then(|{}| Ok({} {{{}\\n                    }}))).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                } else {\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.map(|{}| {} {{{}\\n                    }})).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                }\n                            } else {\n                                \"Vec::new()\".to_string()\n                            }\n                        } else if field.name == \"id\" {\n                            format!(\"uuid_str({}.id(), &arena)\", singular_var)\n                        } else if field.name == \"label\" {\n                            format!(\"{}.label()\", singular_var)\n                        } else if field.name == \"from_node\" {\n                            format!(\"uuid_str({}.from_node(), &arena)\", singular_var)\n                        } else if field.name == \"to_node\" {\n                            format!(\"uuid_str({}.to_node(), &arena)\", singular_var)\n                        } else if field.name == \"data\" {\n                            format!(\"{}.data()\", singular_var)\n                        } else if field.name == \"score\" {\n                            format!(\"{}.score()\", singular_var)\n                        } else {\n                            // Regular schema field\n                            format!(\"{}.get_property(\\\"{}\\\")\", singular_var, field.name)\n                        };\n                        writeln!(f, \"        {}: {},\", field.name, field_value)?;\n                    }\n\n                    // Check if any field is a nested traversal (needs Result handling)\n                    let has_nested = struct_def.fields.iter().any(|f| f.is_nested_traversal);\n                    if has_nested {\n                        write!(f, \"    }})).collect::<Vec<_>>()\")\n                    } else {\n                        write!(f, \"    }}).collect::<Vec<_>>()\")\n                    }?;\n                } else {\n                    // Single item - direct struct construction\n                    // For anonymous traversals, use the source variable directly as the \"item\"\n                    let singular_var = struct_def.source_variable.as_str();\n\n                    writeln!(\n                        f,\n                        \"    \\\"{}\\\": {} {{\",\n                        struct_def.source_variable, struct_def.name\n                    )?;\n\n                    for (field_idx, field) in struct_def.fields.iter().enumerate() {\n                        let field_value = if field.is_nested_traversal {\n                            // Same nested traversal logic as collection case\n                            let field_info = &struct_def.field_infos[field_idx];\n\n                            // Handle scalar nested traversals with closure parameters (e.g., username: u::{name})\n                            // or anonymous traversals (e.g., creatorID: _::In<Created>::ID)\n                            if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                closure_source_var: Some(closure_var),\n                                accessed_field_name: accessed_field,\n                                nested_struct_name: None,\n                                ..\n                            } = &field_info.source {\n                                // Resolve \"_\" and \"val\" placeholders to actual iteration variable\n                                let resolved_var = if closure_var == \"_\" || closure_var == \"val\" {\n                                    singular_var\n                                } else {\n                                    closure_var.as_str()\n                                };\n\n                                // This is a scalar field accessing a closure parameter or anonymous variable\n                                let field_to_access = accessed_field.as_ref()\n                                    .map(|s| s.as_str())\n                                    .unwrap_or(field.name.as_str());\n\n                                if field_to_access == \"id\" || field_to_access == \"ID\" {\n                                    format!(\"uuid_str({}.id(), &arena)\", resolved_var)\n                                } else if field_to_access == \"label\" || field_to_access == \"Label\" {\n                                    format!(\"{}.label()\", resolved_var)\n                                } else {\n                                    format!(\"{}.get_property(\\\"{}\\\")\", resolved_var, field_to_access)\n                                }\n                            } else if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                traversal_code: Some(trav_code),\n                                nested_struct_name: Some(nested_name),\n                                traversal_type,\n                                closure_source_var,\n                                closure_param_name,\n                                own_closure_param,\n                                ..\n                            } = &field_info.source {\n                                let nested_fields = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(fields) = &field_info.field_type {\n                                    fields\n                                } else {\n                                    panic!(\"Nested traversal must have Nested field type\");\n                                };\n\n                                // Extract the actual source variable from the traversal type\n                                let source_var = if let Some(trav_type) = traversal_type {\n                                    use crate::helixc::generator::traversal_steps::TraversalType;\n                                    match trav_type {\n                                        TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                            var.inner().clone()\n                                        }\n                                        _ => {\n                                            struct_def.source_variable.clone()\n                                        }\n                                    }\n                                } else {\n                                    struct_def.source_variable.clone()\n                                };\n\n                                // Determine if we need iter().cloned() or std::iter::once()\n                                let iterator_expr = format!(\"{}.iter().cloned()\", source_var);\n\n                                // Determine the closure parameter name to use in .map(|param| ...)\n                                // Prefer own_closure_param (this traversal's closure), otherwise use closure_param_name (parent context)\n                                let closure_param = own_closure_param.as_ref()\n                                    .or(closure_param_name.as_ref())\n                                    .map(|s| s.as_str())\n                                    .filter(|s| !s.is_empty() && *s != \"_\" && *s != \"val\")\n                                    .unwrap_or(\"item\");\n\n                                // Check if we're in a closure context\n                                let _closure_context_var = closure_source_var.as_ref().map(|s| s.as_str()).unwrap_or(&struct_def.source_variable);\n\n                                let mut nested_field_assigns = String::new();\n                                for nested_field in nested_fields {\n                                    // Check if this nested field is itself a nested traversal with a nested struct\n                                    let nested_val = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        traversal_code: Some(inner_trav_code),\n                                        nested_struct_name: Some(inner_nested_name),\n                                        traversal_type: inner_traversal_type,\n                                        ..\n                                    } = &nested_field.source {\n                                        // This is a deeply nested traversal - generate nested traversal code\n\n                                        // Extract the source variable for this deeply nested traversal\n                                        let inner_source_var = if let Some(inner_trav_type) = inner_traversal_type {\n                                            use crate::helixc::generator::traversal_steps::TraversalType;\n                                            match inner_trav_type {\n                                                TraversalType::FromSingle(var) | TraversalType::FromIter(var) => {\n                                                    let v = var.inner();\n                                                    // Resolve placeholders: \"_\" and \"val\" should use \"item\" in nested context\n                                                    if v == \"_\" || v == \"val\" { \"item\" } else { v }\n                                                }\n                                                _ => \"item\"\n                                            }\n                                        } else {\n                                            \"item\"\n                                        };\n\n                                        // Get the nested fields if available\n                                        let inner_fields_str = if let crate::helixc::generator::return_values::ReturnFieldType::Nested(inner_fields) = &nested_field.field_type {\n                                            // Generate field assignments for the deeply nested struct\n                                            let mut inner_assigns = String::new();\n                                            for inner_f in inner_fields {\n                                                let inner_val = if inner_f.name == \"id\" {\n                                                    \"uuid_str(inner_item.id(), &arena)\".to_string()\n                                                } else if inner_f.name == \"label\" {\n                                                    \"inner_item.label()\".to_string()\n                                                } else {\n                                                    format!(\"inner_item.get_property(\\\"{}\\\")\", inner_f.name)\n                                                };\n                                                inner_assigns.push_str(&format!(\"\\n{}: {},\", inner_f.name, inner_val));\n                                            }\n                                            format!(\".map(|inner_item| inner_item.map(|inner_item| {} {{{}\\n}})).collect::<Result<Vec<_>, _>>()?\", inner_nested_name, inner_assigns)\n                                        } else {\n                                            \".collect::<Result<Vec<_>,_>>()?\".to_string()\n                                        };\n                                        format!(\"G::from_iter(&db, &txn, std::iter::once({}.clone()), &arena){}{}\", inner_source_var, inner_trav_code, inner_fields_str)\n                                    } else {\n                                        // Check if this field itself is a nested traversal that accesses the closure parameter\n                                        // Extract both the access variable and the actual field being accessed\n                                        let (access_var, accessed_field_name) = if let crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                            closure_source_var: Some(closure_var),\n                                            accessed_field_name: accessed_field,\n                                            ..\n                                        } = &nested_field.source {\n                                            // Use the accessed_field_name from the metadata if available,\n                                            // otherwise fall back to the field name\n                                            let field_to_access = accessed_field.as_ref()\n                                                .map(|s| s.as_str())\n                                                .unwrap_or(nested_field.name.as_str());\n                                            (closure_var.as_str(), field_to_access)\n                                        } else {\n                                            (closure_param, nested_field.name.as_str())\n                                        };\n\n                                        if accessed_field_name == \"id\" || accessed_field_name == \"ID\" {\n                                            format!(\"uuid_str({}.id(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"label\" || accessed_field_name == \"Label\" {\n                                            format!(\"{}.label()\", access_var)\n                                        } else if accessed_field_name == \"from_node\" {\n                                            format!(\"uuid_str({}.from_node(), &arena)\", access_var)\n                                        } else if accessed_field_name == \"to_node\" {\n                                            format!(\"uuid_str({}.to_node(), &arena)\", access_var)\n                                        } else {\n                                            format!(\"{}.get_property(\\\"{}\\\")\", access_var, accessed_field_name)\n                                        }\n                                    };\n                                    nested_field_assigns.push_str(&format!(\"\\n                        {}: {},\", nested_field.name, nested_val));\n                                }\n\n                                // Check if any nested field is a deeply nested traversal that needs error handling\n                                let has_deeply_nested = nested_fields.iter().any(|f| matches!(\n                                    f.source,\n                                    crate::helixc::generator::return_values::ReturnFieldSource::NestedTraversal {\n                                        nested_struct_name: Some(_),\n                                        ..\n                                    }\n                                ));\n\n                                if has_deeply_nested {\n                                    // Use and_then so the closure can return Result and use ?\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.and_then(|{}| Ok({} {{{}\\n                    }}))).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                } else {\n                                    format!(\"G::from_iter(&db, &txn, {}, &arena){}.map(|{}| {}.map(|{}| {} {{{}\\n                    }})).collect::<Result<Vec<_>, _>>()?\",\n                                        iterator_expr, trav_code, closure_param, closure_param, closure_param, nested_name, nested_field_assigns)\n                                }\n                            } else {\n                                \"Vec::new()\".to_string()\n                            }\n                        } else if field.name == \"id\" {\n                            format!(\"uuid_str({}.id(), &arena)\", struct_def.source_variable)\n                        } else if field.name == \"label\" {\n                            format!(\"{}.label()\", struct_def.source_variable)\n                        } else if field.name == \"from_node\" {\n                            format!(\n                                \"uuid_str({}.from_node(), &arena)\",\n                                struct_def.source_variable\n                            )\n                        } else if field.name == \"to_node\" {\n                            format!(\"uuid_str({}.to_node(), &arena)\", struct_def.source_variable)\n                        } else if field.name == \"data\" {\n                            format!(\"{}.data()\", struct_def.source_variable)\n                        } else if field.name == \"score\" {\n                            format!(\"{}.score()\", struct_def.source_variable)\n                        } else {\n                            format!(\n                                \"{}.get_property(\\\"{}\\\")\",\n                                struct_def.source_variable, field.name\n                            )\n                        };\n                        writeln!(f, \"        {}: {},\", field.name, field_value)?;\n                    }\n\n                    write!(f, \"    }}\")?;\n                }\n            }\n            writeln!(f)?;\n            writeln!(f, \"}});\")?;\n            self.print_txn_commit(f)?;\n            writeln!(f, \"let mut connections = connections.lock().unwrap();\")?;\n            writeln!(f, \"connections.add_connection(connection);\")?;\n            writeln!(f, \"drop(connections);\")?;\n            writeln!(\n                f,\n                \"Ok(helix_db::protocol::format::Format::Json.create_response(&response))\"\n            )?;\n        } else if !self.return_values.is_empty() {\n            // Legacy json! macro approach\n            write!(f, \"let response = json!({{\")?;\n            for (i, (field_name, ret_val)) in self.return_values.iter().enumerate() {\n                if i > 0 {\n                    write!(f, \",\")?;\n                }\n                writeln!(f)?;\n\n                // If this return value has schema fields, extract them into json\n                if !ret_val.fields.is_empty() {\n                    write!(f, \"    \\\"{}\\\": json!({{\", field_name)?;\n                    for (j, field) in ret_val.fields.iter().enumerate() {\n                        if j > 0 {\n                            write!(f, \",\")?;\n                        }\n                        writeln!(f)?;\n                        if field.name == \"id\" {\n                            write!(\n                                f,\n                                \"        \\\"{}\\\": uuid_str({}.id(), &arena)\",\n                                field.name, field_name\n                            )?;\n                        } else if field.name == \"label\" {\n                            write!(f, \"        \\\"{}\\\": {}.label()\", field.name, field_name)?;\n                        } else {\n                            write!(\n                                f,\n                                \"        \\\"{}\\\": {}.get_property(\\\"{}\\\").unwrap()\",\n                                field.name, field_name, field.name\n                            )?;\n                        }\n                    }\n                    writeln!(f)?;\n                    write!(f, \"    }})\")?;\n                } else {\n                    // For scalar or other types, serialize directly\n                    // If there's a literal value, use it directly\n                    if let Some(ref lit) = ret_val.literal_value {\n                        write!(f, \"    \\\"{}\\\": {}\", field_name, lit)?;\n                    } else {\n                        write!(f, \"    \\\"{}\\\": {}\", field_name, field_name)?;\n                    }\n                }\n            }\n            writeln!(f)?;\n            writeln!(f, \"}});\")?;\n            self.print_txn_commit(f)?;\n            writeln!(f, \"let mut connections = connections.lock().unwrap();\")?;\n            writeln!(f, \"connections.add_connection(connection);\")?;\n            writeln!(f, \"drop(connections);\")?;\n            writeln!(\n                f,\n                \"Ok(helix_db::protocol::format::Format::Json.create_response(&response))\"\n            )?;\n        } else {\n            self.print_txn_commit(f)?;\n            writeln!(f, \"let mut connections = connections.lock().unwrap();\")?;\n            writeln!(f, \"connections.add_connection(connection);\")?;\n            writeln!(f, \"drop(connections);\")?;\n            writeln!(\n                f,\n                \"Ok(helix_db::protocol::format::Format::Json.create_response(&()))\"\n            )?;\n        }\n        if !self.hoisted_embedding_calls.is_empty() {\n            writeln!(f, r#\"}}))).await.expect(\"Cont Channel should be alive\")\"#)?;\n            writeln!(f, \"}})))\")?;\n        }\n        writeln!(f, \"}}\")?;\n        Ok(())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_1442": {
      "name": "Display",
      "type": "impl",
      "start_line": 1442,
      "end_line": 1442,
      "content_hash": "ad17cb398f365014559ee792a04b0d3d412a28a4",
      "content": "impl Display for Query {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_1443": {
      "name": "fmt",
      "type": "method",
      "start_line": 1443,
      "end_line": 1447,
      "content_hash": "a0e10be7680571057f6c3fca55ec8104714dbc5e",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.print_query(f)?;\n        self.print_mcp(f)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_1448": {
      "name": "Default",
      "type": "impl",
      "start_line": 1448,
      "end_line": 1448,
      "content_hash": "9dcfd65806de9b6cbf7f38eb8a2e500a521acfb2",
      "content": "impl Default for Query {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_1449": {
      "name": "default",
      "type": "method",
      "start_line": 1449,
      "end_line": 1465,
      "content_hash": "8e8308efac353c731c56db4268f2747bc2ab22a4",
      "content": "    fn default() -> Self {\n        Self {\n            embedding_model_to_use: None,\n            mcp_handler: None,\n            name: \"\".to_string(),\n            statements: vec![],\n            parameters: vec![],\n            sub_parameters: vec![],\n            return_values: vec![],\n            return_structs: vec![],\n            use_struct_returns: true, // Enable new struct-based returns\n            is_mut: false,\n            hoisted_embedding_calls: vec![],\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Query_1466": {
      "name": "Query",
      "type": "impl",
      "start_line": 1466,
      "end_line": 1466,
      "content_hash": "c6917d5bd3578e55a007c380e491a9dd2194c3dc",
      "content": "impl Query {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_add_hoisted_embed_1467": {
      "name": "add_hoisted_embed",
      "type": "method",
      "start_line": 1467,
      "end_line": 1473,
      "content_hash": "f556b7b094e290ff4541a1c58f8091713a3628c5",
      "content": "    pub fn add_hoisted_embed(&mut self, embed_data: EmbedData) -> String {\n        let name = EmbedData::name_from_index(self.hoisted_embedding_calls.len());\n        self.hoisted_embedding_calls.push(embed_data);\n        name\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Parameter_1474": {
      "name": "Parameter",
      "type": "struct",
      "start_line": 1474,
      "end_line": 1478,
      "content_hash": "eaf7a06fdad352f10f2af5901c64ae1b01399c89",
      "content": "pub struct Parameter {\n    pub name: String,\n    pub field_type: GeneratedType,\n    pub is_optional: bool,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_1479": {
      "name": "Display",
      "type": "impl",
      "start_line": 1479,
      "end_line": 1479,
      "content_hash": "43bec09d017f196a2b4771eb76b87ab3a2ea9313",
      "content": "impl Display for Parameter {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_1480": {
      "name": "fmt",
      "type": "method",
      "start_line": 1480,
      "end_line": 1486,
      "content_hash": "67ce613ec7efb9f4756b01ebc1a6570bdaf22b75",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.is_optional {\n            true => write!(f, \"pub {}: Option<{}>\", self.name, self.field_type),\n            false => write!(f, \"pub {}: {}\", self.name, self.field_type),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}