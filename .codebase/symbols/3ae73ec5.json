{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/tests/check_tests.rs",
  "file_hash": "8572bbb4284517316773116a88e7e1308c5cd2ee",
  "updated_at": "2025-12-26T17:34:22.242624",
  "symbols": {
    "function_create_test_metrics_sender_9": {
      "name": "create_test_metrics_sender",
      "type": "function",
      "start_line": 9,
      "end_line": 13,
      "content_hash": "565f24a573c6037263c316cddd8a8b280f570bdd",
      "content": "fn create_test_metrics_sender() -> MetricsSender {\n    MetricsSender::new().expect(\"Failed to create metrics sender\")\n}\n\n/// Helper function to create a test project with valid schema and queries",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_valid_project_14": {
      "name": "setup_valid_project",
      "type": "function",
      "start_line": 14,
      "end_line": 75,
      "content_hash": "8d3a661010082aa3643367ce93d93ddf425f2368",
      "content": "fn setup_valid_project() -> (TempDir, PathBuf) {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml with a local instance\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create valid schema.hx\n    let schema_content = r#\"\n// Node types\nN::User {\n    name: String,\n    email: String,\n}\n\nN::Post {\n    title: String,\n    content: String,\n}\n\n// Edge types\nE::Authored {\n    From: User,\n    To: Post,\n}\n\nE::Likes {\n    From: User,\n    To: Post,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create valid queries.hx\n    let queries_content = r#\"\nQUERY GetUser(user_id: ID) =>\n    user <- N<User>(user_id)\n    RETURN user\n\nQUERY GetUserPosts(user_id: ID) =>\n    posts <- N<User>(user_id)::Out<Authored>\n    RETURN posts\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries_content)\n        .expect(\"Failed to write queries.hx\");\n\n    (temp_dir, project_path)\n}\n\n/// Helper function to create a project with empty schema",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_project_without_schema_76": {
      "name": "setup_project_without_schema",
      "type": "function",
      "start_line": 76,
      "end_line": 106,
      "content_hash": "ab176369113d866bfc9b056aac2c92b8b92885ad",
      "content": "fn setup_project_without_schema() -> (TempDir, PathBuf) {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory with only queries, no schema\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create queries.hx without schema definitions\n    let queries_content = r#\"\nQUERY GetUser(user_id: ID) =>\n    user <- N<User>(user_id)\n    RETURN user\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries_content)\n        .expect(\"Failed to write queries.hx\");\n\n    (temp_dir, project_path)\n}\n\n/// Helper function to create a project with invalid syntax",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_project_with_invalid_syntax_107": {
      "name": "setup_project_with_invalid_syntax",
      "type": "function",
      "start_line": 107,
      "end_line": 479,
      "content_hash": "1759590881d58d1c5a5e4e1279ea9111eb8744ab",
      "content": "fn setup_project_with_invalid_syntax() -> (TempDir, PathBuf) {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create schema with valid definitions\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create queries.hx with invalid syntax\n    let invalid_queries = r#\"\nQUERY InvalidQuery {\n    this is not valid helix syntax!!!\n}\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), invalid_queries)\n        .expect(\"Failed to write queries.hx\");\n\n    (temp_dir, project_path)\n}\n\n#[tokio::test]\nasync fn test_check_all_instances_success() {\n    let (_temp_dir, project_path) = setup_valid_project();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should succeed with valid project: {:?}\",\n        result.err()\n    );\n}\n\n#[tokio::test]\nasync fn test_check_specific_instance_success() {\n    let (_temp_dir, project_path) = setup_valid_project();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(Some(\"dev\".to_string()), &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should succeed for valid instance: {:?}\",\n        result.err()\n    );\n}\n\n#[tokio::test]\nasync fn test_check_nonexistent_instance_fails() {\n    let (_temp_dir, project_path) = setup_valid_project();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(Some(\"nonexistent\".to_string()), &metrics_sender).await;\n    assert!(\n        result.is_err(),\n        \"Check should fail for nonexistent instance\"\n    );\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"not found\") || error_msg.contains(\"nonexistent\"),\n        \"Error should mention instance not found\"\n    );\n}\n\n#[tokio::test]\nasync fn test_check_fails_without_schema() {\n    let (_temp_dir, project_path) = setup_project_without_schema();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(result.is_err(), \"Check should fail without schema\");\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"schema\") || error_msg.contains(\"N::\") || error_msg.contains(\"E::\"),\n        \"Error should mention missing schema definitions\"\n    );\n}\n\n#[tokio::test]\nasync fn test_check_fails_with_invalid_syntax() {\n    let (_temp_dir, project_path) = setup_project_with_invalid_syntax();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(result.is_err(), \"Check should fail with invalid syntax\");\n}\n\n#[tokio::test]\nasync fn test_check_fails_without_helix_toml() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_err(),\n        \"Check should fail without helix.toml in project\"\n    );\n    let error_msg = format!(\"{:?}\", result.err().unwrap());\n    assert!(\n        error_msg.contains(\"not found\") || error_msg.contains(\"helix.toml\"),\n        \"Error should mention missing helix.toml\"\n    );\n}\n\n#[tokio::test]\nasync fn test_check_with_multiple_instances() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml with multiple instances\n    let mut config = HelixConfig::default_config(\"test-project\");\n    config.local.insert(\n        \"staging\".to_string(),\n        LocalInstanceConfig {\n            port: Some(6970),\n            build_mode: crate::config::BuildMode::Debug,\n            db_config: DbConfig::default(),\n            \n        },\n    );\n    config.local.insert(\n        \"production\".to_string(),\n        LocalInstanceConfig {\n            port: Some(6971),\n            build_mode: crate::config::BuildMode::Debug,\n            db_config: DbConfig::default(),\n            \n        },\n    );\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create valid queries and schema\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\nE::Follows {\n    From: User,\n    To: User,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should succeed with multiple instances: {:?}\",\n        result.err()\n    );\n}\n\n#[tokio::test]\nasync fn test_check_validates_each_instance_individually() {\n    let (_temp_dir, project_path) = setup_valid_project();\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    // Check the specific instance\n    let result = run(Some(\"dev\".to_string()), &metrics_sender).await;\n    assert!(result.is_ok(), \"Check should validate dev instance\");\n}\n\n#[tokio::test]\nasync fn test_check_with_empty_queries_directory() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory but leave it empty\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_err(),\n        \"Check should fail with empty queries directory\"\n    );\n}\n\n#[tokio::test]\nasync fn test_check_with_schema_only() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory with only schema\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    let schema_content = r#\"\nN::User {\n    name: String,\n    email: String,\n}\n\nE::Follows {\n    From: User,\n    To: User,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should succeed with schema only (queries are optional): {:?}\",\n        result.err()\n    );\n}\n\n#[tokio::test]\nasync fn test_check_with_multiple_hx_files() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml\n    let config = HelixConfig::default_config(\"test-project\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create queries directory\n    let queries_dir = project_path.join(\"db\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create queries directory\");\n\n    // Create schema in one file\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    // Create additional schema in another file\n    let more_schema = r#\"\nN::Post {\n    title: String,\n}\n\nE::Authored {\n    From: User,\n    To: Post,\n}\n\"#;\n    fs::write(queries_dir.join(\"more_schema.hx\"), more_schema)\n        .expect(\"Failed to write more_schema.hx\");\n\n    // Create queries in yet another file\n    let queries = r#\"\nQUERY GetUser(id: ID) =>\n    user <- N<User>(id)\n    RETURN user\n\"#;\n    fs::write(queries_dir.join(\"queries.hx\"), queries).expect(\"Failed to write queries.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should succeed with multiple .hx files: {:?}\",\n        result.err()\n    );\n}\n\n#[tokio::test]\nasync fn test_check_with_custom_queries_path() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let project_path = temp_dir.path().to_path_buf();\n\n    // Create helix.toml with custom queries path\n    let mut config = HelixConfig::default_config(\"test-project\");\n    config.project.queries = PathBuf::from(\"custom/helix/queries\");\n    let config_path = project_path.join(\"helix.toml\");\n    config\n        .save_to_file(&config_path)\n        .expect(\"Failed to save config\");\n\n    // Create .helix directory\n    fs::create_dir_all(project_path.join(\".helix\")).expect(\"Failed to create .helix\");\n\n    // Create custom queries directory\n    let queries_dir = project_path.join(\"custom/helix/queries\");\n    fs::create_dir_all(&queries_dir).expect(\"Failed to create custom queries directory\");\n\n    let schema_content = r#\"\nN::User {\n    name: String,\n}\n\"#;\n    fs::write(queries_dir.join(\"schema.hx\"), schema_content)\n        .expect(\"Failed to write schema.hx\");\n\n    let _guard = std::env::set_current_dir(&project_path);\n    let metrics_sender = create_test_metrics_sender();\n\n    let result = run(None, &metrics_sender).await;\n    assert!(\n        result.is_ok(),\n        \"Check should work with custom queries path: {:?}\",\n        result.err()\n    );\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}