{
  "file_path": "/work/internal/fsext/fileutil_test.go",
  "file_hash": "f16a7690a260345de431f90a4f6cf34dff5b697d",
  "updated_at": "2025-12-26T17:34:20.742628",
  "symbols": {
    "function_TestGlobWithDoubleStar_13": {
      "name": "TestGlobWithDoubleStar",
      "type": "function",
      "start_line": 13,
      "end_line": 269,
      "content_hash": "367b4a78ae8726f0a14068048a5a07452fa4057b",
      "content": "func TestGlobWithDoubleStar(t *testing.T) {\n\tt.Run(\"finds files matching pattern\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tmainGo := filepath.Join(testDir, \"src\", \"main.go\")\n\t\tutilsGo := filepath.Join(testDir, \"src\", \"utils.go\")\n\t\thelperGo := filepath.Join(testDir, \"pkg\", \"helper.go\")\n\t\treadmeMd := filepath.Join(testDir, \"README.md\")\n\n\t\tfor _, file := range []string{mainGo, utilsGo, helperGo, readmeMd} {\n\t\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(file), 0o755))\n\t\t\trequire.NoError(t, os.WriteFile(file, []byte(\"test content\"), 0o644))\n\t\t}\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"**/main.go\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\trequire.Equal(t, matches, []string{mainGo})\n\t})\n\n\tt.Run(\"finds directories matching pattern\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tsrcDir := filepath.Join(testDir, \"src\")\n\t\tpkgDir := filepath.Join(testDir, \"pkg\")\n\t\tinternalDir := filepath.Join(testDir, \"internal\")\n\t\tcmdDir := filepath.Join(testDir, \"cmd\")\n\t\tpkgFile := filepath.Join(testDir, \"pkg.txt\")\n\n\t\tfor _, dir := range []string{srcDir, pkgDir, internalDir, cmdDir} {\n\t\t\trequire.NoError(t, os.MkdirAll(dir, 0o755))\n\t\t}\n\n\t\trequire.NoError(t, os.WriteFile(filepath.Join(srcDir, \"main.go\"), []byte(\"package main\"), 0o644))\n\t\trequire.NoError(t, os.WriteFile(pkgFile, []byte(\"test\"), 0o644))\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"pkg\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\trequire.Equal(t, matches, []string{pkgDir})\n\t})\n\n\tt.Run(\"finds nested directories with wildcard patterns\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tsrcPkgDir := filepath.Join(testDir, \"src\", \"pkg\")\n\t\tlibPkgDir := filepath.Join(testDir, \"lib\", \"pkg\")\n\t\tmainPkgDir := filepath.Join(testDir, \"pkg\")\n\t\totherDir := filepath.Join(testDir, \"other\")\n\n\t\tfor _, dir := range []string{srcPkgDir, libPkgDir, mainPkgDir, otherDir} {\n\t\t\trequire.NoError(t, os.MkdirAll(dir, 0o755))\n\t\t}\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"**/pkg\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\tvar relativeMatches []string\n\t\tfor _, match := range matches {\n\t\t\trel, err := filepath.Rel(testDir, match)\n\t\t\trequire.NoError(t, err)\n\t\t\trelativeMatches = append(relativeMatches, filepath.ToSlash(rel))\n\t\t}\n\n\t\trequire.ElementsMatch(t, relativeMatches, []string{\"pkg\", \"src/pkg\", \"lib/pkg\"})\n\t})\n\n\tt.Run(\"finds directory contents with recursive patterns\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tpkgDir := filepath.Join(testDir, \"pkg\")\n\t\tpkgFile1 := filepath.Join(pkgDir, \"main.go\")\n\t\tpkgFile2 := filepath.Join(pkgDir, \"utils.go\")\n\t\tpkgSubdir := filepath.Join(pkgDir, \"internal\")\n\t\tpkgSubfile := filepath.Join(pkgSubdir, \"helper.go\")\n\n\t\trequire.NoError(t, os.MkdirAll(pkgSubdir, 0o755))\n\n\t\tfor _, file := range []string{pkgFile1, pkgFile2, pkgSubfile} {\n\t\t\trequire.NoError(t, os.WriteFile(file, []byte(\"package main\"), 0o644))\n\t\t}\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"pkg/**\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\tvar relativeMatches []string\n\t\tfor _, match := range matches {\n\t\t\trel, err := filepath.Rel(testDir, match)\n\t\t\trequire.NoError(t, err)\n\t\t\trelativeMatches = append(relativeMatches, filepath.ToSlash(rel))\n\t\t}\n\n\t\trequire.ElementsMatch(t, relativeMatches, []string{\n\t\t\t\"pkg\",\n\t\t\t\"pkg/main.go\",\n\t\t\t\"pkg/utils.go\",\n\t\t\t\"pkg/internal\",\n\t\t\t\"pkg/internal/helper.go\",\n\t\t})\n\t})\n\n\tt.Run(\"respects limit parameter\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfor i := range 10 {\n\t\t\tfile := filepath.Join(testDir, \"file\", fmt.Sprintf(\"test%d.txt\", i))\n\t\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(file), 0o755))\n\t\t\trequire.NoError(t, os.WriteFile(file, []byte(\"test\"), 0o644))\n\t\t}\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"**/*.txt\", testDir, 5)\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, truncated, \"Expected truncation with limit\")\n\t\trequire.Len(t, matches, 5, \"Expected exactly 5 matches with limit\")\n\t})\n\n\tt.Run(\"handles nested directory patterns\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfile1 := filepath.Join(testDir, \"a\", \"b\", \"c\", \"file1.txt\")\n\t\tfile2 := filepath.Join(testDir, \"a\", \"b\", \"file2.txt\")\n\t\tfile3 := filepath.Join(testDir, \"a\", \"file3.txt\")\n\t\tfile4 := filepath.Join(testDir, \"file4.txt\")\n\n\t\tfor _, file := range []string{file1, file2, file3, file4} {\n\t\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(file), 0o755))\n\t\t\trequire.NoError(t, os.WriteFile(file, []byte(\"test\"), 0o644))\n\t\t}\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"a/b/c/file1.txt\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\trequire.Equal(t, []string{file1}, matches)\n\t})\n\n\tt.Run(\"returns results sorted by modification time (newest first)\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfile1 := filepath.Join(testDir, \"file1.txt\")\n\t\trequire.NoError(t, os.WriteFile(file1, []byte(\"first\"), 0o644))\n\n\t\tfile2 := filepath.Join(testDir, \"file2.txt\")\n\t\trequire.NoError(t, os.WriteFile(file2, []byte(\"second\"), 0o644))\n\n\t\tfile3 := filepath.Join(testDir, \"file3.txt\")\n\t\trequire.NoError(t, os.WriteFile(file3, []byte(\"third\"), 0o644))\n\n\t\tbase := time.Now()\n\t\tm1 := base\n\t\tm2 := base.Add(10 * time.Hour)\n\t\tm3 := base.Add(20 * time.Hour)\n\n\t\trequire.NoError(t, os.Chtimes(file1, m1, m1))\n\t\trequire.NoError(t, os.Chtimes(file2, m2, m2))\n\t\trequire.NoError(t, os.Chtimes(file3, m3, m3))\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"*.txt\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\n\t\trequire.Equal(t, []string{file3, file2, file1}, matches)\n\t})\n\n\tt.Run(\"handles empty directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"**\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\t\t// Even empty directories should return the directory itself\n\t\trequire.Equal(t, []string{testDir}, matches)\n\t})\n\n\tt.Run(\"handles non-existent search path\", func(t *testing.T) {\n\t\tnonExistentDir := filepath.Join(t.TempDir(), \"does\", \"not\", \"exist\")\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"**\", nonExistentDir, 0)\n\t\trequire.Error(t, err, \"Should return error for non-existent search path\")\n\t\trequire.False(t, truncated)\n\t\trequire.Empty(t, matches)\n\t})\n\n\tt.Run(\"respects basic ignore patterns\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\trootIgnore := filepath.Join(testDir, \".nexoraignore\")\n\n\t\trequire.NoError(t, os.WriteFile(rootIgnore, []byte(\"*.tmp\\nbackup/\\n\"), 0o644))\n\n\t\tgoodFile := filepath.Join(testDir, \"good.txt\")\n\t\trequire.NoError(t, os.WriteFile(goodFile, []byte(\"content\"), 0o644))\n\n\t\tbadFile := filepath.Join(testDir, \"bad.tmp\")\n\t\trequire.NoError(t, os.WriteFile(badFile, []byte(\"temp content\"), 0o644))\n\n\t\tgoodDir := filepath.Join(testDir, \"src\")\n\t\trequire.NoError(t, os.MkdirAll(goodDir, 0o755))\n\n\t\tignoredDir := filepath.Join(testDir, \"backup\")\n\t\trequire.NoError(t, os.MkdirAll(ignoredDir, 0o755))\n\n\t\tignoredFileInDir := filepath.Join(testDir, \"backup\", \"old.txt\")\n\t\trequire.NoError(t, os.WriteFile(ignoredFileInDir, []byte(\"old content\"), 0o644))\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"*.tmp\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\t\trequire.Empty(t, matches, \"Expected no matches for '*.tmp' pattern (should be ignored)\")\n\n\t\tmatches, truncated, err = GlobWithDoubleStar(\"backup\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\t\trequire.Empty(t, matches, \"Expected no matches for 'backup' pattern (should be ignored)\")\n\n\t\tmatches, truncated, err = GlobWithDoubleStar(\"*.txt\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\t\trequire.Equal(t, []string{goodFile}, matches)\n\t})\n\n\tt.Run(\"handles mixed file and directory matching with sorting\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\toldestFile := filepath.Join(testDir, \"old.rs\")\n\t\trequire.NoError(t, os.WriteFile(oldestFile, []byte(\"old\"), 0o644))\n\n\t\tmiddleDir := filepath.Join(testDir, \"mid.rs\")\n\t\trequire.NoError(t, os.MkdirAll(middleDir, 0o755))\n\n\t\tnewestFile := filepath.Join(testDir, \"new.rs\")\n\t\trequire.NoError(t, os.WriteFile(newestFile, []byte(\"new\"), 0o644))\n\n\t\tbase := time.Now()\n\t\ttOldest := base\n\t\ttMiddle := base.Add(10 * time.Hour)\n\t\ttNewest := base.Add(20 * time.Hour)\n\n\t\t// Reverse the expected order\n\t\trequire.NoError(t, os.Chtimes(newestFile, tOldest, tOldest))\n\t\trequire.NoError(t, os.Chtimes(middleDir, tMiddle, tMiddle))\n\t\trequire.NoError(t, os.Chtimes(oldestFile, tNewest, tNewest))\n\n\t\tmatches, truncated, err := GlobWithDoubleStar(\"*.rs\", testDir, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, truncated)\n\t\trequire.Len(t, matches, 3)\n\n\t\t// Results should be sorted by mod time, but we set the oldestFile\n\t\t// to have the most recent mod time\n\t\trequire.Equal(t, []string{oldestFile, middleDir, newestFile}, matches)\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}