{
  "file_path": "/work/internal/update/update_test.go",
  "file_hash": "2cf26cd591eec58af3751501e66be6f2ea6dd619",
  "updated_at": "2025-12-26T17:34:22.355681",
  "symbols": {
    "function_TestCheckForUpdate_Old_11": {
      "name": "TestCheckForUpdate_Old",
      "type": "function",
      "start_line": 11,
      "end_line": 17,
      "content_hash": "687315b730b03a4870e818200b80a9a317d1047a",
      "content": "func TestCheckForUpdate_Old(t *testing.T) {\n\tinfo, err := Check(t.Context(), \"v0.10.0\", testClient{\"v0.11.0\"})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, info)\n\trequire.True(t, info.Available())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCheckForUpdate_Beta_18": {
      "name": "TestCheckForUpdate_Beta",
      "type": "function",
      "start_line": 18,
      "end_line": 41,
      "content_hash": "1ea0d0b41ffa25197a8ba2fc6b9f7413fe883f95",
      "content": "func TestCheckForUpdate_Beta(t *testing.T) {\n\tt.Run(\"current is stable\", func(t *testing.T) {\n\t\tinfo, err := Check(t.Context(), \"v0.10.0\", testClient{\"v0.11.0-beta.1\"})\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, info)\n\t\trequire.False(t, info.Available())\n\t})\n\n\tt.Run(\"current is also beta\", func(t *testing.T) {\n\t\tinfo, err := Check(t.Context(), \"v0.11.0-beta.1\", testClient{\"v0.11.0-beta.2\"})\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, info)\n\t\trequire.True(t, info.Available())\n\t})\n\n\tt.Run(\"current is beta, latest isn't\", func(t *testing.T) {\n\t\tinfo, err := Check(t.Context(), \"v0.11.0-beta.1\", testClient{\"v0.11.0\"})\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, info)\n\t\trequire.True(t, info.Available())\n\t})\n}\n\n// TestInfoAvailable verifies update availability logic",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInfoAvailable_42": {
      "name": "TestInfoAvailable",
      "type": "function",
      "start_line": 42,
      "end_line": 73,
      "content_hash": "9d236da62750cba1967fccdde8b2ac55338bdcbd",
      "content": "func TestInfoAvailable(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tcurrent   string\n\t\tlatest    string\n\t\tavailable bool\n\t}{\n\t\t{\"same version\", \"1.0.0\", \"1.0.0\", false},\n\t\t{\"newer version\", \"1.0.0\", \"1.1.0\", true},\n\t\t{\"older version\", \"1.1.0\", \"1.0.0\", true}, // Different = available\n\t\t{\"current beta, latest stable\", \"1.0.0-beta\", \"1.0.0\", true},\n\t\t{\"current stable, latest beta\", \"1.0.0\", \"1.0.0-beta\", false},\n\t\t{\"both beta, same\", \"1.0.0-beta.1\", \"1.0.0-beta.1\", false},\n\t\t{\"both beta, different\", \"1.0.0-beta.1\", \"1.0.0-beta.2\", true},\n\t\t{\"current rc, latest stable\", \"1.0.0-rc.1\", \"1.0.0\", true},\n\t\t{\"current stable, latest rc\", \"1.0.0\", \"1.0.0-rc.1\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinfo := Info{\n\t\t\t\tCurrent: tt.current,\n\t\t\t\tLatest:  tt.latest,\n\t\t\t}\n\t\t\tif got := info.Available(); got != tt.available {\n\t\t\t\tt.Errorf(\"Available() = %v, want %v\", got, tt.available)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestInfoIsDevelopment verifies development version detection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInfoIsDevelopment_74": {
      "name": "TestInfoIsDevelopment",
      "type": "function",
      "start_line": 74,
      "end_line": 101,
      "content_hash": "0083673ab4fb78db3ae77dec734573aa4b5bf5d9",
      "content": "func TestInfoIsDevelopment(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tcurrent string\n\t\tisDev   bool\n\t}{\n\t\t{\"devel\", \"devel\", true},\n\t\t{\"unknown\", \"unknown\", true},\n\t\t{\"dirty\", \"v1.0.0-dirty\", true},\n\t\t{\"go install version\", \"v0.0.0-0.20251231235959-06c807842604\", true},\n\t\t{\"go install no v prefix\", \"0.0.0-0.20251231235959-06c807842604\", true},\n\t\t{\"stable version\", \"1.0.0\", false},\n\t\t{\"stable with v\", \"v1.0.0\", false},\n\t\t{\"beta version\", \"1.0.0-beta.1\", false},\n\t\t{\"rc version\", \"1.0.0-rc.1\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinfo := Info{Current: tt.current}\n\t\t\tif got := info.IsDevelopment(); got != tt.isDev {\n\t\t\t\tt.Errorf(\"IsDevelopment() = %v, want %v\", got, tt.isDev)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCheck verifies the Check function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCheck_102": {
      "name": "TestCheck",
      "type": "function",
      "start_line": 102,
      "end_line": 144,
      "content_hash": "0b222540aa28a86fd92dbb89060cdb4fa54c54da",
      "content": "func TestCheck(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tclient := testClient{tag: \"v1.2.3\"}\n\t\tinfo, err := Check(context.Background(), \"v1.0.0\", client)\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"1.0.0\", info.Current)\n\t\trequire.Equal(t, \"1.2.3\", info.Latest)\n\t\trequire.Equal(t, \"https://example.org\", info.URL)\n\t\trequire.True(t, info.Available())\n\t})\n\n\tt.Run(\"same version\", func(t *testing.T) {\n\t\tclient := testClient{tag: \"v1.0.0\"}\n\t\tinfo, err := Check(context.Background(), \"v1.0.0\", client)\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"1.0.0\", info.Current)\n\t\trequire.Equal(t, \"1.0.0\", info.Latest)\n\t\trequire.False(t, info.Available())\n\t})\n\n\tt.Run(\"no v prefix\", func(t *testing.T) {\n\t\tclient := testClient{tag: \"1.2.3\"}\n\t\tinfo, err := Check(context.Background(), \"1.0.0\", client)\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"1.0.0\", info.Current)\n\t\trequire.Equal(t, \"1.2.3\", info.Latest)\n\t})\n\n\tt.Run(\"client error\", func(t *testing.T) {\n\t\tclient := errorClient{err: errors.New(\"network error\")}\n\t\tinfo, err := Check(context.Background(), \"1.0.0\", client)\n\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"failed to fetch latest release\")\n\t\trequire.Equal(t, \"1.0.0\", info.Current)\n\t\trequire.Equal(t, \"1.0.0\", info.Latest) // Falls back to current\n\t})\n}\n\n// TestGoInstallRegexp verifies the go install version pattern",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGoInstallRegexp_145": {
      "name": "TestGoInstallRegexp",
      "type": "function",
      "start_line": 145,
      "end_line": 170,
      "content_hash": "9d94eab2898578c70ec8faf354b20ebb5e71d093",
      "content": "func TestGoInstallRegexp(t *testing.T) {\n\ttests := []struct {\n\t\tversion string\n\t\tmatches bool\n\t}{\n\t\t{\"v0.0.0-0.20251231235959-06c807842604\", true},\n\t\t{\"0.0.0-0.20251231235959-06c807842604\", true},\n\t\t{\"v0.0.0-0.20230101000000-123456789abc\", true},\n\t\t{\"v1.2.3\", false},\n\t\t{\"1.2.3-beta.1\", false},\n\t\t{\"devel\", false},\n\t\t{\"v0.0.0-0.20251231235959\", false},                    // Missing commit hash\n\t\t{\"v0.0.0-0.20251231235959-06c807842604-extra\", false}, // Extra suffix\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.version, func(t *testing.T) {\n\t\t\tif got := goInstallRegexp.MatchString(tt.version); got != tt.matches {\n\t\t\t\tt.Errorf(\"goInstallRegexp.MatchString(%q) = %v, want %v\",\n\t\t\t\t\ttt.version, got, tt.matches)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestInfoStruct verifies Info struct fields",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestInfoStruct_171": {
      "name": "TestInfoStruct",
      "type": "function",
      "start_line": 171,
      "end_line": 185,
      "content_hash": "8d15a56e6e362c38fac30111d62c7ed25a55598d",
      "content": "func TestInfoStruct(t *testing.T) {\n\tinfo := Info{\n\t\tCurrent: \"1.0.0\",\n\t\tLatest:  \"1.1.0\",\n\t\tURL:     \"https://github.com/example/repo/releases/tag/v1.1.0\",\n\t}\n\n\trequire.Equal(t, \"1.0.0\", info.Current)\n\trequire.Equal(t, \"1.1.0\", info.Latest)\n\trequire.Equal(t, \"https://github.com/example/repo/releases/tag/v1.1.0\", info.URL)\n\trequire.True(t, info.Available())\n\trequire.False(t, info.IsDevelopment())\n}\n\n// TestReleaseStruct verifies Release struct",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestReleaseStruct_186": {
      "name": "TestReleaseStruct",
      "type": "function",
      "start_line": 186,
      "end_line": 196,
      "content_hash": "ba5213490f0480d94593a110c1cb8244e30de11f",
      "content": "func TestReleaseStruct(t *testing.T) {\n\trelease := Release{\n\t\tTagName: \"v1.2.3\",\n\t\tHTMLURL: \"https://github.com/example/repo/releases/tag/v1.2.3\",\n\t}\n\n\trequire.Equal(t, \"v1.2.3\", release.TagName)\n\trequire.Equal(t, \"https://github.com/example/repo/releases/tag/v1.2.3\", release.HTMLURL)\n}\n\n// TestDefaultClient verifies the default client is set",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestDefaultClient_197": {
      "name": "TestDefaultClient",
      "type": "function",
      "start_line": 197,
      "end_line": 204,
      "content_hash": "906ce649198dee57bdbf5a8570f65dc9b9db8133",
      "content": "func TestDefaultClient(t *testing.T) {\n\trequire.NotNil(t, Default)\n\n\t// Verify it implements Client interface\n\tvar _ Client = Default\n}\n\n// TestCheckWithContext verifies context handling",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCheckWithContext_205": {
      "name": "TestCheckWithContext",
      "type": "function",
      "start_line": 205,
      "end_line": 226,
      "content_hash": "ca1b6320faf0daa74e4a55af144f04c3f7af6bab",
      "content": "func TestCheckWithContext(t *testing.T) {\n\tt.Run(\"context not cancelled\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tclient := testClient{tag: \"v1.0.0\"}\n\t\tinfo, err := Check(ctx, \"v1.0.0\", client)\n\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, info)\n\t})\n\n\tt.Run(\"context with timeout\", func(t *testing.T) {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel() // Cancel immediately\n\n\t\tclient := cancelClient{}\n\t\t_, err := Check(ctx, \"v1.0.0\", client)\n\n\t\t// Should get context cancelled error\n\t\trequire.Error(t, err)\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_testClient_227": {
      "name": "testClient",
      "type": "struct",
      "start_line": 227,
      "end_line": 229,
      "content_hash": "8a5960f9b4625cc3f87692c504ca850ab6feb1fd",
      "content": "type testClient struct{ tag string }\n\n// Latest implements Client.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Latest_230": {
      "name": "Latest",
      "type": "method",
      "start_line": 230,
      "end_line": 236,
      "content_hash": "da3ee7e1437c48cf96a96d501072711c834eea7a",
      "content": "func (t testClient) Latest(ctx context.Context) (*Release, error) {\n\treturn &Release{\n\t\tTagName: t.tag,\n\t\tHTMLURL: \"https://example.org\",\n\t}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_errorClient_237": {
      "name": "errorClient",
      "type": "struct",
      "start_line": 237,
      "end_line": 239,
      "content_hash": "26c5d78a9f60c49199f0a378c7b053fdf4087ed2",
      "content": "type errorClient struct{ err error }\n\n// Latest implements Client.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Latest_240": {
      "name": "Latest",
      "type": "method",
      "start_line": 240,
      "end_line": 243,
      "content_hash": "ca4a881992b8636b9710bfdf2754a9d49685a738",
      "content": "func (e errorClient) Latest(ctx context.Context) (*Release, error) {\n\treturn nil, e.err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_cancelClient_244": {
      "name": "cancelClient",
      "type": "struct",
      "start_line": 244,
      "end_line": 246,
      "content_hash": "df7fa7908bd7e094bfaf63a31e6202b91ad67ed3",
      "content": "type cancelClient struct{}\n\n// Latest implements Client.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Latest_247": {
      "name": "Latest",
      "type": "method",
      "start_line": 247,
      "end_line": 255,
      "content_hash": "90cb49bf4839d4c4fa76a9a9ffbf78fa142e11e8",
      "content": "func (c cancelClient) Latest(ctx context.Context) (*Release, error) {\n\t// Check if context is cancelled\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t\treturn &Release{TagName: \"v1.0.0\", HTMLURL: \"https://example.org\"}, nil\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}