{
  "file_path": "/work/internal/agent/tools/multiedit_test.go",
  "file_hash": "eb9d7c23c2ed4ca96c92d8574d05c45253e076a1",
  "updated_at": "2025-12-26T17:34:21.333864",
  "symbols": {
    "struct_mockPermissionService_17": {
      "name": "mockPermissionService",
      "type": "struct",
      "start_line": 17,
      "end_line": 20,
      "content_hash": "38b4605ce7369f148dcfb089cc01a98108045910",
      "content": "type mockPermissionService struct {\n\t*pubsub.Broker[permission.PermissionRequest]\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Request_21": {
      "name": "Request",
      "type": "method",
      "start_line": 21,
      "end_line": 24,
      "content_hash": "502ff41107c8654776b39d266a17bfbb2f100e8a",
      "content": "func (m *mockPermissionService) Request(req permission.CreatePermissionRequest) bool {\n\treturn true\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Grant_25": {
      "name": "Grant",
      "type": "method",
      "start_line": 25,
      "end_line": 26,
      "content_hash": "5157d5aca294eb2dc65de4eb859a7aad7e7a9e41",
      "content": "func (m *mockPermissionService) Grant(req permission.PermissionRequest) {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Deny_27": {
      "name": "Deny",
      "type": "method",
      "start_line": 27,
      "end_line": 28,
      "content_hash": "59ef5a7fa978171aa87ecc9190f28d9a6976ec8f",
      "content": "func (m *mockPermissionService) Deny(req permission.PermissionRequest) {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GrantPersistent_29": {
      "name": "GrantPersistent",
      "type": "method",
      "start_line": 29,
      "end_line": 30,
      "content_hash": "bd24b161e3bb2a89185a0d62f3a6d3701b7bf478",
      "content": "func (m *mockPermissionService) GrantPersistent(req permission.PermissionRequest) {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_AutoApproveSession_31": {
      "name": "AutoApproveSession",
      "type": "method",
      "start_line": 31,
      "end_line": 32,
      "content_hash": "aac4abcb7e594ac31b896c07ae5831c172914959",
      "content": "func (m *mockPermissionService) AutoApproveSession(sessionID string) {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSkipRequests_33": {
      "name": "SetSkipRequests",
      "type": "method",
      "start_line": 33,
      "end_line": 34,
      "content_hash": "8b667c0c204937354a13e3cd8b0b3f16e16dd261",
      "content": "func (m *mockPermissionService) SetSkipRequests(skip bool) {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SkipRequests_35": {
      "name": "SkipRequests",
      "type": "method",
      "start_line": 35,
      "end_line": 38,
      "content_hash": "0f027c190e40f9f6cc1a88415a1d57f245d897ae",
      "content": "func (m *mockPermissionService) SkipRequests() bool {\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SubscribeNotifications_39": {
      "name": "SubscribeNotifications",
      "type": "method",
      "start_line": 39,
      "end_line": 42,
      "content_hash": "4a7db142c89960452f2b9c31eaae6bf7cc544cb5",
      "content": "func (m *mockPermissionService) SubscribeNotifications(ctx context.Context) <-chan pubsub.Event[permission.PermissionNotification] {\n\treturn make(<-chan pubsub.Event[permission.PermissionNotification])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_mockHistoryService_43": {
      "name": "mockHistoryService",
      "type": "struct",
      "start_line": 43,
      "end_line": 46,
      "content_hash": "cde14280c245756633f13f9367462f87ee7b13ae",
      "content": "type mockHistoryService struct {\n\t*pubsub.Broker[history.File]\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Create_47": {
      "name": "Create",
      "type": "method",
      "start_line": 47,
      "end_line": 50,
      "content_hash": "fde115971fc96ac6bbb564684096e608817be988",
      "content": "func (m *mockHistoryService) Create(ctx context.Context, sessionID, path, content string) (history.File, error) {\n\treturn history.File{Path: path, Content: content}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CreateVersion_51": {
      "name": "CreateVersion",
      "type": "method",
      "start_line": 51,
      "end_line": 54,
      "content_hash": "f184d90cf1c75f6a50f1afb8d2a8e61f3ada33e9",
      "content": "func (m *mockHistoryService) CreateVersion(ctx context.Context, sessionID, path, content string) (history.File, error) {\n\treturn history.File{}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetByPathAndSession_55": {
      "name": "GetByPathAndSession",
      "type": "method",
      "start_line": 55,
      "end_line": 58,
      "content_hash": "cc58835d90c1f98b1458be617225d1621296e153",
      "content": "func (m *mockHistoryService) GetByPathAndSession(ctx context.Context, path, sessionID string) (history.File, error) {\n\treturn history.File{Path: path, Content: \"\"}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Get_59": {
      "name": "Get",
      "type": "method",
      "start_line": 59,
      "end_line": 62,
      "content_hash": "d1edea82f71064c79b963a296033e64c2314c155",
      "content": "func (m *mockHistoryService) Get(ctx context.Context, id string) (history.File, error) {\n\treturn history.File{}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListBySession_63": {
      "name": "ListBySession",
      "type": "method",
      "start_line": 63,
      "end_line": 66,
      "content_hash": "83f82e33316bd5080a1a929172ae0fb04db4bd22",
      "content": "func (m *mockHistoryService) ListBySession(ctx context.Context, sessionID string) ([]history.File, error) {\n\treturn nil, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ListLatestSessionFiles_67": {
      "name": "ListLatestSessionFiles",
      "type": "method",
      "start_line": 67,
      "end_line": 70,
      "content_hash": "ba0db72a5766aa383e9631c7040b1ebd39bf8dc7",
      "content": "func (m *mockHistoryService) ListLatestSessionFiles(ctx context.Context, sessionID string) ([]history.File, error) {\n\treturn nil, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Delete_71": {
      "name": "Delete",
      "type": "method",
      "start_line": 71,
      "end_line": 74,
      "content_hash": "966fca6e24cc20ab2b4e6a727e9db870aa795dc1",
      "content": "func (m *mockHistoryService) Delete(ctx context.Context, id string) error {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_DeleteSessionFiles_75": {
      "name": "DeleteSessionFiles",
      "type": "method",
      "start_line": 75,
      "end_line": 78,
      "content_hash": "fae4d9ebe52e3ca844f2f37d25f38c2bc8a818ab",
      "content": "func (m *mockHistoryService) DeleteSessionFiles(ctx context.Context, sessionID string) error {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestApplyEditToContentPartialSuccess_79": {
      "name": "TestApplyEditToContentPartialSuccess",
      "type": "function",
      "start_line": 79,
      "end_line": 101,
      "content_hash": "abc3cd9ee74d0273e96964707cf3b30a5dee665d",
      "content": "func TestApplyEditToContentPartialSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tcontent := \"line 1\\nline 2\\nline 3\\n\"\n\n\t// Test successful edit.\n\tnewContent, err := applyEditToContent(context.Background(), \"test.txt\", content, MultiEditOperation{\n\t\tOldString: \"line 1\",\n\t\tNewString: \"LINE 1\",\n\t})\n\trequire.NoError(t, err)\n\trequire.Contains(t, newContent, \"LINE 1\")\n\trequire.Contains(t, newContent, \"line 2\")\n\n\t// Test failed edit (string not found).\n\t_, err = applyEditToContent(context.Background(), \"test.txt\", content, MultiEditOperation{\n\t\tOldString: \"line 99\",\n\t\tNewString: \"LINE 99\",\n\t})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"not found\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMultiEditSequentialApplication_102": {
      "name": "TestMultiEditSequentialApplication",
      "type": "function",
      "start_line": 102,
      "end_line": 167,
      "content_hash": "0e1bb3f7bccf8c2a96dbf0b46570ed8c32473d1b",
      "content": "func TestMultiEditSequentialApplication(t *testing.T) {\n\tt.Parallel()\n\n\ttmpDir := t.TempDir()\n\ttestFile := filepath.Join(tmpDir, \"test.txt\")\n\n\t// Create test file.\n\tcontent := \"line 1\\nline 2\\nline 3\\nline 4\\n\"\n\terr := os.WriteFile(testFile, []byte(content), 0o644)\n\trequire.NoError(t, err)\n\n\t// Mock components.\n\tlspClients := csync.NewMap[string, *lsp.Client]()\n\tpermissions := &mockPermissionService{Broker: pubsub.NewBroker[permission.PermissionRequest]()}\n\tfiles := &mockHistoryService{Broker: pubsub.NewBroker[history.File]()}\n\n\t// Create multiedit tool.\n\t_ = NewMultiEditTool(lspClients, permissions, files, tmpDir, nil)\n\n\t// Simulate reading the file first.\n\trecordFileRead(testFile)\n\n\t// Manually test the sequential application logic.\n\tcurrentContent := content\n\n\t// Apply edits sequentially, tracking failures.\n\tedits := []MultiEditOperation{\n\t\t{OldString: \"line 1\", NewString: \"LINE 1\"},   // Should succeed\n\t\t{OldString: \"line 99\", NewString: \"LINE 99\"}, // Should fail - doesn't exist\n\t\t{OldString: \"line 3\", NewString: \"LINE 3\"},   // Should succeed\n\t\t{OldString: \"line 2\", NewString: \"LINE 2\"},   // Should succeed - still exists\n\t}\n\n\tvar failedEdits []FailedEdit\n\tsuccessCount := 0\n\n\tfor i, edit := range edits {\n\t\tnewContent, err := applyEditToContent(context.Background(), \"test.txt\", currentContent, edit)\n\t\tif err != nil {\n\t\t\tfailedEdits = append(failedEdits, FailedEdit{\n\t\t\t\tIndex: i + 1,\n\t\t\t\tError: err.Error(),\n\t\t\t\tEdit:  edit,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tcurrentContent = newContent\n\t\tsuccessCount++\n\t}\n\n\t// Verify results.\n\trequire.Equal(t, 3, successCount, \"Expected 3 successful edits\")\n\trequire.Len(t, failedEdits, 1, \"Expected 1 failed edit\")\n\n\t// Check failed edit details.\n\trequire.Equal(t, 2, failedEdits[0].Index)\n\trequire.Contains(t, failedEdits[0].Error, \"not found\")\n\n\t// Verify content changes.\n\trequire.Contains(t, currentContent, \"LINE 1\")\n\trequire.Contains(t, currentContent, \"LINE 2\")\n\trequire.Contains(t, currentContent, \"LINE 3\")\n\trequire.Contains(t, currentContent, \"line 4\") // Original unchanged\n\trequire.NotContains(t, currentContent, \"LINE 99\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMultiEditAllEditsSucceed_168": {
      "name": "TestMultiEditAllEditsSucceed",
      "type": "function",
      "start_line": 168,
      "end_line": 196,
      "content_hash": "2a02207f255da85288609fa02595bff16ef34258",
      "content": "func TestMultiEditAllEditsSucceed(t *testing.T) {\n\tt.Parallel()\n\n\tcontent := \"line 1\\nline 2\\nline 3\\n\"\n\n\tedits := []MultiEditOperation{\n\t\t{OldString: \"line 1\", NewString: \"LINE 1\"},\n\t\t{OldString: \"line 2\", NewString: \"LINE 2\"},\n\t\t{OldString: \"line 3\", NewString: \"LINE 3\"},\n\t}\n\n\tcurrentContent := content\n\tsuccessCount := 0\n\n\tfor _, edit := range edits {\n\t\tnewContent, err := applyEditToContent(context.Background(), \"test.txt\", currentContent, edit)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tcurrentContent = newContent\n\t\tsuccessCount++\n\t}\n\n\trequire.Equal(t, 3, successCount)\n\trequire.Contains(t, currentContent, \"LINE 1\")\n\trequire.Contains(t, currentContent, \"LINE 2\")\n\trequire.Contains(t, currentContent, \"LINE 3\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMultiEditAllEditsFail_197": {
      "name": "TestMultiEditAllEditsFail",
      "type": "function",
      "start_line": 197,
      "end_line": 225,
      "content_hash": "1819c0cac8937159d609fa9473635ddbb7723604",
      "content": "func TestMultiEditAllEditsFail(t *testing.T) {\n\tt.Parallel()\n\n\tcontent := \"line 1\\nline 2\\n\"\n\n\tedits := []MultiEditOperation{\n\t\t{OldString: \"line 99\", NewString: \"LINE 99\"},\n\t\t{OldString: \"line 100\", NewString: \"LINE 100\"},\n\t}\n\n\tcurrentContent := content\n\tvar failedEdits []FailedEdit\n\n\tfor i, edit := range edits {\n\t\tnewContent, err := applyEditToContent(context.Background(), \"test.txt\", currentContent, edit)\n\t\tif err != nil {\n\t\t\tfailedEdits = append(failedEdits, FailedEdit{\n\t\t\t\tIndex: i + 1,\n\t\t\t\tError: err.Error(),\n\t\t\t\tEdit:  edit,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tcurrentContent = newContent\n\t}\n\n\trequire.Len(t, failedEdits, 2)\n\trequire.Equal(t, content, currentContent, \"Content should be unchanged\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}