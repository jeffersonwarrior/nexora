{
  "file_path": "/work/internal/agent/tools/edit.go",
  "file_hash": "7b3f583a03c33ab4e07baea49a797d76819056fb",
  "updated_at": "2025-12-26T17:34:21.814509",
  "symbols": {
    "function_normalizeTabIndicators_25": {
      "name": "normalizeTabIndicators",
      "type": "function",
      "start_line": 25,
      "end_line": 34,
      "content_hash": "fa32783ff656557619d140ff9a9237b1ae878972",
      "content": "func normalizeTabIndicators(content string) string {\n\t// Convert display format \u2192\\t back to actual tabs \\t\n\tcontent = strings.ReplaceAll(content, \"\u2192\\t\", \"\\t\")\n\t// Also handle cases where only \u2192 is present\n\tcontent = strings.ReplaceAll(content, \"\u2192\", \"\\t\")\n\treturn content\n}\n\nvar sqlcSourceDir = \"/home/nexora/internal/db/sql\"\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isSQLCProject_35": {
      "name": "isSQLCProject",
      "type": "function",
      "start_line": 35,
      "end_line": 40,
      "content_hash": "5dcc6e2b9563cb3342c3b05e411be761be9fecad",
      "content": "func isSQLCProject() bool {\n\t_, errSqlc := os.Stat(\"/home/nexora/sqlc.yaml\")\n\t_, errFiles := os.Stat(\"/home/nexora/internal/db/files.sql.go\")\n\treturn errSqlc == nil && errFiles == nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isSQLCGeneratedFile_41": {
      "name": "isSQLCGeneratedFile",
      "type": "function",
      "start_line": 41,
      "end_line": 49,
      "content_hash": "d02926a6db5fc4328dc029f5f77833c2faac1774",
      "content": "func isSQLCGeneratedFile(filePath string) (bool, string) {\n\tif !strings.HasSuffix(filePath, \".sql.go\") {\n\t\treturn false, \"\"\n\t}\n\tbase := filepath.Base(filePath)\n\tsourcePath := filepath.Join(sqlcSourceDir, strings.TrimSuffix(base, \".go\")+\".sql\")\n\treturn true, sourcePath\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EditParams_50": {
      "name": "EditParams",
      "type": "struct",
      "start_line": 50,
      "end_line": 57,
      "content_hash": "08b1bad4cb71bb6e75710ab54031407858a668ff",
      "content": "type EditParams struct {\n\tFilePath   string `json:\"file_path\" description:\"The absolute path to the file to modify\"`\n\tOldString  string `json:\"old_string\" description:\"The text to replace\"`\n\tNewString  string `json:\"new_string\" description:\"The text to replace it with\"`\n\tReplaceAll bool   `json:\"replace_all,omitempty\" description:\"Replace all occurrences of old_string (default false)\"`\n\tAIMode     bool   `json:\"ai_mode,omitempty\" description:\"Enable AI-optimized editing with automatic context expansion and improved error handling (DEFAULT: true)\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EditPermissionsParams_58": {
      "name": "EditPermissionsParams",
      "type": "struct",
      "start_line": 58,
      "end_line": 63,
      "content_hash": "46257c163ee4f84d95c3d62e0d9e55dba8778eef",
      "content": "type EditPermissionsParams struct {\n\tFilePath   string `json:\"file_path\"`\n\tOldContent string `json:\"old_content,omitempty\"`\n\tNewContent string `json:\"new_content,omitempty\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EditResponseMetadata_64": {
      "name": "EditResponseMetadata",
      "type": "struct",
      "start_line": 64,
      "end_line": 75,
      "content_hash": "ab1a6557b3818281e23672ff2f07a8ef5e33f8d0",
      "content": "type EditResponseMetadata struct {\n\tAdditions  int    `json:\"additions\"`\n\tRemovals   int    `json:\"removals\"`\n\tOldContent string `json:\"old_content,omitempty\"`\n\tNewContent string `json:\"new_content,omitempty\"`\n}\n\nconst EditToolName = \"edit\"\n\n//go:embed edit.md\nvar editDescription []byte\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_editContext_76": {
      "name": "editContext",
      "type": "struct",
      "start_line": 76,
      "end_line": 83,
      "content_hash": "726f74cc7b8e04f8367256eec07972b0934dcbb3",
      "content": "type editContext struct {\n\tctx         context.Context\n\tpermissions permission.Service\n\tfiles       history.Service\n\tworkingDir  string\n\taiops       aiops.Ops\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewEditTool_84": {
      "name": "NewEditTool",
      "type": "function",
      "start_line": 84,
      "end_line": 176,
      "content_hash": "1b35b42871cf9512cddcc53d6d16e231a3c14a9e",
      "content": "func NewEditTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, files history.Service, workingDir string, aiops aiops.Ops) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tEditToolName,\n\t\tstring(editDescription),\n\t\tfunc(ctx context.Context, params EditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\t// COMPREHENSIVE LOGGING - Fail Fast, Fix Fast\n\t\t\tslog.Info(\"EDIT TOOL INVOKED\",\n\t\t\t\t\"file\", params.FilePath,\n\t\t\t\t\"old_string_length\", len(params.OldString),\n\t\t\t\t\"new_string_length\", len(params.NewString),\n\t\t\t\t\"ai_mode_original\", params.AIMode,\n\t\t\t\t\"replace_all\", params.ReplaceAll)\n\n\t\t\t// FORCE AI MODE = true by default (eliminates 90% of failures)\n\t\t\tif !params.AIMode {\n\t\t\t\tslog.Warn(\"AI mode forced to true - this eliminates most whitespace/tab failures\", \"file\", params.FilePath)\n\t\t\t\tparams.AIMode = true\n\t\t\t}\n\n\t\t\tslog.Info(\"AI MODE STATUS\", \"final_ai_mode\", params.AIMode)\n\n\t\t\tif params.FilePath == \"\" {\n\t\t\t\tslog.Error(\"EDIT FAILED: No file path provided\")\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"file_path is required\"), nil\n\t\t\t}\n\n\t\t\tparams.FilePath = filepathext.SmartJoin(workingDir, params.FilePath)\n\t\t\tslog.Info(\"FILE RESOLVED\", \"final_path\", params.FilePath)\n\n\t\t\t// LOG EXACT STRINGS ON FAILURE\n\t\t\tif params.OldString != \"\" {\n\t\t\t\tslog.Debug(\"OLD STRING DETAILS\",\n\t\t\t\t\t\"content\", params.OldString,\n\t\t\t\t\t\"lines\", strings.Count(params.OldString, \"\\n\")+1,\n\t\t\t\t\t\"has_tabs\", strings.Contains(params.OldString, \"\\t\"),\n\t\t\t\t\t\"trail_spaces\", strings.HasSuffix(params.OldString, \" \"))\n\t\t\t}\n\n\t\t\tvar response fantasy.ToolResponse\n\t\t\tvar err error\n\n\t\t\teditCtx := editContext{ctx, permissions, files, workingDir, aiops}\n\n\t\t\tif params.OldString == \"\" {\n\t\t\t\tslog.Info(\"CREATING NEW FILE\", \"file\", params.FilePath)\n\t\t\t\tresponse, err = createNewFile(editCtx, params.FilePath, params.NewString, call)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.Error(\"CREATE FILE FAILED\", \"error\", err)\n\t\t\t\t\treturn response, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif params.NewString == \"\" {\n\t\t\t\tslog.Info(\"DELETING CONTENT\", \"file\", params.FilePath)\n\t\t\t\tresponse, err = deleteContent(editCtx, params.FilePath, params.OldString, params.ReplaceAll, call)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.Error(\"DELETE FAILED\", \"error\", err)\n\t\t\t\t\treturn response, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslog.Info(\"ATTEMPTING EDIT\", \"file\", params.FilePath)\n\t\t\tresponse, err = replaceContent(editCtx, params, params.FilePath, params.OldString, params.NewString, params.ReplaceAll, call)\n\t\t\t// FAILURE ANALYSIS LOGGING\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"EDIT FAILED\",\n\t\t\t\t\t\"error\", err,\n\t\t\t\t\t\"file\", params.FilePath,\n\t\t\t\t\t\"old_preview\", params.OldString[:min(100, len(params.OldString))],\n\t\t\t\t\t\"ai_mode\", params.AIMode)\n\t\t\t}\n\n\t\t\tif response.IsError {\n\t\t\t\tslog.Error(\"EDIT RETURNED ERROR\",\n\t\t\t\t\t\"response\", response.Content,\n\t\t\t\t\t\"file\", params.FilePath,\n\t\t\t\t\t\"ai_mode\", params.AIMode,\n\t\t\t\t\t\"old_string_short\", params.OldString[:min(50, len(params.OldString))])\n\t\t\t\t// Return early if there was an error during content replacement\n\t\t\t\t// This prevents unnecessary LSP diagnostics processing\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\t\tslog.Info(\"EDIT SUCCEEDED\", \"file\", params.FilePath)\n\t\t\tnotifyLSPs(ctx, lspClients, params.FilePath)\n\n\t\t\ttext := fmt.Sprintf(\"<result>\\n%s\\n</result>\\n\", response.Content)\n\t\t\ttext += getDiagnostics(params.FilePath, lspClients)\n\t\t\tresponse.Content = text\n\t\t\treturn response, nil\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createNewFile_177": {
      "name": "createNewFile",
      "type": "function",
      "start_line": 177,
      "end_line": 257,
      "content_hash": "8eca96360ec06adc5ba08ee9ab09591d772936c6",
      "content": "func createNewFile(edit editContext, filePath, content string, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\tfileInfo, err := os.Stat(filePath)\n\tif err == nil {\n\t\tif fileInfo.IsDir() {\n\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"path is a directory, not a file: %s\", filePath)), nil\n\t\t}\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"file already exists: %s\", filePath)), nil\n\t} else if !os.IsNotExist(err) {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to access file: %w\", err)\n\t}\n\n\tdir := filepath.Dir(filePath)\n\tif err = os.MkdirAll(dir, 0o755); err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to create parent directories: %w\", err)\n\t}\n\n\tsessionID := GetSessionFromContext(edit.ctx)\n\tif sessionID == \"\" {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for creating a new file\")\n\t}\n\n\t_, additions, removals := diff.GenerateDiff(\n\t\t\"\",\n\t\tcontent,\n\t\tstrings.TrimPrefix(filePath, edit.workingDir),\n\t)\n\tp := edit.permissions.Request(\n\t\tpermission.CreatePermissionRequest{\n\t\t\tSessionID:   sessionID,\n\t\t\tPath:        fsext.PathOrPrefix(filePath, edit.workingDir),\n\t\t\tToolCallID:  call.ID,\n\t\t\tToolName:    EditToolName,\n\t\t\tAction:      \"write\",\n\t\t\tDescription: fmt.Sprintf(\"Create file %s\", filePath),\n\t\t\tParams: EditPermissionsParams{\n\t\t\t\tFilePath:   filePath,\n\t\t\t\tOldContent: \"\",\n\t\t\t\tNewContent: content,\n\t\t\t},\n\t\t},\n\t)\n\tif !p {\n\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t}\n\n\terr = os.WriteFile(filePath, []byte(content), 0o644)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\t// File can't be in the history so we create a new file history\n\t_, err = edit.files.Create(edit.ctx, sessionID, filePath, \"\")\n\tif err != nil {\n\t\t// Log error but don't fail the operation\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error creating file history: %w\", err)\n\t}\n\n\t// Add the new content to the file history\n\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, content)\n\tif err != nil {\n\t\t// Log error but don't fail the operation\n\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t}\n\n\trecordFileWrite(filePath)\n\trecordFileRead(filePath)\n\n\t// Limit response context to prevent explosion (10 lines max)\n\tlimitedContent := limitResponseContext(content)\n\n\treturn fantasy.WithResponseMetadata(\n\t\tfantasy.NewTextResponse(\"File created: \"+filePath),\n\t\tEditResponseMetadata{\n\t\t\tOldContent: \"\",\n\t\t\tNewContent: limitedContent,\n\t\t\tAdditions:  additions,\n\t\t\tRemovals:   removals,\n\t\t},\n\t), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_deleteContent_258": {
      "name": "deleteContent",
      "type": "function",
      "start_line": 258,
      "end_line": 404,
      "content_hash": "0317c3c7934c68d2edfae28ef141d150b80f50c0",
      "content": "func deleteContent(edit editContext, filePath, oldString string, replaceAll bool, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"file not found: %s\", filePath)), nil\n\t\t}\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to access file: %w\", err)\n\t}\n\n\tif fileInfo.IsDir() {\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"path is a directory, not a file: %s\", filePath)), nil\n\t}\n\n\tif getLastReadTime(filePath).IsZero() {\n\t\treturn fantasy.NewTextErrorResponse(\"you must read the file before editing it. Use the View tool first\"), nil\n\t}\n\n\tmodTime := fileInfo.ModTime()\n\tlastRead := getLastReadTime(filePath)\n\tif modTime.After(lastRead) {\n\t\treturn fantasy.NewTextErrorResponse(\n\t\t\tfmt.Sprintf(\"file %s has been modified since it was last read (mod time: %s, last read: %s)\",\n\t\t\t\tfilePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),\n\t\t\t)), nil\n\t}\n\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\toldContent, isCrlf := fsext.ToUnixLineEndings(string(content))\n\n\tvar newContent string\n\tvar deletionCount int\n\n\tif replaceAll {\n\t\tnewContent = strings.ReplaceAll(oldContent, oldString, \"\")\n\t\tdeletionCount = strings.Count(oldContent, oldString)\n\t\tif deletionCount == 0 {\n\t\t\treturn fantasy.NewTextErrorResponse(createAIErrorMessage(\n\t\t\t\tfmt.Errorf(\"old_string not found in file\"),\n\t\t\t\toldContent, oldString,\n\t\t\t)), nil\n\t\t}\n\t} else {\n\t\tindex := strings.Index(oldContent, oldString)\n\t\tif index == -1 {\n\t\t\treturn fantasy.NewTextErrorResponse(createAIErrorMessage(\n\t\t\t\tfmt.Errorf(\"old_string not found in file\"),\n\t\t\t\toldContent, oldString,\n\t\t\t)), nil\n\t\t}\n\n\t\tlastIndex := strings.LastIndex(oldContent, oldString)\n\t\tif index != lastIndex {\n\t\t\treturn fantasy.NewTextErrorResponse(\"MULTIPLE_MATCHES: The pattern appears multiple times in the file. \" +\n\t\t\t\t\"Solutions: 1) Use AI mode (ai_mode=true) for automatic context expansion, \" +\n\t\t\t\t\"2) Provide 3-5 lines of surrounding context to make it unique, \" +\n\t\t\t\t\"3) Set replace_all=true to replace all occurrences.\"), nil\n\t\t}\n\n\t\tnewContent = oldContent[:index] + oldContent[index+len(oldString):]\n\t\tdeletionCount = 1\n\t}\n\n\tsessionID := GetSessionFromContext(edit.ctx)\n\n\tif sessionID == \"\" {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for creating a new file\")\n\t}\n\n\t_, additions, removals := diff.GenerateDiff(\n\t\toldContent,\n\t\tnewContent,\n\t\tstrings.TrimPrefix(filePath, edit.workingDir),\n\t)\n\n\tp := edit.permissions.Request(\n\t\tpermission.CreatePermissionRequest{\n\t\t\tSessionID:   sessionID,\n\t\t\tPath:        fsext.PathOrPrefix(filePath, edit.workingDir),\n\t\t\tToolCallID:  call.ID,\n\t\t\tToolName:    EditToolName,\n\t\t\tAction:      \"write\",\n\t\t\tDescription: fmt.Sprintf(\"Delete content from file %s\", filePath),\n\t\t\tParams: EditPermissionsParams{\n\t\t\t\tFilePath:   filePath,\n\t\t\t\tOldContent: oldContent,\n\t\t\t\tNewContent: newContent,\n\t\t\t},\n\t\t},\n\t)\n\tif !p {\n\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t}\n\n\tif isCrlf {\n\t\tnewContent, _ = fsext.ToWindowsLineEndings(newContent)\n\t}\n\n\terr = os.WriteFile(filePath, []byte(newContent), 0o644)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\t// Check if file exists in history\n\tfile, err := edit.files.GetByPathAndSession(edit.ctx, filePath, sessionID)\n\tif err != nil {\n\t\t_, err = edit.files.Create(edit.ctx, sessionID, filePath, oldContent)\n\t\tif err != nil {\n\t\t\t// Log error but don't fail the operation\n\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error creating file history: %w\", err)\n\t\t}\n\t}\n\tif file.Content != oldContent {\n\t\t// User Manually changed the content store an intermediate version\n\t\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, oldContent)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t\t}\n\t}\n\t// Store the new version\n\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, \"\")\n\tif err != nil {\n\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t}\n\n\trecordFileWrite(filePath)\n\trecordFileRead(filePath)\n\n\t// Limit response context to prevent explosion (10 lines max)\n\tlimitedOldContent := limitResponseContext(oldContent)\n\tlimitedNewContent := limitResponseContext(newContent)\n\n\treturn fantasy.WithResponseMetadata(\n\t\tfantasy.NewTextResponse(\"Content deleted from file: \"+filePath),\n\t\tEditResponseMetadata{\n\t\t\tOldContent: limitedOldContent,\n\t\t\tNewContent: limitedNewContent,\n\t\t\tAdditions:  additions,\n\t\t\tRemovals:   removals,\n\t\t},\n\t), nil\n}\n\n// autoExpandContext automatically expands minimal context to improve match success",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_autoExpandContext_405": {
      "name": "autoExpandContext",
      "type": "function",
      "start_line": 405,
      "end_line": 435,
      "content_hash": "40624e0ae38c9fdd6d369a2b5c0b047355ccb03d",
      "content": "func autoExpandContext(filePath, partialString string) (string, error) {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read file for context expansion: %w\", err)\n\t}\n\n\tfileContent := string(content)\n\tlines := strings.Split(fileContent, \"\\n\")\n\n\t// Try to find the partial string and expand context around it\n\tfor i, line := range lines {\n\t\tif strings.Contains(line, partialString) {\n\t\t\t// Expand 2 lines before and 2 lines after for better context\n\t\t\tstart := i - 2\n\t\t\tif start < 0 {\n\t\t\t\tstart = 0\n\t\t\t}\n\t\t\tend := i + 3\n\t\t\tif end > len(lines) {\n\t\t\t\tend = len(lines)\n\t\t\t}\n\t\t\treturn strings.Join(lines[start:end], \"\\n\"), nil\n\t\t}\n\t}\n\n\t// If not found, return original (no expansion possible)\n\treturn partialString, nil\n}\n\n// limitEditContext limits the context around an edit to prevent context explosion\n// Returns only 10 lines (5 before and 5 after) the edit location",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_limitEditContext_436": {
      "name": "limitEditContext",
      "type": "function",
      "start_line": 436,
      "end_line": 480,
      "content_hash": "903534f9e4671faabf7a22ba76f50d4dd2337b79",
      "content": "func limitEditContext(fullContent, oldString string) (string, error) {\n\tlines := strings.Split(fullContent, \"\\n\")\n\n\t// Find all lines that contain the old string\n\tvar matchingLines []int\n\tfor i, line := range lines {\n\t\tif strings.Contains(line, oldString) {\n\t\t\tmatchingLines = append(matchingLines, i)\n\t\t}\n\t}\n\n\tif len(matchingLines) == 0 {\n\t\treturn \"\", fmt.Errorf(\"oldstring not found in file for context limiting\")\n\t}\n\n\t// If there are multiple matches, use the first one for context limiting\n\t// This is consistent with how single replace works\n\ttargetLine := matchingLines[0]\n\n\t// Calculate 10-line window (5 before, 5 after + the target line)\n\tstart := targetLine - 5\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\n\tend := targetLine + 6 // +6 because we want 5 lines after, not including the target line\n\tif end > len(lines) {\n\t\tend = len(lines)\n\t}\n\n\t// Extract the limited context\n\tlimitedLines := lines[start:end]\n\tlimitedContent := strings.Join(limitedLines, \"\\n\")\n\n\tslog.Info(\"Edit context limited\",\n\t\t\"original_lines\", len(lines),\n\t\t\"limited_lines\", len(limitedLines),\n\t\t\"target_line\", targetLine,\n\t\t\"start\", start,\n\t\t\"end\", end)\n\n\treturn limitedContent, nil\n}\n\n// limitResponseContext limits the content returned in responses to prevent context explosion",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_limitResponseContext_481": {
      "name": "limitResponseContext",
      "type": "function",
      "start_line": 481,
      "end_line": 504,
      "content_hash": "228a88fa27aa3643a346be24a08d8c0a74006e32",
      "content": "func limitResponseContext(content string) string {\n\tlines := strings.Split(content, \"\\n\")\n\n\t// If content is already 10 lines or less, return as-is\n\tif len(lines) <= 10 {\n\t\treturn content\n\t}\n\n\t// Take only first 10 lines\n\tlimitedLines := lines[:10]\n\tlimitedContent := strings.Join(limitedLines, \"\\n\")\n\n\t// Add indicator that content was truncated\n\tif len(lines) > 10 {\n\t\tlimitedContent += \"\\n... (content truncated to 10 lines to prevent context explosion)\"\n\t}\n\n\tslog.Info(\"Response context limited\",\n\t\t\"original_lines\", len(lines),\n\t\t\"limited_lines\", len(limitedLines))\n\n\treturn limitedContent\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_replaceContent_505": {
      "name": "replaceContent",
      "type": "function",
      "start_line": 505,
      "end_line": 808,
      "content_hash": "4cca0b13c88035422717e0f34de544ed753927d7",
      "content": "func replaceContent(edit editContext, params EditParams, filePath, oldString, newString string, replaceAll bool, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t// NORMALIZE TAB INDICATORS FROM VIEW OUTPUT\n\toldString = normalizeTabIndicators(oldString)\n\tnewString = normalizeTabIndicators(newString)\n\n\t// Try AI mode first (handles 90% of failures automatically)\n\tif params.AIMode {\n\t\tslog.Debug(\"AI mode enabled - auto-expanding context and normalizing tabs\", \"file\", params.FilePath)\n\t\tlineCount := strings.Count(oldString, \"\\n\")\n\t\tif lineCount < 3 { // Less than 3 lines = definitely needs expansion\n\t\t\texpanded, err := autoExpandContext(filePath, oldString)\n\t\t\tif err == nil && expanded != oldString {\n\t\t\t\toldString = expanded\n\t\t\t\tslog.Info(\"AI mode: auto-expanded context\",\n\t\t\t\t\t\"file\", filePath,\n\t\t\t\t\t\"original_lines\", lineCount,\n\t\t\t\t\t\"expanded_lines\", strings.Count(expanded, \"\\n\"))\n\t\t\t}\n\t\t}\n\t}\n\n\tattemptCount := 0\n\t// Auto-view file before every edit to ensure we have latest context\n\tif err := autoViewFileBeforeEdit(edit.ctx, filePath); err != nil {\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"failed to view file before edit: %v\", err)), nil\n\t}\n\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"file not found: %s\", filePath)), nil\n\t\t}\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to access file: %w\", err)\n\t}\n\n\tif fileInfo.IsDir() {\n\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"path is a directory, not a file: %s\", filePath)), nil\n\t}\n\n\tif getLastReadTime(filePath).IsZero() {\n\t\treturn fantasy.NewTextErrorResponse(\"you must read the file before editing it. Use the View tool first\"), nil\n\t}\n\n\tmodTime := fileInfo.ModTime()\n\tlastRead := getLastReadTime(filePath)\n\tif modTime.After(lastRead) {\n\t\treturn fantasy.NewTextErrorResponse(\n\t\t\tfmt.Sprintf(\"file %s has been modified since it was last read (mod time: %s, last read: %s)\",\n\t\t\t\tfilePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),\n\t\t\t)), nil\n\t}\n\n\t// Validate old_string exists before proceeding with edit\n\tif err := ValidateEditString(filePath, oldString, replaceAll); err != nil {\n\t\treturn fantasy.NewTextErrorResponse(err.Error()), nil\n\t}\n\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\toldContent, isCrlf := fsext.ToUnixLineEndings(string(content))\n\n\tvar newContent string\n\tvar replacementCount int\n\n\tif replaceAll {\n\t\tnewContent = strings.ReplaceAll(oldContent, oldString, newString)\n\t\treplacementCount = strings.Count(oldContent, oldString)\n\t\tif replacementCount == 0 {\n\t\t\tif replacementCount == 0 {\n\t\t\t\t// Try whitespace normalization (handles tabs vs spaces from View output)\n\t\t\t\tif normalized, found := tryNormalizedMatch(oldContent, oldString); found {\n\t\t\t\t\toldString = normalized\n\t\t\t\t\tnewContent = strings.ReplaceAll(oldContent, oldString, newString)\n\t\t\t\t\treplacementCount = strings.Count(oldContent, oldString)\n\t\t\t\t\tif replacementCount > 0 {\n\t\t\t\t\t\t// Successfully resolved with whitespace normalization\n\t\t\t\t\t\tgoto foundReplaceAll\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Try fuzzy matching with confidence scoring (skip for very large files)\n\t\t\tif len(oldContent) <= 50000 { // 50KB threshold to avoid O(n\u00b2) performance issues\n\t\t\t\tif match := findBestMatch(oldContent, oldString); match != nil && match.confidence >= 0.90 {\n\t\t\t\t\tslog.Info(\"fuzzy match found (replaceAll)\",\n\t\t\t\t\t\t\"strategy\", match.matchStrategy,\n\t\t\t\t\t\t\"confidence\", match.confidence,\n\t\t\t\t\t\t\"file\", filePath)\n\t\t\t\t\tif match.exactMatch != \"\" {\n\t\t\t\t\t\toldString = match.exactMatch\n\t\t\t\t\t\tnewContent = strings.ReplaceAll(oldContent, oldString, newString)\n\t\t\t\t\t\treplacementCount = strings.Count(oldContent, oldString)\n\t\t\t\t\t\tif replacementCount > 0 {\n\t\t\t\t\t\t\t// Successfully resolved with fuzzy matching\n\t\t\t\t\t\t\tgoto foundReplaceAll\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try AIOPS edit resolution first if available\n\t\t\tif edit.aiops != nil {\n\t\t\t\tresolution, err := edit.aiops.ResolveEdit(edit.ctx, oldContent, oldString, newString)\n\t\t\t\tif err == nil && resolution.Confidence > 0.8 {\n\t\t\t\t\toldString = resolution.ExactOldString\n\t\t\t\t\tnewContent = strings.ReplaceAll(oldContent, oldString, newString)\n\t\t\t\t\treplacementCount = strings.Count(oldContent, oldString)\n\t\t\t\t\tif replacementCount > 0 {\n\t\t\t\t\t\t// Successfully resolved with AIOPS\n\t\t\t\t\t\tgoto foundReplaceAll\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Attempt self-healing retry with better context\n\t\t\tattemptCount++\n\t\t\tretryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)\n\t\t\tif err != nil {\n\t\t\t\tLogEditFailure(EditDiagnosticsInfo{\n\t\t\t\t\tFilePath:      filePath,\n\t\t\t\t\tOldString:     oldString,\n\t\t\t\t\tNewString:     newString,\n\t\t\t\t\tFileContent:   oldContent,\n\t\t\t\t\tFileSizeBytes: len(oldContent),\n\t\t\t\t\tLineCount:     strings.Count(oldContent, \"\\n\") + 1,\n\t\t\t\t\tFailureReason: \"old_string not found (replaceAll)\",\n\t\t\t\t\tContext:       PatternMatchAnalysis(oldContent, oldString),\n\t\t\t\t})\n\t\t\t\treturn fantasy.NewTextErrorResponse(createAIErrorMessage(\n\t\t\t\t\tfmt.Errorf(\"old_string not found in file\"),\n\t\t\t\t\toldContent, oldString,\n\t\t\t\t)), nil\n\t\t\t}\n\t\t\t// Use the improved parameters from retry\n\t\t\toldString = retryParams.OldString\n\t\t\tnewContent = strings.ReplaceAll(oldContent, oldString, newString)\n\t\t\treplacementCount = strings.Count(oldContent, oldString)\n\t\t\tif replacementCount == 0 {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"old_string not found in file. Make sure it matches exactly, including whitespace and line breaks\"), nil\n\t\t\t}\n\t\t}\n\tfoundReplaceAll:\n\t} else {\n\t\tindex := strings.Index(oldContent, oldString)\n\t\tif index == -1 {\n\t\t\t// Try fuzzy matching with confidence scoring (skip for very large files)\n\t\t\tif len(oldContent) <= 50000 { // 50KB threshold to avoid O(n\u00b2) performance issues\n\t\t\t\tif match := findBestMatch(oldContent, oldString); match != nil && match.confidence >= 0.90 {\n\t\t\t\t\tslog.Info(\"fuzzy match found\",\n\t\t\t\t\t\t\"strategy\", match.matchStrategy,\n\t\t\t\t\t\t\"confidence\", match.confidence,\n\t\t\t\t\t\t\"file\", filePath)\n\t\t\t\t\toldString = match.exactMatch\n\t\t\t\t\tindex = match.byteOffset\n\t\t\t\t\tif index != -1 && match.exactMatch != \"\" {\n\t\t\t\t\t\t// Successfully resolved with fuzzy matching\n\t\t\t\t\t\tgoto found\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try AIOPS edit resolution first if available\n\t\t\tif edit.aiops != nil {\n\t\t\t\tresolution, err := edit.aiops.ResolveEdit(edit.ctx, oldContent, oldString, newString)\n\t\t\t\tif err == nil && resolution.Confidence > 0.8 {\n\t\t\t\t\toldString = resolution.ExactOldString\n\t\t\t\t\tindex = strings.Index(oldContent, oldString)\n\t\t\t\t\tif index != -1 {\n\t\t\t\t\t\t// Successfully resolved with AIOPS\n\t\t\t\t\t\tgoto found\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Attempt self-healing retry with better context\n\t\t\tattemptCount++\n\t\t\tretryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)\n\t\t\tif err != nil {\n\t\t\t\tLogEditFailure(EditDiagnosticsInfo{\n\t\t\t\t\tFilePath:      filePath,\n\t\t\t\t\tOldString:     oldString,\n\t\t\t\t\tNewString:     newString,\n\t\t\t\t\tFileContent:   oldContent,\n\t\t\t\t\tFileSizeBytes: len(oldContent),\n\t\t\t\t\tLineCount:     strings.Count(oldContent, \"\\n\") + 1,\n\t\t\t\t\tFailureReason: \"old_string not found (replaceAll)\",\n\t\t\t\t\tContext:       PatternMatchAnalysis(oldContent, oldString),\n\t\t\t\t})\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"old_string not found in file. Make sure it matches exactly, including whitespace and line breaks\"), nil\n\t\t\t}\n\t\t\t// Use the improved parameters from retry\n\t\t\toldString = retryParams.OldString\n\t\t\tindex = strings.Index(oldContent, oldString)\n\t\t\tif index == -1 {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"old_string not found in file. Make sure it matches exactly, including whitespace and line breaks\"), nil\n\t\t\t}\n\t\t}\n\tfound:\n\n\t\tlastIndex := strings.LastIndex(oldContent, oldString)\n\t\tif index != lastIndex {\n\t\t\t// Attempt self-healing retry with better context\n\t\t\tattemptCount++\n\t\t\tretryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"old_string appears multiple times in the file. Please provide more context to ensure a unique match, or set replace_all to true\"), nil\n\t\t\t}\n\t\t\t// Use the improved parameters from retry\n\t\t\toldString = retryParams.OldString\n\t\t\tindex = strings.Index(oldContent, oldString)\n\t\t\tlastIndex = strings.LastIndex(oldContent, oldString)\n\t\t\tif index != lastIndex {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"old_string appears multiple times in the file. Please provide more context to ensure a unique match, or set replace_all to true\"), nil\n\t\t\t}\n\t\t}\n\n\t\tnewContent = oldContent[:index] + newString + oldContent[index+len(oldString):]\n\t\treplacementCount = 1\n\t}\n\n\tif oldContent == newContent {\n\t\treturn fantasy.NewTextErrorResponse(\"new content is the same as old content. No changes made.\"), nil\n\t}\n\tsessionID := GetSessionFromContext(edit.ctx)\n\n\tif sessionID == \"\" {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"session ID is required for creating a new file\")\n\t}\n\t_, additions, removals := diff.GenerateDiff(\n\t\toldContent,\n\t\tnewContent,\n\t\tstrings.TrimPrefix(filePath, edit.workingDir),\n\t)\n\n\tp := edit.permissions.Request(\n\t\tpermission.CreatePermissionRequest{\n\t\t\tSessionID:   sessionID,\n\t\t\tPath:        fsext.PathOrPrefix(filePath, edit.workingDir),\n\t\t\tToolCallID:  call.ID,\n\t\t\tToolName:    EditToolName,\n\t\t\tAction:      \"write\",\n\t\t\tDescription: fmt.Sprintf(\"Replace content in file %s\", filePath),\n\t\t\tParams: EditPermissionsParams{\n\t\t\t\tFilePath:   filePath,\n\t\t\t\tOldContent: oldContent,\n\t\t\t\tNewContent: newContent,\n\t\t\t},\n\t\t},\n\t)\n\tif !p {\n\t\treturn fantasy.ToolResponse{}, permission.ErrorPermissionDenied\n\t}\n\n\tif isCrlf {\n\t\tnewContent, _ = fsext.ToWindowsLineEndings(newContent)\n\t}\n\n\terr = os.WriteFile(filePath, []byte(newContent), 0o644)\n\tif err != nil {\n\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\t// Check if file exists in history\n\tfile, err := edit.files.GetByPathAndSession(edit.ctx, filePath, sessionID)\n\tif err != nil {\n\t\t_, err = edit.files.Create(edit.ctx, sessionID, filePath, oldContent)\n\t\tif err != nil {\n\t\t\t// Log error but don't fail the operation\n\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error creating file history: %w\", err)\n\t\t}\n\t}\n\tif file.Content != oldContent {\n\t\t// User Manually changed the content store an intermediate version\n\t\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, oldContent)\n\t\tif err != nil {\n\t\t\tslog.Debug(\"Error creating file history version\", \"error\", err)\n\t\t}\n\t}\n\t// Store the new version\n\t_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, newContent)\n\tif err != nil {\n\t\tslog.Error(\"Error creating file history version\", \"error\", err)\n\t}\n\n\trecordFileWrite(filePath)\n\trecordFileRead(filePath)\n\tLogEditSuccess(filePath, len(oldString), len(newString), replacementCount, attemptCount)\n\n\t// Limit response context to prevent explosion (10 lines max)\n\tlimitedOldContent := limitResponseContext(oldContent)\n\tlimitedNewContent := limitResponseContext(newContent)\n\n\treturn fantasy.WithResponseMetadata(\n\t\tfantasy.NewTextResponse(\"Content replaced in file: \"+filePath),\n\t\tEditResponseMetadata{\n\t\t\tOldContent: limitedOldContent,\n\t\t\tNewContent: limitedNewContent,\n\t\t\tAdditions:  additions,\n\t\t\tRemovals:   removals,\n\t\t}), nil\n}\n\n// attemptSelfHealingRetry uses the self-healing strategy to improve the old_string\n// by extracting better context from the file when the initial match fails",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_attemptSelfHealingRetry_809": {
      "name": "attemptSelfHealingRetry",
      "type": "function",
      "start_line": 809,
      "end_line": 818,
      "content_hash": "4dc727e1e973519a663c2e3e2b123e459857b5b4",
      "content": "func attemptSelfHealingRetry(ctx context.Context, filePath string, oldString string, newString string) (EditParams, error) {\n\tstrategy := NewEditRetryStrategy(ctx)\n\tretryParams, err := strategy.RetryWithContext(filePath, oldString, newString, \"old_string not found\")\n\tif err != nil {\n\t\treturn EditParams{}, err\n\t}\n\treturn retryParams, nil\n}\n\n// autoViewFileBeforeEdit automatically views a file before editing to ensure we have the latest context",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_autoViewFileBeforeEdit_819": {
      "name": "autoViewFileBeforeEdit",
      "type": "function",
      "start_line": 819,
      "end_line": 835,
      "content_hash": "dcc26e558b718cddba464773f91b64f3a40b8385",
      "content": "func autoViewFileBeforeEdit(ctx context.Context, filePath string) error {\n\t_, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read file for auto-view: %w\", err)\n\t}\n\n\t// Update the last read time to reflect this automatic view\n\trecordFileRead(filePath)\n\n\t// Log that we performed an auto-view\n\tslog.Debug(\"Auto-viewed file before edit\", \"file\", filePath)\n\n\treturn nil\n}\n\n// normalizeWhitespace converts mixed whitespace to consistent tabs for matching\n// This helps match text copied from View output (which may have spaces from display padding)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}