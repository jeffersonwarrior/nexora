{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/commands/integrations/ecr.rs",
  "file_hash": "fc2aa8ed9b29ab15ec95673e95da51236265067e",
  "updated_at": "2025-12-26T17:34:23.151220",
  "symbols": {
    "struct_EcrManager_15": {
      "name": "EcrManager",
      "type": "struct",
      "start_line": 15,
      "end_line": 22,
      "content_hash": "eead861beaf3e3d0da433108fb31fc89f0cae009",
      "content": "pub struct EcrManager<'a> {\n    project: &'a ProjectContext,\n    #[allow(dead_code)]\n    auth: EcrAuth,\n}\n\n/// AWS ECR authentication method\n#[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_EcrAuth_23": {
      "name": "EcrAuth",
      "type": "enum",
      "start_line": 23,
      "end_line": 29,
      "content_hash": "070a92112cb9238fca6526fd54fe8cc72c5304d7",
      "content": "enum EcrAuth {\n    AwsCli,\n    // Future: Could add IAM role, API key, etc.\n}\n\n/// Authentication type selection\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_EcrAuthType_30": {
      "name": "EcrAuthType",
      "type": "enum",
      "start_line": 30,
      "end_line": 34,
      "content_hash": "f5ca5181dfd7afef8a5534e1adf6ab5e619f724a",
      "content": "pub enum EcrAuthType {\n    #[default]\n    AwsCli,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_TryFrom_35": {
      "name": "TryFrom",
      "type": "impl",
      "start_line": 35,
      "end_line": 37,
      "content_hash": "ef784cb7116ea0145377e5ccc4eedc19f2fb161c",
      "content": "impl TryFrom<String> for EcrAuthType {\n    type Error = eyre::Report;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_try_from_38": {
      "name": "try_from",
      "type": "method",
      "start_line": 38,
      "end_line": 50,
      "content_hash": "572919bca37922eb8e2ff4369f3eb2f01b5e22a8",
      "content": "    fn try_from(value: String) -> Result<Self, Self::Error> {\n        match value.as_str() {\n            \"aws_cli\" | \"cli\" => Ok(Self::AwsCli),\n            _ => Err(eyre!(\n                \"Invalid auth type '{}'. Valid options: aws_cli\",\n                value\n            )),\n        }\n    }\n}\n\n/// Configuration for an ECR repository\n#[derive(Debug, Serialize, Deserialize, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EcrConfig_51": {
      "name": "EcrConfig",
      "type": "struct",
      "start_line": 51,
      "end_line": 61,
      "content_hash": "79943ec2ae0b9119225e1f1b280890ebdc71e4f3",
      "content": "pub struct EcrConfig {\n    pub repository_name: String,\n    pub region: String,\n    pub registry_url: Option<String>,\n    pub auth_type: EcrAuthType,\n    #[serde(default = \"default_release_build_mode\")]\n    pub build_mode: BuildMode,\n    #[serde(flatten)]\n    pub db_config: config::DbConfig,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Default_62": {
      "name": "Default",
      "type": "impl",
      "start_line": 62,
      "end_line": 62,
      "content_hash": "9ef17781cda7ec3048aad9617ede218ca285a202",
      "content": "impl Default for EcrConfig {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_default_63": {
      "name": "default",
      "type": "method",
      "start_line": 63,
      "end_line": 74,
      "content_hash": "d2ccc492f3d92034684b60eb7aee24e98425a763",
      "content": "    fn default() -> Self {\n        Self {\n            repository_name: String::new(),\n            region: DEFAULT_ECR_REGION.to_string(),\n            registry_url: None,\n            auth_type: EcrAuthType::default(),\n            build_mode: default_release_build_mode(),\n            db_config: config::DbConfig::default(),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_EcrManager_75": {
      "name": "EcrManager",
      "type": "impl",
      "start_line": 75,
      "end_line": 90,
      "content_hash": "084d3819337075648f3a43faa1ff677ddf1d9fa7",
      "content": "impl<'a> EcrManager<'a> {\n    /// Create a new EcrManager\n    pub async fn new(project: &'a ProjectContext, auth_type: EcrAuthType) -> Result<Self> {\n        let auth = match auth_type {\n            EcrAuthType::AwsCli => {\n                Self::check_aws_cli_auth().await?;\n                EcrAuth::AwsCli\n            }\n        };\n\n        Ok(Self { project, auth })\n    }\n\n    // === CENTRALIZED NAMING METHODS ===\n\n    /// Get the ECR repository name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_repository_name_91": {
      "name": "repository_name",
      "type": "method",
      "start_line": 91,
      "end_line": 94,
      "content_hash": "eb0d442cd761bd8fde24c7e074aff4fe334ba374",
      "content": "    fn repository_name(&self, instance_name: &str) -> String {\n        format!(\"helix-{}-{instance_name}\", self.project.config.project.name)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_image_name_95": {
      "name": "image_name",
      "type": "method",
      "start_line": 95,
      "end_line": 107,
      "content_hash": "bc82011109ff06c5fe0fced70e39bd432b8a5d7b",
      "content": "    fn image_name(&self, repository_name: &str, build_mode: BuildMode) -> String {\n        let tag = match build_mode {\n            BuildMode::Debug => \"debug\",\n            BuildMode::Release => \"latest\",\n            BuildMode::Dev => \"dev\",\n        };\n        format!(\"{repository_name}:{tag}\")\n    }\n\n    // === CENTRALIZED COMMAND EXECUTION ===\n\n    /// Run an AWS CLI command with consistent error handling\n    #[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_aws_command_108": {
      "name": "run_aws_command",
      "type": "method",
      "start_line": 108,
      "end_line": 473,
      "content_hash": "7eab052799276fff65e6eb272a4483396fc51c70",
      "content": "    fn run_aws_command(&self, args: &[&str]) -> Result<Output> {\n        let output = Command::new(\"aws\")\n            .args(args)\n            .output()\n            .map_err(|e| eyre!(\"Failed to run aws {}: {e}\", args.join(\" \")))?;\n        Ok(output)\n    }\n\n    /// Run an AWS CLI command asynchronously with consistent error handling\n    async fn run_aws_command_async(&self, args: &[&str]) -> Result<Output> {\n        let status = tokio::process::Command::new(\"aws\")\n            .args(args)\n            .output()\n            .await\n            .map_err(|e| eyre!(\"Failed to run aws {}: {e}\", args.join(\" \")))?;\n        Ok(status)\n    }\n\n    // === STATIC UTILITY METHODS ===\n\n    /// Check if AWS CLI is installed and authenticated\n    pub async fn check_aws_cli_available() -> Result<()> {\n        let output = Command::new(\"aws\")\n            .args([\"--version\"])\n            .output()\n            .map_err(|_| eyre!(\"AWS CLI is not installed or not available in PATH. Visit https://aws.amazon.com/cli/\"))?;\n\n        if !output.status.success() {\n            return Err(eyre!(\"AWS CLI is installed but not working properly\"));\n        }\n\n        Ok(())\n    }\n\n    /// Check if AWS CLI is authenticated\n    async fn check_aws_cli_auth() -> Result<()> {\n        Self::check_aws_cli_available().await?;\n\n        print_status(\"ECR\", \"Checking AWS CLI authentication\");\n        let output = tokio::process::Command::new(\"aws\")\n            .args([\"sts\", \"get-caller-identity\"])\n            .output()\n            .await\n            .map_err(|e| eyre!(\"Failed to check AWS authentication: {e}\"))?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\n                \"AWS CLI authentication failed. Configure your credentials with 'aws configure' first.\\nError: {}\",\n                stderr\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Get the AWS account ID\n    async fn get_account_id(&self) -> Result<String> {\n        let output = self\n            .run_aws_command_async(&[\n                \"sts\",\n                \"get-caller-identity\",\n                \"--query\",\n                \"Account\",\n                \"--output\",\n                \"text\",\n            ])\n            .await?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to get AWS account ID: {stderr}\"));\n        }\n\n        let account_id = String::from_utf8_lossy(&output.stdout).trim().to_string();\n        Ok(account_id)\n    }\n\n    /// Get the ECR registry URL for the current account and region\n    async fn get_registry_url(&self, region: &str) -> Result<String> {\n        let account_id = self.get_account_id().await?;\n        Ok(format!(\"{account_id}.dkr.ecr.{region}.amazonaws.com\"))\n    }\n\n    // === CONFIGURATION MANAGEMENT ===\n\n    /// Create an ECR configuration\n    pub async fn create_ecr_config(\n        &self,\n        _instance_name: &str,\n        region: Option<String>,\n        auth_type: EcrAuthType,\n    ) -> Result<EcrConfig> {\n        let repository_name = self.repository_name(_instance_name);\n        let region = region.unwrap_or_else(|| DEFAULT_ECR_REGION.to_string());\n        let registry_url = Some(self.get_registry_url(&region).await?);\n\n        Ok(EcrConfig {\n            repository_name,\n            region,\n            registry_url,\n            auth_type,\n            build_mode: BuildMode::default(),\n            db_config: config::DbConfig::default(),\n        })\n    }\n\n    /// Save ECR configuration to file\n    pub async fn save_config(&self, instance_name: &str, config: &EcrConfig) -> Result<()> {\n        let config_path = self\n            .project\n            .instance_workspace(instance_name)\n            .join(\"ecr.toml\");\n\n        // Ensure the directory exists\n        if let Some(parent) = config_path.parent() {\n            fs::create_dir_all(parent).await?;\n        }\n\n        let toml_content = toml::to_string_pretty(config)?;\n        fs::write(&config_path, toml_content).await?;\n\n        println!(\"[ECR] Configuration saved to {}\", config_path.display());\n        Ok(())\n    }\n\n    /// Load ECR configuration from file\n    pub async fn load_config(&self, instance_name: &str) -> Result<EcrConfig> {\n        let config_path = self\n            .project\n            .instance_workspace(instance_name)\n            .join(\"ecr.toml\");\n\n        if !config_path.exists() {\n            return Err(eyre!(\n                \"ECR configuration not found at {}. Run 'helix init ecr' first.\",\n                config_path.display()\n            ));\n        }\n\n        let toml_content = fs::read_to_string(&config_path).await?;\n        let config: EcrConfig = toml::from_str(&toml_content)?;\n\n        Ok(config)\n    }\n\n    // === REPOSITORY OPERATIONS ===\n\n    /// Initialize a new ECR repository\n    pub async fn init_repository(&self, _instance_name: &str, config: &EcrConfig) -> Result<()> {\n        let repository_name = &config.repository_name;\n        let region = &config.region;\n\n        print_status(\n            \"ECR\",\n            &format!(\"Creating ECR repository '{repository_name}'\"),\n        );\n\n        // Check if repository already exists\n        let check_output = self\n            .run_aws_command_async(&[\n                \"ecr\",\n                \"describe-repositories\",\n                \"--repository-names\",\n                repository_name,\n                \"--region\",\n                region,\n            ])\n            .await?;\n\n        if check_output.status.success() {\n            println!(\"[ECR] Repository '{repository_name}' already exists\");\n            return Ok(());\n        }\n\n        // Create the repository\n        let create_output = self\n            .run_aws_command_async(&[\n                \"ecr\",\n                \"create-repository\",\n                \"--repository-name\",\n                repository_name,\n                \"--region\",\n                region,\n                \"--image-scanning-configuration\",\n                \"scanOnPush=true\",\n            ])\n            .await?;\n\n        if !create_output.status.success() {\n            let stderr = String::from_utf8_lossy(&create_output.stderr);\n            return Err(eyre!(\n                \"Failed to create ECR repository '{repository_name}': {stderr}\"\n            ));\n        }\n\n        println!(\"[ECR] Repository '{repository_name}' created successfully\");\n        Ok(())\n    }\n\n    /// Deploy an image to ECR\n    pub async fn deploy_image(\n        &self,\n        docker: &DockerManager<'_>,\n        config: &EcrConfig,\n        _instance_name: &str,\n        image_name: &str,\n    ) -> Result<()> {\n        let tag = \"latest\";\n        let registry_url = config\n            .registry_url\n            .as_ref()\n            .ok_or_else(|| eyre!(\"Registry URL not found in configuration\"))?;\n        let repository_name = &config.repository_name;\n        let region = &config.region;\n\n        print_status(\"ECR\", &format!(\"Deploying '{image_name}' to ECR\"));\n        println!(\"\\tRepository: {repository_name}\");\n        println!(\"\\tRegion: {region}\");\n        println!(\"\\tTag: {tag}\");\n\n        // Authenticate Docker with ECR\n        print_status(\"ECR\", \"Authenticating Docker with ECR\");\n        let auth_output = self\n            .run_aws_command_async(&[\"ecr\", \"get-login-password\", \"--region\", region])\n            .await?;\n\n        if !auth_output.status.success() {\n            let stderr = String::from_utf8_lossy(&auth_output.stderr);\n            return Err(eyre!(\"Failed to get ECR login password: {stderr}\"));\n        }\n\n        let password = String::from_utf8_lossy(&auth_output.stdout)\n            .trim()\n            .to_string();\n\n        use tokio::io::AsyncWriteExt;\n        let mut login_cmd = tokio::process::Command::new(docker.runtime.binary());\n        login_cmd.args([\n            \"login\",\n            \"--username\",\n            \"AWS\",\n            \"--password-stdin\",\n            registry_url,\n        ]);\n        login_cmd.stdin(std::process::Stdio::piped());\n        let mut child = login_cmd.spawn()?;\n        if let Some(mut stdin) = child.stdin.take() {\n            stdin.write_all(password.as_bytes()).await?;\n        }\n        let output = child.wait_with_output().await?;\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to login to ECR: {}\", stderr));\n        }\n        // Tag image for ECR\n        print_status(\"ECR\", \"Tagging image for ECR\");\n        let image_name = self.image_name(repository_name, config.build_mode);\n        docker.tag(&image_name, registry_url)?;\n\n        // Push image to ECR\n        print_status(\"ECR\", &format!(\"Pushing image '{image_name}' to ECR\"));\n        docker.push(&image_name, registry_url)?;\n\n        println!(\"[ECR] Image '{image_name}' deployed successfully to {registry_url}\");\n        Ok(())\n    }\n\n    /// Delete an ECR repository\n    pub async fn delete_repository(&self, instance_name: &str) -> Result<()> {\n        let config = self.load_config(instance_name).await?;\n        let repository_name = &config.repository_name;\n        let region = &config.region;\n\n        print_status(\n            \"ECR\",\n            &format!(\"Deleting ECR repository '{repository_name}'\"),\n        );\n\n        let delete_output = self\n            .run_aws_command_async(&[\n                \"ecr\",\n                \"delete-repository\",\n                \"--repository-name\",\n                repository_name,\n                \"--region\",\n                region,\n                \"--force\", // Force delete even if repository contains images\n            ])\n            .await?;\n\n        if !delete_output.status.success() {\n            let stderr = String::from_utf8_lossy(&delete_output.stderr);\n            // Check if repository doesn't exist\n            if stderr.contains(\"RepositoryNotFoundException\") {\n                println!(\"[ECR] Repository '{repository_name}' does not exist\");\n                return Ok(());\n            }\n            return Err(eyre!(\n                \"Failed to delete ECR repository '{repository_name}': {stderr}\"\n            ));\n        }\n\n        println!(\"[ECR] Repository '{repository_name}' deleted successfully\");\n        Ok(())\n    }\n\n    /// Get the status of ECR repositories for this project\n    #[allow(dead_code)]\n    pub async fn get_project_status(&self) -> Result<Vec<EcrRepositoryStatus>> {\n        let _account_id = self.get_account_id().await?;\n        let project_prefix = format!(\"helix-{}-\", self.project.config.project.name);\n\n        // List all repositories\n        let output = self\n            .run_aws_command_async(&[\n                \"ecr\",\n                \"describe-repositories\",\n                \"--query\",\n                &format!(\"repositories[?starts_with(repositoryName, '{project_prefix}')]\"),\n                \"--output\",\n                \"json\",\n            ])\n            .await?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to list ECR repositories: {stderr}\"));\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let repositories: serde_json::Value = serde_json::from_str(&stdout)\n            .map_err(|e| eyre!(\"Failed to parse ECR repositories JSON: {e}\"))?;\n\n        let mut statuses = Vec::new();\n\n        if let Some(repos_array) = repositories.as_array() {\n            for repo in repos_array {\n                if let Some(name) = repo.get(\"repositoryName\").and_then(|n| n.as_str())\n                    && let Some(instance_name) = name.strip_prefix(&project_prefix)\n                {\n                    let uri = repo\n                        .get(\"repositoryUri\")\n                        .and_then(|u| u.as_str())\n                        .unwrap_or(\"unknown\");\n                    let created_at = repo\n                        .get(\"createdAt\")\n                        .and_then(|c| c.as_str())\n                        .unwrap_or(\"unknown\");\n\n                    statuses.push(EcrRepositoryStatus {\n                        instance_name: instance_name.to_string(),\n                        repository_name: name.to_string(),\n                        repository_uri: uri.to_string(),\n                        created_at: created_at.to_string(),\n                    });\n                }\n            }\n        }\n\n        Ok(statuses)\n    }\n}\n\n#[derive(Debug)]\n#[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EcrRepositoryStatus_474": {
      "name": "EcrRepositoryStatus",
      "type": "struct",
      "start_line": 474,
      "end_line": 479,
      "content_hash": "294a2da00a9bf977f00e3eb325238f7fdd97e81d",
      "content": "pub struct EcrRepositoryStatus {\n    pub instance_name: String,\n    pub repository_name: String,\n    pub repository_uri: String,\n    pub created_at: String,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}