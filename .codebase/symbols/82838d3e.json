{
  "file_path": "/work/external-deps/Context-Engine/tests/test_globs_and_snippet.py",
  "file_hash": "9e8836ce300a83bad793dc4702e398337bdaad09",
  "updated_at": "2025-12-26T17:34:22.704682",
  "symbols": {
    "class__Pt_14": {
      "name": "_Pt",
      "type": "class",
      "start_line": 14,
      "end_line": 24,
      "content_hash": "b55001309fa4b8b3600b72a0588644a32298e4f5",
      "content": "class _Pt:\n    def __init__(self, pid, path):\n        self.id = pid\n        # minimal payload structure used by hybrid filters\n        self.payload = {\n            \"metadata\": {\n                \"path\": path,\n                \"start_line\": 1,\n                \"end_line\": 2,\n            }\n        }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___15": {
      "name": "__init__",
      "type": "method",
      "start_line": 15,
      "end_line": 24,
      "content_hash": "6897c804b842457ffcb34a00ded4a4411c8133c1",
      "content": "    def __init__(self, pid, path):\n        self.id = pid\n        # minimal payload structure used by hybrid filters\n        self.payload = {\n            \"metadata\": {\n                \"path\": path,\n                \"start_line\": 1,\n                \"end_line\": 2,\n            }\n        }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class__QP_27": {
      "name": "_QP",
      "type": "class",
      "start_line": 27,
      "end_line": 29,
      "content_hash": "ef9c614735ab57921cb3f41389956e6ef74be590",
      "content": "class _QP:\n    def __init__(self, points):\n        self.points = points",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___28": {
      "name": "__init__",
      "type": "method",
      "start_line": 28,
      "end_line": 29,
      "content_hash": "9a6a49b3de50e1344e6f2281b0f97d71aa6b85c2",
      "content": "    def __init__(self, points):\n        self.points = points",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_FakeQdrant_32": {
      "name": "FakeQdrant",
      "type": "class",
      "start_line": 32,
      "end_line": 41,
      "content_hash": "355c7db66ddcfd971e92ba0119258444dae8f0e4",
      "content": "class FakeQdrant:\n    def __init__(self, points):\n        self._points = points\n\n    # dense_query tries query_points first, then search on exception\n    def query_points(self, **kwargs):\n        return _QP(self._points)\n\n    def search(self, **kwargs):\n        return self._points",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___33": {
      "name": "__init__",
      "type": "method",
      "start_line": 33,
      "end_line": 34,
      "content_hash": "4d437af401b79f04defdd313c88ac7aa989e27a4",
      "content": "    def __init__(self, points):\n        self._points = points",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_query_points_37": {
      "name": "query_points",
      "type": "method",
      "start_line": 37,
      "end_line": 38,
      "content_hash": "ba34ef8978b4b1dd4aa10519300c218f1388d004",
      "content": "    def query_points(self, **kwargs):\n        return _QP(self._points)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_search_40": {
      "name": "search",
      "type": "method",
      "start_line": 40,
      "end_line": 41,
      "content_hash": "659a49ce52fa60b955fce5cc1f6cd65e2291b98f",
      "content": "    def search(self, **kwargs):\n        return self._points",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_FakeEmbed_44": {
      "name": "FakeEmbed",
      "type": "class",
      "start_line": 44,
      "end_line": 54,
      "content_hash": "b7354972d58dbf1b39a0eebbb6593989d3e4a681",
      "content": "class FakeEmbed:\n    class _Vec:\n        def __init__(self):\n            self._v = [0.01] * 8\n\n        def tolist(self):\n            return self._v\n\n    def embed(self, texts):\n        for _ in texts:\n            yield FakeEmbed._Vec()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class__Vec_45": {
      "name": "_Vec",
      "type": "class",
      "start_line": 45,
      "end_line": 50,
      "content_hash": "ce2dafce23b826e82390bfd9170570b8d381ea17",
      "content": "    class _Vec:\n        def __init__(self):\n            self._v = [0.01] * 8\n\n        def tolist(self):\n            return self._v",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___46": {
      "name": "__init__",
      "type": "method",
      "start_line": 46,
      "end_line": 47,
      "content_hash": "35dc3f72ee5fe4f5ad89c920fa78164821c9d1a3",
      "content": "        def __init__(self):\n            self._v = [0.01] * 8",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tolist_49": {
      "name": "tolist",
      "type": "method",
      "start_line": 49,
      "end_line": 50,
      "content_hash": "47bd73574e3227f54d772588ec5fe7dfd361c9db",
      "content": "        def tolist(self):\n            return self._v",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_embed_52": {
      "name": "embed",
      "type": "method",
      "start_line": 52,
      "end_line": 54,
      "content_hash": "53d4723d641b6074a042651460d52e04a50bbb53",
      "content": "    def embed(self, texts):\n        for _ in texts:\n            yield FakeEmbed._Vec()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_run_hybrid_search_list_globs_58": {
      "name": "test_run_hybrid_search_list_globs",
      "type": "function",
      "start_line": 58,
      "end_line": 87,
      "content_hash": "ee0076fc1cde0ed851f8642d7aab0bcabf59db33",
      "content": "def test_run_hybrid_search_list_globs(monkeypatch):\n    # Prepare fake points across different folders to exercise path_glob/not_glob\n    pts = [\n        _Pt(\"1\", \"src/a.py\"),\n        _Pt(\"2\", \"tests/b_test.py\"),\n        _Pt(\"3\", \"docs/readme.md\"),\n    ]\n    # Patch the symbol used inside hybrid_search\n    monkeypatch.setattr(hyb, \"QdrantClient\", lambda *a, **k: FakeQdrant(pts))\n    monkeypatch.setenv(\"EMBEDDING_MODEL\", \"unit-test\")\n    monkeypatch.setenv(\"QDRANT_URL\", \"http://localhost:6333\")\n\n    # Use fake embedder to avoid model init\n    monkeypatch.setattr(hyb, \"TextEmbedding\", lambda *a, **k: FakeEmbed())\n    monkeypatch.setattr(hyb, \"_get_embedding_model\", lambda *a, **k: FakeEmbed())\n\n    # path_glob supports list: keep src/*.py and tests/*, filter out docs/*\n    items = hyb.run_hybrid_search(\n        queries=[\"foo\"],\n        limit=10,\n        per_path=2,\n        path_glob=[\"src/*.py\", \"tests/*\"],\n        not_glob=None,\n        expand=False,\n        model=FakeEmbed(),\n    )\n    paths = {it.get(\"path\") for it in items}\n    assert \"src/a.py\" in paths\n    assert \"tests/b_test.py\" in paths\n    assert \"docs/readme.md\" not in paths",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_run_hybrid_search_slugged_path_globs_91": {
      "name": "test_run_hybrid_search_slugged_path_globs",
      "type": "function",
      "start_line": 91,
      "end_line": 114,
      "content_hash": "3b1279629f2e06101e006acf93c3c3340607366d",
      "content": "def test_run_hybrid_search_slugged_path_globs(monkeypatch):\n    # Ensure path_glob matches slugged /work/<slug>/ paths\n    pts = [\n        _Pt(\"1\", \"/work/repo-slug/src/a.py\"),\n        _Pt(\"2\", \"/work/other/docs/readme.md\"),\n    ]\n    monkeypatch.setattr(hyb, \"QdrantClient\", lambda *a, **k: FakeQdrant(pts))\n    monkeypatch.setenv(\"EMBEDDING_MODEL\", \"unit-test\")\n    monkeypatch.setenv(\"QDRANT_URL\", \"http://localhost:6333\")\n    monkeypatch.setattr(hyb, \"TextEmbedding\", lambda *a, **k: FakeEmbed())\n    monkeypatch.setattr(hyb, \"_get_embedding_model\", lambda *a, **k: FakeEmbed())\n\n    items = hyb.run_hybrid_search(\n        queries=[\"foo\"],\n        limit=10,\n        per_path=2,\n        path_glob=[\"src/*.py\"],  # repo-relative glob\n        not_glob=None,\n        expand=False,\n        model=FakeEmbed(),\n    )\n    paths = {it.get(\"path\") for it in items}\n    assert \"/work/repo-slug/src/a.py\" in paths\n    assert \"/work/other/docs/readme.md\" not in paths",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_dense_query_preserves_collection_on_filter_drop_118": {
      "name": "test_dense_query_preserves_collection_on_filter_drop",
      "type": "function",
      "start_line": 118,
      "end_line": 145,
      "content_hash": "15b747e334c8cccf4030be7d8d3025f453236beb",
      "content": "def test_dense_query_preserves_collection_on_filter_drop(monkeypatch):\n    calls = []\n\n    class RecordingClient:\n        def __init__(self):\n            self._fail_once = True\n\n        def query_points(self, **kwargs):\n            calls.append(kwargs)\n            if self._fail_once:\n                self._fail_once = False\n                raise Exception(\"boom\")\n            return types.SimpleNamespace(points=[\"ok\"])\n\n    # Avoid pulling real qdrant models\n    monkeypatch.setattr(\n        hyb,\n        \"models\",\n        types.SimpleNamespace(SearchParams=lambda hnsw_ef: {\"hnsw_ef\": hnsw_ef}),\n    )\n\n    client = RecordingClient()\n    out = hyb.dense_query(client, \"vec\", [0.1], flt=None, per_query=1, collection_name=\"explicit-coll\")\n\n    assert out == [\"ok\"]\n    assert len(calls) == 2  # first fails, second succeeds after filter drop\n    assert calls[1][\"collection_name\"] == \"explicit-coll\"\n    assert calls[1].get(\"query_filter\") is None or calls[1].get(\"filter\") is None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_RecordingClient_121": {
      "name": "RecordingClient",
      "type": "class",
      "start_line": 121,
      "end_line": 130,
      "content_hash": "25f890fb70e8da9b06a6bfbf40020539bf88eaf8",
      "content": "    class RecordingClient:\n        def __init__(self):\n            self._fail_once = True\n\n        def query_points(self, **kwargs):\n            calls.append(kwargs)\n            if self._fail_once:\n                self._fail_once = False\n                raise Exception(\"boom\")\n            return types.SimpleNamespace(points=[\"ok\"])",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___122": {
      "name": "__init__",
      "type": "method",
      "start_line": 122,
      "end_line": 123,
      "content_hash": "9104d55087a450157d74f384d3203392fabd15e1",
      "content": "        def __init__(self):\n            self._fail_once = True",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_query_points_125": {
      "name": "query_points",
      "type": "method",
      "start_line": 125,
      "end_line": 130,
      "content_hash": "1e57b0c8f5e1a7fc2ec8bd05b6bfa951644a3955",
      "content": "        def query_points(self, **kwargs):\n            calls.append(kwargs)\n            if self._fail_once:\n                self._fail_once = False\n                raise Exception(\"boom\")\n            return types.SimpleNamespace(points=[\"ok\"])",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_collection_prefers_env_over_state_149": {
      "name": "test_collection_prefers_env_over_state",
      "type": "function",
      "start_line": 149,
      "end_line": 158,
      "content_hash": "b8f63d17b24f13f2da35d691956a7431d5143e86",
      "content": "def test_collection_prefers_env_over_state(monkeypatch, tmp_path):\n    # State file should be ignored when COLLECTION_NAME env var is set\n    state_dir = tmp_path / \".codebase\"\n    state_dir.mkdir()\n    (state_dir / \"state.json\").write_text(json.dumps({\"qdrant_collection\": \"state-coll\"}), encoding=\"utf-8\")\n\n    monkeypatch.setenv(\"WORKSPACE_PATH\", str(tmp_path))\n    monkeypatch.setenv(\"COLLECTION_NAME\", \"env-coll\")\n\n    assert hyb._collection(None) == \"env-coll\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_repo_search_snippet_strict_cap_after_highlight_162": {
      "name": "test_repo_search_snippet_strict_cap_after_highlight",
      "type": "function",
      "start_line": 162,
      "end_line": 214,
      "content_hash": "07f1d8b916b01a139d223dc2abe4d1b7c95c6c68",
      "content": "def test_repo_search_snippet_strict_cap_after_highlight(monkeypatch):\n    # Stub run_hybrid_search to emit a single result with a known path and range\n    async def fake_run(**kwargs):\n        return {\"results\": [{\"path\": \"/work/f.txt\", \"start_line\": 1, \"end_line\": 1}]}\n\n    # Force in-process shaping to trigger snippet code path\n    monkeypatch.setenv(\"HYBRID_IN_PROCESS\", \"1\")\n\n    # Monkeypatch srv.hybrid_search.run_hybrid_search result pathing via repo_search flow\n    monkeypatch.setattr(\n        srv, \"_tokens_from_queries\", lambda q: [\"foo\"]\n    )  # ensure highlight runs\n\n    # Fake open for the specific /work path\n    big_line = \"foo \" * 1000  # large content to exceed cap\n    _orig_open = builtins.open\n\n    def fake_open(path, *a, **k):\n        if path == \"/work/f.txt\":\n            return types.SimpleNamespace(readlines=lambda: [big_line])\n        return _orig_open(path, *a, **k)  # pragma: no cover\n\n    # Ensure sandbox passes\n    monkeypatch.setattr(srv.os.path, \"isabs\", lambda p: True)\n    monkeypatch.setattr(srv.os.path, \"realpath\", lambda p: \"/work/f.txt\")\n    monkeypatch.setenv(\"MCP_SNIPPET_MAX_BYTES\", \"64\")\n\n    # Stub hybrid_search.run_hybrid_search to return a single item\n    import sys\n\n    class HS:\n        @staticmethod\n        def run_hybrid_search(**kwargs):\n            return [\n                {\"path\": \"/work/f.txt\", \"start_line\": 1, \"end_line\": 1, \"score\": 1.0}\n            ]\n\n    monkeypatch.setitem(sys.modules, \"scripts.hybrid_search\", HS)\n\n    import io\n\n    # Patch open builtin used by server\n    monkeypatch.setattr(builtins, \"open\", fake_open)\n\n    # Execute\n    res = srv.asyncio.get_event_loop().run_until_complete(\n        srv.repo_search(\n            query=\"foo\", include_snippet=True, highlight_snippet=True, context_lines=0\n        )\n    )\n    snip = res[\"results\"][0].get(\"snippet\", \"\")\n    # Strict cap: final length must be <= cap (64)\n    assert len(snip) <= 64",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_fake_run_164": {
      "name": "fake_run",
      "type": "function",
      "start_line": 164,
      "end_line": 165,
      "content_hash": "8287088978649d8612b1addb4abacbc0b7277787",
      "content": "    async def fake_run(**kwargs):\n        return {\"results\": [{\"path\": \"/work/f.txt\", \"start_line\": 1, \"end_line\": 1}]}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_fake_open_179": {
      "name": "fake_open",
      "type": "function",
      "start_line": 179,
      "end_line": 182,
      "content_hash": "90bbdba7a69358a887a03ef9a872799d39cd9d59",
      "content": "    def fake_open(path, *a, **k):\n        if path == \"/work/f.txt\":\n            return types.SimpleNamespace(readlines=lambda: [big_line])\n        return _orig_open(path, *a, **k)  # pragma: no cover",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_HS_192": {
      "name": "HS",
      "type": "class",
      "start_line": 192,
      "end_line": 197,
      "content_hash": "ea36f78d7737e31172c04766b205cd320c5cccf6",
      "content": "    class HS:\n        @staticmethod\n        def run_hybrid_search(**kwargs):\n            return [\n                {\"path\": \"/work/f.txt\", \"start_line\": 1, \"end_line\": 1, \"score\": 1.0}\n            ]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_hybrid_search_194": {
      "name": "run_hybrid_search",
      "type": "method",
      "start_line": 194,
      "end_line": 197,
      "content_hash": "eb44165ab2da25e8bd2117cccb934f99c9eec74c",
      "content": "        def run_hybrid_search(**kwargs):\n            return [\n                {\"path\": \"/work/f.txt\", \"start_line\": 1, \"end_line\": 1, \"score\": 1.0}\n            ]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_repo_search_docstring_clean_218": {
      "name": "test_repo_search_docstring_clean",
      "type": "function",
      "start_line": 218,
      "end_line": 222,
      "content_hash": "6a2a3cab6931b0ecead9f8142c7b62415915faab",
      "content": "def test_repo_search_docstring_clean():\n    doc = srv.repo_search.__doc__\n    assert doc and \"Zero-config code search\" in doc\n    # Ensure stray inline pseudo-code is not embedded in docstring\n    assert \"Accept common alias keys from clients\" not in doc",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}