{
  "file_path": "/work/internal/agent/utils/tool_id_test.go",
  "file_hash": "e4d76640393978222ef44987e6d83660240a38be",
  "updated_at": "2025-12-26T17:34:19.965239",
  "symbols": {
    "function_TestGenerateToolCallID_9": {
      "name": "TestGenerateToolCallID",
      "type": "function",
      "start_line": 9,
      "end_line": 46,
      "content_hash": "a55b9bde123ea8b17126444a72b5a4e4e308de88",
      "content": "func TestGenerateToolCallID(t *testing.T) {\n\tt.Run(\"Mistral ID generation\", func(t *testing.T) {\n\t\tid := GenerateToolCallID(\"mistral\")\n\t\trequire.Len(t, id, 9)\n\t\trequire.True(t, ValidateMistralID(id), \"Generated ID should be valid for Mistral\")\n\n\t\t// Test uniqueness\n\t\tid2 := GenerateToolCallID(\"mistral\")\n\t\trequire.NotEqual(t, id, id2, \"Generated IDs should be unique\")\n\n\t\t// Test alphanumeric only\n\t\tfor _, char := range id {\n\t\t\trequire.True(t,\n\t\t\t\t(char >= 'a' && char <= 'z') ||\n\t\t\t\t\t(char >= 'A' && char <= 'Z') ||\n\t\t\t\t\t(char >= '0' && char <= '9'),\n\t\t\t\t\"ID should contain only alphanumeric characters: %s\", string(char))\n\t\t}\n\t})\n\n\tt.Run(\"Mistral-native ID generation\", func(t *testing.T) {\n\t\tid := GenerateToolCallID(\"mistral-native\")\n\t\trequire.Len(t, id, 9)\n\t\trequire.True(t, ValidateMistralID(id))\n\t})\n\n\tt.Run(\"OpenAI ID generation\", func(t *testing.T) {\n\t\tid := GenerateToolCallID(\"openai\")\n\t\trequire.True(t, len(id) > 12, \"OpenAI ID should include call_ prefix + random chars\")\n\t\trequire.Contains(t, id, \"call_\")\n\t})\n\n\tt.Run(\"Default provider\", func(t *testing.T) {\n\t\tid := GenerateToolCallID(\"unknown\")\n\t\trequire.Contains(t, id, \"call_\")\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestValidateMistralID_47": {
      "name": "TestValidateMistralID",
      "type": "function",
      "start_line": 47,
      "end_line": 71,
      "content_hash": "1bb7d836f8371734881ccb08e991029f46a098a1",
      "content": "func TestValidateMistralID(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tid       string\n\t\texpected bool\n\t}{\n\t\t{\"Valid 9 chars\", \"abc123XYZ\", true},\n\t\t{\"Valid all letters\", \"ABCDEFGHI\", true},\n\t\t{\"Valid all numbers\", \"123456789\", true},\n\t\t{\"Valid mixed case\", \"AbCdEfGhI\", true},\n\t\t{\"Invalid too short\", \"abc123\", false},\n\t\t{\"Invalid too long\", \"abcdefghijk\", false},\n\t\t{\"Invalid contains underscore\", \"abc_12345\", false},\n\t\t{\"Invalid contains dash\", \"abc-12345\", false},\n\t\t{\"Invalid empty\", \"\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := ValidateMistralID(tt.id)\n\t\t\trequire.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSanitizeToolCallID_72": {
      "name": "TestSanitizeToolCallID",
      "type": "function",
      "start_line": 72,
      "end_line": 109,
      "content_hash": "246939d1624638fabd357deb5ae6e1e437eb1567",
      "content": "func TestSanitizeToolCallID(t *testing.T) {\n\tt.Run(\"Mistral sanitization\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tinput    string\n\t\t\texpected int // expected length\n\t\t}{\n\t\t\t{\"call_61626542\", 9}, // Error case from bug report\n\t\t\t{\"call_abcdefghijklmnopqrstu\", 9},\n\t\t\t{\"call_1234567890\", 9},\n\t\t\t{\"abc_123\", 9}, // Non-standard format\n\t\t\t{\"test123456789\", 9},\n\t\t\t{\"\", 9}, // Empty input\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t\tresult := SanitizeToolCallID(tt.input, \"mistral\")\n\t\t\t\trequire.Len(t, result, 9)\n\t\t\t\trequire.True(t, ValidateMistralID(result),\n\t\t\t\t\t\"Sanitized ID should be valid: %s from %s\", result, tt.input)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"OpenAI passthrough\", func(t *testing.T) {\n\t\tinput := \"call_61626542\"\n\t\tresult := SanitizeToolCallID(input, \"openai\")\n\t\trequire.Equal(t, input, result, \"OpenAI IDs should pass through unchanged\")\n\t})\n\n\tt.Run(\"Mistral-nativE sanitization\", func(t *testing.T) {\n\t\tinput := \"call_61626542\"\n\t\tresult := SanitizeToolCallID(input, \"mistral-native\")\n\t\trequire.Len(t, result, 9)\n\t\trequire.True(t, ValidateMistralID(result))\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestEdgeCases_110": {
      "name": "TestEdgeCases",
      "type": "function",
      "start_line": 110,
      "end_line": 128,
      "content_hash": "ee57d7e10655d4c51ca3b09dfbafc8de9fedc5ea",
      "content": "func TestEdgeCases(t *testing.T) {\n\tt.Run(\"Multiple sanitizations consistency\", func(t *testing.T) {\n\t\tinput := \"call_61626542\"\n\t\tresult1 := SanitizeToolCallID(input, \"mistral\")\n\t\tresult2 := SanitizeToolCallID(input, \"mistral\")\n\n\t\t// Results might be different due to random padding, but both should be valid\n\t\trequire.True(t, ValidateMistralID(result1))\n\t\trequire.True(t, ValidateMistralID(result2))\n\t})\n\n\tt.Run(\"All invalid chars input\", func(t *testing.T) {\n\t\tinput := \"!@#$%^&*()_+-=[]{}|;':\\\",./<>?\"\n\t\tresult := SanitizeToolCallID(input, \"mistral\")\n\t\trequire.Len(t, result, 9)\n\t\trequire.True(t, ValidateMistralID(result))\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHasTextToolCalls_129": {
      "name": "TestHasTextToolCalls",
      "type": "function",
      "start_line": 129,
      "end_line": 179,
      "content_hash": "d500e9b18c7ca473c8823d6b6da85908df1f8037",
      "content": "func TestHasTextToolCalls(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ttext     string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"MiniMax tool call format\",\n\t\t\ttext:     \"Let me view that file minimax:tool_call /home/user/file.go 30 310 </minimax:tool_call>\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"XML tool_call format\",\n\t\t\ttext:     \"I'll call a tool <tool_call>{\\\"name\\\": \\\"view\\\", \\\"arguments\\\": {\\\"file_path\\\": \\\"/test\\\"}}</tool_call>\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"function_call format\",\n\t\t\ttext:     \"Calling <function_call name=\\\"bash\\\">echo hello</function_call>\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Plain text without tool calls\",\n\t\t\ttext:     \"This is just regular text without any tool calls\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\ttext:     \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Partial match - only opening tag\",\n\t\t\ttext:     \"Some text with minimax:tool_call but no closing tag\",\n\t\t\texpected: true, // HasTextToolCalls only checks for presence of patterns\n\t\t},\n\t\t{\n\t\t\tname:     \"xai:function_call format\",\n\t\t\ttext:     \"<xai:function_call name=\\\"bash\\\">ls</xai:function_call>\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := HasTextToolCalls(tt.text)\n\t\t\trequire.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestParseTextToolCalls_180": {
      "name": "TestParseTextToolCalls",
      "type": "function",
      "start_line": 180,
      "end_line": 276,
      "content_hash": "163f98a18153c8c8b889334356d176cf03d196b4",
      "content": "func TestParseTextToolCalls(t *testing.T) {\n\tt.Run(\"MiniMax tool call format - view with path only\", func(t *testing.T) {\n\t\ttext := \"Let me view that file minimax:tool_call /home/user/file.go </minimax:tool_call>\"\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"view\", calls[0].Name)\n\t\trequire.Contains(t, calls[0].Arguments, \"/home/user/file.go\")\n\t})\n\n\tt.Run(\"MiniMax tool call format - view with path, limit, offset\", func(t *testing.T) {\n\t\ttext := \"Now viewing minimax:tool_call /home/nexora/internal/agent/agent.go 30 310 </minimax:tool_call>\"\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"view\", calls[0].Name)\n\t\trequire.Contains(t, calls[0].Arguments, \"/home/nexora/internal/agent/agent.go\")\n\t\trequire.Contains(t, calls[0].Arguments, \"30\")\n\t\trequire.Contains(t, calls[0].Arguments, \"310\")\n\t})\n\n\tt.Run(\"XML tool_call format\", func(t *testing.T) {\n\t\ttext := `I'll use a tool <tool_call>{\"name\": \"bash\", \"arguments\": {\"command\": \"ls -la\"}}</tool_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"bash\", calls[0].Name)\n\t})\n\n\tt.Run(\"function_call format\", func(t *testing.T) {\n\t\ttext := `Executing <function_call name=\"grep\">{\"pattern\": \"test\"}</function_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"grep\", calls[0].Name)\n\t})\n\n\tt.Run(\"Multiple tool calls\", func(t *testing.T) {\n\t\ttext := `First call <tool_call>{\"name\": \"view\", \"arguments\": {\"file_path\": \"/a\"}}</tool_call> and another <tool_call>{\"name\": \"bash\", \"arguments\": {\"command\": \"pwd\"}}</tool_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 2)\n\t\trequire.Equal(t, \"view\", calls[0].Name)\n\t\trequire.Equal(t, \"bash\", calls[1].Name)\n\t})\n\n\tt.Run(\"No tool calls in text\", func(t *testing.T) {\n\t\ttext := \"This is plain text without any tool call patterns\"\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Empty(t, calls)\n\t})\n\n\tt.Run(\"Malformed tool call - no closing tag\", func(t *testing.T) {\n\t\ttext := \"minimax:tool_call /some/path without closing tag\"\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Empty(t, calls) // Should not parse without closing tag\n\t})\n\n\tt.Run(\"Generated IDs are unique\", func(t *testing.T) {\n\t\ttext := `<tool_call>{\"name\": \"a\", \"arguments\": {}}</tool_call><tool_call>{\"name\": \"b\", \"arguments\": {}}</tool_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 2)\n\t\trequire.NotEqual(t, calls[0].ID, calls[1].ID, \"Each tool call should have a unique ID\")\n\t})\n\n\tt.Run(\"Real-world MiniMax sample from bug report\", func(t *testing.T) {\n\t\t// This is the actual format seen in the bug report\n\t\ttext := `that when the default max tokens are 0 or undefined, it gets passed as 0 to the backend.                             \n                                                                                                                      \n Let me add a validation fix to ensure that  MaxOutputTokens  is always at least 1:                                   \n                                                                                                                      \n Now I understand the issue! The problem is that  MaxOutputTokens  is being set to 0 somewhere, and this gets passed  \n to the backend as  max_completion_tokens  with a value of 0. The backend validates that  max_completion_tokens       \n must be at least 1, so it fails with the error you're seeing.                                                        \n                                                                                                                      \n Let me fix this by adding validation to ensure  MaxOutputTokens  is always at least 1: minimax:tool_call             \n /home/nexora/internal/agent/agent.go 30 310  </minimax:tool_call>`\n\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"view\", calls[0].Name)\n\t\trequire.Contains(t, calls[0].Arguments, \"/home/nexora/internal/agent/agent.go\")\n\t})\n\n\tt.Run(\"xai:function_call format\", func(t *testing.T) {\n\t\ttext := `I'll use the bash tool <xai:function_call name=\"bash\">\n<parameter name=\"command\">make test-qa</parameter>\n</xai:function_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 1)\n\t\trequire.Equal(t, \"bash\", calls[0].Name)\n\t\trequire.Contains(t, calls[0].Arguments, \"make test-qa\")\n\t})\n\n\tt.Run(\"Multiple xai:function_call\", func(t *testing.T) {\n\t\ttext := `<xai:function_call name=\"view\"><parameter name=\"file_path\">/test</parameter></xai:function_call> then <xai:function_call name=\"bash\"><parameter name=\"command\">ls</parameter></xai:function_call>`\n\t\tcalls := ParseTextToolCalls(text)\n\t\trequire.Len(t, calls, 2)\n\t\trequire.Equal(t, \"view\", calls[0].Name)\n\t\trequire.Equal(t, \"bash\", calls[1].Name)\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}