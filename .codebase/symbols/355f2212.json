{
  "file_path": "/work/internal/indexer/storage.go",
  "file_hash": "eb115f9721f31c021dd34d0628e94ce0a6c25ebb",
  "updated_at": "2025-12-26T17:34:20.172759",
  "symbols": {
    "struct_Indexer_17": {
      "name": "Indexer",
      "type": "struct",
      "start_line": 17,
      "end_line": 24,
      "content_hash": "27c0382e90b2975b97f8b1188a461dd1ddc3e49b",
      "content": "type Indexer struct {\n\tdb        *sql.DB\n\tinitOnce  sync.Once\n\tinitMu    sync.Mutex\n\tinitError error\n}\n\n// NewIndexer creates a new indexer with SQLite backend",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewIndexer_25": {
      "name": "NewIndexer",
      "type": "function",
      "start_line": 25,
      "end_line": 57,
      "content_hash": "62e3a250b14588fcd3957fbd5bab004d024ea016",
      "content": "func NewIndexer(dbPath string) (*Indexer, error) {\n\t// Parse the path to separate filename from query params if needed\n\t// Or trust the driver to handle it.\n\t// But tests show that dbPath is used literally as filename if params are appended.\n\t// The standard sqlite3 driver supports URI filenames if \"file:\" prefix is used or config is set.\n\t// Here we just append params.\n\n\t// If we are testing, we might want to avoid WAL mode or be careful about filenames.\n\t// But better: use \"file:\" prefix to force URI interpretation.\n\tdsn := fmt.Sprintf(\"file:%s?_journal_mode=WAL&_synchronous=NORMAL&_cache_size=10000\", dbPath)\n\n\tdb, err := sql.Open(\"sqlite3\", dsn)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open database: %w\", err)\n\t}\n\n\tindexer := &Indexer{db: db}\n\tindexer.initOnce.Do(func() {\n\t\tindexer.initMu.Lock()\n\t\tdefer indexer.initMu.Unlock()\n\t\tif err := indexer.initSchema(); err != nil {\n\t\t\tindexer.initError = err\n\t\t}\n\t})\n\n\tif indexer.initError != nil {\n\t\treturn nil, indexer.initError\n\t}\n\n\treturn indexer, nil\n}\n\n// initSchema creates the necessary database tables",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_initSchema_58": {
      "name": "initSchema",
      "type": "method",
      "start_line": 58,
      "end_line": 113,
      "content_hash": "50a80f0399240a1a874eb6da2f67d06e032d53d1",
      "content": "func (i *Indexer) initSchema() error {\n\tqueries := []string{\n\t\t`CREATE TABLE IF NOT EXISTS symbols (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tname TEXT NOT NULL,\n\t\t\ttype TEXT NOT NULL,\n\t\t\tpackage TEXT NOT NULL,\n\t\t\tfile TEXT NOT NULL,\n\t\t\tline INTEGER NOT NULL,\n\t\t\tcolumn INTEGER NOT NULL,\n\t\t\tsignature TEXT,\n\t\t\tdoc TEXT,\n\t\t\timports TEXT,\n\t\t\tcallers TEXT,\n\t\t\tcalls TEXT,\n\t\t\tpublic BOOLEAN NOT NULL,\n\t\t\tparams TEXT,\n\t\t\treturns TEXT,\n\t\t\tfields TEXT,\n\t\t\tmethods TEXT,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t)`,\n\t\t`CREATE TABLE IF NOT EXISTS embeddings (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\ttype TEXT NOT NULL,\n\t\t\ttext TEXT NOT NULL,\n\t\t\tvector BLOB NOT NULL,\n\t\t\tmetadata TEXT NOT NULL,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t)`,\n\t\t`CREATE TABLE IF NOT EXISTS relationships (\n\t\t\tfrom_id TEXT NOT NULL,\n\t\t\tto_id TEXT NOT NULL,\n\t\t\trelationship_type TEXT NOT NULL,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\t\t\tPRIMARY KEY (from_id, to_id, relationship_type)\n\t\t)`,\n\t\t`CREATE VIRTUAL TABLE IF NOT EXISTS symbols_fts USING fts5(\n\t\t\tid UNINDEXED, name, type, package, signature, doc\n\t\t)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_symbols_name ON symbols(name)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_symbols_type ON symbols(type)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_symbols_package ON symbols(package)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_symbols_file ON symbols(file)`,\n\t}\n\n\tfor _, query := range queries {\n\t\tif _, err := i.db.Exec(query); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute schema query: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// StoreSymbols saves symbols to the database",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StoreSymbols_114": {
      "name": "StoreSymbols",
      "type": "method",
      "start_line": 114,
      "end_line": 167,
      "content_hash": "5611ac31360bafcd2f589bd880cec81c496c63c4",
      "content": "func (i *Indexer) StoreSymbols(ctx context.Context, symbols []Symbol) error {\n\ttx, err := i.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback()\n\n\tstmt, err := tx.PrepareContext(ctx, `\n\t\tINSERT OR REPLACE INTO symbols (\n\t\t\tid, name, type, package, file, line, column, signature, doc,\n\t\t\timports, callers, calls, public, params, returns, fields, methods\n\t\t) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\tfor _, symbol := range symbols {\n\t\timportsJSON, _ := json.Marshal(symbol.Imports)\n\t\tcallersJSON, _ := json.Marshal(symbol.Callers)\n\t\tcallsJSON, _ := json.Marshal(symbol.Calls)\n\t\tparamsJSON, _ := json.Marshal(symbol.Params)\n\t\treturnsJSON, _ := json.Marshal(symbol.Returns)\n\t\tfieldsJSON, _ := json.Marshal(symbol.Fields)\n\t\tmethodsJSON, _ := json.Marshal(symbol.Methods)\n\n\t\tid := fmt.Sprintf(\"%s:%s:%d\", symbol.Package, symbol.Name, symbol.Line)\n\n\t\t_, err := stmt.ExecContext(ctx,\n\t\t\tid, symbol.Name, symbol.Type, symbol.Package, symbol.File,\n\t\t\tsymbol.Line, symbol.Column, symbol.Signature, symbol.Doc,\n\t\t\tstring(importsJSON), string(callersJSON), string(callsJSON),\n\t\t\tsymbol.Public, string(paramsJSON), string(returnsJSON),\n\t\t\tstring(fieldsJSON), string(methodsJSON),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to insert symbol %s: %w\", symbol.Name, err)\n\t\t}\n\n\t\t// Add to FTS\n\t\t_, err = tx.ExecContext(ctx, `\n\t\t\tINSERT OR REPLACE INTO symbols_fts(id, name, type, package, signature, doc)\n\t\t\tVALUES (?, ?, ?, ?, ?, ?)\n\t\t`, id, symbol.Name, symbol.Type, symbol.Package, symbol.Signature, symbol.Doc)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Failed to add symbol to FTS\", \"symbol\", symbol.Name, \"error\", err)\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n\n// StoreEmbeddings saves embeddings to the database",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_StoreEmbeddings_168": {
      "name": "StoreEmbeddings",
      "type": "method",
      "start_line": 168,
      "end_line": 206,
      "content_hash": "16dc11e79340efe44d06ddf7f8485a4bb7d75dd5",
      "content": "func (i *Indexer) StoreEmbeddings(ctx context.Context, embeddings []Embedding) error {\n\ttx, err := i.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback()\n\n\tstmt, err := tx.PrepareContext(ctx, `\n\t\tINSERT OR REPLACE INTO embeddings (id, type, text, vector, metadata)\n\t\tVALUES (?, ?, ?, ?, ?)\n\t`)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\tfor _, embedding := range embeddings {\n\t\tvectorJSON, err := json.Marshal(embedding.Vector)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal vector for embedding %s: %w\", embedding.ID, err)\n\t\t}\n\n\t\tmetadataJSON, err := json.Marshal(embedding.Metadata)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal metadata for embedding %s: %w\", embedding.ID, err)\n\t\t}\n\n\t\t_, err = stmt.ExecContext(ctx,\n\t\t\tembedding.ID, embedding.Type, embedding.Text, string(vectorJSON), string(metadataJSON),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to insert embedding %s: %w\", embedding.ID, err)\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n\n// SearchSymbols performs text search on symbols",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SearchSymbols_207": {
      "name": "SearchSymbols",
      "type": "method",
      "start_line": 207,
      "end_line": 264,
      "content_hash": "46201d617bf858d63911572e7d31aa15e7f1a2e9",
      "content": "func (i *Indexer) SearchSymbols(ctx context.Context, query string, limit int) ([]Symbol, error) {\n\tvar rows *sql.Rows\n\tvar err error\n\n\tif query == \"\" {\n\t\t// For empty query, return all symbols\n\t\trows, err = i.db.QueryContext(ctx, `\n\t\t\tSELECT DISTINCT s.* FROM symbols s\n\t\t\tLIMIT ?\n\t\t`, limit)\n\t} else {\n\t\t// Use FTS for text search\n\t\trows, err = i.db.QueryContext(ctx, `\n\t\t\tSELECT s.* FROM symbols s\n\t\t\tJOIN symbols_fts ON s.id = symbols_fts.id\n\t\t\tWHERE symbols_fts MATCH ?\n\t\t\tLIMIT ?\n\t\t`, query, limit)\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search symbols: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tsymbols := make([]Symbol, 0)\n\tfor rows.Next() {\n\t\tvar symbol Symbol\n\t\tvar id string\n\t\tvar importsJSON, callersJSON, callsJSON, paramsJSON, returnsJSON, fieldsJSON, methodsJSON string\n\t\tvar createdAt time.Time\n\n\t\terr := rows.Scan(\n\t\t\t&id, &symbol.Name, &symbol.Type, &symbol.Package,\n\t\t\t&symbol.File, &symbol.Line, &symbol.Column, &symbol.Signature,\n\t\t\t&symbol.Doc, &importsJSON, &callersJSON, &callsJSON,\n\t\t\t&symbol.Public, &paramsJSON, &returnsJSON, &fieldsJSON,\n\t\t\t&methodsJSON, &createdAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan symbol row: %w\", err)\n\t\t}\n\n\t\t// Parse JSON fields\n\t\tjson.Unmarshal([]byte(importsJSON), &symbol.Imports)\n\t\tjson.Unmarshal([]byte(callersJSON), &symbol.Callers)\n\t\tjson.Unmarshal([]byte(callsJSON), &symbol.Calls)\n\t\tjson.Unmarshal([]byte(paramsJSON), &symbol.Params)\n\t\tjson.Unmarshal([]byte(returnsJSON), &symbol.Returns)\n\t\tjson.Unmarshal([]byte(fieldsJSON), &symbol.Fields)\n\t\tjson.Unmarshal([]byte(methodsJSON), &symbol.Methods)\n\n\t\tsymbols = append(symbols, symbol)\n\t}\n\n\treturn symbols, nil\n}\n\n// GetSymbol finds a specific symbol by ID",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSymbol_265": {
      "name": "GetSymbol",
      "type": "method",
      "start_line": 265,
      "end_line": 329,
      "content_hash": "8ae20849c1d932d3486f27499cb14be3fe4755f9",
      "content": "func (i *Indexer) GetSymbol(ctx context.Context, id string) (*Symbol, error) {\n\t// Try to get symbol by ID first\n\trow := i.db.QueryRowContext(ctx, `\n\t\tSELECT id, name, type, package, file, line, column, signature, doc,\n\t\timports, callers, calls, public, params, returns, fields, methods, created_at\n\t\tFROM symbols WHERE id = ?\n\t`, id)\n\n\tvar symbol Symbol\n\tvar importsJSON, callersJSON, callsJSON, paramsJSON, returnsJSON, fieldsJSON, methodsJSON string\n\tvar createdAt time.Time\n\n\terr := row.Scan(\n\t\t&id, &symbol.Name, &symbol.Type, &symbol.Package,\n\t\t&symbol.File, &symbol.Line, &symbol.Column, &symbol.Signature,\n\t\t&symbol.Doc, &importsJSON, &callersJSON, &callsJSON,\n\t\t&symbol.Public, paramsJSON, &returnsJSON, &fieldsJSON,\n\t\t&methodsJSON, &createdAt,\n\t)\n\tif err == nil {\n\t\t// Successfully found by ID\n\t\treturn &symbol, nil\n\t}\n\n\t// If ID lookup failed, try name lookup\n\trow = i.db.QueryRowContext(ctx, `\n\t\tSELECT id, name, type, package, file, line, column, signature, doc,\n\t\timports, callers, calls, public, params, returns, fields, methods, created_at\n\t\tFROM symbols WHERE name = ?\n\t\tLIMIT 1\n\t`, id)\n\n\t// Reset variables for name lookup\n\tvar symbolID string\n\tvar importsJSON2, callersJSON2, callsJSON2, paramsJSON2, returnsJSON2, fieldsJSON2, methodsJSON2 string\n\tvar createdAt2 time.Time\n\n\terr = row.Scan(\n\t\t&symbolID, &symbol.Name, &symbol.Type, &symbol.Package,\n\t\t&symbol.File, &symbol.Line, &symbol.Column, &symbol.Signature,\n\t\t&symbol.Doc, &importsJSON2, &callersJSON2, &callsJSON2,\n\t\t&symbol.Public, &paramsJSON2, &returnsJSON2, &fieldsJSON2,\n\t\t&methodsJSON2, &createdAt2,\n\t)\n\n\tif err == nil {\n\t\t// Parse JSON fields for name lookup\n\t\tjson.Unmarshal([]byte(importsJSON2), &symbol.Imports)\n\t\tjson.Unmarshal([]byte(callersJSON2), &symbol.Callers)\n\t\tjson.Unmarshal([]byte(callsJSON2), &symbol.Calls)\n\t\tjson.Unmarshal([]byte(paramsJSON2), &symbol.Params)\n\t\tjson.Unmarshal([]byte(returnsJSON2), &symbol.Returns)\n\t\tjson.Unmarshal([]byte(fieldsJSON2), &symbol.Fields)\n\t\tjson.Unmarshal([]byte(methodsJSON2), &symbol.Methods)\n\n\t\treturn &symbol, nil\n\t}\n\n\tif err == sql.ErrNoRows {\n\t\treturn nil, fmt.Errorf(\"symbol not found: %s\", id)\n\t}\n\treturn nil, fmt.Errorf(\"failed to get symbol: %w\", err)\n}\n\n// FindCallers finds all symbols that call the given symbol",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindCallers_330": {
      "name": "FindCallers",
      "type": "method",
      "start_line": 330,
      "end_line": 344,
      "content_hash": "77e3607d8192030fd7aed54f4b25f7542bb24e61",
      "content": "func (i *Indexer) FindCallers(ctx context.Context, targetSymbol string) ([]Symbol, error) {\n\trows, err := i.db.QueryContext(ctx, `\n\t\tSELECT DISTINCT s.* FROM symbols s\n\t\tWHERE s.calls LIKE ?\n\t\tORDER BY s.package, s.name\n\t`, \"%\"+targetSymbol+\"%\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to find callers: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\treturn i.scanSymbols(rows)\n}\n\n// FindCalled finds all symbols called by the given symbol",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindCalled_345": {
      "name": "FindCalled",
      "type": "method",
      "start_line": 345,
      "end_line": 359,
      "content_hash": "5924109b7c3012622e8858ccde0298336ccbb823",
      "content": "func (i *Indexer) FindCalled(ctx context.Context, sourceSymbol string) ([]Symbol, error) {\n\trows, err := i.db.QueryContext(ctx, `\n\t\tSELECT DISTINCT s.* FROM symbols s\n\t\tWHERE s.callers LIKE ?\n\t\tORDER BY s.package, s.name\n\t`, \"%\"+sourceSymbol+\"%\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to find called symbols: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\treturn i.scanSymbols(rows)\n}\n\n// GetAllEmbeddings retrieves all embeddings from storage",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetAllEmbeddings_360": {
      "name": "GetAllEmbeddings",
      "type": "method",
      "start_line": 360,
      "end_line": 386,
      "content_hash": "1d7c6619222ee25ed4b24b93c919799ec6f477d5",
      "content": "func (i *Indexer) GetAllEmbeddings(ctx context.Context) ([]Embedding, error) {\n\trows, err := i.db.QueryContext(ctx, \"SELECT id, type, text, vector, metadata, created_at FROM embeddings\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get embeddings: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tembeddings := make([]Embedding, 0)\n\tfor rows.Next() {\n\t\tvar embedding Embedding\n\t\tvar vectorJSON, metadataJSON string\n\n\t\terr := rows.Scan(&embedding.ID, &embedding.Type, &embedding.Text, &vectorJSON, &metadataJSON, &embedding.Created)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan embedding row: %w\", err)\n\t\t}\n\n\t\tjson.Unmarshal([]byte(vectorJSON), &embedding.Vector)\n\t\tjson.Unmarshal([]byte(metadataJSON), &embedding.Metadata)\n\n\t\tembeddings = append(embeddings, embedding)\n\t}\n\n\treturn embeddings, nil\n}\n\n// Close closes the database connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_387": {
      "name": "Close",
      "type": "method",
      "start_line": 387,
      "end_line": 391,
      "content_hash": "ecc3ee6d7e4a3ceb30a439bf963382431a8e9ba8",
      "content": "func (i *Indexer) Close() error {\n\treturn i.db.Close()\n}\n\n// Helper function to scan symbols from database rows",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_scanSymbols_392": {
      "name": "scanSymbols",
      "type": "method",
      "start_line": 392,
      "end_line": 425,
      "content_hash": "efff366f8f4add5a364af952f5551c75162c66fb",
      "content": "func (i *Indexer) scanSymbols(rows *sql.Rows) ([]Symbol, error) {\n\tsymbols := make([]Symbol, 0)\n\tfor rows.Next() {\n\t\tvar symbol Symbol\n\t\tvar id string\n\t\tvar importsJSON, callersJSON, callsJSON, paramsJSON, returnsJSON, fieldsJSON, methodsJSON string\n\t\tvar createdAt time.Time\n\n\t\terr := rows.Scan(\n\t\t\t&id, &symbol.Name, &symbol.Type, &symbol.Package,\n\t\t\t&symbol.File, &symbol.Line, &symbol.Column, &symbol.Signature,\n\t\t\t&symbol.Doc, &importsJSON, &callersJSON, &callsJSON,\n\t\t\t&symbol.Public, &paramsJSON, &returnsJSON, &fieldsJSON,\n\t\t\t&methodsJSON, &createdAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan symbol row: %w\", err)\n\t\t}\n\n\t\t// Parse JSON fields\n\t\tjson.Unmarshal([]byte(importsJSON), &symbol.Imports)\n\t\tjson.Unmarshal([]byte(callersJSON), &symbol.Callers)\n\t\tjson.Unmarshal([]byte(callsJSON), &symbol.Calls)\n\t\tjson.Unmarshal([]byte(paramsJSON), &symbol.Params)\n\t\tjson.Unmarshal([]byte(returnsJSON), &symbol.Returns)\n\t\tjson.Unmarshal([]byte(fieldsJSON), &symbol.Fields)\n\t\tjson.Unmarshal([]byte(methodsJSON), &symbol.Methods)\n\n\t\tsymbols = append(symbols, symbol)\n\t}\n\treturn symbols, nil\n}\n\n// DeleteSymbolsByFile removes all symbols associated with a specific file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_DeleteSymbolsByFile_426": {
      "name": "DeleteSymbolsByFile",
      "type": "method",
      "start_line": 426,
      "end_line": 440,
      "content_hash": "b748626ef925afd6fae3ef1a16503277f22547b9",
      "content": "func (i *Indexer) DeleteSymbolsByFile(ctx context.Context, filePath string) error {\n\t// Delete symbols from the symbols table\n\t_, err := i.db.ExecContext(ctx, \"DELETE FROM symbols WHERE file = ?\", filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete symbols from file %s: %w\", filePath, err)\n\t}\n\n\t// Delete associated embeddings\n\t_, err = i.db.ExecContext(ctx, \"DELETE FROM embeddings WHERE metadata LIKE ?\", \"%\"+filePath+\"%\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete embeddings from file %s: %w\", filePath, err)\n\t}\n\n\treturn nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}