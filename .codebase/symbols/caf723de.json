{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/mcp/tools.rs",
  "file_hash": "ef981d07013a6cbc138500a6659ba2c9ce6c0b2d",
  "updated_at": "2025-12-26T17:34:21.572431",
  "symbols": {
    "enum_EdgeType_26": {
      "name": "EdgeType",
      "type": "enum",
      "start_line": 26,
      "end_line": 33,
      "content_hash": "d1bfbfe3dc9632838b163f52072009edcbea57fd",
      "content": "pub enum EdgeType {\n    Node,\n    Vec,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"tool_name\", content = \"args\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ToolArgs_34": {
      "name": "ToolArgs",
      "type": "enum",
      "start_line": 34,
      "end_line": 85,
      "content_hash": "98df2596707f43aaee29e593bf3dab429d8b2c14",
      "content": "pub enum ToolArgs {\n    OutStep {\n        edge_label: String,\n        edge_type: EdgeType,\n        filter: Option<FilterTraversal>,\n    },\n    OutEStep {\n        edge_label: String,\n        filter: Option<FilterTraversal>,\n    },\n    InStep {\n        edge_label: String,\n        edge_type: EdgeType,\n        filter: Option<FilterTraversal>,\n    },\n    InEStep {\n        edge_label: String,\n        filter: Option<FilterTraversal>,\n    },\n    NFromType {\n        node_type: String,\n    },\n    EFromType {\n        edge_type: String,\n    },\n    FilterItems {\n        #[serde(default)]\n        filter: FilterTraversal,\n    },\n    OrderBy {\n        properties: String,\n        order: Order,\n    },\n    SearchKeyword {\n        query: String,\n        limit: usize,\n        label: String,\n    },\n    SearchVecText {\n        query: String,\n        label: String,\n        k: usize,\n    },\n    SearchVec {\n        vector: Vec<f64>,\n        k: usize,\n        min_score: Option<f64>,\n        cutoff: Option<usize>,\n    },\n}\n\n#[derive(Debug, Clone, Copy, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Order_86": {
      "name": "Order",
      "type": "enum",
      "start_line": 86,
      "end_line": 94,
      "content_hash": "7f9fcb6e96f36734d7a11b596d06e16c48b06a80",
      "content": "pub enum Order {\n    #[serde(rename = \"asc\")]\n    Asc,\n    #[serde(rename = \"desc\")]\n    Desc,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"snake_case\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FilterProperties_95": {
      "name": "FilterProperties",
      "type": "struct",
      "start_line": 95,
      "end_line": 101,
      "content_hash": "d2f6fbb3db3be10fbaa5b4647b28724ea73c8c41",
      "content": "pub struct FilterProperties {\n    pub key: String,\n    pub value: Value,\n    pub operator: Option<Operator>,\n}\n\n#[derive(Debug, Clone, Deserialize, Default)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FilterTraversal_102": {
      "name": "FilterTraversal",
      "type": "struct",
      "start_line": 102,
      "end_line": 107,
      "content_hash": "b0a591f8b72b838823611063a9ba1a40ce4880dc",
      "content": "pub struct FilterTraversal {\n    pub properties: Option<Vec<Vec<FilterProperties>>>,\n    pub filter_traversals: Option<Vec<ToolArgs>>,\n}\n\n#[derive(Debug, Clone, Copy, Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Operator_108": {
      "name": "Operator",
      "type": "enum",
      "start_line": 108,
      "end_line": 122,
      "content_hash": "8fab62f07ec93de283638012bfae0a87fd6d94b3",
      "content": "pub enum Operator {\n    #[serde(rename = \"==\")]\n    Eq,\n    #[serde(rename = \"!=\")]\n    Neq,\n    #[serde(rename = \">\")]\n    Gt,\n    #[serde(rename = \"<\")]\n    Lt,\n    #[serde(rename = \">=\")]\n    Gte,\n    #[serde(rename = \"<=\")]\n    Lte,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Operator_123": {
      "name": "Operator",
      "type": "impl",
      "start_line": 123,
      "end_line": 124,
      "content_hash": "c8ec9b7afbaaf58841951c0494f975fc9f45217f",
      "content": "impl Operator {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_execute_125": {
      "name": "execute",
      "type": "method",
      "start_line": 125,
      "end_line": 139,
      "content_hash": "3d175e50e6610929fe75dedec070a51dab6a4562",
      "content": "    pub fn execute(&self, lhs: &Value, rhs: &Value) -> bool {\n        match self {\n            Operator::Eq => lhs == rhs,\n            Operator::Neq => lhs != rhs,\n            Operator::Gt => lhs > rhs,\n            Operator::Lt => lhs < rhs,\n            Operator::Gte => lhs >= rhs,\n            Operator::Lte => lhs <= rhs,\n        }\n    }\n}\n\ntype DynIter<'arena, 'txn> =\n    Box<dyn Iterator<Item = Result<TraversalValue<'arena>, GraphError>> + 'txn>;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TraversalStream_140": {
      "name": "TraversalStream",
      "type": "struct",
      "start_line": 140,
      "end_line": 147,
      "content_hash": "fe0c4e947146032d579a1ad3404b68f57783111a",
      "content": "pub struct TraversalStream<'db, 'arena, 'txn>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    iter: RoTraversalIterator<'db, 'arena, 'txn, DynIter<'arena, 'txn>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_TraversalStream_148": {
      "name": "TraversalStream",
      "type": "impl",
      "start_line": 148,
      "end_line": 152,
      "content_hash": "31837f2b95a6951d2427981b21f44fdc62036fa2",
      "content": "impl<'db, 'arena, 'txn> TraversalStream<'db, 'arena, 'txn>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_153": {
      "name": "new",
      "type": "method",
      "start_line": 153,
      "end_line": 160,
      "content_hash": "f69135fc2caeebb8bd42a3305e76817bd91ab51e",
      "content": "    pub fn new(\n        storage: &'db HelixGraphStorage,\n        txn: &'txn RoTxn<'db>,\n        arena: &'arena Bump,\n    ) -> Self {\n        Self::from_ro_iterator(G::new(storage, txn, arena))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_iter_161": {
      "name": "from_iter",
      "type": "method",
      "start_line": 161,
      "end_line": 202,
      "content_hash": "4b7bf3fb77e088b33517c425e8abcaab095330de",
      "content": "    pub fn from_iter(\n        storage: &'db HelixGraphStorage,\n        txn: &'txn RoTxn<'db>,\n        arena: &'arena Bump,\n        items: impl Iterator<Item = TraversalValue<'arena>> + 'txn,\n    ) -> Self {\n        Self::from_ro_iterator(G::from_iter(storage, txn, items, arena))\n    }\n\n    pub fn from_ro_iterator<I>(iter: RoTraversalIterator<'db, 'arena, 'txn, I>) -> Self\n    where\n        I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>> + 'txn,\n    {\n        let RoTraversalIterator {\n            storage,\n            arena,\n            txn,\n            inner,\n        } = iter;\n\n        let boxed: DynIter<'arena, 'txn> = Box::new(inner);\n\n        Self {\n            iter: RoTraversalIterator {\n                storage,\n                arena,\n                txn,\n                inner: boxed,\n            },\n        }\n    }\n\n    pub fn map<I, F>(self, f: F) -> TraversalStream<'db, 'arena, 'txn>\n    where\n        I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>> + 'txn,\n        F: FnOnce(\n            RoTraversalIterator<'db, 'arena, 'txn, DynIter<'arena, 'txn>>,\n        ) -> RoTraversalIterator<'db, 'arena, 'txn, I>,\n    {\n        TraversalStream::from_ro_iterator(f(self.iter))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_ro_203": {
      "name": "into_ro",
      "type": "method",
      "start_line": 203,
      "end_line": 206,
      "content_hash": "13c4d074782b4bf093fb02173262722dca0d445d",
      "content": "    pub fn into_ro(self) -> RoTraversalIterator<'db, 'arena, 'txn, DynIter<'arena, 'txn>> {\n        self.iter\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_inner_iter_207": {
      "name": "into_inner_iter",
      "type": "method",
      "start_line": 207,
      "end_line": 210,
      "content_hash": "7fcbf3ccf9ad9ffc69924f9e182a1f81ae899114",
      "content": "    pub fn into_inner_iter(self) -> DynIter<'arena, 'txn> {\n        self.iter.inner\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_collect_211": {
      "name": "collect",
      "type": "method",
      "start_line": 211,
      "end_line": 218,
      "content_hash": "bcd3a66a8c1972e23a0ed0068cd7cbfbe3cfb917",
      "content": "    pub fn collect(self) -> Result<Vec<TraversalValue<'arena>>, GraphError> {\n        let mut values = Vec::new();\n        for item in self.into_inner_iter() {\n            values.push(item?);\n        }\n        Ok(values)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_nth_219": {
      "name": "nth",
      "type": "method",
      "start_line": 219,
      "end_line": 501,
      "content_hash": "9efc31e0448a875b5a346db02664139443079ab3",
      "content": "    pub fn nth(self, index: usize) -> Result<Option<TraversalValue<'arena>>, GraphError> {\n        let mut iter = self.into_inner_iter();\n        for _ in 0..index {\n            if let Some(res) = iter.next() {\n                res?;\n            } else {\n                return Ok(None);\n            }\n        }\n\n        match iter.next() {\n            Some(res) => res.map(Some),\n            None => Ok(None),\n        }\n    }\n}\n\npub fn execute_query_chain<'db, 'arena, 'txn>(\n    steps: &[ToolArgs],\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n) -> Result<TraversalStream<'db, 'arena, 'txn>, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    let initial = TraversalStream::new(storage, txn, arena);\n    execute_query_chain_with_stream(initial, steps, storage, txn, arena)\n}\n\npub fn execute_query_chain_from_seed<'db, 'arena, 'txn>(\n    steps: &[ToolArgs],\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n    seed: impl Iterator<Item = TraversalValue<'arena>> + 'txn,\n) -> Result<TraversalStream<'db, 'arena, 'txn>, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    let initial = TraversalStream::from_iter(storage, txn, arena, seed);\n    execute_query_chain_with_stream(initial, steps, storage, txn, arena)\n}\n\npub fn execute_query_chain_with_stream<'db, 'arena, 'txn>(\n    initial: TraversalStream<'db, 'arena, 'txn>,\n    steps: &[ToolArgs],\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n) -> Result<TraversalStream<'db, 'arena, 'txn>, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    steps.iter().try_fold(initial, |stream, step| {\n        apply_step(stream, step, storage, txn, arena)\n    })\n}\n\nfn apply_step<'db, 'arena, 'txn>(\n    stream: TraversalStream<'db, 'arena, 'txn>,\n    step: &ToolArgs,\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n) -> Result<TraversalStream<'db, 'arena, 'txn>, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    match step {\n        ToolArgs::NFromType { node_type } => {\n            let label = arena.alloc_str(node_type);\n            Ok(TraversalStream::from_ro_iterator(\n                G::new(storage, txn, arena).n_from_type(label),\n            ))\n        }\n        ToolArgs::EFromType { edge_type } => {\n            let label = arena.alloc_str(edge_type);\n            Ok(TraversalStream::from_ro_iterator(\n                G::new(storage, txn, arena).e_from_type(label),\n            ))\n        }\n        ToolArgs::OutStep {\n            edge_label,\n            edge_type,\n            filter,\n        } => {\n            let label = arena.alloc_str(edge_label);\n            let edge_kind = *edge_type;\n            let transformed = match edge_kind {\n                EdgeType::Node => stream.map(|iter| iter.out_node(label)),\n                EdgeType::Vec => stream.map(|iter| iter.out_vec(label, true)),\n            };\n\n            if let Some(filter) = filter.clone() {\n                apply_filter(transformed, filter)\n            } else {\n                Ok(transformed)\n            }\n        }\n        ToolArgs::OutEStep { edge_label, filter } => {\n            let label = arena.alloc_str(edge_label);\n            let transformed = stream.map(|iter| iter.out_e(label));\n\n            if let Some(filter) = filter.clone() {\n                apply_filter(transformed, filter)\n            } else {\n                Ok(transformed)\n            }\n        }\n        ToolArgs::InStep {\n            edge_label,\n            edge_type,\n            filter,\n        } => {\n            let label = arena.alloc_str(edge_label);\n            let edge_kind = *edge_type;\n            let transformed = match edge_kind {\n                EdgeType::Node => stream.map(|iter| iter.in_node(label)),\n                EdgeType::Vec => stream.map(|iter| iter.in_vec(label, true)),\n            };\n\n            if let Some(filter) = filter.clone() {\n                apply_filter(transformed, filter)\n            } else {\n                Ok(transformed)\n            }\n        }\n        ToolArgs::InEStep { edge_label, filter } => {\n            let label = arena.alloc_str(edge_label);\n            let transformed = stream.map(|iter| iter.in_e(label));\n\n            if let Some(filter) = filter.clone() {\n                apply_filter(transformed, filter)\n            } else {\n                Ok(transformed)\n            }\n        }\n        ToolArgs::FilterItems { filter } => apply_filter(stream, filter.clone()),\n        ToolArgs::OrderBy { properties, order } => {\n            let props = arena.alloc_str(properties);\n            let values = stream.collect()?;\n            let iter = TraversalStream::from_iter(storage, txn, arena, values.into_iter());\n            let ordered_stream = match order {\n                Order::Asc => iter.map(|iter| iter.order_by_asc(props)),\n                Order::Desc => iter.map(|iter| iter.order_by_desc(props)),\n            };\n            Ok(ordered_stream)\n        }\n        ToolArgs::SearchKeyword { .. } => {\n            // SearchKeyword requires special BM25 indexing and connection state\n            // It should be called via the dedicated search_keyword MCP handler\n            // not through the generic query chain execution\n            Err(GraphError::New(\n                \"SearchKeyword is not supported in generic query chains. Use the search_keyword endpoint directly.\".to_string()\n            ))\n        }\n        ToolArgs::SearchVecText { query, label, k } => {\n            // SearchVecText requires embedding model initialization\n            // It should be called via the dedicated search_vec_text MCP handler\n            // not through the generic query chain execution\n            Err(GraphError::New(format!(\n                \"SearchVecText (query: {}, label: {}, k: {}) is not supported in generic query chains. Use the search_vec_text endpoint directly.\",\n                query, label, k\n            )))\n        }\n        ToolArgs::SearchVec {\n            vector,\n            k,\n            min_score,\n            cutoff,\n        } => {\n            use crate::helix_engine::traversal_core::ops::vectors::brute_force_search::BruteForceSearchVAdapter;\n\n            let query_vec = arena.alloc_slice_copy(vector);\n            let mut results = match cutoff {\n                Some(cutoff_val) => stream.map(|iter| {\n                    iter.range(0, *cutoff_val)\n                        .brute_force_search_v(query_vec, *k)\n                }),\n                None => stream.map(|iter| iter.brute_force_search_v(query_vec, *k)),\n            };\n\n            // Apply min_score filter if specified\n            if let Some(min_score_val) = min_score {\n                let min_score_copy = *min_score_val;\n                results = results.map(|iter| {\n                    let RoTraversalIterator {\n                        storage,\n                        arena,\n                        txn,\n                        inner,\n                    } = iter;\n                    let filtered: DynIter<'arena, 'txn> = Box::new(inner.filter(move |item_res| {\n                        match item_res {\n                            Ok(TraversalValue::Vector(v)) => v.get_distance() > min_score_copy,\n                            _ => true, // Keep non-vector items\n                        }\n                    }));\n                    RoTraversalIterator {\n                        storage,\n                        arena,\n                        txn,\n                        inner: filtered,\n                    }\n                });\n            }\n\n            Ok(results)\n        }\n    }\n}\n\nfn apply_filter<'db, 'arena, 'txn>(\n    stream: TraversalStream<'db, 'arena, 'txn>,\n    filter: FilterTraversal,\n) -> Result<TraversalStream<'db, 'arena, 'txn>, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    let filter_arc = Arc::new(filter);\n\n    Ok(stream.map(|iter| {\n        let RoTraversalIterator {\n            storage,\n            arena,\n            txn,\n            inner,\n        } = iter;\n\n        let filter_clone = Arc::clone(&filter_arc);\n        let filtered: DynIter<'arena, 'txn> =\n            Box::new(inner.filter_map(move |item_res| match item_res {\n                Ok(item) => match matches_filter(&item, &filter_clone, storage, txn, arena) {\n                    Ok(true) => Some(Ok(item)),\n                    Ok(false) => None,\n                    Err(err) => Some(Err(err)),\n                },\n                Err(err) => Some(Err(err)),\n            }));\n\n        RoTraversalIterator {\n            storage,\n            arena,\n            txn,\n            inner: filtered,\n        }\n    }))\n}\n\nfn matches_filter<'db, 'arena, 'txn>(\n    item: &TraversalValue<'arena>,\n    filter: &FilterTraversal,\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n) -> Result<bool, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    if !matches_properties(item, filter.properties.as_ref()) {\n        return Ok(false);\n    }\n\n    match &filter.filter_traversals {\n        Some(traversals) => {\n            for tool in traversals {\n                if !evaluate_sub_traversal(item, tool, storage, txn, arena)? {\n                    return Ok(false);\n                }\n            }\n            Ok(true)\n        }\n        None => Ok(true),\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_matches_properties_502": {
      "name": "matches_properties",
      "type": "method",
      "start_line": 502,
      "end_line": 539,
      "content_hash": "98a4dd6a4d7ba287aa178a029d70f2a8aa498463",
      "content": "fn matches_properties(\n    item: &TraversalValue<'_>,\n    groups: Option<&Vec<Vec<FilterProperties>>>,\n) -> bool {\n    match groups {\n        Some(groups) => groups.iter().any(|filters| {\n            filters.iter().all(|filter| {\n                item.get_property(&filter.key)\n                    .map(|value| value.compare(&filter.value, filter.operator))\n                    .unwrap_or(false)\n            })\n        }),\n        None => true,\n    }\n}\n\nfn evaluate_sub_traversal<'db, 'arena, 'txn>(\n    item: &TraversalValue<'arena>,\n    step: &ToolArgs,\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    arena: &'arena Bump,\n) -> Result<bool, GraphError>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n{\n    let seed = std::iter::once(item.clone());\n    let stream =\n        execute_query_chain_from_seed(std::slice::from_ref(step), storage, txn, arena, seed)?;\n    let mut iter = stream.into_inner_iter();\n    match iter.next() {\n        Some(Ok(_)) => Ok(true),\n        Some(Err(err)) => Err(err),\n        None => Ok(false),\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_FilterValues_540": {
      "name": "FilterValues",
      "type": "trait",
      "start_line": 540,
      "end_line": 540,
      "content_hash": "3ab8d5f29a0edd0b95a7743834d3b96f408fd72a",
      "content": "pub trait FilterValues {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_compare_541": {
      "name": "compare",
      "type": "method",
      "start_line": 541,
      "end_line": 552,
      "content_hash": "ef56632ac7b5c1a62546e712eb6293707e9f9379",
      "content": "    fn compare(&self, value: &Value, operator: Option<Operator>) -> bool;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // Operator::execute() Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_eq_553": {
      "name": "test_operator_eq",
      "type": "method",
      "start_line": 553,
      "end_line": 575,
      "content_hash": "be443112889cd1cdb9b06d07ca9c93efd85f36b9",
      "content": "    fn test_operator_eq() {\n        let op = Operator::Eq;\n\n        // Integers\n        assert!(op.execute(&Value::I32(5), &Value::I32(5)));\n        assert!(!op.execute(&Value::I32(5), &Value::I32(6)));\n\n        // Strings\n        assert!(op.execute(\n            &Value::String(\"hello\".to_string()),\n            &Value::String(\"hello\".to_string())\n        ));\n        assert!(!op.execute(\n            &Value::String(\"hello\".to_string()),\n            &Value::String(\"world\".to_string())\n        ));\n\n        // Booleans\n        assert!(op.execute(&Value::Boolean(true), &Value::Boolean(true)));\n        assert!(!op.execute(&Value::Boolean(true), &Value::Boolean(false)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_neq_576": {
      "name": "test_operator_neq",
      "type": "method",
      "start_line": 576,
      "end_line": 592,
      "content_hash": "c835daae926fedfb5b40a180abfa2c1e061f58f0",
      "content": "    fn test_operator_neq() {\n        let op = Operator::Neq;\n\n        assert!(op.execute(&Value::I32(5), &Value::I32(6)));\n        assert!(!op.execute(&Value::I32(5), &Value::I32(5)));\n\n        assert!(op.execute(\n            &Value::String(\"hello\".to_string()),\n            &Value::String(\"world\".to_string())\n        ));\n        assert!(!op.execute(\n            &Value::String(\"hello\".to_string()),\n            &Value::String(\"hello\".to_string())\n        ));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_lt_593": {
      "name": "test_operator_lt",
      "type": "method",
      "start_line": 593,
      "end_line": 606,
      "content_hash": "98c67a79e26a567937ffa98b79202febed11fdc3",
      "content": "    fn test_operator_lt() {\n        let op = Operator::Lt;\n\n        // Integers\n        assert!(op.execute(&Value::I32(3), &Value::I32(5)));\n        assert!(!op.execute(&Value::I32(5), &Value::I32(3)));\n        assert!(!op.execute(&Value::I32(5), &Value::I32(5))); // Equal is not less than\n\n        // Floats\n        assert!(op.execute(&Value::F64(1.5), &Value::F64(2.5)));\n        assert!(!op.execute(&Value::F64(2.5), &Value::F64(1.5)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_gt_607": {
      "name": "test_operator_gt",
      "type": "method",
      "start_line": 607,
      "end_line": 620,
      "content_hash": "caaaf136e17164a01c41c0411fa8c0b36a34b751",
      "content": "    fn test_operator_gt() {\n        let op = Operator::Gt;\n\n        // Integers\n        assert!(op.execute(&Value::I32(5), &Value::I32(3)));\n        assert!(!op.execute(&Value::I32(3), &Value::I32(5)));\n        assert!(!op.execute(&Value::I32(5), &Value::I32(5))); // Equal is not greater than\n\n        // Floats\n        assert!(op.execute(&Value::F64(2.5), &Value::F64(1.5)));\n        assert!(!op.execute(&Value::F64(1.5), &Value::F64(2.5)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_lte_621": {
      "name": "test_operator_lte",
      "type": "method",
      "start_line": 621,
      "end_line": 632,
      "content_hash": "5320ec1fbc4df85eb9156a36b471b23b42041568",
      "content": "    fn test_operator_lte() {\n        let op = Operator::Lte;\n\n        // Less than\n        assert!(op.execute(&Value::I32(3), &Value::I32(5)));\n        // Equal\n        assert!(op.execute(&Value::I32(5), &Value::I32(5)));\n        // Greater than\n        assert!(!op.execute(&Value::I32(5), &Value::I32(3)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_gte_633": {
      "name": "test_operator_gte",
      "type": "method",
      "start_line": 633,
      "end_line": 644,
      "content_hash": "673b59f5256830e1d183562af567a76c5279374f",
      "content": "    fn test_operator_gte() {\n        let op = Operator::Gte;\n\n        // Greater than\n        assert!(op.execute(&Value::I32(5), &Value::I32(3)));\n        // Equal\n        assert!(op.execute(&Value::I32(5), &Value::I32(5)));\n        // Less than\n        assert!(!op.execute(&Value::I32(3), &Value::I32(5)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_cross_type_numeric_645": {
      "name": "test_operator_cross_type_numeric",
      "type": "method",
      "start_line": 645,
      "end_line": 659,
      "content_hash": "a78e4458c247a20c73001836d7aa2e4f909e85d4",
      "content": "    fn test_operator_cross_type_numeric() {\n        // Value's PartialOrd and PartialEq handle cross-type numeric comparisons\n        let op_eq = Operator::Eq;\n        let op_gt = Operator::Gt;\n\n        // I32 vs F64 - equality works for matching values\n        assert!(op_eq.execute(&Value::I32(42), &Value::F64(42.0)));\n\n        // Different integer sizes work correctly\n        assert!(op_eq.execute(&Value::I32(100), &Value::I64(100)));\n        assert!(op_gt.execute(&Value::U64(1000), &Value::I32(500)));\n        assert!(op_gt.execute(&Value::I64(1000), &Value::I32(500)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_string_comparison_660": {
      "name": "test_operator_string_comparison",
      "type": "method",
      "start_line": 660,
      "end_line": 675,
      "content_hash": "d4a021f38154e851c33507317c581147864f8d46",
      "content": "    fn test_operator_string_comparison() {\n        let op_lt = Operator::Lt;\n        let op_gt = Operator::Gt;\n\n        // Lexicographic ordering\n        assert!(op_lt.execute(\n            &Value::String(\"apple\".to_string()),\n            &Value::String(\"banana\".to_string())\n        ));\n        assert!(op_gt.execute(\n            &Value::String(\"zebra\".to_string()),\n            &Value::String(\"apple\".to_string())\n        ));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_empty_value_676": {
      "name": "test_operator_empty_value",
      "type": "method",
      "start_line": 676,
      "end_line": 687,
      "content_hash": "27dbc0da6d7db539e915a7820389121f4fa9e901",
      "content": "    fn test_operator_empty_value() {\n        let op_eq = Operator::Eq;\n\n        // Empty equals empty\n        assert!(op_eq.execute(&Value::Empty, &Value::Empty));\n\n        // Empty doesn't equal non-empty\n        assert!(!op_eq.execute(&Value::Empty, &Value::I32(0)));\n        assert!(!op_eq.execute(&Value::I32(0), &Value::Empty));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_operator_boolean_values_688": {
      "name": "test_operator_boolean_values",
      "type": "method",
      "start_line": 688,
      "end_line": 696,
      "content_hash": "52094b8a71ee07bb347046917a2532f5ed35d597",
      "content": "    fn test_operator_boolean_values() {\n        let op_eq = Operator::Eq;\n        let op_neq = Operator::Neq;\n\n        assert!(op_eq.execute(&Value::Boolean(true), &Value::Boolean(true)));\n        assert!(op_eq.execute(&Value::Boolean(false), &Value::Boolean(false)));\n        assert!(op_neq.execute(&Value::Boolean(true), &Value::Boolean(false)));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}