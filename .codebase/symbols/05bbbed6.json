{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/hnsw_tests.rs",
  "file_hash": "dee471a3365a73e64e0877cc2e96c84f98550255",
  "updated_at": "2025-12-26T17:34:19.729470",
  "symbols": {
    "function_setup_env_17": {
      "name": "setup_env",
      "type": "function",
      "start_line": 17,
      "end_line": 35,
      "content_hash": "c5b23f4e15395516037cefa696d73c408573976d",
      "content": "fn setup_env() -> (Env, TempDir) {\n    let temp_dir = tempfile::tempdir().unwrap();\n    let path = temp_dir.path();\n\n    let env = unsafe {\n        EnvOpenOptions::new()\n            .map_size(512 * 1024 * 1024)\n            .max_dbs(32)\n            .open(path)\n            .unwrap()\n    };\n    (env, temp_dir)\n}\n\n// ============================================================================\n// HNSWConfig Validation Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_config_defaults_36": {
      "name": "test_hnsw_config_defaults",
      "type": "function",
      "start_line": 36,
      "end_line": 44,
      "content_hash": "3ffedcc42196b5586dc04fc29a538286744f8204",
      "content": "fn test_hnsw_config_defaults() {\n    let config = HNSWConfig::new(None, None, None);\n    assert_eq!(config.m, 16);\n    assert_eq!(config.ef_construct, 128);\n    // ef defaults to 768 but is clamped to max of 512\n    assert_eq!(config.ef, 512);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_config_clamp_below_min_45": {
      "name": "test_hnsw_config_clamp_below_min",
      "type": "function",
      "start_line": 45,
      "end_line": 55,
      "content_hash": "a6984b7ac20183221c961ae9aa640dfbb5638bd1",
      "content": "fn test_hnsw_config_clamp_below_min() {\n    // m < 5 should clamp to 5\n    let config = HNSWConfig::new(Some(1), Some(10), Some(1));\n    assert_eq!(config.m, 5);\n    // ef_construct < 40 should clamp to 40\n    assert_eq!(config.ef_construct, 40);\n    // ef < 10 should clamp to 10\n    assert_eq!(config.ef, 10);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_config_clamp_above_max_56": {
      "name": "test_hnsw_config_clamp_above_max",
      "type": "function",
      "start_line": 56,
      "end_line": 66,
      "content_hash": "76813c6439b4405814fd0d7430b6c9fe4c1909dc",
      "content": "fn test_hnsw_config_clamp_above_max() {\n    // m > 48 should clamp to 48\n    let config = HNSWConfig::new(Some(100), Some(1000), Some(1000));\n    assert_eq!(config.m, 48);\n    // ef_construct > 512 should clamp to 512\n    assert_eq!(config.ef_construct, 512);\n    // ef > 512 should clamp to 512\n    assert_eq!(config.ef, 512);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_config_m_l_calculation_67": {
      "name": "test_hnsw_config_m_l_calculation",
      "type": "function",
      "start_line": 67,
      "end_line": 79,
      "content_hash": "626f1728fe26f77919137be8c3daeeafaba8a4f5",
      "content": "fn test_hnsw_config_m_l_calculation() {\n    let config = HNSWConfig::new(Some(16), None, None);\n    // m_l = 1.0 / ln(m) = 1.0 / ln(16)\n    let expected_m_l = 1.0 / (16.0_f64).ln();\n    assert!((config.m_l - expected_m_l).abs() < f64::EPSILON);\n\n    // Test with a different m value\n    let config = HNSWConfig::new(Some(32), None, None);\n    let expected_m_l = 1.0 / (32.0_f64).ln();\n    assert!((config.m_l - expected_m_l).abs() < f64::EPSILON);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_config_m_max_0_calculation_80": {
      "name": "test_hnsw_config_m_max_0_calculation",
      "type": "function",
      "start_line": 80,
      "end_line": 93,
      "content_hash": "eb571c0eee1f8c79309adc0b1128d04450e61ebc",
      "content": "fn test_hnsw_config_m_max_0_calculation() {\n    let config = HNSWConfig::new(Some(16), None, None);\n    // m_max_0 = 2 * m\n    assert_eq!(config.m_max_0, 32);\n\n    let config = HNSWConfig::new(Some(24), None, None);\n    assert_eq!(config.m_max_0, 48);\n}\n\n// ============================================================================\n// VectorCore Delete Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_delete_existing_vector_94": {
      "name": "test_delete_existing_vector",
      "type": "function",
      "start_line": 94,
      "end_line": 120,
      "content_hash": "f464ed426f20c62cf7d3b9a6cdd4707b3c9d052a",
      "content": "fn test_delete_existing_vector() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let vector: Vec<f64> = vec![0.1, 0.2, 0.3, 0.4];\n    let data = arena.alloc_slice_copy(&vector);\n    let inserted = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n    let inserted_id = inserted.id;\n\n    // Delete the vector\n    let delete_arena = Bump::new();\n    let result = index.delete(&mut txn, inserted_id, &delete_arena);\n    assert!(result.is_ok());\n    txn.commit().unwrap();\n\n    // Verify it's marked as deleted (get_vector_properties returns VectorDeleted error)\n    let read_arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let props_result = index.get_vector_properties(&txn, inserted_id, &read_arena);\n    assert!(matches!(props_result, Err(VectorError::VectorDeleted)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_deleted_vector_excluded_from_search_121": {
      "name": "test_deleted_vector_excluded_from_search",
      "type": "function",
      "start_line": 121,
      "end_line": 162,
      "content_hash": "c937794fa40fe473c664f2f1a31045244f91f9d6",
      "content": "fn test_deleted_vector_excluded_from_search() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let target_vector: Vec<f64> = vec![1.0, 0.0, 0.0, 0.0];\n    let data = arena.alloc_slice_copy(&target_vector);\n    let target = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n\n    // Insert some other vectors\n    for i in 0..5 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n\n    // Delete the target vector\n    let delete_arena = Bump::new();\n    index.delete(&mut txn, target.id, &delete_arena).unwrap();\n    txn.commit().unwrap();\n\n    // Search for the deleted vector's pattern - it should not appear in results\n    let search_arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [1.0, 0.0, 0.0, 0.0];\n    let results = index\n        .search::<Filter>(&txn, &query, 10, \"vector\", None, false, &search_arena)\n        .unwrap();\n\n    // Verify the deleted vector is not in results\n    for result in &results {\n        assert_ne!(result.id, target.id);\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_delete_non_existent_vector_163": {
      "name": "test_delete_non_existent_vector",
      "type": "function",
      "start_line": 163,
      "end_line": 176,
      "content_hash": "98175b0eda42d1665ee3f694ab90db9a03845b89",
      "content": "fn test_delete_non_existent_vector() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    // Try to delete a vector that doesn't exist\n    let fake_id: u128 = 12345678901234567890;\n    let result = index.delete(&mut txn, fake_id, &arena);\n\n    assert!(matches!(result, Err(VectorError::VectorNotFound(_))));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_delete_already_deleted_vector_177": {
      "name": "test_delete_already_deleted_vector",
      "type": "function",
      "start_line": 177,
      "end_line": 209,
      "content_hash": "865ec272366a7143ff1465bca6853d974f35ad18",
      "content": "fn test_delete_already_deleted_vector() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let vector: Vec<f64> = vec![0.1, 0.2, 0.3, 0.4];\n    let data = arena.alloc_slice_copy(&vector);\n    let inserted = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n    let inserted_id = inserted.id;\n\n    // Delete once - should succeed\n    let delete_arena = Bump::new();\n    index.delete(&mut txn, inserted_id, &delete_arena).unwrap();\n\n    // Delete again - should fail with VectorDeleted\n    // Note: get_vector_properties returns VectorDeleted for deleted vectors,\n    // which gets propagated before the VectorAlreadyDeleted check\n    let delete_arena2 = Bump::new();\n    let result = index.delete(&mut txn, inserted_id, &delete_arena2);\n    assert!(matches!(result, Err(VectorError::VectorDeleted)));\n\n    // Commit transaction to ensure proper cleanup\n    txn.commit().unwrap();\n}\n\n// ============================================================================\n// VectorCore Retrieval Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_vector_properties_existing_210": {
      "name": "test_get_vector_properties_existing",
      "type": "function",
      "start_line": 210,
      "end_line": 233,
      "content_hash": "3f8c67557ce2a6ba709ed841d974bca2b47fa260",
      "content": "fn test_get_vector_properties_existing() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let vector: Vec<f64> = vec![0.1, 0.2, 0.3, 0.4];\n    let data = arena.alloc_slice_copy(&vector);\n    let inserted = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n    txn.commit().unwrap();\n\n    let txn = env.read_txn().unwrap();\n    let props = index\n        .get_vector_properties(&txn, inserted.id, &arena)\n        .unwrap();\n    assert!(props.is_some());\n    let props = props.unwrap();\n    assert_eq!(props.id, inserted.id);\n    assert!(!props.deleted);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_vector_properties_deleted_234": {
      "name": "test_get_vector_properties_deleted",
      "type": "function",
      "start_line": 234,
      "end_line": 256,
      "content_hash": "a728f14dc87eb5ec28b6646984b7edfaabf2e398",
      "content": "fn test_get_vector_properties_deleted() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let vector: Vec<f64> = vec![0.1, 0.2, 0.3, 0.4];\n    let data = arena.alloc_slice_copy(&vector);\n    let inserted = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n\n    // Delete the vector\n    index.delete(&mut txn, inserted.id, &arena).unwrap();\n    txn.commit().unwrap();\n\n    // Getting properties of deleted vector should return error\n    let txn = env.read_txn().unwrap();\n    let result = index.get_vector_properties(&txn, inserted.id, &arena);\n    assert!(matches!(result, Err(VectorError::VectorDeleted)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_full_vector_existing_257": {
      "name": "test_get_full_vector_existing",
      "type": "function",
      "start_line": 257,
      "end_line": 278,
      "content_hash": "90d29d509a67490a32baee16d04c6ab70048b965",
      "content": "fn test_get_full_vector_existing() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let arena = Bump::new();\n    let vector: Vec<f64> = vec![0.1, 0.2, 0.3, 0.4];\n    let data = arena.alloc_slice_copy(&vector);\n    let inserted = index\n        .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n        .unwrap();\n    txn.commit().unwrap();\n\n    let txn = env.read_txn().unwrap();\n    let full_vector = index.get_full_vector(&txn, inserted.id, &arena).unwrap();\n    assert_eq!(full_vector.id, inserted.id);\n    assert!(!full_vector.deleted);\n    // Verify vector data matches\n    assert_eq!(full_vector.data.len(), 4);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_full_vector_non_existent_279": {
      "name": "test_get_full_vector_non_existent",
      "type": "function",
      "start_line": 279,
      "end_line": 292,
      "content_hash": "6e0f8981d693bb0dfbc3ef40b5a2bbf5e0111873",
      "content": "fn test_get_full_vector_non_existent() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let fake_id: u128 = 12345678901234567890;\n    let result = index.get_full_vector(&txn, fake_id, &arena);\n    assert!(matches!(result, Err(VectorError::VectorNotFound(_))));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_get_all_vectors_with_level_filter_293": {
      "name": "test_get_all_vectors_with_level_filter",
      "type": "function",
      "start_line": 293,
      "end_line": 325,
      "content_hash": "f66c0d6c5018401fce4e46cb02566f371e7f96a3",
      "content": "fn test_get_all_vectors_with_level_filter() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    // Insert multiple vectors\n    for i in 0..10 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n\n    // Get all vectors without level filter\n    let all_vectors = index.get_all_vectors(&txn, None, &arena).unwrap();\n    assert_eq!(all_vectors.len(), 10);\n\n    // Get vectors at level 0 (all vectors are stored at level 0)\n    let level_0_vectors = index.get_all_vectors(&txn, Some(0), &arena).unwrap();\n    assert_eq!(level_0_vectors.len(), 10);\n}\n\n// ============================================================================\n// Search Edge Case Tests\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_k_zero_326": {
      "name": "test_search_k_zero",
      "type": "function",
      "start_line": 326,
      "end_line": 353,
      "content_hash": "c80c621168ae54dd1532d0106ae655e1c6976043",
      "content": "fn test_search_k_zero() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    // Insert some vectors\n    for i in 0..5 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Search with k=0 should return empty results\n    let results = index\n        .search::<Filter>(&txn, &query, 0, \"vector\", None, false, &arena)\n        .unwrap();\n    assert!(results.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_k_exceeds_total_354": {
      "name": "test_search_k_exceeds_total",
      "type": "function",
      "start_line": 354,
      "end_line": 382,
      "content_hash": "ac8445d6e176d1e2cf9490fa308659c0a56cac04",
      "content": "fn test_search_k_exceeds_total() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    // Insert exactly 5 vectors\n    for i in 0..5 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Search with k=100, more than total vectors\n    let results = index\n        .search::<Filter>(&txn, &query, 100, \"vector\", None, false, &arena)\n        .unwrap();\n    // Should return at most 5 (all available vectors)\n    assert!(results.len() <= 5);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_empty_index_383": {
      "name": "test_search_empty_index",
      "type": "function",
      "start_line": 383,
      "end_line": 398,
      "content_hash": "d7e245871335f4d903eb2c5d0a90d598dbd96edf",
      "content": "fn test_search_empty_index() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Search on empty index should return EntryPointNotFound error\n    let result = index.search::<Filter>(&txn, &query, 5, \"vector\", None, false, &arena);\n    assert!(matches!(result, Err(VectorError::EntryPointNotFound)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_after_deletions_399": {
      "name": "test_search_after_deletions",
      "type": "function",
      "start_line": 399,
      "end_line": 444,
      "content_hash": "005ef80764d2918914b042711deddbe4b7690a3e",
      "content": "fn test_search_after_deletions() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let mut inserted_ids = Vec::new();\n\n    // Insert 10 vectors\n    for i in 0..10 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let inserted = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n        inserted_ids.push(inserted.id);\n    }\n\n    // Delete first 5 vectors\n    for i in 0..5 {\n        let arena = Bump::new();\n        index.delete(&mut txn, inserted_ids[i], &arena).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Search should only return non-deleted vectors\n    let results = index\n        .search::<Filter>(&txn, &query, 10, \"vector\", None, false, &arena)\n        .unwrap();\n\n    // Should only find up to 5 vectors (the non-deleted ones)\n    assert!(results.len() <= 5);\n\n    // Verify none of the deleted vectors appear in results\n    for result in &results {\n        for i in 0..5 {\n            assert_ne!(result.id, inserted_ids[i]);\n        }\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_with_filter_predicate_445": {
      "name": "test_search_with_filter_predicate",
      "type": "function",
      "start_line": 445,
      "end_line": 480,
      "content_hash": "8d267927e96f6fc41d9105afe89a478470b893cf",
      "content": "fn test_search_with_filter_predicate() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    // Insert vectors\n    for i in 0..10 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Filter that always returns false - should find no results\n    let filter: &[fn(&HVector, &RoTxn) -> bool] = &[|_, _| false];\n    let results = index\n        .search(&txn, &query, 10, \"vector\", Some(filter), false, &arena)\n        .unwrap();\n    assert!(results.is_empty());\n\n    // Filter that always returns true - should find results\n    let filter: &[fn(&HVector, &RoTxn) -> bool] = &[|_, _| true];\n    let results = index\n        .search(&txn, &query, 10, \"vector\", Some(filter), false, &arena)\n        .unwrap();\n    assert!(!results.is_empty());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_search_label_filtering_481": {
      "name": "test_search_label_filtering",
      "type": "function",
      "start_line": 481,
      "end_line": 534,
      "content_hash": "43e0f961dd97e70be0e0f811bd7eb84b6bd432a6",
      "content": "fn test_search_label_filtering() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    // Insert vectors with label \"vector_a\"\n    for i in 0..5 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector_a\", data, None, &arena)\n            .unwrap();\n    }\n\n    // Insert vectors with label \"vector_b\"\n    for i in 0..5 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = vec![0.5 + 0.1 * i as f64, 0.2, 0.3, 0.4];\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector_b\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n\n    // Search for label \"vector_a\"\n    let results = index\n        .search::<Filter>(&txn, &query, 10, \"vector_a\", None, false, &arena)\n        .unwrap();\n    // All results should have label \"vector_a\"\n    for result in &results {\n        assert_eq!(result.label, \"vector_a\");\n    }\n\n    // Search for label \"vector_b\"\n    let results = index\n        .search::<Filter>(&txn, &query, 10, \"vector_b\", None, false, &arena)\n        .unwrap();\n    // All results should have label \"vector_b\"\n    for result in &results {\n        assert_eq!(result.label, \"vector_b\");\n    }\n}\n\n// ============================================================================\n// Original Tests (kept for backwards compatibility)\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_insert_and_count_535": {
      "name": "test_hnsw_insert_and_count",
      "type": "function",
      "start_line": 535,
      "end_line": 554,
      "content_hash": "4cd2a8bb4febc1daba11139fa02de466b3295af3",
      "content": "fn test_hnsw_insert_and_count() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let vector: Vec<f64> = (0..4).map(|_| rand::rng().random_range(0.0..1.0)).collect();\n    for _ in 0..10 {\n        let arena = Bump::new();\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n\n    txn.commit().unwrap();\n    let txn = env.read_txn().unwrap();\n    assert!(index.num_inserted_vectors(&txn).unwrap() >= 10);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_hnsw_search_returns_results_555": {
      "name": "test_hnsw_search_returns_results",
      "type": "function",
      "start_line": 555,
      "end_line": 578,
      "content_hash": "2acabbc791148e8ba0b155b7e0532c29a9400c1e",
      "content": "fn test_hnsw_search_returns_results() {\n    let (env, _temp_dir) = setup_env();\n    let mut txn = env.write_txn().unwrap();\n    let index = VectorCore::new(&env, &mut txn, HNSWConfig::new(None, None, None)).unwrap();\n\n    let mut rng = rand::rng();\n    for _ in 0..128 {\n        let arena = Bump::new();\n        let vector: Vec<f64> = (0..4).map(|_| rng.random_range(0.0..1.0)).collect();\n        let data = arena.alloc_slice_copy(&vector);\n        let _ = index\n            .insert::<Filter>(&mut txn, \"vector\", data, None, &arena)\n            .unwrap();\n    }\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = env.read_txn().unwrap();\n    let query = [0.5, 0.5, 0.5, 0.5];\n    let results = index\n        .search::<Filter>(&txn, &query, 5, \"vector\", None, false, &arena)\n        .unwrap();\n    assert!(!results.is_empty());\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}