{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/query_validation.rs",
  "file_hash": "88ac713ba852e166367a992797065e62cca0cbf5",
  "updated_at": "2025-12-26T17:34:25.066667",
  "symbols": {
    "function_capitalize_first_30": {
      "name": "capitalize_first",
      "type": "function",
      "start_line": 30,
      "end_line": 39,
      "content_hash": "82d999fc54f29cfa52944909675f7e6c37e46cad",
      "content": "fn capitalize_first(s: &str) -> String {\n    let mut chars = s.chars();\n    match chars.next() {\n        None => String::new(),\n        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),\n    }\n}\n\n/// Build unified field list for return types\n/// This handles all cases: simple schema, projections, spread, nested traversals",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_build_return_fields_40": {
      "name": "build_return_fields",
      "type": "function",
      "start_line": 40,
      "end_line": 558,
      "content_hash": "864bcb83bfed2ddfb2c8e40e3948c90814df867c",
      "content": "fn build_return_fields(\n    ctx: &Ctx,\n    inferred_type: &Type,\n    traversal: &GeneratedTraversal,\n    struct_name_prefix: &str,\n) -> Vec<ReturnFieldInfo> {\n    let mut fields = Vec::new();\n\n    // Handle aggregate types specially\n    if let Type::Aggregate(info) = inferred_type {\n        // All aggregates have a key field (the grouping key from HashMap)\n        fields.push(ReturnFieldInfo::new_implicit(\n            \"key\".to_string(),\n            \"String\".to_string(),\n        ));\n\n        // Add fields for each grouped property\n        // We need to get the source type's schema to determine property types\n        let (_schema_fields, _item_type) = match info.source_type.as_ref() {\n            Type::Node(Some(label)) | Type::Nodes(Some(label)) => {\n                (ctx.node_fields.get(label.as_str()), \"node\")\n            }\n            Type::Edge(Some(label)) | Type::Edges(Some(label)) => {\n                (ctx.edge_fields.get(label.as_str()), \"edge\")\n            }\n            Type::Vector(Some(label)) | Type::Vectors(Some(label)) => {\n                (ctx.vector_fields.get(label.as_str()), \"vector\")\n            }\n            _ => (None, \"unknown\"),\n        };\n\n        // Add each grouped property as a field\n        for prop_name in &info.properties {\n            fields.push(ReturnFieldInfo::new_schema(\n                prop_name.clone(),\n                \"Option<&'a Value>\".to_string(),\n            ));\n        }\n\n        // Add count field\n        fields.push(ReturnFieldInfo::new_implicit(\n            \"count\".to_string(),\n            \"i32\".to_string(),\n        ));\n\n        // For non-COUNT aggregates, add items field with nested struct\n        if !info.is_count {\n            // Build nested struct for the items\n            let items_struct_name = format!(\"{}Items\", struct_name_prefix);\n            // Recursively build fields for the source type\n            let item_fields = build_return_fields(\n                ctx,\n                info.source_type.as_ref(),\n                traversal,\n                &items_struct_name,\n            );\n\n            // Create field with proper nested_struct_name to avoid conflicts\n            fields.push(ReturnFieldInfo {\n                name: \"items\".to_string(),\n                field_type: ReturnFieldType::Nested(item_fields),\n                source: ReturnFieldSource::NestedTraversal {\n                    traversal_expr: String::new(),\n                    traversal_code: None,\n                    nested_struct_name: Some(format!(\"{}ReturnType\", items_struct_name)),\n                    traversal_type: None,\n                    closure_param_name: None,\n                    closure_source_var: None,\n                    accessed_field_name: None,\n                    own_closure_param: None,\n                },\n            });\n        }\n\n        return fields;\n    }\n\n    // Get schema type name if this is a schema type\n    let schema_type = match inferred_type {\n        Type::Node(Some(label)) | Type::Nodes(Some(label)) => Some((label.as_str(), \"node\")),\n        Type::Edge(Some(label)) | Type::Edges(Some(label)) => Some((label.as_str(), \"edge\")),\n        Type::Vector(Some(label)) | Type::Vectors(Some(label)) => Some((label.as_str(), \"vector\")),\n        _ => None,\n    };\n\n    // Step 1: Add implicit fields if this is a schema type\n    if let Some((label, item_type)) = schema_type {\n        // If has_object_step, only add implicit fields if they're explicitly selected\n        // Otherwise, add all implicit fields (default behavior)\n        let should_add_field = |field_name: &str| {\n            // Exclude if field is in excluded_fields\n            if traversal.excluded_fields.contains(&field_name.to_string()) {\n                return false;\n            }\n            // If has object step, only include if explicitly selected\n            !traversal.has_object_step || traversal.object_fields.contains(&field_name.to_string())\n        };\n\n        // Add id and label if no object step OR if explicitly selected\n        if should_add_field(\"id\") {\n            fields.push(ReturnFieldInfo::new_implicit(\n                \"id\".to_string(),\n                \"&'a str\".to_string(),\n            ));\n        }\n        if should_add_field(\"label\") {\n            fields.push(ReturnFieldInfo::new_implicit(\n                \"label\".to_string(),\n                \"&'a str\".to_string(),\n            ));\n        }\n\n        // Add type-specific implicit fields\n        if item_type == \"edge\" {\n            if should_add_field(\"from_node\") {\n                fields.push(ReturnFieldInfo::new_implicit(\n                    \"from_node\".to_string(),\n                    \"&'a str\".to_string(),\n                ));\n            }\n            if should_add_field(\"to_node\") {\n                fields.push(ReturnFieldInfo::new_implicit(\n                    \"to_node\".to_string(),\n                    \"&'a str\".to_string(),\n                ));\n            }\n        } else if item_type == \"vector\" {\n            if should_add_field(\"data\") {\n                fields.push(ReturnFieldInfo::new_implicit(\n                    \"data\".to_string(),\n                    \"&'a [f64]\".to_string(),\n                ));\n            }\n            if should_add_field(\"score\") {\n                fields.push(ReturnFieldInfo::new_implicit(\n                    \"score\".to_string(),\n                    \"f64\".to_string(),\n                ));\n            }\n        }\n\n        // Step 2: Add schema fields based on projection mode\n        let schema_fields = match item_type {\n            \"node\" => ctx.node_fields.get(label),\n            \"edge\" => ctx.edge_fields.get(label),\n            \"vector\" => ctx.vector_fields.get(label),\n            _ => None,\n        };\n\n        if let Some(schema_fields) = schema_fields {\n            if traversal.has_object_step {\n                // Projection mode - only include selected fields\n                for field_name in &traversal.object_fields {\n                    // Skip if it's a nested traversal (handled separately)\n                    if traversal.nested_traversals.contains_key(field_name) {\n                        continue;\n                    }\n\n                    // Skip implicit fields (already added)\n                    if field_name == \"id\"\n                        || field_name == \"label\"\n                        || field_name == \"from_node\"\n                        || field_name == \"to_node\"\n                        || field_name == \"data\"\n                        || field_name == \"score\"\n                    {\n                        continue;\n                    }\n\n                    if let Some(_field) = schema_fields.get(field_name.as_str()) {\n                        fields.push(ReturnFieldInfo::new_schema(\n                            field_name.clone(),\n                            \"Option<&'a Value>\".to_string(),\n                        ));\n                    }\n                }\n\n                // If has_spread, add all remaining schema fields\n                if traversal.has_spread {\n                    for (field_name, _field) in schema_fields.iter() {\n                        // Skip if already added\n                        let already_exists = fields.iter().any(|f| f.name == *field_name);\n                        if already_exists {\n                            continue;\n                        }\n                        // Skip if excluded\n                        if traversal.excluded_fields.contains(&field_name.to_string()) {\n                            continue;\n                        }\n\n                        // Check if this is an implicit field - if so, use the correct type\n                        let is_implicit_field = matches!(\n                            *field_name,\n                            \"id\" | \"label\" | \"from_node\" | \"to_node\" | \"data\" | \"score\"\n                        );\n\n                        if is_implicit_field {\n                            let rust_type = match *field_name {\n                                \"data\" => \"&'a [f64]\".to_string(),\n                                \"score\" => \"f64\".to_string(),\n                                _ => \"&'a str\".to_string(),\n                            };\n                            fields.push(ReturnFieldInfo::new_implicit(\n                                field_name.to_string(),\n                                rust_type,\n                            ));\n                        } else {\n                            fields.push(ReturnFieldInfo::new_schema(\n                                field_name.to_string(),\n                                \"Option<&'a Value>\".to_string(),\n                            ));\n                        }\n                    }\n                }\n            } else {\n                // No projection - include all schema fields except excluded ones\n                for (field_name, _field) in schema_fields.iter() {\n                    // Skip implicit fields (already added)\n                    if *field_name == \"id\"\n                        || *field_name == \"label\"\n                        || *field_name == \"from_node\"\n                        || *field_name == \"to_node\"\n                        || *field_name == \"data\"\n                        || *field_name == \"score\"\n                    {\n                        continue;\n                    }\n                    // Skip if excluded\n                    if traversal.excluded_fields.contains(&field_name.to_string()) {\n                        continue;\n                    }\n                    fields.push(ReturnFieldInfo::new_schema(\n                        field_name.to_string(),\n                        \"Option<&'a Value>\".to_string(),\n                    ));\n                }\n            }\n        }\n    }\n\n    // Step 3: Add nested traversals\n    for (field_name, nested_info) in &traversal.nested_traversals {\n        // For nested traversals, extract the return type and build nested fields\n        if let Some(ref return_type) = nested_info.return_type {\n            // Check if this is a scalar type or needs a struct\n            match return_type {\n                Type::Scalar(_scalar_ty) => {\n                    // Check if the traversal is accessing an implicit field\n                    // For nested traversals like usr::ID, we need to check what field is actually accessed\n                    let accessed_field = nested_info.traversal.object_fields.first(); // Get the first (and usually only) field being accessed\n                    let is_implicit = accessed_field\n                        .map(|f| {\n                            matches!(\n                                f.as_str(),\n                                \"id\" | \"label\"\n                                    | \"from_node\"\n                                    | \"to_node\"\n                                    | \"data\"\n                                    | \"score\"\n                                    | \"ID\"\n                                    | \"Label\" // Also check capitalized versions\n                            )\n                        })\n                        .unwrap_or(!nested_info.traversal.has_object_step);\n\n                    let rust_type = if is_implicit {\n                        // Use the appropriate type based on the implicit field\n                        match accessed_field.map(|s| s.as_str()) {\n                            Some(\"data\") => \"&'a [f64]\".to_string(),\n                            Some(\"score\") => \"f64\".to_string(),\n                            Some(\"id\") | Some(\"ID\") | Some(\"label\") | Some(\"Label\")\n                            | Some(\"from_node\") | Some(\"to_node\") | None => \"&'a str\".to_string(),\n                            _ => \"Option<&'a Value>\".to_string(),\n                        }\n                    } else {\n                        \"Option<&'a Value>\".to_string()\n                    };\n\n                    let trav_code = nested_info.traversal.format_steps_only();\n                    // Extract the accessed field name from object_fields\n                    let accessed_field_name = nested_info.traversal.object_fields.first().cloned();\n                    fields.push(ReturnFieldInfo {\n                        name: field_name.clone(),\n                        field_type: ReturnFieldType::Simple(rust_type),\n                        source: ReturnFieldSource::NestedTraversal {\n                            traversal_expr: format!(\"nested_traversal_{}\", field_name),\n                            traversal_code: Some(trav_code),\n                            nested_struct_name: None,\n                            traversal_type: Some(nested_info.traversal.traversal_type.clone()),\n                            closure_param_name: nested_info.closure_param_name.clone(),\n                            closure_source_var: nested_info.closure_source_var.clone(),\n                            accessed_field_name,\n                            own_closure_param: nested_info.own_closure_param.clone(),\n                        },\n                    });\n                }\n                Type::Node(_)\n                | Type::Edge(_)\n                | Type::Vector(_)\n                | Type::Nodes(_)\n                | Type::Edges(_)\n                | Type::Vectors(_) => {\n                    // Complex types need nested structs\n                    let nested_prefix =\n                        format!(\"{}{}\", struct_name_prefix, capitalize_first(field_name));\n                    let nested_fields = build_return_fields(\n                        ctx,\n                        return_type,\n                        &nested_info.traversal,\n                        &nested_prefix,\n                    );\n                    let nested_struct_name = format!(\"{}ReturnType\", nested_prefix);\n\n                    fields.push(ReturnFieldInfo {\n                        name: field_name.clone(),\n                        field_type: ReturnFieldType::Nested(nested_fields),\n                        source: ReturnFieldSource::NestedTraversal {\n                            traversal_expr: format!(\"nested_traversal_{}\", field_name),\n                            traversal_code: Some(nested_info.traversal.format_steps_only()),\n                            nested_struct_name: Some(nested_struct_name),\n                            traversal_type: Some(nested_info.traversal.traversal_type.clone()),\n                            closure_param_name: nested_info.closure_param_name.clone(),\n                            closure_source_var: nested_info.closure_source_var.clone(),\n                            accessed_field_name: None,\n                            own_closure_param: nested_info.own_closure_param.clone(),\n                        },\n                    });\n                }\n                _ => {\n                    // Other types - use placeholder\n                    fields.push(ReturnFieldInfo {\n                        name: field_name.clone(),\n                        field_type: ReturnFieldType::Simple(\"Value\".to_string()),\n                        source: ReturnFieldSource::NestedTraversal {\n                            traversal_expr: format!(\"nested_traversal_{}\", field_name),\n                            traversal_code: Some(nested_info.traversal.format_steps_only()),\n                            nested_struct_name: None,\n                            traversal_type: Some(nested_info.traversal.traversal_type.clone()),\n                            closure_param_name: nested_info.closure_param_name.clone(),\n                            closure_source_var: nested_info.closure_source_var.clone(),\n                            accessed_field_name: None,\n                            own_closure_param: nested_info.own_closure_param.clone(),\n                        },\n                    });\n                }\n            }\n        } else {\n            // Type not yet determined - create placeholder\n            // This will be filled in during a later pass\n            fields.push(ReturnFieldInfo {\n                name: field_name.clone(),\n                field_type: ReturnFieldType::Simple(\"Value\".to_string()),\n                source: ReturnFieldSource::NestedTraversal {\n                    traversal_expr: format!(\"nested_traversal_{}\", field_name),\n                    traversal_code: None,\n                    nested_struct_name: None,\n                    traversal_type: None,\n                    closure_param_name: None,\n                    closure_source_var: None,\n                    accessed_field_name: None,\n                    own_closure_param: None,\n                },\n            });\n        }\n    }\n\n    fields\n}\n\n/// Process object literal return types and create struct definitions\n/// This handles RETURN { field1: expr1, field2: { ... }, field3: [...] } syntax\n///\n/// Note: This is a simplified implementation that delegates to analyze_return_expr for each field\nfn process_object_literal<'a>(\n    ctx: &mut Ctx<'a>,\n    _original_query: &'a Query,\n    scope: &mut HashMap<&'a str, VariableInfo>,\n    query: &mut GeneratedQuery,\n    object_fields: &HashMap<String, ReturnType>,\n    _struct_name: String,\n) -> ReturnValueStruct {\n    // Build JSON construction code recursively\n    fn build_json_code<'a>(\n        ctx: &Ctx<'a>,\n        obj_fields: &HashMap<String, ReturnType>,\n        scope: &HashMap<&str, VariableInfo>,\n    ) -> String {\n        let mut json_parts = Vec::new();\n\n        for (field_name, return_type) in obj_fields {\n            let field_value = match return_type {\n                ReturnType::Expression(expr) => {\n                    match &expr.expr {\n                        ExpressionType::Traversal(trav) => {\n                            // Handle traversal like app::{name}\n                            // Extract variable name from start node\n                            let var_name = match &trav.start {\n                                crate::helixc::parser::types::StartNode::Identifier(id) => id.clone(),\n                                _ => \"unknown\".to_string(),\n                            };\n\n                            // Check if there's an Object step to extract property name\n                            if let Some(step) = trav.steps.first() {\n                                if let crate::helixc::parser::types::StepType::Object(obj) = &step.step {\n                                    // Extract the first field name from the object step\n                                    if let Some(field) = obj.fields.first() {\n                                        let prop_name = &field.key;\n\n                                        // Generate appropriate access code based on property\n                                        if prop_name == \"id\" {\n                                            format!(\"uuid_str({}.id(), &arena)\", var_name)\n                                        } else if prop_name == \"label\" {\n                                            format!(\"{}.label()\", var_name)\n                                        } else {\n                                            format!(\"{}.get_property(\\\"{}\\\")\", var_name, prop_name)\n                                        }\n                                    } else {\n                                        // No fields in object step\n                                        format!(\"json!({})\", var_name)\n                                    }\n                                } else {\n                                    // Not an Object step, just return the variable\n                                    format!(\"json!({})\", var_name)\n                                }\n                            } else {\n                                // No steps, just the identifier\n                                format!(\"json!({})\", var_name)\n                            }\n                        }\n                        ExpressionType::Identifier(id) => {\n                            // Look up the variable type in scope and generate property extraction\n                            if let Some(var_info) = scope.get(id.as_str()) {\n                                build_identifier_json(ctx, id, &var_info.ty)\n                            } else {\n                                // Fallback if not in scope\n                                format!(\"json!({})\", id)\n                            }\n                        }\n                        _ => {\n                            \"serde_json::Value::Null\".to_string()\n                        }\n                    }\n                }\n                ReturnType::Object(nested_obj) => {\n                    // Recursively build nested object\n                    let nested_json = build_json_code(ctx, nested_obj, scope);\n                    format!(\"json!({})\", nested_json)\n                }\n                ReturnType::Array(arr) => {\n                    // Build array\n                    let mut array_parts = Vec::new();\n                    for elem in arr {\n                        match elem {\n                            ReturnType::Expression(expr) => {\n                                match &expr.expr {\n                                    ExpressionType::Identifier(id) => {\n                                        // Look up the variable type and generate property extraction\n                                        if let Some(var_info) = scope.get(id.as_str()) {\n                                            array_parts.push(build_identifier_json(ctx, id, &var_info.ty));\n                                        } else {\n                                            // Fallback\n                                            array_parts.push(format!(\"json!({})\", id));\n                                        }\n                                    }\n                                    ExpressionType::Traversal(trav) => {\n                                        // Handle traversal in array\n                                        let var_name = match &trav.start {\n                                            crate::helixc::parser::types::StartNode::Identifier(id) => id.clone(),\n                                            _ => \"unknown\".to_string(),\n                                        };\n\n                                        // Check for object step\n                                        if let Some(step) = trav.steps.first() {\n                                            if let crate::helixc::parser::types::StepType::Object(obj) = &step.step {\n                                                if let Some(field) = obj.fields.first() {\n                                                    let prop_name = &field.key;\n                                                    if prop_name == \"id\" {\n                                                        array_parts.push(format!(\"uuid_str({}.id(), &arena)\", var_name));\n                                                    } else if prop_name == \"label\" {\n                                                        array_parts.push(format!(\"{}.label()\", var_name));\n                                                    } else {\n                                                        array_parts.push(format!(\"{}.get_property(\\\"{}\\\")\", var_name, prop_name));\n                                                    }\n                                                } else {\n                                                    array_parts.push(format!(\"json!({})\", var_name));\n                                                }\n                                            } else {\n                                                array_parts.push(format!(\"json!({})\", var_name));\n                                            }\n                                        } else {\n                                            array_parts.push(format!(\"json!({})\", var_name));\n                                        }\n                                    }\n                                    _ => {\n                                        array_parts.push(\"serde_json::Value::Null\".to_string());\n                                    }\n                                }\n                            }\n                            ReturnType::Object(obj) => {\n                                let nested_json = build_json_code(ctx, obj, scope);\n                                array_parts.push(format!(\"json!({})\", nested_json));\n                            }\n                            _ => {\n                                array_parts.push(\"serde_json::Value::Null\".to_string());\n                            }\n                        }\n                    }\n                    format!(\"json!([{}])\", array_parts.join(\", \"))\n                }\n                ReturnType::Empty => \"serde_json::Value::Null\".to_string(),\n            };\n\n            json_parts.push(format!(\"\\\"{}\\\": {}\", field_name, field_value));\n        }\n\n        format!(\"{{\\n        {}\\n    }}\", json_parts.join(\",\\n        \"))\n    }\n\n    // Helper function to build JSON for an identifier based on its type",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_build_identifier_json_559": {
      "name": "build_identifier_json",
      "type": "function",
      "start_line": 559,
      "end_line": 643,
      "content_hash": "95655684a2a32b25af03cf42e18ca21458e46c67",
      "content": "    fn build_identifier_json(ctx: &Ctx, var_name: &str, ty: &Type) -> String {\n        match ty {\n            Type::Node(Some(label)) => {\n                // Look up the node schema to get its properties\n                if let Some(node_fields) = ctx.node_fields.get(label.as_str()) {\n                    let mut props = vec![\n                        format!(\"\\\"id\\\": uuid_str({}.id(), &arena)\", var_name),\n                        format!(\"\\\"label\\\": {}.label()\", var_name),\n                    ];\n\n                    for (prop_name, _prop_type) in node_fields.iter() {\n                        // Skip implicit fields that are accessed via methods, not get_property\n                        if *prop_name == \"id\" || *prop_name == \"label\" {\n                            continue;\n                        }\n                        props.push(format!(\"\\\"{}\\\":  {}.get_property(\\\"{}\\\")\", prop_name, var_name, prop_name));\n                    }\n\n                    format!(\"json!({{\\n        {}\\n    }})\", props.join(\",\\n        \"))\n                } else {\n                    // Fallback if schema not found\n                    format!(\"json!({{\\\"id\\\": uuid_str({}.id(), &arena), \\\"label\\\": {}.label()}})\", var_name, var_name)\n                }\n            }\n            Type::Edge(Some(label)) => {\n                // Similar for edges\n                if let Some(edge_fields) = ctx.edge_fields.get(label.as_str()) {\n                    let mut props = vec![\n                        format!(\"\\\"id\\\": uuid_str({}.id(), &arena)\", var_name),\n                        format!(\"\\\"label\\\": {}.label()\", var_name),\n                    ];\n\n                    for (prop_name, _prop_type) in edge_fields.iter() {\n                        // Skip implicit fields\n                        if *prop_name == \"id\" || *prop_name == \"label\" {\n                            continue;\n                        }\n                        props.push(format!(\"\\\"{}\\\":  {}.get_property(\\\"{}\\\")\", prop_name, var_name, prop_name));\n                    }\n\n                    format!(\"json!({{\\n        {}\\n    }})\", props.join(\",\\n        \"))\n                } else {\n                    format!(\"json!({{\\\"id\\\": uuid_str({}.id(), &arena), \\\"label\\\": {}.label()}})\", var_name, var_name)\n                }\n            }\n            _ => {\n                // For other types (Node(None), Edge(None), primitives, etc), just use json! macro\n                format!(\"json!({})\", var_name)\n            }\n        }\n    }\n\n    let json_code = build_json_code(ctx, object_fields, scope);\n\n    // Add a single return value with the literal JSON construction code\n    query.return_values.push((\n        \"response\".to_string(),\n        ReturnValue {\n            name: \"serde_json::Value\".to_string(),\n            fields: vec![],\n            literal_value: Some(crate::helixc::generator::utils::GenRef::Std(format!(\"json!({})\", json_code))),\n        },\n    ));\n\n    // Mark to NOT use struct returns\n    query.use_struct_returns = false;\n\n    // Return a placeholder struct (won't be used)\n    ReturnValueStruct {\n        name: \"Unused\".to_string(),\n        fields: vec![],\n        has_lifetime: false,\n        is_query_return_type: false,\n        is_collection: false,\n        is_aggregate: false,\n        is_group_by: false,\n        source_variable: String::new(),\n        is_reused_variable: false,\n        field_infos: vec![],\n        aggregate_properties: Vec::new(),\n        is_count_aggregate: false,\n    }\n}\n\n/// Helper function to get Rust type string from analyzer Type and populate return value fields",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_type_to_rust_string_and_fields_644": {
      "name": "type_to_rust_string_and_fields",
      "type": "function",
      "start_line": 644,
      "end_line": 1262,
      "content_hash": "b1f059271d36e64d7785e0823a3d53b4e13bdee6",
      "content": "fn type_to_rust_string_and_fields(\n    ty: &Type,\n    should_collect: &ShouldCollect,\n    ctx: &Ctx,\n    _field_name: &str,\n) -> (\n    String,\n    Vec<crate::helixc::generator::return_values::ReturnValueField>,\n) {\n    match (ty, should_collect) {\n        // For single nodes/vectors/edges, generate a proper struct based on schema\n        (Type::Node(Some(label)), ShouldCollect::ToObj | ShouldCollect::No) => {\n            let type_name = format!(\"{}ReturnType\", label);\n            let mut fields = vec![\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"id\".to_string(),\n                    \"ID\".to_string(),\n                )\n                .with_implicit(true),\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"label\".to_string(),\n                    \"String\".to_string(),\n                )\n                .with_implicit(true),\n            ];\n\n            // Add properties from schema (skip id and label as they're already added)\n            if let Some(node_fields) = ctx.node_fields.get(label.as_str()) {\n                for (prop_name, field) in node_fields {\n                    if *prop_name != \"id\" && *prop_name != \"label\" {\n                        fields.push(\n                            crate::helixc::generator::return_values::ReturnValueField::new(\n                                prop_name.to_string(),\n                                format!(\"{}\", field.field_type),\n                            ),\n                        );\n                    }\n                }\n            }\n            (type_name, fields)\n        }\n        (Type::Edge(Some(label)), ShouldCollect::ToObj | ShouldCollect::No) => {\n            let type_name = format!(\"{}ReturnType\", label);\n            let mut fields = vec![\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"id\".to_string(),\n                    \"ID\".to_string(),\n                )\n                .with_implicit(true),\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"label\".to_string(),\n                    \"String\".to_string(),\n                )\n                .with_implicit(true),\n            ];\n\n            if let Some(edge_fields) = ctx.edge_fields.get(label.as_str()) {\n                for (prop_name, field) in edge_fields {\n                    if *prop_name != \"id\" && *prop_name != \"label\" {\n                        fields.push(\n                            crate::helixc::generator::return_values::ReturnValueField::new(\n                                prop_name.to_string(),\n                                format!(\"{}\", field.field_type),\n                            ),\n                        );\n                    }\n                }\n            }\n            (type_name, fields)\n        }\n        (Type::Vector(Some(label)), ShouldCollect::ToObj | ShouldCollect::No) => {\n            let type_name = format!(\"{}ReturnType\", label);\n            let mut fields = vec![\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"id\".to_string(),\n                    \"ID\".to_string(),\n                )\n                .with_implicit(true),\n                crate::helixc::generator::return_values::ReturnValueField::new(\n                    \"label\".to_string(),\n                    \"String\".to_string(),\n                )\n                .with_implicit(true),\n            ];\n\n            if let Some(vector_fields) = ctx.vector_fields.get(label.as_str()) {\n                for (prop_name, field) in vector_fields {\n                    if *prop_name != \"id\" && *prop_name != \"label\" {\n                        fields.push(\n                            crate::helixc::generator::return_values::ReturnValueField::new(\n                                prop_name.to_string(),\n                                format!(\"{}\", field.field_type),\n                            ),\n                        );\n                    }\n                }\n            }\n            (type_name, fields)\n        }\n        // For Vec types, we still need Vec<TypeName>\n        (Type::Node(Some(label)), ShouldCollect::ToVec) => {\n            (format!(\"Vec<{}ReturnType>\", label), vec![])\n        }\n        (Type::Edge(Some(label)), ShouldCollect::ToVec) => {\n            (format!(\"Vec<{}ReturnType>\", label), vec![])\n        }\n        (Type::Vector(Some(label)), ShouldCollect::ToVec) => {\n            (format!(\"Vec<{}ReturnType>\", label), vec![])\n        }\n        // Fallbacks for None labels\n        (Type::Node(None), _) | (Type::Edge(None), _) | (Type::Vector(None), _) => {\n            (\"\".to_string(), vec![])\n        }\n        (Type::Scalar(s), _) => (format!(\"{}\", s), vec![]),\n        (Type::Boolean, _) => (\"bool\".to_string(), vec![]),\n        (Type::Array(inner), _) => {\n            let (inner_type, _) =\n                type_to_rust_string_and_fields(inner, &ShouldCollect::No, ctx, _field_name);\n            (format!(\"Vec<{}>\", inner_type), vec![])\n        }\n        (Type::Aggregate(_info), _) => {\n            // For aggregates, return HashMap type since that's what group_by/aggregate_by returns\n            // The actual struct fields will be generated later in build_return_fields\n            (\"HashMap<String, AggregateItem>\".to_string(), vec![])\n        }\n        _ => (\"\".to_string(), vec![]),\n    }\n}\n\npub(crate) fn validate_query<'a>(ctx: &mut Ctx<'a>, original_query: &'a Query) {\n    let mut query = GeneratedQuery {\n        name: original_query.name.clone(),\n        ..Default::default()\n    };\n\n    if let Some(BuiltInMacro::Model(model_name)) = &original_query.built_in_macro {\n        // handle model macro\n        query.embedding_model_to_use = Some(model_name.clone());\n    }\n\n    // -------------------------------------------------\n    // Parameter validation\n    // -------------------------------------------------\n    for param in &original_query.parameters {\n        if let FieldType::Identifier(ref id) = param.param_type.1\n            && is_valid_identifier(ctx, original_query, param.param_type.0.clone(), id.as_str())\n            && !ctx.node_set.contains(id.as_str())\n            && !ctx.edge_map.contains_key(id.as_str())\n            && !ctx.vector_set.contains(id.as_str())\n        {\n            generate_error!(\n                ctx,\n                original_query,\n                param.param_type.0.clone(),\n                E209,\n                &id,\n                &param.name.1\n            );\n        }\n        // constructs parameters and sub\u2011parameters for generator\n        GeneratedParameter::unwrap_param(\n            param.clone(),\n            &mut query.parameters,\n            &mut query.sub_parameters,\n        );\n    }\n\n    // -------------------------------------------------\n    // Statement\u2011by\u2011statement walk\n    // -------------------------------------------------\n    let mut scope: HashMap<&str, VariableInfo> = HashMap::new();\n    for param in &original_query.parameters {\n        let param_type = Type::from(param.param_type.1.clone());\n        // Parameters are singular unless they're array types (Nodes, Edges, Vectors, etc.)\n        let is_single = !matches!(\n            param_type,\n            Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_)\n        );\n        scope.insert(\n            param.name.1.as_str(),\n            VariableInfo::new(param_type, is_single),\n        );\n    }\n    for stmt in &original_query.statements {\n        let statement = validate_statements(ctx, &mut scope, original_query, &mut query, stmt);\n        if let Some(s) = statement {\n            query.statements.push(s);\n        } else {\n            // given all erroneous statements are caught by the analyzer, this should never happen\n            return;\n        }\n    }\n\n    // -------------------------------------------------\n    // Validate RETURN expressions\n    // -------------------------------------------------\n    if original_query.return_values.is_empty() {\n        let end = original_query.loc.end;\n        push_query_warn(\n            ctx,\n            original_query,\n            Loc::new(\n                original_query.loc.filepath.clone(),\n                end,\n                end,\n                original_query.loc.span.clone(),\n            ),\n            ErrorCode::W101,\n            \"query has no RETURN clause\".to_string(),\n            \"add `RETURN <expr>` at the end\",\n            None,\n        );\n    }\n    for ret in &original_query.return_values {\n        analyze_return_expr(ctx, original_query, &mut scope, &mut query, ret);\n    }\n\n    if let Some(BuiltInMacro::MCP) = &original_query.built_in_macro {\n        if query.return_values.len() != 1 {\n            generate_error!(\n                ctx,\n                original_query,\n                original_query.loc.clone(),\n                E401,\n                &query.return_values.len().to_string()\n            );\n        }\n        let return_name = query.return_values.first().unwrap().0.clone();\n        query.mcp_handler = Some(return_name);\n    }\n\n    ctx.output.queries.push(query);\n}\n\nfn analyze_return_expr<'a>(\n    ctx: &mut Ctx<'a>,\n    original_query: &'a Query,\n    scope: &mut HashMap<&'a str, VariableInfo>,\n    query: &mut GeneratedQuery,\n    ret: &'a ReturnType,\n) {\n    match ret {\n        ReturnType::Expression(expr) => {\n            let (inferred_type, stmt) =\n                infer_expr_type(ctx, expr, scope, original_query, None, query);\n\n            if stmt.is_none() {\n                return;\n            }\n\n            match stmt.unwrap() {\n                GeneratedStatement::Traversal(traversal) => {\n                    match &traversal.source_step.inner() {\n                        SourceStep::Identifier(v) => {\n                            is_valid_identifier(\n                                ctx,\n                                original_query,\n                                expr.loc.clone(),\n                                v.inner().as_str(),\n                            );\n\n                            let field_name = v.inner().clone();\n\n                            // Legacy approach\n                            let (rust_type, fields) = type_to_rust_string_and_fields(\n                                &inferred_type,\n                                &traversal.should_collect,\n                                ctx,\n                                &field_name,\n                            );\n\n                            // For Scalar types with field access (e.g., dataset_id::{value} or files::ID),\n                            // generate the property access code\n                            let literal_value = if matches!(inferred_type, Type::Scalar(_))\n                                && !traversal.object_fields.is_empty()\n                            {\n                                let property_name = &traversal.object_fields[0];\n\n                                match traversal.should_collect {\n                                    ShouldCollect::ToObj => {\n                                        // Single item - use literal_value\n                                        if property_name == \"id\" {\n                                            Some(GenRef::Std(format!(\n                                                \"uuid_str({}.id(), &arena)\",\n                                                field_name\n                                            )))\n                                        } else if property_name == \"label\" {\n                                            Some(GenRef::Std(format!(\"{}.label()\", field_name)))\n                                        } else {\n                                            Some(GenRef::Std(format!(\n                                                \"{}.get_property(\\\"{}\\\")\",\n                                                field_name, property_name\n                                            )))\n                                        }\n                                    }\n                                    ShouldCollect::ToVec => {\n                                        // Collection - generate iteration code\n                                        let iter_code = if property_name == \"id\" {\n                                            format!(\"{}.iter().map(|item| uuid_str(item.id(), &arena)).collect::<Vec<_>>()\", field_name)\n                                        } else if property_name == \"label\" {\n                                            format!(\"{}.iter().map(|item| item.label()).collect::<Vec<_>>()\", field_name)\n                                        } else {\n                                            format!(\"{}.iter().map(|item| item.get_property(\\\"{}\\\")).collect::<Vec<_>>()\", field_name, property_name)\n                                        };\n                                        Some(GenRef::Std(iter_code))\n                                    }\n                                    _ => None,\n                                }\n                            } else {\n                                None\n                            };\n\n                            query.return_values.push((\n                                field_name.clone(),\n                                ReturnValue {\n                                    name: rust_type,\n                                    fields,\n                                    literal_value,\n                                },\n                            ));\n\n                            // New unified approach\n                            // Skip struct generation for primitive types (Boolean, Scalar) - they use legacy path only\n                            if !matches!(inferred_type, Type::Boolean | Type::Scalar(_)) {\n                                let struct_name_prefix = format!(\n                                    \"{}{}\",\n                                    capitalize_first(&query.name),\n                                    capitalize_first(&field_name)\n                                );\n                                let return_fields = build_return_fields(\n                                    ctx,\n                                    &inferred_type,\n                                    &traversal,\n                                    &struct_name_prefix,\n                                );\n                                let struct_name = format!(\"{}ReturnType\", struct_name_prefix);\n                                let is_collection = matches!(\n                                    inferred_type,\n                                    Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_)\n                                );\n                                let (\n                                    is_aggregate,\n                                    is_group_by,\n                                    aggregate_properties,\n                                    is_count_aggregate,\n                                ) = match inferred_type {\n                                    Type::Aggregate(info) => (\n                                        true,\n                                        info.is_group_by,\n                                        info.properties.clone(),\n                                        info.is_count,\n                                    ),\n                                    _ => (false, false, Vec::new(), false),\n                                };\n                                query\n                                    .return_structs\n                                    .push(ReturnValueStruct::from_return_fields(\n                                        struct_name.clone(),\n                                        return_fields.clone(),\n                                        field_name.clone(),\n                                        is_collection,\n                                        traversal.is_reused_variable,\n                                        is_aggregate,\n                                        is_group_by,\n                                        aggregate_properties,\n                                        is_count_aggregate,\n                                    ));\n                            }\n\n                            // Note: Map closures are no longer injected here.\n                            // Mapping will happen at response construction time instead.\n                        }\n                        _ => {\n                            let field_name = \"data\".to_string();\n\n                            // Legacy approach\n                            let (rust_type, fields) = type_to_rust_string_and_fields(\n                                &inferred_type,\n                                &traversal.should_collect,\n                                ctx,\n                                &field_name,\n                            );\n                            query.return_values.push((\n                                field_name.clone(),\n                                ReturnValue {\n                                    name: rust_type,\n                                    fields,\n                                    literal_value: None,\n                                },\n                            ));\n\n                            // New unified approach\n                            let struct_name_prefix = format!(\n                                \"{}{}\",\n                                capitalize_first(&query.name),\n                                capitalize_first(&field_name)\n                            );\n                            let return_fields = build_return_fields(\n                                ctx,\n                                &inferred_type,\n                                &traversal,\n                                &struct_name_prefix,\n                            );\n                            let struct_name = format!(\"{}ReturnType\", struct_name_prefix);\n                            let is_collection = matches!(\n                                inferred_type,\n                                Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_)\n                            );\n                            let (\n                                is_aggregate,\n                                is_group_by,\n                                aggregate_properties,\n                                is_count_aggregate,\n                            ) = match inferred_type {\n                                Type::Aggregate(info) => (\n                                    true,\n                                    info.is_group_by,\n                                    info.properties.clone(),\n                                    info.is_count,\n                                ),\n                                _ => (false, false, Vec::new(), false),\n                            };\n                            query\n                                .return_structs\n                                .push(ReturnValueStruct::from_return_fields(\n                                    struct_name.clone(),\n                                    return_fields.clone(),\n                                    field_name.clone(),\n                                    is_collection,\n                                    traversal.is_reused_variable,\n                                    is_aggregate,\n                                    is_group_by,\n                                    aggregate_properties,\n                                    is_count_aggregate,\n                                ));\n\n                            // Generate map closure (direct return, no variable assignment to update)\n                            // Map closure will be used during return generation phase\n                        }\n                    }\n                }\n                GeneratedStatement::Identifier(id) => {\n                    is_valid_identifier(ctx, original_query, expr.loc.clone(), id.inner().as_str());\n                    let identifier_end_type = match scope.get(id.inner().as_str()) {\n                        Some(var_info) => var_info.ty.clone(),\n                        None => {\n                            generate_error!(\n                                ctx,\n                                original_query,\n                                expr.loc.clone(),\n                                E301,\n                                id.inner().as_str()\n                            );\n                            Type::Unknown\n                        }\n                    };\n\n                    let field_name = id.inner().clone();\n\n                    // Legacy approach\n                    let (rust_type, fields) = type_to_rust_string_and_fields(\n                        &identifier_end_type,\n                        &ShouldCollect::No,\n                        ctx,\n                        &field_name,\n                    );\n                    query.return_values.push((\n                        field_name.clone(),\n                        ReturnValue {\n                            name: rust_type,\n                            fields,\n                            literal_value: None,\n                        },\n                    ));\n\n                    // New unified approach\n                    // Skip struct generation for primitive types (Boolean, Scalar) - they use legacy path only\n                    if !matches!(identifier_end_type, Type::Boolean | Type::Scalar(_)) {\n                        // For identifier returns, we need to create a traversal to build fields from\n                        let var_info = scope.get(id.inner().as_str());\n                        let is_reused = var_info.is_some_and(|v| v.reference_count > 1);\n                        let is_collection = var_info.is_some_and(|v| !v.is_single);\n                        let traversal = GeneratedTraversal {\n                            is_reused_variable: is_reused,\n                            ..Default::default()\n                        };\n                        let struct_name_prefix = format!(\n                            \"{}{}\",\n                            capitalize_first(&query.name),\n                            capitalize_first(&field_name)\n                        );\n                        let return_fields = build_return_fields(\n                            ctx,\n                            &identifier_end_type,\n                            &traversal,\n                            &struct_name_prefix,\n                        );\n                        let struct_name = format!(\"{}ReturnType\", struct_name_prefix);\n                        let (is_aggregate, is_group_by) = match identifier_end_type {\n                            Type::Aggregate(info) => (true, info.is_group_by),\n                            _ => (false, false),\n                        };\n                        // For GeneratedStatement::Identifier, the variable is already transformed\n                        // (no transformation code needed)\n                        let aggregate_properties = Vec::new();\n                        let is_count_aggregate = false;\n\n                        query\n                            .return_structs\n                            .push(ReturnValueStruct::from_return_fields(\n                                struct_name.clone(),\n                                return_fields.clone(),\n                                field_name.clone(),\n                                is_collection,\n                                is_reused,\n                                is_aggregate,\n                                is_group_by,\n                                aggregate_properties,\n                                is_count_aggregate,\n                            ));\n                    }\n\n                    // Note: Map closures are no longer injected here.\n                    // Mapping will happen at response construction time instead.\n                }\n                GeneratedStatement::Literal(l) => {\n                    let field_name = \"data\".to_string();\n                    let rust_type = \"Value\".to_string();\n\n                    query.return_values.push((\n                        field_name,\n                        ReturnValue {\n                            name: rust_type,\n                            fields: vec![],\n                            literal_value: Some(l.clone()),\n                        },\n                    ));\n                }\n                GeneratedStatement::Empty => query.return_values = vec![],\n\n                // given all erroneous statements are caught by the analyzer, this should never happen\n                // all malformed statements (not gramatically correct) should be caught by the parser\n                _ => unreachable!(),\n            }\n        }\n        ReturnType::Array(values) => {\n            // For arrays, check if they contain simple expressions (identifiers/traversals)\n            // or complex nested structures\n            let is_simple_array = values\n                .iter()\n                .all(|v| matches!(v, ReturnType::Expression(_)));\n\n            if is_simple_array {\n                // Process each element as a separate return value\n                for return_expr in values {\n                    analyze_return_expr(ctx, original_query, scope, query, return_expr);\n                }\n            } else {\n                // Complex nested array/object structure\n                // Wrap in an object with a single \"data\" field for now\n                let mut object_fields = HashMap::new();\n                object_fields.insert(\"data\".to_string(), ReturnType::Array(values.clone()));\n\n                let struct_name = format!(\"{}ReturnType\", capitalize_first(&query.name));\n                process_object_literal(\n                    ctx,\n                    original_query,\n                    scope,\n                    query,\n                    &object_fields,\n                    struct_name,\n                );\n\n                // Note: process_object_literal adds to query.return_values\n                // and sets use_struct_returns = false, so no need to push to return_structs\n            }\n        }\n        ReturnType::Object(values) => {\n            // Check if this is a simple object with only expression values\n            let is_simple_object = values\n                .values()\n                .all(|v| matches!(v, ReturnType::Expression(_)));\n\n            if is_simple_object {\n                // Process each field in the object\n                for return_expr in values.values() {\n                    // Recursively analyze each field's return expression\n                    analyze_return_expr(ctx, original_query, scope, query, return_expr);\n                }\n            } else {\n                // Complex nested object - use new object literal processing\n                let struct_name = format!(\"{}ReturnType\", capitalize_first(&query.name));\n                process_object_literal(\n                    ctx,\n                    original_query,\n                    scope,\n                    query,\n                    values,\n                    struct_name,\n                );\n\n                // Note: process_object_literal adds to query.return_values\n                // and sets use_struct_returns = false, so no need to push to return_structs\n            }\n        }\n        ReturnType::Empty => {}\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::helixc::parser::{HelixParser, write_to_temp_file};\n\n    // ============================================================================\n    // Parameter Validation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_unknown_parameter_type_1263": {
      "name": "test_unknown_parameter_type",
      "type": "function",
      "start_line": 1263,
      "end_line": 1286,
      "content_hash": "24b006a69f25dda28dfbf15711a0339d2b67d2eb",
      "content": "    fn test_unknown_parameter_type() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(data: UnknownType) =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E209));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"unknown type\") && d.message.contains(\"UnknownType\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_valid_array_parameter_type_1287": {
      "name": "test_valid_array_parameter_type",
      "type": "function",
      "start_line": 1287,
      "end_line": 1310,
      "content_hash": "e76e25681039c3dcfcb8d7e77ba0f79c4801d199",
      "content": "    fn test_valid_array_parameter_type() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY createPeople(names: [String]) =>\n                p <- N<Person>\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not have E209 errors for valid array parameter type\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E209));\n    }\n\n    // ============================================================================\n    // Variable Scope Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_variable_not_in_scope_1311": {
      "name": "test_variable_not_in_scope",
      "type": "function",
      "start_line": 1311,
      "end_line": 1334,
      "content_hash": "0a884802ca7a301e81ccf17d5a65a2898f76b35b",
      "content": "    fn test_variable_not_in_scope() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN unknownVar\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"not in scope\") && d.message.contains(\"unknownVar\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_parameter_in_scope_1335": {
      "name": "test_parameter_in_scope",
      "type": "function",
      "start_line": 1335,
      "end_line": 1353,
      "content_hash": "e519d0b60f668cc4926c64117b4f09a15c7ed4c9",
      "content": "    fn test_parameter_in_scope() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                p <- N<Person>(id)\n                RETURN p\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_assigned_variable_in_scope_1354": {
      "name": "test_assigned_variable_in_scope",
      "type": "function",
      "start_line": 1354,
      "end_line": 1377,
      "content_hash": "1f8c8a0cdb3117bd509f08a8e86399343d792f92",
      "content": "    fn test_assigned_variable_in_scope() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                result <- p::{name}\n                RETURN result\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    // ============================================================================\n    // MCP Macro Validation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_mcp_query_single_return_valid_1378": {
      "name": "test_mcp_query_single_return_valid",
      "type": "function",
      "start_line": 1378,
      "end_line": 1397,
      "content_hash": "9b131c1ee346fa733f0713230ca0f46ade8da361",
      "content": "    fn test_mcp_query_single_return_valid() {\n        let source = r#\"\n            N::Person { name: String }\n\n            #[mcp]\n            QUERY getPerson(id: ID) =>\n                person <- N<Person>(id)\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E401));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_mcp_query_multiple_returns_invalid_1398": {
      "name": "test_mcp_query_multiple_returns_invalid",
      "type": "function",
      "start_line": 1398,
      "end_line": 1423,
      "content_hash": "60041240c00f5f118bdaa70664b01b6429ca94e8",
      "content": "    fn test_mcp_query_multiple_returns_invalid() {\n        let source = r#\"\n            N::Person { name: String }\n\n            #[mcp]\n            QUERY getPerson() =>\n                p1 <- N<Person>\n                p2 <- N<Person>\n                RETURN p1, p2\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E401));\n        assert!(\n            diagnostics\n                .iter()\n                .any(|d| d.message.contains(\"MCP query must return a single value\"))\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_non_mcp_query_multiple_returns_valid_1424": {
      "name": "test_non_mcp_query_multiple_returns_valid",
      "type": "function",
      "start_line": 1424,
      "end_line": 1448,
      "content_hash": "c11b785db11930812fd0f4f0204678c575bfd811",
      "content": "    fn test_non_mcp_query_multiple_returns_valid() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY getPeople() =>\n                p1 <- N<Person>\n                p2 <- N<Person>\n                RETURN p1, p2\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Non-MCP queries can return multiple values\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E401));\n    }\n\n    // ============================================================================\n    // Return Value Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_return_literal_value_1449": {
      "name": "test_return_literal_value",
      "type": "function",
      "start_line": 1449,
      "end_line": 1468,
      "content_hash": "a48792ff918d3e6341cc1e22d47cc3a73200eadf",
      "content": "    fn test_return_literal_value() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN \"success\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Should not have errors for returning literal\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_return_multiple_values_1469": {
      "name": "test_return_multiple_values",
      "type": "function",
      "start_line": 1469,
      "end_line": 1488,
      "content_hash": "f7280531f0d389f4c93b267c32356d3de60a22a6",
      "content": "    fn test_return_multiple_values() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p1 <- N<Person>\n                p2 <- N<Person>\n                RETURN p1, p2\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_return_object_1489": {
      "name": "test_return_object",
      "type": "function",
      "start_line": 1489,
      "end_line": 1511,
      "content_hash": "060a4b8ccf849fd5df6187962346d9675dd003e1",
      "content": "    fn test_return_object() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                p <- N<Person>\n                RETURN {person: p, status: \"found\"}\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    // ============================================================================\n    // Model Macro Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_model_macro_sets_embedding_model_1512": {
      "name": "test_model_macro_sets_embedding_model",
      "type": "function",
      "start_line": 1512,
      "end_line": 1546,
      "content_hash": "25895af5ad6ac8b33d03b6f30836fc89702e664c",
      "content": "    fn test_model_macro_sets_embedding_model() {\n        let source = r#\"\n            V::Document { content: String, embedding: [F32] }\n\n            #[model(\"gpt-4\")]\n            QUERY addDoc(text: String) =>\n                doc <- AddV<Document>(Embed(text), {content: text})\n                RETURN doc\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, generated) = result.unwrap();\n        // Model macro should be processed without errors\n        assert!(\n            diagnostics.is_empty() || !diagnostics.iter().any(|d| d.error_code == ErrorCode::E301)\n        );\n\n        // Check that the generated query has the embedding model set\n        assert_eq!(generated.queries.len(), 1);\n        // Model name includes quotes from parsing\n        assert_eq!(\n            generated.queries[0].embedding_model_to_use,\n            Some(\"\\\"gpt-4\\\"\".to_string())\n        );\n    }\n\n    // ============================================================================\n    // Complex Query Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_query_with_traversal_and_filtering_1547": {
      "name": "test_query_with_traversal_and_filtering",
      "type": "function",
      "start_line": 1547,
      "end_line": 1568,
      "content_hash": "354d637a9c2298763747510348012bad5ab1a398",
      "content": "    fn test_query_with_traversal_and_filtering() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n            E::Knows { From: Person, To: Person }\n\n            QUERY getFriends(id: ID, minAge: U32) =>\n                person <- N<Person>(id)\n                friends <- person::Out<Knows>::WHERE(_::{age}::GT(minAge))\n                RETURN friends\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Complex queries should not have scope errors\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_query_with_multiple_assignments_1569": {
      "name": "test_query_with_multiple_assignments",
      "type": "function",
      "start_line": 1569,
      "end_line": 1591,
      "content_hash": "4887970bb992f6285cd42a1922c5b53964b8e73f",
      "content": "    fn test_query_with_multiple_assignments() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY getEmployees(companyId: ID) =>\n                company <- N<Company>(companyId)\n                edges <- company::InE<WorksAt>\n                people <- edges::FromN\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_query_returning_property_access_1592": {
      "name": "test_query_returning_property_access",
      "type": "function",
      "start_line": 1592,
      "end_line": 1610,
      "content_hash": "5cfb35a24b155b896cec5972762300435b1ba4bc",
      "content": "    fn test_query_returning_property_access() {\n        let source = r#\"\n            N::Person { name: String, email: String }\n\n            QUERY getEmail(id: ID) =>\n                person <- N<Person>(id)\n                email <- person::{email}\n                RETURN email\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}