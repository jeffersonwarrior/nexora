{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/mod.rs",
  "file_hash": "9b0aea13f7834e5229346e0d5dfa55c431689c50",
  "updated_at": "2025-12-26T17:34:24.953637",
  "symbols": {
    "struct_HelixParser_34": {
      "name": "HelixParser",
      "type": "struct",
      "start_line": 34,
      "end_line": 37,
      "content_hash": "a12344f943520fdfa23bd444493e703f7e0fbe14",
      "content": "pub struct HelixParser {\n    pub(super) source: Source,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixParser_38": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 38,
      "end_line": 38,
      "content_hash": "450bcf283cd89b2f8b75533f641005b5dc1a4062",
      "content": "impl HelixParser {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_source_39": {
      "name": "parse_source",
      "type": "method",
      "start_line": 39,
      "end_line": 188,
      "content_hash": "fb60c3f216d0651825ebba58f0c1bcfece3296a6",
      "content": "    pub fn parse_source(input: &Content) -> Result<Source, ParserError> {\n        let mut source = Source {\n            source: String::new(),\n            schema: HashMap::new(),\n            migrations: Vec::new(),\n            queries: Vec::new(),\n        };\n\n        input.files.iter().try_for_each(|file| {\n            source.source.push_str(&file.content);\n            source.source.push('\\n');\n            let pair = match HelixParser::parse(Rule::source, &file.content) {\n                Ok(mut pairs) => pairs\n                    .next()\n                    .ok_or_else(|| ParserError::from(\"Empty input\"))?,\n                Err(e) => {\n                    return Err(ParserError::from(e));\n                }\n            };\n            let mut parser = HelixParser {\n                source: Source::default(),\n            };\n\n            let pairs = pair.into_inner();\n            let mut remaining_queries = HashSet::new();\n            let mut remaining_migrations = HashSet::new();\n            for pair in pairs {\n                match pair.as_rule() {\n                    Rule::schema_def => {\n                        let mut schema_pairs = pair.into_inner();\n\n                        let schema_version = match schema_pairs.peek() {\n                            Some(pair) => {\n                                if pair.as_rule() == Rule::schema_version {\n                                    let version_pair = schema_pairs.next().ok_or_else(|| {\n                                        ParserError::from(\"Expected schema version\")\n                                    })?;\n                                    let version_str = version_pair\n                                        .into_inner()\n                                        .next()\n                                        .ok_or_else(|| {\n                                            ParserError::from(\"Schema version missing value\")\n                                        })?\n                                        .as_str();\n                                    version_str.parse::<usize>().map_err(|e| {\n                                        ParserError::from(format!(\n                                            \"Invalid schema version number '{version_str}': {e}\"\n                                        ))\n                                    })?\n                                } else {\n                                    1\n                                }\n                            }\n                            None => 1,\n                        };\n\n                        for pair in schema_pairs {\n                            match pair.as_rule() {\n                                Rule::node_def => {\n                                    let node_schema =\n                                        parser.parse_node_def(pair.clone(), file.name.clone())?;\n                                    parser\n                                        .source\n                                        .schema\n                                        .entry(schema_version)\n                                        .and_modify(|schema| {\n                                            schema.node_schemas.push(node_schema.clone())\n                                        })\n                                        .or_insert(Schema {\n                                            loc: pair.loc(),\n                                            version: (pair.loc(), schema_version),\n                                            node_schemas: vec![node_schema],\n                                            edge_schemas: vec![],\n                                            vector_schemas: vec![],\n                                        });\n                                }\n                                Rule::edge_def => {\n                                    let edge_schema =\n                                        parser.parse_edge_def(pair.clone(), file.name.clone())?;\n                                    parser\n                                        .source\n                                        .schema\n                                        .entry(schema_version)\n                                        .and_modify(|schema| {\n                                            schema.edge_schemas.push(edge_schema.clone())\n                                        })\n                                        .or_insert(Schema {\n                                            loc: pair.loc(),\n                                            version: (pair.loc(), schema_version),\n                                            node_schemas: vec![],\n                                            edge_schemas: vec![edge_schema],\n                                            vector_schemas: vec![],\n                                        });\n                                }\n                                Rule::vector_def => {\n                                    let vector_schema =\n                                        parser.parse_vector_def(pair.clone(), file.name.clone())?;\n                                    parser\n                                        .source\n                                        .schema\n                                        .entry(schema_version)\n                                        .and_modify(|schema| {\n                                            schema.vector_schemas.push(vector_schema.clone())\n                                        })\n                                        .or_insert(Schema {\n                                            loc: pair.loc(),\n                                            version: (pair.loc(), schema_version),\n                                            node_schemas: vec![],\n                                            edge_schemas: vec![],\n                                            vector_schemas: vec![vector_schema],\n                                        });\n                                }\n                                _ => return Err(ParserError::from(\"Unexpected rule encountered\")),\n                            }\n                        }\n                    }\n                    Rule::migration_def => {\n                        remaining_migrations.insert(pair);\n                    }\n                    Rule::query_def => {\n                        remaining_queries.insert(pair);\n                    }\n                    Rule::EOI => (),\n                    _ => return Err(ParserError::from(\"Unexpected rule encountered\")),\n                }\n            }\n\n            for pair in remaining_migrations {\n                let migration = parser.parse_migration_def(pair, file.name.clone())?;\n                parser.source.migrations.push(migration);\n            }\n\n            for pair in remaining_queries {\n                parser\n                    .source\n                    .queries\n                    .push(parser.parse_query_def(pair, file.name.clone())?);\n            }\n\n            // parse all schemas first then parse queries using self\n            source.schema.extend(parser.source.schema);\n            source.queries.extend(parser.source.queries);\n            source.migrations.extend(parser.source.migrations);\n            Ok(())\n        })?;\n\n        Ok(source)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_write_to_temp_file_189": {
      "name": "write_to_temp_file",
      "type": "method",
      "start_line": 189,
      "end_line": 205,
      "content_hash": "d7f56688d7008ab697defe0357dbba67e9f73566",
      "content": "pub fn write_to_temp_file(content: Vec<&str>) -> Content {\n    let mut files = Vec::new();\n    for c in content {\n        let mut file = tempfile::NamedTempFile::new().unwrap();\n        file.write_all(c.as_bytes()).unwrap();\n        let path = file.path().to_string_lossy().into_owned();\n        files.push(HxFile {\n            name: path,\n            content: c.to_string(),\n        });\n    }\n    Content {\n        content: String::new(),\n        files,\n        source: Source::default(),\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}