{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/main.rs",
  "file_hash": "43a683271070ccbe772976303aa56e443fd43550",
  "updated_at": "2025-12-26T17:34:20.375000",
  "symbols": {
    "struct_Cli_22": {
      "name": "Cli",
      "type": "struct",
      "start_line": 22,
      "end_line": 27,
      "content_hash": "064f88e6ab1abaa7fe4d62636c331981e81f43a8",
      "content": "struct Cli {\n    #[clap(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_Commands_28": {
      "name": "Commands",
      "type": "enum",
      "start_line": 28,
      "end_line": 267,
      "content_hash": "f61df2fea6f1c3752824620fe630015a98abc4df",
      "content": "enum Commands {\n    /// Initialize a new Helix project with helix.toml\n    Init {\n        /// Project directory (defaults to current directory)\n        #[clap(short, long)]\n        path: Option<String>,\n\n        #[clap(short, long, default_value = \"empty\")]\n        template: String,\n\n        /// Queries directory path (defaults to ./db/)\n        #[clap(short = 'q', long = \"queries-path\", default_value = \"./db/\")]\n        queries_path: String,\n\n        #[clap(subcommand)]\n        cloud: Option<CloudDeploymentTypeCommand>,\n    },\n\n    /// Add a new instance to an existing Helix project\n    Add {\n        #[clap(subcommand)]\n        cloud: Option<CloudDeploymentTypeCommand>,\n    },\n\n    /// Create a new Helix Cloud cluster\n    CreateCluster {\n        /// Instance name\n        instance: String,\n\n        /// Region for cluster (defaults to us-east-1)\n        #[clap(short, long)]\n        region: Option<String>,\n    },\n\n    /// Validate project configuration and queries\n    Check {\n        /// Instance to check (defaults to all instances)\n        instance: Option<String>,\n    },\n\n    /// Compile project queries into the workspace\n    Compile {\n        /// Directory containing helix.toml (defaults to current directory or project root)\n        #[clap(short, long)]\n        path: Option<String>,\n\n        /// Path to output compiled queries\n        #[clap(short, long)]\n        output: Option<String>,\n    },\n\n    /// Build and compile project for an instance\n    Build {\n        /// Instance name to build (interactive selection if not provided)\n        instance: Option<String>,\n    },\n\n    /// Deploy/start an instance\n    Push {\n        /// Instance name to push (interactive selection if not provided)\n        instance: Option<String>,\n        /// Use development profile for faster builds (Helix Cloud only)\n        #[clap(long)]\n        dev: bool,\n    },\n\n    /// Pull .hql files from instance back to local project\n    Pull {\n        /// Instance name to pull from\n        instance: String,\n    },\n\n    /// Start an instance (doesn't rebuild)\n    Start {\n        /// Instance name to start (interactive selection if not provided)\n        instance: Option<String>,\n    },\n\n    /// Stop an instance\n    Stop {\n        /// Instance name to stop (interactive selection if not provided)\n        instance: Option<String>,\n    },\n\n    /// Show status of all instances\n    Status,\n\n    /// Cloud operations (login, keys, etc.)\n    Auth {\n        #[clap(subcommand)]\n        action: AuthAction,\n    },\n\n    /// Prune containers, images and workspace (preserves volumes)\n    Prune {\n        /// Instance to prune (if not specified, prunes unused resources)\n        instance: Option<String>,\n\n        /// Prune all instances in project\n        #[clap(short, long)]\n        all: bool,\n    },\n\n    /// Delete an instance completely\n    Delete {\n        /// Instance name to delete\n        instance: String,\n    },\n\n    /// Manage metrics collection\n    Metrics {\n        #[clap(subcommand)]\n        action: MetricsAction,\n    },\n\n    /// Launch the Helix Dashboard\n    Dashboard {\n        #[clap(subcommand)]\n        action: DashboardAction,\n    },\n\n    /// Update to the latest version\n    Update {\n        /// Force update even if already on latest version\n        #[clap(long)]\n        force: bool,\n    },\n\n    /// Migrate v1 project to v2 format\n    Migrate {\n        /// Project directory to migrate (defaults to current directory)\n        #[clap(short, long)]\n        path: Option<String>,\n\n        /// Directory to move .hx files to (defaults to ./db/)\n        #[clap(short = 'q', long = \"queries-dir\", default_value = \"./db/\")]\n        queries_dir: String,\n\n        /// Name for the default local instance (defaults to \"dev\")\n        #[clap(short, long, default_value = \"dev\")]\n        instance_name: String,\n\n        /// Port for local instance (defaults to 6969)\n        #[clap(long, default_value = \"6969\")]\n        port: u16,\n\n        /// Show what would be migrated without making changes\n        #[clap(long)]\n        dry_run: bool,\n\n        /// Skip creating backup of v1 files\n        #[clap(long)]\n        no_backup: bool,\n    },\n\n    /// Backup instance at the given path\n    Backup {\n        /// Instance name to backup\n        instance: String,\n\n        /// Output directory for the backup. If omitted, ./backups/backup-<ts>/ will be used\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n    },\n\n    /// Send feedback to the Helix team\n    Feedback {\n        /// Feedback message (opens interactive prompt if not provided)\n        message: Option<String>,\n    },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Initialize error reporting\n    color_eyre::install()?;\n\n    // Initialize metrics sender\n    let metrics_sender = metrics_sender::MetricsSender::new()?;\n\n    // Send CLI install event (only first time)\n    metrics_sender.send_cli_install_event_if_first_time();\n\n    // Check for updates before processing commands\n    update::check_for_updates().await?;\n\n    let cli = Cli::parse();\n\n    let result = match cli.command {\n        Commands::Init {\n            path,\n            template,\n            queries_path,\n            cloud,\n        } => commands::init::run(path, template, queries_path, cloud).await,\n        Commands::Add { cloud } => commands::add::run(cloud).await,\n        Commands::CreateCluster { instance, region } => {\n            commands::create_cluster::run(&instance, region).await\n        }\n        Commands::Check { instance } => commands::check::run(instance, &metrics_sender).await,\n        Commands::Compile { output, path } => commands::compile::run(output, path).await,\n        Commands::Build { instance } => commands::build::run(instance, &metrics_sender)\n            .await\n            .map(|_| ()),\n        Commands::Push { instance, dev } => commands::push::run(instance, dev, &metrics_sender).await,\n        Commands::Pull { instance } => commands::pull::run(instance).await,\n        Commands::Start { instance } => commands::start::run(instance).await,\n        Commands::Stop { instance } => commands::stop::run(instance).await,\n        Commands::Status => commands::status::run().await,\n        Commands::Auth { action } => commands::auth::run(action).await,\n        Commands::Prune { instance, all } => commands::prune::run(instance, all).await,\n        Commands::Delete { instance } => commands::delete::run(instance).await,\n        Commands::Metrics { action } => commands::metrics::run(action).await,\n        Commands::Dashboard { action } => commands::dashboard::run(action).await,\n        Commands::Update { force } => commands::update::run(force).await,\n        Commands::Migrate {\n            path,\n            queries_dir,\n            instance_name,\n            port,\n            dry_run,\n            no_backup,\n        } => {\n            commands::migrate::run(path, queries_dir, instance_name, port, dry_run, no_backup).await\n        }\n        Commands::Backup { instance, output } => commands::backup::run(output, instance).await,\n        Commands::Feedback { message } => commands::feedback::run(message).await,\n    };\n\n    // Shutdown metrics sender\n    metrics_sender.shutdown().await?;\n\n    // Handle result with proper error formatting\n    if let Err(e) = result {\n        eprintln!(\"{e}\");\n        std::process::exit(1);\n    }\n\n    Ok(())\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}