{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/statement_validation.rs",
  "file_hash": "1384d52a5bb617f51c28128f0e59effebea96ae2",
  "updated_at": "2025-12-26T17:34:23.371386",
  "symbols": {
    "function_test_duplicate_variable_assignment_322": {
      "name": "test_duplicate_variable_assignment",
      "type": "function",
      "start_line": 322,
      "end_line": 342,
      "content_hash": "75acfbb4d6f73ea3bfec0764d9d2dd660e4c7722",
      "content": "    fn test_duplicate_variable_assignment() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                person <- N<Person>\n                person <- N<Person>\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E302));\n        assert!(diagnostics.iter().any(|d| d.message.contains(\"previously declared\")));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_valid_multiple_assignments_different_names_343": {
      "name": "test_valid_multiple_assignments_different_names",
      "type": "function",
      "start_line": 343,
      "end_line": 366,
      "content_hash": "b18fe1c1c7f3b61c77accaa74a7fc4c48afd5097",
      "content": "    fn test_valid_multiple_assignments_different_names() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                person1 <- N<Person>\n                person2 <- N<Person>\n                RETURN person1, person2\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E302));\n    }\n\n    // ============================================================================\n    // For Loop Validation Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_for_loop_in_variable_not_in_scope_367": {
      "name": "test_for_loop_in_variable_not_in_scope",
      "type": "function",
      "start_line": 367,
      "end_line": 388,
      "content_hash": "ee5d5ec13573c2c12ecd3d5935ffa7b5f23ff043",
      "content": "    fn test_for_loop_in_variable_not_in_scope() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                FOR p IN unknownList {\n                    person <- N<Person>\n                }\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n        assert!(diagnostics.iter().any(|d| d.message.contains(\"not in scope\") && d.message.contains(\"unknownList\")));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_for_loop_with_valid_parameter_389": {
      "name": "test_for_loop_with_valid_parameter",
      "type": "function",
      "start_line": 389,
      "end_line": 410,
      "content_hash": "43df0239db10721a6bc706c1289a6545bc4dff4c",
      "content": "    fn test_for_loop_with_valid_parameter() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(ids: [ID]) =>\n                FOR id IN ids {\n                    person <- N<Person>(id)\n                }\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E651));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_for_loop_non_iterable_variable_411": {
      "name": "test_for_loop_non_iterable_variable",
      "type": "function",
      "start_line": 411,
      "end_line": 432,
      "content_hash": "e78b80b6adf9a22db2c937e09f25243ae19acaee",
      "content": "    fn test_for_loop_non_iterable_variable() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                FOR p IN id {\n                    person <- N<Person>\n                }\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E651));\n        assert!(diagnostics.iter().any(|d| d.message.contains(\"not iterable\")));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_for_loop_with_object_destructuring_433": {
      "name": "test_for_loop_with_object_destructuring",
      "type": "function",
      "start_line": 433,
      "end_line": 456,
      "content_hash": "13b0e95606622a516b1ac663c661a9eeda8a5db5",
      "content": "    fn test_for_loop_with_object_destructuring() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(data: [{name: String, age: U32}]) =>\n                FOR {name, age} IN data {\n                    person <- AddN<Person>({name: name, age: age})\n                }\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        // This tests the for loop with object destructuring works\n    }\n\n    // ============================================================================\n    // Drop Statement Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_statement_valid_457": {
      "name": "test_drop_statement_valid",
      "type": "function",
      "start_line": 457,
      "end_line": 478,
      "content_hash": "edbc77c024e2a10e86aff132b9a48b9304db9eb5",
      "content": "    fn test_drop_statement_valid() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                DROP person::Out<Knows>\n                RETURN person\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // DROP statements should not produce scope errors\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_drop_with_undefined_variable_479": {
      "name": "test_drop_with_undefined_variable",
      "type": "function",
      "start_line": 479,
      "end_line": 501,
      "content_hash": "21b1e76c9e2fe51f1d5611b604a3aec16037fdd1",
      "content": "    fn test_drop_with_undefined_variable() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                DROP unknownVar\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    // ============================================================================\n    // Expression Statement Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_expression_statement_add_node_502": {
      "name": "test_expression_statement_add_node",
      "type": "function",
      "start_line": 502,
      "end_line": 521,
      "content_hash": "6637f5ceac8420834d31a9ec04d235b18e84eacc",
      "content": "    fn test_expression_statement_add_node() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                AddN<Person>({name: \"Alice\"})\n                RETURN \"created\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Expression statements should not produce errors\n        assert!(diagnostics.is_empty() || !diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_expression_statement_add_edge_522": {
      "name": "test_expression_statement_add_edge",
      "type": "function",
      "start_line": 522,
      "end_line": 547,
      "content_hash": "a681d37201ea3e1e374ceaef970991a62d900b80",
      "content": "    fn test_expression_statement_add_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id1: ID, id2: ID) =>\n                p1 <- N<Person>(id1)\n                p2 <- N<Person>(id2)\n                AddE<Knows>::From(p1)::To(p2)\n                RETURN \"connected\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    // ============================================================================\n    // Complex Statement Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nested_for_loops_548": {
      "name": "test_nested_for_loops",
      "type": "function",
      "start_line": 548,
      "end_line": 572,
      "content_hash": "b00ec67e0fd00bf9e504bedb36dbfa59d8b269f4",
      "content": "    fn test_nested_for_loops() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n\n            QUERY test(peopleIds: [ID], companyIds: [ID]) =>\n                FOR personId IN peopleIds {\n                    FOR companyId IN companyIds {\n                        person <- N<Person>(personId)\n                    }\n                }\n                RETURN \"done\"\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        // Nested for loops should work\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_assignment_with_property_access_573": {
      "name": "test_assignment_with_property_access",
      "type": "function",
      "start_line": 573,
      "end_line": 593,
      "content_hash": "3463559fe9347ad4c2b6078f0d501a9b1710b6c1",
      "content": "    fn test_assignment_with_property_access() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                name <- person::{name}\n                age <- person::{age}\n                RETURN name, age\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301 || d.error_code == ErrorCode::E302));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_assignment_with_traversal_chain_594": {
      "name": "test_assignment_with_traversal_chain",
      "type": "function",
      "start_line": 594,
      "end_line": 615,
      "content_hash": "208f7d4ff0169663354c20c1115cf7e42ffb1b68",
      "content": "    fn test_assignment_with_traversal_chain() {\n        let source = r#\"\n            N::Person { name: String }\n            N::Company { name: String }\n            E::WorksAt { From: Person, To: Company }\n\n            QUERY test(personId: ID) =>\n                person <- N<Person>(personId)\n                edges <- person::OutE<WorksAt>\n                companies <- edges::ToN\n                RETURN companies\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(!diagnostics.iter().any(|d| d.error_code == ErrorCode::E301 || d.error_code == ErrorCode::E302));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}