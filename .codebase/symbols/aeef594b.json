{
  "file_path": "/work/context-engine/scripts/sync_env_to_k8s.py",
  "file_hash": "9406ff9325afa360c95530ce8193c879c7d5809f",
  "updated_at": "2025-12-26T17:34:23.432092",
  "symbols": {
    "function_repo_root_26": {
      "name": "repo_root",
      "type": "function",
      "start_line": 26,
      "end_line": 28,
      "content_hash": "c7c4e4269efccffdae41768d955b00d46a01b562",
      "content": "def repo_root() -> Path:\n    \"\"\"Return the repo root (one level above scripts/).\"\"\"\n    return Path(__file__).resolve().parents[1]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_parse_env_file_31": {
      "name": "parse_env_file",
      "type": "function",
      "start_line": 31,
      "end_line": 94,
      "content_hash": "018114438cf03be38c4696bc04235f751953bcec",
      "content": "def parse_env_file(env_path: Path) -> dict:\n    \"\"\"Parse a simple KEY=VALUE .env file into a dict of strings.\n\n    - Ignores blank lines and lines starting with '#'.\n    - Splits on the first '='.\n    - Strips surrounding quotes from values if present.\n    \"\"\"\n    data: dict[str, str] = {}\n    with env_path.open(\"r\", encoding=\"utf-8\") as f:\n        for raw_line in f:\n            line = raw_line.strip()\n            if not line:\n                continue\n\n            commented = False\n            if line.startswith(\"#\"):\n                # Support commented defaults of the form \"# KEY=VALUE\" so that\n                # template-style .env files can still drive configmap.yaml.\n                stripped = line.lstrip(\"#\").strip()\n                if \"=\" not in stripped:\n                    # Pure comment, skip.\n                    continue\n\n                key_part, value_part = stripped.split(\"=\", 1)\n                key_candidate = key_part.strip()\n\n                # Only treat as a default if the key looks like an env var:\n                # UPPERCASE letters, digits, and underscores, with no spaces/colons.\n                if (\n                    not key_candidate\n                    or \" \" in key_candidate\n                    or \":\" in key_candidate\n                    or not key_candidate.replace(\"_\", \"\").isalnum()\n                    or not key_candidate.isupper()\n                ):\n                    # Looks like prose (e.g. \"Repository mode: 0=...\") rather than\n                    # an environment variable. Leave it as a comment.\n                    continue\n\n                line = f\"{key_candidate}={value_part.strip()}\"\n                commented = True\n\n            if \"=\" not in line:\n                continue\n            key, value = line.split(\"=\", 1)\n            key = key.strip()\n            value = value.strip()\n            if not key:\n                continue\n            # Do not let commented defaults override explicit KEY=VALUE entries\n            # that appeared earlier in the file.\n            if commented and key in data:\n                continue\n            # Strip inline shell-style comments from unquoted values, so that\n            # \"VALUE  # comment\" becomes just \"VALUE\".\n            if \"#\" in value and not (value.startswith(\"\\\"\") or value.startswith(\"'\")):\n                value = value.split(\"#\", 1)[0].rstrip()\n            # Strip single/double quotes if the whole value is quoted\n            if (value.startswith(\"\\\"\") and value.endswith(\"\\\"\")) or (\n                value.startswith(\"'\") and value.endswith(\"'\")\n            ):\n                value = value[1:-1]\n            data[key] = str(value)\n    return data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_update_configmap_97": {
      "name": "update_configmap",
      "type": "function",
      "start_line": 97,
      "end_line": 137,
      "content_hash": "b58ba64c671bdbc1536a7def50ead0a6cf6c3e78",
      "content": "def update_configmap(\n    configmap_path: Path,\n    env_data: dict,\n    name: str,\n    namespace: str,\n    exclude_keys: list[str] | None = None,\n) -> None:\n    \"\"\"Regenerate configmap.yaml so that data matches env_data.\n\n    Metadata (name/namespace) are ensured; any existing labels/annotations are preserved\n    if present in the current file.\n\n    Optionally excludes specific keys (e.g. sensitive secrets like GLM_API_KEY)\n    from the generated ConfigMap data.\n    \"\"\"\n    existing_meta = {}\n    if configmap_path.exists():\n        with configmap_path.open(\"r\", encoding=\"utf-8\") as f:\n            docs = list(yaml.safe_load_all(f))\n        if docs and isinstance(docs[0], dict):\n            existing_meta = docs[0].get(\"metadata\", {}) or {}\n\n    metadata = dict(existing_meta)\n    metadata.setdefault(\"name\", name)\n    metadata.setdefault(\"namespace\", namespace)\n\n    if exclude_keys is None:\n        exclude_keys = []\n    excluded = set(exclude_keys)\n\n    data = {k: str(v) for k, v in sorted(env_data.items()) if k not in excluded}\n\n    cm = {\n        \"apiVersion\": \"v1\",\n        \"kind\": \"ConfigMap\",\n        \"metadata\": metadata,\n        \"data\": data,\n    }\n\n    with configmap_path.open(\"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(cm, f, default_flow_style=False, sort_keys=False)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ensure_envfrom_in_doc_140": {
      "name": "ensure_envfrom_in_doc",
      "type": "function",
      "start_line": 140,
      "end_line": 179,
      "content_hash": "a8539cb107aa20bf5407c9f2065ede310149acb7",
      "content": "def ensure_envfrom_in_doc(doc: dict, configmap_name: str) -> bool:\n    \"\"\"Ensure every container in a Deployment/Job has envFrom for the given ConfigMap.\n\n    Returns True if the document was modified.\n    \"\"\"\n    kind = doc.get(\"kind\")\n    if kind not in {\"Deployment\", \"Job\"}:\n        return False\n\n    spec = doc.get(\"spec\") or {}\n    template = spec.get(\"template\") or {}\n    pod_spec = template.get(\"spec\") or {}\n    containers = pod_spec.get(\"containers\") or []\n    if not isinstance(containers, list) or not containers:\n        return False\n\n    changed = False\n\n    for container in containers:\n        env_from = container.get(\"envFrom\") or []\n        if not isinstance(env_from, list):\n            env_from = [env_from]\n\n        already_present = any(\n            isinstance(entry, dict)\n            and \"configMapRef\" in entry\n            and isinstance(entry[\"configMapRef\"], dict)\n            and entry[\"configMapRef\"].get(\"name\") == configmap_name\n            for entry in env_from\n        )\n\n        if not already_present:\n            env_from.append({\"configMapRef\": {\"name\": configmap_name}})\n            container[\"envFrom\"] = env_from\n            changed = True\n        else:\n            # Normalise back to list form\n            container[\"envFrom\"] = env_from\n\n    return changed",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_update_workloads_182": {
      "name": "update_workloads",
      "type": "function",
      "start_line": 182,
      "end_line": 205,
      "content_hash": "4ccc6f0e29a14ad70808d4a5fe18174a056eede1",
      "content": "def update_workloads(k8s_dir: Path, configmap_name: str) -> None:\n    \"\"\"Walk deploy/kubernetes and inject envFrom into all Deployments/Jobs.\"\"\"\n    for path in sorted(k8s_dir.glob(\"*.yaml\")):\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            docs = list(yaml.safe_load_all(f))\n\n        if not docs:\n            continue\n\n        changed = False\n        new_docs: list[dict] = []\n\n        for doc in docs:\n            if not isinstance(doc, dict):\n                new_docs.append(doc)\n                continue\n            if ensure_envfrom_in_doc(doc, configmap_name):\n                changed = True\n            new_docs.append(doc)\n\n        if changed:\n            with path.open(\"w\", encoding=\"utf-8\") as f:\n                yaml.safe_dump_all(new_docs, f, default_flow_style=False, sort_keys=False)\n            print(f\"Updated envFrom in {path}\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_208": {
      "name": "main",
      "type": "function",
      "start_line": 208,
      "end_line": 268,
      "content_hash": "0343be266d4fe97a557f4dc54ed7efd00766c4e0",
      "content": "def main() -> None:\n    root = repo_root()\n\n    parser = argparse.ArgumentParser(\n        description=\"Sync .env into configmap.yaml and inject envFrom into Kubernetes workloads.\",\n    )\n    parser.add_argument(\n        \"--env-file\",\n        default=str(root / \".env\"),\n        help=\"Path to .env file (default: repo_root/.env)\",\n    )\n    parser.add_argument(\n        \"--k8s-dir\",\n        default=str(root / \"deploy\" / \"kubernetes\"),\n        help=\"Path to Kubernetes manifests directory (default: deploy/kubernetes)\",\n    )\n    parser.add_argument(\n        \"--configmap-name\",\n        default=\"context-engine-config\",\n        help=\"Name of the ConfigMap to update (default: context-engine-config)\",\n    )\n    parser.add_argument(\n        \"--namespace\",\n        default=\"context-engine\",\n        help=\"Namespace for the ConfigMap (default: context-engine)\",\n    )\n    parser.add_argument(\n        \"--exclude-key\",\n        action=\"append\",\n        default=None,\n        help=(\n            \"Environment key to exclude from the generated ConfigMap data. \"\n            \"May be passed multiple times. Defaults to ['GLM_API_KEY'] if not provided.\"\n        ),\n    )\n\n    args = parser.parse_args()\n\n    env_path = Path(args.env_file)\n    k8s_dir = Path(args.k8s_dir)\n\n    if not env_path.is_file():\n        raise SystemExit(f\".env file not found at {env_path}\")\n    if not k8s_dir.is_dir():\n        raise SystemExit(f\"Kubernetes directory not found at {k8s_dir}\")\n\n    print(f\"Loading .env from {env_path}...\")\n    env_data = parse_env_file(env_path)\n    print(f\"Loaded {len(env_data)} keys from .env\")\n\n    configmap_path = k8s_dir / \"configmap.yaml\"\n    print(f\"Updating ConfigMap at {configmap_path}...\")\n    exclude_keys = args.exclude_key if args.exclude_key is not None else [\"GLM_API_KEY\"]\n    if exclude_keys:\n        print(f\"Excluding keys from ConfigMap: {', '.join(sorted(set(exclude_keys)))}\")\n    update_configmap(configmap_path, env_data, args.configmap_name, args.namespace, exclude_keys)\n\n    print(f\"Injecting envFrom: configMapRef: {args.configmap_name} into workloads under {k8s_dir}...\")\n    update_workloads(k8s_dir, args.configmap_name)\n\n    print(\"Done. Review and commit the updated YAMLs if they look correct.\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}