{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/vector.rs",
  "file_hash": "b7cdd5e832845971f56d7f651df106655beff683",
  "updated_at": "2025-12-26T17:34:21.493449",
  "symbols": {
    "struct_HVector_23": {
      "name": "HVector",
      "type": "struct",
      "start_line": 23,
      "end_line": 41,
      "content_hash": "38e0c3e8c8399025ebf0bafc22043fa31fb6b747",
      "content": "pub struct HVector<'arena> {\n    /// The id of the HVector\n    pub id: u128,\n    /// The label of the HVector\n    pub label: &'arena str,\n    /// the version of the vector\n    pub version: u8,\n    /// whether the vector is deleted\n    pub deleted: bool,\n    /// The level of the HVector\n    pub level: usize,\n    /// The distance of the HVector\n    pub distance: Option<f64>,\n    /// The actual vector\n    pub data: &'arena [f64],\n    /// The properties of the HVector\n    pub properties: Option<ImmutablePropertiesMap<'arena>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_42": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 42,
      "end_line": 77,
      "content_hash": "60d8f2ad2281740e2b8b0fa6364433b3d411621d",
      "content": "impl<'arena> Serialize for HVector<'arena> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        // Check if this is a human-readable format (like JSON)\n        if serializer.is_human_readable() {\n            // Include id for JSON serialization\n            let mut buffer = [0u8; 36];\n            let mut state = serializer.serialize_map(Some(\n                5 + self.properties.as_ref().map(|p| p.len()).unwrap_or(0),\n            ))?;\n            state.serialize_entry(\"id\", uuid_str_from_buf(self.id, &mut buffer))?;\n            state.serialize_entry(\"label\", &self.label)?;\n            state.serialize_entry(\"version\", &self.version)?;\n            state.serialize_entry(\"deleted\", &self.deleted)?;\n            if let Some(properties) = &self.properties {\n                for (key, value) in properties.iter() {\n                    state.serialize_entry(key, value)?;\n                }\n            }\n            state.end()\n        } else {\n            // Skip id, level, distance, and data for bincode serialization\n            let mut state = serializer.serialize_struct(\"HVector\", 4)?;\n            state.serialize_field(\"label\", &self.label)?;\n            state.serialize_field(\"version\", &self.version)?;\n            state.serialize_field(\"deleted\", &self.deleted)?;\n            state.serialize_field(\"properties\", &self.properties)?;\n            state.end()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_78": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 78,
      "end_line": 78,
      "content_hash": "6e1a9f8379c15fc1c53dec63e165162a48530572",
      "content": "impl PartialEq for HVector<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_79": {
      "name": "eq",
      "type": "method",
      "start_line": 79,
      "end_line": 82,
      "content_hash": "e42e74568e66462fe2136c6e1059be269af7bdfd",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.id == other.id\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_83": {
      "name": "Eq",
      "type": "impl",
      "start_line": 83,
      "end_line": 83,
      "content_hash": "654db88c834239fb5f90053cfe6b19922ba253b3",
      "content": "impl Eq for HVector<'_> {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_84": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 84,
      "end_line": 84,
      "content_hash": "569e28d7f49dddab0f7466d5b78efad90b687777",
      "content": "impl PartialOrd for HVector<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_85": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 85,
      "end_line": 88,
      "content_hash": "6fc71b4b68787d78ec38d0512318bdc8aa5bedbf",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_89": {
      "name": "Ord",
      "type": "impl",
      "start_line": 89,
      "end_line": 89,
      "content_hash": "2d48b0fbb4e71d1cdd8f27b15c0f2157a729e3c5",
      "content": "impl Ord for HVector<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_90": {
      "name": "cmp",
      "type": "method",
      "start_line": 90,
      "end_line": 97,
      "content_hash": "7547e85bbbe5d197cf638786ffa680c17693665d",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        other\n            .distance\n            .partial_cmp(&self.distance)\n            .unwrap_or(Ordering::Equal)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Debug_98": {
      "name": "Debug",
      "type": "impl",
      "start_line": 98,
      "end_line": 98,
      "content_hash": "38a46d36aa74a1cfc488b11a43c686c1fc0f6c0e",
      "content": "impl Debug for HVector<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_99": {
      "name": "fmt",
      "type": "method",
      "start_line": 99,
      "end_line": 111,
      "content_hash": "e6c48a264477752ce0da8188a98b114c5f10c53c",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{{ \\nid: {},\\nlevel: {},\\ndistance: {:?},\\ndata: {:?}, }}\",\n            uuid::Uuid::from_u128(self.id),\n            // self.is_deleted,\n            self.level,\n            self.distance,\n            self.data,\n        )\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HVector_112": {
      "name": "HVector",
      "type": "impl",
      "start_line": 112,
      "end_line": 113,
      "content_hash": "00f7da395d43e83bda9b11b3015a759ebdfe304c",
      "content": "impl<'arena> HVector<'arena> {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_slice_114": {
      "name": "from_slice",
      "type": "method",
      "start_line": 114,
      "end_line": 131,
      "content_hash": "051bd51918ceb6c8d57b9cf8c289425d1e85747c",
      "content": "    pub fn from_slice(label: &'arena str, level: usize, data: &'arena [f64]) -> Self {\n        let id = v6_uuid();\n        HVector {\n            id,\n            // is_deleted: false,\n            version: 1,\n            level,\n            label,\n            data,\n            distance: None,\n            properties: None,\n            deleted: false,\n        }\n    }\n\n    /// Converts the HVector to an vec of bytes by accessing the data field directly\n    /// and converting each f64 to a byte slice\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_vector_data_to_bytes_132": {
      "name": "vector_data_to_bytes",
      "type": "method",
      "start_line": 132,
      "end_line": 164,
      "content_hash": "0140de7523a51935bc92bea2216d0be89bb58b7c",
      "content": "    pub fn vector_data_to_bytes(&self) -> Result<&[u8], VectorError> {\n        bytemuck::try_cast_slice(self.data).map_err(|_| {\n            VectorError::ConversionError(\"Invalid vector data: vector data\".to_string())\n        })\n    }\n\n    /// Deserializes bytes into an vector using a custom deserializer that allocates into the provided arena\n    ///\n    /// Both the properties bytes (if present) and the raw vector data are combined to generate the final vector struct\n    ///\n    /// NOTE: in this method, fixint encoding is used\n    #[inline]\n    pub fn from_bincode_bytes<'txn>(\n        arena: &'arena bumpalo::Bump,\n        properties: Option<&'txn [u8]>,\n        raw_vector_data: &'txn [u8],\n        id: u128,\n    ) -> Result<Self, VectorError> {\n        bincode::options()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(\n                VectorDeSeed {\n                    arena,\n                    id,\n                    raw_vector_data,\n                },\n                properties.unwrap_or(&[]),\n            )\n            .map_err(|e| VectorError::ConversionError(format!(\"Error deserializing vector: {e}\")))\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_bincode_bytes_165": {
      "name": "to_bincode_bytes",
      "type": "method",
      "start_line": 165,
      "end_line": 234,
      "content_hash": "c4ab40d5376bde6b8c96d82d726396343d944754",
      "content": "    pub fn to_bincode_bytes(&self) -> Result<Vec<u8>, bincode::Error> {\n        bincode::serialize(self)\n    }\n\n    /// Casts the raw bytes to a f64 slice by copying them once into the arena\n    #[inline]\n    pub fn cast_raw_vector_data<'txn>(\n        arena: &'arena bumpalo::Bump,\n        raw_vector_data: &'txn [u8],\n    ) -> &'arena [f64] {\n        assert!(!raw_vector_data.is_empty(), \"raw_vector_data.len() == 0\");\n        assert!(\n            raw_vector_data.len().is_multiple_of(mem::size_of::<f64>()),\n            \"raw_vector_data bytes len is not a multiple of size_of::<f64>()\"\n        );\n        let dimensions = raw_vector_data.len() / mem::size_of::<f64>();\n\n        assert!(\n            raw_vector_data.len().is_multiple_of(dimensions),\n            \"raw_vector_data does not have the exact required number of dimensions\"\n        );\n\n        let layout = alloc::Layout::array::<f64>(dimensions)\n            .expect(\"vector_data array arithmetic overflow or total size exceeds isize::MAX\");\n\n        let vector_data: ptr::NonNull<u8> = arena.alloc_layout(layout);\n\n        // 'arena because the destination pointer is allocated in the arena\n        let data: &'arena [f64] = unsafe {\n            // SAFETY:\n            // - We assert data is present and that we are within bounds in asserts above\n            ptr::copy_nonoverlapping(\n                raw_vector_data.as_ptr(),\n                vector_data.as_ptr(),\n                raw_vector_data.len(),\n            );\n\n            // We allocated with the layout of an f64 array\n            let vector_data: ptr::NonNull<f64> = vector_data.cast();\n\n            // SAFETY:\n            // - `vector_data`` is guaranteed to be valid by being NonNull\n            // - the asserts above guarantee that there are enough valid bytes to be read\n            slice::from_raw_parts(vector_data.as_ptr(), dimensions)\n        };\n\n        data\n    }\n\n    /// Uses just the vector data to generate a HVector struct\n    pub fn from_raw_vector_data<'txn>(\n        arena: &'arena bumpalo::Bump,\n        raw_vector_data: &'txn [u8],\n        label: &'arena str,\n        id: u128,\n    ) -> Result<Self, VectorError> {\n        let data = Self::cast_raw_vector_data(arena, raw_vector_data);\n        Ok(HVector {\n            id,\n            label,\n            data,\n            version: 1,\n            level: 0,\n            distance: None,\n            properties: None,\n            deleted: false,\n        })\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_len_235": {
      "name": "len",
      "type": "method",
      "start_line": 235,
      "end_line": 239,
      "content_hash": "a3ff8fe501f5bb5785e675d02c3839311b628f27",
      "content": "    pub fn len(&self) -> usize {\n        self.data.len()\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_empty_240": {
      "name": "is_empty",
      "type": "method",
      "start_line": 240,
      "end_line": 244,
      "content_hash": "7d16cb5b7f1c71bfc0ad4ebb744d90f77349b4fc",
      "content": "    pub fn is_empty(&self) -> bool {\n        self.data.is_empty()\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_distance_to_245": {
      "name": "distance_to",
      "type": "method",
      "start_line": 245,
      "end_line": 249,
      "content_hash": "c3180280e7b33b87c21db2762c3a92454e602a6b",
      "content": "    pub fn distance_to(&self, other: &HVector) -> Result<f64, VectorError> {\n        HVector::<'arena>::distance(self, other)\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_distance_250": {
      "name": "set_distance",
      "type": "method",
      "start_line": 250,
      "end_line": 254,
      "content_hash": "46f07f97d3799d970d6a91a371e69443b47e220f",
      "content": "    pub fn set_distance(&mut self, distance: f64) {\n        self.distance = Some(distance);\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_distance_255": {
      "name": "get_distance",
      "type": "method",
      "start_line": 255,
      "end_line": 259,
      "content_hash": "3a20f10de926f93ef38e316c0a5975703f68c325",
      "content": "    pub fn get_distance(&self) -> f64 {\n        self.distance.unwrap_or(2.0)\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_label_260": {
      "name": "get_label",
      "type": "method",
      "start_line": 260,
      "end_line": 267,
      "content_hash": "42ae18f92bcb30ff9108f1dc024504098f4ca06a",
      "content": "    pub fn get_label(&self) -> Option<&Value> {\n        match &self.properties {\n            Some(p) => p.get(\"label\"),\n            None => None,\n        }\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_property_268": {
      "name": "get_property",
      "type": "method",
      "start_line": 268,
      "end_line": 271,
      "content_hash": "3a8265ece109f95318a2ef540c55776ef93aeaa3",
      "content": "    pub fn get_property(&self, key: &str) -> Option<&'arena Value> {\n        self.properties.as_ref().and_then(|value| value.get(key))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_id_272": {
      "name": "id",
      "type": "method",
      "start_line": 272,
      "end_line": 275,
      "content_hash": "91cbe510e3ff9eb683227e2fd287978f372c9a7e",
      "content": "    pub fn id(&self) -> &u128 {\n        &self.id\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_label_276": {
      "name": "label",
      "type": "method",
      "start_line": 276,
      "end_line": 279,
      "content_hash": "974ca497a948b4a2433d2623c18d2ab6c516f987",
      "content": "    pub fn label(&self) -> &'arena str {\n        self.label\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_score_280": {
      "name": "score",
      "type": "method",
      "start_line": 280,
      "end_line": 283,
      "content_hash": "85c8900dc3fdd7ee14970f1d5a347c7871c21c45",
      "content": "    pub fn score(&self) -> f64 {\n        self.distance.unwrap_or(2.0)\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expand_from_vector_without_data_284": {
      "name": "expand_from_vector_without_data",
      "type": "method",
      "start_line": 284,
      "end_line": 291,
      "content_hash": "2ffaeb5e8b1a5c74c25a8084e30242d50c65ae7c",
      "content": "    pub fn expand_from_vector_without_data(&mut self, vector: VectorWithoutData<'arena>) {\n        self.label = vector.label;\n        self.version = vector.version;\n        self.level = vector.level;\n        self.properties = vector.properties;\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_292": {
      "name": "From",
      "type": "impl",
      "start_line": 292,
      "end_line": 292,
      "content_hash": "17f728fcd0a1cf499aaa5bba8c6df370a6e99721",
      "content": "impl<'arena> From<VectorWithoutData<'arena>> for HVector<'arena> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_293": {
      "name": "from",
      "type": "method",
      "start_line": 293,
      "end_line": 305,
      "content_hash": "dd8e7b9464a894c308fa5479b82a9cd9926b5ba3",
      "content": "    fn from(value: VectorWithoutData<'arena>) -> Self {\n        HVector {\n            id: value.id,\n            label: value.label,\n            version: value.version,\n            level: value.level,\n            distance: None,\n            data: &[],\n            properties: value.properties,\n            deleted: value.deleted,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}