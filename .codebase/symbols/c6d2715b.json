{
  "file_path": "/work/internal/agent/agent.go",
  "file_hash": "4e01577bf95d99e688f30c0cc50757234fe0b470",
  "updated_at": "2025-12-26T17:34:24.069403",
  "symbols": {
    "struct_SessionAgentCall_53": {
      "name": "SessionAgentCall",
      "type": "struct",
      "start_line": 53,
      "end_line": 65,
      "content_hash": "8d2f4bc824f3fdfa20941eb8e7d10c26034f8588",
      "content": "type SessionAgentCall struct {\n\tSessionID        string\n\tPrompt           string\n\tProviderOptions  fantasy.ProviderOptions\n\tAttachments      []message.Attachment\n\tMaxOutputTokens  int64\n\tTemperature      *float64\n\tTopP             *float64\n\tTopK             *int64\n\tFrequencyPenalty *float64\n\tPresencePenalty  *float64\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_SessionAgent_66": {
      "name": "SessionAgent",
      "type": "interface",
      "start_line": 66,
      "end_line": 79,
      "content_hash": "fb5831b83cac96dda2d74d2507426a285459825f",
      "content": "type SessionAgent interface {\n\tRun(context.Context, SessionAgentCall) (*fantasy.AgentResult, error)\n\tSetModels(large Model, small Model)\n\tSetTools(tools []fantasy.AgentTool)\n\tCancel(sessionID string)\n\tCancelAll()\n\tIsSessionBusy(sessionID string) bool\n\tIsBusy() bool\n\tQueuedPrompts(sessionID string) int\n\tClearQueue(sessionID string)\n\tSummarize(context.Context, string, fantasy.ProviderOptions) error\n\tModel() Model\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Model_80": {
      "name": "Model",
      "type": "struct",
      "start_line": 80,
      "end_line": 85,
      "content_hash": "4e0d956fb2e12909a14d6e54ef8e9398a99a80b7",
      "content": "type Model struct {\n\tModel      fantasy.LanguageModel\n\tCatwalkCfg catwalk.Model\n\tModelCfg   config.SelectedModel\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_sessionAgent_86": {
      "name": "sessionAgent",
      "type": "struct",
      "start_line": 86,
      "end_line": 129,
      "content_hash": "2be89c8c4e147b4f2fbfe535669bccb26053c752",
      "content": "type sessionAgent struct {\n\tlargeModel           Model\n\tsmallModel           Model\n\tsystemPromptPrefix   string\n\tsystemPrompt         string\n\ttools                []fantasy.AgentTool\n\tsessions             session.Service\n\tmessages             message.Service\n\tdisableAutoSummarize bool\n\tisYolo               bool\n\n\tmessageQueue   *csync.Map[string, []SessionAgentCall]\n\tactiveRequests *csync.Map[string, context.CancelFunc]\n\taiops          aiops.Ops            // AIOPS client for operational support\n\tconvoMgr       *ConversationManager // Manages conversation state\n\n\t// Resource monitoring\n\tresourceMonitor *resources.Monitor\n\n\t// State for loop and drift detection\n\trecentCalls       []aiops.ToolCall\n\tcallCount         int\n\trecentActions     []aiops.Action\n\tactionCount       int\n\trecentCallsLock   sync.Mutex\n\trecentActionsLock sync.Mutex\n\n\t// Session state tracking\n\tsessionStates *csync.Map[string, string] // Track session states like \"awaiting_continuation\"\n\n\t// State machines per session\n\tstateMachines *csync.Map[string, *state.StateMachine]\n\n\t// Error recovery system\n\trecoveryRegistry *recovery.RecoveryRegistry\n\n\t// Retry tracking for automatic recovery\n\tretryQueue *csync.Map[string, *RetryRequest] // sessionID -> retry request\n\n\t// Tool timeout configuration\n\ttoolTimeout time.Duration\n}\n\n// RetryRequest tracks a pending retry after successful recovery",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_RetryRequest_130": {
      "name": "RetryRequest",
      "type": "struct",
      "start_line": 130,
      "end_line": 135,
      "content_hash": "6e5b4e61b4db2f3651e1eb81bd5abaa382381b6f",
      "content": "type RetryRequest struct {\n\tToolName string\n\tInput    map[string]interface{}\n\tAttempt  int\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SessionAgentOptions_136": {
      "name": "SessionAgentOptions",
      "type": "struct",
      "start_line": 136,
      "end_line": 149,
      "content_hash": "6e5d1aecab1733b2c7f5f9ba2c01b8f9dbe894e9",
      "content": "type SessionAgentOptions struct {\n\tLargeModel           Model\n\tSmallModel           Model\n\tSystemPromptPrefix   string\n\tSystemPrompt         string\n\tDisableAutoSummarize bool\n\tIsYolo               bool\n\tSessions             session.Service\n\tMessages             message.Service\n\tTools                []fantasy.AgentTool\n\tAIOPS                aiops.Ops          // AIOPS client\n\tResourceMonitor      *resources.Monitor // Resource monitor for pause/resume\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewSessionAgent_150": {
      "name": "NewSessionAgent",
      "type": "function",
      "start_line": 150,
      "end_line": 180,
      "content_hash": "a2f6bcae4b42456d35d7bc034eca3a7a2100c323",
      "content": "func NewSessionAgent(\n\topts SessionAgentOptions,\n) SessionAgent {\n\treturn &sessionAgent{\n\t\tconvoMgr:             NewConversationManager(),\n\t\tlargeModel:           opts.LargeModel,\n\t\tsmallModel:           opts.SmallModel,\n\t\tsystemPromptPrefix:   opts.SystemPromptPrefix,\n\t\tsystemPrompt:         opts.SystemPrompt,\n\t\tsessions:             opts.Sessions,\n\t\tmessages:             opts.Messages,\n\t\tdisableAutoSummarize: opts.DisableAutoSummarize,\n\t\ttools:                opts.Tools,\n\t\tisYolo:               opts.IsYolo,\n\t\tmessageQueue:         csync.NewMap[string, []SessionAgentCall](),\n\t\tactiveRequests:       csync.NewMap[string, context.CancelFunc](),\n\t\taiops:                opts.AIOPS,\n\t\tresourceMonitor:      opts.ResourceMonitor,\n\t\tsessionStates:        csync.NewMap[string, string](),\n\t\tstateMachines:        csync.NewMap[string, *state.StateMachine](),\n\t\trecoveryRegistry:     recovery.NewRecoveryRegistry(),\n\t\tretryQueue:           csync.NewMap[string, *RetryRequest](),\n\t\ttoolTimeout:          defaultToolTimeout,\n\t}\n}\n\n// wrapToolsWithTimeout cannot directly wrap fantasy.AgentTool since it's from external package\n// Instead, we need to wrap at tool creation time in the coordinator\n// This is a placeholder for now - timeout enforcement will be added in coordinator.buildTools\n\n// wrapToolWithTimeout wraps a single tool function with timeout enforcement",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_wrapToolWithTimeout_181": {
      "name": "wrapToolWithTimeout",
      "type": "method",
      "start_line": 181,
      "end_line": 191,
      "content_hash": "d1c2fad1bae24525d481504194da33fc2ac40fe0",
      "content": "func (a *sessionAgent) wrapToolWithTimeout(toolFunc interface{}) interface{} {\n\treturn func(ctx context.Context, params interface{}, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t// Extract tool name from call - use call.Name directly\n\t\ttoolName := call.Name\n\n\t\t// Create timeout context based on tool type\n\t\ttimeout := a.getToolTimeout(toolName)\n\t\ttimeoutCtx, cancel := context.WithTimeout(ctx, timeout)\n\t\tdefer cancel()\n\n\t\t// Channel to capture result",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_result_192": {
      "name": "result",
      "type": "struct",
      "start_line": 192,
      "end_line": 218,
      "content_hash": "5eee3a51cf4823d40cfbc439c161ef0d65002f89",
      "content": "\t\ttype result struct {\n\t\t\tresp fantasy.ToolResponse\n\t\t\terr  error\n\t\t}\n\t\tresultChan := make(chan result, 1)\n\n\t\t// Execute tool in goroutine\n\t\tgo func() {\n\t\t\t// Use reflection to call the original function\n\t\t\tresp, err := toolFunc.(func(context.Context, interface{}, fantasy.ToolCall) (fantasy.ToolResponse, error))(timeoutCtx, params, call)\n\t\t\tresultChan <- result{resp: resp, err: err}\n\t\t}()\n\n\t\t// Wait for completion or timeout\n\t\tselect {\n\t\tcase res := <-resultChan:\n\t\t\treturn res.resp, res.err\n\t\tcase <-timeoutCtx.Done():\n\t\t\tif timeoutCtx.Err() == context.DeadlineExceeded {\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"tool execution timed out after %v\", timeout)\n\t\t\t}\n\t\t\treturn fantasy.ToolResponse{}, timeoutCtx.Err()\n\t\t}\n\t}\n}\n\n// getToolTimeout returns the appropriate timeout for a tool based on its name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getToolTimeout_219": {
      "name": "getToolTimeout",
      "type": "method",
      "start_line": 219,
      "end_line": 238,
      "content_hash": "5333d0edbb6072a058926e74d0326775a843ea11",
      "content": "func (a *sessionAgent) getToolTimeout(toolName string) time.Duration {\n\tswitch toolName {\n\tcase \"bash\":\n\t\t// Bash commands can run longer, especially for builds/tests\n\t\treturn criticalToolTimeout\n\tcase \"agentic_fetch\", \"fetch\":\n\t\t// Network operations need longer timeouts\n\t\treturn criticalToolTimeout\n\tcase \"view\", \"grep\", \"ls\", \"glob\":\n\t\t// Read-only operations are fast\n\t\treturn defaultToolTimeout\n\tcase \"edit\", \"multiedit\", \"write\":\n\t\t// File operations can take some time for large files\n\t\treturn 2 * time.Minute\n\tdefault:\n\t\treturn defaultToolTimeout\n\t}\n}\n\n// wrapErrorForRecovery converts generic errors into recoverable errors based on error patterns",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_wrapErrorForRecovery_239": {
      "name": "wrapErrorForRecovery",
      "type": "method",
      "start_line": 239,
      "end_line": 288,
      "content_hash": "3379b804d0933321915c8123b1981a3a2129302b",
      "content": "func (a *sessionAgent) wrapErrorForRecovery(err error, toolName, filePath string, oldText, newText string) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\terrorStr := err.Error()\n\n\t// File modification errors\n\tif strings.Contains(errorStr, \"file has been modified\") ||\n\t\tstrings.Contains(errorStr, \"file changed on disk\") ||\n\t\tstrings.Contains(errorStr, \"stale file\") {\n\t\treturn recovery.NewFileOutdatedError(err, filePath)\n\t}\n\n\t// Edit operation errors\n\tif strings.Contains(errorStr, \"whitespace mismatch\") ||\n\t\tstrings.Contains(errorStr, \"failed to match\") ||\n\t\tstrings.Contains(errorStr, \"no match for text\") ||\n\t\tstrings.Contains(errorStr, \"edit failed\") {\n\t\treturn recovery.NewEditFailedError(err, filePath, oldText, newText)\n\t}\n\n\t// Timeout errors\n\tif strings.Contains(errorStr, \"timeout\") ||\n\t\tstrings.Contains(errorStr, \"deadline exceeded\") ||\n\t\tstrings.Contains(errorStr, \"context canceled\") {\n\t\treturn recovery.NewTimeoutError(toolName, 60*time.Second)\n\t}\n\n\t// Resource limit errors\n\tif strings.Contains(errorStr, \"out of memory\") ||\n\t\tstrings.Contains(errorStr, \"disk space\") ||\n\t\tstrings.Contains(errorStr, \"too many open files\") ||\n\t\tstrings.Contains(errorStr, \"resource limit exceeded\") {\n\t\treturn recovery.NewResourceLimitError(toolName, \"current\", \"limit\")\n\t}\n\n\t// Loop detection (this is handled by state machine but wrap if we get it)\n\tif strings.Contains(errorStr, \"loop detected\") ||\n\t\tstrings.Contains(errorStr, \"infinite loop\") ||\n\t\tstrings.Contains(errorStr, \"stuck\") {\n\t\treturn recovery.NewLoopDetectedError(toolName, 3)\n\t}\n\n\t// Default: wrap as recoverable with standard retries\n\treturn recovery.NewRecoverableError(err, \"generic\", map[string]interface{}{\n\t\t\"retries\": 2,\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTaskContext_289": {
      "name": "getTaskContext",
      "type": "method",
      "start_line": 289,
      "end_line": 306,
      "content_hash": "d7f9aa208b4a08fee4942d3aabde806acd0d7e76",
      "content": "func (a *sessionAgent) getTaskContext(sessionID string) string {\n\t// Get the most recent meaningful user message, not just the first\n\tmessages, err := a.messages.List(context.Background(), sessionID)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\t// Look for the last user message that contains substantial content\n\tfor i := len(messages) - 1; i >= 0; i-- {\n\t\tmsg := messages[i]\n\t\tif msg.Role == message.User && len(msg.Content().Text) > 10 {\n\t\t\treturn msg.Content().Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// getOrCreateStateMachine gets or creates a state machine for a session.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getOrCreateStateMachine_307": {
      "name": "getOrCreateStateMachine",
      "type": "method",
      "start_line": 307,
      "end_line": 391,
      "content_hash": "864f3e4be68a65752c82857610e3dc282f072e7e",
      "content": "func (a *sessionAgent) getOrCreateStateMachine(sessionID string, ctx context.Context) *state.StateMachine {\n\tif sm, ok := a.stateMachines.Get(sessionID); ok {\n\t\treturn sm\n\t}\n\n\t// Create new state machine\n\tsm := state.NewStateMachine(state.Config{\n\t\tSessionID: sessionID,\n\t\tContext:   ctx,\n\t\tOnStuck: func(reason string) {\n\t\t\tslog.Warn(\"session stuck - loop detected\",\n\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\"reason\", reason,\n\t\t\t)\n\t\t},\n\t\tOnProgress: func(stats state.ProgressStats) {\n\t\t\tslog.Debug(\"session progress\",\n\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\"files_modified\", stats.FilesModified,\n\t\t\t\t\"successes\", stats.RecentSuccesses,\n\t\t\t\t\"failures\", stats.RecentFailures,\n\t\t\t)\n\t\t},\n\t})\n\n\t// Integrate with resource monitor if available\n\tif a.resourceMonitor != nil && sm != nil {\n\t\ta.resourceMonitor.SetStateMachine(sm)\n\t\ta.resourceMonitor.SetCallbacks(\n\t\t\tfunc(usage float64) {\n\t\t\t\tif sm == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tslog.Warn(\"CPU usage high, pausing session\",\n\t\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\t\"cpu_percent\", usage,\n\t\t\t\t)\n\t\t\t\tif sm.CanTransitionTo(state.StateResourcePaused) {\n\t\t\t\t\tsm.TransitionTo(state.StateResourcePaused)\n\t\t\t\t\tsm.SetPauseReason(fmt.Sprintf(\"CPU usage %.1f%% exceeds threshold\", usage))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc(usage uint64) {\n\t\t\t\tif sm == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tslog.Warn(\"Memory usage high, pausing session\",\n\t\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\t\"mem_usage_mb\", usage/(1024*1024),\n\t\t\t\t)\n\t\t\t\tif sm.CanTransitionTo(state.StateResourcePaused) {\n\t\t\t\t\tsm.TransitionTo(state.StateResourcePaused)\n\t\t\t\t\tsm.SetPauseReason(fmt.Sprintf(\"Memory usage %.1f%% exceeds threshold\", float64(usage)/float64(1024*1024*1024)*100))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc(free uint64) {\n\t\t\t\tif sm == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tslog.Warn(\"Disk space low, pausing session\",\n\t\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\t\"disk_free_gb\", float64(free)/(1024*1024*1024),\n\t\t\t\t)\n\t\t\t\tif sm.CanTransitionTo(state.StateResourcePaused) {\n\t\t\t\t\tsm.TransitionTo(state.StateResourcePaused)\n\t\t\t\t\tsm.SetPauseReason(fmt.Sprintf(\"Disk space low: %.1fGB free\", float64(free)/(1024*1024*1024)))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc(v resources.Violation) {\n\t\t\t\tif sm == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tslog.Warn(\"Resource violation\",\n\t\t\t\t\t\"session_id\", sessionID,\n\t\t\t\t\t\"type\", v.Type,\n\t\t\t\t\t\"message\", v.Message,\n\t\t\t\t)\n\t\t\t},\n\t\t)\n\t}\n\n\ta.stateMachines.Set(sessionID, sm)\n\treturn sm\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getOriginalPrompt_392": {
      "name": "getOriginalPrompt",
      "type": "method",
      "start_line": 392,
      "end_line": 397,
      "content_hash": "2a3c43665cb1f1c303c21a462cb161bc3d972480",
      "content": "func (a *sessionAgent) getOriginalPrompt(sessionID string) string {\n\t// Legacy method - use getTaskContext for better continuation\n\treturn a.getTaskContext(sessionID)\n}\n\n// setSessionState sets the state of a session (e.g., \"awaiting_continuation\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setSessionState_398": {
      "name": "setSessionState",
      "type": "method",
      "start_line": 398,
      "end_line": 406,
      "content_hash": "aeb1d7f50dc6930c8ca4ecc0c124b19321984e33",
      "content": "func (a *sessionAgent) setSessionState(sessionID, state string) {\n\tif state == \"\" {\n\t\ta.sessionStates.Del(sessionID)\n\t} else {\n\t\ta.sessionStates.Set(sessionID, state)\n\t}\n}\n\n// getSessionState gets the current state of a session",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionState_407": {
      "name": "getSessionState",
      "type": "method",
      "start_line": 407,
      "end_line": 415,
      "content_hash": "20a268cbb49376ae958d643a91669fc6fa30e220",
      "content": "func (a *sessionAgent) getSessionState(sessionID string) string {\n\tstate, ok := a.sessionStates.Get(sessionID)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn state\n}\n\n// hasUnfinishedWork checks if the last AI response indicates unfinished work",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_hasUnfinishedWork_416": {
      "name": "hasUnfinishedWork",
      "type": "method",
      "start_line": 416,
      "end_line": 449,
      "content_hash": "566cbb01ca8b708ed649a144f7712f39f176efe6",
      "content": "func (a *sessionAgent) hasUnfinishedWork(ctx context.Context, sessionID string) bool {\n\tmessages, err := a.messages.List(ctx, sessionID)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(messages) == 0 {\n\t\treturn false\n\t}\n\n\tlastAI := messages[len(messages)-1]\n\tif lastAI.Role == message.Assistant {\n\t\tcontent := lastAI.Content().Text\n\n\t\t// Phrases that strongly indicate unfinished work\n\t\tunfinishedSignals := []string{\n\t\t\t\"now let me\", \"next, i'll\", \"let me create\", \"i'll now\",\n\t\t\t\"let me check\", \"let me examine\", \"let me review\",\n\t\t\t\"let me implement\", \"now i'll\", \"moving on to\",\n\t\t\t\"let me update\", \"let me modify\", \"let me add\", \"let me fix\",\n\t\t\t\"let me test\", \"let me verify\", \"let me validate\",\n\t\t\t\"i need to\", \"i should\", \"we should\", \"we need to\",\n\t\t}\n\n\t\tcontentLower := strings.ToLower(content)\n\t\tfor _, signal := range unfinishedSignals {\n\t\t\tif strings.Contains(contentLower, signal) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Run_450": {
      "name": "Run",
      "type": "method",
      "start_line": 450,
      "end_line": 1252,
      "content_hash": "1b9b681f991c443dc4e8dab6dd3c24786ab83616",
      "content": "func (a *sessionAgent) Run(ctx context.Context, call SessionAgentCall) (*fantasy.AgentResult, error) {\n\t// Handle special continuation prompts\n\tisContinuation := call.Prompt == \"CONTINUE_AFTER_TOOL_EXECUTION\"\n\n\t// Check for pending retry request before processing\n\tif !isContinuation && call.Prompt != \"\" {\n\t\tif retryReq, ok := a.retryQueue.Get(call.SessionID); ok {\n\t\t\tslog.Info(\"Executing retry for recovered tool\",\n\t\t\t\t\"session_id\", call.SessionID,\n\t\t\t\t\"tool\", retryReq.ToolName,\n\t\t\t\t\"attempt\", retryReq.Attempt,\n\t\t\t)\n\t\t\t// Clear retry request\n\t\t\ta.retryQueue.Del(call.SessionID)\n\n\t\t\t// The tool will be retried automatically by the agent's tool execution loop\n\t\t\t// We just need to ensure the agent continues processing\n\t\t\tcall.Prompt = \"CONTINUE_AFTER_TOOL_EXECUTION\"\n\t\t\tisContinuation = true\n\t\t}\n\t}\n\n\t// Clear session state when any new non-continuation message is sent\n\tif !isContinuation && call.Prompt != \"\" {\n\t\ta.setSessionState(call.SessionID, \"\")\n\t}\n\n\tif call.Prompt == \"\" && !isContinuation {\n\t\treturn nil, ErrEmptyPrompt\n\t}\n\tif isContinuation {\n\t\t// For continuation, use the task context instead of just the original prompt\n\t\tcall.Prompt = a.getTaskContext(call.SessionID)\n\t\tif call.Prompt == \"\" {\n\t\t\t// Fallback if we can't get the task context\n\t\t\tcall.Prompt = \"Please continue with the previous task\"\n\t\t}\n\t}\n\tif call.SessionID == \"\" {\n\t\treturn nil, ErrSessionMissing\n\t}\n\n\t// Get or create state machine for this session\n\tsm := a.getOrCreateStateMachine(call.SessionID, ctx)\n\n\t// Transition to processing state\n\tif err := sm.TransitionTo(state.StateProcessingPrompt); err != nil {\n\t\tslog.Warn(\"failed to transition to processing state\", \"error\", err, \"session_id\", call.SessionID)\n\t}\n\n\t// Queue the message if busy\n\tif a.IsSessionBusy(call.SessionID) {\n\t\texisting, ok := a.messageQueue.Get(call.SessionID)\n\t\tif !ok {\n\t\t\texisting = []SessionAgentCall{}\n\t\t}\n\t\t// Limit queue size to prevent memory issues\n\t\tif len(existing) >= 50 {\n\t\t\treturn nil, fmt.Errorf(\"session %s: queue is full (max 50 queued requests)\", call.SessionID)\n\t\t}\n\t\texisting = append(existing, call)\n\t\ta.messageQueue.Set(call.SessionID, existing)\n\t\t// Return a specific error to indicate message was queued, not processed\n\t\treturn nil, fmt.Errorf(\"session %s: message queued (position %d in queue)\", call.SessionID, len(existing))\n\t}\n\n\tif len(a.tools) > 0 {\n\t\t// Add Anthropic caching to the last tool.\n\t\ta.tools[len(a.tools)-1].SetProviderOptions(a.getCacheControlOptions())\n\t}\n\n\tagent := fantasy.NewAgent(\n\t\ta.largeModel.Model,\n\t\tfantasy.WithSystemPrompt(a.systemPrompt),\n\t\tfantasy.WithTools(a.tools...),\n\t)\n\n\tsessionLock := sync.Mutex{}\n\tcurrentSession, err := a.sessions.Get(ctx, call.SessionID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get session: %w\", err)\n\t}\n\n\tmsgs, err := a.getSessionMessages(ctx, currentSession)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get session messages: %w\", err)\n\t}\n\n\tvar wg sync.WaitGroup\n\t// Generate title if first message.\n\tif currentSession.MessageCount == 0 {\n\t\twg.Go(func() {\n\t\t\tsessionLock.Lock()\n\t\t\ta.generateTitle(ctx, &currentSession, call.Prompt)\n\t\t\tsessionLock.Unlock()\n\t\t})\n\t\t// Ensure we wait for title generation even if there's an error\n\t\tdefer wg.Wait()\n\t}\n\n\t// Add the user message to the session.\n\t_, err = a.createUserMessage(ctx, call)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Add the session to the context.\n\tctx = context.WithValue(ctx, tools.SessionIDContextKey, call.SessionID)\n\n\t// Tool timeout enforcement is handled at coordinator level during tool creation\n\n\tgenCtx, cancel := context.WithCancel(ctx)\n\ta.activeRequests.Set(call.SessionID, cancel)\n\n\tdefer cancel()\n\tdefer a.activeRequests.Del(call.SessionID)\n\n\thistory, files := a.preparePrompt(msgs, call.Attachments...)\n\n\tstartTime := time.Now()\n\ta.eventPromptSent(call.SessionID)\n\n\t// Ensure MaxOutputTokens is at least 1 for API compatibility\n\t// Some providers (Anthropic, Google) require max_tokens >= 1\n\tmaxOutputTokens := call.MaxOutputTokens\n\tif maxOutputTokens < 1 {\n\t\tmaxOutputTokens = 4096 // Safe default\n\t\tslog.Warn(\"MaxOutputTokens was < 1, using fallback\",\n\t\t\t\"original\", call.MaxOutputTokens,\n\t\t\t\"fallback\", maxOutputTokens,\n\t\t\t\"session_id\", call.SessionID)\n\t}\n\n\tvar currentAssistant *message.Message\n\tvar shouldSummarize bool\n\tresult, err := agent.Stream(genCtx, fantasy.AgentStreamCall{\n\t\tPrompt:           call.Prompt,\n\t\tFiles:            files,\n\t\tMessages:         history,\n\t\tProviderOptions:  call.ProviderOptions,\n\t\tMaxOutputTokens:  &maxOutputTokens,\n\t\tTopP:             call.TopP,\n\t\tTemperature:      call.Temperature,\n\t\tPresencePenalty:  call.PresencePenalty,\n\t\tTopK:             call.TopK,\n\t\tFrequencyPenalty: call.FrequencyPenalty,\n\t\tPrepareStep: func(callContext context.Context, options fantasy.PrepareStepFunctionOptions) (_ context.Context, prepared fantasy.PrepareStepResult, err error) {\n\t\t\tprepared.Messages = options.Messages\n\t\t\tfor i := range prepared.Messages {\n\t\t\t\tprepared.Messages[i].ProviderOptions = nil\n\t\t\t}\n\n\t\t\t// Only process queued messages if this is NOT an auto-continuation\n\t\t\t// Auto-continuation has the special prompt \"CONTINUE_AFTER_TOOL_EXECUTION\"\n\t\t\tif call.Prompt != \"CONTINUE_AFTER_TOOL_EXECUTION\" {\n\t\t\t\tqueuedCalls, _ := a.messageQueue.Get(call.SessionID)\n\t\t\t\ta.messageQueue.Del(call.SessionID)\n\t\t\t\tfor _, queued := range queuedCalls {\n\t\t\t\t\tuserMessage, createErr := a.createUserMessage(callContext, queued)\n\t\t\t\t\tif createErr != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tprepared.Messages = append(prepared.Messages, userMessage.ToAIMessage()...)\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastSystemRoleInx := 0\n\t\t\tsystemMessageUpdated := false\n\t\t\tfor i, msg := range prepared.Messages {\n\t\t\t\t// Only add cache control to the last message.\n\t\t\t\tif msg.Role == fantasy.MessageRoleSystem {\n\t\t\t\t\tlastSystemRoleInx = i\n\t\t\t\t} else if !systemMessageUpdated {\n\t\t\t\t\tprepared.Messages[lastSystemRoleInx].ProviderOptions = a.getCacheControlOptions()\n\t\t\t\t\tsystemMessageUpdated = true\n\t\t\t\t}\n\t\t\t\t// Than add cache control to the last 2 messages.\n\t\t\t\tif i > len(prepared.Messages)-3 {\n\t\t\t\t\tprepared.Messages[i].ProviderOptions = a.getCacheControlOptions()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif promptPrefix := a.promptPrefix(); promptPrefix != \"\" {\n\t\t\t\tprepared.Messages = append([]fantasy.Message{fantasy.NewSystemMessage(promptPrefix)}, prepared.Messages...)\n\t\t\t}\n\n\t\t\tvar assistantMsg message.Message\n\t\t\tassistantMsg, err = a.messages.Create(callContext, call.SessionID, message.CreateMessageParams{\n\t\t\t\tRole:     message.Assistant,\n\t\t\t\tParts:    []message.ContentPart{},\n\t\t\t\tModel:    a.largeModel.ModelCfg.Model,\n\t\t\t\tProvider: a.largeModel.ModelCfg.Provider,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn callContext, prepared, err\n\t\t\t}\n\t\t\tcallContext = context.WithValue(callContext, tools.MessageIDContextKey, assistantMsg.ID)\n\t\t\tcallContext = context.WithValue(callContext, tools.SupportsImagesContextKey, a.largeModel.CatwalkCfg.SupportsImages)\n\t\t\tcallContext = context.WithValue(callContext, tools.ModelNameContextKey, a.largeModel.CatwalkCfg.Name)\n\t\t\tcurrentAssistant = &assistantMsg\n\n\t\t\t// Set tool_choice for Cerebras/ZAI when tools are available\n\t\t\t// This ensures tool calling works properly with GPT OSS models\n\t\t\tif (a.largeModel.ModelCfg.Provider == \"cerebras\" || a.largeModel.ModelCfg.Provider == string(catwalk.InferenceProviderZAI)) && len(prepared.Tools) > 0 {\n\t\t\t\ttoolChoice := fantasy.ToolChoiceAuto\n\t\t\t\tprepared.ToolChoice = &toolChoice\n\t\t\t} else if (a.largeModel.ModelCfg.Provider == \"cerebras\" || a.largeModel.ModelCfg.Provider == string(catwalk.InferenceProviderZAI)) && len(prepared.Tools) == 0 {\n\t\t\t\tprepared.ToolChoice = nil // Explicitly set to nil\n\t\t\t}\n\n\t\t\treturn callContext, prepared, err\n\t\t},\n\t\tOnReasoningStart: func(id string, reasoning fantasy.ReasoningContent) error {\n\t\t\tcurrentAssistant.AppendReasoningContent(reasoning.Text)\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnReasoningDelta: func(id string, text string) error {\n\t\t\tcurrentAssistant.AppendReasoningContent(text)\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnReasoningEnd: func(id string, reasoning fantasy.ReasoningContent) error {\n\t\t\t// handle anthropic signature\n\t\t\tif anthropicData, ok := reasoning.ProviderMetadata[anthropic.Name]; ok {\n\t\t\t\tif reasoning, ok := anthropicData.(*anthropic.ReasoningOptionMetadata); ok {\n\t\t\t\t\tcurrentAssistant.AppendReasoningSignature(reasoning.Signature)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif googleData, ok := reasoning.ProviderMetadata[google.Name]; ok {\n\t\t\t\tif reasoning, ok := googleData.(*google.ReasoningMetadata); ok {\n\t\t\t\t\tcurrentAssistant.AppendThoughtSignature(reasoning.Signature, reasoning.ToolID)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif openaiData, ok := reasoning.ProviderMetadata[openai.Name]; ok {\n\t\t\t\tif reasoning, ok := openaiData.(*openai.ResponsesReasoningMetadata); ok {\n\t\t\t\t\tcurrentAssistant.SetReasoningResponsesData(reasoning)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentAssistant.FinishThinking()\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnTextDelta: func(id string, text string) error {\n\t\t\t// Strip leading newline from initial text content. This is is\n\t\t\t// particularly important in non-interactive mode where leading\n\t\t\t// newlines are very visible.\n\t\t\tif len(currentAssistant.Parts) == 0 {\n\t\t\t\ttext = strings.TrimPrefix(text, \"\\n\")\n\t\t\t}\n\n\t\t\tcurrentAssistant.AppendContent(text)\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnToolInputStart: func(id string, toolName string) error {\n\t\t\ttoolCall := message.ToolCall{\n\t\t\t\tID:               id,\n\t\t\t\tName:             toolName,\n\t\t\t\tProviderExecuted: false,\n\t\t\t\tFinished:         false,\n\t\t\t}\n\t\t\tcurrentAssistant.AddToolCall(toolCall)\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnRetry: func(err *fantasy.ProviderError, delay time.Duration) {\n\t\t\t// Log the retry attempt\n\t\t\tslog.Warn(\"Provider request failed, retrying\",\n\t\t\t\t\"error\", err.Error(),\n\t\t\t\t\"delay\", delay,\n\t\t\t\t\"session_id\", currentSession.ID,\n\t\t\t)\n\n\t\t\t// Show user-facing message for rate limit errors\n\t\t\tif err.StatusCode == 429 {\n\t\t\t\t_, createErr := a.messages.Create(genCtx, currentAssistant.SessionID, message.CreateMessageParams{\n\t\t\t\t\tRole: message.System,\n\t\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\t\tmessage.TextContent{Text: \"Model is rate limited. Retrying request...\"},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif createErr != nil {\n\t\t\t\t\tslog.Error(\"Failed to create rate limit message\", \"error\", createErr, \"session_id\", currentSession.ID)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tOnToolCall: func(tc fantasy.ToolCallContent) error {\n\t\t\t// Fix Mistral tool call ID format (9 alphanumeric chars)\n\t\t\tsanitizedID := tc.ToolCallID\n\t\t\tif a.largeModel.ModelCfg.Provider == \"mistral\" || a.largeModel.ModelCfg.Provider == \"mistral-native\" {\n\t\t\t\tsanitizedID = utils.SanitizeToolCallID(tc.ToolCallID, \"mistral\")\n\t\t\t}\n\n\t\t\ttoolCall := message.ToolCall{\n\t\t\t\tID:               sanitizedID,\n\t\t\t\tName:             tc.ToolName,\n\t\t\t\tInput:            tc.Input,\n\t\t\t\tProviderExecuted: false,\n\t\t\t\tFinished:         true,\n\t\t\t}\n\t\t\tcurrentAssistant.AddToolCall(toolCall)\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tOnToolResult: func(result fantasy.ToolResultContent) error {\n\t\t\t// Get state machine for this session\n\t\t\tsm := a.getOrCreateStateMachine(currentAssistant.SessionID, genCtx)\n\n\t\t\t// Extract tool details for tracking\n\t\t\tvar errorMsg string\n\t\t\tvar toolError error\n\n\t\t\tswitch result.Result.GetType() {\n\t\t\tcase fantasy.ToolResultContentTypeError:\n\t\t\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentError](result.Result); ok {\n\t\t\t\t\terrorMsg = r.Error.Error()\n\t\t\t\t\ttoolError = r.Error\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Attempt error recovery if there's an error\n\t\t\tif toolError != nil {\n\t\t\t\texecCtx := &state.AgentExecutionContext{\n\t\t\t\t\tSessionID: currentAssistant.SessionID,\n\t\t\t\t}\n\t\t\t\trecoverableErr := a.wrapErrorForRecovery(toolError, result.ToolName, \"\", \"\", \"\")\n\t\t\t\trecoveryErr := a.recoveryRegistry.AttemptRecovery(genCtx, recoverableErr, execCtx)\n\t\t\t\tif recoveryErr != nil {\n\t\t\t\t\tslog.Error(\"Error recovery failed\",\n\t\t\t\t\t\t\"session_id\", currentAssistant.SessionID,\n\t\t\t\t\t\t\"tool\", result.ToolName,\n\t\t\t\t\t\t\"original_error\", toolError.Error(),\n\t\t\t\t\t\t\"recovery_error\", recoveryErr.Error(),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tslog.Info(\"Error recovery succeeded - scheduling retry\",\n\t\t\t\t\t\t\"session_id\", currentAssistant.SessionID,\n\t\t\t\t\t\t\"tool\", result.ToolName,\n\t\t\t\t\t\t\"error\", toolError.Error(),\n\t\t\t\t\t)\n\t\t\t\t\t// Queue retry request instead of clearing error\n\t\t\t\t\tretryReq := &RetryRequest{\n\t\t\t\t\t\tToolName: result.ToolName,\n\t\t\t\t\t\tInput:    nil, // Input will be captured from the tool call\n\t\t\t\t\t\tAttempt:  execCtx.RetryCount,\n\t\t\t\t\t}\n\t\t\t\t\ta.retryQueue.Set(currentAssistant.SessionID, retryReq)\n\t\t\t\t\terrorMsg = \"\" // Clear error to allow continuation\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Record tool call in state machine\n\t\t\t// Note: We don't have file_path/command from ToolResultContent, but tool name is tracked\n\t\t\tsuccess := errorMsg == \"\"\n\t\t\tsm.RecordToolCall(result.ToolName, \"\", \"\", errorMsg, success)\n\n\t\t\t// Check for stuck condition after each tool call\n\t\t\tif stuck, reason := sm.IsStuck(); stuck {\n\t\t\t\tslog.Warn(\"session stuck - halting\",\n\t\t\t\t\t\"session_id\", currentAssistant.SessionID,\n\t\t\t\t\t\"reason\", reason,\n\t\t\t\t\t\"tool_calls\", sm.GetToolCallCount(),\n\t\t\t\t)\n\n\t\t\t\t// Create system message about being stuck\n\t\t\t\t_, _ = a.messages.Create(genCtx, currentAssistant.SessionID, message.CreateMessageParams{\n\t\t\t\t\tRole: message.System,\n\t\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\t\tmessage.TextContent{\n\t\t\t\t\t\t\tText: fmt.Sprintf(\"\ud83d\uded1 Loop detected: %s\\n\\nStopping execution to prevent infinite loop. Please review the error and try a different approach.\", reason),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t})\n\n\t\t\t\t// Return error to halt execution\n\t\t\t\treturn fmt.Errorf(\"loop detected: %s\", reason)\n\t\t\t}\n\n\t\t\t// Track tool call for loop detection (existing AIOPS code)\n\t\t\tif a.aiops != nil {\n\t\t\t\tvar content string\n\t\t\t\tvar aiopsErrorMsg string\n\n\t\t\t\tswitch result.Result.GetType() {\n\t\t\t\tcase fantasy.ToolResultContentTypeText:\n\t\t\t\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentText](result.Result); ok {\n\t\t\t\t\t\tcontent = r.Text\n\t\t\t\t\t}\n\t\t\t\tcase fantasy.ToolResultContentTypeError:\n\t\t\t\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentError](result.Result); ok {\n\t\t\t\t\t\taiopsErrorMsg = r.Error.Error()\n\t\t\t\t\t}\n\t\t\t\tcase fantasy.ToolResultContentTypeMedia:\n\t\t\t\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentMedia](result.Result); ok {\n\t\t\t\t\t\tcontent = fmt.Sprintf(\"Loaded %s content\", r.MediaType)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif aiopsErrorMsg != \"\" {\n\t\t\t\t\tcontent = aiopsErrorMsg // Track error messages for loop detection\n\t\t\t\t}\n\n\t\t\t\t// Convert to AIOPS ToolCall for tracking\n\t\t\t\taiopsCall := aiops.ToolCall{\n\t\t\t\t\tID:        result.ToolCallID,\n\t\t\t\t\tName:      result.ToolName,\n\t\t\t\t\tResult:    content,\n\t\t\t\t\tError:     aiopsErrorMsg,\n\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t}\n\t\t\t\tif len(aiopsCall.Result) > 10000 {\n\t\t\t\t\taiopsCall.Result = aiopsCall.Result[:10000] + \"...\"\n\t\t\t\t}\n\n\t\t\t\t// Add to recent calls\n\t\t\t\ta.recentCallsLock.Lock()\n\t\t\t\tif len(a.recentCalls) >= 10 {\n\t\t\t\t\t// Keep only last 10 calls\n\t\t\t\t\tcopy(a.recentCalls, a.recentCalls[1:])\n\t\t\t\t\ta.recentCalls[len(a.recentCalls)-1] = aiopsCall\n\t\t\t\t} else {\n\t\t\t\t\ta.recentCalls = append(a.recentCalls, aiopsCall)\n\t\t\t\t}\n\n\t\t\t\t// Increment call count\n\t\t\t\ta.callCount++\n\n\t\t\t\t// Check for loops every 5 tool calls\n\t\t\t\tif a.callCount%5 == 0 && len(a.recentCalls) >= 5 {\n\t\t\t\t\tgo func(calls []aiops.ToolCall, sessionID string, agentCtx context.Context) {\n\t\t\t\t\t\tdetectCtx, cancel := context.WithTimeout(agentCtx, 2*time.Second)\n\t\t\t\t\t\tdefer cancel()\n\t\t\t\t\t\tdetection, err := a.aiops.DetectLoop(detectCtx, calls)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tslog.Debug(\"Loop detection failed\", \"error\", err, \"session_id\", sessionID)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif detection.IsLooping {\n\t\t\t\t\t\t\t// Create a system message about the loop\n\t\t\t\t\t\t\t_, createErr := a.messages.Create(genCtx, currentAssistant.SessionID, message.CreateMessageParams{\n\t\t\t\t\t\t\t\tRole: message.System,\n\t\t\t\t\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\t\t\t\t\tmessage.TextContent{\n\t\t\t\t\t\t\t\t\t\tText: fmt.Sprintf(\"\ud83d\udd01 Loop detected: %s. Suggestion: %s\", detection.Reason, detection.Suggestion),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif createErr != nil {\n\t\t\t\t\t\t\t\tslog.Error(\"Failed to create loop detection message\", \"error\", createErr, \"session_id\", sessionID)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}(a.recentCalls, currentAssistant.SessionID, genCtx)\n\t\t\t\t}\n\n\t\t\t\t// Track actions for drift detection\n\t\t\t\ta.recentActions = append(a.recentActions, aiops.Action{\n\t\t\t\t\tDescription: fmt.Sprintf(\"Tool call: %s\", result.ToolName),\n\t\t\t\t\tToolCalls: []aiops.ToolCall{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tID:        result.ToolCallID,\n\t\t\t\t\t\t\tName:      result.ToolName,\n\t\t\t\t\t\t\tParams:    map[string]any{}, // We don't have access to the original params in ToolResultContent\n\t\t\t\t\t\t\tResult:    content,\n\t\t\t\t\t\t\tError:     aiopsErrorMsg,\n\t\t\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t})\n\t\t\t\t// Keep only the last 20 actions\n\t\t\t\tif len(a.recentActions) > 20 {\n\t\t\t\t\ta.recentActions = a.recentActions[len(a.recentActions)-20:]\n\t\t\t\t}\n\t\t\t\ta.actionCount++\n\t\t\t\t// Check for drift every 10 tool calls\n\t\t\t\tif a.actionCount%10 == 0 && a.aiops != nil {\n\t\t\t\t\tgo func(actions []aiops.Action, sessionID string, agentCtx context.Context) {\n\t\t\t\t\t\tdetectCtx, cancel := context.WithTimeout(agentCtx, 2*time.Second)\n\t\t\t\t\t\tdefer cancel()\n\n\t\t\t\t\t\t// Get the original task from the first message in the session\n\t\t\t\t\t\toriginalTask := \"\"\n\t\t\t\t\t\tif msgs, err := a.messages.List(detectCtx, sessionID); err == nil && len(msgs) > 0 {\n\t\t\t\t\t\t\t// Extract task from the first user message\n\t\t\t\t\t\t\tfor _, msg := range msgs {\n\t\t\t\t\t\t\t\tif msg.Role == message.User {\n\t\t\t\t\t\t\t\t\tfor _, part := range msg.Parts {\n\t\t\t\t\t\t\t\t\t\tif tc, ok := part.(message.TextContent); ok {\n\t\t\t\t\t\t\t\t\t\t\toriginalTask = tc.Text\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif originalTask != \"\" {\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif originalTask != \"\" {\n\t\t\t\t\t\t\tdrift, err := a.aiops.DetectDrift(detectCtx, originalTask, actions)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tslog.Debug(\"Drift detection failed\", \"error\", err, \"session_id\", sessionID)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif drift.IsDrifting {\n\t\t\t\t\t\t\t\t// Create a warning message about task drift\n\t\t\t\t\t\t\t\t_, createErr := a.messages.Create(agentCtx, sessionID, message.CreateMessageParams{\n\t\t\t\t\t\t\t\t\tRole: message.System,\n\t\t\t\t\t\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\t\t\t\t\t\tmessage.TextContent{\n\t\t\t\t\t\t\t\t\t\t\tText: fmt.Sprintf(\"\u26a0\ufe0f Task drift detected: %s. Suggestion: %s\", drift.Reason, drift.Suggestion),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tif createErr != nil {\n\t\t\t\t\t\t\t\t\tslog.Error(\"Failed to create drift detection message\", \"error\", createErr, \"session_id\", sessionID)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}(a.recentActions, currentAssistant.SessionID, genCtx)\n\t\t\t\t}\n\t\t\t\ta.recentCallsLock.Unlock()\n\t\t\t}\n\n\t\t\ttoolResult := a.convertToToolResult(result)\n\t\t\t_, createMsgErr := a.messages.Create(genCtx, currentAssistant.SessionID, message.CreateMessageParams{\n\t\t\t\tRole: message.Tool,\n\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\ttoolResult,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn createMsgErr\n\t\t},\n\t\tOnStepFinish: func(stepResult fantasy.StepResult) error {\n\t\t\tfinishReason := message.FinishReasonUnknown\n\t\t\tswitch stepResult.FinishReason {\n\t\t\tcase fantasy.FinishReasonLength:\n\t\t\t\tfinishReason = message.FinishReasonMaxTokens\n\t\t\tcase fantasy.FinishReasonStop:\n\t\t\t\tfinishReason = message.FinishReasonEndTurn\n\t\t\tcase fantasy.FinishReasonToolCalls:\n\t\t\t\tfinishReason = message.FinishReasonToolUse\n\t\t\t}\n\t\t\tcurrentAssistant.AddFinish(finishReason, \"\", \"\")\n\t\t\ta.updateSessionUsage(a.largeModel, &currentSession, stepResult.Usage, a.openrouterCost(stepResult.ProviderMetadata))\n\t\t\tsessionLock.Lock()\n\t\t\t_, sessionErr := a.sessions.Save(genCtx, currentSession)\n\t\t\tsessionLock.Unlock()\n\t\t\tif sessionErr != nil {\n\t\t\t\treturn sessionErr\n\t\t\t}\n\t\t\treturn a.messages.Update(genCtx, *currentAssistant)\n\t\t},\n\t\tStopWhen: []fantasy.StopCondition{\n\t\t\tfunc(steps []fantasy.StepResult) bool {\n\t\t\t\tcw := int64(a.largeModel.CatwalkCfg.ContextWindow)\n\t\t\t\ttokens := currentSession.CompletionTokens + currentSession.PromptTokens\n\t\t\t\tremaining := cw - tokens\n\t\t\t\tvar threshold int64\n\t\t\t\tif cw > 200_000 {\n\t\t\t\t\tthreshold = 20_000\n\t\t\t\t} else {\n\t\t\t\t\tthreshold = int64(float64(cw) * 0.2)\n\t\t\t\t}\n\n\t\t\t\t// Log context usage\n\t\t\t\tpercentUsed := float64(tokens) / float64(cw) * 100\n\t\t\t\tslog.Debug(\"Context window check\",\n\t\t\t\t\t\"context_window\", cw,\n\t\t\t\t\t\"tokens_used\", tokens,\n\t\t\t\t\t\"remaining\", remaining,\n\t\t\t\t\t\"threshold\", threshold,\n\t\t\t\t\t\"percent_used\", fmt.Sprintf(\"%.1f%%\", percentUsed),\n\t\t\t\t\t\"will_summarize\", remaining <= threshold && !a.disableAutoSummarize)\n\n\t\t\t\t// Only stop if we're not actively streaming a response\n\t\t\t\tisCurrentlyStreaming := len(steps) > 0 && steps[len(steps)-1].FinishReason == \"\"\n\t\t\t\tif (remaining <= threshold) && !a.disableAutoSummarize && !isCurrentlyStreaming {\n\t\t\t\t\tslog.Info(\"Context threshold reached - triggering auto-summarization\",\n\t\t\t\t\t\t\"tokens_used\", tokens,\n\t\t\t\t\t\t\"context_window\", cw,\n\t\t\t\t\t\t\"percent_used\", fmt.Sprintf(\"%.1f%%\", percentUsed),\n\t\t\t\t\t\t\"threshold\", threshold)\n\t\t\t\t\tshouldSummarize = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t},\n\t\t},\n\t})\n\n\ta.eventPromptResponded(call.SessionID, time.Since(startTime).Truncate(time.Second))\n\n\tif err != nil {\n\t\tisCancelErr := errors.Is(err, context.Canceled)\n\t\tisPermissionErr := errors.Is(err, permission.ErrorPermissionDenied)\n\t\tif currentAssistant == nil {\n\t\t\treturn result, err\n\t\t}\n\t\t// Ensure we finish thinking on error to close the reasoning state.\n\t\tcurrentAssistant.FinishThinking()\n\t\ttoolCalls := currentAssistant.ToolCalls()\n\t\t// INFO: we use the parent context here because the genCtx has been cancelled.\n\t\tmsgs, createErr := a.messages.List(ctx, currentAssistant.SessionID)\n\t\tif createErr != nil {\n\t\t\treturn nil, createErr\n\t\t}\n\t\tfor _, tc := range toolCalls {\n\t\t\tif !tc.Finished {\n\t\t\t\ttc.Finished = true\n\t\t\t\ttc.Input = \"{}\"\n\t\t\t\tcurrentAssistant.AddToolCall(tc)\n\t\t\t\tupdateErr := a.messages.Update(ctx, *currentAssistant)\n\t\t\t\tif updateErr != nil {\n\t\t\t\t\treturn nil, updateErr\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfound := false\n\t\t\tfor _, msg := range msgs {\n\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\tfor _, tr := range msg.ToolResults() {\n\t\t\t\t\t\tif tr.ToolCallID == tc.ID {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif found {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif found {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcontent := \"There was an error while executing the tool\"\n\t\t\tisViewDirectoryHelp := false\n\t\t\tif isCancelErr {\n\t\t\t\tcontent = \"Tool execution canceled by user\"\n\t\t\t} else if isPermissionErr {\n\t\t\t\tcontent = \"User denied permission\"\n\t\t\t} else if tc.Name == \"view\" && strings.Contains(err.Error(), \"Path is a directory\") {\n\t\t\t\t// Automatic recovery for VIEW tool directory errors\n\t\t\t\t// Extract the directory path from the error message\n\t\t\t\tparts := strings.Split(err.Error(), \": \")\n\t\t\t\tif len(parts) >= 2 {\n\t\t\t\t\tdirPath := strings.TrimSpace(parts[1])\n\t\t\t\t\t// List directory contents to help AI understand what's available\n\t\t\t\t\tif dirEntries, dirErr := os.ReadDir(dirPath); dirErr == nil {\n\t\t\t\t\t\tvar fileList []string\n\t\t\t\t\t\tfor _, entry := range dirEntries {\n\t\t\t\t\t\t\tfileList = append(fileList, entry.Name())\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create helpful response with directory contents\n\t\t\t\t\t\tresponse := fmt.Sprintf(\"Path is a directory: %s\\n\\nDirectory contents:\\n\", dirPath)\n\t\t\t\t\t\tfor i, file := range fileList {\n\t\t\t\t\t\t\tresponse += fmt.Sprintf(\"%d. %s\\n\", i+1, file)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse += \"\\n\ud83d\udca1 Suggestions:\\n\"\n\t\t\t\t\t\tresponse += \"- Use 'view' with a specific file path (e.g., 'view \" + dirPath + \"/filename')\\n\"\n\t\t\t\t\t\tresponse += \"- Use 'ls' command to explore directory structure\\n\"\n\t\t\t\t\t\tresponse += \"- Try 'find' to search for specific files\\n\"\n\n\t\t\t\t\t\tcontent = response\n\t\t\t\t\t\t// Don't mark as error - this is a helpful response\n\t\t\t\t\t\tisViewDirectoryHelp = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent = fmt.Sprintf(\"Path is a directory: %s. Cannot read directory contents: %v\", dirPath, dirErr)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontent = \"Path is a directory. Cannot extract directory path from error.\"\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoolResult := message.ToolResult{\n\t\t\t\tToolCallID: tc.ID,\n\t\t\t\tName:       tc.Name,\n\t\t\t\tContent:    content,\n\t\t\t\tIsError:    true && !isViewDirectoryHelp,\n\t\t\t}\n\t\t\t_, createErr = a.messages.Create(context.Background(), currentAssistant.SessionID, message.CreateMessageParams{\n\t\t\t\tRole: message.Tool,\n\t\t\t\tParts: []message.ContentPart{\n\t\t\t\t\ttoolResult,\n\t\t\t\t},\n\t\t\t})\n\t\t\tif createErr != nil {\n\t\t\t\treturn nil, createErr\n\t\t\t}\n\t\t}\n\t\tvar fantasyErr *fantasy.Error\n\t\tvar providerErr *fantasy.ProviderError\n\t\tconst defaultTitle = \"Provider Error\"\n\t\tif isCancelErr {\n\t\t\tcurrentAssistant.AddFinish(message.FinishReasonCanceled, \"User canceled request\", \"\")\n\t\t} else if isPermissionErr {\n\t\t\tcurrentAssistant.AddFinish(message.FinishReasonPermissionDenied, \"User denied permission\", \"\")\n\t\t} else if errors.As(err, &providerErr) {\n\t\t\tcurrentAssistant.AddFinish(message.FinishReasonError, cmp.Or(stringext.Capitalize(providerErr.Title), defaultTitle), providerErr.Message)\n\t\t} else if errors.As(err, &fantasyErr) {\n\t\t\tcurrentAssistant.AddFinish(message.FinishReasonError, cmp.Or(stringext.Capitalize(fantasyErr.Title), defaultTitle), fantasyErr.Message)\n\t\t} else {\n\t\t\tcurrentAssistant.AddFinish(message.FinishReasonError, defaultTitle, err.Error())\n\t\t}\n\t\t// Note: we use the parent context here because the genCtx has been\n\t\t// cancelled.\n\t\tupdateErr := a.messages.Update(ctx, *currentAssistant)\n\t\tif updateErr != nil {\n\t\t\treturn nil, updateErr\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif shouldSummarize {\n\t\ta.activeRequests.Del(call.SessionID)\n\t\tif summarizeErr := a.Summarize(genCtx, call.SessionID, call.ProviderOptions); summarizeErr != nil {\n\t\t\treturn nil, summarizeErr\n\t\t}\n\t\t// If the agent wasn't done...\n\t\tif len(currentAssistant.ToolCalls()) > 0 {\n\t\t\texisting, ok := a.messageQueue.Get(call.SessionID)\n\t\t\tif !ok {\n\t\t\t\texisting = []SessionAgentCall{}\n\t\t\t}\n\t\t\tcall.Prompt = fmt.Sprintf(\"The previous session was interrupted because it got too long, the initial user request was: `%s`\", call.Prompt)\n\t\t\texisting = append(existing, call)\n\t\t\ta.messageQueue.Set(call.SessionID, existing)\n\t\t}\n\t}\n\n\t// Check for queued messages before cleaning up\n\tqueuedMessages, ok := a.messageQueue.Get(call.SessionID)\n\tif !ok || len(queuedMessages) == 0 {\n\t\t// No queued messages\n\t\ta.activeRequests.Del(call.SessionID)\n\n\t\t// Check if we have tool calls that were just completed\n\t\t// If we have tool results but no more queued messages, we need to continue\n\t\t// the conversation by calling Run again with an empty prompt\n\t\thasToolResults := false\n\t\tif messages, err := a.messages.List(ctx, currentAssistant.SessionID); err == nil {\n\t\t\tfor _, msg := range messages {\n\t\t\t\tif msg.Role == message.Tool {\n\t\t\t\t\thasToolResults = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we just completed tool calls, continue the conversation\n\t\t// Also check if the AI response indicates unfinished work\n\t\tshouldContinue := hasToolResults && currentAssistant != nil && len(currentAssistant.ToolCalls()) > 0\n\t\tif !shouldContinue && a.convoMgr.IsConversationCompleted(call.SessionID) {\n\t\t\t// Don/'t continue - conversation is marked as completed\n\t\t\tcancel()\n\t\t\treturn result, err\n\t\t}\n\n\t\t// Record the assistant message and let the manager handle state\n\t\tif currentAssistant != nil {\n\t\t\ta.convoMgr.RecordMessage(call.SessionID, *currentAssistant)\n\t\t}\n\n\t\tif !shouldContinue && a.shouldContinueAfterTool(ctx, call.SessionID, currentAssistant) {\n\t\t\t// Auto-continue if the AI response suggests unfinished work\n\t\t\tshouldContinue = true\n\t\t}\n\n\t\t// Check for unfinished work and set session state instead of auto-continuing\n\t\tif !shouldContinue && a.hasUnfinishedWork(ctx, call.SessionID) {\n\t\t\ta.setSessionState(call.SessionID, \"awaiting_continuation\")\n\t\t\t// Don't continue automatically - wait for explicit continue command or button\n\t\t} else {\n\t\t\t// Clear the session state if we're continuing or work is done\n\t\t\ta.setSessionState(call.SessionID, \"\")\n\t\t}\n\n\t\tif shouldContinue {\n\t\t\t// Create a new context for the next run but don't cancel the parent\n\t\t\tnextRunCtx := context.WithValue(ctx, tools.SessionIDContextKey, call.SessionID)\n\t\t\t// Run with special continuation prompt to continue after tool execution\n\t\t\treturn a.Run(nextRunCtx, SessionAgentCall{\n\t\t\t\tSessionID:       call.SessionID,\n\t\t\t\tPrompt:          \"CONTINUE_AFTER_TOOL_EXECUTION\", // Special prompt to continue\n\t\t\t\tProviderOptions: call.ProviderOptions,\n\t\t\t})\n\t\t}\n\n\t\t// Otherwise, clean up and return\n\t\tcancel()\n\t\treturn result, err\n\t}\n\n\t// Has queued messages, create new context for next run\n\tfirstQueuedMessage := queuedMessages[0]\n\ta.messageQueue.Set(call.SessionID, queuedMessages[1:])\n\n\t// Release active request for this call, but don't cancel parent context\n\ta.activeRequests.Del(call.SessionID)\n\n\t// Start new run with fresh context to avoid cancellation propagation\n\tnextRunCtx := context.WithValue(ctx, tools.SessionIDContextKey, call.SessionID)\n\treturn a.Run(nextRunCtx, firstQueuedMessage)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Summarize_1253": {
      "name": "Summarize",
      "type": "method",
      "start_line": 1253,
      "end_line": 1389,
      "content_hash": "b4b6b1e83115442613b9678acaaaf64c54ef0ee6",
      "content": "func (a *sessionAgent) Summarize(ctx context.Context, sessionID string, opts fantasy.ProviderOptions) error {\n\tif a.IsSessionBusy(sessionID) {\n\t\treturn ErrSessionBusy\n\t}\n\n\tcurrentSession, err := a.sessions.Get(ctx, sessionID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get session: %w\", err)\n\t}\n\tmsgs, err := a.getSessionMessages(ctx, currentSession)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(msgs) == 0 {\n\t\t// Nothing to summarize.\n\t\treturn nil\n\t}\n\n\taiMsgs, _ := a.preparePrompt(msgs)\n\n\tgenCtx, cancel := context.WithCancel(ctx)\n\ta.activeRequests.Set(sessionID, cancel)\n\tdefer a.activeRequests.Del(sessionID)\n\tdefer cancel()\n\n\t// Provider-specific summarization model selection:\n\t// Cerebras GLM-4.6 struggles with summarization at 180K tokens (90% threshold),\n\t// so we use the smaller, more reliable llama3.1-8b model for summarization.\n\t// Other providers continue using their large models as before.\n\n\t// Use smaller model for Cerebras summarization (more reliable at 180K)\n\tvar agent fantasy.Agent\n\tvar summarizationModel Model\n\tvar summarizationOpts fantasy.ProviderOptions\n\tif strings.Contains(a.largeModel.Model.Model(), \"glm-4.6\") || strings.Contains(a.largeModel.Model.Provider(), \"cerebras\") {\n\t\tagent = fantasy.NewAgent(a.smallModel.Model,\n\t\t\tfantasy.WithSystemPrompt(string(summaryPrompt)),\n\t\t)\n\t\tsummarizationModel = a.smallModel\n\t\t// Clear provider options when switching models - they may not be compatible\n\t\tsummarizationOpts = fantasy.ProviderOptions{}\n\t} else {\n\t\tagent = fantasy.NewAgent(a.largeModel.Model,\n\t\t\tfantasy.WithSystemPrompt(string(summaryPrompt)),\n\t\t)\n\t\tsummarizationModel = a.largeModel\n\t\tsummarizationOpts = opts\n\t}\n\tsummaryMessage, err := a.messages.Create(ctx, sessionID, message.CreateMessageParams{\n\t\tRole:             message.Assistant,\n\t\tModel:            summarizationModel.Model.Model(),\n\t\tProvider:         summarizationModel.Model.Provider(),\n\t\tIsSummaryMessage: true,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure Anthropic compatibility - max tokens must be >= 1\n\tmaxOutputTokens := summarizationModel.CatwalkCfg.DefaultMaxTokens\n\tif maxOutputTokens < 1 {\n\t\tslog.Warn(\"Invalid DefaultMaxTokens for summarization, using fallback\",\n\t\t\t\"model\", summarizationModel.Model.Model(),\n\t\t\t\"defaultMaxTokens\", maxOutputTokens)\n\t\tmaxOutputTokens = 4096\n\t}\n\n\tresp, err := agent.Stream(genCtx, fantasy.AgentStreamCall{\n\t\tPrompt:          \"Provide a detailed summary of our conversation above.\",\n\t\tMessages:        aiMsgs,\n\t\tProviderOptions: summarizationOpts,\n\t\tMaxOutputTokens: &maxOutputTokens,\n\t\tPrepareStep: func(callContext context.Context, options fantasy.PrepareStepFunctionOptions) (_ context.Context, prepared fantasy.PrepareStepResult, err error) {\n\t\t\tprepared.Messages = options.Messages\n\t\t\tif a.systemPromptPrefix != \"\" {\n\t\t\t\tprepared.Messages = append([]fantasy.Message{fantasy.NewSystemMessage(a.systemPromptPrefix)}, prepared.Messages...)\n\t\t\t}\n\t\t\treturn callContext, prepared, nil\n\t\t},\n\t\tOnReasoningDelta: func(id string, text string) error {\n\t\t\tsummaryMessage.AppendReasoningContent(text)\n\t\t\treturn a.messages.Update(genCtx, summaryMessage)\n\t\t},\n\t\tOnReasoningEnd: func(id string, reasoning fantasy.ReasoningContent) error {\n\t\t\t// Handle anthropic signature.\n\t\t\tif anthropicData, ok := reasoning.ProviderMetadata[\"anthropic\"]; ok {\n\t\t\t\tif signature, ok := anthropicData.(*anthropic.ReasoningOptionMetadata); ok && signature.Signature != \"\" {\n\t\t\t\t\tsummaryMessage.AppendReasoningSignature(signature.Signature)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsummaryMessage.FinishThinking()\n\t\t\treturn a.messages.Update(genCtx, summaryMessage)\n\t\t},\n\t\tOnTextDelta: func(id, text string) error {\n\t\t\tsummaryMessage.AppendContent(text)\n\t\t\treturn a.messages.Update(genCtx, summaryMessage)\n\t\t},\n\t})\n\tif err != nil {\n\t\tisCancelErr := errors.Is(err, context.Canceled)\n\t\tif isCancelErr {\n\t\t\t// User cancelled summarize we need to remove the summary message.\n\t\t\tdeleteErr := a.messages.Delete(ctx, summaryMessage.ID)\n\t\t\treturn deleteErr\n\t\t}\n\t\treturn err\n\t}\n\n\tsummaryMessage.AddFinish(message.FinishReasonEndTurn, \"\", \"\")\n\terr = a.messages.Update(genCtx, summaryMessage)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar openrouterCost *float64\n\tfor _, step := range resp.Steps {\n\t\tstepCost := a.openrouterCost(step.ProviderMetadata)\n\t\tif stepCost != nil {\n\t\t\tnewCost := *stepCost\n\t\t\tif openrouterCost != nil {\n\t\t\t\tnewCost += *openrouterCost\n\t\t\t}\n\t\t\topenrouterCost = &newCost\n\t\t}\n\t}\n\n\ta.updateSessionUsage(a.largeModel, &currentSession, resp.TotalUsage, openrouterCost)\n\n\t// Just in case, get just the last usage info.\n\tusage := resp.Response.Usage\n\tcurrentSession.SummaryMessageID = summaryMessage.ID\n\tcurrentSession.CompletionTokens = usage.OutputTokens\n\tcurrentSession.PromptTokens = 0\n\t_, err = a.sessions.Save(genCtx, currentSession)\n\treturn err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getCacheControlOptions_1390": {
      "name": "getCacheControlOptions",
      "type": "method",
      "start_line": 1390,
      "end_line": 1403,
      "content_hash": "2529ebc91cff136d8535d740225deb1b8af59d34",
      "content": "func (a *sessionAgent) getCacheControlOptions() fantasy.ProviderOptions {\n\tif t, _ := strconv.ParseBool(os.Getenv(\"NEXORA_DISABLE_ANTHROPIC_CACHE\")); t {\n\t\treturn fantasy.ProviderOptions{}\n\t}\n\treturn fantasy.ProviderOptions{\n\t\tanthropic.Name: &anthropic.ProviderCacheControlOptions{\n\t\t\tCacheControl: anthropic.CacheControl{Type: \"ephemeral\"},\n\t\t},\n\t\tbedrock.Name: &anthropic.ProviderCacheControlOptions{\n\t\t\tCacheControl: anthropic.CacheControl{Type: \"ephemeral\"},\n\t\t},\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createUserMessage_1404": {
      "name": "createUserMessage",
      "type": "method",
      "start_line": 1404,
      "end_line": 1420,
      "content_hash": "05f7fc2dcda3f143ec277c03e159aa07a7f03055",
      "content": "func (a *sessionAgent) createUserMessage(ctx context.Context, call SessionAgentCall) (message.Message, error) {\n\tvar attachmentParts []message.ContentPart\n\tfor _, attachment := range call.Attachments {\n\t\tattachmentParts = append(attachmentParts, message.BinaryContent{Path: attachment.FilePath, MIMEType: attachment.MimeType, Data: attachment.Content})\n\t}\n\tparts := []message.ContentPart{message.TextContent{Text: call.Prompt}}\n\tparts = append(parts, attachmentParts...)\n\tmsg, err := a.messages.Create(ctx, call.SessionID, message.CreateMessageParams{\n\t\tRole:  message.User,\n\t\tParts: parts,\n\t})\n\tif err != nil {\n\t\treturn message.Message{}, fmt.Errorf(\"failed to create user message: %w\", err)\n\t}\n\treturn msg, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_preparePrompt_1421": {
      "name": "preparePrompt",
      "type": "method",
      "start_line": 1421,
      "end_line": 1446,
      "content_hash": "6e4ccd0c76b3d2903fb2110e338192f69bd7949a",
      "content": "func (a *sessionAgent) preparePrompt(msgs []message.Message, attachments ...message.Attachment) ([]fantasy.Message, []fantasy.FilePart) {\n\tvar history []fantasy.Message\n\tfor _, m := range msgs {\n\t\tif len(m.Parts) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// Assistant message without content or tool calls (cancelled before it\n\t\t// returned anything).\n\t\tif m.Role == message.Assistant && len(m.ToolCalls()) == 0 && m.Content().Text == \"\" && m.ReasoningContent().String() == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\thistory = append(history, m.ToAIMessage()...)\n\t}\n\n\tvar files []fantasy.FilePart\n\tfor _, attachment := range attachments {\n\t\tfiles = append(files, fantasy.FilePart{\n\t\t\tFilename:  attachment.FileName,\n\t\t\tData:      attachment.Content,\n\t\t\tMediaType: attachment.MimeType,\n\t\t})\n\t}\n\n\treturn history, files\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSessionMessages_1447": {
      "name": "getSessionMessages",
      "type": "method",
      "start_line": 1447,
      "end_line": 1468,
      "content_hash": "fff09d3ff353e99b58586ec9860824672bab135c",
      "content": "func (a *sessionAgent) getSessionMessages(ctx context.Context, session session.Session) ([]message.Message, error) {\n\tmsgs, err := a.messages.List(ctx, session.ID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list messages: %w\", err)\n\t}\n\n\tif session.SummaryMessageID != \"\" {\n\t\tsummaryMsgInex := -1\n\t\tfor i, msg := range msgs {\n\t\t\tif msg.ID == session.SummaryMessageID {\n\t\t\t\tsummaryMsgInex = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif summaryMsgInex != -1 {\n\t\t\tmsgs = msgs[summaryMsgInex:]\n\t\t\tmsgs[0].Role = message.User\n\t\t}\n\t}\n\treturn msgs, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generateTitle_1469": {
      "name": "generateTitle",
      "type": "method",
      "start_line": 1469,
      "end_line": 1597,
      "content_hash": "b21930e95d0ab1c8d3005d0cc5c8cf48850916de",
      "content": "func (a *sessionAgent) generateTitle(ctx context.Context, session *session.Session, prompt string) {\n\tif prompt == \"\" {\n\t\tslog.Debug(\"generateTitle: empty prompt, returning\")\n\t\treturn\n\t}\n\n\tslog.Debug(\"generateTitle: starting\",\n\t\t\"session_id\", session.ID,\n\t\t\"small_model\", a.smallModel.ModelCfg.Model,\n\t\t\"provider\", a.smallModel.ModelCfg.Provider)\n\n\tvar maxOutput int64 = 40\n\tif a.smallModel.CatwalkCfg.CanReason {\n\t\tmaxOutput = a.smallModel.CatwalkCfg.DefaultMaxTokens\n\t}\n\n\t// Ensure max_tokens is at least 1 for Anthropic API compatibility\n\tif maxOutput < 1 {\n\t\tmaxOutput = 40\n\t}\n\n\tagent := fantasy.NewAgent(a.smallModel.Model,\n\t\tfantasy.WithSystemPrompt(string(titlePrompt)+\"\\n /no_think\"),\n\t)\n\n\tresp, err := agent.Stream(ctx, fantasy.AgentStreamCall{\n\t\tPrompt:          fmt.Sprintf(\"Generate a concise title for the following content:\\n\\n%s\\n <think>\\n\\n</think>\", prompt),\n\t\tMaxOutputTokens: &maxOutput,\n\t\tPrepareStep: func(callContext context.Context, options fantasy.PrepareStepFunctionOptions) (_ context.Context, prepared fantasy.PrepareStepResult, err error) {\n\t\t\tprepared.Messages = options.Messages\n\t\t\tif a.systemPromptPrefix != \"\" {\n\t\t\t\tprepared.Messages = append([]fantasy.Message{fantasy.NewSystemMessage(a.systemPromptPrefix)}, prepared.Messages...)\n\t\t\t}\n\t\t\treturn callContext, prepared, nil\n\t\t},\n\t})\n\tif err != nil {\n\t\tslog.Error(\"error generating title, using prompt fallback\",\n\t\t\t\"err\", err,\n\t\t\t\"session_id\", session.ID,\n\t\t\t\"model\", a.smallModel.ModelCfg.Model,\n\t\t\t\"provider\", a.smallModel.ModelCfg.Provider)\n\t\t// Fallback: use first 50 chars of prompt\n\t\ttitle := prompt\n\t\tif len(title) > 50 {\n\t\t\ttitle = title[:50] + \"...\"\n\t\t}\n\t\tif title == \"\" {\n\t\t\ttitle = \"Conversation\"\n\t\t}\n\t\tsession.Title = title\n\t\t// Save the fallback title\n\t\tif _, saveErr := a.sessions.Save(ctx, *session); saveErr != nil {\n\t\t\tslog.Error(\"failed to save fallback title\",\n\t\t\t\t\"error\", saveErr,\n\t\t\t\t\"session_id\", session.ID,\n\t\t\t\t\"title\", title)\n\t\t}\n\t\treturn\n\t}\n\n\tslog.Debug(\"generateTitle: received response\",\n\t\t\"session_id\", session.ID,\n\t\t\"content_preview\", func() string {\n\t\t\tcontent := resp.Response.Content.Text()\n\t\t\tif len(content) > 100 {\n\t\t\t\treturn content[:100] + \"...\"\n\t\t\t}\n\t\t\treturn content\n\t\t}())\n\n\ttitle := resp.Response.Content.Text()\n\n\ttitle = strings.ReplaceAll(title, \"\\n\", \" \")\n\n\t// Remove thinking tags if present.\n\tif idx := strings.Index(title, \"</think>\"); idx > 0 {\n\t\ttitle = title[idx+len(\"</think>\"):]\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title == \"\" {\n\t\tslog.Warn(\"failed to generate title, using prompt fallback\",\n\t\t\t\"warn\", \"empty title\",\n\t\t\t\"session_id\", session.ID,\n\t\t\t\"original_response\", resp.Response.Content.Text())\n\t\t// Fallback: use first 50 chars of prompt\n\t\ttitle = prompt\n\t\tif len(title) > 50 {\n\t\t\ttitle = title[:50] + \"...\"\n\t\t}\n\t\t// If still empty, use a default\n\t\tif title == \"\" {\n\t\t\ttitle = \"Conversation\"\n\t\t}\n\t}\n\n\tslog.Info(\"generateTitle: generated new title\",\n\t\t\"session_id\", session.ID,\n\t\t\"title\", title,\n\t\t\"old_title\", session.Title)\n\n\tsession.Title = title\n\n\tvar openrouterCost *float64\n\tfor _, step := range resp.Steps {\n\t\tstepCost := a.openrouterCost(step.ProviderMetadata)\n\t\tif stepCost != nil {\n\t\t\tnewCost := *stepCost\n\t\t\tif openrouterCost != nil {\n\t\t\t\tnewCost += *openrouterCost\n\t\t\t}\n\t\t\topenrouterCost = &newCost\n\t\t}\n\t}\n\n\ta.updateSessionUsage(a.smallModel, session, resp.TotalUsage, openrouterCost)\n\t_, saveErr := a.sessions.Save(ctx, *session)\n\tif saveErr != nil {\n\t\tslog.Error(\"failed to save session title & usage\",\n\t\t\t\"error\", saveErr,\n\t\t\t\"session_id\", session.ID,\n\t\t\t\"title\", title)\n\t\treturn\n\t}\n\tslog.Debug(\"generateTitle: successfully saved new title\",\n\t\t\"session_id\", session.ID)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_openrouterCost_1598": {
      "name": "openrouterCost",
      "type": "method",
      "start_line": 1598,
      "end_line": 1610,
      "content_hash": "7fed6514f5165c718eb939756efb615c878826c8",
      "content": "func (a *sessionAgent) openrouterCost(metadata fantasy.ProviderMetadata) *float64 {\n\topenrouterMetadata, ok := metadata[openrouter.Name]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\topts, ok := openrouterMetadata.(*openrouter.ProviderMetadata)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn &opts.Usage.Cost\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateSessionUsage_1611": {
      "name": "updateSessionUsage",
      "type": "method",
      "start_line": 1611,
      "end_line": 1633,
      "content_hash": "bbf892026570fb91ac11a618755ebe59993a0979",
      "content": "func (a *sessionAgent) updateSessionUsage(model Model, session *session.Session, usage fantasy.Usage, overrideCost *float64) {\n\tmodelConfig := model.CatwalkCfg\n\tcost := modelConfig.CostPer1MInCached/1e6*float64(usage.CacheCreationTokens) +\n\t\tmodelConfig.CostPer1MOutCached/1e6*float64(usage.CacheReadTokens) +\n\t\tmodelConfig.CostPer1MIn/1e6*float64(usage.InputTokens) +\n\t\tmodelConfig.CostPer1MOut/1e6*float64(usage.OutputTokens)\n\n\tif a.isClaudeCode() {\n\t\tcost = 0\n\t}\n\n\ta.eventTokensUsed(session.ID, model, usage, cost)\n\n\tif overrideCost != nil {\n\t\tsession.Cost += *overrideCost\n\t} else {\n\t\tsession.Cost += cost\n\t}\n\n\tsession.CompletionTokens = usage.OutputTokens + usage.CacheReadTokens\n\tsession.PromptTokens = usage.InputTokens + usage.CacheCreationTokens\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Cancel_1634": {
      "name": "Cancel",
      "type": "method",
      "start_line": 1634,
      "end_line": 1652,
      "content_hash": "771a1a6968a6a679716a3e6be8a81984dbe5d233",
      "content": "func (a *sessionAgent) Cancel(sessionID string) {\n\t// Cancel regular requests.\n\tif cancel, ok := a.activeRequests.Take(sessionID); ok && cancel != nil {\n\t\tslog.Info(\"Request cancellation initiated\", \"session_id\", sessionID)\n\t\tcancel()\n\t}\n\n\t// Also check for summarize requests.\n\tif cancel, ok := a.activeRequests.Take(sessionID + \"-summarize\"); ok && cancel != nil {\n\t\tslog.Info(\"Summarize cancellation initiated\", \"session_id\", sessionID)\n\t\tcancel()\n\t}\n\n\tif a.QueuedPrompts(sessionID) > 0 {\n\t\tslog.Info(\"Clearing queued prompts\", \"session_id\", sessionID)\n\t\ta.messageQueue.Del(sessionID)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ClearQueue_1653": {
      "name": "ClearQueue",
      "type": "method",
      "start_line": 1653,
      "end_line": 1659,
      "content_hash": "9a44c2d1fcde5889a8b1a68b5664b78b6264c837",
      "content": "func (a *sessionAgent) ClearQueue(sessionID string) {\n\tif a.QueuedPrompts(sessionID) > 0 {\n\t\tslog.Info(\"Clearing queued prompts\", \"session_id\", sessionID)\n\t\ta.messageQueue.Del(sessionID)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CancelAll_1660": {
      "name": "CancelAll",
      "type": "method",
      "start_line": 1660,
      "end_line": 1678,
      "content_hash": "59d361b32e1dda4aafbac22770ea247f19f75460",
      "content": "func (a *sessionAgent) CancelAll() {\n\tif !a.IsBusy() {\n\t\treturn\n\t}\n\tfor key := range a.activeRequests.Seq2() {\n\t\ta.Cancel(key) // key is sessionID\n\t}\n\n\ttimeout := time.After(5 * time.Second)\n\tfor a.IsBusy() {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn\n\t\tdefault:\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsBusy_1679": {
      "name": "IsBusy",
      "type": "method",
      "start_line": 1679,
      "end_line": 1689,
      "content_hash": "c96f269f621e392cc5407c388d56a21f8e2cf670",
      "content": "func (a *sessionAgent) IsBusy() bool {\n\tvar busy bool\n\tfor cancelFunc := range a.activeRequests.Seq() {\n\t\tif cancelFunc != nil {\n\t\t\tbusy = true\n\t\t\tbreak\n\t\t}\n\t}\n\treturn busy\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsSessionBusy_1690": {
      "name": "IsSessionBusy",
      "type": "method",
      "start_line": 1690,
      "end_line": 1694,
      "content_hash": "3b9ff0d0f2fcaab1247950467abf78202a6a9888",
      "content": "func (a *sessionAgent) IsSessionBusy(sessionID string) bool {\n\t_, busy := a.activeRequests.Get(sessionID)\n\treturn busy\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_QueuedPrompts_1695": {
      "name": "QueuedPrompts",
      "type": "method",
      "start_line": 1695,
      "end_line": 1702,
      "content_hash": "dab426c6289e3f5599bf8fd7462f374d041e3427",
      "content": "func (a *sessionAgent) QueuedPrompts(sessionID string) int {\n\tl, ok := a.messageQueue.Get(sessionID)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn len(l)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetModels_1703": {
      "name": "SetModels",
      "type": "method",
      "start_line": 1703,
      "end_line": 1707,
      "content_hash": "d5bb66ce6c7a2c6f49c6bf68f31c91e2d09a345a",
      "content": "func (a *sessionAgent) SetModels(large Model, small Model) {\n\ta.largeModel = large\n\ta.smallModel = small\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetTools_1708": {
      "name": "SetTools",
      "type": "method",
      "start_line": 1708,
      "end_line": 1711,
      "content_hash": "7394acf94f8e33640ccbf40ffcbc3318be7f0a08",
      "content": "func (a *sessionAgent) SetTools(tools []fantasy.AgentTool) {\n\ta.tools = tools\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Model_1712": {
      "name": "Model",
      "type": "method",
      "start_line": 1712,
      "end_line": 1715,
      "content_hash": "27eb2fcaef63e861dcac9d1931078a63ce580464",
      "content": "func (a *sessionAgent) Model() Model {\n\treturn a.largeModel\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_promptPrefix_1716": {
      "name": "promptPrefix",
      "type": "method",
      "start_line": 1716,
      "end_line": 1722,
      "content_hash": "3a5f44c6c33812c59adf9048cb266f2b56e742f7",
      "content": "func (a *sessionAgent) promptPrefix() string {\n\tif a.isClaudeCode() {\n\t\treturn \"You are Claude Code, Anthropic's official CLI for Claude.\"\n\t}\n\treturn a.systemPromptPrefix\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isClaudeCode_1723": {
      "name": "isClaudeCode",
      "type": "method",
      "start_line": 1723,
      "end_line": 1729,
      "content_hash": "95ceac20ed3b7968f2024e219427adbedc13d9eb",
      "content": "func (a *sessionAgent) isClaudeCode() bool {\n\tcfg := config.Get()\n\tpc, ok := cfg.Providers.Get(a.largeModel.ModelCfg.Provider)\n\treturn ok && pc.ID == string(catwalk.InferenceProviderAnthropic) && pc.OAuthToken != nil\n}\n\n// convertToToolResult converts a fantasy tool result to a message tool result.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_convertToToolResult_1730": {
      "name": "convertToToolResult",
      "type": "method",
      "start_line": 1730,
      "end_line": 1782,
      "content_hash": "a0eb89748c633829aa78e94a7bf5864aeb0215de",
      "content": "func (a *sessionAgent) convertToToolResult(result fantasy.ToolResultContent) message.ToolResult {\n\tbaseResult := message.ToolResult{\n\t\tToolCallID: result.ToolCallID,\n\t\tName:       result.ToolName,\n\t\tMetadata:   result.ClientMetadata,\n\t}\n\n\tswitch result.Result.GetType() {\n\tcase fantasy.ToolResultContentTypeText:\n\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentText](result.Result); ok {\n\t\t\tbaseResult.Content = r.Text\n\t\t}\n\tcase fantasy.ToolResultContentTypeError:\n\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentError](result.Result); ok {\n\t\t\tbaseResult.Content = r.Error.Error()\n\t\t\tbaseResult.IsError = true\n\t\t}\n\tcase fantasy.ToolResultContentTypeMedia:\n\t\tif r, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentMedia](result.Result); ok {\n\t\t\tcontent := r.Text\n\t\t\tif content == \"\" {\n\t\t\t\tcontent = fmt.Sprintf(\"Loaded %s content\", r.MediaType)\n\t\t\t}\n\t\t\tbaseResult.Content = content\n\t\t\tbaseResult.Data = r.Data\n\t\t\tbaseResult.MIMEType = r.MediaType\n\t\t}\n\t}\n\n\treturn baseResult\n}\n\n// workaroundProviderMediaLimitations converts media content in tool results to\n// user messages for providers that don't natively support images in tool results.\n//\n// Problem: OpenAI, Google, OpenRouter, and other OpenAI-compatible providers\n// don't support sending images/media in tool result messages - they only accept\n// text in tool results. However, they DO support images in user messages.\n//\n// If we send media in tool results to these providers, the API returns an error.\n//\n// Solution: For these providers, we:\n//  1. Replace the media in the tool result with a text placeholder\n//  2. Inject a user message immediately after with the image as a file attachment\n//  3. This maintains the tool execution flow while working around API limitations\n//\n// Anthropic and Bedrock support images natively in tool results, so we skip\n// this workaround for them.\n//\n// Example transformation:\n//\n//\tBEFORE: [tool result: image data]\n//\tAFTER:  [tool result: \"Image loaded - see attached\"], [user: image attachment]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_workaroundProviderMediaLimitations_1783": {
      "name": "workaroundProviderMediaLimitations",
      "type": "method",
      "start_line": 1783,
      "end_line": 1851,
      "content_hash": "37b8978b880282e43dc2ce828d7d9d599f255ad4",
      "content": "func (a *sessionAgent) workaroundProviderMediaLimitations(messages []fantasy.Message) []fantasy.Message {\n\tproviderSupportsMedia := a.largeModel.ModelCfg.Provider == string(catwalk.InferenceProviderAnthropic) ||\n\t\ta.largeModel.ModelCfg.Provider == string(catwalk.InferenceProviderBedrock)\n\n\tif providerSupportsMedia {\n\t\treturn messages\n\t}\n\n\tconvertedMessages := make([]fantasy.Message, 0, len(messages))\n\n\tfor _, msg := range messages {\n\t\tif msg.Role != fantasy.MessageRoleTool {\n\t\t\tconvertedMessages = append(convertedMessages, msg)\n\t\t\tcontinue\n\t\t}\n\n\t\ttextParts := make([]fantasy.MessagePart, 0, len(msg.Content))\n\t\tvar mediaFiles []fantasy.FilePart\n\n\t\tfor _, part := range msg.Content {\n\t\t\ttoolResult, ok := fantasy.AsMessagePart[fantasy.ToolResultPart](part)\n\t\t\tif !ok {\n\t\t\t\ttextParts = append(textParts, part)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif media, ok := fantasy.AsToolResultOutputType[fantasy.ToolResultOutputContentMedia](toolResult.Output); ok {\n\t\t\t\tdecoded, err := base64.StdEncoding.DecodeString(media.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.Warn(\"failed to decode media data\", \"error\", err)\n\t\t\t\t\ttextParts = append(textParts, part)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tmediaFiles = append(mediaFiles, fantasy.FilePart{\n\t\t\t\t\tData:      decoded,\n\t\t\t\t\tMediaType: media.MediaType,\n\t\t\t\t\tFilename:  fmt.Sprintf(\"tool-result-%s\", toolResult.ToolCallID),\n\t\t\t\t})\n\n\t\t\t\ttextParts = append(textParts, fantasy.ToolResultPart{\n\t\t\t\t\tToolCallID: toolResult.ToolCallID,\n\t\t\t\t\tOutput: fantasy.ToolResultOutputContentText{\n\t\t\t\t\t\tText: \"[Image/media content loaded - see attached file]\",\n\t\t\t\t\t},\n\t\t\t\t\tProviderOptions: toolResult.ProviderOptions,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\ttextParts = append(textParts, part)\n\t\t\t}\n\t\t}\n\n\t\tconvertedMessages = append(convertedMessages, fantasy.Message{\n\t\t\tRole:    fantasy.MessageRoleTool,\n\t\t\tContent: textParts,\n\t\t})\n\n\t\tif len(mediaFiles) > 0 {\n\t\t\tconvertedMessages = append(convertedMessages, fantasy.NewUserMessage(\n\t\t\t\t\"Here is the media content from the tool result:\",\n\t\t\t\tmediaFiles...,\n\t\t\t))\n\t\t}\n\t}\n\n\treturn convertedMessages\n}\n\n// shouldContinueAfterTool checks if the conversation should continue based on state",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldContinueAfterTool_1852": {
      "name": "shouldContinueAfterTool",
      "type": "method",
      "start_line": 1852,
      "end_line": 1855,
      "content_hash": "069d58abe9f2be74bf24950d3f6361949913451f",
      "content": "func (a *sessionAgent) shouldContinueAfterTool(ctx context.Context, sessionID string, currentAssistant *message.Message) bool {\n\t// Use the conversation manager to determine continuation based on state\n\treturn a.convoMgr.ShouldContinue(sessionID)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}