{
  "file_path": "/work/internal/agent/prompt/prompt.go",
  "file_hash": "b6873e32f8ff0897bc48d84f34be2908ebbfc790",
  "updated_at": "2025-12-26T17:34:25.114196",
  "symbols": {
    "struct_Prompt_33": {
      "name": "Prompt",
      "type": "struct",
      "start_line": 33,
      "end_line": 40,
      "content_hash": "391d87f99b331b15f93f30e9b39228b636c36daf",
      "content": "type Prompt struct {\n\tname       string\n\ttemplate   string\n\tnow        func() time.Time\n\tplatform   string\n\tworkingDir string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PromptDat_41": {
      "name": "PromptDat",
      "type": "struct",
      "start_line": 41,
      "end_line": 68,
      "content_hash": "e61419bbcb0b75c696a2878125d7fdaf4613b5e2",
      "content": "type PromptDat struct {\n\tProvider       string\n\tModel          string\n\tConfig         config.Config\n\tWorkingDir     string\n\tIsGitRepo      bool\n\tPlatform       string\n\tDate           string\n\tDateTime       string\n\tGitStatus      string\n\tContextFiles   []ContextFile\n\tCurrentUser    string\n\tLocalIP        string\n\tPythonVersion  string\n\tNodeVersion    string\n\tGoVersion      string\n\tShellType      string\n\tGitUserName    string\n\tGitUserEmail   string\n\tMemoryInfo     string\n\tDiskInfo       string\n\tArchitecture   string\n\tContainerType  string\n\tTerminalInfo   string\n\tNetworkStatus  string\n\tActiveServices string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ContextFile_69": {
      "name": "ContextFile",
      "type": "struct",
      "start_line": 69,
      "end_line": 75,
      "content_hash": "ecb54833d02d57c47ab4091edecd6de969268673",
      "content": "type ContextFile struct {\n\tPath    string\n\tContent string\n}\n\ntype Option func(*Prompt)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithTimeFunc_76": {
      "name": "WithTimeFunc",
      "type": "function",
      "start_line": 76,
      "end_line": 81,
      "content_hash": "a97d63eee3f7ffecfd74d1b64e29947b624c85de",
      "content": "func WithTimeFunc(fn func() time.Time) Option {\n\treturn func(p *Prompt) {\n\t\tp.now = fn\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithPlatform_82": {
      "name": "WithPlatform",
      "type": "function",
      "start_line": 82,
      "end_line": 87,
      "content_hash": "14fcd69298043ab532ca5fa8c93d7c34a39539be",
      "content": "func WithPlatform(platform string) Option {\n\treturn func(p *Prompt) {\n\t\tp.platform = platform\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithWorkingDir_88": {
      "name": "WithWorkingDir",
      "type": "function",
      "start_line": 88,
      "end_line": 93,
      "content_hash": "4e400b2979c3185e446b80bdb2b68900c85cabb7",
      "content": "func WithWorkingDir(workingDir string) Option {\n\treturn func(p *Prompt) {\n\t\tp.workingDir = workingDir\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewPrompt_94": {
      "name": "NewPrompt",
      "type": "function",
      "start_line": 94,
      "end_line": 105,
      "content_hash": "69bad66ad18d84e3a71149266ae4b9248ff4788a",
      "content": "func NewPrompt(name, promptTemplate string, opts ...Option) (*Prompt, error) {\n\tp := &Prompt{\n\t\tname:     name,\n\t\ttemplate: promptTemplate,\n\t\tnow:      time.Now,\n\t}\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\treturn p, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Build_106": {
      "name": "Build",
      "type": "method",
      "start_line": 106,
      "end_line": 122,
      "content_hash": "ddf834f78145f2794134b9320b234badd9f3daa2",
      "content": "func (p *Prompt) Build(ctx context.Context, provider, model string, cfg config.Config) (string, error) {\n\tt, err := template.New(p.name).Parse(p.template)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"parsing template: %w\", err)\n\t}\n\tvar sb strings.Builder\n\td, err := p.promptData(ctx, provider, model, cfg)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := t.Execute(&sb, d); err != nil {\n\t\treturn \"\", fmt.Errorf(\"executing template: %w\", err)\n\t}\n\n\treturn sb.String(), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_processFile_123": {
      "name": "processFile",
      "type": "function",
      "start_line": 123,
      "end_line": 133,
      "content_hash": "18fc8a8354cd59ea7eb8a562c491377e6d9fa548",
      "content": "func processFile(filePath string) *ContextFile {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn &ContextFile{\n\t\tPath:    filePath,\n\t\tContent: string(content),\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_processContextPath_134": {
      "name": "processContextPath",
      "type": "function",
      "start_line": 134,
      "end_line": 165,
      "content_hash": "a8a6260ebc2dc59dbfb8bffc09a189a4b8527e79",
      "content": "func processContextPath(p string, cfg config.Config) []ContextFile {\n\tvar contexts []ContextFile\n\tfullPath := p\n\tif !filepath.IsAbs(p) {\n\t\tfullPath = filepath.Join(cfg.WorkingDir(), p)\n\t}\n\tinfo, err := os.Stat(fullPath)\n\tif err != nil {\n\t\treturn contexts\n\t}\n\tif info.IsDir() {\n\t\tfilepath.WalkDir(fullPath, func(path string, d os.DirEntry, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !d.IsDir() {\n\t\t\t\tif result := processFile(path); result != nil {\n\t\t\t\t\tcontexts = append(contexts, *result)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t} else {\n\t\tresult := processFile(fullPath)\n\t\tif result != nil {\n\t\t\tcontexts = append(contexts, *result)\n\t\t}\n\t}\n\treturn contexts\n}\n\n// expandPath expands ~ and environment variables in file paths",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_expandPath_166": {
      "name": "expandPath",
      "type": "function",
      "start_line": 166,
      "end_line": 177,
      "content_hash": "dcdb97c59833888a2b6be8342b62432f8e34a0be",
      "content": "func expandPath(path string, cfg config.Config) string {\n\tpath = home.Long(path)\n\t// Handle environment variable expansion using the same pattern as config\n\tif strings.HasPrefix(path, \"$\") {\n\t\tif expanded, err := cfg.Resolver().ResolveValue(path); err == nil {\n\t\t\tpath = expanded\n\t\t}\n\t}\n\n\treturn path\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_promptData_178": {
      "name": "promptData",
      "type": "method",
      "start_line": 178,
      "end_line": 261,
      "content_hash": "b45c4e0176521ecb23f4c6c938dc7228dde032a9",
      "content": "func (p *Prompt) promptData(ctx context.Context, provider, model string, cfg config.Config) (PromptDat, error) {\n\tworkingDir := cmp.Or(p.workingDir, cfg.WorkingDir())\n\tplatform := cmp.Or(p.platform, runtime.GOOS)\n\n\tfiles := map[string][]ContextFile{}\n\n\tfor _, pth := range cfg.Options.ContextPaths {\n\t\texpanded := expandPath(pth, cfg)\n\t\tpathKey := strings.ToLower(expanded)\n\t\tif _, ok := files[pathKey]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tcontent := processContextPath(expanded, cfg)\n\t\tfiles[pathKey] = content\n\t}\n\n\tisGit := isGitRepo(cfg.WorkingDir())\n\n\t// Gather environment information using cache\n\tnow := p.now()\n\n\t// Get cached environment data (uses parallel execution internally)\n\tfullEnv := os.Getenv(\"NEXORA_FULL_ENV\") == \"1\"\n\tenvData, err := envCache.Get(ctx, workingDir, fullEnv)\n\tif err != nil {\n\t\treturn PromptDat{}, fmt.Errorf(\"failed to get environment data: %w\", err)\n\t}\n\n\t// Extract Go version number from \"go version go1.x.x ...\"\n\tgoVer := envData.GoVersion\n\tif goVer != \"not installed\" {\n\t\tparts := strings.Fields(goVer)\n\t\tif len(parts) >= 3 {\n\t\t\tgoVer = parts[2]\n\t\t}\n\t}\n\n\tshellType := \"bash (mvdan/sh)\"\n\tgitUserName := \"\"\n\tgitUserEmail := \"\"\n\tif isGit {\n\t\tgitUserName = envData.GitUserName\n\t\tgitUserEmail = envData.GitUserEmail\n\t}\n\n\tdata := PromptDat{\n\t\tProvider:       provider,\n\t\tModel:          model,\n\t\tConfig:         cfg,\n\t\tWorkingDir:     filepath.ToSlash(workingDir),\n\t\tIsGitRepo:      isGit,\n\t\tPlatform:       platform,\n\t\tDate:           now.Format(\"1/2/2006\"),\n\t\tDateTime:       now.Format(\"2006-01-02 15:04:05 MST\"),\n\t\tCurrentUser:    envData.CurrentUser,\n\t\tLocalIP:        envData.LocalIP,\n\t\tPythonVersion:  envData.PythonVersion,\n\t\tNodeVersion:    envData.NodeVersion,\n\t\tGoVersion:      goVer,\n\t\tShellType:      shellType,\n\t\tGitUserName:    gitUserName,\n\t\tGitUserEmail:   gitUserEmail,\n\t\tMemoryInfo:     envData.MemoryInfo,\n\t\tDiskInfo:       envData.DiskInfo,\n\t\tArchitecture:   envData.Architecture,\n\t\tContainerType:  envData.ContainerType,\n\t\tTerminalInfo:   envData.TerminalInfo,\n\t\tNetworkStatus:  envData.NetworkStatus,\n\t\tActiveServices: envData.ActiveServices,\n\t}\n\tif isGit {\n\t\tvar err error\n\t\tdata.GitStatus, err = getGitStatus(ctx, cfg.WorkingDir())\n\t\tif err != nil {\n\t\t\treturn PromptDat{}, err\n\t\t}\n\t}\n\n\tfor _, contextFiles := range files {\n\t\tdata.ContextFiles = append(data.ContextFiles, contextFiles...)\n\t}\n\treturn data, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isGitRepo_262": {
      "name": "isGitRepo",
      "type": "function",
      "start_line": 262,
      "end_line": 266,
      "content_hash": "0af70b3b1472afe1edc0601d2908226d9de8ddd9",
      "content": "func isGitRepo(dir string) bool {\n\t_, err := os.Stat(filepath.Join(dir, \".git\"))\n\treturn err == nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getGitStatus_267": {
      "name": "getGitStatus",
      "type": "function",
      "start_line": 267,
      "end_line": 285,
      "content_hash": "3887fbaa4169c75c6705e163f17ace414bccfe13",
      "content": "func getGitStatus(ctx context.Context, dir string) (string, error) {\n\tsh := shell.NewShell(&shell.Options{\n\t\tWorkingDir: dir,\n\t})\n\tbranch, err := getGitBranch(ctx, sh)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tstatus, err := getGitStatusSummary(ctx, sh)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcommits, err := getGitRecentCommits(ctx, sh)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn branch + status + commits, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getGitBranch_286": {
      "name": "getGitBranch",
      "type": "function",
      "start_line": 286,
      "end_line": 297,
      "content_hash": "2ed0ae74f6dabc2d616dedec8412a8a197c1ef6d",
      "content": "func getGitBranch(ctx context.Context, sh *shell.Shell) (string, error) {\n\tout, _, err := sh.Exec(ctx, \"git branch --show-current 2>/dev/null\")\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tout = strings.TrimSpace(out)\n\tif out == \"\" {\n\t\treturn \"\", nil\n\t}\n\treturn fmt.Sprintf(\"Current branch: %s\\n\", out), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getGitStatusSummary_298": {
      "name": "getGitStatusSummary",
      "type": "function",
      "start_line": 298,
      "end_line": 310,
      "content_hash": "d596b9d76d7d3500df749420556889c61bcc587d",
      "content": "func getGitStatusSummary(ctx context.Context, sh *shell.Shell) (string, error) {\n\t// Reduced from 20 to 5 files for token efficiency\n\tout, _, err := sh.Exec(ctx, \"git status --short 2>/dev/null | head -5\")\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tout = strings.TrimSpace(out)\n\tif out == \"\" {\n\t\treturn \"Status: clean\\n\", nil\n\t}\n\treturn fmt.Sprintf(\"Status:\\n%s\\n\", out), nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getGitRecentCommits_311": {
      "name": "getGitRecentCommits",
      "type": "function",
      "start_line": 311,
      "end_line": 321,
      "content_hash": "fbdfe8024d3f76c583b7df6026f0c1885d2bc4b5",
      "content": "func getGitRecentCommits(ctx context.Context, sh *shell.Shell) (string, error) {\n\t// Reduced from 3 to 2 commits for token efficiency\n\tout, _, err := sh.Exec(ctx, \"git log --oneline -n 2 2>/dev/null\")\n\tif err != nil || out == \"\" {\n\t\treturn \"\", nil\n\t}\n\tout = strings.TrimSpace(out)\n\treturn fmt.Sprintf(\"Recent commits:\\n%s\\n\", out), nil\n}\n\n// getCommandOutput runs a command and returns its trimmed output, or fallback on error",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getCommandOutput_322": {
      "name": "getCommandOutput",
      "type": "function",
      "start_line": 322,
      "end_line": 341,
      "content_hash": "c572f31dbc954b8ce54b6da487c4a25447994ffb",
      "content": "func getCommandOutput(ctx context.Context, cmd string, fallback string) string {\n\tparts := strings.Fields(cmd)\n\tif len(parts) == 0 {\n\t\treturn fallback\n\t}\n\n\texecCmd := exec.CommandContext(ctx, parts[0], parts[1:]...)\n\tout, err := execCmd.Output()\n\tif err != nil {\n\t\treturn fallback\n\t}\n\n\tresult := strings.TrimSpace(string(out))\n\tif result == \"\" {\n\t\treturn fallback\n\t}\n\treturn result\n}\n\n// getCurrentUser returns the current username",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getCurrentUser_342": {
      "name": "getCurrentUser",
      "type": "function",
      "start_line": 342,
      "end_line": 349,
      "content_hash": "c8d9dbd3c3f645da70e8a918d46e289a47b6b078",
      "content": "func getCurrentUser() string {\n\tif u, err := user.Current(); err == nil {\n\t\treturn u.Username\n\t}\n\treturn \"unknown\"\n}\n\n// getLocalIP attempts to get the local IP address",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getLocalIP_350": {
      "name": "getLocalIP",
      "type": "function",
      "start_line": 350,
      "end_line": 371,
      "content_hash": "210e70737930cd4b1b334a045a24acce57f7294d",
      "content": "func getLocalIP(ctx context.Context) string {\n\t// Try Linux/Unix approach first\n\tip := getCommandOutput(ctx, \"hostname -I\", \"\")\n\tif ip != \"\" {\n\t\t// Get first IP\n\t\tparts := strings.Fields(ip)\n\t\tif len(parts) > 0 {\n\t\t\treturn parts[0]\n\t\t}\n\t}\n\n\t// Try macOS approach\n\tip = getCommandOutput(ctx, \"ipconfig getifaddr en0\", \"\")\n\tif ip != \"\" {\n\t\treturn ip\n\t}\n\n\t// Fallback\n\treturn \"unavailable\"\n}\n\n// getRuntimeVersion gets version info for a runtime",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getRuntimeVersion_372": {
      "name": "getRuntimeVersion",
      "type": "function",
      "start_line": 372,
      "end_line": 376,
      "content_hash": "d8b866a261598665a67fd14062ea6df82f195cd9",
      "content": "func getRuntimeVersion(ctx context.Context, cmd string) string {\n\treturn getCommandOutput(ctx, cmd, \"not installed\")\n}\n\n// getGitConfig gets git configuration value",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getGitConfig_377": {
      "name": "getGitConfig",
      "type": "function",
      "start_line": 377,
      "end_line": 381,
      "content_hash": "c32a0a26d2475dcbdccec377c66c4ddce8007cca",
      "content": "func getGitConfig(ctx context.Context, key string) string {\n\treturn getCommandOutput(ctx, fmt.Sprintf(\"git config --get %s\", key), \"not configured\")\n}\n\n// getMemoryInfo returns system memory information",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getMemoryInfo_382": {
      "name": "getMemoryInfo",
      "type": "function",
      "start_line": 382,
      "end_line": 406,
      "content_hash": "0b515d34f2c32f738ef4f3bad10f513f085e6bef",
      "content": "func getMemoryInfo(ctx context.Context) string {\n\t// Try Linux free command\n\tout := getCommandOutput(ctx, \"free -h\", \"\")\n\tif out != \"\" {\n\t\tlines := strings.Split(out, \"\\n\")\n\t\tfor _, line := range lines {\n\t\t\tif strings.HasPrefix(line, \"Mem:\") {\n\t\t\t\tfields := strings.Fields(line)\n\t\t\t\tif len(fields) >= 7 {\n\t\t\t\t\treturn fmt.Sprintf(\"%s total, %s available\", fields[1], fields[6])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Try macOS vm_stat\n\tout = getCommandOutput(ctx, \"vm_stat\", \"\")\n\tif out != \"\" {\n\t\treturn \"available (macOS)\"\n\t}\n\n\treturn \"unavailable\"\n}\n\n// getDiskInfo returns disk space information for current directory",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getDiskInfo_407": {
      "name": "getDiskInfo",
      "type": "function",
      "start_line": 407,
      "end_line": 426,
      "content_hash": "689921eac35dc50015e1fc272d5a1d28ad40774c",
      "content": "func getDiskInfo(ctx context.Context, workingDir string) string {\n\t// Try df command\n\tcmd := exec.CommandContext(ctx, \"df\", \"-h\", workingDir)\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"unavailable\"\n\t}\n\n\tlines := strings.Split(string(out), \"\\n\")\n\tif len(lines) >= 2 {\n\t\tfields := strings.Fields(lines[1])\n\t\tif len(fields) >= 4 {\n\t\t\treturn fmt.Sprintf(\"%s total, %s free\", fields[1], fields[3])\n\t\t}\n\t}\n\n\treturn \"unavailable\"\n}\n\n// getArchitecture returns CPU architecture",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getArchitecture_427": {
      "name": "getArchitecture",
      "type": "function",
      "start_line": 427,
      "end_line": 431,
      "content_hash": "419495bf810e40be890079b509b0fe223c51c782",
      "content": "func getArchitecture() string {\n\treturn runtime.GOARCH\n}\n\n// detectContainer returns container type if running in one",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectContainer_432": {
      "name": "detectContainer",
      "type": "function",
      "start_line": 432,
      "end_line": 463,
      "content_hash": "3e976450c1a335ac505f9f79c071e527c640c8c5",
      "content": "func detectContainer(ctx context.Context) string {\n\t// Check for Docker\n\tif _, err := os.Stat(\"/.dockerenv\"); err == nil {\n\t\treturn \"Docker\"\n\t}\n\n\t// Check cgroup for docker/podman/kubernetes\n\tif data, err := os.ReadFile(\"/proc/1/cgroup\"); err == nil {\n\t\tcontent := string(data)\n\t\tif strings.Contains(content, \"docker\") {\n\t\t\treturn \"Docker\"\n\t\t}\n\t\tif strings.Contains(content, \"podman\") {\n\t\t\treturn \"Podman\"\n\t\t}\n\t\tif strings.Contains(content, \"kubepods\") {\n\t\t\treturn \"Kubernetes\"\n\t\t}\n\t}\n\n\t// Check for container env vars\n\tif os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" {\n\t\treturn \"Kubernetes\"\n\t}\n\tif os.Getenv(\"container\") != \"\" {\n\t\treturn os.Getenv(\"container\")\n\t}\n\n\treturn \"none\"\n}\n\n// getTerminalInfo returns terminal capabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getTerminalInfo_464": {
      "name": "getTerminalInfo",
      "type": "function",
      "start_line": 464,
      "end_line": 494,
      "content_hash": "1b82df0fdf5a7fd10487afa8ac938136501ff72e",
      "content": "func getTerminalInfo(ctx context.Context) string {\n\tvar info []string\n\n\t// Check color support\n\tterm := os.Getenv(\"TERM\")\n\tif term != \"\" {\n\t\tif strings.Contains(term, \"color\") || strings.Contains(term, \"256\") || term == \"xterm\" {\n\t\t\tinfo = append(info, \"color\")\n\t\t}\n\t}\n\n\t// Check terminal dimensions\n\tcols := getCommandOutput(ctx, \"tput cols\", \"\")\n\tlines := getCommandOutput(ctx, \"tput lines\", \"\")\n\tif cols != \"\" && lines != \"\" {\n\t\tinfo = append(info, fmt.Sprintf(\"%sx%s\", cols, lines))\n\t}\n\n\t// Check if interactive\n\tif term != \"\" && term != \"dumb\" {\n\t\tinfo = append(info, \"interactive\")\n\t}\n\n\tif len(info) == 0 {\n\t\treturn \"basic\"\n\t}\n\n\treturn strings.Join(info, \", \")\n}\n\n// getNetworkStatus checks internet connectivity",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getNetworkStatus_495": {
      "name": "getNetworkStatus",
      "type": "function",
      "start_line": 495,
      "end_line": 516,
      "content_hash": "b07bf899554584fda7da4ec1bffc7ad2615378dc",
      "content": "func getNetworkStatus(ctx context.Context) string {\n\t// Create a context with short timeout\n\ttimeoutCtx, cancel := context.WithTimeout(ctx, 2*time.Second)\n\tdefer cancel()\n\n\t// Try to resolve a common DNS (quick check)\n\tcmd := exec.CommandContext(timeoutCtx, \"ping\", \"-c\", \"1\", \"-W\", \"1\", \"8.8.8.8\")\n\tout, err := cmd.Output()\n\tif err == nil && !strings.Contains(string(out), \"100% packet loss\") {\n\t\treturn \"online\"\n\t}\n\n\t// Quick fallback to checking if network interface is up\n\tout, err = exec.CommandContext(timeoutCtx, \"ip\", \"link\", \"show\").Output()\n\tif err == nil && strings.Contains(string(out), \"state UP\") {\n\t\treturn \"network up\"\n\t}\n\n\treturn \"offline or restricted\"\n}\n\n// detectActiveServices checks for common development services",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectActiveServices_517": {
      "name": "detectActiveServices",
      "type": "function",
      "start_line": 517,
      "end_line": 570,
      "content_hash": "e1ab24168570113a8cf56ce912e0b2a49a2ade77",
      "content": "func detectActiveServices(ctx context.Context) string {\n\t// Create a context with timeout\n\ttimeoutCtx, cancel := context.WithTimeout(ctx, 2*time.Second)\n\tdefer cancel()\n\n\tvar services []string\n\n\t// Check for common ports using a single ss/netstat command\n\tif runtime.GOOS == \"linux\" || runtime.GOOS == \"darwin\" {\n\t\tcmd := exec.CommandContext(timeoutCtx, \"sh\", \"-c\", \"ss -ln 2>/dev/null | grep -E ':(5432|3306|6379|27017|9200|8080|3000|4200|5000|8000)' || netstat -an 2>/dev/null | grep -E ':(5432|3306|6379|27017|9200|8080|3000|4200|5000|8000)'\")\n\t\tout, err := cmd.Output()\n\t\tif err == nil {\n\t\t\tportMap := map[string]string{\n\t\t\t\t\"5432\":  \"PostgreSQL\",\n\t\t\t\t\"3306\":  \"MySQL\",\n\t\t\t\t\"6379\":  \"Redis\",\n\t\t\t\t\"27017\": \"MongoDB\",\n\t\t\t\t\"9200\":  \"Elasticsearch\",\n\t\t\t\t\"8080\":  \"HTTP:8080\",\n\t\t\t\t\"3000\":  \"HTTP:3000\",\n\t\t\t\t\"4200\":  \"HTTP:4200\",\n\t\t\t\t\"5000\":  \"HTTP:5000\",\n\t\t\t\t\"8000\":  \"HTTP:8000\",\n\t\t\t}\n\n\t\t\tfound := make(map[string]bool)\n\t\t\tfor port, name := range portMap {\n\t\t\t\tif strings.Contains(string(out), \":\"+port) && !found[name] {\n\t\t\t\t\tservices = append(services, name)\n\t\t\t\t\tfound[name] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Quick Docker check\n\tcmd := exec.CommandContext(timeoutCtx, \"docker\", \"info\")\n\tif err := cmd.Run(); err == nil {\n\t\tservices = append(services, \"Docker\")\n\t}\n\n\tif len(services) == 0 {\n\t\treturn \"none detected\"\n\t}\n\n\t// Limit to first 5 to keep output concise\n\tif len(services) > 5 {\n\t\tservices = services[:5]\n\t\treturn strings.Join(services, \", \") + \", ...\"\n\t}\n\n\treturn strings.Join(services, \", \")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_571": {
      "name": "Name",
      "type": "method",
      "start_line": 571,
      "end_line": 573,
      "content_hash": "eb146b085948e8aa0e4e0dacdf885d9ab8f2f5d4",
      "content": "func (p *Prompt) Name() string {\n\treturn p.name\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}