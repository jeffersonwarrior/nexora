{
  "file_path": "/work/internal/agent/tools/self_heal_test.go",
  "file_hash": "3485b387c0b75f821cef9f89327ff6c647dcf6a5",
  "updated_at": "2025-12-26T17:34:22.358174",
  "symbols": {
    "function_TestNormalizeWhitespace_13": {
      "name": "TestNormalizeWhitespace",
      "type": "function",
      "start_line": 13,
      "end_line": 41,
      "content_hash": "a262c870cadd710d65319d464afce7462ba5594c",
      "content": "func TestNormalizeWhitespace(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    \"  func foo() {\",\n\t\t\texpected: \"func foo() {\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"func\\t\\tfoo()\\t{\",\n\t\t\texpected: \"func        foo()    {\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"line1\\n  line2\\nline3  \",\n\t\t\texpected: \"line1\\nline2\\nline3\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(strings.TrimSpace(tt.input), func(t *testing.T) {\n\t\t\tresult := normalizeWhitespace(tt.input)\n\t\t\trequire.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFindSimilarPattern_42": {
      "name": "TestFindSimilarPattern",
      "type": "function",
      "start_line": 42,
      "end_line": 50,
      "content_hash": "b2fe5bed65c4b426e3c8b6f695e00b2e0bd13097",
      "content": "func TestFindSimilarPattern(t *testing.T) {\n\tt.Parallel()\n\n\tcontent := `package main\n\nimport (\n\t\"fmt\"\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_51": {
      "name": "main",
      "type": "function",
      "start_line": 51,
      "end_line": 77,
      "content_hash": "48ff467cbfb336a73b53bc7f65bd5bbeb2bdea07",
      "content": "func main() {\n\tfmt.Println(\"hello\")\n}\n`\n\n\ttests := []struct {\n\t\tpattern string\n\t\tfound   bool\n\t}{\n\t\t{\"package main\", true},\n\t\t{\"fmt.Println\", true},\n\t\t{\"hello\", true},\n\t\t{\"nonexistent\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.pattern, func(t *testing.T) {\n\t\t\tidx := findSimilarPattern(content, tt.pattern)\n\t\t\tif tt.found {\n\t\t\t\trequire.NotEqual(t, -1, idx, \"pattern should be found\")\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, -1, idx, \"pattern should not be found\")\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestExtractContextLines_78": {
      "name": "TestExtractContextLines",
      "type": "function",
      "start_line": 78,
      "end_line": 86,
      "content_hash": "a69044816e61010c92a146dcdaad049c0be63f0a",
      "content": "func TestExtractContextLines(t *testing.T) {\n\tt.Parallel()\n\n\tdir := t.TempDir()\n\ttestFile := filepath.Join(dir, \"test.go\")\n\tcontent := `package main\n\nimport \"fmt\"\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_87": {
      "name": "main",
      "type": "function",
      "start_line": 87,
      "end_line": 100,
      "content_hash": "a91de2d26474938ded469638e568d44e5d92a666",
      "content": "func main() {\n\tfmt.Println(\"test\")\n}\n`\n\trequire.NoError(t, os.WriteFile(testFile, []byte(content), 0o644))\n\n\tresult, err := ExtractContextLines(testFile, \"func main\", 1)\n\trequire.NoError(t, err)\n\n\t// Should contain the function declaration and surrounding lines\n\trequire.Contains(t, result, \"func main()\")\n\trequire.Contains(t, result, \"fmt.Println\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestValidateEditPattern_101": {
      "name": "TestValidateEditPattern",
      "type": "function",
      "start_line": 101,
      "end_line": 139,
      "content_hash": "93789b676b4ecfac7431bd04498bc205ac3c1f1c",
      "content": "func TestValidateEditPattern(t *testing.T) {\n\tt.Parallel()\n\n\tdir := t.TempDir()\n\ttestFile := filepath.Join(dir, \"test.txt\")\n\tcontent := `line 1\nline 2\nline 3\nunique line\nline 5\nduplicate line\nduplicate line\n`\n\trequire.NoError(t, os.WriteFile(testFile, []byte(content), 0o644))\n\n\ttests := []struct {\n\t\tpattern   string\n\t\twantValid bool\n\t\twantErr   bool\n\t}{\n\t\t{\"line 1\", true, false},\n\t\t{\"unique line\", true, false},\n\t\t{\"duplicate line\", false, true},\n\t\t{\"nonexistent\", false, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.pattern, func(t *testing.T) {\n\t\t\tvalid, err := ValidateEditPattern(testFile, tt.pattern)\n\t\t\tif tt.wantErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t\trequire.Equal(t, tt.wantValid, valid)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRetryWithContext_140": {
      "name": "TestRetryWithContext",
      "type": "function",
      "start_line": 140,
      "end_line": 146,
      "content_hash": "3d7cfd8358cdcd01efb986fa422215110cee6530",
      "content": "func TestRetryWithContext(t *testing.T) {\n\tt.Parallel()\n\n\tdir := t.TempDir()\n\ttestFile := filepath.Join(dir, \"test.go\")\n\tcontent := `package main\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_hello_147": {
      "name": "hello",
      "type": "function",
      "start_line": 147,
      "end_line": 150,
      "content_hash": "abcb74af4e571bdd2cf358cc47be93992effff1d",
      "content": "func hello() {\n\treturn \"hello\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_world_151": {
      "name": "world",
      "type": "function",
      "start_line": 151,
      "end_line": 173,
      "content_hash": "99d12a14b558572279e690c2e2b84b1177403921",
      "content": "func world() {\n\treturn \"world\"\n}\n`\n\trequire.NoError(t, os.WriteFile(testFile, []byte(content), 0o644))\n\n\tstrategy := NewEditRetryStrategy(context.Background())\n\n\t// Attempt to retry with context when exact match fails\n\timprovedParams, err := strategy.RetryWithContext(\n\t\ttestFile,\n\t\t\"func hello() {\",\n\t\t\"func greeting() {\",\n\t\t\"old_string not found\",\n\t)\n\n\t// The retry should either succeed or fail gracefully\n\tif err == nil {\n\t\trequire.Equal(t, testFile, improvedParams.FilePath)\n\t\trequire.Equal(t, \"func greeting() {\", improvedParams.NewString)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestFindBestMatch_174": {
      "name": "TestFindBestMatch",
      "type": "function",
      "start_line": 174,
      "end_line": 182,
      "content_hash": "de74e86749a03c3bd1a8f5a66d9330c909a7ceb3",
      "content": "func TestFindBestMatch(t *testing.T) {\n\tt.Parallel()\n\n\tdir := t.TempDir()\n\ttestFile := filepath.Join(dir, \"test.go\")\n\tcontent := `func foo() {\n\tbar()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_baz_183": {
      "name": "baz",
      "type": "function",
      "start_line": 183,
      "end_line": 194,
      "content_hash": "7d440f20654bc2ca7be3c3458efe3305e65d6387",
      "content": "func baz() {\n\tqux()\n}\n`\n\trequire.NoError(t, os.WriteFile(testFile, []byte(content), 0o644))\n\n\tresult, err := FindBestMatch(testFile, \"func foo()\", 1)\n\trequire.NoError(t, err)\n\trequire.Contains(t, result, \"func foo()\")\n\trequire.Contains(t, result, \"bar()\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCountNewlines_195": {
      "name": "TestCountNewlines",
      "type": "function",
      "start_line": 195,
      "end_line": 214,
      "content_hash": "fe490fb2f43b99a6bec57ec9caa1fa07d77dec24",
      "content": "func TestCountNewlines(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected int\n\t}{\n\t\t{\"hello\", 0},\n\t\t{\"hello\\nworld\", 1},\n\t\t{\"a\\nb\\nc\\n\", 3},\n\t\t{\"\\n\\n\\n\", 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(strings.TrimSpace(tt.input), func(t *testing.T) {\n\t\t\tresult := countNewlines(tt.input)\n\t\t\trequire.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}