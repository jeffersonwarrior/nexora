{
  "file_path": "/work/external-deps/claude-mem/src/ui/viewer/hooks/useSSE.ts",
  "file_hash": "1f6783b015516352d612768b4f677878c9e3dde6",
  "updated_at": "2025-12-26T17:34:20.224215",
  "symbols": {
    "function_useSSE_6": {
      "name": "useSSE",
      "type": "function",
      "start_line": 6,
      "end_line": 113,
      "content_hash": "3158d9681e3c27616a33f5f351a53f267685ba4c",
      "content": "export function useSSE() {\n  const [observations, setObservations] = useState<Observation[]>([]);\n  const [summaries, setSummaries] = useState<Summary[]>([]);\n  const [prompts, setPrompts] = useState<UserPrompt[]>([]);\n  const [projects, setProjects] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [queueDepth, setQueueDepth] = useState(0);\n  const eventSourceRef = useRef<EventSource | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    const connect = () => {\n      // Clean up existing connection\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n\n      const eventSource = new EventSource(API_ENDPOINTS.STREAM);\n      eventSourceRef.current = eventSource;\n\n      eventSource.onopen = () => {\n        console.log('[SSE] Connected');\n        setIsConnected(true);\n        // Clear any pending reconnect\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n        }\n      };\n\n      eventSource.onerror = (error) => {\n        console.error('[SSE] Connection error:', error);\n        setIsConnected(false);\n        eventSource.close();\n\n        // Reconnect after delay\n        reconnectTimeoutRef.current = setTimeout(() => {\n          reconnectTimeoutRef.current = undefined; // Clear before reconnecting\n          console.log('[SSE] Attempting to reconnect...');\n          connect();\n        }, TIMING.SSE_RECONNECT_DELAY_MS);\n      };\n\n      eventSource.onmessage = (event) => {\n        try {\n          const data: StreamEvent = JSON.parse(event.data);\n\n          switch (data.type) {\n            case 'initial_load':\n              console.log('[SSE] Initial load:', {\n                projects: data.projects?.length || 0\n              });\n              // Only load projects list - data will come via pagination\n              setProjects(data.projects || []);\n              break;\n\n            case 'new_observation':\n              if (data.observation) {\n                console.log('[SSE] New observation:', data.observation.id);\n                setObservations(prev => [data.observation, ...prev]);\n              }\n              break;\n\n            case 'new_summary':\n              if (data.summary) {\n                const summary = data.summary;\n                console.log('[SSE] New summary:', summary.id);\n                setSummaries(prev => [summary, ...prev]);\n              }\n              break;\n\n            case 'new_prompt':\n              if (data.prompt) {\n                const prompt = data.prompt;\n                console.log('[SSE] New prompt:', prompt.id);\n                setPrompts(prev => [prompt, ...prev]);\n              }\n              break;\n\n            case 'processing_status':\n              if (typeof data.isProcessing === 'boolean') {\n                console.log('[SSE] Processing status:', data.isProcessing, 'Queue depth:', data.queueDepth);\n                setIsProcessing(data.isProcessing);\n                setQueueDepth(data.queueDepth || 0);\n              }\n              break;\n          }\n        } catch (error) {\n          console.error('[SSE] Failed to parse message:', error);\n        }\n      };\n    };\n\n    connect();\n\n    // Cleanup on unmount\n    return () => {\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return { observations, summaries, prompts, projects, isProcessing, queueDepth, isConnected };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_connect_18": {
      "name": "connect",
      "type": "function",
      "start_line": 18,
      "end_line": 97,
      "content_hash": "fe666ac1d14a575b8cbdacfe99e732e01664f2b3",
      "content": "    const connect = () => {\n      // Clean up existing connection\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n\n      const eventSource = new EventSource(API_ENDPOINTS.STREAM);\n      eventSourceRef.current = eventSource;\n\n      eventSource.onopen = () => {\n        console.log('[SSE] Connected');\n        setIsConnected(true);\n        // Clear any pending reconnect\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n        }\n      };\n\n      eventSource.onerror = (error) => {\n        console.error('[SSE] Connection error:', error);\n        setIsConnected(false);\n        eventSource.close();\n\n        // Reconnect after delay\n        reconnectTimeoutRef.current = setTimeout(() => {\n          reconnectTimeoutRef.current = undefined; // Clear before reconnecting\n          console.log('[SSE] Attempting to reconnect...');\n          connect();\n        }, TIMING.SSE_RECONNECT_DELAY_MS);\n      };\n\n      eventSource.onmessage = (event) => {\n        try {\n          const data: StreamEvent = JSON.parse(event.data);\n\n          switch (data.type) {\n            case 'initial_load':\n              console.log('[SSE] Initial load:', {\n                projects: data.projects?.length || 0\n              });\n              // Only load projects list - data will come via pagination\n              setProjects(data.projects || []);\n              break;\n\n            case 'new_observation':\n              if (data.observation) {\n                console.log('[SSE] New observation:', data.observation.id);\n                setObservations(prev => [data.observation, ...prev]);\n              }\n              break;\n\n            case 'new_summary':\n              if (data.summary) {\n                const summary = data.summary;\n                console.log('[SSE] New summary:', summary.id);\n                setSummaries(prev => [summary, ...prev]);\n              }\n              break;\n\n            case 'new_prompt':\n              if (data.prompt) {\n                const prompt = data.prompt;\n                console.log('[SSE] New prompt:', prompt.id);\n                setPrompts(prev => [prompt, ...prev]);\n              }\n              break;\n\n            case 'processing_status':\n              if (typeof data.isProcessing === 'boolean') {\n                console.log('[SSE] Processing status:', data.isProcessing, 'Queue depth:', data.queueDepth);\n                setIsProcessing(data.isProcessing);\n                setQueueDepth(data.queueDepth || 0);\n              }\n              break;\n          }\n        } catch (error) {\n          console.error('[SSE] Failed to parse message:', error);\n        }\n      };\n    };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}