{
  "file_path": "/work/internal/indexer/delta.go",
  "file_hash": "c79a82e94867c107735b8fea1aae895d08e848d7",
  "updated_at": "2025-12-26T17:34:24.258779",
  "symbols": {
    "struct_DeltaHandler_15": {
      "name": "DeltaHandler",
      "type": "struct",
      "start_line": 15,
      "end_line": 25,
      "content_hash": "5bb5c7ae8de59dc8a3d8da07b6b56e1a94ce8d12",
      "content": "type DeltaHandler struct {\n\tindexer *Indexer\n\tparser  *ASTParser\n\tengine  *EmbeddingEngine\n\n\t// Delta tracking\n\tlastSync time.Time\n\tbatch    DeltaBatch\n}\n\n// DeltaBatch represents a batch of changes to apply",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_DeltaBatch_26": {
      "name": "DeltaBatch",
      "type": "struct",
      "start_line": 26,
      "end_line": 32,
      "content_hash": "9bdd3d2cc9a5d26cb8b8fe77f7c5040763866ec0",
      "content": "type DeltaBatch struct {\n\tAdded    []string `json:\"added\"`    // File paths added\n\tModified []string `json:\"modified\"` // File paths modified\n\tRemoved  []string `json:\"removed\"`  // File paths removed\n}\n\n// NewDeltaHandler creates a new delta handler",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewDeltaHandler_33": {
      "name": "NewDeltaHandler",
      "type": "function",
      "start_line": 33,
      "end_line": 52,
      "content_hash": "65072aa5ee721c82703993b920f0c99320607917",
      "content": "func NewDeltaHandler(indexer *Indexer, parser *ASTParser, engine *EmbeddingEngine) (*DeltaHandler, error) {\n\t// Get last sync time from database\n\tlastSync := time.Time{}\n\tif indexer != nil {\n\t\tvar syncTime sql.NullTime\n\t\terr := indexer.db.QueryRow(\"SELECT MAX(updated_at) FROM symbols\").Scan(&syncTime)\n\t\tif err == nil && syncTime.Valid {\n\t\t\tlastSync = syncTime.Time\n\t\t}\n\t}\n\n\treturn &DeltaHandler{\n\t\tindexer:  indexer,\n\t\tparser:   parser,\n\t\tengine:   engine,\n\t\tlastSync: lastSync,\n\t}, nil\n}\n\n// ProcessDelta processes a batch of file changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ProcessDelta_53": {
      "name": "ProcessDelta",
      "type": "method",
      "start_line": 53,
      "end_line": 92,
      "content_hash": "e428307ce884af820245432ca5cac66d714ad833",
      "content": "func (dh *DeltaHandler) ProcessDelta(ctx context.Context, batch DeltaBatch) error {\n\tslog.Info(\"Processing delta batch\",\n\t\t\"added\", len(batch.Added),\n\t\t\"modified\", len(batch.Modified),\n\t\t\"removed\", len(batch.Removed))\n\n\t// Start transaction for atomic updates\n\ttx, err := dh.indexer.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback()\n\n\t// Process removed files\n\tfor _, filePath := range batch.Removed {\n\t\tif err := dh.removeFile(ctx, tx, filePath); err != nil {\n\t\t\tslog.Warn(\"Failed to remove file\", \"file\", filePath, \"error\", err)\n\t\t}\n\t}\n\n\t// Process added and modified files\n\tallUpdates := append(batch.Added, batch.Modified...)\n\tfor _, filePath := range allUpdates {\n\t\tif err := dh.updateFile(ctx, tx, filePath); err != nil {\n\t\t\tslog.Warn(\"Failed to update file\", \"file\", filePath, \"error\", err)\n\t\t}\n\t}\n\n\t// Commit transaction\n\tif err := tx.Commit(); err != nil {\n\t\treturn fmt.Errorf(\"failed to commit delta transaction: %w\", err)\n\t}\n\n\t// Update last sync time\n\tdh.lastSync = time.Now()\n\n\treturn nil\n}\n\n// removeFile removes all symbols and embeddings for a file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_removeFile_93": {
      "name": "removeFile",
      "type": "method",
      "start_line": 93,
      "end_line": 110,
      "content_hash": "0d147831588e318b2fa1a3737b50359de0a0702d",
      "content": "func (dh *DeltaHandler) removeFile(ctx context.Context, tx *sql.Tx, filePath string) error {\n\t// Remove symbols\n\t_, err := tx.ExecContext(ctx, \"DELETE FROM symbols WHERE file = ?\", filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove symbols for %s: %w\", filePath, err)\n\t}\n\n\t// Remove embeddings (metadata contains file path)\n\t_, err = tx.ExecContext(ctx, \"DELETE FROM embeddings WHERE metadata LIKE ?\", \"%\"+filePath+\"%\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove embeddings for %s: %w\", filePath, err)\n\t}\n\n\tslog.Info(\"Removed file from index\", \"file\", filePath)\n\treturn nil\n}\n\n// updateFile updates symbols and embeddings for a file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_updateFile_111": {
      "name": "updateFile",
      "type": "method",
      "start_line": 111,
      "end_line": 155,
      "content_hash": "36e2c090820a581ec13f71b0a15f54b5be23d3bf",
      "content": "func (dh *DeltaHandler) updateFile(ctx context.Context, tx *sql.Tx, filePath string) error {\n\t// Remove old symbols for this file first\n\t_, err := tx.ExecContext(ctx, \"DELETE FROM symbols WHERE file = ?\", filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove old symbols for %s: %w\", filePath, err)\n\t}\n\n\t// Parse file for new symbols\n\tsymbols, err := dh.parser.ParseFile(ctx, filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse file %s: %w\", filePath, err)\n\t}\n\n\tif len(symbols) == 0 {\n\t\tslog.Debug(\"No symbols found in file\", \"file\", filePath)\n\t\treturn nil\n\t}\n\n\t// Store new symbols using transaction\n\tfor _, symbol := range symbols {\n\t\tif err := dh.storeSymbolInTx(ctx, tx, symbol); err != nil {\n\t\t\tslog.Warn(\"Failed to store symbol\", \"symbol\", symbol.Name, \"file\", filePath, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\t// Generate and store embeddings\n\tif dh.engine != nil {\n\t\tembeddings, err := dh.engine.GenerateSymbolEmbeddings(ctx, symbols)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Failed to generate embeddings\", \"file\", filePath, \"error\", err)\n\t\t} else {\n\t\t\tfor _, embedding := range embeddings {\n\t\t\t\tif err := dh.storeEmbeddingInTx(ctx, tx, embedding); err != nil {\n\t\t\t\t\tslog.Warn(\"Failed to store embedding\", \"symbol\", embedding.ID, \"file\", filePath, \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tslog.Info(\"Updated file in index\", \"file\", filePath, \"symbols\", len(symbols))\n\treturn nil\n}\n\n// storeSymbolInTx stores a symbol within a transaction",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_storeSymbolInTx_156": {
      "name": "storeSymbolInTx",
      "type": "method",
      "start_line": 156,
      "end_line": 181,
      "content_hash": "d35a93d41ee2c9c9c0c34e067d255ff6d7755841",
      "content": "func (dh *DeltaHandler) storeSymbolInTx(ctx context.Context, tx *sql.Tx, symbol Symbol) error {\n\timportsJSON, _ := json.Marshal(symbol.Imports)\n\tcallersJSON, _ := json.Marshal(symbol.Callers)\n\tcallsJSON, _ := json.Marshal(symbol.Calls)\n\tparamsJSON, _ := json.Marshal(symbol.Params)\n\treturnsJSON, _ := json.Marshal(symbol.Returns)\n\tfieldsJSON, _ := json.Marshal(symbol.Fields)\n\tmethodsJSON, _ := json.Marshal(symbol.Methods)\n\n\t_, err := tx.ExecContext(ctx, `\n\t\tINSERT OR REPLACE INTO symbols (\n\t\t\tid, name, type, package, file, line, column, signature, doc,\n\t\t\timports, callers, calls, public, params, returns, fields, methods, created_at\n\t\t) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`,\n\t\tfmt.Sprintf(\"%s:%s:%d\", symbol.Package, symbol.Name, symbol.Line),\n\t\tsymbol.Name, symbol.Type, symbol.Package, symbol.File,\n\t\tsymbol.Line, symbol.Column, symbol.Signature, symbol.Doc,\n\t\tstring(importsJSON), string(callersJSON), string(callsJSON),\n\t\tsymbol.Public, string(paramsJSON), string(returnsJSON),\n\t\tstring(fieldsJSON), string(methodsJSON), time.Now(),\n\t)\n\treturn err\n}\n\n// storeEmbeddingInTx stores an embedding within a transaction",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_storeEmbeddingInTx_182": {
      "name": "storeEmbeddingInTx",
      "type": "method",
      "start_line": 182,
      "end_line": 197,
      "content_hash": "678dd616b39530e5f95b969783366bacba550593",
      "content": "func (dh *DeltaHandler) storeEmbeddingInTx(ctx context.Context, tx *sql.Tx, embedding Embedding) error {\n\tvectorJSON, _ := json.Marshal(embedding.Vector)\n\tmetadataJSON, _ := json.Marshal(embedding.Metadata)\n\n\t_, err := tx.ExecContext(ctx, `\n\t\tINSERT OR REPLACE INTO embeddings (\n\t\t\tid, type, text, vector, metadata, created_at\n\t\t) VALUES (?, ?, ?, ?, ?, ?)\n\t`,\n\t\tembedding.ID, embedding.Type, embedding.Text,\n\t\tstring(vectorJSON), string(metadataJSON), embedding.Created,\n\t)\n\treturn err\n}\n\n// GetLastSync returns the timestamp of the last sync",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetLastSync_198": {
      "name": "GetLastSync",
      "type": "method",
      "start_line": 198,
      "end_line": 202,
      "content_hash": "10d4d1a304e57e47755576321dfdb537e1e6e25d",
      "content": "func (dh *DeltaHandler) GetLastSync() time.Time {\n\treturn dh.lastSync\n}\n\n// SetLastSync manually sets the last sync time",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetLastSync_203": {
      "name": "SetLastSync",
      "type": "method",
      "start_line": 203,
      "end_line": 207,
      "content_hash": "cb44269241edce1691c116106de780739b2432be",
      "content": "func (dh *DeltaHandler) SetLastSync(t time.Time) {\n\tdh.lastSync = t\n}\n\n// CreateDeltaBatch creates a delta batch from file change lists",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_CreateDeltaBatch_208": {
      "name": "CreateDeltaBatch",
      "type": "function",
      "start_line": 208,
      "end_line": 216,
      "content_hash": "e51489259cdc4ed4b8c2e2b2e05464d2737a2e98",
      "content": "func CreateDeltaBatch(added, modified, removed []string) DeltaBatch {\n\treturn DeltaBatch{\n\t\tAdded:    added,\n\t\tModified: modified,\n\t\tRemoved:  removed,\n\t}\n}\n\n// Checkpoint creates a checkpoint to mark a successful sync",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Checkpoint_217": {
      "name": "Checkpoint",
      "type": "method",
      "start_line": 217,
      "end_line": 250,
      "content_hash": "ebfedef42b28cabe6d8b05c4bebd59a0f928bad0",
      "content": "func (dh *DeltaHandler) Checkpoint(ctx context.Context) error {\n\tif dh.indexer == nil {\n\t\treturn nil\n\t}\n\n\t// Store checkpoint in metadata table\n\t_, err := dh.indexer.db.ExecContext(ctx, `\n\t\tCREATE TABLE IF NOT EXISTS checkpoints (\n\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\ttimestamp DATETIME NOT NULL,\n\t\t\tcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n\t\t)\n\t`)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create checkpoints table: %w\", err)\n\t}\n\n\t_, err = dh.indexer.db.ExecContext(ctx, `\n\t\tINSERT INTO checkpoints (timestamp) VALUES (?)\n\t`, dh.lastSync)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to store checkpoint: %w\", err)\n\t}\n\n\t// Clean up old checkpoints (keep last 10)\n\t_, err = dh.indexer.db.ExecContext(ctx, `\n\t\tDELETE FROM checkpoints WHERE id NOT IN (\n\t\t\tSELECT id FROM checkpoints ORDER BY timestamp DESC LIMIT 10\n\t\t)\n\t`)\n\treturn err\n}\n\n// GetLastCheckpoint gets the timestamp of the last successful checkpoint",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetLastCheckpoint_251": {
      "name": "GetLastCheckpoint",
      "type": "method",
      "start_line": 251,
      "end_line": 272,
      "content_hash": "e24336bd0b93115d7d9ee8240778255ca094101a",
      "content": "func (dh *DeltaHandler) GetLastCheckpoint(ctx context.Context) (time.Time, error) {\n\tif dh.indexer == nil {\n\t\treturn time.Time{}, nil\n\t}\n\n\tvar checkpointTime sql.NullTime\n\terr := dh.indexer.db.QueryRowContext(ctx, `\n\t\tSELECT timestamp FROM checkpoints ORDER BY timestamp DESC LIMIT 1\n\t`).Scan(&checkpointTime)\n\n\tif err == sql.ErrNoRows {\n\t\treturn time.Time{}, nil\n\t}\n\tif err != nil {\n\t\treturn time.Time{}, fmt.Errorf(\"failed to get last checkpoint: %w\", err)\n\t}\n\n\tif checkpointTime.Valid {\n\t\treturn checkpointTime.Time, nil\n\t}\n\treturn time.Time{}, nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}