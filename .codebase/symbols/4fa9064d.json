{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/property_based_tests.rs",
  "file_hash": "53b2d98beb5ed46deaefd7677a956ba3566d2300",
  "updated_at": "2025-12-26T17:34:22.873305",
  "symbols": {
    "function_arb_label_23": {
      "name": "arb_label",
      "type": "function",
      "start_line": 23,
      "end_line": 27,
      "content_hash": "c68a96ec2a5b09c978ac4f9f9cf91c15845a57bd",
      "content": "    fn arb_label() -> impl Strategy<Value = String> {\n        prop::string::string_regex(\"[a-zA-Z0-9_]{1,50}\").unwrap()\n    }\n\n    // Strategy for generating longer strings",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_arb_long_string_28": {
      "name": "arb_long_string",
      "type": "function",
      "start_line": 28,
      "end_line": 32,
      "content_hash": "0c80770663538a7a690a5782eced8dcc184085ae",
      "content": "    fn arb_long_string() -> impl Strategy<Value = String> {\n        prop::string::string_regex(\"[a-zA-Z0-9 ]{0,200}\").unwrap()\n    }\n\n    // Strategy for generating Value types",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_arb_value_33": {
      "name": "arb_value",
      "type": "function",
      "start_line": 33,
      "end_line": 46,
      "content_hash": "143e2eb25c650a4c0e5db757b1d743082b655416",
      "content": "    fn arb_value() -> impl Strategy<Value = Value> {\n        prop_oneof![\n            any::<i32>().prop_map(Value::I32),\n            any::<i64>().prop_map(Value::I64),\n            any::<u32>().prop_map(Value::U32),\n            any::<u64>().prop_map(Value::U64),\n            any::<f64>().prop_filter(\"Not NaN\", |f| !f.is_nan()).prop_map(Value::F64),\n            any::<bool>().prop_map(Value::Boolean),\n            arb_long_string().prop_map(Value::String),\n            Just(Value::Empty),\n        ]\n    }\n\n    // Strategy for generating property maps",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_arb_properties_47": {
      "name": "arb_properties",
      "type": "function",
      "start_line": 47,
      "end_line": 54,
      "content_hash": "fc0dd06d61933cf7aeef1b881e9395a3108ee89f",
      "content": "    fn arb_properties() -> impl Strategy<Value = Vec<(String, Value)>> {\n        prop::collection::vec(\n            (arb_label(), arb_value()),\n            0..10, // 0 to 10 properties\n        )\n    }\n\n    // Strategy for generating vector data",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_arb_vector_data_55": {
      "name": "arb_vector_data",
      "type": "function",
      "start_line": 55,
      "end_line": 67,
      "content_hash": "49af85e9835d8eb9424bbaae0b9b9fd8453d80e6",
      "content": "    fn arb_vector_data() -> impl Strategy<Value = Vec<f64>> {\n        prop::collection::vec(\n            any::<f64>().prop_filter(\"Not NaN\", |f| !f.is_nan()),\n            1..128, // 1 to 128 dimensions\n        )\n    }\n\n    // ========================================================================\n    // NODE PROPERTY TESTS\n    // ========================================================================\n\n    proptest! {\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_node_roundtrip_preserves_label_68": {
      "name": "prop_node_roundtrip_preserves_label",
      "type": "function",
      "start_line": 68,
      "end_line": 84,
      "content_hash": "6e2ecdbd9c72bdeb9adabf24c6f82d06cb7fb2d2",
      "content": "        fn prop_node_roundtrip_preserves_label(\n            label in arb_label(),\n            id in any::<u128>(),\n        ) {\n            let arena = Bump::new();\n            let node = create_simple_node(&arena, id, &label);\n\n            let bytes = bincode::serialize(&node).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Node::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            prop_assert_eq!(deserialized.label, label.as_str());\n            prop_assert_eq!(deserialized.id, id);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_node_roundtrip_preserves_version_85": {
      "name": "prop_node_roundtrip_preserves_version",
      "type": "function",
      "start_line": 85,
      "end_line": 101,
      "content_hash": "625939b34cc3de7673d7b15acba0a1235d6d7fec",
      "content": "        fn prop_node_roundtrip_preserves_version(\n            label in arb_label(),\n            id in any::<u128>(),\n            version in any::<u8>(),\n        ) {\n            let arena = Bump::new();\n            let node = create_arena_node(&arena, id, &label, version, vec![]);\n\n            let bytes = bincode::serialize(&node).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Node::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            prop_assert_eq!(deserialized.version, version);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_node_roundtrip_with_properties_102": {
      "name": "prop_node_roundtrip_with_properties",
      "type": "function",
      "start_line": 102,
      "end_line": 134,
      "content_hash": "8b0562d77b3af945c61f8e8116e4836c7828a8a1",
      "content": "        fn prop_node_roundtrip_with_properties(\n            label in arb_label(),\n            id in any::<u128>(),\n            props in arb_properties(),\n        ) {\n            let arena = Bump::new();\n\n            // Convert String keys to &str\n            let props_refs: Vec<(&str, Value)> = props.iter()\n                .map(|(k, v)| (k.as_str(), v.clone()))\n                .collect();\n\n            let node = create_arena_node(&arena, id, &label, 0, props_refs);\n\n            let bytes = bincode::serialize(&node).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Node::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            prop_assert_eq!(deserialized.label, label.as_str());\n            prop_assert_eq!(deserialized.id, id);\n\n            // Check property count\n            match (&node.properties, &deserialized.properties) {\n                (None, None) => {},\n                (Some(p1), Some(p2)) => {\n                    prop_assert_eq!(p1.len(), p2.len());\n                }\n                _ => prop_assert!(false, \"Property presence mismatch\"),\n            }\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_node_serialization_idempotent_135": {
      "name": "prop_node_serialization_idempotent",
      "type": "function",
      "start_line": 135,
      "end_line": 150,
      "content_hash": "f173a16b6cd208e46d71a264e5879d7b6d316298",
      "content": "        fn prop_node_serialization_idempotent(\n            label in arb_label(),\n            id in any::<u128>(),\n        ) {\n            let arena = Bump::new();\n            let node = create_simple_node(&arena, id, &label);\n\n            // Serialize twice\n            let bytes1 = bincode::serialize(&node).unwrap();\n            let bytes2 = bincode::serialize(&node).unwrap();\n\n            // Should produce identical bytes\n            prop_assert_eq!(bytes1, bytes2);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_node_double_roundtrip_stable_151": {
      "name": "prop_node_double_roundtrip_stable",
      "type": "function",
      "start_line": 151,
      "end_line": 182,
      "content_hash": "41f415d4e86220c4aee08f5314299cb87a7f3d4d",
      "content": "        fn prop_node_double_roundtrip_stable(\n            label in arb_label(),\n            id in any::<u128>(),\n        ) {\n            let arena = Bump::new();\n            let node = create_simple_node(&arena, id, &label);\n\n            // First roundtrip\n            let bytes1 = bincode::serialize(&node).unwrap();\n            let arena2 = Bump::new();\n            let node2 = Node::from_bincode_bytes(id, &bytes1, &arena2).unwrap();\n\n            // Second roundtrip\n            let bytes2 = bincode::serialize(&node2).unwrap();\n            let arena3 = Bump::new();\n            let node3 = Node::from_bincode_bytes(id, &bytes2, &arena3).unwrap();\n\n            // Bytes should be identical\n            prop_assert_eq!(bytes1, bytes2);\n\n            // Semantics should be preserved\n            prop_assert_eq!(node2.label, node3.label);\n            prop_assert_eq!(node2.id, node3.id);\n        }\n    }\n\n    // ========================================================================\n    // EDGE PROPERTY TESTS\n    // ========================================================================\n\n    proptest! {\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_edge_roundtrip_preserves_all_fields_183": {
      "name": "prop_edge_roundtrip_preserves_all_fields",
      "type": "function",
      "start_line": 183,
      "end_line": 205,
      "content_hash": "7d9a8dcc344035f1cec5cf332d4d912bffe384c0",
      "content": "        fn prop_edge_roundtrip_preserves_all_fields(\n            label in arb_label(),\n            id in any::<u128>(),\n            from_node in any::<u128>(),\n            to_node in any::<u128>(),\n            version in any::<u8>(),\n        ) {\n            let arena = Bump::new();\n            let edge = create_arena_edge(&arena, id, &label, version, from_node, to_node, vec![]);\n\n            let bytes = bincode::serialize(&edge).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            prop_assert_eq!(deserialized.label, label.as_str());\n            prop_assert_eq!(deserialized.id, id);\n            prop_assert_eq!(deserialized.from_node, from_node);\n            prop_assert_eq!(deserialized.to_node, to_node);\n            prop_assert_eq!(deserialized.version, version);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_edge_roundtrip_with_properties_206": {
      "name": "prop_edge_roundtrip_with_properties",
      "type": "function",
      "start_line": 206,
      "end_line": 230,
      "content_hash": "e615bdedace9544197a1f4486fddfe3956a2c50c",
      "content": "        fn prop_edge_roundtrip_with_properties(\n            label in arb_label(),\n            id in any::<u128>(),\n            from_node in any::<u128>(),\n            to_node in any::<u128>(),\n            props in arb_properties(),\n        ) {\n            let arena = Bump::new();\n\n            let props_refs: Vec<(&str, Value)> = props.iter()\n                .map(|(k, v)| (k.as_str(), v.clone()))\n                .collect();\n\n            let edge = create_arena_edge(&arena, id, &label, 0, from_node, to_node, props_refs);\n\n            let bytes = bincode::serialize(&edge).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            prop_assert_eq!(deserialized.from_node, from_node);\n            prop_assert_eq!(deserialized.to_node, to_node);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_edge_serialization_idempotent_231": {
      "name": "prop_edge_serialization_idempotent",
      "type": "function",
      "start_line": 231,
      "end_line": 246,
      "content_hash": "cda3c1a980d91657af58f132b1bdc15338d62166",
      "content": "        fn prop_edge_serialization_idempotent(\n            label in arb_label(),\n            id in any::<u128>(),\n            from_node in any::<u128>(),\n            to_node in any::<u128>(),\n        ) {\n            let arena = Bump::new();\n            let edge = create_simple_edge(&arena, id, &label, from_node, to_node);\n\n            let bytes1 = bincode::serialize(&edge).unwrap();\n            let bytes2 = bincode::serialize(&edge).unwrap();\n\n            prop_assert_eq!(bytes1, bytes2);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_edge_relationship_preserved_247": {
      "name": "prop_edge_relationship_preserved",
      "type": "function",
      "start_line": 247,
      "end_line": 273,
      "content_hash": "25a293886cf1de7776ba19ede37cfbc897bda772",
      "content": "        fn prop_edge_relationship_preserved(\n            label in arb_label(),\n            id in any::<u128>(),\n            from_node in any::<u128>(),\n            to_node in any::<u128>(),\n        ) {\n            // Property: After serialization, edge relationship must be preserved\n            let arena = Bump::new();\n            let edge = create_simple_edge(&arena, id, &label, from_node, to_node);\n\n            let bytes = bincode::serialize(&edge).unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n            // Relationship invariant\n            prop_assert_eq!(deserialized.from_node, from_node);\n            prop_assert_eq!(deserialized.to_node, to_node);\n        }\n    }\n\n    // ========================================================================\n    // VECTOR PROPERTY TESTS\n    // ========================================================================\n\n    proptest! {\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_vector_roundtrip_preserves_data_274": {
      "name": "prop_vector_roundtrip_preserves_data",
      "type": "function",
      "start_line": 274,
      "end_line": 304,
      "content_hash": "4cf66fbcb75799851361d61bd9cfef290ed697ca",
      "content": "        fn prop_vector_roundtrip_preserves_data(\n            label in arb_label(),\n            id in any::<u128>(),\n            data in arb_vector_data(),\n        ) {\n            let arena = Bump::new();\n            let vector = create_simple_vector(&arena, id, &label, &data);\n\n            let props_bytes = bincode::serialize(&vector).unwrap();\n            let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = HVector::from_bincode_bytes(\n                &arena2,\n                Some(&props_bytes),\n                data_bytes,\n                id,\n            ).unwrap();\n\n            prop_assert_eq!(deserialized.label, label.as_str());\n            prop_assert_eq!(deserialized.id, id);\n            prop_assert_eq!(deserialized.data.len(), data.len());\n\n            // Check each data point (with floating point tolerance)\n            for (i, (&orig, &deser)) in data.iter().zip(deserialized.data.iter()).enumerate() {\n                let diff = (orig - deser).abs();\n                prop_assert!(diff < 1e-10, \"Data mismatch at index {}: {} vs {}\", i, orig, deser);\n            }\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_vector_roundtrip_with_properties_305": {
      "name": "prop_vector_roundtrip_with_properties",
      "type": "function",
      "start_line": 305,
      "end_line": 335,
      "content_hash": "06f2073d642075dc2d47d868eb457918e93bc679",
      "content": "        fn prop_vector_roundtrip_with_properties(\n            label in arb_label(),\n            id in any::<u128>(),\n            data in arb_vector_data(),\n            props in arb_properties(),\n            deleted in any::<bool>(),\n        ) {\n            let arena = Bump::new();\n\n            let props_refs: Vec<(&str, Value)> = props.iter()\n                .map(|(k, v)| (k.as_str(), v.clone()))\n                .collect();\n\n            let vector = create_arena_vector(&arena, id, &label, 1, deleted, 0, &data, props_refs);\n\n            let props_bytes = bincode::serialize(&vector).unwrap();\n            let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n            let arena2 = Bump::new();\n            let deserialized = HVector::from_bincode_bytes(\n                &arena2,\n                Some(&props_bytes),\n                data_bytes,\n                id,\n            ).unwrap();\n\n            prop_assert_eq!(deserialized.deleted, deleted);\n            prop_assert_eq!(deserialized.data.len(), data.len());\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_vector_data_bytes_roundtrip_336": {
      "name": "prop_vector_data_bytes_roundtrip",
      "type": "function",
      "start_line": 336,
      "end_line": 353,
      "content_hash": "c641b7cae164bbeaf29f301b576bd5610d437e58",
      "content": "        fn prop_vector_data_bytes_roundtrip(\n            data in arb_vector_data(),\n        ) {\n            let arena = Bump::new();\n\n            // Convert to bytes and back\n            let bytes = create_vector_bytes(&data);\n            let restored = HVector::cast_raw_vector_data(&arena, &bytes);\n\n            prop_assert_eq!(restored.len(), data.len());\n\n            for (i, (&orig, &rest)) in data.iter().zip(restored.iter()).enumerate() {\n                let diff = (orig - rest).abs();\n                prop_assert!(diff < 1e-10, \"Data mismatch at index {}: {} vs {}\", i, orig, rest);\n            }\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_vector_serialization_idempotent_354": {
      "name": "prop_vector_serialization_idempotent",
      "type": "function",
      "start_line": 354,
      "end_line": 372,
      "content_hash": "f382012628a97ea8c84ab6f9579a75b42058dec8",
      "content": "        fn prop_vector_serialization_idempotent(\n            label in arb_label(),\n            id in any::<u128>(),\n            data in arb_vector_data(),\n        ) {\n            let arena = Bump::new();\n            let vector = create_simple_vector(&arena, id, &label, &data);\n\n            let props_bytes1 = bincode::serialize(&vector).unwrap();\n            let data_bytes1 = vector.vector_data_to_bytes().unwrap();\n\n            let props_bytes2 = bincode::serialize(&vector).unwrap();\n            let data_bytes2 = vector.vector_data_to_bytes().unwrap();\n\n            prop_assert_eq!(props_bytes1, props_bytes2);\n            prop_assert_eq!(data_bytes1, data_bytes2);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_vector_double_roundtrip_stable_373": {
      "name": "prop_vector_double_roundtrip_stable",
      "type": "function",
      "start_line": 373,
      "end_line": 407,
      "content_hash": "6039511867b38e4e1585b9f2cbbe37e73c615162",
      "content": "        fn prop_vector_double_roundtrip_stable(\n            label in arb_label(),\n            id in any::<u128>(),\n            data in arb_vector_data(),\n        ) {\n            let arena = Bump::new();\n            let vector = create_simple_vector(&arena, id, &label, &data);\n\n            // First roundtrip\n            let props_bytes1 = bincode::serialize(&vector).unwrap();\n            let data_bytes1 = vector.vector_data_to_bytes().unwrap();\n            let arena2 = Bump::new();\n            let vector2 = HVector::from_bincode_bytes(\n                &arena2,\n                Some(&props_bytes1),\n                data_bytes1,\n                id,\n            ).unwrap();\n\n            // Second roundtrip\n            let props_bytes2 = bincode::serialize(&vector2).unwrap();\n            let data_bytes2 = vector2.vector_data_to_bytes().unwrap();\n\n            // Bytes should be identical\n            prop_assert_eq!(props_bytes1, props_bytes2);\n            prop_assert_eq!(data_bytes1, data_bytes2);\n        }\n    }\n\n    // ========================================================================\n    // CROSS-TYPE INVARIANT TESTS\n    // ========================================================================\n\n    proptest! {\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_id_preserved_across_all_types_408": {
      "name": "prop_id_preserved_across_all_types",
      "type": "function",
      "start_line": 408,
      "end_line": 443,
      "content_hash": "5c45e53c05a79f1425b0b60ed817fe426c32ad20",
      "content": "        fn prop_id_preserved_across_all_types(\n            id in any::<u128>(),\n            label in arb_label(),\n        ) {\n            // Node\n            let arena_node = Bump::new();\n            let node = create_simple_node(&arena_node, id, &label);\n            let node_bytes = bincode::serialize(&node).unwrap();\n            let arena_node2 = Bump::new();\n            let node_restored = Node::from_bincode_bytes(id, &node_bytes, &arena_node2).unwrap();\n            prop_assert_eq!(node_restored.id, id);\n\n            // Edge\n            let arena_edge = Bump::new();\n            let edge = create_simple_edge(&arena_edge, id, &label, 1, 2);\n            let edge_bytes = bincode::serialize(&edge).unwrap();\n            let arena_edge2 = Bump::new();\n            let edge_restored = Edge::from_bincode_bytes(id, &edge_bytes, &arena_edge2).unwrap();\n            prop_assert_eq!(edge_restored.id, id);\n\n            // Vector\n            let arena_vec = Bump::new();\n            let vector = create_simple_vector(&arena_vec, id, &label, &[1.0, 2.0]);\n            let props_bytes = bincode::serialize(&vector).unwrap();\n            let data_bytes = vector.vector_data_to_bytes().unwrap();\n            let arena_vec2 = Bump::new();\n            let vector_restored = HVector::from_bincode_bytes(\n                &arena_vec2,\n                Some(&props_bytes),\n                data_bytes,\n                id,\n            ).unwrap();\n            prop_assert_eq!(vector_restored.id, id);\n        }\n\n        #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_prop_label_preserved_across_all_types_444": {
      "name": "prop_label_preserved_across_all_types",
      "type": "function",
      "start_line": 444,
      "end_line": 479,
      "content_hash": "2273fd47cd754041299497ad5fea1f9efff905af",
      "content": "        fn prop_label_preserved_across_all_types(\n            id in any::<u128>(),\n            label in arb_label(),\n        ) {\n            // Node\n            let arena_node = Bump::new();\n            let node = create_simple_node(&arena_node, id, &label);\n            let node_bytes = bincode::serialize(&node).unwrap();\n            let arena_node2 = Bump::new();\n            let node_restored = Node::from_bincode_bytes(id, &node_bytes, &arena_node2).unwrap();\n            prop_assert_eq!(node_restored.label, label.as_str());\n\n            // Edge\n            let arena_edge = Bump::new();\n            let edge = create_simple_edge(&arena_edge, id, &label, 1, 2);\n            let edge_bytes = bincode::serialize(&edge).unwrap();\n            let arena_edge2 = Bump::new();\n            let edge_restored = Edge::from_bincode_bytes(id, &edge_bytes, &arena_edge2).unwrap();\n            prop_assert_eq!(edge_restored.label, label.as_str());\n\n            // Vector\n            let arena_vec = Bump::new();\n            let vector = create_simple_vector(&arena_vec, id, &label, &[1.0]);\n            let props_bytes = bincode::serialize(&vector).unwrap();\n            let data_bytes = vector.vector_data_to_bytes().unwrap();\n            let arena_vec2 = Bump::new();\n            let vector_restored = HVector::from_bincode_bytes(\n                &arena_vec2,\n                Some(&props_bytes),\n                data_bytes,\n                id,\n            ).unwrap();\n            prop_assert_eq!(vector_restored.label, label.as_str());\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}