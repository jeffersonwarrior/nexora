{
  "file_path": "/work/internal/permission/permission_test.go",
  "file_hash": "54c473a8867e36b9d15b8d47cbc934ca2c4064c9",
  "updated_at": "2025-12-26T17:34:23.294337",
  "symbols": {
    "function_TestPermissionService_AllowedCommands_10": {
      "name": "TestPermissionService_AllowedCommands",
      "type": "function",
      "start_line": 10,
      "end_line": 80,
      "content_hash": "8e4b812e4596de0e56847409898116336da60229",
      "content": "func TestPermissionService_AllowedCommands(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tallowedTools []string\n\t\ttoolName     string\n\t\taction       string\n\t\texpected     bool\n\t}{\n\t\t{\n\t\t\tname:         \"tool in allowlist\",\n\t\t\tallowedTools: []string{\"bash\", \"view\"},\n\t\t\ttoolName:     \"bash\",\n\t\t\taction:       \"execute\",\n\t\t\texpected:     true,\n\t\t},\n\t\t{\n\t\t\tname:         \"tool:action in allowlist\",\n\t\t\tallowedTools: []string{\"bash:execute\", \"edit:create\"},\n\t\t\ttoolName:     \"bash\",\n\t\t\taction:       \"execute\",\n\t\t\texpected:     true,\n\t\t},\n\t\t{\n\t\t\tname:         \"tool not in allowlist\",\n\t\t\tallowedTools: []string{\"view\", \"ls\"},\n\t\t\ttoolName:     \"bash\",\n\t\t\taction:       \"execute\",\n\t\t\texpected:     false,\n\t\t},\n\t\t{\n\t\t\tname:         \"tool:action not in allowlist\",\n\t\t\tallowedTools: []string{\"bash:read\", \"edit:create\"},\n\t\t\ttoolName:     \"bash\",\n\t\t\taction:       \"execute\",\n\t\t\texpected:     false,\n\t\t},\n\t\t{\n\t\t\tname:         \"empty allowlist\",\n\t\t\tallowedTools: []string{},\n\t\t\ttoolName:     \"bash\",\n\t\t\taction:       \"execute\",\n\t\t\texpected:     false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tservice := NewPermissionService(\"/tmp\", false, tt.allowedTools)\n\n\t\t\t// Create a channel to capture the permission request\n\t\t\t// Since we're testing the allowlist logic, we need to simulate the request\n\t\t\tps := service.(*permissionService)\n\n\t\t\t// Test the allowlist logic directly\n\t\t\tcommandKey := tt.toolName + \":\" + tt.action\n\t\t\tallowed := false\n\t\t\tfor _, cmd := range ps.allowedTools {\n\t\t\t\tif cmd == commandKey || cmd == tt.toolName {\n\t\t\t\t\tallowed = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif allowed != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v for tool %s action %s with allowlist %v\",\n\t\t\t\t\ttt.expected, allowed, tt.toolName, tt.action, tt.allowedTools)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPermissionService_SkipMode_81": {
      "name": "TestPermissionService_SkipMode",
      "type": "function",
      "start_line": 81,
      "end_line": 96,
      "content_hash": "9f1d75da0949d2c890e7c8503c85622915668ed6",
      "content": "func TestPermissionService_SkipMode(t *testing.T) {\n\tservice := NewPermissionService(\"/tmp\", true, []string{})\n\n\tresult := service.Request(CreatePermissionRequest{\n\t\tSessionID:   \"test-session\",\n\t\tToolName:    \"bash\",\n\t\tAction:      \"execute\",\n\t\tDescription: \"test command\",\n\t\tPath:        \"/tmp\",\n\t})\n\n\tif !result {\n\t\tt.Error(\"expected permission to be granted in skip mode\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPermissionService_SequentialProperties_97": {
      "name": "TestPermissionService_SequentialProperties",
      "type": "function",
      "start_line": 97,
      "end_line": 247,
      "content_hash": "a6af0ce457641d0db8c6acc5c2fa14684ff5cc44",
      "content": "func TestPermissionService_SequentialProperties(t *testing.T) {\n\tt.Run(\"Sequential permission requests with persistent grants\", func(t *testing.T) {\n\t\tservice := NewPermissionService(\"/tmp\", false, []string{})\n\n\t\treq1 := CreatePermissionRequest{\n\t\t\tSessionID:   \"session1\",\n\t\t\tToolName:    \"file_tool\",\n\t\t\tDescription: \"Read file\",\n\t\t\tAction:      \"read\",\n\t\t\tParams:      map[string]string{\"file\": \"test.txt\"},\n\t\t\tPath:        \"/tmp/test.txt\",\n\t\t}\n\n\t\tvar result1 bool\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\n\t\tevents := service.Subscribe(t.Context())\n\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tresult1 = service.Request(req1)\n\t\t}()\n\n\t\tvar permissionReq PermissionRequest\n\t\tevent := <-events\n\n\t\tpermissionReq = event.Payload\n\t\tservice.GrantPersistent(permissionReq)\n\n\t\twg.Wait()\n\t\tassert.True(t, result1, \"First request should be granted\")\n\n\t\t// Second identical request should be automatically approved due to persistent permission\n\t\treq2 := CreatePermissionRequest{\n\t\t\tSessionID:   \"session1\",\n\t\t\tToolName:    \"file_tool\",\n\t\t\tDescription: \"Read file again\",\n\t\t\tAction:      \"read\",\n\t\t\tParams:      map[string]string{\"file\": \"test.txt\"},\n\t\t\tPath:        \"/tmp/test.txt\",\n\t\t}\n\t\tresult2 := service.Request(req2)\n\t\tassert.True(t, result2, \"Second request should be auto-approved\")\n\t})\n\tt.Run(\"Sequential requests with temporary grants\", func(t *testing.T) {\n\t\tservice := NewPermissionService(\"/tmp\", false, []string{})\n\n\t\treq := CreatePermissionRequest{\n\t\t\tSessionID:   \"session2\",\n\t\t\tToolName:    \"file_tool\",\n\t\t\tDescription: \"Write file\",\n\t\t\tAction:      \"write\",\n\t\t\tParams:      map[string]string{\"file\": \"test.txt\"},\n\t\t\tPath:        \"/tmp/test.txt\",\n\t\t}\n\n\t\tevents := service.Subscribe(t.Context())\n\t\tvar result1 bool\n\t\tvar wg sync.WaitGroup\n\n\t\twg.Go(func() {\n\t\t\tresult1 = service.Request(req)\n\t\t})\n\n\t\tvar permissionReq PermissionRequest\n\t\tevent := <-events\n\t\tpermissionReq = event.Payload\n\n\t\tservice.Grant(permissionReq)\n\t\twg.Wait()\n\t\tassert.True(t, result1, \"First request should be granted\")\n\n\t\tvar result2 bool\n\n\t\twg.Go(func() {\n\t\t\tresult2 = service.Request(req)\n\t\t})\n\n\t\tevent = <-events\n\t\tpermissionReq = event.Payload\n\t\tservice.Deny(permissionReq)\n\t\twg.Wait()\n\t\tassert.False(t, result2, \"Second request should be denied\")\n\t})\n\tt.Run(\"Concurrent requests with different outcomes\", func(t *testing.T) {\n\t\tservice := NewPermissionService(\"/tmp\", false, []string{})\n\n\t\tevents := service.Subscribe(t.Context())\n\n\t\tvar wg sync.WaitGroup\n\t\tresults := make([]bool, 0)\n\n\t\trequests := []CreatePermissionRequest{\n\t\t\t{\n\t\t\t\tSessionID:   \"concurrent1\",\n\t\t\t\tToolName:    \"tool1\",\n\t\t\t\tAction:      \"action1\",\n\t\t\t\tPath:        \"/tmp/file1.txt\",\n\t\t\t\tDescription: \"First concurrent request\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSessionID:   \"concurrent2\",\n\t\t\t\tToolName:    \"tool2\",\n\t\t\t\tAction:      \"action2\",\n\t\t\t\tPath:        \"/tmp/file2.txt\",\n\t\t\t\tDescription: \"Second concurrent request\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSessionID:   \"concurrent3\",\n\t\t\t\tToolName:    \"tool3\",\n\t\t\t\tAction:      \"action3\",\n\t\t\t\tPath:        \"/tmp/file3.txt\",\n\t\t\t\tDescription: \"Third concurrent request\",\n\t\t\t},\n\t\t}\n\n\t\tfor i, req := range requests {\n\t\t\twg.Add(1)\n\t\t\tgo func(index int, request CreatePermissionRequest) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresults = append(results, service.Request(request))\n\t\t\t}(i, req)\n\t\t}\n\n\t\tfor range 3 {\n\t\t\tevent := <-events\n\t\t\tswitch event.Payload.ToolName {\n\t\t\tcase \"tool1\":\n\t\t\t\tservice.Grant(event.Payload)\n\t\t\tcase \"tool2\":\n\t\t\t\tservice.GrantPersistent(event.Payload)\n\t\t\tcase \"tool3\":\n\t\t\t\tservice.Deny(event.Payload)\n\t\t\t}\n\t\t}\n\t\twg.Wait()\n\t\tgrantedCount := 0\n\t\tfor _, result := range results {\n\t\t\tif result {\n\t\t\t\tgrantedCount++\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, 2, grantedCount, \"Should have 2 granted and 1 denied\")\n\t\tsecondReq := requests[1]\n\t\tsecondReq.Description = \"Repeat of second request\"\n\t\tresult := service.Request(secondReq)\n\t\tassert.True(t, result, \"Repeated request should be auto-approved due to persistent permission\")\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}