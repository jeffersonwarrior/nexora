{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/commands/integrations/fly.rs",
  "file_hash": "e43b83600c5239daf23e9ece46c928d6a7f6c94e",
  "updated_at": "2025-12-26T17:34:20.185986",
  "symbols": {
    "struct_FlyManager_20": {
      "name": "FlyManager",
      "type": "struct",
      "start_line": 20,
      "end_line": 26,
      "content_hash": "e128f7963c8f74355aa530371198117b2a80436a",
      "content": "pub struct FlyManager<'a> {\n    project: &'a ProjectContext,\n    auth: FlyAuth,\n}\n\n/// Fly.io authentication method\n#[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_FlyAuth_27": {
      "name": "FlyAuth",
      "type": "enum",
      "start_line": 27,
      "end_line": 33,
      "content_hash": "2d9aa318f8b1e247c7a7d1ed8a02f8271dae1572",
      "content": "enum FlyAuth {\n    ApiKey(String),\n    Cli,\n}\n\n/// Authentication type selection\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_FlyAuthType_34": {
      "name": "FlyAuthType",
      "type": "enum",
      "start_line": 34,
      "end_line": 39,
      "content_hash": "37e230e94eb9b31c556649f7f5f0009091843ae4",
      "content": "pub enum FlyAuthType {\n    ApiKey,\n    #[default]\n    Cli,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_TryFrom_40": {
      "name": "TryFrom",
      "type": "impl",
      "start_line": 40,
      "end_line": 42,
      "content_hash": "f18b74a1dcefa2e991887a5bec661b6d4f52dec0",
      "content": "impl TryFrom<String> for FlyAuthType {\n    type Error = eyre::Report;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_try_from_43": {
      "name": "try_from",
      "type": "method",
      "start_line": 43,
      "end_line": 55,
      "content_hash": "46bfa494865aa7f3cc38fa94ea2d142737a07c62",
      "content": "    fn try_from(value: String) -> Result<Self, Self::Error> {\n        match value.as_str() {\n            \"api_key\" => Ok(Self::ApiKey),\n            \"cli\" => Ok(Self::Cli),\n            _ => Err(eyre!(\n                \"Invalid auth type '{value}'. Valid options: api_key, cli\"\n            )),\n        }\n    }\n}\n\n/// VM sizes available on Fly.io\n#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq, Eq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_VmSize_56": {
      "name": "VmSize",
      "type": "enum",
      "start_line": 56,
      "end_line": 86,
      "content_hash": "339f3b08abf787a0230ea01ab44f6cb43e758eb5",
      "content": "pub enum VmSize {\n    /// 4 CPU, 1GB RAM\n    #[serde(rename = \"shared-cpu-4x\")]\n    SharedCpu4x,\n    /// 8 CPU, 2GB RAM\n    #[serde(rename = \"shared-cpu-8x\")]\n    SharedCpu8x,\n    /// 4 CPU, 8GB RAM\n    #[default]\n    #[serde(rename = \"performance-4x\")]\n    PerformanceCpu4x,\n    /// 8 CPU, 16GB RAM\n    #[serde(rename = \"performance-8x\")]\n    PerformanceCpu8x,\n    /// 16 CPU, 32GB RAM\n    #[serde(rename = \"performance-16x\")]\n    PerformanceCpu16x,\n    /// 8 CPU, 32GB RAM, a10 GPU\n    #[serde(rename = \"a10\")]\n    A10,\n    /// 8 CPU, 32GB RAM, a100 pcie 40GB GPU\n    #[serde(rename = \"a100-40gb\")]\n    A10040Gb,\n    /// 8 CPU, 32GB RAM, a100 sxm 80GB GPU\n    #[serde(rename = \"a100-80gb\")]\n    A10080Gb,\n    /// 8 CPU, 32GB RAM, l40s GPU\n    #[serde(rename = \"l40s\")]\n    L40s,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_TryFrom_87": {
      "name": "TryFrom",
      "type": "impl",
      "start_line": 87,
      "end_line": 89,
      "content_hash": "6db159c55a3f23f8b34e523cf932d0b27b73739f",
      "content": "impl TryFrom<String> for VmSize {\n    type Error = eyre::Report;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_try_from_90": {
      "name": "try_from",
      "type": "method",
      "start_line": 90,
      "end_line": 107,
      "content_hash": "7395978648c24469c5977aed9a7235d47ebc4255",
      "content": "    fn try_from(value: String) -> Result<Self, Self::Error> {\n        match value.as_str() {\n            \"shared-cpu-4x\" => Ok(Self::SharedCpu4x),\n            \"shared-cpu-8x\" => Ok(Self::SharedCpu8x),\n            \"performance-4x\" => Ok(Self::PerformanceCpu4x),\n            \"performance-8x\" => Ok(Self::PerformanceCpu8x),\n            \"performance-16x\" => Ok(Self::PerformanceCpu16x),\n            \"a10\" => Ok(Self::A10),\n            \"a100-40gb\" => Ok(Self::A10040Gb),\n            \"a100-80gb\" => Ok(Self::A10080Gb),\n            \"l40s\" => Ok(Self::L40s),\n            _ => Err(eyre!(\n                \"Invalid VM size '{value}'. Valid options: shared-cpu-1x, shared-cpu-2x, shared-cpu-4x, shared-cpu-8x, performance-1x, performance-2x, performance-4x, performance-8x, performance-16x, a10, a100-40gb, a100-80gb, l40s\"\n            )),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_VmSize_108": {
      "name": "VmSize",
      "type": "impl",
      "start_line": 108,
      "end_line": 109,
      "content_hash": "7251976622afb997465073af36259c3a86c82a1c",
      "content": "impl VmSize {\n    /// Get the string representation of the VM size (used for CLI args and config)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_as_str_110": {
      "name": "as_str",
      "type": "method",
      "start_line": 110,
      "end_line": 123,
      "content_hash": "66603984b0e47c57b61264234e097f3326e3fb43",
      "content": "    pub fn as_str(&self) -> &'static str {\n        match self {\n            VmSize::SharedCpu4x => \"shared-cpu-4x\",\n            VmSize::SharedCpu8x => \"shared-cpu-8x\",\n            VmSize::PerformanceCpu4x => \"performance-4x\",\n            VmSize::PerformanceCpu8x => \"performance-8x\",\n            VmSize::PerformanceCpu16x => \"performance-16x\",\n            VmSize::A10 => \"a10\",\n            VmSize::A10040Gb => \"a100-40gb\",\n            VmSize::A10080Gb => \"a100-80gb\",\n            VmSize::L40s => \"l40s\",\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_command_args_124": {
      "name": "into_command_args",
      "type": "method",
      "start_line": 124,
      "end_line": 129,
      "content_hash": "10403c49441d222e8e2b191606233585f60ce835",
      "content": "    fn into_command_args(&self) -> [&'static str; 2] {\n        [\"--vm-size\", self.as_str()]\n    }\n}\n/// Configuration for a Fly.io instance\n#[derive(Debug, Serialize, Deserialize, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FlyInstanceConfig_130": {
      "name": "FlyInstanceConfig",
      "type": "struct",
      "start_line": 130,
      "end_line": 144,
      "content_hash": "a0c57826cf7b36fe2815447f1a4e4211f8db8975",
      "content": "pub struct FlyInstanceConfig {\n    #[serde(default = \"default_release_build_mode\")]\n    pub build_mode: BuildMode,\n    #[serde(default)]\n    pub region: Option<String>,\n    pub vm_size: VmSize,\n    pub volume: String,\n    pub volume_initial_size: u16,\n    #[serde(default)]\n    pub private: bool,\n    pub auth_type: FlyAuthType,\n    #[serde(flatten)]\n    pub db_config: config::DbConfig,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FlyManager_145": {
      "name": "FlyManager",
      "type": "impl",
      "start_line": 145,
      "end_line": 179,
      "content_hash": "0f44e911172c7b3a6cc7525734526933ec64c017",
      "content": "impl<'a> FlyManager<'a> {\n    /// Create a new FlyManager\n    pub async fn new(project: &'a ProjectContext, auth_type: FlyAuthType) -> Result<Self> {\n        let auth = match auth_type {\n            FlyAuthType::ApiKey => {\n                let env_path = project.helix_dir.join(\"helix.env\");\n                let env_content = std::fs::read_to_string(&env_path).map_err(|_| {\n                    eyre!(\n                        \"File {} not found. Create it with your FLY_API_KEY.\",\n                        env_path.display()\n                    )\n                })?;\n\n                let api_key = env_content\n                    .lines()\n                    .find(|line| line.starts_with(\"FLY_API_KEY=\"))\n                    .and_then(|line| line.split_once('=').map(|x| x.1))\n                    .map(|key| key.trim().to_string())\n                    .ok_or_else(|| eyre!(\"FLY_API_KEY not found in {}\", env_path.display()))?;\n\n                FlyAuth::ApiKey(api_key)\n            }\n            FlyAuthType::Cli => {\n                Self::check_fly_cli_auth().await?;\n                FlyAuth::Cli\n            }\n        };\n\n        Ok(Self { project, auth })\n    }\n\n    // === CENTRALIZED NAMING METHODS ===\n\n    /// Get the Fly.io app name for an instance\n    /// Note: Underscores in project names are converted to hyphens for fly.io compatibility",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_app_name_180": {
      "name": "app_name",
      "type": "method",
      "start_line": 180,
      "end_line": 185,
      "content_hash": "a0ee4251db7567e4adf37c0544518ae4871fd8b6",
      "content": "    fn app_name(&self, instance_name: &str) -> String {\n        let sanitized_project_name = self.project.config.project.name.replace('_', \"-\");\n        format!(\"helix-{}-{}\", sanitized_project_name, instance_name)\n    }\n\n    /// Get the volume name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_volume_name_186": {
      "name": "volume_name",
      "type": "method",
      "start_line": 186,
      "end_line": 190,
      "content_hash": "f904f83af136b414e512da9d34d05c12ae3bee6d",
      "content": "    fn volume_name(&self, instance_name: &str) -> String {\n        format!(\"{}_data\", self.app_name(instance_name).replace(\"-\", \"_\"))\n    }\n\n    /// Get the registry image name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_registry_image_name_191": {
      "name": "registry_image_name",
      "type": "method",
      "start_line": 191,
      "end_line": 198,
      "content_hash": "e07ab10ceaea425e3b0ed88131a6e27a34508aad",
      "content": "    fn registry_image_name(&self, image_name: &str) -> String {\n        format!(\"{FLY_REGISTRY_URL}/{image_name}\")\n    }\n\n    // === CENTRALIZED COMMAND EXECUTION ===\n\n    /// Run a flyctl command with consistent error handling\n    #[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_fly_command_199": {
      "name": "run_fly_command",
      "type": "method",
      "start_line": 199,
      "end_line": 217,
      "content_hash": "ecddd5f223e141a25fa5809e76e4d2d120172ce3",
      "content": "    fn run_fly_command(&self, args: &[&str]) -> Result<Output> {\n        let output = Command::new(\"flyctl\")\n            .args(args)\n            .output()\n            .map_err(|e| eyre!(\"Failed to run flyctl {}: {e}\", args.join(\" \")))?;\n        Ok(output)\n    }\n\n    /// Run a flyctl command asynchronously with consistent error handling\n    async fn run_fly_command_async(&self, args: &[&str]) -> Result<Output> {\n        let status = tokio::process::Command::new(\"flyctl\")\n            .args(args)\n            .output()\n            .await\n            .map_err(|e| eyre!(\"Failed to run flyctl {}: {e}\", args.join(\" \")))?;\n        Ok(status)\n    }\n\n    /// Get the API client and key (only for API auth)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_api_client_218": {
      "name": "get_api_client",
      "type": "method",
      "start_line": 218,
      "end_line": 296,
      "content_hash": "a569750d6b7ccf51f7f624a28018f3cc34334778",
      "content": "    fn get_api_client(&self) -> Result<(&reqwest::Client, &str)> {\n        match &self.auth {\n            FlyAuth::ApiKey(api_key) => {\n                // We'll create the client when needed for simplicity\n                // In a real implementation, we might cache this\n                static CLIENT: std::sync::OnceLock<reqwest::Client> = std::sync::OnceLock::new();\n                let client = CLIENT.get_or_init(reqwest::Client::new);\n                Ok((client, api_key))\n            }\n            FlyAuth::Cli => Err(eyre!(\n                \"API client not available when using CLI authentication\"\n            )),\n        }\n    }\n\n    // === STATIC UTILITY METHODS ===\n\n    /// Check if Fly.io CLI is installed and authenticated\n    pub async fn check_fly_cli_available() -> Result<()> {\n        let output = Command::new(\"flyctl\")\n            .output()\n            .map_err(|_| eyre!(\"flyctl is not installed or not available in PATH. Visit https://fly.io/docs/flyctl/install/\"))?;\n\n        if !output.status.success() {\n            return Err(eyre!(\"flyctl is installed but not working properly\"));\n        }\n\n        Ok(())\n    }\n\n    /// Check if Fly.io CLI is authenticated\n    async fn check_fly_cli_auth() -> Result<()> {\n        Self::check_fly_cli_available().await?;\n\n        println!(\"Checking Fly.io CLI authentication\");\n        let mut child = tokio::process::Command::new(\"flyctl\")\n            .args([\"auth\", \"whoami\"])\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()\n            .map_err(|e| eyre!(\"Failed to check Fly.io authentication: {e}\"))?;\n\n        if let Some(stdin) = child.stdin.as_mut() {\n            stdin.write_all(b\"N\\n\").await?;\n        }\n\n        let status = child.wait().await?;\n        if !status.success() {\n            return Err(eyre!(\n                \"Fly.io CLI authentication failed. Run 'flyctl auth login' first.\"\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Check if a Fly.io app exists by name\n    pub async fn app_exists(&self, app_name: &str) -> Result<bool> {\n        match &self.auth {\n            FlyAuth::ApiKey(api_key) => {\n                let (client, _) = self.get_api_client()?;\n                let response = client\n                    .get(format!(\"{FLY_MACHINES_API_URL}/apps/{app_name}\"))\n                    .header(\"Authorization\", format!(\"Bearer {api_key}\"))\n                    .send()\n                    .await?;\n\n                Ok(response.status().is_success())\n            }\n            FlyAuth::Cli => {\n                let status_output = self\n                    .run_fly_command_async(&[\"status\", \"-a\", app_name])\n                    .await?;\n                Ok(status_output.status.success())\n            }\n        }\n    }\n\n    /// Read the app name from an existing fly.toml file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_read_app_name_from_fly_toml_297": {
      "name": "read_app_name_from_fly_toml",
      "type": "method",
      "start_line": 297,
      "end_line": 320,
      "content_hash": "c8a12ec384d17d58444208f0ac2b1bba111bbeb7",
      "content": "    pub fn read_app_name_from_fly_toml(fly_toml_path: &Path) -> Result<Option<String>> {\n        if !fly_toml_path.exists() {\n            return Ok(None);\n        }\n\n        let content = std::fs::read_to_string(fly_toml_path)\n            .map_err(|e| eyre!(\"Failed to read fly.toml: {e}\"))?;\n\n        // Parse the TOML to extract the app name\n        let toml: toml::Value = content\n            .parse()\n            .map_err(|e| eyre!(\"Failed to parse fly.toml: {e}\"))?;\n\n        let app_name = toml\n            .get(\"app\")\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string());\n\n        Ok(app_name)\n    }\n\n    // === INSTANCE CONFIGURATION ===\n\n    /// Create a Fly.io instance configuration",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_create_instance_config_321": {
      "name": "create_instance_config",
      "type": "method",
      "start_line": 321,
      "end_line": 571,
      "content_hash": "2ca6b018723357cffdf15d7000cb0e28b25950a9",
      "content": "    pub fn create_instance_config(\n        &self,\n        _docker: &DockerManager<'_>,\n        instance_name: &str,\n        volume_initial_size: u16,\n        vm_size: VmSize,\n        private: bool,\n        auth_type: FlyAuthType,\n    ) -> FlyInstanceConfig {\n        let volume = format!(\"{}:/data\", self.volume_name(instance_name));\n\n        FlyInstanceConfig {\n            build_mode: BuildMode::default(),\n            region: None,\n            vm_size,\n            volume,\n            volume_initial_size,\n            private,\n            auth_type,\n            db_config: config::DbConfig::default(),\n        }\n    }\n\n    // === DEPLOYMENT OPERATIONS ===\n\n    /// Initialize a new Fly.io application\n    pub async fn init_app(&self, instance_name: &str, config: &FlyInstanceConfig) -> Result<()> {\n        let app_name = self.app_name(instance_name);\n\n        if app_name.len() > MAX_APP_NAME_LENGTH {\n            return Err(eyre!(\n                \"Fly.io app name '{}' exceeds {} characters (length: {}). \\\n                Consider using a shorter project name or instance name.\",\n                app_name,\n                MAX_APP_NAME_LENGTH,\n                app_name.len()\n            ));\n        }\n\n        // Check if fly.toml already exists for this instance\n        let fly_toml_path = self.project.instance_workspace(instance_name).join(\"fly.toml\");\n        if let Some(existing_app_name) = Self::read_app_name_from_fly_toml(&fly_toml_path)? {\n            // Check if the app in fly.toml exists on Fly.io\n            if self.app_exists(&existing_app_name).await? {\n                return Err(eyre!(\n                    \"A fly.toml already exists at '{}' with app name '{}', and this app already exists on Fly.io. \\\n                    Either delete the existing Fly.io app with 'flyctl apps destroy {}' or remove the fly.toml file.\",\n                    fly_toml_path.display(),\n                    existing_app_name,\n                    existing_app_name\n                ));\n            }\n        }\n\n        // Check if the target app name already exists on Fly.io\n        if self.app_exists(&app_name).await? {\n            return Err(eyre!(\n                \"Fly.io app '{}' already exists. Either delete the existing app with 'flyctl apps destroy {}' \\\n                or use a different instance name.\",\n                app_name,\n                app_name\n            ));\n        }\n\n        print_status(\"FLY\", &format!(\"Creating Fly.io app '{app_name}'\"));\n\n        match &self.auth {\n            FlyAuth::ApiKey(api_key) => {\n                let (client, _) = self.get_api_client()?;\n                let request = json!({\n                    \"app_name\": app_name,\n                    \"org_slug\": \"default\",\n                    \"network\": \"default\",\n                });\n\n                let response = client\n                    .post(format!(\"{FLY_MACHINES_API_URL}/apps\"))\n                    .header(\"Authorization\", format!(\"Bearer {api_key}\"))\n                    .json(&request)\n                    .send()\n                    .await?;\n\n                if !response.status().is_success() {\n                    return Err(eyre!(\n                        \"Failed to create Fly.io app '{app_name}': {}\",\n                        response.status()\n                    ));\n                }\n            }\n            FlyAuth::Cli => {\n                // Configure app with launch\n                let helix_dir_path = self.project.instance_workspace(instance_name);\n\n                let volume_size_str = config.volume_initial_size.to_string();\n\n                let mut launch_args = vec![\n                    \"launch\",\n                    \"--no-deploy\",\n                    \"--path\",\n                    helix_dir_path.to_str().ok_or_else(|| {\n                        eyre!(\n                            \"cannot convert helix instance workspace to string: {helix_dir_path:?}\"\n                        )\n                    })?,\n                ];\n\n                // Add VM size args\n                let vm_args = config.vm_size.into_command_args();\n                launch_args.extend_from_slice(&vm_args);\n\n                // Add volume args\n                let volume_name = config.volume.replace(\"-\", \"_\");\n                launch_args.extend_from_slice(&[\"--volume\", &volume_name]);\n                launch_args.extend_from_slice(&[\"--volume-initial-size\", &volume_size_str]);\n\n                // Add internal port args\n                launch_args.extend_from_slice(&[\"--internal-port\", INTERNAL_PORT]);\n\n                // name the app\n                launch_args.extend_from_slice(&[\"--name\", &app_name]);\n\n                // Add privacy args\n                launch_args.extend_from_slice(&match config.private {\n                    true => vec![\"--no-public-ips\"],\n                    false => vec![],\n                });\n\n                let launch_status = tokio::process::Command::new(\"flyctl\")\n                    .args(&launch_args)\n                    .output()\n                    .await\n                    .map_err(|e| eyre!(\"Failed to run flyctl launch: {e}\"))?;\n\n                if !launch_status.status.success() {\n                    return Err(eyre!(\"Failed to configure Fly.io app '{app_name}'\"));\n                }\n            }\n        }\n\n        println!(\"[FLY] App '{app_name}' created successfully\");\n        Ok(())\n    }\n\n    /// Deploy an image to Fly.io\n    pub async fn deploy_image(\n        &self,\n        docker: &DockerManager<'_>,\n        _config: &FlyInstanceConfig,\n        instance_name: &str,\n        image_name: &str,\n    ) -> Result<()> {\n        let app_name = self.app_name(instance_name);\n        let registry_image = self.registry_image_name(image_name);\n        let helix_dir_path = &self\n            .project\n            .instance_workspace(instance_name)\n            .join(\"fly.toml\")\n            .display()\n            .to_string();\n\n        print_status(\"FLY\", &format!(\"Deploying '{app_name}' to Fly.io\"));\n        println!(\"\\tImage: {image_name}\");\n\n        match &self.auth {\n            FlyAuth::ApiKey(_) => Err(eyre!(\n                \"API-based deployment not yet implemented. Use CLI authentication instead.\"\n            )),\n            FlyAuth::Cli => {\n                // Tag image for Fly.io registry\n                print_status(\"FLY\", \"Tagging image for Fly.io registry\");\n\n                // authenticate docker\n                let auth_args = vec![\"auth\", \"docker\"];\n                let auth_status = self.run_fly_command_async(&auth_args).await?;\n                if !auth_status.status.success() {\n                    return Err(eyre!(\"Failed to authenticate Docker with Fly.io\"));\n                }\n\n                docker.tag(image_name, FLY_REGISTRY_URL)?;\n\n                // Push image to registry\n                print_status(\n                    \"FLY\",\n                    &format!(\"Pushing image '{image_name}' to Fly.io registry\"),\n                );\n                docker.push(image_name, FLY_REGISTRY_URL)?;\n\n                // Get environment variables first to ensure they live long enough\n                let env_vars = docker.environment_variables(instance_name);\n\n                let mut deploy_args = vec![\n                    \"deploy\",\n                    \"--image\",\n                    &registry_image,\n                    \"--config\",\n                    &helix_dir_path,\n                    \"-a\",\n                    &app_name,\n                    \"--now\",\n                ];\n\n                // Add environment variables to deploy args\n                for env in &env_vars {\n                    deploy_args.push(\"--env\");\n                    deploy_args.push(env);\n                }\n\n                // Deploy image\n                print_status(\"FLY\", \"Deploying image to Fly.io\");\n                let deploy_status = self.run_fly_command_async(&deploy_args).await?;\n\n                if !deploy_status.status.success() {\n                    return Err(eyre!(\"Failed to deploy image '{registry_image}'\"));\n                }\n\n                println!(\"[FLY] Image '{registry_image}' deployed successfully\");\n                Ok(())\n            }\n        }\n    }\n\n    /// Stop a Fly.io instance\n    pub async fn stop_instance(&self, instance_name: &str) -> Result<()> {\n        let app_name = self.app_name(instance_name);\n        let stop_status = self\n            .run_fly_command_async(&[\"scale\", \"count\", \"0\", \"-a\", &app_name, \"-y\"])\n            .await?;\n        if !stop_status.status.success() {\n            return Err(eyre!(\"Failed to stop Fly.io app '{app_name}'\"));\n        }\n\n        println!(\"[FLY] App '{app_name}' stopped successfully\");\n        Ok(())\n    }\n\n    /// Start a Fly.io instance\n    pub async fn start_instance(&self, instance_name: &str) -> Result<()> {\n        let app_name = self.app_name(instance_name);\n        let start_status = self\n            .run_fly_command_async(&[\"scale\", \"count\", \"1\", \"-a\", &app_name, \"-y\"])\n            .await?;\n        if !start_status.status.success() {\n            return Err(eyre!(\"Failed to start Fly.io app '{app_name}'\"));\n        }\n\n        println!(\"[FLY] App '{app_name}' started successfully\");\n        Ok(())\n    }\n\n    /// Get the status of Fly.io apps for this project\n    #[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_project_status_572": {
      "name": "get_project_status",
      "type": "method",
      "start_line": 572,
      "end_line": 635,
      "content_hash": "b6efca6819b1c2aff5f2aacc023fa676a372aeff",
      "content": "    pub fn get_project_status(&self) -> Result<Vec<FlyAppStatus>> {\n        let output = self.run_fly_command(&[\"apps\", \"list\", \"--json\"])?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to get Fly.io app status:\\n{stderr}\"));\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let apps: serde_json::Value = serde_json::from_str(&stdout)\n            .map_err(|e| eyre!(\"Failed to parse Fly.io apps JSON: {e}\"))?;\n\n        let mut statuses = Vec::new();\n        let sanitized_project_name = self.project.config.project.name.replace('_', \"-\");\n        let project_prefix = format!(\"helix-{}-\", sanitized_project_name);\n\n        if let Some(apps_array) = apps.as_array() {\n            for app in apps_array {\n                if let Some(name) = app.get(\"name\").and_then(|n| n.as_str())\n                    && let Some(instance_name) = name.strip_prefix(&project_prefix)\n                {\n                    let status = app\n                        .get(\"status\")\n                        .and_then(|s| s.as_str())\n                        .unwrap_or(\"unknown\");\n                    let region = app\n                        .get(\"primaryRegion\")\n                        .and_then(|r| r.as_str())\n                        .unwrap_or(\"unknown\");\n\n                    statuses.push(FlyAppStatus {\n                        instance_name: instance_name.to_string(),\n                        app_name: name.to_string(),\n                        status: status.to_string(),\n                        region: region.to_string(),\n                    });\n                }\n            }\n        }\n\n        Ok(statuses)\n    }\n\n    /// Delete a Fly.io application\n    pub async fn delete_app(&self, instance_name: &str) -> Result<()> {\n        let app_name = self.app_name(instance_name);\n\n        print_status(\"FLY\", &format!(\"Deleting Fly.io app '{app_name}'\"));\n\n        let delete_status = self\n            .run_fly_command_async(&[\"apps\", \"destroy\", &app_name, \"--yes\"])\n            .await?;\n\n        if !delete_status.status.success() {\n            return Err(eyre!(\"Failed to delete Fly.io app '{app_name}'\"));\n        }\n\n        println!(\"[FLY] App '{app_name}' deleted successfully\");\n        Ok(())\n    }\n}\n\n#[derive(Debug)]\n#[allow(unused)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FlyAppStatus_636": {
      "name": "FlyAppStatus",
      "type": "struct",
      "start_line": 636,
      "end_line": 641,
      "content_hash": "0f3f85c82f87fe30048ddf96ec3798e4029ec194",
      "content": "pub struct FlyAppStatus {\n    pub instance_name: String,\n    pub app_name: String,\n    pub status: String,\n    pub region: String,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}