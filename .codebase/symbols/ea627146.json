{
  "file_path": "/work/external-deps/claude-mem/src/utils/transcript-parser.ts",
  "file_hash": "8024d230e22236c65b4680a5e9717eb305ac1c3a",
  "updated_at": "2025-12-26T17:34:20.898139",
  "symbols": {
    "class_TranscriptParser_26": {
      "name": "TranscriptParser",
      "type": "class",
      "start_line": 26,
      "end_line": 254,
      "content_hash": "363e8fde00c9fa67512742bd40f79167da7d2b62",
      "content": "export class TranscriptParser {\n  private entries: TranscriptEntry[] = [];\n  private parseErrors: Array<{ lineNumber: number; error: string }> = [];\n\n  constructor(transcriptPath: string) {\n    this.parseTranscript(transcriptPath);\n  }\n\n  private parseTranscript(transcriptPath: string): void {\n    const content = readFileSync(transcriptPath, 'utf-8').trim();\n    if (!content) return;\n\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      try {\n        const entry = JSON.parse(line) as TranscriptEntry;\n        this.entries.push(entry);\n      } catch (error) {\n        this.parseErrors.push({\n          lineNumber: index + 1,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    });\n  }\n\n  /**\n   * Get all entries of a specific type\n   */\n  getEntriesByType<T extends TranscriptEntry>(type: T['type']): T[] {\n    return this.entries.filter((e) => e.type === type) as T[];\n  }\n\n  /**\n   * Get all user entries\n   */\n  getUserEntries(): UserTranscriptEntry[] {\n    return this.getEntriesByType<UserTranscriptEntry>('user');\n  }\n\n  /**\n   * Get all assistant entries\n   */\n  getAssistantEntries(): AssistantTranscriptEntry[] {\n    return this.getEntriesByType<AssistantTranscriptEntry>('assistant');\n  }\n\n  /**\n   * Get all summary entries\n   */\n  getSummaryEntries(): SummaryTranscriptEntry[] {\n    return this.getEntriesByType<SummaryTranscriptEntry>('summary');\n  }\n\n  /**\n   * Get all system entries\n   */\n  getSystemEntries(): SystemTranscriptEntry[] {\n    return this.getEntriesByType<SystemTranscriptEntry>('system');\n  }\n\n  /**\n   * Get all queue operation entries\n   */\n  getQueueOperationEntries(): QueueOperationTranscriptEntry[] {\n    return this.getEntriesByType<QueueOperationTranscriptEntry>('queue-operation');\n  }\n\n  /**\n   * Get last entry of a specific type\n   */\n  getLastEntryByType<T extends TranscriptEntry>(type: T['type']): T | null {\n    const entries = this.getEntriesByType<T>(type);\n    return entries.length > 0 ? entries[entries.length - 1] : null;\n  }\n\n  /**\n   * Extract text content from content items\n   */\n  private extractTextFromContent(content: string | ContentItem[]): string {\n    if (typeof content === 'string') {\n      return content;\n    }\n\n    if (Array.isArray(content)) {\n      return content\n        .filter((item): item is TextContent => item.type === 'text')\n        .map((item) => item.text)\n        .join('\\n');\n    }\n\n    return '';\n  }\n\n  /**\n   * Get last user message text (finds last entry with actual text content)\n   */\n  getLastUserMessage(): string {\n    const userEntries = this.getUserEntries();\n\n    // Iterate backward to find the last user message with text content\n    for (let i = userEntries.length - 1; i >= 0; i--) {\n      const entry = userEntries[i];\n      if (!entry?.message?.content) continue;\n\n      const text = this.extractTextFromContent(entry.message.content);\n      if (text) return text;\n    }\n\n    return '';\n  }\n\n  /**\n   * Get last assistant message text (finds last entry with text content, with optional system-reminder filtering)\n   */\n  getLastAssistantMessage(filterSystemReminders = true): string {\n    const assistantEntries = this.getAssistantEntries();\n\n    // Iterate backward to find the last assistant message with text content\n    for (let i = assistantEntries.length - 1; i >= 0; i--) {\n      const entry = assistantEntries[i];\n      if (!entry?.message?.content) continue;\n\n      let text = this.extractTextFromContent(entry.message.content);\n      if (!text) continue;\n\n      if (filterSystemReminders) {\n        // Filter out system-reminder tags and their content\n        text = text.replace(/<system-reminder>[\\s\\S]*?<\\/system-reminder>/g, '');\n        // Clean up excessive whitespace\n        text = text.replace(/\\n{3,}/g, '\\n\\n').trim();\n      }\n\n      if (text) return text;\n    }\n\n    return '';\n  }\n\n  /**\n   * Get all tool use operations from assistant entries\n   */\n  getToolUseHistory(): Array<{ name: string; timestamp: string; input: any }> {\n    const toolUses: Array<{ name: string; timestamp: string; input: any }> = [];\n\n    for (const entry of this.getAssistantEntries()) {\n      if (Array.isArray(entry.message.content)) {\n        for (const item of entry.message.content) {\n          if (item.type === 'tool_use') {\n            toolUses.push({\n              name: item.name,\n              timestamp: entry.timestamp,\n              input: item.input,\n            });\n          }\n        }\n      }\n    }\n\n    return toolUses;\n  }\n\n  /**\n   * Get total token usage across all assistant messages\n   */\n  getTotalTokenUsage(): {\n    inputTokens: number;\n    outputTokens: number;\n    cacheCreationTokens: number;\n    cacheReadTokens: number;\n  } {\n    const assistantEntries = this.getAssistantEntries();\n\n    return assistantEntries.reduce(\n      (acc, entry) => {\n        const usage = entry.message.usage;\n        if (usage) {\n          acc.inputTokens += usage.input_tokens || 0;\n          acc.outputTokens += usage.output_tokens || 0;\n          acc.cacheCreationTokens += usage.cache_creation_input_tokens || 0;\n          acc.cacheReadTokens += usage.cache_read_input_tokens || 0;\n        }\n        return acc;\n      },\n      {\n        inputTokens: 0,\n        outputTokens: 0,\n        cacheCreationTokens: 0,\n        cacheReadTokens: 0,\n      }\n    );\n  }\n\n  /**\n   * Get parse statistics\n   */\n  getParseStats(): ParseStats {\n    const entriesByType: Record<string, number> = {};\n\n    for (const entry of this.entries) {\n      entriesByType[entry.type] = (entriesByType[entry.type] || 0) + 1;\n    }\n\n    const totalLines = this.entries.length + this.parseErrors.length;\n\n    return {\n      totalLines,\n      parsedEntries: this.entries.length,\n      failedLines: this.parseErrors.length,\n      entriesByType,\n      failureRate: totalLines > 0 ? this.parseErrors.length / totalLines : 0,\n    };\n  }\n\n  /**\n   * Get parse errors\n   */\n  getParseErrors(): Array<{ lineNumber: number; error: string }> {\n    return this.parseErrors;\n  }\n\n  /**\n   * Get all entries (raw)\n   */\n  getAllEntries(): TranscriptEntry[] {\n    return this.entries;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_30": {
      "name": "constructor",
      "type": "method",
      "start_line": 30,
      "end_line": 32,
      "content_hash": "be4d34ff7ceed10cbd14bdf5ebf8e4cdc1caa95e",
      "content": "  constructor(transcriptPath: string) {\n    this.parseTranscript(transcriptPath);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseTranscript_34": {
      "name": "parseTranscript",
      "type": "method",
      "start_line": 34,
      "end_line": 51,
      "content_hash": "65a5635c0a37977c341ed3c4f176c47e011326ee",
      "content": "  private parseTranscript(transcriptPath: string): void {\n    const content = readFileSync(transcriptPath, 'utf-8').trim();\n    if (!content) return;\n\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      try {\n        const entry = JSON.parse(line) as TranscriptEntry;\n        this.entries.push(entry);\n      } catch (error) {\n        this.parseErrors.push({\n          lineNumber: index + 1,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getEntriesByType_56": {
      "name": "getEntriesByType",
      "type": "method",
      "start_line": 56,
      "end_line": 58,
      "content_hash": "ff31a2279c962dd9b06815dc3c4bee58eb06c5ff",
      "content": "  getEntriesByType<T extends TranscriptEntry>(type: T['type']): T[] {\n    return this.entries.filter((e) => e.type === type) as T[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getUserEntries_63": {
      "name": "getUserEntries",
      "type": "method",
      "start_line": 63,
      "end_line": 65,
      "content_hash": "f3b60e07cef96e0d9856ce57b3e1c1cfa92a14cd",
      "content": "  getUserEntries(): UserTranscriptEntry[] {\n    return this.getEntriesByType<UserTranscriptEntry>('user');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAssistantEntries_70": {
      "name": "getAssistantEntries",
      "type": "method",
      "start_line": 70,
      "end_line": 72,
      "content_hash": "9a8e0caf478b90d605d86415129ccfbb453d9823",
      "content": "  getAssistantEntries(): AssistantTranscriptEntry[] {\n    return this.getEntriesByType<AssistantTranscriptEntry>('assistant');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSummaryEntries_77": {
      "name": "getSummaryEntries",
      "type": "method",
      "start_line": 77,
      "end_line": 79,
      "content_hash": "037784f7ddebf57d93779f724609b2e9a0bdf922",
      "content": "  getSummaryEntries(): SummaryTranscriptEntry[] {\n    return this.getEntriesByType<SummaryTranscriptEntry>('summary');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getSystemEntries_84": {
      "name": "getSystemEntries",
      "type": "method",
      "start_line": 84,
      "end_line": 86,
      "content_hash": "041b7fb10c5b1be0f4a27ba3e219f0c03aedc070",
      "content": "  getSystemEntries(): SystemTranscriptEntry[] {\n    return this.getEntriesByType<SystemTranscriptEntry>('system');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getQueueOperationEntries_91": {
      "name": "getQueueOperationEntries",
      "type": "method",
      "start_line": 91,
      "end_line": 93,
      "content_hash": "472d05b75e52bb84e6f55a45fbafde9cbc25a2a6",
      "content": "  getQueueOperationEntries(): QueueOperationTranscriptEntry[] {\n    return this.getEntriesByType<QueueOperationTranscriptEntry>('queue-operation');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getLastEntryByType_98": {
      "name": "getLastEntryByType",
      "type": "method",
      "start_line": 98,
      "end_line": 101,
      "content_hash": "6d55a69f855dadb9854e5e4379d4b7a109d49f2d",
      "content": "  getLastEntryByType<T extends TranscriptEntry>(type: T['type']): T | null {\n    const entries = this.getEntriesByType<T>(type);\n    return entries.length > 0 ? entries[entries.length - 1] : null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractTextFromContent_106": {
      "name": "extractTextFromContent",
      "type": "method",
      "start_line": 106,
      "end_line": 119,
      "content_hash": "222cec5ba13fed76504dc86cbd4832c5a204af89",
      "content": "  private extractTextFromContent(content: string | ContentItem[]): string {\n    if (typeof content === 'string') {\n      return content;\n    }\n\n    if (Array.isArray(content)) {\n      return content\n        .filter((item): item is TextContent => item.type === 'text')\n        .map((item) => item.text)\n        .join('\\n');\n    }\n\n    return '';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getLastUserMessage_124": {
      "name": "getLastUserMessage",
      "type": "method",
      "start_line": 124,
      "end_line": 137,
      "content_hash": "7be6d68fe70d16f9cc2737bbd054088f0988dba9",
      "content": "  getLastUserMessage(): string {\n    const userEntries = this.getUserEntries();\n\n    // Iterate backward to find the last user message with text content\n    for (let i = userEntries.length - 1; i >= 0; i--) {\n      const entry = userEntries[i];\n      if (!entry?.message?.content) continue;\n\n      const text = this.extractTextFromContent(entry.message.content);\n      if (text) return text;\n    }\n\n    return '';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getLastAssistantMessage_142": {
      "name": "getLastAssistantMessage",
      "type": "method",
      "start_line": 142,
      "end_line": 164,
      "content_hash": "68eda89906eb7bd246b951d04f649922d3080ec5",
      "content": "  getLastAssistantMessage(filterSystemReminders = true): string {\n    const assistantEntries = this.getAssistantEntries();\n\n    // Iterate backward to find the last assistant message with text content\n    for (let i = assistantEntries.length - 1; i >= 0; i--) {\n      const entry = assistantEntries[i];\n      if (!entry?.message?.content) continue;\n\n      let text = this.extractTextFromContent(entry.message.content);\n      if (!text) continue;\n\n      if (filterSystemReminders) {\n        // Filter out system-reminder tags and their content\n        text = text.replace(/<system-reminder>[\\s\\S]*?<\\/system-reminder>/g, '');\n        // Clean up excessive whitespace\n        text = text.replace(/\\n{3,}/g, '\\n\\n').trim();\n      }\n\n      if (text) return text;\n    }\n\n    return '';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getToolUseHistory_169": {
      "name": "getToolUseHistory",
      "type": "method",
      "start_line": 169,
      "end_line": 187,
      "content_hash": "d92c8bc0bd00a83ab19375d01c324d0989aec745",
      "content": "  getToolUseHistory(): Array<{ name: string; timestamp: string; input: any }> {\n    const toolUses: Array<{ name: string; timestamp: string; input: any }> = [];\n\n    for (const entry of this.getAssistantEntries()) {\n      if (Array.isArray(entry.message.content)) {\n        for (const item of entry.message.content) {\n          if (item.type === 'tool_use') {\n            toolUses.push({\n              name: item.name,\n              timestamp: entry.timestamp,\n              input: item.input,\n            });\n          }\n        }\n      }\n    }\n\n    return toolUses;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTotalTokenUsage_192": {
      "name": "getTotalTokenUsage",
      "type": "method",
      "start_line": 192,
      "end_line": 218,
      "content_hash": "acb3cb0cb312136d6e9a2f7312b01bc64e402c4b",
      "content": "  getTotalTokenUsage(): {\n    inputTokens: number;\n    outputTokens: number;\n    cacheCreationTokens: number;\n    cacheReadTokens: number;\n  } {\n    const assistantEntries = this.getAssistantEntries();\n\n    return assistantEntries.reduce(\n      (acc, entry) => {\n        const usage = entry.message.usage;\n        if (usage) {\n          acc.inputTokens += usage.input_tokens || 0;\n          acc.outputTokens += usage.output_tokens || 0;\n          acc.cacheCreationTokens += usage.cache_creation_input_tokens || 0;\n          acc.cacheReadTokens += usage.cache_read_input_tokens || 0;\n        }\n        return acc;\n      },\n      {\n        inputTokens: 0,\n        outputTokens: 0,\n        cacheCreationTokens: 0,\n        cacheReadTokens: 0,\n      }\n    );\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getParseStats_223": {
      "name": "getParseStats",
      "type": "method",
      "start_line": 223,
      "end_line": 239,
      "content_hash": "d08534f96df7241481ad45e2176a36392e8bea76",
      "content": "  getParseStats(): ParseStats {\n    const entriesByType: Record<string, number> = {};\n\n    for (const entry of this.entries) {\n      entriesByType[entry.type] = (entriesByType[entry.type] || 0) + 1;\n    }\n\n    const totalLines = this.entries.length + this.parseErrors.length;\n\n    return {\n      totalLines,\n      parsedEntries: this.entries.length,\n      failedLines: this.parseErrors.length,\n      entriesByType,\n      failureRate: totalLines > 0 ? this.parseErrors.length / totalLines : 0,\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getParseErrors_244": {
      "name": "getParseErrors",
      "type": "method",
      "start_line": 244,
      "end_line": 246,
      "content_hash": "63344370806f9d6f6971999e2abd95340b9a0cc0",
      "content": "  getParseErrors(): Array<{ lineNumber: number; error: string }> {\n    return this.parseErrors;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getAllEntries_251": {
      "name": "getAllEntries",
      "type": "method",
      "start_line": 251,
      "end_line": 253,
      "content_hash": "8f18c3b54b282ed129ba02b54539b90946c73fd7",
      "content": "  getAllEntries(): TranscriptEntry[] {\n    return this.entries;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}