{
  "file_path": "/work/external-deps/helix-db/helix-db/src/utils/items.rs",
  "file_hash": "86f9801c5bd044a1bb91d3b86a0f0615f47ee6e4",
  "updated_at": "2025-12-26T17:34:24.036894",
  "symbols": {
    "struct_Node_19": {
      "name": "Node",
      "type": "struct",
      "start_line": 19,
      "end_line": 38,
      "content_hash": "06253ab208cee85d563f6441b7610175d3950ab8",
      "content": "pub struct Node<'arena> {\n    /// The ID of the node.\n    ///\n    /// This is not serialized when stored as it is the key.\n    pub id: u128,\n    /// The label of the node.\n    pub label: &'arena str,\n    /// The version of the node.\n    pub version: u8,\n    /// The properties of the node.\n    ///\n    /// Properties are optional and can be None.\n    /// Properties are serialised without enum variant names in JSON format.\n    pub properties: Option<ImmutablePropertiesMap<'arena>>,\n}\n\n// Custom Serialize implementation to match old #[derive(Serialize)] behavior\n// Bincode serializes #[derive(Serialize)] structs using serialize_struct internally\n// which produces a compact format without length prefixes\n// For JSON serialization, the id field is included, but for bincode it is skipped",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_serde::Serialize_39": {
      "name": "serde::Serialize",
      "type": "impl",
      "start_line": 39,
      "end_line": 70,
      "content_hash": "e75e2fa2033d275065e9c4cde7d3b4b2ecd36273",
      "content": "impl<'arena> serde::Serialize for Node<'arena> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        // Check if this is a human-readable format (like JSON)\n        if serializer.is_human_readable() {\n            // Include id for JSON serialization\n            let mut buffer = [0u8; 36];\n            let mut state = serializer.serialize_map(Some(3 + self.properties.as_ref().map(|p| p.len()).unwrap_or(0)))?;\n            state.serialize_entry(\"id\", uuid_str_from_buf(self.id, &mut buffer))?;\n            state.serialize_entry(\"label\",    self.label)?;\n            state.serialize_entry(\"version\", &self.version)?;\n            if let Some(properties  ) = &self.properties {\n                for (key, value) in properties.iter() {\n                    state.serialize_entry(key, value)?;\n                }\n            }\n            state.end()\n        } else {\n            // Skip id for bincode serialization\n            let mut state = serializer.serialize_struct(\"Node\", 3)?;\n            state.serialize_field(\"label\", self.label)?;\n            state.serialize_field(\"version\", &self.version)?;\n            state.serialize_field(\"properties\", &self.properties)?;\n            state.end()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Node_71": {
      "name": "Node",
      "type": "impl",
      "start_line": 71,
      "end_line": 75,
      "content_hash": "bff2f55144ca336347e963b864d8e0f4bca7038e",
      "content": "impl<'arena> Node<'arena> {\n    /// Gets property from node\n    ///\n    /// NOTE: the `'arena` lifetime which comes from the fact the node's ImmutablePropertiesMap\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_property_76": {
      "name": "get_property",
      "type": "method",
      "start_line": 76,
      "end_line": 97,
      "content_hash": "f0322d6e59043082f6e50e5f22f1683b081b6b37",
      "content": "    pub fn get_property(&self, prop: &str) -> Option<&'arena Value> {\n        self.properties.and_then(|value| value.get(prop))\n    }\n\n    /// Deserializes bytes into a node using a custom deserializer that allocates into the provided arena\n    ///\n    /// NOTE: in this method, fixint encoding is used\n    #[inline(always)]\n    pub fn from_bincode_bytes<'txn>(\n        id: u128,\n        bytes: &'txn [u8],\n        arena: &'arena bumpalo::Bump,\n    ) -> bincode::Result<Self> {\n        // Use fixint encoding to match bincode::serialize() behavior (8-byte lengths)\n        // Allow trailing bytes since we manually control Option reading\n        bincode::DefaultOptions::new()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(NodeDeSeed { arena, id }, bytes)\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_bincode_bytes_98": {
      "name": "to_bincode_bytes",
      "type": "method",
      "start_line": 98,
      "end_line": 103,
      "content_hash": "5ec16e51bff5b6dd9de8b4263fc5fd77cad0d74d",
      "content": "    pub fn to_bincode_bytes(&self) -> Result<Vec<u8>, bincode::Error> {\n        bincode::serialize(self)\n    }\n}\n\n// Core trait implementations for Node",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::fmt::Display_104": {
      "name": "std::fmt::Display",
      "type": "impl",
      "start_line": 104,
      "end_line": 104,
      "content_hash": "1ea06d5bc035c9aaa0bed112c7fd39786fdbcea8",
      "content": "impl std::fmt::Display for Node<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_105": {
      "name": "fmt",
      "type": "method",
      "start_line": 105,
      "end_line": 113,
      "content_hash": "32f515d6d57756b6ff64c636effca588dc63441f",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"{{ id: {}, label: {} }}\",\n            uuid::Uuid::from_u128(self.id),\n            self.label,\n        )\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::fmt::Debug_114": {
      "name": "std::fmt::Debug",
      "type": "impl",
      "start_line": 114,
      "end_line": 114,
      "content_hash": "2fba43c13223c15f17607e82d5c2aa9e22636e56",
      "content": "impl std::fmt::Debug for Node<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_115": {
      "name": "fmt",
      "type": "method",
      "start_line": 115,
      "end_line": 124,
      "content_hash": "6469739590e5c180f8a45fc3b46edcde0a9c1588",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"{{ \\nid:{},\\nlabel:{} }}\",\n            uuid::Uuid::from_u128(self.id),\n            self.label,\n        )\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_125": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 125,
      "end_line": 125,
      "content_hash": "5619f3d1926823220f840721513dc78fcd04e2ce",
      "content": "impl PartialEq for Node<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_126": {
      "name": "eq",
      "type": "method",
      "start_line": 126,
      "end_line": 129,
      "content_hash": "e42e74568e66462fe2136c6e1059be269af7bdfd",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.id == other.id\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_130": {
      "name": "Eq",
      "type": "impl",
      "start_line": 130,
      "end_line": 130,
      "content_hash": "c2dd0cd49d03b888c0aaadaa6ed16e00622bd6ba",
      "content": "impl Eq for Node<'_> {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_131": {
      "name": "Ord",
      "type": "impl",
      "start_line": 131,
      "end_line": 131,
      "content_hash": "86120ddbf23f0cef6c68f506bda4eedac058cf6c",
      "content": "impl Ord for Node<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_132": {
      "name": "cmp",
      "type": "method",
      "start_line": 132,
      "end_line": 135,
      "content_hash": "a3646a792af49868a7358ec7e919f7a6e8a52752",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        self.id.cmp(&other.id)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_136": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 136,
      "end_line": 136,
      "content_hash": "3101b85db1194ac8f44bb722c54e54c38d3bb314",
      "content": "impl PartialOrd for Node<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_137": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 137,
      "end_line": 144,
      "content_hash": "5ded0214449840bd43744cc780454671fee01c84",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// An edge in the graph connecting two nodes with an ID, label, and property map.\n/// Properties are serialised without enum variant names in JSON format.\n#[derive(Clone, Copy)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Edge_145": {
      "name": "Edge",
      "type": "struct",
      "start_line": 145,
      "end_line": 168,
      "content_hash": "a6d22beedd5c9266d4ed1f8c499d0fb95537841f",
      "content": "pub struct Edge<'arena> {\n    /// The ID of the edge.\n    ///\n    /// This is not serialized when stored as it is the key.\n    pub id: u128,\n    /// The label of the edge.\n    pub label: &'arena str,\n    /// The version of the edge.\n    pub version: u8,\n    /// The ID of the from node.\n    pub from_node: u128,\n    /// The ID of the to node.\n    pub to_node: u128,\n    /// The properties of the edge.\n    ///\n    /// Properties are optional and can be None.\n    /// Properties are serialised without enum variant names in JSON format.\n    pub properties: Option<ImmutablePropertiesMap<'arena>>,\n}\n\n// Custom Serialize implementation to match old #[derive(Serialize)] behavior\n// Bincode serializes #[derive(Serialize)] structs using serialize_struct internally\n// which produces a compact format without length prefixes\n// For JSON serialization, the id field is included, but for bincode it is skipped",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_serde::Serialize_169": {
      "name": "serde::Serialize",
      "type": "impl",
      "start_line": 169,
      "end_line": 204,
      "content_hash": "7700794b27d0eecf8772b49e01f7619452a1fde7",
      "content": "impl<'arena> serde::Serialize for Edge<'arena> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        // Check if this is a human-readable format (like JSON)\n        if serializer.is_human_readable() {\n            // Include id for JSON serialization\n            let mut buffer = [0u8; 36];\n            let mut state = serializer.serialize_map(Some(5 + self.properties.as_ref().map(|p| p.len()).unwrap_or(0)))?;\n            state.serialize_entry(\"id\", uuid_str_from_buf(self.id, &mut buffer))?;\n            state.serialize_entry(\"label\", self.label)?;\n            state.serialize_entry(\"version\", &self.version)?;\n            state.serialize_entry(\"from_node\", &self.from_node)?;\n            state.serialize_entry(\"to_node\", &self.to_node)?;\n            if let Some(properties) = &self.properties {\n                for (key, value) in properties.iter() {\n                    state.serialize_entry(key, value)?;\n                }\n            }\n            state.end()\n        } else {\n            // Skip id for bincode serialization\n            let mut state = serializer.serialize_struct(\"Edge\", 5)?;\n            state.serialize_field(\"label\", self.label)?;\n            state.serialize_field(\"version\", &self.version)?;\n            state.serialize_field(\"from_node\", &self.from_node)?;\n            state.serialize_field(\"to_node\", &self.to_node)?;\n            state.serialize_field(\"properties\", &self.properties)?;\n            state.end()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Edge_205": {
      "name": "Edge",
      "type": "impl",
      "start_line": 205,
      "end_line": 209,
      "content_hash": "9d43a24ee476ff18e5c4d1787637c92cb3ce7395",
      "content": "impl<'arena> Edge<'arena> {\n    /// Gets property from node\n    ///\n    /// NOTE: the `'arena` lifetime which comes from the fact the node's ImmutablePropertiesMap\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_property_210": {
      "name": "get_property",
      "type": "method",
      "start_line": 210,
      "end_line": 230,
      "content_hash": "af291a021c32e805e1a02d2f58dc36664e53f28c",
      "content": "    pub fn get_property(&self, prop: &str) -> Option<&'arena Value> {\n        self.properties.as_ref().and_then(|value| value.get(prop))\n    }\n\n    /// Deserializes bytes into an edge using a custom deserializer that allocates into the provided arena\n    ///\n    /// NOTE: in this method, fixint encoding is used\n    #[inline(always)]\n    pub fn from_bincode_bytes<'txn>(\n        id: u128,\n        bytes: &'txn [u8],\n        arena: &'arena bumpalo::Bump,\n    ) -> bincode::Result<Self> {\n        // Use fixint encoding to match bincode::serialize() behavior (8-byte lengths)\n        bincode::DefaultOptions::new()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(EdgeDeSeed { arena, id }, bytes)\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_bincode_bytes_231": {
      "name": "to_bincode_bytes",
      "type": "method",
      "start_line": 231,
      "end_line": 236,
      "content_hash": "9ea363e95898070242873285180927640e51055a",
      "content": "    pub fn to_bincode_bytes(&self) -> Result<Vec<u8>, bincode::Error> {\n        bincode::serialize(self)\n    }\n}\n\n// Core trait implementations for Edge",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::fmt::Display_237": {
      "name": "std::fmt::Display",
      "type": "impl",
      "start_line": 237,
      "end_line": 237,
      "content_hash": "125867a030bac997733eb671af1fac78ea6ef675",
      "content": "impl std::fmt::Display for Edge<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_238": {
      "name": "fmt",
      "type": "method",
      "start_line": 238,
      "end_line": 248,
      "content_hash": "f4a97bf6d042d3423b6bf3cf142c1399afc049bf",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"{{ id: {}, label: {}, from_node: {}, to_node: {}}}\",\n            uuid::Uuid::from_u128(self.id),\n            self.label,\n            uuid::Uuid::from_u128(self.from_node),\n            uuid::Uuid::from_u128(self.to_node),\n        )\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::fmt::Debug_249": {
      "name": "std::fmt::Debug",
      "type": "impl",
      "start_line": 249,
      "end_line": 249,
      "content_hash": "596ff90ce1e3fb5f419a6360d1656702204230a5",
      "content": "impl std::fmt::Debug for Edge<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_250": {
      "name": "fmt",
      "type": "method",
      "start_line": 250,
      "end_line": 260,
      "content_hash": "77db7308edc7be91931818c4be5afc57701ab6d2",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"{{ \\nid: {},\\nlabel: {},\\nfrom_node: {},\\nto_node: {}}}\",\n            uuid::Uuid::from_u128(self.id),\n            self.label,\n            uuid::Uuid::from_u128(self.from_node),\n            uuid::Uuid::from_u128(self.to_node),\n        )\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_261": {
      "name": "Eq",
      "type": "impl",
      "start_line": 261,
      "end_line": 261,
      "content_hash": "0aed54202fed1911571788c6c86b8c198f6a5008",
      "content": "impl Eq for Edge<'_> {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_262": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 262,
      "end_line": 262,
      "content_hash": "8633ea9a134d692d1cdffd9f80870073e9af693c",
      "content": "impl PartialEq for Edge<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_263": {
      "name": "eq",
      "type": "method",
      "start_line": 263,
      "end_line": 266,
      "content_hash": "e42e74568e66462fe2136c6e1059be269af7bdfd",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.id == other.id\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_267": {
      "name": "Ord",
      "type": "impl",
      "start_line": 267,
      "end_line": 267,
      "content_hash": "d76a447543c963e511513814442f207e55658794",
      "content": "impl Ord for Edge<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_268": {
      "name": "cmp",
      "type": "method",
      "start_line": 268,
      "end_line": 271,
      "content_hash": "a3646a792af49868a7358ec7e919f7a6e8a52752",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        self.id.cmp(&other.id)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_272": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 272,
      "end_line": 272,
      "content_hash": "aafb10dc99e43a1af3420a1a41d95d593a3949d2",
      "content": "impl PartialOrd for Edge<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_273": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 273,
      "end_line": 330,
      "content_hash": "b6acaf8587ad9fd60150826cbf2146d4e24a9aef",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use bumpalo::Bump;\n\n    use super::*;\n    use crate::protocol::value::Value as PropsValue;\n\n    // Helper function to create a test node\n    fn create_test_node<'arena>(\n        id: u128,\n        label: &'arena str,\n        props: Option<ImmutablePropertiesMap<'arena>>,\n    ) -> Node<'arena> {\n        Node {\n            id,\n            label,\n            version: 0,\n            properties: props,\n        }\n    }\n\n    // Helper function to create a test edge\n    fn create_test_edge<'arena>(\n        id: u128,\n        label: &'arena str,\n        from: u128,\n        to: u128,\n        props: Option<ImmutablePropertiesMap<'arena>>,\n    ) -> Edge<'arena> {\n        Edge {\n            id,\n            label,\n            version: 0,\n            from_node: from,\n            to_node: to,\n            properties: props,\n        }\n    }\n\n    // Helper function to create ImmutablePropertiesMap from a HashMap\n    fn create_props_map<'arena>(\n        props: HashMap<&'arena str, PropsValue>,\n        arena: &'arena Bump,\n    ) -> ImmutablePropertiesMap<'arena> {\n        let len = props.len();\n        ImmutablePropertiesMap::new(len, props.into_iter(), arena)\n    }\n\n    // Basic Node tests\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_node_creation_basic_331": {
      "name": "test_node_creation_basic",
      "type": "method",
      "start_line": 331,
      "end_line": 341,
      "content_hash": "8caf2e7b9255c01350eab406d863112aabf89c66",
      "content": "    fn test_node_creation_basic() {\n        let arena = Bump::new();\n        let node = create_test_node(12345, arena.alloc_str(\"person\"), None);\n\n        assert_eq!(node.id, 12345);\n        assert_eq!(node.label, \"person\");\n        assert_eq!(node.version, 0);\n        assert!(node.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_node_with_properties_342": {
      "name": "test_node_with_properties",
      "type": "method",
      "start_line": 342,
      "end_line": 364,
      "content_hash": "81106602099371813a6e1a572ded1e1c0c259608",
      "content": "    fn test_node_with_properties() {\n        let arena = Bump::new();\n        let mut props = HashMap::new();\n        let name_key: &str = arena.alloc_str(\"name\");\n        let age_key: &str = arena.alloc_str(\"age\");\n        props.insert(name_key, PropsValue::String(\"John\".to_string()));\n        props.insert(age_key, PropsValue::I64(20));\n\n        let props_map = create_props_map(props, &arena);\n        let label: &str = arena.alloc_str(\"person\");\n        let node = create_test_node(456, label, Some(props_map));\n\n        assert_eq!(node.id, 456);\n        assert_eq!(node.label, \"person\");\n        assert!(node.properties.is_some());\n\n        let properties = node.properties.as_ref().unwrap();\n        assert_eq!(properties.len(), 2);\n        assert!(properties.get(\"name\").is_some());\n        assert!(properties.get(\"age\").is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_node_get_property_365": {
      "name": "test_node_get_property",
      "type": "method",
      "start_line": 365,
      "end_line": 383,
      "content_hash": "474018a5e3b1e4204e10f0d861b4dcde6f149bbd",
      "content": "    fn test_node_get_property() {\n        let arena = Bump::new();\n        let mut props = HashMap::new();\n        let name_key: &str = arena.alloc_str(\"name\");\n        props.insert(name_key, PropsValue::String(\"John\".to_string()));\n\n        let props_map = create_props_map(props, &arena);\n        let label: &str = arena.alloc_str(\"person\");\n        let node = create_test_node(789, label, Some(props_map));\n\n        // Note: get_property returns Option<&Value> where Value is from protocol, not properties\n        // This is a type mismatch in the current implementation\n        assert!(node.get_property(\"name\").is_some());\n        assert_eq!(node.get_property(\"nonexistent\"), None);\n    }\n\n    // Basic Edge tests\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_creation_basic_384": {
      "name": "test_edge_creation_basic",
      "type": "method",
      "start_line": 384,
      "end_line": 396,
      "content_hash": "2733c91d6c6f7dd4ee015b9039b7255fe0d2ab39",
      "content": "    fn test_edge_creation_basic() {\n        let arena = Bump::new();\n        let edge = create_test_edge(1, arena.alloc_str(\"knows\"), 100, 200, None);\n\n        assert_eq!(edge.id, 1);\n        assert_eq!(edge.label, \"knows\");\n        assert_eq!(edge.from_node, 100);\n        assert_eq!(edge.to_node, 200);\n        assert_eq!(edge.version, 0);\n        assert!(edge.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_with_properties_397": {
      "name": "test_edge_with_properties",
      "type": "method",
      "start_line": 397,
      "end_line": 418,
      "content_hash": "eb267b662ef606c3e5b5173b2e2ba292e3b9e882",
      "content": "    fn test_edge_with_properties() {\n        let arena = Bump::new();\n        let mut props = HashMap::new();\n        let weight_key: &str = arena.alloc_str(\"weight\");\n        let since_key: &str = arena.alloc_str(\"since\");\n        props.insert(weight_key, PropsValue::F64(1.0));\n        props.insert(since_key, PropsValue::I64(2020));\n\n        let props_map = create_props_map(props, &arena);\n        let label: &str = arena.alloc_str(\"knows\");\n        let edge = create_test_edge(2, label, 300, 400, Some(props_map));\n\n        assert_eq!(edge.id, 2);\n        assert_eq!(edge.from_node, 300);\n        assert_eq!(edge.to_node, 400);\n\n        let properties = edge.properties.as_ref().unwrap();\n        assert_eq!(properties.len(), 2);\n        assert!(properties.get(\"weight\").is_some());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_get_property_419": {
      "name": "test_edge_get_property",
      "type": "method",
      "start_line": 419,
      "end_line": 433,
      "content_hash": "58d6b0b1c1e1fe66a505321f1839aa8f7773be46",
      "content": "    fn test_edge_get_property() {\n        let arena = Bump::new();\n        let mut props = HashMap::new();\n        let type_key: &str = arena.alloc_str(\"type\");\n        props.insert(type_key, PropsValue::String(\"friend\".to_string()));\n\n        let props_map = create_props_map(props, &arena);\n        let label: &str = arena.alloc_str(\"knows\");\n        let edge = create_test_edge(3, label, 500, 600, Some(props_map));\n\n        assert!(edge.get_property(\"type\").is_some());\n        assert_eq!(edge.get_property(\"nonexistent\"), None);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_self_loop_434": {
      "name": "test_edge_self_loop",
      "type": "method",
      "start_line": 434,
      "end_line": 442,
      "content_hash": "f99922a2cecf62da89e14dce8f33057b46e96374",
      "content": "    fn test_edge_self_loop() {\n        let arena = Bump::new();\n        let edge = create_test_edge(4, arena.alloc_str(\"self_reference\"), 700, 700, None);\n\n        assert_eq!(edge.from_node, edge.to_node);\n        assert_eq!(edge.from_node, 700);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_large_node_ids_443": {
      "name": "test_edge_large_node_ids",
      "type": "method",
      "start_line": 443,
      "end_line": 454,
      "content_hash": "5168d79d85a57e3f09b3d1327d2e388773f261f4",
      "content": "    fn test_edge_large_node_ids() {\n        let arena = Bump::new();\n        let max_id = u128::MAX;\n        let edge = create_test_edge(6, arena.alloc_str(\"test\"), max_id - 1, max_id, None);\n\n        assert_eq!(edge.from_node, max_id - 1);\n        assert_eq!(edge.to_node, max_id);\n    }\n\n    // Test Display and Debug implementations\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_node_display_455": {
      "name": "test_node_display",
      "type": "method",
      "start_line": 455,
      "end_line": 470,
      "content_hash": "2eda6a31726ca270d536c47e73905ceca6895eaa",
      "content": "    fn test_node_display() {\n        let arena = Bump::new();\n        let mut props = HashMap::new();\n        let key: &str = arena.alloc_str(\"key\");\n        props.insert(key, PropsValue::String(\"value\".to_string()));\n        let props_map = create_props_map(props, &arena);\n\n        let label: &str = arena.alloc_str(\"test\");\n        let node = create_test_node(123456789, label, Some(props_map));\n\n        let display = format!(\"{}\", node);\n        assert!(display.contains(\"test\"));\n        assert!(display.contains(\"id\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_display_471": {
      "name": "test_edge_display",
      "type": "method",
      "start_line": 471,
      "end_line": 483,
      "content_hash": "1b3fcbba8346ff50a596ec6ad27d3e4faf83e096",
      "content": "    fn test_edge_display() {\n        let arena = Bump::new();\n        let edge = create_test_edge(123, arena.alloc_str(\"knows\"), 100, 200, None);\n\n        let display = format!(\"{}\", edge);\n        assert!(display.contains(\"knows\"));\n        assert!(display.contains(\"from_node\"));\n        assert!(display.contains(\"to_node\"));\n    }\n\n    // Test ordering implementations\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_node_ordering_484": {
      "name": "test_node_ordering",
      "type": "method",
      "start_line": 484,
      "end_line": 501,
      "content_hash": "d2370a1f7933575d8312fcdcf0de3e1dfc2369b7",
      "content": "    fn test_node_ordering() {\n        let arena = Bump::new();\n        let node1 = create_test_node(100, arena.alloc_str(\"a\"), None);\n        let node2 = create_test_node(200, arena.alloc_str(\"b\"), None);\n        let node3 = create_test_node(100, arena.alloc_str(\"a\"), None); // Same ID and label\n\n        assert!(node1 < node2);\n        assert!(node2 > node1);\n        // Nodes with same ID are equal (PartialEq only compares ID)\n        assert_eq!(node1, node3);\n        // Nodes with same ID but different label are still equal (by ID)\n        let node4 = create_test_node(100, arena.alloc_str(\"different\"), None);\n        assert_eq!(node1, node4);\n        // Ordering only considers ID\n        assert_eq!(node1.cmp(&node4), Ordering::Equal);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_edge_ordering_502": {
      "name": "test_edge_ordering",
      "type": "method",
      "start_line": 502,
      "end_line": 518,
      "content_hash": "31ba6bb6fcd6987bb3439ddb002223b14458532b",
      "content": "    fn test_edge_ordering() {\n        let arena = Bump::new();\n        let edge1 = create_test_edge(100, arena.alloc_str(\"a\"), 1, 2, None);\n        let edge2 = create_test_edge(200, arena.alloc_str(\"b\"), 3, 4, None);\n        let edge3 = create_test_edge(100, arena.alloc_str(\"a\"), 1, 2, None); // Same ID\n\n        assert!(edge1 < edge2);\n        assert!(edge2 > edge1);\n        // Edges with same ID are equal (PartialEq only compares ID)\n        assert_eq!(edge1, edge3);\n        // Edges with same ID but different data are still equal (by ID)\n        let edge4 = create_test_edge(100, arena.alloc_str(\"different\"), 5, 6, None);\n        assert_eq!(edge1, edge4);\n        // Ordering only considers ID\n        assert_eq!(edge1.cmp(&edge4), Ordering::Equal);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}