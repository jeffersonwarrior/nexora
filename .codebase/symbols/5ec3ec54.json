{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/builtin/nodes_by_label.rs",
  "file_hash": "a5be123bba054adf23345a3257f92396674ec4f5",
  "updated_at": "2025-12-26T17:34:22.165545",
  "symbols": {
    "struct_NodesByLabelQuery_21": {
      "name": "NodesByLabelQuery",
      "type": "struct",
      "start_line": 21,
      "end_line": 56,
      "content_hash": "cf7568bebc6876ba0c479cb494864af774b20d64",
      "content": "pub struct NodesByLabelQuery {\n    label: String,\n    limit: Option<usize>,\n}\n\npub async fn nodes_by_label_handler(\n    State(state): State<Arc<AppState>>,\n    Query(params): Query<NodesByLabelQuery>,\n) -> axum::http::Response<Body> {\n    let mut req = protocol::request::Request {\n        name: \"nodes_by_label\".to_string(),\n        req_type: RequestType::Query,\n        api_key: None,\n        body: axum::body::Bytes::new(),\n        in_fmt: protocol::Format::default(),\n        out_fmt: protocol::Format::default(),\n    };\n\n    if let Ok(params_json) = sonic_rs::to_vec(&json!({\n        \"label\": params.label,\n        \"limit\": params.limit\n    })) {\n        req.body = axum::body::Bytes::from(params_json);\n    }\n\n    let res = state.worker_pool.process(req).await;\n\n    match res {\n        Ok(r) => r.into_response(),\n        Err(e) => {\n            info!(?e, \"Got error\");\n            e.into_response()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_nodes_by_label_inner_57": {
      "name": "nodes_by_label_inner",
      "type": "function",
      "start_line": 57,
      "end_line": 163,
      "content_hash": "46e7ed9f23dde444009221e9f275ad59e4910121",
      "content": "pub fn nodes_by_label_inner(input: HandlerInput) -> Result<protocol::Response, GraphError> {\n    let db = Arc::clone(&input.graph.storage);\n    let txn = db.graph_env.read_txn().map_err(GraphError::from)?;\n    let arena = bumpalo::Bump::new();\n\n    let (label, limit) = if !input.request.body.is_empty() {\n        match sonic_rs::from_slice::<sonic_rs::Value>(&input.request.body) {\n            Ok(params) => {\n                let label = params\n                    .get(\"label\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| s.to_string());\n                let limit = params\n                    .get(\"limit\")\n                    .and_then(|v| v.as_u64())\n                    .map(|n| n as usize);\n                (label, limit)\n            }\n            Err(_) => (None, None),\n        }\n    } else {\n        (None, None)\n    };\n\n    let label = label.ok_or_else(|| GraphError::New(\"label is required\".to_string()))?;\n    const MAX_PREALLOCATE_CAPACITY: usize = 100_000;\n\n    let initial_capacity = match limit {\n        Some(n) if n <= MAX_PREALLOCATE_CAPACITY => n,\n        Some(_) => MAX_PREALLOCATE_CAPACITY,\n        None => 100,\n    };\n\n    let mut nodes_json = Vec::with_capacity(initial_capacity);\n    let mut count = 0;\n\n    for result in db.nodes_db.iter(&txn)? {\n        let (id, node_data) = result?;\n        match Node::from_bincode_bytes(id, node_data, &arena) {\n            Ok(node) => {\n                if node.label == label {\n                    let id_str = ID::from(id).stringify();\n\n                    let mut node_json = json!({\n                        \"id\": id_str.clone(),\n                        \"label\": node.label,\n                        \"title\": id_str\n                    });\n\n                    // Add node properties\n                    if let Some(properties) = &node.properties {\n                        for (key, value) in properties.iter() {\n                            node_json[key] = sonic_rs::to_value(&value.inner_stringify())\n                                .unwrap_or_else(|_| sonic_rs::Value::from(\"\"));\n                        }\n                    }\n\n                    nodes_json.push(node_json);\n                    count += 1;\n\n                    if let Some(limit_count) = limit\n                        && count >= limit_count\n                    {\n                        break;\n                    }\n                }\n            }\n            Err(_) => continue,\n        }\n    }\n\n    let result = json!({\n        \"nodes\": nodes_json,\n        \"count\": count\n    });\n\n    Ok(protocol::Response {\n        body: sonic_rs::to_vec(&result).map_err(|e| GraphError::New(e.to_string()))?,\n        fmt: Default::default(),\n    })\n}\n\ninventory::submit! {\n    HandlerSubmission(\n        Handler::new(\"nodes_by_label\", nodes_by_label_inner, false)\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        helix_engine::{\n            storage_core::version_info::VersionInfo,\n            traversal_core::{\n                HelixGraphEngine, HelixGraphEngineOpts,\n                config::Config,\n                ops::{g::G, source::add_n::AddNAdapter},\n            },\n        },\n        helix_gateway::router::router::HandlerInput,\n        protocol::{Format, request::Request, request::RequestType, value::Value},\n    };\n    use axum::body::Bytes;\n    use std::sync::Arc;\n    use tempfile::TempDir;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_test_engine_164": {
      "name": "setup_test_engine",
      "type": "function",
      "start_line": 164,
      "end_line": 176,
      "content_hash": "bc59db59deca98ae1700862874b6d2114ed21047",
      "content": "    fn setup_test_engine() -> (HelixGraphEngine, TempDir) {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().to_str().unwrap();\n        let opts = HelixGraphEngineOpts {\n            path: db_path.to_string(),\n            config: Config::default(),\n            version_info: VersionInfo::default(),\n        };\n        let engine = HelixGraphEngine::new(opts).unwrap();\n        (engine, temp_dir)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_by_label_found_177": {
      "name": "test_nodes_by_label_found",
      "type": "function",
      "start_line": 177,
      "end_line": 237,
      "content_hash": "045f4f19370cfdbbf089af0243d65fc81b4ffa0f",
      "content": "    fn test_nodes_by_label_found() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let props1 = vec![(\"name\", Value::String(\"Alice\".to_string()))];\n        let props_map1 = ImmutablePropertiesMap::new(\n            props1.len(),\n            props1\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let _node1 = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map1), None)\n            .collect_to_obj()?;\n\n        let props2 = vec![(\"name\", Value::String(\"Bob\".to_string()))];\n        let props_map2 = ImmutablePropertiesMap::new(\n            props2.len(),\n            props2\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let _node2 = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map2), None)\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let params_json = sonic_rs::to_vec(&json!({\"label\": \"person\"})).unwrap();\n\n        let request = Request {\n            name: \"nodes_by_label\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_by_label_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"count\\\":2\"));\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_by_label_with_limit_238": {
      "name": "test_nodes_by_label_with_limit",
      "type": "function",
      "start_line": 238,
      "end_line": 287,
      "content_hash": "13d37e70c3d8287b0b48a495c44cc378c265ce05",
      "content": "    fn test_nodes_by_label_with_limit() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        for i in 0..10 {\n            let props = vec![(\"index\", Value::I64(i))];\n            let props_map = ImmutablePropertiesMap::new(\n                props.len(),\n                props\n                    .iter()\n                    .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n                &arena,\n            );\n\n            let _node = G::new_mut(&engine.storage, &arena, &mut txn)\n                .add_n(arena.alloc_str(\"person\"), Some(props_map), None)\n                .collect_to_obj()?;\n        }\n\n        txn.commit().unwrap();\n\n        let params_json = sonic_rs::to_vec(&json!({\"label\": \"person\", \"limit\": 5})).unwrap();\n\n        let request = Request {\n            name: \"nodes_by_label\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_by_label_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"count\\\":5\"));\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_by_label_not_found_288": {
      "name": "test_nodes_by_label_not_found",
      "type": "function",
      "start_line": 288,
      "end_line": 315,
      "content_hash": "9041561c6a9ca8ce665c8007750fff825974c228",
      "content": "    fn test_nodes_by_label_not_found() {\n        let (engine, _temp_dir) = setup_test_engine();\n\n        let params_json = sonic_rs::to_vec(&json!({\"label\": \"nonexistent\"})).unwrap();\n\n        let request = Request {\n            name: \"nodes_by_label\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_by_label_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"count\\\":0\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_by_label_missing_label_316": {
      "name": "test_nodes_by_label_missing_label",
      "type": "function",
      "start_line": 316,
      "end_line": 337,
      "content_hash": "c9a6c1f0e34e4de43e94e2b99450bfd4c57f36c9",
      "content": "    fn test_nodes_by_label_missing_label() {\n        let (engine, _temp_dir) = setup_test_engine();\n\n        let request = Request {\n            name: \"nodes_by_label\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::new(),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_by_label_inner(input);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_nodes_by_label_multiple_labels_338": {
      "name": "test_nodes_by_label_multiple_labels",
      "type": "function",
      "start_line": 338,
      "end_line": 377,
      "content_hash": "f2a82940a5e9dd97bae6995075d21bf9cb5d3c6e",
      "content": "    fn test_nodes_by_label_multiple_labels() -> Result<(), Box<dyn std::error::Error>> {\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let _person = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), None, None)\n            .collect_to_obj()?;\n\n        let _company = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"company\"), None, None)\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let params_json = sonic_rs::to_vec(&json!({\"label\": \"person\"})).unwrap();\n\n        let request = Request {\n            name: \"nodes_by_label\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = nodes_by_label_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"count\\\":1\"));\n        Ok(())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}