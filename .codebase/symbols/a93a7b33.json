{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/traversal_core/ops/util/paths.rs",
  "file_hash": "d677da4aecf9e82801a869c2b22be48b7f75a65f",
  "updated_at": "2025-12-26T17:34:23.805382",
  "symbols": {
    "enum_PathType_76": {
      "name": "PathType",
      "type": "enum",
      "start_line": 76,
      "end_line": 81,
      "content_hash": "c6d69c747898f3e63e43b8f676304888462e4a53",
      "content": "pub enum PathType {\n    From(u128),\n    To(u128),\n}\n\n#[derive(Debug, Clone, PartialEq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_PathAlgorithm_82": {
      "name": "PathAlgorithm",
      "type": "enum",
      "start_line": 82,
      "end_line": 87,
      "content_hash": "42e8f32e9f7570240dd20fbcb92168b0e3a9d486",
      "content": "pub enum PathAlgorithm {\n    BFS,\n    Dijkstra,\n    AStar,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ShortestPathIterator_88": {
      "name": "ShortestPathIterator",
      "type": "struct",
      "start_line": 88,
      "end_line": 106,
      "content_hash": "eb552bea55c878a0cda6e51514fef267ec929fbe",
      "content": "pub struct ShortestPathIterator<'db, 'arena, 'txn, I, F, H = fn(&Node<'arena>) -> Result<f64, GraphError>>\nwhere\n    'db: 'arena,\n    'arena: 'txn,\n    F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n    H: Fn(&Node<'arena>) -> Result<f64, GraphError>,\n{\n    pub arena: &'arena bumpalo::Bump,\n    pub iter: I,\n    path_type: PathType,\n    edge_label: Option<&'arena str>,\n    storage: &'db HelixGraphStorage,\n    txn: &'txn RoTxn<'db>,\n    algorithm: PathAlgorithm,\n    weight_fn: F,\n    heuristic_fn: Option<H>,\n}\n\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_DijkstraState_107": {
      "name": "DijkstraState",
      "type": "struct",
      "start_line": 107,
      "end_line": 111,
      "content_hash": "94f4c8ec4dc17b06e04f2925317a442fb3999131",
      "content": "struct DijkstraState {\n    node_id: u128,\n    distance: f64,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_112": {
      "name": "Eq",
      "type": "impl",
      "start_line": 112,
      "end_line": 113,
      "content_hash": "8b86800682032b831659830418f516c9a10b447d",
      "content": "impl Eq for DijkstraState {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_114": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 114,
      "end_line": 114,
      "content_hash": "d3f3c7f62403c5b5d53d78fa178879cfe3e01895",
      "content": "impl PartialEq for DijkstraState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_115": {
      "name": "eq",
      "type": "method",
      "start_line": 115,
      "end_line": 119,
      "content_hash": "2e3981b6f46f7b8cda449efb6c49a60371843796",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.node_id == other.node_id\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_120": {
      "name": "Ord",
      "type": "impl",
      "start_line": 120,
      "end_line": 120,
      "content_hash": "046c02a858efdf135b73c09ad9531f63f40c9519",
      "content": "impl Ord for DijkstraState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_121": {
      "name": "cmp",
      "type": "method",
      "start_line": 121,
      "end_line": 129,
      "content_hash": "47bfd512015342974e60db4ed0a35a26c65a0b3c",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        other\n            .distance\n            .partial_cmp(&self.distance)\n            .unwrap_or(Ordering::Equal)\n            .then_with(|| self.node_id.cmp(&other.node_id))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_130": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 130,
      "end_line": 130,
      "content_hash": "fbc1c7d49e5edabd14afb566194b18142b6f1d0e",
      "content": "impl PartialOrd for DijkstraState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_131": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 131,
      "end_line": 136,
      "content_hash": "78124319a3537d25f60acf7e1fd34ab528ed524d",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AStarState_137": {
      "name": "AStarState",
      "type": "struct",
      "start_line": 137,
      "end_line": 142,
      "content_hash": "431a97b4dce5f9eaf24d28829a687e7af68d7773",
      "content": "struct AStarState {\n    node_id: u128,\n    g_score: f64,\n    f_score: f64,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_143": {
      "name": "Eq",
      "type": "impl",
      "start_line": 143,
      "end_line": 144,
      "content_hash": "ca2e0a8cf972f91b556864723fdd78747321e919",
      "content": "impl Eq for AStarState {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_145": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 145,
      "end_line": 145,
      "content_hash": "71760411036b1d077924cf868ac9db51d0c9533f",
      "content": "impl PartialEq for AStarState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_146": {
      "name": "eq",
      "type": "method",
      "start_line": 146,
      "end_line": 150,
      "content_hash": "2e3981b6f46f7b8cda449efb6c49a60371843796",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.node_id == other.node_id\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_151": {
      "name": "Ord",
      "type": "impl",
      "start_line": 151,
      "end_line": 151,
      "content_hash": "f2816c87048a63edc13f887ade9759ff3984fc67",
      "content": "impl Ord for AStarState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_152": {
      "name": "cmp",
      "type": "method",
      "start_line": 152,
      "end_line": 161,
      "content_hash": "a1a1c2508c291aa5fe66d4868fbf340c103b1653",
      "content": "    fn cmp(&self, other: &Self) -> Ordering {\n        // Min-heap: lower f_score = higher priority\n        other\n            .f_score\n            .partial_cmp(&self.f_score)\n            .unwrap_or(Ordering::Equal)\n            .then_with(|| self.node_id.cmp(&other.node_id))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_162": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 162,
      "end_line": 162,
      "content_hash": "44cc6b35bf28f1bb7bd122d145cd6a972ba70d2d",
      "content": "impl PartialOrd for AStarState {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_163": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 163,
      "end_line": 179,
      "content_hash": "1704f926c4e09054b3c9bc1ea89dd9c6f933da30",
      "content": "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl<\n    'db: 'arena,\n    'arena: 'txn,\n    'txn,\n    I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n    H: Fn(&Node<'arena>) -> Result<f64, GraphError>,\n> Iterator for ShortestPathIterator<'db, 'arena, 'txn, I, F, H>\n{\n    type Item = Result<TraversalValue<'arena>, GraphError>;\n\n    /// Returns the next outgoing node by decoding the edge id and then getting the edge and node",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_180": {
      "name": "next",
      "type": "method",
      "start_line": 180,
      "end_line": 199,
      "content_hash": "d98006f99f139a804f6e40f015b80841f32e015e",
      "content": "    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(TraversalValue::Node(node))) => {\n                let (from, to) = match self.path_type {\n                    PathType::From(from) => (from, node.id),\n                    PathType::To(to) => (node.id, to),\n                };\n\n                match self.algorithm {\n                    PathAlgorithm::BFS => self.bfs_shortest_path(from, to),\n                    PathAlgorithm::Dijkstra => self.dijkstra_shortest_path(from, to),\n                    PathAlgorithm::AStar => self.astar_shortest_path(from, to),\n                }\n            }\n            Some(other) => Some(other),\n            None => None,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ShortestPathIterator_200": {
      "name": "ShortestPathIterator",
      "type": "impl",
      "start_line": 200,
      "end_line": 204,
      "content_hash": "dc8fc5e27e0dca2a87ae8e83b18ad5df43ebc4d6",
      "content": "impl<'db, 'arena, 'txn, I, F, H> ShortestPathIterator<'db, 'arena, 'txn, I, F, H>\nwhere\n    F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n    H: Fn(&Node<'arena>) -> Result<f64, GraphError>,\n{",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_reconstruct_path_205": {
      "name": "reconstruct_path",
      "type": "method",
      "start_line": 205,
      "end_line": 232,
      "content_hash": "73d3799ede0ceb6a5976d99b11d15f328af6060f",
      "content": "    fn reconstruct_path(\n        &self,\n        parent: &HashMap<u128, (u128, u128)>,\n        start_id: &u128,\n        end_id: &u128,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<TraversalValue<'arena>, GraphError> {\n        let mut nodes = Vec::with_capacity(parent.len());\n        let mut edges = Vec::with_capacity(parent.len().saturating_sub(1));\n\n        let mut current = end_id;\n\n        while current != start_id {\n            nodes.push(self.storage.get_node(self.txn, current, arena)?);\n\n            let (prev_node, edge) = &parent[current];\n            edges.push(self.storage.get_edge(self.txn, edge, arena)?);\n            current = prev_node;\n        }\n\n        nodes.push(self.storage.get_node(self.txn, start_id, arena)?);\n\n        nodes.reverse();\n        edges.reverse();\n\n        Ok(TraversalValue::Path((nodes, edges)))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_bfs_shortest_path_233": {
      "name": "bfs_shortest_path",
      "type": "method",
      "start_line": 233,
      "end_line": 287,
      "content_hash": "087b6d592bab4dfd88f93fbd87e70f8a18913740",
      "content": "    fn bfs_shortest_path(\n        &self,\n        from: u128,\n        to: u128,\n    ) -> Option<Result<TraversalValue<'arena>, GraphError>> {\n        let mut queue = VecDeque::with_capacity(32);\n        let mut visited = HashSet::with_capacity(64);\n        let mut parent: HashMap<u128, (u128, u128)> = HashMap::with_capacity(32);\n        queue.push_back(from);\n        visited.insert(from);\n\n        // find shortest-path from one node to itself\n        if from == to {\n            return Some(self.reconstruct_path(&parent, &from, &to, self.arena));\n        }\n\n        while let Some(current_id) = queue.pop_front() {\n            let out_prefix = self.edge_label.map_or_else(\n                || current_id.to_be_bytes().to_vec(),\n                |label| {\n                    HelixGraphStorage::out_edge_key(&current_id, &hash_label(label, None)).to_vec()\n                },\n            );\n\n            let iter = self\n                .storage\n                .out_edges_db\n                .prefix_iter(self.txn, &out_prefix)\n                .unwrap();\n\n            for result in iter {\n                let value = match result {\n                    Ok((_, value)) => value,\n                    Err(e) => return Some(Err(GraphError::from(e))),\n                };\n                let (edge_id, to_node) = match HelixGraphStorage::unpack_adj_edge_data(value) {\n                    Ok((edge_id, to_node)) => (edge_id, to_node),\n                    Err(e) => return Some(Err(e)),\n                };\n\n                if !visited.contains(&to_node) {\n                    visited.insert(to_node);\n                    parent.insert(to_node, (current_id, edge_id));\n\n                    if to_node == to {\n                        return Some(self.reconstruct_path(&parent, &from, &to, self.arena));\n                    }\n\n                    queue.push_back(to_node);\n                }\n            }\n        }\n        Some(Err(GraphError::ShortestPathNotFound))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_dijkstra_shortest_path_288": {
      "name": "dijkstra_shortest_path",
      "type": "method",
      "start_line": 288,
      "end_line": 383,
      "content_hash": "5f80c78a83042d2636fdd1533391d8ed0a02c0eb",
      "content": "    fn dijkstra_shortest_path(\n        &self,\n        from: u128,\n        to: u128,\n    ) -> Option<Result<TraversalValue<'arena>, GraphError>> {\n        let mut heap = BinaryHeap::new();\n        let mut distances = HashMap::with_capacity(64);\n        let mut parent: HashMap<u128, (u128, u128)> = HashMap::with_capacity(32);\n\n        distances.insert(from, 0.0);\n        heap.push(DijkstraState {\n            node_id: from,\n            distance: 0.0,\n        });\n\n        while let Some(DijkstraState {\n            node_id: current_id,\n            distance: current_dist,\n        }) = heap.pop()\n        {\n            // Already found a better path\n            if let Some(&best_dist) = distances.get(&current_id)\n                && current_dist > best_dist\n            {\n                continue;\n            }\n\n            // Found the target\n            if current_id == to {\n                return Some(self.reconstruct_path(&parent, &from, &to, self.arena));\n            }\n\n            let out_prefix = self.edge_label.map_or_else(\n                || current_id.to_be_bytes().to_vec(),\n                |label| {\n                    HelixGraphStorage::out_edge_key(&current_id, &hash_label(label, None)).to_vec()\n                },\n            );\n\n            let iter = self\n                .storage\n                .out_edges_db\n                .prefix_iter(self.txn, &out_prefix)\n                .unwrap();\n\n            for result in iter {\n                let (_, value) = result.unwrap(); // TODO: handle error\n                let (edge_id, to_node) = HelixGraphStorage::unpack_adj_edge_data(value).unwrap(); // TODO: handle error\n\n                let edge = match self.storage.get_edge(self.txn, &edge_id, self.arena) {\n                    Ok(e) => e,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                // Fetch nodes for full context in weight calculation\n                let src_node = match self.storage.get_node(self.txn, &current_id, self.arena) {\n                    Ok(n) => n,\n                    Err(e) => return Some(Err(e)),\n                };\n                let dst_node = match self.storage.get_node(self.txn, &to_node, self.arena) {\n                    Ok(n) => n,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                // Call custom weight function with full context\n                let weight = match (self.weight_fn)(&edge, &src_node, &dst_node) {\n                    Ok(w) => w,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                if weight < 0.0 {\n                    return Some(Err(GraphError::TraversalError(\n                        \"Negative edge weights are not supported for Dijkstra's algorithm\"\n                            .to_string(),\n                    )));\n                }\n\n                let new_dist = current_dist + weight;\n\n                let should_update = distances\n                    .get(&to_node)\n                    .is_none_or(|&existing_dist| new_dist < existing_dist);\n\n                if should_update {\n                    distances.insert(to_node, new_dist);\n                    parent.insert(to_node, (current_id, edge_id));\n                    heap.push(DijkstraState {\n                        node_id: to_node,\n                        distance: new_dist,\n                    });\n                }\n            }\n        }\n        Some(Err(GraphError::ShortestPathNotFound))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_astar_shortest_path_384": {
      "name": "astar_shortest_path",
      "type": "method",
      "start_line": 384,
      "end_line": 510,
      "content_hash": "c1cd6632ce9690daab28907a13afb42b409fc6e6",
      "content": "    fn astar_shortest_path(\n        &self,\n        from: u128,\n        to: u128,\n    ) -> Option<Result<TraversalValue<'arena>, GraphError>> {\n        let heuristic_fn = match &self.heuristic_fn {\n            Some(h) => h,\n            None => {\n                return Some(Err(GraphError::TraversalError(\n                    \"A* algorithm requires a heuristic function\".to_string(),\n                )))\n            }\n        };\n\n        let mut heap = BinaryHeap::new();\n        let mut g_scores: HashMap<u128, f64> = HashMap::with_capacity(64);\n        let mut parent: HashMap<u128, (u128, u128)> = HashMap::with_capacity(32);\n\n        // Calculate initial heuristic for start node\n        let start_node = match self.storage.get_node(self.txn, &from, self.arena) {\n            Ok(node) => node,\n            Err(e) => return Some(Err(e)),\n        };\n\n        let h_start = match heuristic_fn(&start_node) {\n            Ok(h) => h,\n            Err(e) => return Some(Err(e)),\n        };\n\n        g_scores.insert(from, 0.0);\n        heap.push(AStarState {\n            node_id: from,\n            g_score: 0.0,\n            f_score: h_start,\n        });\n\n        while let Some(AStarState {\n            node_id: current_id,\n            g_score: current_g,\n            ..\n        }) = heap.pop()\n        {\n            // Found the target\n            if current_id == to {\n                return Some(self.reconstruct_path(&parent, &from, &to, self.arena));\n            }\n\n            // Already found a better path\n            if let Some(&best_g) = g_scores.get(&current_id)\n                && current_g > best_g\n            {\n                continue;\n            }\n\n            let out_prefix = self.edge_label.map_or_else(\n                || current_id.to_be_bytes().to_vec(),\n                |label| {\n                    HelixGraphStorage::out_edge_key(&current_id, &hash_label(label, None)).to_vec()\n                },\n            );\n\n            let iter = self\n                .storage\n                .out_edges_db\n                .prefix_iter(self.txn, &out_prefix)\n                .unwrap();\n\n            for result in iter {\n                let (_, value) = result.unwrap(); // TODO: handle error\n                let (edge_id, to_node) = HelixGraphStorage::unpack_adj_edge_data(value).unwrap(); // TODO: handle error\n\n                let edge = match self.storage.get_edge(self.txn, &edge_id, self.arena) {\n                    Ok(e) => e,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                // Fetch nodes for full context in weight calculation\n                let src_node = match self.storage.get_node(self.txn, &current_id, self.arena) {\n                    Ok(n) => n,\n                    Err(e) => return Some(Err(e)),\n                };\n                let dst_node = match self.storage.get_node(self.txn, &to_node, self.arena) {\n                    Ok(n) => n,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                // Call custom weight function with full context\n                let weight = match (self.weight_fn)(&edge, &src_node, &dst_node) {\n                    Ok(w) => w,\n                    Err(e) => return Some(Err(e)),\n                };\n\n                if weight < 0.0 {\n                    return Some(Err(GraphError::TraversalError(\n                        \"Negative edge weights are not supported for A* algorithm\".to_string(),\n                    )));\n                }\n\n                let tentative_g = current_g + weight;\n\n                let should_update = g_scores\n                    .get(&to_node)\n                    .is_none_or(|&existing_g| tentative_g < existing_g);\n\n                if should_update {\n                    // Calculate heuristic for neighbor\n                    let h = match heuristic_fn(&dst_node) {\n                        Ok(h) => h,\n                        Err(e) => return Some(Err(e)),\n                    };\n\n                    let f = tentative_g + h;\n\n                    g_scores.insert(to_node, tentative_g);\n                    parent.insert(to_node, (current_id, edge_id));\n                    heap.push(AStarState {\n                        node_id: to_node,\n                        g_score: tentative_g,\n                        f_score: f,\n                    });\n                }\n            }\n        }\n        Some(Err(GraphError::ShortestPathNotFound))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "trait_ShortestPathAdapter_511": {
      "name": "ShortestPathAdapter",
      "type": "trait",
      "start_line": 511,
      "end_line": 529,
      "content_hash": "f186df6b69bdf33e5d5d76f123e6bbc1e698486d",
      "content": "pub trait ShortestPathAdapter<'db, 'arena, 'txn, 's, I>:\n    Iterator<Item = Result<TraversalValue<'arena>, GraphError>>\n{\n    /// ShortestPath finds the shortest path between two nodes\n    ///\n    /// # Arguments\n    ///\n    /// * `edge_label` - The label of the edge to use\n    /// * `from` - The starting node\n    /// * `to` - The ending node\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// let node1 = Node { id: 1, label: \"Person\".to_string(), properties: None };\n    /// let node2 = Node { id: 2, label: \"Person\".to_string(), properties: None };\n    /// let traversal = G::new(storage, &txn).shortest_path(Some(\"knows\"), Some(&node1.id), Some(&node2.id));\n    /// ```\n    #[allow(clippy::type_complexity)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shortest_path_530": {
      "name": "shortest_path",
      "type": "method",
      "start_line": 530,
      "end_line": 575,
      "content_hash": "a9216c2bcb0c62e2606adc748c813aa7eec7b10c",
      "content": "    fn shortest_path(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,\n        ShortestPathIterator<\n            'db,\n            'arena,\n            'txn,\n            I,\n            fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n        >,\n    >;\n\n    fn shortest_path_with_algorithm<F>(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n        algorithm: PathAlgorithm,\n        weight_fn: F,\n    ) -> RoTraversalIterator<'db, 'arena, 'txn, ShortestPathIterator<'db, 'arena, 'txn, I, F>>\n    where\n        F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>;\n\n    fn shortest_path_astar<F, H>(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n        weight_fn: F,\n        heuristic_fn: H,\n    ) -> RoTraversalIterator<'db, 'arena, 'txn, ShortestPathIterator<'db, 'arena, 'txn, I, F, H>>\n    where\n        F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n        H: Fn(&Node<'arena>) -> Result<f64, GraphError>;\n}\n\nimpl<'db, 'arena, 'txn, 's, I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>>\n    ShortestPathAdapter<'db, 'arena, 'txn, 's, I> for RoTraversalIterator<'db, 'arena, 'txn, I>\n{\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shortest_path_576": {
      "name": "shortest_path",
      "type": "method",
      "start_line": 576,
      "end_line": 664,
      "content_hash": "5d25703a863e89b490e2874657b64ad5cc7927c5",
      "content": "    fn shortest_path(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,\n        ShortestPathIterator<\n            'db,\n            'arena,\n            'txn,\n            I,\n            fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n        >,\n    > {\n        self.shortest_path_with_algorithm(edge_label, from, to, PathAlgorithm::BFS, default_weight_fn)\n    }\n\n    #[inline]\n    fn shortest_path_with_algorithm<F>(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n        algorithm: PathAlgorithm,\n        weight_fn: F,\n    ) -> RoTraversalIterator<'db, 'arena, 'txn, ShortestPathIterator<'db, 'arena, 'txn, I, F>>\n    where\n        F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n    {\n        RoTraversalIterator {\n            arena: self.arena,\n            inner: ShortestPathIterator {\n                arena: self.arena,\n                iter: self.inner,\n                path_type: match (from, to) {\n                    (Some(from), None) => PathType::From(*from),\n                    (None, Some(to)) => PathType::To(*to),\n                    _ => panic!(\"Invalid shortest path\"),\n                },\n                edge_label,\n                storage: self.storage,\n                txn: self.txn,\n                algorithm,\n                weight_fn,\n                heuristic_fn: None,\n            },\n            storage: self.storage,\n            txn: self.txn,\n        }\n    }\n\n    #[inline]\n    fn shortest_path_astar<F, H>(\n        self,\n        edge_label: Option<&'arena str>,\n        from: Option<&'s u128>,\n        to: Option<&'s u128>,\n        weight_fn: F,\n        heuristic_fn: H,\n    ) -> RoTraversalIterator<'db, 'arena, 'txn, ShortestPathIterator<'db, 'arena, 'txn, I, F, H>>\n    where\n        F: Fn(&Edge<'arena>, &Node<'arena>, &Node<'arena>) -> Result<f64, GraphError>,\n        H: Fn(&Node<'arena>) -> Result<f64, GraphError>,\n    {\n        RoTraversalIterator {\n            arena: self.arena,\n            inner: ShortestPathIterator {\n                arena: self.arena,\n                iter: self.inner,\n                path_type: match (from, to) {\n                    (Some(from), None) => PathType::From(*from),\n                    (None, Some(to)) => PathType::To(*to),\n                    _ => panic!(\"Invalid shortest path\"),\n                },\n                edge_label,\n                storage: self.storage,\n                txn: self.txn,\n                algorithm: PathAlgorithm::AStar,\n                weight_fn,\n                heuristic_fn: Some(heuristic_fn),\n            },\n            storage: self.storage,\n            txn: self.txn,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}