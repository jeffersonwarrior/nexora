{
  "file_path": "/work/.local/tools/modelscan/sdk/agent/workflow_test.go",
  "file_hash": "b37b0c90cc68610b403e9d52bc1874e1f77cdbb5",
  "updated_at": "2025-12-26T17:34:20.232896",
  "symbols": {
    "struct_mockWorkflowStep_14": {
      "name": "mockWorkflowStep",
      "type": "struct",
      "start_line": 14,
      "end_line": 22,
      "content_hash": "9b4574c4a98e0eeef4d8497cf10f34dfdf40f6b6",
      "content": "type mockWorkflowStep struct {\n\tname          string\n\texecuted      bool\n\tinput         map[string]interface{}\n\toutput        map[string]interface{}\n\terrorToReturn error\n\tdelay         time.Duration\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Execute_23": {
      "name": "Execute",
      "type": "method",
      "start_line": 23,
      "end_line": 42,
      "content_hash": "c66843f1f6563021a1b1d02ab1c2f695c39dbd94",
      "content": "func (m *mockWorkflowStep) Execute(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\tm.executed = true\n\tm.input = input\n\n\tif m.delay > 0 {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tcase <-time.After(m.delay):\n\t\t\t// Continue after delay\n\t\t}\n\t}\n\n\tif m.errorToReturn != nil {\n\t\treturn nil, m.errorToReturn\n\t}\n\n\treturn m.output, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_43": {
      "name": "Name",
      "type": "method",
      "start_line": 43,
      "end_line": 46,
      "content_hash": "2051156bb6b8181271e0933b89c693bfce469ae5",
      "content": "func (m *mockWorkflowStep) Name() string {\n\treturn m.name\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewWorkflow_CreatesEmptyWorkflow_47": {
      "name": "TestNewWorkflow_CreatesEmptyWorkflow",
      "type": "function",
      "start_line": 47,
      "end_line": 54,
      "content_hash": "7c3ef219023fdfa3a2752d91074385be7e377204",
      "content": "func TestNewWorkflow_CreatesEmptyWorkflow(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\n\tassert.Equal(t, \"test-workflow\", workflow.Name())\n\tassert.Empty(t, workflow.steps)\n\tassert.Empty(t, workflow.dependencies)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_AddStep_AddsStepToWorkflow_55": {
      "name": "TestWorkflow_AddStep_AddsStepToWorkflow",
      "type": "function",
      "start_line": 55,
      "end_line": 64,
      "content_hash": "f8f205b8c62bd9f1a2121b4a8a42c3ea624399ea",
      "content": "func TestWorkflow_AddStep_AddsStepToWorkflow(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep := &mockWorkflowStep{name: \"step1\"}\n\n\tworkflow.AddStep(step)\n\n\tassert.Contains(t, workflow.steps, \"step1\")\n\tassert.Equal(t, step, workflow.steps[\"step1\"])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_AddDependency_CreatesDependencyBetweenSteps_65": {
      "name": "TestWorkflow_AddDependency_CreatesDependencyBetweenSteps",
      "type": "function",
      "start_line": 65,
      "end_line": 76,
      "content_hash": "c4af1cf6fb5d9cda1e207bfc1696adc67c778630",
      "content": "func TestWorkflow_AddDependency_CreatesDependencyBetweenSteps(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep1 := &mockWorkflowStep{name: \"step1\"}\n\tstep2 := &mockWorkflowStep{name: \"step2\"}\n\n\tworkflow.AddStep(step1)\n\tworkflow.AddStep(step2)\n\tworkflow.AddDependency(\"step2\", \"step1\")\n\n\tassert.Contains(t, workflow.dependencies[\"step2\"], \"step1\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_SingleStep_Success_77": {
      "name": "TestWorkflow_Execute_SingleStep_Success",
      "type": "function",
      "start_line": 77,
      "end_line": 94,
      "content_hash": "90fa6f7d276c4e8cd3c28e3107af28927d9e99b9",
      "content": "func TestWorkflow_Execute_SingleStep_Success(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep := &mockWorkflowStep{\n\t\tname: \"step1\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"result\": \"success\",\n\t\t},\n\t}\n\n\tworkflow.AddStep(step)\n\n\tresult, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\n\trequire.NoError(t, err)\n\tassert.True(t, step.executed)\n\tassert.Equal(t, \"success\", result[\"step1_result\"])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_SequentialSteps_Success_95": {
      "name": "TestWorkflow_Execute_SequentialSteps_Success",
      "type": "function",
      "start_line": 95,
      "end_line": 121,
      "content_hash": "86796fd79c45b5ecb461b7d1920d399b36a3e25b",
      "content": "func TestWorkflow_Execute_SequentialSteps_Success(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep1 := &mockWorkflowStep{\n\t\tname: \"step1\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"value\": 10,\n\t\t},\n\t}\n\tstep2 := &mockWorkflowStep{\n\t\tname: \"step2\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"doubled\": 20,\n\t\t},\n\t}\n\n\tworkflow.AddStep(step1)\n\tworkflow.AddStep(step2)\n\tworkflow.AddDependency(\"step2\", \"step1\")\n\n\tresult, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\n\trequire.NoError(t, err)\n\tassert.True(t, step1.executed)\n\tassert.True(t, step2.executed)\n\tassert.Equal(t, 20, result[\"step2_doubled\"])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_ParallelSteps_Success_122": {
      "name": "TestWorkflow_Execute_ParallelSteps_Success",
      "type": "function",
      "start_line": 122,
      "end_line": 155,
      "content_hash": "e9ad49ecbfa05ca8f222f805c7bc6d991d7ffb12",
      "content": "func TestWorkflow_Execute_ParallelSteps_Success(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep1 := &mockWorkflowStep{\n\t\tname: \"step1\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"task1\": \"done\",\n\t\t},\n\t\tdelay: 100 * time.Millisecond,\n\t}\n\tstep2 := &mockWorkflowStep{\n\t\tname: \"step2\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"task2\": \"done\",\n\t\t},\n\t\tdelay: 100 * time.Millisecond,\n\t}\n\n\tworkflow.AddStep(step1)\n\tworkflow.AddStep(step2)\n\t// No dependencies - should run in parallel\n\n\tstart := time.Now()\n\tresult, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\tduration := time.Since(start)\n\n\trequire.NoError(t, err)\n\tassert.True(t, step1.executed)\n\tassert.True(t, step2.executed)\n\tassert.Equal(t, \"done\", result[\"step1_task1\"])\n\tassert.Equal(t, \"done\", result[\"step2_task2\"])\n\t// Should complete in roughly 100ms, not 200ms (parallel execution)\n\tassert.Less(t, duration, 150*time.Millisecond)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_ConditionalBranch_ExecutesCorrectPath_156": {
      "name": "TestWorkflow_Execute_ConditionalBranch_ExecutesCorrectPath",
      "type": "function",
      "start_line": 156,
      "end_line": 197,
      "content_hash": "a645218247c382975259c0554f20d2f117d3c0a7",
      "content": "func TestWorkflow_Execute_ConditionalBranch_ExecutesCorrectPath(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\n\t// Create a step that outputs a condition\n\tconditionStep := &mockWorkflowStep{\n\t\tname: \"condition\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"should_branch\": true,\n\t\t},\n\t}\n\n\t// Create branch steps\n\tbranchTrue := &mockWorkflowStep{\n\t\tname: \"branch_true\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"result\": \"executed_true_path\",\n\t\t},\n\t}\n\n\tbranchFalse := &mockWorkflowStep{\n\t\tname: \"branch_false\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"result\": \"executed_false_path\",\n\t\t},\n\t}\n\n\tworkflow.AddStep(conditionStep)\n\tworkflow.AddStep(branchTrue)\n\tworkflow.AddStep(branchFalse)\n\n\t// Only add dependency for true branch\n\tworkflow.AddDependency(\"branch_true\", \"condition\")\n\tworkflow.AddDependency(\"branch_false\", \"condition\")\n\n\t_, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\n\trequire.NoError(t, err)\n\tassert.True(t, conditionStep.executed)\n\t// Both branches execute in this simple implementation\n\t// In a real conditional workflow, we'd add conditional logic\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_CircularDependency_ReturnsError_198": {
      "name": "TestWorkflow_Execute_CircularDependency_ReturnsError",
      "type": "function",
      "start_line": 198,
      "end_line": 213,
      "content_hash": "1316293b2115c294a715e7fcd35aee435df94442",
      "content": "func TestWorkflow_Execute_CircularDependency_ReturnsError(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep1 := &mockWorkflowStep{name: \"step1\"}\n\tstep2 := &mockWorkflowStep{name: \"step2\"}\n\n\tworkflow.AddStep(step1)\n\tworkflow.AddStep(step2)\n\tworkflow.AddDependency(\"step1\", \"step2\")\n\tworkflow.AddDependency(\"step2\", \"step1\") // Circular dependency\n\n\t_, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"circular dependency\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_StepError_PropagatesError_214": {
      "name": "TestWorkflow_Execute_StepError_PropagatesError",
      "type": "function",
      "start_line": 214,
      "end_line": 228,
      "content_hash": "dfbff4ba18009c99bd136b960d9f579d571e2cd8",
      "content": "func TestWorkflow_Execute_StepError_PropagatesError(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep := &mockWorkflowStep{\n\t\tname:          \"step1\",\n\t\terrorToReturn: errors.New(\"step failed\"),\n\t}\n\n\tworkflow.AddStep(step)\n\n\t_, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"step failed\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_Execute_ContextCancellation_PropagatesError_229": {
      "name": "TestWorkflow_Execute_ContextCancellation_PropagatesError",
      "type": "function",
      "start_line": 229,
      "end_line": 249,
      "content_hash": "a2facbb3ec866c08c463effba038e5daaa386a32",
      "content": "func TestWorkflow_Execute_ContextCancellation_PropagatesError(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep := &mockWorkflowStep{\n\t\tname:  \"step1\",\n\t\tdelay: 100 * time.Millisecond,\n\t\toutput: map[string]interface{}{\n\t\t\t\"result\": \"success\",\n\t\t},\n\t}\n\n\tworkflow.AddStep(step)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := workflow.Execute(ctx, map[string]interface{}{})\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"context deadline exceeded\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestWorkflow_GetExecutionStatus_TracksExecution_250": {
      "name": "TestWorkflow_GetExecutionStatus_TracksExecution",
      "type": "function",
      "start_line": 250,
      "end_line": 269,
      "content_hash": "a89579dfd81b7f0634c86051af8a07ee9b8a3de7",
      "content": "func TestWorkflow_GetExecutionStatus_TracksExecution(t *testing.T) {\n\tworkflow := NewWorkflow(\"test-workflow\")\n\tstep := &mockWorkflowStep{\n\t\tname: \"step1\",\n\t\toutput: map[string]interface{}{\n\t\t\t\"result\": \"success\",\n\t\t},\n\t}\n\n\tworkflow.AddStep(step)\n\n\t// Execute workflow\n\t_, err := workflow.Execute(context.Background(), map[string]interface{}{})\n\trequire.NoError(t, err)\n\n\t// Check execution status\n\tstatus := workflow.GetExecutionStatus()\n\tassert.NotNil(t, status)\n\tassert.True(t, status[\"step1\"].Executed)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}