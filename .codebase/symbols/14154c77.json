{
  "file_path": "/work/context-engine/scripts/subprocess_manager.py",
  "file_hash": "029f362ecc569b66a5800e7f85dce478f24ac401",
  "updated_at": "2025-12-26T17:34:21.821193",
  "symbols": {
    "class_SubprocessManager_22": {
      "name": "SubprocessManager",
      "type": "class",
      "start_line": 22,
      "end_line": 254,
      "content_hash": "d6f03d5c96f7ea898d286e81252870ce288068d6",
      "content": "class SubprocessManager:\n    \"\"\"Context manager for subprocess lifecycle management.\"\"\"\n\n    def __init__(self, timeout: Optional[float] = None, env: Optional[Dict[str, str]] = None):\n        self.timeout = timeout\n        self.env = env or {}\n        self.process = None\n        self._id = None\n\n    def __enter__(self):\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        # Create subprocess with proper resource management\n        try:\n            # For async operations, we'll store the process but not start it here\n            return self\n        except Exception as e:\n            logger.error(f\"Failed to initialize subprocess manager: {e}\")\n            raise\n\n    async def __aenter__(self):\n        \"\"\"Support async context management.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Ensure async cleanup on exit.\"\"\"\n        try:\n            await self._cleanup()\n        except Exception:\n            pass\n\n    async def run_async(self, cmd: List[str]) -> Dict[str, Any]:\n        \"\"\"Run subprocess asynchronously with proper cleanup.\"\"\"\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        with _PROCESS_LOCK:\n            _PROCESS_COUNTER += 1\n            self._id = _PROCESS_COUNTER\n\n        try:\n            # Create the subprocess\n            self.process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                env=self.env,\n            )\n\n            # Register the process\n            _ACTIVE_PROCESSES[self._id] = self.process\n\n            # Determine effective timeout without overwriting caller-supplied value\n            if self.timeout is None:\n                timeout_str = os.environ.get(\"SUBPROCESS_DEFAULT_TIMEOUT\", \"600\")\n                try:\n                    eff_timeout = float(timeout_str)\n                except ValueError:\n                    eff_timeout = 600.0\n            else:\n                eff_timeout = self.timeout\n\n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    self.process.communicate(),\n                    timeout=eff_timeout\n                )\n                return {\n                    \"ok\": self.process.returncode == 0,\n                    \"code\": self.process.returncode,\n                    \"stdout\": stdout.decode(\"utf-8\", errors=\"ignore\") if stdout else \"\",\n                    \"stderr\": stderr.decode(\"utf-8\", errors=\"ignore\") if stderr else \"\",\n                }\n            except asyncio.TimeoutError:\n                logger.warning(f\"Subprocess {self._id} timed out after {self.timeout}s, terminating\")\n                try:\n                    self.process.kill()\n                except Exception:\n                    pass\n                return {\n                    \"ok\": False,\n                    \"code\": -1,\n                    \"stdout\": \"\",\n                    \"stderr\": f\"Command timed out after {self.timeout}s\",\n                }\n            finally:\n                # Cleanup\n                await self._cleanup()\n\n        except Exception as e:\n            logger.error(f\"Failed to run subprocess {self._id}: {e}\")\n            await self._cleanup()\n            return {\n                \"ok\": False,\n                \"code\": -2,\n                \"stdout\": \"\",\n                \"stderr\": str(e),\n            }\n\n    def run_sync(self, cmd: List[str]) -> Dict[str, Any]:\n        \"\"\"Run subprocess synchronously with proper cleanup.\"\"\"\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        with _PROCESS_LOCK:\n            _PROCESS_COUNTER += 1\n            self._id = _PROCESS_COUNTER\n\n        try:\n            # Determine effective timeout without overwriting caller-supplied value\n            if self.timeout is None:\n                timeout_str = os.environ.get(\"SUBPROCESS_DEFAULT_TIMEOUT\", \"600\")\n                try:\n                    eff_timeout = float(timeout_str)\n                except ValueError:\n                    eff_timeout = 600.0\n            else:\n                eff_timeout = self.timeout\n\n            # Create the subprocess\n            self.process = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                env=self.env,\n            )\n\n            # Register the process\n            _ACTIVE_PROCESSES[self._id] = self.process\n\n            try:\n                stdout, stderr = self.process.communicate(timeout=eff_timeout)\n                return {\n                    \"ok\": self.process.returncode == 0,\n                    \"code\": self.process.returncode,\n                    \"stdout\": stdout.decode(\"utf-8\", errors=\"ignore\") if stdout else \"\",\n                    \"stderr\": stderr.decode(\"utf-8\", errors=\"ignore\") if stderr else \"\",\n                }\n            except subprocess.TimeoutExpired:\n                logger.warning(f\"Subprocess {self._id} timed out after {eff_timeout}s, terminating\")\n                try:\n                    self.process.kill()\n                except Exception:\n                    pass\n                return {\n                    \"ok\": False,\n                    \"code\": -1,\n                    \"stdout\": \"\",\n                    \"stderr\": f\"Command timed out after {self.timeout}s\",\n                }\n            finally:\n                # Cleanup\n                self._cleanup()\n\n        except Exception as e:\n            logger.error(f\"Failed to run subprocess {self._id}: {e}\")\n            self._cleanup()\n            return {\n                \"ok\": False,\n                \"code\": -2,\n                \"stdout\": \"\",\n                \"stderr\": str(e),\n            }\n\n    async def _cleanup(self):\n        \"\"\"Clean up subprocess resources.\"\"\"\n        if self.process is not None:\n            try:\n                # Close pipes\n                if self.process.stdout:\n                    self.process.stdout.close()\n                if self.process.stderr:\n                    self.process.stderr.close()\n\n                # Wait for process to terminate\n                with contextlib.suppress(Exception):\n                    await self.process.wait()\n\n                # Remove from active processes\n                global _ACTIVE_PROCESSES, _PROCESS_LOCK\n                with _PROCESS_LOCK:\n                    if self._id in _ACTIVE_PROCESSES:\n                        del _ACTIVE_PROCESSES[self._id]\n            except Exception as e:\n                logger.error(f\"Error during subprocess cleanup {self._id}: {e}\")\n            finally:\n                self.process = None\n                self._id = None\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit - ensure cleanup.\"\"\"\n        # For sync context manager usage\n        if self.process is not None:\n            try:\n                self._cleanup_sync()\n            except Exception as e:\n                logger.error(f\"Error during subprocess cleanup: {e}\")\n\n    def _cleanup_sync(self):\n        \"\"\"Synchronous cleanup for context manager exit.\"\"\"\n        if self.process is not None:\n            try:\n                # Close pipes\n                if self.process.stdout:\n                    self.process.stdout.close()\n                if self.process.stderr:\n                    self.process.stderr.close()\n\n                # Terminate process if still running\n                if self.process.poll() is None:\n                    try:\n                        self.process.terminate()\n                        # Give it a moment to terminate gracefully\n                        try:\n                            self.process.wait(timeout=5)\n                        except subprocess.TimeoutExpired:\n                            # Force kill if it doesn't terminate\n                            self.process.kill()\n                    except Exception:\n                        pass\n\n                # Ensure process is reaped\n                with contextlib.suppress(Exception):\n                    self.process.wait()\n\n                # Remove from active processes\n                global _ACTIVE_PROCESSES, _PROCESS_LOCK\n                with _PROCESS_LOCK:\n                    if self._id in _ACTIVE_PROCESSES:\n                        del _ACTIVE_PROCESSES[self._id]\n            except Exception as e:\n                logger.error(f\"Error during subprocess sync cleanup: {e}\")\n            finally:\n                self.process = None\n                self._id = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___init___25": {
      "name": "__init__",
      "type": "method",
      "start_line": 25,
      "end_line": 29,
      "content_hash": "2b38cba48c7121d970f563c7997f5c0865a2ea2e",
      "content": "    def __init__(self, timeout: Optional[float] = None, env: Optional[Dict[str, str]] = None):\n        self.timeout = timeout\n        self.env = env or {}\n        self.process = None\n        self._id = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___enter___31": {
      "name": "__enter__",
      "type": "method",
      "start_line": 31,
      "end_line": 40,
      "content_hash": "e48895b6128761e1193e4de6edf8e8cf40037f08",
      "content": "    def __enter__(self):\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        # Create subprocess with proper resource management\n        try:\n            # For async operations, we'll store the process but not start it here\n            return self\n        except Exception as e:\n            logger.error(f\"Failed to initialize subprocess manager: {e}\")\n            raise",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___aenter___42": {
      "name": "__aenter__",
      "type": "method",
      "start_line": 42,
      "end_line": 44,
      "content_hash": "79c9d8a8f6a5e0f2cb828137e92556c81883b873",
      "content": "    async def __aenter__(self):\n        \"\"\"Support async context management.\"\"\"\n        return self",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___aexit___46": {
      "name": "__aexit__",
      "type": "method",
      "start_line": 46,
      "end_line": 51,
      "content_hash": "034329b19dfd9b76d148fb0c0c4ff06dcab6299b",
      "content": "    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Ensure async cleanup on exit.\"\"\"\n        try:\n            await self._cleanup()\n        except Exception:\n            pass",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_async_53": {
      "name": "run_async",
      "type": "method",
      "start_line": 53,
      "end_line": 118,
      "content_hash": "b88c03439a60d64259a11f20563ef603a95801a2",
      "content": "    async def run_async(self, cmd: List[str]) -> Dict[str, Any]:\n        \"\"\"Run subprocess asynchronously with proper cleanup.\"\"\"\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        with _PROCESS_LOCK:\n            _PROCESS_COUNTER += 1\n            self._id = _PROCESS_COUNTER\n\n        try:\n            # Create the subprocess\n            self.process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                env=self.env,\n            )\n\n            # Register the process\n            _ACTIVE_PROCESSES[self._id] = self.process\n\n            # Determine effective timeout without overwriting caller-supplied value\n            if self.timeout is None:\n                timeout_str = os.environ.get(\"SUBPROCESS_DEFAULT_TIMEOUT\", \"600\")\n                try:\n                    eff_timeout = float(timeout_str)\n                except ValueError:\n                    eff_timeout = 600.0\n            else:\n                eff_timeout = self.timeout\n\n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    self.process.communicate(),\n                    timeout=eff_timeout\n                )\n                return {\n                    \"ok\": self.process.returncode == 0,\n                    \"code\": self.process.returncode,\n                    \"stdout\": stdout.decode(\"utf-8\", errors=\"ignore\") if stdout else \"\",\n                    \"stderr\": stderr.decode(\"utf-8\", errors=\"ignore\") if stderr else \"\",\n                }\n            except asyncio.TimeoutError:\n                logger.warning(f\"Subprocess {self._id} timed out after {self.timeout}s, terminating\")\n                try:\n                    self.process.kill()\n                except Exception:\n                    pass\n                return {\n                    \"ok\": False,\n                    \"code\": -1,\n                    \"stdout\": \"\",\n                    \"stderr\": f\"Command timed out after {self.timeout}s\",\n                }\n            finally:\n                # Cleanup\n                await self._cleanup()\n\n        except Exception as e:\n            logger.error(f\"Failed to run subprocess {self._id}: {e}\")\n            await self._cleanup()\n            return {\n                \"ok\": False,\n                \"code\": -2,\n                \"stdout\": \"\",\n                \"stderr\": str(e),\n            }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_sync_120": {
      "name": "run_sync",
      "type": "method",
      "start_line": 120,
      "end_line": 182,
      "content_hash": "e64b230bef5be189bb71cb737574871b0311b075",
      "content": "    def run_sync(self, cmd: List[str]) -> Dict[str, Any]:\n        \"\"\"Run subprocess synchronously with proper cleanup.\"\"\"\n        global _PROCESS_COUNTER, _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n        with _PROCESS_LOCK:\n            _PROCESS_COUNTER += 1\n            self._id = _PROCESS_COUNTER\n\n        try:\n            # Determine effective timeout without overwriting caller-supplied value\n            if self.timeout is None:\n                timeout_str = os.environ.get(\"SUBPROCESS_DEFAULT_TIMEOUT\", \"600\")\n                try:\n                    eff_timeout = float(timeout_str)\n                except ValueError:\n                    eff_timeout = 600.0\n            else:\n                eff_timeout = self.timeout\n\n            # Create the subprocess\n            self.process = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                env=self.env,\n            )\n\n            # Register the process\n            _ACTIVE_PROCESSES[self._id] = self.process\n\n            try:\n                stdout, stderr = self.process.communicate(timeout=eff_timeout)\n                return {\n                    \"ok\": self.process.returncode == 0,\n                    \"code\": self.process.returncode,\n                    \"stdout\": stdout.decode(\"utf-8\", errors=\"ignore\") if stdout else \"\",\n                    \"stderr\": stderr.decode(\"utf-8\", errors=\"ignore\") if stderr else \"\",\n                }\n            except subprocess.TimeoutExpired:\n                logger.warning(f\"Subprocess {self._id} timed out after {eff_timeout}s, terminating\")\n                try:\n                    self.process.kill()\n                except Exception:\n                    pass\n                return {\n                    \"ok\": False,\n                    \"code\": -1,\n                    \"stdout\": \"\",\n                    \"stderr\": f\"Command timed out after {self.timeout}s\",\n                }\n            finally:\n                # Cleanup\n                self._cleanup()\n\n        except Exception as e:\n            logger.error(f\"Failed to run subprocess {self._id}: {e}\")\n            self._cleanup()\n            return {\n                \"ok\": False,\n                \"code\": -2,\n                \"stdout\": \"\",\n                \"stderr\": str(e),\n            }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method__cleanup_184": {
      "name": "_cleanup",
      "type": "method",
      "start_line": 184,
      "end_line": 207,
      "content_hash": "c1b4c4b892bcee0f54f247040e01bf3b5f5ac9a2",
      "content": "    async def _cleanup(self):\n        \"\"\"Clean up subprocess resources.\"\"\"\n        if self.process is not None:\n            try:\n                # Close pipes\n                if self.process.stdout:\n                    self.process.stdout.close()\n                if self.process.stderr:\n                    self.process.stderr.close()\n\n                # Wait for process to terminate\n                with contextlib.suppress(Exception):\n                    await self.process.wait()\n\n                # Remove from active processes\n                global _ACTIVE_PROCESSES, _PROCESS_LOCK\n                with _PROCESS_LOCK:\n                    if self._id in _ACTIVE_PROCESSES:\n                        del _ACTIVE_PROCESSES[self._id]\n            except Exception as e:\n                logger.error(f\"Error during subprocess cleanup {self._id}: {e}\")\n            finally:\n                self.process = None\n                self._id = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method___exit___209": {
      "name": "__exit__",
      "type": "method",
      "start_line": 209,
      "end_line": 216,
      "content_hash": "116dcd93c2e72708fd53bc3746eadf782c6be51d",
      "content": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit - ensure cleanup.\"\"\"\n        # For sync context manager usage\n        if self.process is not None:\n            try:\n                self._cleanup_sync()\n            except Exception as e:\n                logger.error(f\"Error during subprocess cleanup: {e}\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method__cleanup_sync_218": {
      "name": "_cleanup_sync",
      "type": "method",
      "start_line": 218,
      "end_line": 254,
      "content_hash": "0f6cf2e11668e8ac9ed1598dbf34392d96221273",
      "content": "    def _cleanup_sync(self):\n        \"\"\"Synchronous cleanup for context manager exit.\"\"\"\n        if self.process is not None:\n            try:\n                # Close pipes\n                if self.process.stdout:\n                    self.process.stdout.close()\n                if self.process.stderr:\n                    self.process.stderr.close()\n\n                # Terminate process if still running\n                if self.process.poll() is None:\n                    try:\n                        self.process.terminate()\n                        # Give it a moment to terminate gracefully\n                        try:\n                            self.process.wait(timeout=5)\n                        except subprocess.TimeoutExpired:\n                            # Force kill if it doesn't terminate\n                            self.process.kill()\n                    except Exception:\n                        pass\n\n                # Ensure process is reaped\n                with contextlib.suppress(Exception):\n                    self.process.wait()\n\n                # Remove from active processes\n                global _ACTIVE_PROCESSES, _PROCESS_LOCK\n                with _PROCESS_LOCK:\n                    if self._id in _ACTIVE_PROCESSES:\n                        del _ACTIVE_PROCESSES[self._id]\n            except Exception as e:\n                logger.error(f\"Error during subprocess sync cleanup: {e}\")\n            finally:\n                self.process = None\n                self._id = None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_active_processes_257": {
      "name": "get_active_processes",
      "type": "function",
      "start_line": 257,
      "end_line": 274,
      "content_hash": "e9e2934c687b750dea0a2ded3525de27d6e34852",
      "content": "def get_active_processes() -> Dict[int, str]:\n    \"\"\"Get information about currently active subprocess processes.\"\"\"\n    global _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n    with _PROCESS_LOCK:\n        info = {}\n        for pid, proc in _ACTIVE_PROCESSES.items():\n            try:\n                args = ' '.join(proc.args) if hasattr(proc, 'args') else 'unknown'\n            except Exception:\n                args = 'unknown'\n            try:\n                running = (proc.poll() is None) if hasattr(proc, 'poll') else (getattr(proc, 'returncode', None) is None)\n            except Exception:\n                running = False\n            status = 'running' if running else f\"returncode: {getattr(proc, 'returncode', 'unknown')}\"\n            info[pid] = f\"cmd: {args}, status: {status}\"\n        return info",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_cleanup_all_processes_277": {
      "name": "cleanup_all_processes",
      "type": "function",
      "start_line": 277,
      "end_line": 301,
      "content_hash": "97db0576df5d3ec08afe3029c9b59648c0c4054a",
      "content": "def cleanup_all_processes():\n    \"\"\"Force cleanup of all active subprocess processes.\"\"\"\n    global _ACTIVE_PROCESSES, _PROCESS_LOCK\n\n    with _PROCESS_LOCK:\n        for pid, proc in list(_ACTIVE_PROCESSES.items()):\n            try:\n                if (hasattr(proc, 'poll') and proc.poll() is None) or (getattr(proc, 'returncode', None) is None):\n                    proc.terminate()\n                    # Give it a moment to terminate gracefully\n                    try:\n                        proc.wait(timeout=5)\n                    except subprocess.TimeoutExpired:\n                        # Force kill if it doesn't terminate\n                        proc.kill()\n                    except Exception:\n                        pass\n\n                # Ensure process is reaped\n                with contextlib.suppress(Exception):\n                    proc.wait()\n            except Exception as e:\n                logger.error(f\"Error cleaning up process {pid}: {e}\")\n\n        _ACTIVE_PROCESSES.clear()",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_run_subprocess_async_305": {
      "name": "run_subprocess_async",
      "type": "function",
      "start_line": 305,
      "end_line": 308,
      "content_hash": "20bc0b442d6bd25908079a30fe7762576d0ab215",
      "content": "async def run_subprocess_async(cmd: List[str], timeout: Optional[float] = None, env: Optional[Dict[str, str]] = None) -> Dict[str, Any]:\n    \"\"\"Convenience function to run subprocess asynchronously with proper cleanup.\"\"\"\n    async with SubprocessManager(timeout=timeout, env=env) as manager:\n        return await manager.run_async(cmd)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_run_subprocess_sync_311": {
      "name": "run_subprocess_sync",
      "type": "function",
      "start_line": 311,
      "end_line": 314,
      "content_hash": "6a2fdde834a2428451ac94ac627c9e8371413ee1",
      "content": "def run_subprocess_sync(cmd: List[str], timeout: Optional[float] = None, env: Optional[Dict[str, str]] = None) -> Dict[str, Any]:\n    \"\"\"Convenience function to run subprocess synchronously with proper cleanup.\"\"\"\n    with SubprocessManager(timeout=timeout, env=env) as manager:\n        return manager.run_sync(cmd)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}