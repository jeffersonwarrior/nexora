{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/http/routes/SessionRoutes.ts",
  "file_hash": "abfa29e1589393359dcc17fcec6ea402627a6a7e",
  "updated_at": "2025-12-26T17:34:20.001793",
  "symbols": {
    "class_SessionRoutes_23": {
      "name": "SessionRoutes",
      "type": "class",
      "start_line": 23,
      "end_line": 481,
      "content_hash": "16af1eb83768a37edba9bb0c524a8e0220335939",
      "content": "export class SessionRoutes extends BaseRouteHandler {\n  private completionHandler: SessionCompletionHandler;\n\n  constructor(\n    private sessionManager: SessionManager,\n    private dbManager: DatabaseManager,\n    private sdkAgent: SDKAgent,\n    private eventBroadcaster: SessionEventBroadcaster,\n    private workerService: WorkerService\n  ) {\n    super();\n    this.completionHandler = new SessionCompletionHandler(\n      sessionManager,\n      dbManager,\n      eventBroadcaster\n    );\n  }\n\n  /**\n   * Ensures SDK agent generator is running for a session\n   * Auto-starts if not already running to process pending queue\n   */\n  private ensureGeneratorRunning(sessionDbId: number, source: string): void {\n    const session = this.sessionManager.getSession(sessionDbId);\n    if (session && !session.generatorPromise) {\n      logger.info('SESSION', `Generator auto-starting (${source})`, {\n        sessionId: sessionDbId,\n        queueDepth: session.pendingMessages.length\n      });\n\n      session.generatorPromise = this.sdkAgent.startSession(session, this.workerService)\n        .finally(() => {\n          logger.info('SESSION', `Generator finished`, { sessionId: sessionDbId });\n          session.generatorPromise = null;\n          this.workerService.broadcastProcessingStatus();\n        });\n    }\n  }\n\n  setupRoutes(app: express.Application): void {\n    // Legacy session endpoints (use sessionDbId)\n    app.post('/sessions/:sessionDbId/init', this.handleSessionInit.bind(this));\n    app.post('/sessions/:sessionDbId/observations', this.handleObservations.bind(this));\n    app.post('/sessions/:sessionDbId/summarize', this.handleSummarize.bind(this));\n    app.get('/sessions/:sessionDbId/status', this.handleSessionStatus.bind(this));\n    app.delete('/sessions/:sessionDbId', this.handleSessionDelete.bind(this));\n    app.post('/sessions/:sessionDbId/complete', this.handleSessionComplete.bind(this));\n\n    // New session endpoints (use claudeSessionId)\n    app.post('/api/sessions/init', this.handleSessionInitByClaudeId.bind(this));\n    app.post('/api/sessions/observations', this.handleObservationsByClaudeId.bind(this));\n    app.post('/api/sessions/summarize', this.handleSummarizeByClaudeId.bind(this));\n    app.post('/api/sessions/complete', this.handleSessionCompleteByClaudeId.bind(this));\n  }\n\n  /**\n   * Initialize a new session\n   */\n  private handleSessionInit = this.wrapHandler((req: Request, res: Response): void => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    const { userPrompt, promptNumber } = req.body;\n    const session = this.sessionManager.initializeSession(sessionDbId, userPrompt, promptNumber);\n\n    // Get the latest user_prompt for this session to sync to Chroma\n    const latestPrompt = this.dbManager.getSessionStore().getLatestUserPrompt(session.claudeSessionId);\n\n    // Broadcast new prompt to SSE clients (for web UI)\n    if (latestPrompt) {\n      this.eventBroadcaster.broadcastNewPrompt({\n        id: latestPrompt.id,\n        claude_session_id: latestPrompt.claude_session_id,\n        project: latestPrompt.project,\n        prompt_number: latestPrompt.prompt_number,\n        prompt_text: latestPrompt.prompt_text,\n        created_at_epoch: latestPrompt.created_at_epoch\n      });\n\n      // Sync user prompt to Chroma\n      const chromaStart = Date.now();\n      const promptText = latestPrompt.prompt_text;\n      this.dbManager.getChromaSync().syncUserPrompt(\n        latestPrompt.id,\n        latestPrompt.sdk_session_id,\n        latestPrompt.project,\n        promptText,\n        latestPrompt.prompt_number,\n        latestPrompt.created_at_epoch\n      ).then(() => {\n        const chromaDuration = Date.now() - chromaStart;\n        const truncatedPrompt = promptText.length > 60\n          ? promptText.substring(0, 60) + '...'\n          : promptText;\n        logger.debug('CHROMA', 'User prompt synced', {\n          promptId: latestPrompt.id,\n          duration: `${chromaDuration}ms`,\n          prompt: truncatedPrompt\n        });\n      }).catch((error) => {\n        logger.warn('CHROMA', 'User prompt sync failed, continuing without vector search', {\n          promptId: latestPrompt.id,\n          prompt: promptText.length > 60 ? promptText.substring(0, 60) + '...' : promptText\n        }, error);\n      });\n    }\n\n    // Start SDK agent in background (pass worker ref for spinner control)\n    logger.info('SESSION', 'Generator starting', {\n      sessionId: sessionDbId,\n      project: session.project,\n      promptNum: session.lastPromptNumber\n    });\n\n    session.generatorPromise = this.sdkAgent.startSession(session, this.workerService)\n      .finally(() => {\n        // Clear generator reference when completed\n        logger.info('SESSION', `Generator finished`, { sessionId: sessionDbId });\n        session.generatorPromise = null;\n        // Broadcast status change (generator finished, may stop spinner)\n        this.workerService.broadcastProcessingStatus();\n      });\n\n    // Broadcast session started event\n    this.eventBroadcaster.broadcastSessionStarted(sessionDbId, session.project);\n\n    res.json({ status: 'initialized', sessionDbId, port: getWorkerPort() });\n  });\n\n  /**\n   * Queue observations for processing\n   * CRITICAL: Ensures SDK agent is running to process the queue (ALWAYS SAVE EVERYTHING)\n   */\n  private handleObservations = this.wrapHandler((req: Request, res: Response): void => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    const { tool_name, tool_input, tool_response, prompt_number, cwd } = req.body;\n\n    this.sessionManager.queueObservation(sessionDbId, {\n      tool_name,\n      tool_input,\n      tool_response,\n      prompt_number,\n      cwd\n    });\n\n    // CRITICAL: Ensure SDK agent is running to consume the queue\n    this.ensureGeneratorRunning(sessionDbId, 'observation');\n\n    // Broadcast observation queued event\n    this.eventBroadcaster.broadcastObservationQueued(sessionDbId);\n\n    res.json({ status: 'queued' });\n  });\n\n  /**\n   * Queue summarize request\n   * CRITICAL: Ensures SDK agent is running to process the queue (ALWAYS SAVE EVERYTHING)\n   */\n  private handleSummarize = this.wrapHandler((req: Request, res: Response): void => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    const { last_user_message, last_assistant_message } = req.body;\n\n    this.sessionManager.queueSummarize(sessionDbId, last_user_message, last_assistant_message);\n\n    // CRITICAL: Ensure SDK agent is running to consume the queue\n    this.ensureGeneratorRunning(sessionDbId, 'summarize');\n\n    // Broadcast summarize queued event\n    this.eventBroadcaster.broadcastSummarizeQueued();\n\n    res.json({ status: 'queued' });\n  });\n\n  /**\n   * Get session status\n   */\n  private handleSessionStatus = this.wrapHandler((req: Request, res: Response): void => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    const session = this.sessionManager.getSession(sessionDbId);\n\n    if (!session) {\n      res.json({ status: 'not_found' });\n      return;\n    }\n\n    res.json({\n      status: 'active',\n      sessionDbId,\n      project: session.project,\n      queueLength: session.pendingMessages.length,\n      uptime: Date.now() - session.startTime\n    });\n  });\n\n  /**\n   * Delete a session\n   */\n  private handleSessionDelete = this.wrapHandler(async (req: Request, res: Response): Promise<void> => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    await this.completionHandler.completeByDbId(sessionDbId);\n\n    res.json({ status: 'deleted' });\n  });\n\n  /**\n   * Complete a session (backward compatibility for cleanup-hook)\n   * cleanup-hook expects POST /sessions/:sessionDbId/complete instead of DELETE\n   */\n  private handleSessionComplete = this.wrapHandler(async (req: Request, res: Response): Promise<void> => {\n    const sessionDbId = this.parseIntParam(req, res, 'sessionDbId');\n    if (sessionDbId === null) return;\n\n    await this.completionHandler.completeByDbId(sessionDbId);\n\n    res.json({ success: true });\n  });\n\n  /**\n   * Queue observations by claudeSessionId (post-tool-use-hook uses this)\n   * POST /api/sessions/observations\n   * Body: { claudeSessionId, tool_name, tool_input, tool_response, cwd }\n   */\n  private handleObservationsByClaudeId = this.wrapHandler((req: Request, res: Response): void => {\n    const { claudeSessionId, tool_name, tool_input, tool_response, cwd } = req.body;\n\n    if (!claudeSessionId) {\n      return this.badRequest(res, 'Missing claudeSessionId');\n    }\n\n    // Load skip tools from settings\n    const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n    const skipTools = new Set(settings.CLAUDE_MEM_SKIP_TOOLS.split(',').map(t => t.trim()).filter(Boolean));\n\n    // Skip low-value or meta tools\n    if (skipTools.has(tool_name)) {\n      logger.debug('SESSION', 'Skipping observation for tool', { tool_name });\n      res.json({ status: 'skipped', reason: 'tool_excluded' });\n      return;\n    }\n\n    // Skip meta-observations: file operations on session-memory files\n    const fileOperationTools = new Set(['Edit', 'Write', 'Read', 'NotebookEdit']);\n    if (fileOperationTools.has(tool_name) && tool_input) {\n      const filePath = tool_input.file_path || tool_input.notebook_path;\n      if (filePath && filePath.includes('session-memory')) {\n        logger.debug('SESSION', 'Skipping meta-observation for session-memory file', {\n          tool_name,\n          file_path: filePath\n        });\n        res.json({ status: 'skipped', reason: 'session_memory_meta' });\n        return;\n      }\n    }\n\n    const store = this.dbManager.getSessionStore();\n\n    // Get or create session\n    const sessionDbId = store.createSDKSession(claudeSessionId, '', '');\n    const promptNumber = store.getPromptCounter(sessionDbId);\n\n    // Privacy check: skip if user prompt was entirely private\n    const userPrompt = PrivacyCheckValidator.checkUserPromptPrivacy(\n      store,\n      claudeSessionId,\n      promptNumber,\n      'observation',\n      sessionDbId,\n      { tool_name }\n    );\n    if (!userPrompt) {\n      res.json({ status: 'skipped', reason: 'private' });\n      return;\n    }\n\n    // Strip memory tags from tool_input and tool_response\n    const cleanedToolInput = tool_input !== undefined\n      ? stripMemoryTagsFromJson(JSON.stringify(tool_input))\n      : '{}';\n\n    const cleanedToolResponse = tool_response !== undefined\n      ? stripMemoryTagsFromJson(JSON.stringify(tool_response))\n      : '{}';\n\n    // Queue observation\n    this.sessionManager.queueObservation(sessionDbId, {\n      tool_name,\n      tool_input: cleanedToolInput,\n      tool_response: cleanedToolResponse,\n      prompt_number: promptNumber,\n      cwd: cwd || logger.happyPathError(\n        'SESSION',\n        'Missing cwd when queueing observation in SessionRoutes',\n        { sessionId: sessionDbId },\n        { tool_name },\n        ''\n      )\n    });\n\n    // Ensure SDK agent is running\n    this.ensureGeneratorRunning(sessionDbId, 'observation');\n\n    // Broadcast observation queued event\n    this.eventBroadcaster.broadcastObservationQueued(sessionDbId);\n\n    res.json({ status: 'queued' });\n  });\n\n  /**\n   * Queue summarize by claudeSessionId (summary-hook uses this)\n   * POST /api/sessions/summarize\n   * Body: { claudeSessionId, last_user_message, last_assistant_message }\n   *\n   * Checks privacy, queues summarize request for SDK agent\n   */\n  private handleSummarizeByClaudeId = this.wrapHandler((req: Request, res: Response): void => {\n    const { claudeSessionId, last_user_message, last_assistant_message } = req.body;\n\n    if (!claudeSessionId) {\n      return this.badRequest(res, 'Missing claudeSessionId');\n    }\n\n    const store = this.dbManager.getSessionStore();\n\n    // Get or create session\n    const sessionDbId = store.createSDKSession(claudeSessionId, '', '');\n    const promptNumber = store.getPromptCounter(sessionDbId);\n\n    // Privacy check: skip if user prompt was entirely private\n    const userPrompt = PrivacyCheckValidator.checkUserPromptPrivacy(\n      store,\n      claudeSessionId,\n      promptNumber,\n      'summarize',\n      sessionDbId\n    );\n    if (!userPrompt) {\n      res.json({ status: 'skipped', reason: 'private' });\n      return;\n    }\n\n    // Queue summarize\n    this.sessionManager.queueSummarize(\n      sessionDbId,\n      last_user_message || logger.happyPathError(\n        'SESSION',\n        'Missing last_user_message when queueing summary in SessionRoutes',\n        { sessionId: sessionDbId },\n        undefined,\n        ''\n      ),\n      last_assistant_message\n    );\n\n    // Ensure SDK agent is running\n    this.ensureGeneratorRunning(sessionDbId, 'summarize');\n\n    // Broadcast summarize queued event\n    this.eventBroadcaster.broadcastSummarizeQueued();\n\n    res.json({ status: 'queued' });\n  });\n\n  /**\n   * Complete session by claudeSessionId (cleanup-hook uses this)\n   * POST /api/sessions/complete\n   * Body: { claudeSessionId }\n   *\n   * Marks session complete, stops SDK agent, broadcasts status\n   */\n  private handleSessionCompleteByClaudeId = this.wrapHandler(async (req: Request, res: Response): Promise<void> => {\n    const { claudeSessionId } = req.body;\n\n    if (!claudeSessionId) {\n      return this.badRequest(res, 'Missing claudeSessionId');\n    }\n\n    const found = await this.completionHandler.completeByClaudeId(claudeSessionId);\n\n    if (!found) {\n      // No active session - nothing to clean up (may have already been completed)\n      res.json({ success: true, message: 'No active session found' });\n      return;\n    }\n\n    res.json({ success: true });\n  });\n\n  /**\n   * Initialize session by claudeSessionId (new-hook uses this)\n   * POST /api/sessions/init\n   * Body: { claudeSessionId, project, prompt }\n   *\n   * Performs all session initialization DB operations:\n   * - Creates/gets SDK session (idempotent)\n   * - Increments prompt counter\n   * - Saves user prompt (with privacy tag stripping)\n   *\n   * Returns: { sessionDbId, promptNumber, skipped: boolean, reason?: string }\n   */\n  private handleSessionInitByClaudeId = this.wrapHandler((req: Request, res: Response): void => {\n    const { claudeSessionId, project, prompt } = req.body;\n\n    // Validate required parameters\n    if (!this.validateRequired(req, res, ['claudeSessionId', 'project', 'prompt'])) {\n      return;\n    }\n\n    const store = this.dbManager.getSessionStore();\n\n    // Step 1: Create/get SDK session (idempotent INSERT OR IGNORE)\n    const sessionDbId = store.createSDKSession(claudeSessionId, project, prompt);\n\n    // Step 2: Increment prompt counter\n    const promptNumber = store.incrementPromptCounter(sessionDbId);\n\n    // Step 3: Strip privacy tags from prompt\n    const cleanedPrompt = stripMemoryTagsFromPrompt(prompt);\n\n    // Step 4: Check if prompt is entirely private\n    if (!cleanedPrompt || cleanedPrompt.trim() === '') {\n      logger.debug('HOOK', 'Session init - prompt entirely private', {\n        sessionId: sessionDbId,\n        promptNumber,\n        originalLength: prompt.length\n      });\n\n      res.json({\n        sessionDbId,\n        promptNumber,\n        skipped: true,\n        reason: 'private'\n      });\n      return;\n    }\n\n    // Step 5: Save cleaned user prompt\n    store.saveUserPrompt(claudeSessionId, promptNumber, cleanedPrompt);\n\n    logger.info('SESSION', 'Session initialized via HTTP', {\n      sessionId: sessionDbId,\n      promptNumber,\n      project\n    });\n\n    res.json({\n      sessionDbId,\n      promptNumber,\n      skipped: false\n    });\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_26": {
      "name": "constructor",
      "type": "method",
      "start_line": 26,
      "end_line": 39,
      "content_hash": "75d8cb5f9a2048c5f234d4c2b3469013d239aa98",
      "content": "  constructor(\n    private sessionManager: SessionManager,\n    private dbManager: DatabaseManager,\n    private sdkAgent: SDKAgent,\n    private eventBroadcaster: SessionEventBroadcaster,\n    private workerService: WorkerService\n  ) {\n    super();\n    this.completionHandler = new SessionCompletionHandler(\n      sessionManager,\n      dbManager,\n      eventBroadcaster\n    );\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureGeneratorRunning_45": {
      "name": "ensureGeneratorRunning",
      "type": "method",
      "start_line": 45,
      "end_line": 60,
      "content_hash": "a9d2ae0a0f980ac41c48bfdf82006da1088b064c",
      "content": "  private ensureGeneratorRunning(sessionDbId: number, source: string): void {\n    const session = this.sessionManager.getSession(sessionDbId);\n    if (session && !session.generatorPromise) {\n      logger.info('SESSION', `Generator auto-starting (${source})`, {\n        sessionId: sessionDbId,\n        queueDepth: session.pendingMessages.length\n      });\n\n      session.generatorPromise = this.sdkAgent.startSession(session, this.workerService)\n        .finally(() => {\n          logger.info('SESSION', `Generator finished`, { sessionId: sessionDbId });\n          session.generatorPromise = null;\n          this.workerService.broadcastProcessingStatus();\n        });\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupRoutes_62": {
      "name": "setupRoutes",
      "type": "method",
      "start_line": 62,
      "end_line": 76,
      "content_hash": "e9f6ff54efc6f3cc2bb4c54ad240904c15995eb6",
      "content": "  setupRoutes(app: express.Application): void {\n    // Legacy session endpoints (use sessionDbId)\n    app.post('/sessions/:sessionDbId/init', this.handleSessionInit.bind(this));\n    app.post('/sessions/:sessionDbId/observations', this.handleObservations.bind(this));\n    app.post('/sessions/:sessionDbId/summarize', this.handleSummarize.bind(this));\n    app.get('/sessions/:sessionDbId/status', this.handleSessionStatus.bind(this));\n    app.delete('/sessions/:sessionDbId', this.handleSessionDelete.bind(this));\n    app.post('/sessions/:sessionDbId/complete', this.handleSessionComplete.bind(this));\n\n    // New session endpoints (use claudeSessionId)\n    app.post('/api/sessions/init', this.handleSessionInitByClaudeId.bind(this));\n    app.post('/api/sessions/observations', this.handleObservationsByClaudeId.bind(this));\n    app.post('/api/sessions/summarize', this.handleSummarizeByClaudeId.bind(this));\n    app.post('/api/sessions/complete', this.handleSessionCompleteByClaudeId.bind(this));\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}