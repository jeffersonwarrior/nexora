{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/error_handling_tests.rs",
  "file_hash": "ab7d47d9e5b1807835b10a1effdb8c3c768024de",
  "updated_at": "2025-12-26T17:34:20.404634",
  "symbols": {
    "function_test_node_empty_bytes_26": {
      "name": "test_node_empty_bytes",
      "type": "function",
      "start_line": 26,
      "end_line": 35,
      "content_hash": "2472c674ca849170136dd824ae4b01e47c672dee",
      "content": "    fn test_node_empty_bytes() {\n        let arena = Bump::new();\n        let id = 12345u128;\n        let empty_bytes: &[u8] = &[];\n\n        let result = Node::from_bincode_bytes(id, empty_bytes, &arena);\n        assert!(result.is_err(), \"Should fail on empty bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_truncated_bytes_36": {
      "name": "test_node_truncated_bytes",
      "type": "function",
      "start_line": 36,
      "end_line": 52,
      "content_hash": "d0e75cba430b37c2d9661613a16ea0355f3f2a6e",
      "content": "    fn test_node_truncated_bytes() {\n        let arena = Bump::new();\n        let id = 11111u128;\n\n        // Create a valid node and serialize it\n        let valid_node = create_simple_node(&arena, id, \"test\");\n        let valid_bytes = bincode::serialize(&valid_node).unwrap();\n\n        // Truncate the bytes\n        let truncated = &valid_bytes[..valid_bytes.len() / 2];\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, truncated, &arena2);\n        assert!(result.is_err(), \"Should fail on truncated bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_garbage_bytes_53": {
      "name": "test_node_garbage_bytes",
      "type": "function",
      "start_line": 53,
      "end_line": 62,
      "content_hash": "4d9981fe11f4a7420cc211300d483528f046fda9",
      "content": "    fn test_node_garbage_bytes() {\n        let arena = Bump::new();\n        let id = 22222u128;\n        let garbage: Vec<u8> = vec![0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA];\n\n        let result = Node::from_bincode_bytes(id, &garbage, &arena);\n        assert!(result.is_err(), \"Should fail on garbage bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_corrupted_property_map_63": {
      "name": "test_node_corrupted_property_map",
      "type": "function",
      "start_line": 63,
      "end_line": 85,
      "content_hash": "a753d97dcaf9594a7ad73a9b98c0202ff661e798",
      "content": "    fn test_node_corrupted_property_map() {\n        let arena = Bump::new();\n        let id = 33333u128;\n\n        // Create a node with properties\n        let props = vec![(\"key\", Value::String(\"value\".to_string()))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let mut bytes = bincode::serialize(&node).unwrap();\n\n        // Corrupt the middle of the bytes (likely the property map)\n        let len = bytes.len();\n        if bytes.len() > 10 {\n            bytes[len / 2] = 0xFF;\n            bytes[len / 2 + 1] = 0xFF;\n        }\n\n        let arena2 = Bump::new();\n        let _result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        // May or may not fail depending on where corruption occurs\n        // This test documents behavior\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_single_byte_86": {
      "name": "test_node_single_byte",
      "type": "function",
      "start_line": 86,
      "end_line": 95,
      "content_hash": "35dbfd31a3968eb82a99f823debab2d2aef69efe",
      "content": "    fn test_node_single_byte() {\n        let arena = Bump::new();\n        let id = 44444u128;\n        let single_byte: &[u8] = &[0x01];\n\n        let result = Node::from_bincode_bytes(id, single_byte, &arena);\n        assert!(result.is_err(), \"Should fail on single byte\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_all_zeros_96": {
      "name": "test_node_all_zeros",
      "type": "function",
      "start_line": 96,
      "end_line": 106,
      "content_hash": "c1e1a16ee0d23661032f4a0946954133d0e5bd2f",
      "content": "    fn test_node_all_zeros() {\n        let arena = Bump::new();\n        let id = 55555u128;\n        let zeros = vec![0u8; 100];\n\n        let _result = Node::from_bincode_bytes(id, &zeros, &arena);\n        // This might actually deserialize to some default values\n        // Test documents behavior\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_all_ones_107": {
      "name": "test_node_all_ones",
      "type": "function",
      "start_line": 107,
      "end_line": 120,
      "content_hash": "20cb4a38b186d4d8839e5bcea81fb111ea08fc78",
      "content": "    fn test_node_all_ones() {\n        let arena = Bump::new();\n        let id = 66666u128;\n        let ones = vec![0xFFu8; 100];\n\n        let result = Node::from_bincode_bytes(id, &ones, &arena);\n        assert!(result.is_err(), \"Should likely fail on all 0xFF bytes\");\n    }\n\n    // ========================================================================\n    // MALFORMED BINCODE DATA TESTS - EDGES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_empty_bytes_121": {
      "name": "test_edge_empty_bytes",
      "type": "function",
      "start_line": 121,
      "end_line": 130,
      "content_hash": "f8cb68a8f3a555ca83b8c4cd37e67dc4a0520eac",
      "content": "    fn test_edge_empty_bytes() {\n        let arena = Bump::new();\n        let id = 77777u128;\n        let empty_bytes: &[u8] = &[];\n\n        let result = Edge::from_bincode_bytes(id, empty_bytes, &arena);\n        assert!(result.is_err(), \"Should fail on empty bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_truncated_bytes_131": {
      "name": "test_edge_truncated_bytes",
      "type": "function",
      "start_line": 131,
      "end_line": 145,
      "content_hash": "5bdc78ecc04c4b0bab7bde84512492be76a0d476",
      "content": "    fn test_edge_truncated_bytes() {\n        let arena = Bump::new();\n        let id = 88888u128;\n\n        let valid_edge = create_simple_edge(&arena, id, \"test\", 1, 2);\n        let valid_bytes = bincode::serialize(&valid_edge).unwrap();\n\n        let truncated = &valid_bytes[..valid_bytes.len() / 2];\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, truncated, &arena2);\n        assert!(result.is_err(), \"Should fail on truncated bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_garbage_bytes_146": {
      "name": "test_edge_garbage_bytes",
      "type": "function",
      "start_line": 146,
      "end_line": 155,
      "content_hash": "46b2a700c3058e519aecc0311706f3d174cd9d68",
      "content": "    fn test_edge_garbage_bytes() {\n        let arena = Bump::new();\n        let id = 99999u128;\n        let garbage: Vec<u8> = vec![0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE];\n\n        let result = Edge::from_bincode_bytes(id, &garbage, &arena);\n        assert!(result.is_err(), \"Should fail on garbage bytes\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_corrupted_node_ids_156": {
      "name": "test_edge_corrupted_node_ids",
      "type": "function",
      "start_line": 156,
      "end_line": 175,
      "content_hash": "f435e0febaa1595f1ee8773205edc7e4ac13c9ce",
      "content": "    fn test_edge_corrupted_node_ids() {\n        let arena = Bump::new();\n        let id = 111222u128;\n\n        let edge = create_simple_edge(&arena, id, \"test\", 1, 2);\n        let mut bytes = bincode::serialize(&edge).unwrap();\n\n        // Corrupt bytes that might be the node IDs\n        if bytes.len() > 20 {\n            for i in 10..20 {\n                bytes[i] = 0xFF;\n            }\n        }\n\n        let arena2 = Bump::new();\n        let _result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        // Might succeed with corrupted IDs - test documents behavior\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_single_byte_176": {
      "name": "test_edge_single_byte",
      "type": "function",
      "start_line": 176,
      "end_line": 185,
      "content_hash": "14ca54dc835e87c7eff47ffcaa0f5d4bdbe48f8c",
      "content": "    fn test_edge_single_byte() {\n        let arena = Bump::new();\n        let id = 222333u128;\n        let single_byte: &[u8] = &[0x42];\n\n        let result = Edge::from_bincode_bytes(id, single_byte, &arena);\n        assert!(result.is_err(), \"Should fail on single byte\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_all_zeros_186": {
      "name": "test_edge_all_zeros",
      "type": "function",
      "start_line": 186,
      "end_line": 199,
      "content_hash": "0679ebc2e44e2c511f4bb84d42a3c5136cee68d4",
      "content": "    fn test_edge_all_zeros() {\n        let arena = Bump::new();\n        let id = 333444u128;\n        let zeros = vec![0u8; 100];\n\n        let _result = Edge::from_bincode_bytes(id, &zeros, &arena);\n        // May deserialize with zero values - test documents behavior\n    }\n\n    // ========================================================================\n    // MALFORMED BINCODE DATA TESTS - VECTORS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_empty_props_bytes_200": {
      "name": "test_vector_empty_props_bytes",
      "type": "function",
      "start_line": 200,
      "end_line": 212,
      "content_hash": "1041a36c238f2bd4bdaa9ce0b897206b6871cf93",
      "content": "    fn test_vector_empty_props_bytes() {\n        let arena = Bump::new();\n        let id = 444555u128;\n        let empty_bytes: &[u8] = &[];\n        let valid_data = vec![1.0, 2.0, 3.0];\n        let data_bytes = create_vector_bytes(&valid_data);\n\n        let result = HVector::from_bincode_bytes(&arena, Some(empty_bytes), &data_bytes, id);\n        assert!(result.is_err(), \"Should fail on empty property bytes\");\n    }\n\n    #[test]\n    #[should_panic]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_empty_data_bytes_213": {
      "name": "test_vector_empty_data_bytes",
      "type": "function",
      "start_line": 213,
      "end_line": 226,
      "content_hash": "5a790aacef2414b2c316348e52cbb7be756de8d5",
      "content": "    fn test_vector_empty_data_bytes() {\n        let arena = Bump::new();\n        let id = 555666u128;\n        let vector = create_simple_vector(&arena, id, \"test\", &[1.0, 2.0]);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let empty_data: &[u8] = &[];\n\n        let arena2 = Bump::new();\n        let _result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), empty_data, id);\n        // Should panic due to assertion in cast_raw_vector_data\n    }\n\n    #[test]\n    #[should_panic(expected = \"raw_vector_data.len() == 0\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_cast_empty_raw_data_panics_227": {
      "name": "test_vector_cast_empty_raw_data_panics",
      "type": "function",
      "start_line": 227,
      "end_line": 233,
      "content_hash": "721b254acc1c7a754030f65019f8e683c30c8ef6",
      "content": "    fn test_vector_cast_empty_raw_data_panics() {\n        let arena = Bump::new();\n        let empty_data: &[u8] = &[];\n        HVector::cast_raw_vector_data(&arena, empty_data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_truncated_props_234": {
      "name": "test_vector_truncated_props",
      "type": "function",
      "start_line": 234,
      "end_line": 249,
      "content_hash": "3b2c923a2c8959f3d333ce1fa6da3bdd59592f90",
      "content": "    fn test_vector_truncated_props() {\n        let arena = Bump::new();\n        let id = 666777u128;\n        let props = vec![(\"key\", Value::String(\"value\".to_string()))];\n        let vector = create_arena_vector(&arena, id, \"test\", 1, false, 0, &[1.0], props);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let truncated_props = &props_bytes[..props_bytes.len() / 2];\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(truncated_props), data_bytes, id);\n        assert!(result.is_err(), \"Should fail on truncated properties\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_garbage_props_250": {
      "name": "test_vector_garbage_props",
      "type": "function",
      "start_line": 250,
      "end_line": 261,
      "content_hash": "4281665cf4fb5b92c36098df90038902e2b52376",
      "content": "    fn test_vector_garbage_props() {\n        let arena = Bump::new();\n        let id = 777888u128;\n        let garbage: Vec<u8> = vec![0xFF; 50];\n        let data_bytes = create_vector_bytes(&[1.0, 2.0, 3.0]);\n\n        let result = HVector::from_bincode_bytes(&arena, Some(&garbage), &data_bytes, id);\n        assert!(result.is_err(), \"Should fail on garbage property bytes\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"is not a multiple of size_of::<f64>()\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_misaligned_data_bytes_panics_262": {
      "name": "test_vector_misaligned_data_bytes_panics",
      "type": "function",
      "start_line": 262,
      "end_line": 269,
      "content_hash": "0f220efbbbc50393d65151f5b4537efc3c4df6dd",
      "content": "    fn test_vector_misaligned_data_bytes_panics() {\n        let arena = Bump::new();\n        // 7 bytes is not a multiple of 8 (size of f64)\n        let misaligned: &[u8] = &[0, 1, 2, 3, 4, 5, 6];\n        HVector::cast_raw_vector_data(&arena, misaligned);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_single_byte_data_270": {
      "name": "test_vector_single_byte_data",
      "type": "function",
      "start_line": 270,
      "end_line": 285,
      "content_hash": "502f46356d04960218b5ac83863be0350a1fc796",
      "content": "    fn test_vector_single_byte_data() {\n        let arena = Bump::new();\n        let id = 888999u128;\n        let vector = create_simple_vector(&arena, id, \"test\", &[1.0]);\n        let _props_bytes = bincode::serialize(&vector).unwrap();\n        let _single_byte: &[u8] = &[0x42];\n\n        let _arena2 = Bump::new();\n        // Should panic due to misalignment\n    }\n\n    // ========================================================================\n    // PROPERTY MAP CORRUPTION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_property_count_mismatch_286": {
      "name": "test_node_property_count_mismatch",
      "type": "function",
      "start_line": 286,
      "end_line": 306,
      "content_hash": "5025d69e505de2ca6425b6e349d455eafe495bd4",
      "content": "    fn test_node_property_count_mismatch() {\n        let arena = Bump::new();\n        let id = 123123u128;\n\n        // This tests if property count in serialized data doesn't match actual properties\n        let props = vec![(\"key1\", Value::I32(1)), (\"key2\", Value::I32(2))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let mut bytes = bincode::serialize(&node).unwrap();\n\n        // Try to corrupt the property count (depends on bincode format)\n        // This is exploratory testing\n        if bytes.len() > 5 {\n            bytes[2] = 99; // Try to change count\n        }\n\n        let arena2 = Bump::new();\n        let _result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        // Behavior depends on exact corruption\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_property_key_corruption_307": {
      "name": "test_edge_property_key_corruption",
      "type": "function",
      "start_line": 307,
      "end_line": 330,
      "content_hash": "c550dc93338685298e4307c2a7aef9f605c18cd6",
      "content": "    fn test_edge_property_key_corruption() {\n        let arena = Bump::new();\n        let id = 234234u128;\n\n        let props = vec![(\"valid_key\", Value::String(\"valid_value\".to_string()))];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let mut bytes = bincode::serialize(&edge).unwrap();\n\n        // Corrupt part of the property key\n        if bytes.len() > 30 {\n            bytes[25] = 0xFF;\n            bytes[26] = 0xFF;\n        }\n\n        let arena2 = Bump::new();\n        let _result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        // May fail on UTF-8 validation\n    }\n\n    // ========================================================================\n    // INVALID UTF-8 TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_invalid_utf8_in_label_331": {
      "name": "test_node_invalid_utf8_in_label",
      "type": "function",
      "start_line": 331,
      "end_line": 352,
      "content_hash": "76c0442000b1265b7a3a4e5aab4f0593cfb6ffe0",
      "content": "    fn test_node_invalid_utf8_in_label() {\n        let arena = Bump::new();\n        let id = 345345u128;\n\n        // Create bytes that represent invalid UTF-8\n        // Start with valid serialized node\n        let node = create_simple_node(&arena, id, \"test\");\n        let mut bytes = bincode::serialize(&node).unwrap();\n\n        // Insert invalid UTF-8 sequence\n        // 0xC0 0x80 is an invalid UTF-8 sequence (overlong encoding)\n        if bytes.len() > 10 {\n            bytes[8] = 0xC0;\n            bytes[9] = 0x80;\n        }\n\n        let arena2 = Bump::new();\n        let _result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        // Should fail on UTF-8 validation\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_invalid_utf8_in_label_353": {
      "name": "test_edge_invalid_utf8_in_label",
      "type": "function",
      "start_line": 353,
      "end_line": 371,
      "content_hash": "0ece19696a92b11825a9550dbe8eb2c6cb3c9b89",
      "content": "    fn test_edge_invalid_utf8_in_label() {\n        let arena = Bump::new();\n        let id = 456456u128;\n\n        let edge = create_simple_edge(&arena, id, \"test\", 1, 2);\n        let mut bytes = bincode::serialize(&edge).unwrap();\n\n        // Insert invalid UTF-8\n        if bytes.len() > 10 {\n            bytes[8] = 0xFF;\n            bytes[9] = 0xFE;\n        }\n\n        let arena2 = Bump::new();\n        let _result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        // Should fail on UTF-8 validation\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_invalid_utf8_in_label_372": {
      "name": "test_vector_invalid_utf8_in_label",
      "type": "function",
      "start_line": 372,
      "end_line": 391,
      "content_hash": "db4ef8128d7f69386e3f65479389d0a0ec2d6f0d",
      "content": "    fn test_vector_invalid_utf8_in_label() {\n        let arena = Bump::new();\n        let id = 567567u128;\n\n        let vector = create_simple_vector(&arena, id, \"test\", &[1.0, 2.0]);\n        let mut props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Corrupt label bytes\n        if props_bytes.len() > 10 {\n            props_bytes[8] = 0x80;\n            props_bytes[9] = 0x81;\n        }\n\n        let arena2 = Bump::new();\n        let _result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        // Should fail on UTF-8 validation\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_invalid_utf8_in_property_key_392": {
      "name": "test_node_invalid_utf8_in_property_key",
      "type": "function",
      "start_line": 392,
      "end_line": 411,
      "content_hash": "2eb24b41dfe3cd8800d9501ba937354a2c4f1bee",
      "content": "    fn test_node_invalid_utf8_in_property_key() {\n        let arena = Bump::new();\n        let id = 678678u128;\n\n        let props = vec![(\"key\", Value::String(\"value\".to_string()))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let mut bytes = bincode::serialize(&node).unwrap();\n\n        // Try to corrupt property key UTF-8\n        if bytes.len() > 30 {\n            bytes[28] = 0xC0;\n            bytes[29] = 0xC0;\n        }\n\n        let arena2 = Bump::new();\n        let _result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        // May fail on UTF-8 validation\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_invalid_utf8_in_property_value_412": {
      "name": "test_edge_invalid_utf8_in_property_value",
      "type": "function",
      "start_line": 412,
      "end_line": 436,
      "content_hash": "b8e1b781007041039256a2d7477aef7642ac673a",
      "content": "    fn test_edge_invalid_utf8_in_property_value() {\n        let arena = Bump::new();\n        let id = 789789u128;\n\n        let props = vec![(\"key\", Value::String(\"value\".to_string()))];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let mut bytes = bincode::serialize(&edge).unwrap();\n\n        // Corrupt string value UTF-8\n        if bytes.len() > 40 {\n            bytes[38] = 0xED;\n            bytes[39] = 0xA0;\n            bytes[40] = 0x80; // Invalid UTF-8 surrogate\n        }\n\n        let arena2 = Bump::new();\n        let _result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        // May fail during property deserialization\n    }\n\n    // ========================================================================\n    // VERSION FIELD TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_extreme_version_value_437": {
      "name": "test_node_extreme_version_value",
      "type": "function",
      "start_line": 437,
      "end_line": 451,
      "content_hash": "9e6067fbcf0579f16e0b2144e3545c4ed3759cf6",
      "content": "    fn test_node_extreme_version_value() {\n        let arena = Bump::new();\n        let id = 890890u128;\n\n        // u8::MAX version\n        let node = create_arena_node(&arena, id, \"test\", 255, vec![]);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle u8::MAX version\");\n        assert_eq!(result.unwrap().version, 255);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_extreme_version_value_452": {
      "name": "test_edge_extreme_version_value",
      "type": "function",
      "start_line": 452,
      "end_line": 465,
      "content_hash": "182f807295a3b398e8e2ee8c3b247cb4eb66ef3c",
      "content": "    fn test_edge_extreme_version_value() {\n        let arena = Bump::new();\n        let id = 901901u128;\n\n        let edge = create_arena_edge(&arena, id, \"test\", 255, 1, 2, vec![]);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle u8::MAX version\");\n        assert_eq!(result.unwrap().version, 255);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_extreme_version_value_466": {
      "name": "test_vector_extreme_version_value",
      "type": "function",
      "start_line": 466,
      "end_line": 484,
      "content_hash": "5757ecade5c01ff23ef0890962f0b6d42f540e23",
      "content": "    fn test_vector_extreme_version_value() {\n        let arena = Bump::new();\n        let id = 012012u128;\n\n        let vector = create_arena_vector(&arena, id, \"test\", 255, false, 0, &[1.0], vec![]);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok(), \"Should handle u8::MAX version\");\n        assert_eq!(result.unwrap().version, 255);\n    }\n\n    // ========================================================================\n    // EXTREME ID VALUES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_zero_id_485": {
      "name": "test_node_zero_id",
      "type": "function",
      "start_line": 485,
      "end_line": 498,
      "content_hash": "04a586dd9587c4ec3d949de0c28819423ad460c8",
      "content": "    fn test_node_zero_id() {\n        let arena = Bump::new();\n        let id = 0u128;\n\n        let node = create_simple_node(&arena, id, \"test\");\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle zero ID\");\n        assert_eq!(result.unwrap().id, 0);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_max_id_499": {
      "name": "test_edge_max_id",
      "type": "function",
      "start_line": 499,
      "end_line": 512,
      "content_hash": "66b1dcadab71896077b748afffe61530b0b03249",
      "content": "    fn test_edge_max_id() {\n        let arena = Bump::new();\n        let id = u128::MAX;\n\n        let edge = create_simple_edge(&arena, id, \"test\", 1, 2);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle u128::MAX ID\");\n        assert_eq!(result.unwrap().id, u128::MAX);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_max_id_513": {
      "name": "test_vector_max_id",
      "type": "function",
      "start_line": 513,
      "end_line": 527,
      "content_hash": "e512e2375538dd19309e9b00bce4c07a7407bd75",
      "content": "    fn test_vector_max_id() {\n        let arena = Bump::new();\n        let id = u128::MAX;\n\n        let vector = create_simple_vector(&arena, id, \"test\", &[1.0, 2.0]);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(result.is_ok(), \"Should handle u128::MAX ID\");\n        assert_eq!(result.unwrap().id, u128::MAX);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_extreme_node_ids_528": {
      "name": "test_edge_extreme_node_ids",
      "type": "function",
      "start_line": 528,
      "end_line": 548,
      "content_hash": "a01adcf783a7ab7879a669acad6fb7fc8c22051f",
      "content": "    fn test_edge_extreme_node_ids() {\n        let arena = Bump::new();\n        let id = 123456u128;\n\n        // Edge with extreme from/to node IDs\n        let edge = create_simple_edge(&arena, id, \"test\", 0, u128::MAX);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle extreme node IDs\");\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.from_node, 0);\n        assert_eq!(deserialized.to_node, u128::MAX);\n    }\n\n    // ========================================================================\n    // SPECIAL NUMERIC VALUES IN PROPERTIES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_with_nan_property_549": {
      "name": "test_node_with_nan_property",
      "type": "function",
      "start_line": 549,
      "end_line": 562,
      "content_hash": "b1607b1247c409c8823db51f84a00fb2583a23f3",
      "content": "    fn test_node_with_nan_property() {\n        let arena = Bump::new();\n        let id = 246810u128;\n\n        let props = vec![(\"nan_val\", Value::F64(f64::NAN))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle NaN in properties\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_infinity_property_563": {
      "name": "test_edge_with_infinity_property",
      "type": "function",
      "start_line": 563,
      "end_line": 579,
      "content_hash": "77ded31b57868d11d24c0d622e1fe7a94b5da0f3",
      "content": "    fn test_edge_with_infinity_property() {\n        let arena = Bump::new();\n        let id = 135791u128;\n\n        let props = vec![\n            (\"pos_inf\", Value::F64(f64::INFINITY)),\n            (\"neg_inf\", Value::F64(f64::NEG_INFINITY)),\n        ];\n        let edge = create_arena_edge(&arena, id, \"test\", 0, 1, 2, props);\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Edge::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle infinity in properties\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_with_special_floats_580": {
      "name": "test_vector_data_with_special_floats",
      "type": "function",
      "start_line": 580,
      "end_line": 603,
      "content_hash": "cb08340718a40e6d0d2c222d80ce6f57f12ed7bb",
      "content": "    fn test_vector_data_with_special_floats() {\n        let arena = Bump::new();\n        let id = 987654u128;\n\n        // Vector with NaN, infinity, and other special values\n        let data = vec![f64::NAN, f64::INFINITY, f64::NEG_INFINITY, 0.0, -0.0];\n        let vector = create_simple_vector(&arena, id, \"special\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n        assert!(\n            result.is_ok(),\n            \"Should handle special float values in vector data\"\n        );\n    }\n\n    // ========================================================================\n    // BACKWARDS COMPATIBILITY ERROR SCENARIOS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_deserialize_future_version_604": {
      "name": "test_node_deserialize_future_version",
      "type": "function",
      "start_line": 604,
      "end_line": 619,
      "content_hash": "ab4db63206c444ec229d2e6bf2ef5486365aaa5a",
      "content": "    fn test_node_deserialize_future_version() {\n        let arena = Bump::new();\n        let id = 111222u128;\n\n        // Create a node with a \"future\" version\n        let node = create_arena_node(&arena, id, \"test\", 100, vec![]);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        // Should still deserialize - version is just a field\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().version, 100);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_empty_string_property_keys_620": {
      "name": "test_empty_string_property_keys",
      "type": "function",
      "start_line": 620,
      "end_line": 633,
      "content_hash": "5cbe50b21022606d1f982b0ad104b16f1bc07828",
      "content": "    fn test_empty_string_property_keys() {\n        let arena = Bump::new();\n        let id = 333444u128;\n\n        // Empty string as property key\n        let props = vec![(\"\", Value::String(\"value\".to_string()))];\n        let node = create_arena_node(&arena, id, \"test\", 0, props);\n        let bytes = bincode::serialize(&node).unwrap();\n\n        let arena2 = Bump::new();\n        let result = Node::from_bincode_bytes(id, &bytes, &arena2);\n        assert!(result.is_ok(), \"Should handle empty string property key\");\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}