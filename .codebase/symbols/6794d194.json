{
  "file_path": "/work/internal/oauth/token_test.go",
  "file_hash": "95d3951288792f4a176feca97bc329d2660ac445",
  "updated_at": "2025-12-26T17:34:22.171437",
  "symbols": {
    "function_TestTokenSetExpiresAt_8": {
      "name": "TestTokenSetExpiresAt",
      "type": "function",
      "start_line": 8,
      "end_line": 84,
      "content_hash": "8f711e8daf417b31a929b28d84a065b43f44eebe",
      "content": "func TestTokenSetExpiresAt(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\texpiresIn int\n\t\ttolerance time.Duration // Allow some tolerance for timing\n\t}{\n\t\t{\n\t\t\tname:      \"1 hour expiry\",\n\t\t\texpiresIn: 3600,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname:      \"1 minute expiry\",\n\t\t\texpiresIn: 60,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname:      \"1 day expiry\",\n\t\t\texpiresIn: 86400,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname:      \"zero expiry\",\n\t\t\texpiresIn: 0,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname:      \"very short expiry\",\n\t\t\texpiresIn: 1,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname:      \"30 days expiry\",\n\t\t\texpiresIn: 2592000,\n\t\t\ttolerance: 2 * time.Second,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttoken := &Token{\n\t\t\t\tAccessToken:  \"test-access-token\",\n\t\t\t\tRefreshToken: \"test-refresh-token\",\n\t\t\t\tExpiresIn:    tt.expiresIn,\n\t\t\t}\n\n\t\t\tbeforeSet := time.Now()\n\t\t\ttoken.SetExpiresAt()\n\t\t\tafterSet := time.Now()\n\n\t\t\t// Calculate expected expiry time range\n\t\t\texpectedMin := beforeSet.Add(time.Duration(tt.expiresIn) * time.Second).Unix()\n\t\t\texpectedMax := afterSet.Add(time.Duration(tt.expiresIn) * time.Second).Unix()\n\n\t\t\t// Verify ExpiresAt is set within the expected range\n\t\t\tif token.ExpiresAt < expectedMin || token.ExpiresAt > expectedMax {\n\t\t\t\tt.Errorf(\"SetExpiresAt() = %d, expected between %d and %d\",\n\t\t\t\t\ttoken.ExpiresAt, expectedMin, expectedMax)\n\t\t\t}\n\n\t\t\t// Verify it's approximately ExpiresIn seconds from now\n\t\t\tactualDuration := time.Unix(token.ExpiresAt, 0).Sub(beforeSet)\n\t\t\texpectedDuration := time.Duration(tt.expiresIn) * time.Second\n\n\t\t\tdiff := actualDuration - expectedDuration\n\t\t\tif diff < 0 {\n\t\t\t\tdiff = -diff\n\t\t\t}\n\n\t\t\tif diff > tt.tolerance {\n\t\t\t\tt.Errorf(\"SetExpiresAt() duration difference too large: got %v, expected ~%v (diff: %v)\",\n\t\t\t\t\tactualDuration, expectedDuration, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestTokenIsExpired_85": {
      "name": "TestTokenIsExpired",
      "type": "function",
      "start_line": 85,
      "end_line": 224,
      "content_hash": "500e23ea6e6b783e3fc3edb5b038006134cd7c43",
      "content": "func TestTokenIsExpired(t *testing.T) {\n\ttests := []struct {\n\t\tname            string\n\t\tsetupToken      func() *Token\n\t\texpectedExpired bool\n\t\tdescription     string\n\t}{\n\t\t{\n\t\t\tname: \"fresh token\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\ttoken := &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    3600, // 1 hour\n\t\t\t\t}\n\t\t\t\ttoken.SetExpiresAt()\n\t\t\t\treturn token\n\t\t\t},\n\t\t\texpectedExpired: false,\n\t\t\tdescription:     \"Token just created should not be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"expired token\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    3600,\n\t\t\t\t\tExpiresAt:    time.Now().Add(-1 * time.Hour).Unix(), // 1 hour ago\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token expired 1 hour ago should be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"token expiring in 5% of lifetime\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\texpiresIn := 3600 // 1 hour\n\t\t\t\t// Set to expire in 5% of lifetime (180 seconds)\n\t\t\t\t// IsExpired triggers at 10%, so this SHOULD be expired\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    expiresIn,\n\t\t\t\t\tExpiresAt:    time.Now().Add(180 * time.Second).Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token with 5% lifetime remaining should be expired (threshold is 10%)\",\n\t\t},\n\t\t{\n\t\t\tname: \"token at 10% threshold\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\texpiresIn := 3600 // 1 hour\n\t\t\t\t// Set to expire in exactly 10% of lifetime (360 seconds)\n\t\t\t\t// This is the threshold, so should be considered expired\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    expiresIn,\n\t\t\t\t\tExpiresAt:    time.Now().Add(360 * time.Second).Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token at exactly 10% threshold should be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"token with 15% lifetime remaining\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\texpiresIn := 3600 // 1 hour\n\t\t\t\t// Set to expire in 15% of lifetime (540 seconds)\n\t\t\t\t// Above 10% threshold, should NOT be expired\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    expiresIn,\n\t\t\t\t\tExpiresAt:    time.Now().Add(540 * time.Second).Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: false,\n\t\t\tdescription:     \"Token with 15% lifetime remaining should not be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"token just below 10% threshold\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\texpiresIn := 3600 // 1 hour\n\t\t\t\t// Set to expire in 9% of lifetime (324 seconds)\n\t\t\t\t// Should be considered expired\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    expiresIn,\n\t\t\t\t\tExpiresAt:    time.Now().Add(324 * time.Second).Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token with <10% lifetime should be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"token with zero expiresIn\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    0,\n\t\t\t\t\tExpiresAt:    time.Now().Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token with zero expiresIn should be expired\",\n\t\t},\n\t\t{\n\t\t\tname: \"token expired exactly now\",\n\t\t\tsetupToken: func() *Token {\n\t\t\t\treturn &Token{\n\t\t\t\t\tAccessToken:  \"test\",\n\t\t\t\t\tRefreshToken: \"test\",\n\t\t\t\t\tExpiresIn:    3600,\n\t\t\t\t\tExpiresAt:    time.Now().Unix(),\n\t\t\t\t}\n\t\t\t},\n\t\t\texpectedExpired: true,\n\t\t\tdescription:     \"Token expiring right now should be expired\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttoken := tt.setupToken()\n\t\t\tresult := token.IsExpired()\n\n\t\t\tif result != tt.expectedExpired {\n\t\t\t\tt.Errorf(\"IsExpired() = %v, want %v - %s (ExpiresIn: %d, ExpiresAt: %d, Now: %d)\",\n\t\t\t\t\tresult, tt.expectedExpired, tt.description,\n\t\t\t\t\ttoken.ExpiresIn, token.ExpiresAt, time.Now().Unix())\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestTokenLifecycle_225": {
      "name": "TestTokenLifecycle",
      "type": "function",
      "start_line": 225,
      "end_line": 248,
      "content_hash": "54b55a5b3a7d60437fd8be3496e1d865a7ccc670",
      "content": "func TestTokenLifecycle(t *testing.T) {\n\t// Test a full lifecycle: create, check not expired, wait, check expired\n\ttoken := &Token{\n\t\tAccessToken:  \"test-access\",\n\t\tRefreshToken: \"test-refresh\",\n\t\tExpiresIn:    1, // 1 second\n\t}\n\n\ttoken.SetExpiresAt()\n\n\t// Should not be expired immediately\n\tif token.IsExpired() {\n\t\tt.Error(\"Token should not be expired immediately after creation\")\n\t}\n\n\t// Wait for expiration (plus 10% buffer)\n\ttime.Sleep(1200 * time.Millisecond)\n\n\t// Should now be expired\n\tif !token.IsExpired() {\n\t\tt.Error(\"Token should be expired after waiting past expiry time\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestTokenFields_249": {
      "name": "TestTokenFields",
      "type": "function",
      "start_line": 249,
      "end_line": 279,
      "content_hash": "c37d371f743daf767b2248206f9a8ab9c5183c20",
      "content": "func TestTokenFields(t *testing.T) {\n\ttoken := &Token{\n\t\tAccessToken:  \"access-123\",\n\t\tRefreshToken: \"refresh-456\",\n\t\tExpiresIn:    7200,\n\t}\n\n\t// Verify fields are set correctly\n\tif token.AccessToken != \"access-123\" {\n\t\tt.Errorf(\"AccessToken = %q, want %q\", token.AccessToken, \"access-123\")\n\t}\n\tif token.RefreshToken != \"refresh-456\" {\n\t\tt.Errorf(\"RefreshToken = %q, want %q\", token.RefreshToken, \"refresh-456\")\n\t}\n\tif token.ExpiresIn != 7200 {\n\t\tt.Errorf(\"ExpiresIn = %d, want %d\", token.ExpiresIn, 7200)\n\t}\n\n\t// Before SetExpiresAt, ExpiresAt should be 0\n\tif token.ExpiresAt != 0 {\n\t\tt.Errorf(\"ExpiresAt should be 0 before SetExpiresAt(), got %d\", token.ExpiresAt)\n\t}\n\n\ttoken.SetExpiresAt()\n\n\t// After SetExpiresAt, ExpiresAt should be set\n\tif token.ExpiresAt == 0 {\n\t\tt.Error(\"ExpiresAt should be set after SetExpiresAt()\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestTokenExpiryCalculation_280": {
      "name": "TestTokenExpiryCalculation",
      "type": "function",
      "start_line": 280,
      "end_line": 303,
      "content_hash": "e389c666afef11acde3aca9a6257eae10baac444",
      "content": "func TestTokenExpiryCalculation(t *testing.T) {\n\t// Test the 10% buffer calculation\n\ttestCases := []struct {\n\t\texpiresIn      int\n\t\texpectedBuffer int64\n\t\tdescription    string\n\t}{\n\t\t{3600, 360, \"1 hour with 6 minute buffer\"},\n\t\t{60, 6, \"1 minute with 6 second buffer\"},\n\t\t{10, 1, \"10 seconds with 1 second buffer\"},\n\t\t{100, 10, \"100 seconds with 10 second buffer\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tbuffer := int64(tc.expiresIn) / 10\n\t\t\tif buffer != tc.expectedBuffer {\n\t\t\t\tt.Errorf(\"Buffer calculation: got %d, want %d\", buffer, tc.expectedBuffer)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// BenchmarkSetExpiresAt tests performance of SetExpiresAt",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkSetExpiresAt_304": {
      "name": "BenchmarkSetExpiresAt",
      "type": "function",
      "start_line": 304,
      "end_line": 317,
      "content_hash": "fb2654fa5bbf0fd836f03651ab62c11402005dd7",
      "content": "func BenchmarkSetExpiresAt(b *testing.B) {\n\ttoken := &Token{\n\t\tAccessToken:  \"test\",\n\t\tRefreshToken: \"test\",\n\t\tExpiresIn:    3600,\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttoken.SetExpiresAt()\n\t}\n}\n\n// BenchmarkIsExpired tests performance of IsExpired",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkIsExpired_318": {
      "name": "BenchmarkIsExpired",
      "type": "function",
      "start_line": 318,
      "end_line": 330,
      "content_hash": "03994babc54bd238cf6f95aca26377f9aadbf061",
      "content": "func BenchmarkIsExpired(b *testing.B) {\n\ttoken := &Token{\n\t\tAccessToken:  \"test\",\n\t\tRefreshToken: \"test\",\n\t\tExpiresIn:    3600,\n\t}\n\ttoken.SetExpiresAt()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttoken.IsExpired()\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}