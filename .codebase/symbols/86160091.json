{
  "file_path": "/work/context-engine/vscode-extension/context-engine-uploader/prompt_plus.js",
  "file_hash": "ebfb9d68956cd0a84d6bfbcd8ceb390eb102a8a0",
  "updated_at": "2025-12-26T17:34:22.044522",
  "symbols": {
    "function_createPromptPlusManager_1": {
      "name": "createPromptPlusManager",
      "type": "function",
      "start_line": 1,
      "end_line": 335,
      "content_hash": "b82386919822062e5f9b268858ab1f76deaedab2",
      "content": "function createPromptPlusManager(deps) {\n  const vscode = deps.vscode;\n  const spawn = deps.spawn;\n  const path = deps.path;\n  const fs = deps.fs;\n  const log = deps.log;\n\n  const extensionRoot = deps.extensionRoot;\n  const getEffectiveConfig = deps.getEffectiveConfig;\n  const getTargetPath = deps.getTargetPath;\n  const getWorkspaceFolderPath = deps.getWorkspaceFolderPath;\n  const detectDefaultTargetPath = deps.detectDefaultTargetPath;\n  const resolveBridgeHttpUrl = deps.resolveBridgeHttpUrl;\n  const getPythonOverridePath = deps.getPythonOverridePath;\n  const appendOutput = deps.appendOutput;\n\n  function dispose() {\n    // No timers/processes owned.\n  }\n\n  function getConfiguredPythonPath() {\n    try {\n      const cfg = getEffectiveConfig();\n      const configured = (cfg.get('pythonPath') || 'python3').trim();\n      const override = typeof getPythonOverridePath === 'function' ? getPythonOverridePath() : undefined;\n      if (override && fs.existsSync(override)) {\n        return override;\n      }\n      return configured || 'python3';\n    } catch (_) {\n      const override = typeof getPythonOverridePath === 'function' ? getPythonOverridePath() : undefined;\n      if (override && fs.existsSync(override)) {\n        return override;\n      }\n      return 'python3';\n    }\n  }\n\n  function getConfiguredDecoderUrl() {\n    try {\n      const cfg = getEffectiveConfig();\n      const configured = (cfg.get('decoderUrl') || '').trim();\n      return configured || 'http://localhost:8081';\n    } catch (_) {\n      return 'http://localhost:8081';\n    }\n  }\n\n  function resolveCtxScriptPath() {\n    const candidates = [];\n    candidates.push(path.join(extensionRoot, 'scripts', 'ctx.py'));\n    candidates.push(path.join(extensionRoot, 'ctx.py'));\n    const wsFolder = getWorkspaceFolderPath();\n    if (wsFolder) {\n      candidates.push(path.join(wsFolder, 'scripts', 'ctx.py'));\n      candidates.push(path.join(wsFolder, 'ctx.py'));\n    }\n    candidates.push(path.resolve(extensionRoot, '..', '..', 'scripts', 'ctx.py'));\n\n    for (const candidate of candidates) {\n      if (candidate && fs.existsSync(candidate)) {\n        return path.resolve(candidate);\n      }\n    }\n\n    vscode.window.showErrorMessage('Context Engine Uploader: ctx.py not found (expected scripts/ctx.py).');\n    return undefined;\n  }\n\n  function getActiveSelectionText() {\n    const editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      return { editor: undefined, selection: undefined, text: '' };\n    }\n    const selection = editor.selections && editor.selections.length ? editor.selections[0] : editor.selection;\n    const text = selection && !selection.isEmpty ? editor.document.getText(selection) : '';\n    return { editor, selection, text };\n  }\n\n  async function resolveInputTextFromUser(selectionText) {\n    const selectionTrimmed = (selectionText || '').trim();\n    if (selectionTrimmed) {\n      const picked = await vscode.window.showQuickPick(\n        [\n          { label: 'Use selection', id: 'selection' },\n          { label: 'Enter message', id: 'message' },\n          { label: 'Enter message + selection', id: 'message+selection' },\n        ],\n        { placeHolder: 'Prompt+ input source' }\n      );\n      if (!picked) {\n        return undefined;\n      }\n      if (picked.id === 'selection') {\n        return selectionText;\n      }\n      const message = await vscode.window.showInputBox({\n        prompt: 'Prompt+ message',\n        placeHolder: 'Type an instruction or question to enhance with Context Engine',\n        ignoreFocusOut: true,\n      });\n      const msgTrimmed = (message || '').trim();\n      if (!msgTrimmed) {\n        return undefined;\n      }\n      if (picked.id === 'message') {\n        return msgTrimmed;\n      }\n      return `${msgTrimmed}\\n\\n${selectionText}`;\n    }\n\n    const message = await vscode.window.showInputBox({\n      prompt: 'Prompt+ message',\n      placeHolder: 'Type an instruction or question to enhance with Context Engine',\n      ignoreFocusOut: true,\n    });\n    const msgTrimmed = (message || '').trim();\n    if (!msgTrimmed) {\n      return undefined;\n    }\n    return msgTrimmed;\n  }\n\n  function normalizePromptMode(raw) {\n    const v = (raw || '').trim().toLowerCase();\n    if (v === 'unicorn') {\n      return 'unicorn';\n    }\n    return 'default';\n  }\n\n  function readDefaultModeFromCtxConfig(ctxWorkspaceDir) {\n    try {\n      if (!ctxWorkspaceDir || typeof ctxWorkspaceDir !== 'string') {\n        return undefined;\n      }\n      const cfgPath = path.join(ctxWorkspaceDir, 'ctx_config.json');\n      if (!fs.existsSync(cfgPath)) {\n        return undefined;\n      }\n      const raw = fs.readFileSync(cfgPath, 'utf8');\n      const parsed = JSON.parse(raw);\n      if (!parsed || typeof parsed !== 'object') {\n        return undefined;\n      }\n      if (typeof parsed.default_mode === 'string') {\n        return normalizePromptMode(parsed.default_mode);\n      }\n      return undefined;\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  function runPrompt(text) {\n    const input = (text || '').trim();\n    if (!input) {\n      return Promise.resolve(undefined);\n    }\n    const ctxScript = resolveCtxScriptPath();\n    if (!ctxScript) {\n      return Promise.resolve(undefined);\n    }\n\n    const pythonPath = getConfiguredPythonPath();\n    const projectRoot = path.dirname(path.dirname(ctxScript));\n    const env = { ...process.env };\n    env.PYTHONUNBUFFERED = '1';\n    const decoderUrl = getConfiguredDecoderUrl();\n    if (decoderUrl) {\n      env.DECODER_URL = decoderUrl;\n    }\n\n    try {\n      const cfg = getEffectiveConfig();\n      const transportModeRaw = cfg.get('mcpTransportMode') || 'sse-remote';\n      const serverModeRaw = cfg.get('mcpServerMode') || 'bridge';\n      const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n      const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n      let idxUrlRaw = (cfg.get('ctxIndexerUrl') || cfg.get('mcpIndexerUrl') || '').trim();\n      if (serverMode === 'bridge' && transportMode === 'http') {\n        const bridgeUrl = resolveBridgeHttpUrl();\n        if (bridgeUrl) {\n          idxUrlRaw = bridgeUrl;\n        }\n      }\n      if (idxUrlRaw) {\n        env.MCP_INDEXER_URL = idxUrlRaw;\n      }\n    } catch (_) {\n    }\n\n    let ctxWorkspaceDir;\n    try {\n      const cfg = getEffectiveConfig();\n      const useGpuDecoder = cfg.get('useGpuDecoder', false);\n      if (useGpuDecoder) {\n        env.USE_GPU_DECODER = '1';\n      }\n      try {\n        ctxWorkspaceDir = getTargetPath(cfg);\n      } catch (error) {\n        ctxWorkspaceDir = undefined;\n      }\n      if (!ctxWorkspaceDir) {\n        const wsFolder = getWorkspaceFolderPath();\n        if (wsFolder) {\n          ctxWorkspaceDir = detectDefaultTargetPath(wsFolder);\n        }\n      }\n      if (ctxWorkspaceDir && typeof ctxWorkspaceDir === 'string' && fs.existsSync(ctxWorkspaceDir)) {\n        env.CTX_WORKSPACE_DIR = ctxWorkspaceDir;\n      }\n    } catch (_) {\n      ctxWorkspaceDir = undefined;\n    }\n\n    const existingPyPath = env.PYTHONPATH || '';\n    env.PYTHONPATH = existingPyPath ? `${projectRoot}${path.delimiter}${existingPyPath}` : projectRoot;\n\n    const configuredMode = readDefaultModeFromCtxConfig(ctxWorkspaceDir);\n    const modeUsed = configuredMode || 'default';\n\n    log(`Running Prompt+ via ctx.py at ${ctxScript} (mode=${modeUsed})`);\n\n    return new Promise((resolve) => {\n      const args = [ctxScript];\n      if (modeUsed === 'unicorn') {\n        args.push('--unicorn');\n      }\n      args.push(input);\n      const child = spawn(pythonPath, args, { cwd: projectRoot, env });\n      let stdout = '';\n      let stderr = '';\n\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data.toString();\n        });\n      }\n      if (child.stderr) {\n        child.stderr.on('data', data => {\n          const chunk = data.toString();\n          stderr += chunk;\n          try {\n            if (typeof appendOutput === 'function') {\n              appendOutput(`[prompt+] ${chunk}`);\n            }\n          } catch (_) {\n          }\n        });\n      }\n\n      child.on('error', error => {\n        log(`Prompt+ spawn failed: ${error instanceof Error ? error.message : String(error)}`);\n        vscode.window.showErrorMessage('Prompt+ failed to start. Check Python path.');\n        resolve(undefined);\n      });\n\n      child.on('close', code => {\n        if (code !== 0) {\n          log(`Prompt+ exited with code ${code}${stderr ? `: ${stderr.trim()}` : ''}`);\n          vscode.window.showErrorMessage('Prompt+ failed. See output for details.');\n          return resolve(undefined);\n        }\n        const enhanced = (stdout || '').trim();\n        if (!enhanced) {\n          vscode.window.showWarningMessage('Prompt+ returned no output.');\n          return resolve(undefined);\n        }\n        resolve({ enhanced, modeUsed });\n      });\n    });\n  }\n\n  async function enhanceSelectionWithUnicorn() {\n    const { editor, selection, text } = getActiveSelectionText();\n    if (!editor) {\n      vscode.window.showWarningMessage('Open a file and select text to enhance with Prompt+.');\n      return;\n    }\n    if (!selection || selection.isEmpty || !text || !text.trim()) {\n      vscode.window.showWarningMessage('Select text to enhance with Prompt+.');\n      return;\n    }\n    const result = await runPrompt(text);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const modeLabel = result.modeUsed === 'unicorn' ? 'Unicorn Mode' : 'Default Mode';\n    await editor.edit(editBuilder => editBuilder.replace(selection, result.enhanced)).then(ok => {\n      if (ok) {\n        vscode.window.showInformationMessage(`Prompt+ applied (${modeLabel}).`);\n      } else {\n        vscode.window.showErrorMessage('Prompt+ could not update the selection.');\n      }\n    });\n  }\n\n  async function enhancePromptWithUnicornCopy() {\n    const { text } = getActiveSelectionText();\n    const input = await resolveInputTextFromUser(text);\n    if (!input) {\n      return;\n    }\n    const result = await runPrompt(input);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const modeLabel = result.modeUsed === 'unicorn' ? 'Unicorn Mode' : 'Default Mode';\n    await vscode.env.clipboard.writeText(result.enhanced);\n    vscode.window.showInformationMessage(`Prompt+ copied to clipboard (${modeLabel}).`);\n  }\n\n  async function enhancePromptWithUnicornOpen() {\n    const { text } = getActiveSelectionText();\n    const input = await resolveInputTextFromUser(text);\n    if (!input) {\n      return;\n    }\n    const result = await runPrompt(input);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const doc = await vscode.workspace.openTextDocument({ content: result.enhanced, language: 'markdown' });\n    await vscode.window.showTextDocument(doc, { preview: true });\n  }\n\n  return {\n    enhanceSelectionWithUnicorn,\n    enhancePromptWithUnicornCopy,\n    enhancePromptWithUnicornOpen,\n    dispose,\n  };\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_dispose_17": {
      "name": "dispose",
      "type": "function",
      "start_line": 17,
      "end_line": 19,
      "content_hash": "e104c1742e925f80b1209b488acaf8f306e2f02e",
      "content": "  function dispose() {\n    // No timers/processes owned.\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getConfiguredPythonPath_21": {
      "name": "getConfiguredPythonPath",
      "type": "function",
      "start_line": 21,
      "end_line": 37,
      "content_hash": "0c131bccbfa47d84a97387eb2a86fca26d21b782",
      "content": "  function getConfiguredPythonPath() {\n    try {\n      const cfg = getEffectiveConfig();\n      const configured = (cfg.get('pythonPath') || 'python3').trim();\n      const override = typeof getPythonOverridePath === 'function' ? getPythonOverridePath() : undefined;\n      if (override && fs.existsSync(override)) {\n        return override;\n      }\n      return configured || 'python3';\n    } catch (_) {\n      const override = typeof getPythonOverridePath === 'function' ? getPythonOverridePath() : undefined;\n      if (override && fs.existsSync(override)) {\n        return override;\n      }\n      return 'python3';\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getConfiguredDecoderUrl_39": {
      "name": "getConfiguredDecoderUrl",
      "type": "function",
      "start_line": 39,
      "end_line": 47,
      "content_hash": "86743cd80f3aa0ed4e3217f679d6be4dffc87446",
      "content": "  function getConfiguredDecoderUrl() {\n    try {\n      const cfg = getEffectiveConfig();\n      const configured = (cfg.get('decoderUrl') || '').trim();\n      return configured || 'http://localhost:8081';\n    } catch (_) {\n      return 'http://localhost:8081';\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveCtxScriptPath_49": {
      "name": "resolveCtxScriptPath",
      "type": "function",
      "start_line": 49,
      "end_line": 68,
      "content_hash": "0ea36e309de78e2dcd18c6932c3c151fee9f4ee4",
      "content": "  function resolveCtxScriptPath() {\n    const candidates = [];\n    candidates.push(path.join(extensionRoot, 'scripts', 'ctx.py'));\n    candidates.push(path.join(extensionRoot, 'ctx.py'));\n    const wsFolder = getWorkspaceFolderPath();\n    if (wsFolder) {\n      candidates.push(path.join(wsFolder, 'scripts', 'ctx.py'));\n      candidates.push(path.join(wsFolder, 'ctx.py'));\n    }\n    candidates.push(path.resolve(extensionRoot, '..', '..', 'scripts', 'ctx.py'));\n\n    for (const candidate of candidates) {\n      if (candidate && fs.existsSync(candidate)) {\n        return path.resolve(candidate);\n      }\n    }\n\n    vscode.window.showErrorMessage('Context Engine Uploader: ctx.py not found (expected scripts/ctx.py).');\n    return undefined;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getActiveSelectionText_70": {
      "name": "getActiveSelectionText",
      "type": "function",
      "start_line": 70,
      "end_line": 78,
      "content_hash": "a88cda261c4262b4313ba768a3325503fd7b6488",
      "content": "  function getActiveSelectionText() {\n    const editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      return { editor: undefined, selection: undefined, text: '' };\n    }\n    const selection = editor.selections && editor.selections.length ? editor.selections[0] : editor.selection;\n    const text = selection && !selection.isEmpty ? editor.document.getText(selection) : '';\n    return { editor, selection, text };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_resolveInputTextFromUser_80": {
      "name": "resolveInputTextFromUser",
      "type": "function",
      "start_line": 80,
      "end_line": 122,
      "content_hash": "9fbb1f8f05aebff67f7a322cab34e6fd8835aef7",
      "content": "  async function resolveInputTextFromUser(selectionText) {\n    const selectionTrimmed = (selectionText || '').trim();\n    if (selectionTrimmed) {\n      const picked = await vscode.window.showQuickPick(\n        [\n          { label: 'Use selection', id: 'selection' },\n          { label: 'Enter message', id: 'message' },\n          { label: 'Enter message + selection', id: 'message+selection' },\n        ],\n        { placeHolder: 'Prompt+ input source' }\n      );\n      if (!picked) {\n        return undefined;\n      }\n      if (picked.id === 'selection') {\n        return selectionText;\n      }\n      const message = await vscode.window.showInputBox({\n        prompt: 'Prompt+ message',\n        placeHolder: 'Type an instruction or question to enhance with Context Engine',\n        ignoreFocusOut: true,\n      });\n      const msgTrimmed = (message || '').trim();\n      if (!msgTrimmed) {\n        return undefined;\n      }\n      if (picked.id === 'message') {\n        return msgTrimmed;\n      }\n      return `${msgTrimmed}\\n\\n${selectionText}`;\n    }\n\n    const message = await vscode.window.showInputBox({\n      prompt: 'Prompt+ message',\n      placeHolder: 'Type an instruction or question to enhance with Context Engine',\n      ignoreFocusOut: true,\n    });\n    const msgTrimmed = (message || '').trim();\n    if (!msgTrimmed) {\n      return undefined;\n    }\n    return msgTrimmed;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizePromptMode_124": {
      "name": "normalizePromptMode",
      "type": "function",
      "start_line": 124,
      "end_line": 130,
      "content_hash": "701a86298f191092ffafb0dd02337709e410564f",
      "content": "  function normalizePromptMode(raw) {\n    const v = (raw || '').trim().toLowerCase();\n    if (v === 'unicorn') {\n      return 'unicorn';\n    }\n    return 'default';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_readDefaultModeFromCtxConfig_132": {
      "name": "readDefaultModeFromCtxConfig",
      "type": "function",
      "start_line": 132,
      "end_line": 153,
      "content_hash": "2967de0852bbe579e4f4aee40a7987490fde9503",
      "content": "  function readDefaultModeFromCtxConfig(ctxWorkspaceDir) {\n    try {\n      if (!ctxWorkspaceDir || typeof ctxWorkspaceDir !== 'string') {\n        return undefined;\n      }\n      const cfgPath = path.join(ctxWorkspaceDir, 'ctx_config.json');\n      if (!fs.existsSync(cfgPath)) {\n        return undefined;\n      }\n      const raw = fs.readFileSync(cfgPath, 'utf8');\n      const parsed = JSON.parse(raw);\n      if (!parsed || typeof parsed !== 'object') {\n        return undefined;\n      }\n      if (typeof parsed.default_mode === 'string') {\n        return normalizePromptMode(parsed.default_mode);\n      }\n      return undefined;\n    } catch (_) {\n      return undefined;\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runPrompt_155": {
      "name": "runPrompt",
      "type": "function",
      "start_line": 155,
      "end_line": 274,
      "content_hash": "3cf884772c6ad3e1513e454c29577db8c2c57c6b",
      "content": "  function runPrompt(text) {\n    const input = (text || '').trim();\n    if (!input) {\n      return Promise.resolve(undefined);\n    }\n    const ctxScript = resolveCtxScriptPath();\n    if (!ctxScript) {\n      return Promise.resolve(undefined);\n    }\n\n    const pythonPath = getConfiguredPythonPath();\n    const projectRoot = path.dirname(path.dirname(ctxScript));\n    const env = { ...process.env };\n    env.PYTHONUNBUFFERED = '1';\n    const decoderUrl = getConfiguredDecoderUrl();\n    if (decoderUrl) {\n      env.DECODER_URL = decoderUrl;\n    }\n\n    try {\n      const cfg = getEffectiveConfig();\n      const transportModeRaw = cfg.get('mcpTransportMode') || 'sse-remote';\n      const serverModeRaw = cfg.get('mcpServerMode') || 'bridge';\n      const transportMode = (typeof transportModeRaw === 'string' ? transportModeRaw.trim() : 'sse-remote') || 'sse-remote';\n      const serverMode = (typeof serverModeRaw === 'string' ? serverModeRaw.trim() : 'bridge') || 'bridge';\n      let idxUrlRaw = (cfg.get('ctxIndexerUrl') || cfg.get('mcpIndexerUrl') || '').trim();\n      if (serverMode === 'bridge' && transportMode === 'http') {\n        const bridgeUrl = resolveBridgeHttpUrl();\n        if (bridgeUrl) {\n          idxUrlRaw = bridgeUrl;\n        }\n      }\n      if (idxUrlRaw) {\n        env.MCP_INDEXER_URL = idxUrlRaw;\n      }\n    } catch (_) {\n    }\n\n    let ctxWorkspaceDir;\n    try {\n      const cfg = getEffectiveConfig();\n      const useGpuDecoder = cfg.get('useGpuDecoder', false);\n      if (useGpuDecoder) {\n        env.USE_GPU_DECODER = '1';\n      }\n      try {\n        ctxWorkspaceDir = getTargetPath(cfg);\n      } catch (error) {\n        ctxWorkspaceDir = undefined;\n      }\n      if (!ctxWorkspaceDir) {\n        const wsFolder = getWorkspaceFolderPath();\n        if (wsFolder) {\n          ctxWorkspaceDir = detectDefaultTargetPath(wsFolder);\n        }\n      }\n      if (ctxWorkspaceDir && typeof ctxWorkspaceDir === 'string' && fs.existsSync(ctxWorkspaceDir)) {\n        env.CTX_WORKSPACE_DIR = ctxWorkspaceDir;\n      }\n    } catch (_) {\n      ctxWorkspaceDir = undefined;\n    }\n\n    const existingPyPath = env.PYTHONPATH || '';\n    env.PYTHONPATH = existingPyPath ? `${projectRoot}${path.delimiter}${existingPyPath}` : projectRoot;\n\n    const configuredMode = readDefaultModeFromCtxConfig(ctxWorkspaceDir);\n    const modeUsed = configuredMode || 'default';\n\n    log(`Running Prompt+ via ctx.py at ${ctxScript} (mode=${modeUsed})`);\n\n    return new Promise((resolve) => {\n      const args = [ctxScript];\n      if (modeUsed === 'unicorn') {\n        args.push('--unicorn');\n      }\n      args.push(input);\n      const child = spawn(pythonPath, args, { cwd: projectRoot, env });\n      let stdout = '';\n      let stderr = '';\n\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data.toString();\n        });\n      }\n      if (child.stderr) {\n        child.stderr.on('data', data => {\n          const chunk = data.toString();\n          stderr += chunk;\n          try {\n            if (typeof appendOutput === 'function') {\n              appendOutput(`[prompt+] ${chunk}`);\n            }\n          } catch (_) {\n          }\n        });\n      }\n\n      child.on('error', error => {\n        log(`Prompt+ spawn failed: ${error instanceof Error ? error.message : String(error)}`);\n        vscode.window.showErrorMessage('Prompt+ failed to start. Check Python path.');\n        resolve(undefined);\n      });\n\n      child.on('close', code => {\n        if (code !== 0) {\n          log(`Prompt+ exited with code ${code}${stderr ? `: ${stderr.trim()}` : ''}`);\n          vscode.window.showErrorMessage('Prompt+ failed. See output for details.');\n          return resolve(undefined);\n        }\n        const enhanced = (stdout || '').trim();\n        if (!enhanced) {\n          vscode.window.showWarningMessage('Prompt+ returned no output.');\n          return resolve(undefined);\n        }\n        resolve({ enhanced, modeUsed });\n      });\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_enhanceSelectionWithUnicorn_276": {
      "name": "enhanceSelectionWithUnicorn",
      "type": "function",
      "start_line": 276,
      "end_line": 298,
      "content_hash": "bf4c0fe3332a4a5e3a5d3e7cd08a202cc3799168",
      "content": "  async function enhanceSelectionWithUnicorn() {\n    const { editor, selection, text } = getActiveSelectionText();\n    if (!editor) {\n      vscode.window.showWarningMessage('Open a file and select text to enhance with Prompt+.');\n      return;\n    }\n    if (!selection || selection.isEmpty || !text || !text.trim()) {\n      vscode.window.showWarningMessage('Select text to enhance with Prompt+.');\n      return;\n    }\n    const result = await runPrompt(text);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const modeLabel = result.modeUsed === 'unicorn' ? 'Unicorn Mode' : 'Default Mode';\n    await editor.edit(editBuilder => editBuilder.replace(selection, result.enhanced)).then(ok => {\n      if (ok) {\n        vscode.window.showInformationMessage(`Prompt+ applied (${modeLabel}).`);\n      } else {\n        vscode.window.showErrorMessage('Prompt+ could not update the selection.');\n      }\n    });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_enhancePromptWithUnicornCopy_300": {
      "name": "enhancePromptWithUnicornCopy",
      "type": "function",
      "start_line": 300,
      "end_line": 313,
      "content_hash": "0e088cd77923c4fb2d5bcd695e44c8ba01e8eaeb",
      "content": "  async function enhancePromptWithUnicornCopy() {\n    const { text } = getActiveSelectionText();\n    const input = await resolveInputTextFromUser(text);\n    if (!input) {\n      return;\n    }\n    const result = await runPrompt(input);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const modeLabel = result.modeUsed === 'unicorn' ? 'Unicorn Mode' : 'Default Mode';\n    await vscode.env.clipboard.writeText(result.enhanced);\n    vscode.window.showInformationMessage(`Prompt+ copied to clipboard (${modeLabel}).`);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_enhancePromptWithUnicornOpen_315": {
      "name": "enhancePromptWithUnicornOpen",
      "type": "function",
      "start_line": 315,
      "end_line": 327,
      "content_hash": "95e0c3a8cb116ba257893a485bcff5411b88fe63",
      "content": "  async function enhancePromptWithUnicornOpen() {\n    const { text } = getActiveSelectionText();\n    const input = await resolveInputTextFromUser(text);\n    if (!input) {\n      return;\n    }\n    const result = await runPrompt(input);\n    if (!result || !result.enhanced) {\n      return;\n    }\n    const doc = await vscode.workspace.openTextDocument({ content: result.enhanced, language: 'markdown' });\n    await vscode.window.showTextDocument(doc, { preview: true });\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}