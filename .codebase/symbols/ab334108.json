{
  "file_path": "/work/.local/tools/modelscan/sdk/agent/agent.go",
  "file_hash": "529484def1a2568ed79cf398614d6c094a025d02",
  "updated_at": "2025-12-26T17:34:23.664825",
  "symbols": {
    "interface_Memory_10": {
      "name": "Memory",
      "type": "interface",
      "start_line": 10,
      "end_line": 26,
      "content_hash": "7aedd9497e6ba7c3f8ec53ce02362603f38e8317",
      "content": "type Memory interface {\n\t// Store stores a message in memory\n\tStore(ctx context.Context, message MemoryMessage) error\n\n\t// Retrieve retrieves relevant messages from memory\n\t// If query is empty, returns all messages up to limit\n\t// Returns messages in reverse chronological order (newest first)\n\tRetrieve(ctx context.Context, query string, limit int) ([]MemoryMessage, error)\n\n\t// Search searches for messages matching the pattern\n\tSearch(ctx context.Context, pattern string) ([]MemoryMessage, error)\n\n\t// Clear clears all memory\n\tClear(ctx context.Context) error\n}\n\n// MemoryMessage represents a message stored in memory",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MemoryMessage_27": {
      "name": "MemoryMessage",
      "type": "struct",
      "start_line": 27,
      "end_line": 35,
      "content_hash": "cba43879e0c62d75916ebe09f0944c9d6a330426",
      "content": "type MemoryMessage struct {\n\tID        string                 `json:\"id\"`        // Unique message ID\n\tRole      string                 `json:\"role\"`      // \"user\", \"assistant\", \"tool\"\n\tContent   string                 `json:\"content\"`   // Message content\n\tTimestamp int64                  `json:\"timestamp\"` // Unix timestamp in nanoseconds\n\tMetadata  map[string]interface{} `json:\"metadata,omitempty\"`\n}\n\n// Tool represents a tool that an agent can use",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_Tool_36": {
      "name": "Tool",
      "type": "interface",
      "start_line": 36,
      "end_line": 42,
      "content_hash": "e2cee391408e15619320d53081b3ac0fc2e17ab9",
      "content": "type Tool interface {\n\tName() string\n\tDescription() string\n\tExecute(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error)\n}\n\n// Planner represents a planning algorithm for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_Planner_43": {
      "name": "Planner",
      "type": "interface",
      "start_line": 43,
      "end_line": 48,
      "content_hash": "05a9f3cfbad4c75ea293c54ffc9e9847db3a631f",
      "content": "type Planner interface {\n\t// Plan generates a plan based on the current state and goal\n\tPlan(ctx context.Context, state State, goal string) (Plan, error)\n}\n\n// Plan represents a sequence of actions to take",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Plan_49": {
      "name": "Plan",
      "type": "struct",
      "start_line": 49,
      "end_line": 53,
      "content_hash": "b3e694926ccd59d85a75dac5dabb192e25a0f2bf",
      "content": "type Plan struct {\n\tSteps []PlanStep `json:\"steps\"`\n}\n\n// PlanStep represents a single step in a plan",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PlanStep_54": {
      "name": "PlanStep",
      "type": "struct",
      "start_line": 54,
      "end_line": 61,
      "content_hash": "bbca0da3e452ac011149dfcba24adbeb2c15f6ae",
      "content": "type PlanStep struct {\n\tType       string                 `json:\"type\"` // \"tool\", \"think\", \"wait\"\n\tToolName   string                 `json:\"tool_name,omitempty\"`\n\tParameters map[string]interface{} `json:\"parameters,omitempty\"`\n\tThought    string                 `json:\"thought,omitempty\"`\n}\n\n// State represents the current state of the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_State_62": {
      "name": "State",
      "type": "struct",
      "start_line": 62,
      "end_line": 74,
      "content_hash": "b4a8272f989e01ead25b6dab27ea7bcdbd65f93e",
      "content": "type State struct {\n\tMessages []MemoryMessage        `json:\"messages\"`\n\tTools    []Tool                 `json:\"tools\"`\n\tContext  map[string]interface{} `json:\"context\"`\n}\n\n// TokenCounter estimates the number of tokens in a text\ntype TokenCounter func(prompt string) int\n\n// CostEstimator estimates the cost of a request\ntype CostEstimator func(prompt string) float64\n\n// Agent represents an AI agent that can execute tasks using tools",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Agent_75": {
      "name": "Agent",
      "type": "struct",
      "start_line": 75,
      "end_line": 89,
      "content_hash": "57c81dd09038e540c1cb5bd376cd1a44f864d4e7",
      "content": "type Agent struct {\n\ttools        []Tool\n\tmemory       Memory\n\tplanner      Planner\n\tbudget       float64\n\tmaxIter      int\n\ttimeout      time.Duration\n\ttokenCounter TokenCounter\n\tcostEst      CostEstimator\n\tusage        TokenUsage\n\toptions      AgentOptions\n\tteamContext  *Team // Link to team for inter-agent communication\n}\n\n// TokenUsage tracks token consumption",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TokenUsage_90": {
      "name": "TokenUsage",
      "type": "struct",
      "start_line": 90,
      "end_line": 97,
      "content_hash": "7f0d448662bd8b483fb5482273d5c296c08edd3b",
      "content": "type TokenUsage struct {\n\tInputTokens   int\n\tOutputTokens  int\n\tTotalTokens   int\n\tEstimatedCost float64\n}\n\n// AgentOptions configures agent behavior",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_AgentOptions_98": {
      "name": "AgentOptions",
      "type": "struct",
      "start_line": 98,
      "end_line": 103,
      "content_hash": "585e8e14cf5c8f1eab77ad537b146e0836ab4214",
      "content": "type AgentOptions struct {\n\tEnableLoopDetection bool\n\tRetryOptions        RetryOptions\n}\n\n// RetryOptions defines retry behavior",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_RetryOptions_104": {
      "name": "RetryOptions",
      "type": "struct",
      "start_line": 104,
      "end_line": 109,
      "content_hash": "42ea4ddd88af1631c97a7eb318cf8cdf9af061e3",
      "content": "type RetryOptions struct {\n\tMaxRetries int\n\tBackoff    time.Duration\n}\n\n// Execute runs the agent with the given prompt",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Execute_110": {
      "name": "Execute",
      "type": "method",
      "start_line": 110,
      "end_line": 315,
      "content_hash": "967a2eb3d7a3254a1f79b436f83209b6d57e85fc",
      "content": "func (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n\t// Initialize usage tracking\n\ta.usage = TokenUsage{}\n\n\t// Check budget before starting\n\tif a.costEst != nil {\n\t\tcost := a.costEst(prompt)\n\t\ta.usage.EstimatedCost = cost\n\t\tif a.budget > 0 && cost > a.budget {\n\t\t\treturn \"\", fmt.Errorf(\"budget exceeded: estimated cost %.4f exceeds budget %.4f\", cost, a.budget)\n\t\t}\n\t}\n\n\t// Count tokens\n\tif a.tokenCounter != nil {\n\t\ta.usage.InputTokens = a.tokenCounter(prompt)\n\t\ta.usage.TotalTokens = a.usage.InputTokens\n\t}\n\n\t// Set timeout context\n\tif a.timeout > 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(ctx, a.timeout)\n\t\tdefer cancel()\n\t}\n\n\t// Create initial state\n\tstate := State{\n\t\tMessages: []MemoryMessage{\n\t\t\t{Role: \"user\", Content: prompt, Timestamp: time.Now().Unix()},\n\t\t},\n\t\tTools:   a.tools,\n\t\tContext: make(map[string]interface{}),\n\t}\n\n\t// Main execution loop\n\tvar result string\n\tvar lastErr error\n\titerations := 0\n\n\tfor iterations < a.maxIter {\n\t\titerations++\n\n\t\t// Check for context timeout/cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn \"\", fmt.Errorf(\"execution timeout: %v\", ctx.Err())\n\t\tdefault:\n\t\t}\n\n\t\tvar plan Plan\n\t\tvar err error\n\n\t\tif a.planner != nil {\n\t\t\tplan, err = a.planner.Plan(ctx, state, prompt)\n\t\t\tif err != nil {\n\t\t\t\tlastErr = err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\t// Simple plan: just execute first available tool\n\t\t\tif len(a.tools) > 0 {\n\t\t\t\tplan = Plan{\n\t\t\t\t\tSteps: []PlanStep{\n\t\t\t\t\t\t{Type: \"tool\", ToolName: a.tools[0].Name(), Parameters: map[string]interface{}{}},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No tools, just return a mock response\n\t\t\t\tresult = \"mock response\"\n\t\t\t\ta.usage.OutputTokens = 5\n\t\t\t\ta.usage.TotalTokens += a.usage.OutputTokens\n\t\t\t\treturn result, nil\n\t\t\t}\n\t\t}\n\n\t\t// Initialize needsMoreIterations per iteration\n\t\tneedsMoreIterations := false\n\n\t\t// Execute plan steps\n\t\tfor _, step := range plan.Steps {\n\t\t\tswitch step.Type {\n\t\t\tcase \"think\":\n\t\t\t\t// Just record the thought\n\t\t\t\tstate.Messages = append(state.Messages, MemoryMessage{\n\t\t\t\t\tRole: \"assistant\", Content: step.Thought, Timestamp: time.Now().Unix(),\n\t\t\t\t})\n\n\t\t\tcase \"tool\":\n\t\t\t\t// Mark that we executed a tool\n\t\t\t\t// Find the tool\n\t\t\t\tvar tool Tool\n\t\t\t\tfor _, t := range a.tools {\n\t\t\t\t\tif t.Name() == step.ToolName {\n\t\t\t\t\t\ttool = t\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif tool == nil {\n\t\t\t\t\tlastErr = fmt.Errorf(\"tool not found: %s\", step.ToolName)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Execute tool with retry logic\n\t\t\t\tvar toolResult map[string]interface{}\n\t\t\t\tvar toolErr error\n\n\t\t\t\tmaxRetries := 0\n\t\t\t\tbackoff := time.Duration(0)\n\t\t\t\tif a.options.RetryOptions.MaxRetries > 0 {\n\t\t\t\t\tmaxRetries = a.options.RetryOptions.MaxRetries\n\t\t\t\t\tbackoff = a.options.RetryOptions.Backoff\n\t\t\t\t}\n\n\t\t\t\tretryCount := 0\n\t\t\t\tfor retryCount <= maxRetries {\n\t\t\t\t\tretryCount++\n\n\t\t\t\t\t// Execute tool\n\t\t\t\t\ttoolCtx := ctx\n\t\t\t\t\t// Don't set tool-level timeout, just use the main context timeout\n\n\t\t\t\t\ttoolResult, toolErr = tool.Execute(toolCtx, step.Parameters)\n\t\t\t\t\tif toolErr == nil {\n\t\t\t\t\t\tbreak // Success\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this is a context timeout\n\t\t\t\t\tif ctx.Err() != nil {\n\t\t\t\t\t\ttoolErr = fmt.Errorf(\"timeout\")\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if it's a tool error that should be retried\n\t\t\t\t\tif _, isToolErr := toolErr.(*ToolError); isToolErr && retryCount <= maxRetries {\n\t\t\t\t\t\t// Wait for backoff\n\t\t\t\t\t\tif backoff > 0 {\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase <-time.After(backoff):\n\t\t\t\t\t\t\t\t// Continue with retry\n\t\t\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\t\t\treturn \"\", fmt.Errorf(\"timeout during retry: %v\", ctx.Err())\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbackoff *= 2 // Exponential backoff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif toolErr != nil {\n\t\t\t\t\tlastErr = toolErr\n\t\t\t\t\tstate.Messages = append(state.Messages, MemoryMessage{\n\t\t\t\t\t\tRole: \"tool\", Content: fmt.Sprintf(\"Error: %v\", toolErr), Timestamp: time.Now().Unix(),\n\t\t\t\t\t})\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Record tool result\n\t\t\t\tresultStr := fmt.Sprintf(\"mock response with result from %s\", tool.Name())\n\n\t\t\t\t// Check if tool indicates more work is needed\n\t\t\t\tif toolResult != nil {\n\t\t\t\t\tif needsMore, ok := toolResult[\"needs_more\"].(bool); ok && needsMore {\n\t\t\t\t\t\tneedsMoreIterations = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.Messages = append(state.Messages, MemoryMessage{\n\t\t\t\t\tRole: \"tool\", Content: resultStr, Timestamp: time.Now().Unix(),\n\t\t\t\t})\n\n\t\t\t\t// Update token usage\n\t\t\t\tif a.tokenCounter != nil {\n\t\t\t\t\ttokens := a.tokenCounter(resultStr)\n\t\t\t\t\ta.usage.OutputTokens += tokens\n\t\t\t\t\ta.usage.TotalTokens += tokens\n\t\t\t\t}\n\n\t\t\t\tresult = resultStr\n\t\t\t}\n\t\t}\n\n\t\t// If we got a successful result, or completed all plan steps, break\n\t\tif result != \"\" && lastErr == nil && !needsMoreIterations {\n\t\t\t// If no tools were executed (e.g., only thinking), return a mock result\n\t\t\tif result == \"\" && a.planner != nil {\n\t\t\t\tresult = \"mock response after planning\"\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Check if we exceeded max iterations\n\tif iterations >= a.maxIter && lastErr == nil {\n\t\tlastErr = fmt.Errorf(\"max iterations exceeded\")\n\t}\n\n\tif lastErr != nil {\n\t\treturn \"\", lastErr\n\t}\n\n\treturn result, nil\n}\n\n// TokenUsage returns the current token usage statistics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_TokenUsage_316": {
      "name": "TokenUsage",
      "type": "method",
      "start_line": 316,
      "end_line": 320,
      "content_hash": "29fe087b28abbff2f211d0fb13f27304ba2af849",
      "content": "func (a *Agent) TokenUsage() TokenUsage {\n\treturn a.usage\n}\n\n// NewAgent creates a new agent with the given options",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewAgent_321": {
      "name": "NewAgent",
      "type": "function",
      "start_line": 321,
      "end_line": 341,
      "content_hash": "53844fc6717df75bd12b50a9b5d3b28b001abf4d",
      "content": "func NewAgent(opts ...AgentOption) *Agent {\n\ta := &Agent{\n\t\tbudget:  1.0,\n\t\tmaxIter: 10,\n\t\ttimeout: 0, // No timeout by default\n\t\toptions: AgentOptions{\n\t\t\tEnableLoopDetection: true,\n\t\t},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a)\n\t}\n\n\treturn a\n}\n\n// AgentOption configures an agent\ntype AgentOption func(*Agent)\n\n// WithTools sets the available tools for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithTools_342": {
      "name": "WithTools",
      "type": "function",
      "start_line": 342,
      "end_line": 348,
      "content_hash": "569c052f0c1a8bb72b79de50df8e3509dc44b1ef",
      "content": "func WithTools(tools ...Tool) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.tools = tools\n\t}\n}\n\n// WithMemory sets the memory system for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithMemory_349": {
      "name": "WithMemory",
      "type": "function",
      "start_line": 349,
      "end_line": 355,
      "content_hash": "0d4ad1f5b6fb9a8df2be722861ca3162e0d871eb",
      "content": "func WithMemory(mem Memory) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.memory = mem\n\t}\n}\n\n// WithPlanner sets the planning algorithm for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithPlanner_356": {
      "name": "WithPlanner",
      "type": "function",
      "start_line": 356,
      "end_line": 362,
      "content_hash": "075fafab75e4760cee5358bc5daafa7d71fd17c4",
      "content": "func WithPlanner(planner Planner) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.planner = planner\n\t}\n}\n\n// WithBudget sets the maximum budget for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithBudget_363": {
      "name": "WithBudget",
      "type": "function",
      "start_line": 363,
      "end_line": 369,
      "content_hash": "7d8944952abae59b7c8bf4613726794942492adf",
      "content": "func WithBudget(budget float64) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.budget = budget\n\t}\n}\n\n// WithMaxIterations sets the maximum number of iterations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithMaxIterations_370": {
      "name": "WithMaxIterations",
      "type": "function",
      "start_line": 370,
      "end_line": 376,
      "content_hash": "39141419eba2ec01611f5d42cf4d2475666c8374",
      "content": "func WithMaxIterations(maxIter int) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.maxIter = maxIter\n\t}\n}\n\n// WithTimeout sets the overall timeout for agent execution",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithTimeout_377": {
      "name": "WithTimeout",
      "type": "function",
      "start_line": 377,
      "end_line": 383,
      "content_hash": "485aab289db4a37302fede35541c42a021e785ba",
      "content": "func WithTimeout(timeout time.Duration) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.timeout = timeout\n\t}\n}\n\n// WithTokenCounter sets the token counting function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithTokenCounter_384": {
      "name": "WithTokenCounter",
      "type": "function",
      "start_line": 384,
      "end_line": 390,
      "content_hash": "4c55f0e30ce8e135154f41d0e6162a527d6ecfe0",
      "content": "func WithTokenCounter(counter TokenCounter) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.tokenCounter = counter\n\t}\n}\n\n// WithCostEstimator sets the cost estimation function",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithCostEstimator_391": {
      "name": "WithCostEstimator",
      "type": "function",
      "start_line": 391,
      "end_line": 397,
      "content_hash": "10aa60ffa9d97e7a8bb21bf0094c415bdd37d2a9",
      "content": "func WithCostEstimator(estimator CostEstimator) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.costEst = estimator\n\t}\n}\n\n// WithRetryOptions configures retry behavior",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithRetryOptions_398": {
      "name": "WithRetryOptions",
      "type": "function",
      "start_line": 398,
      "end_line": 404,
      "content_hash": "6ee96b2b573ce93ce334b36ba921a274ded1e79e",
      "content": "func WithRetryOptions(options RetryOptions) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.options.RetryOptions = options\n\t}\n}\n\n// WithInfiniteLoopDetection enables or disables infinite loop detection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithInfiniteLoopDetection_405": {
      "name": "WithInfiniteLoopDetection",
      "type": "function",
      "start_line": 405,
      "end_line": 411,
      "content_hash": "714267f5dde3484f07e87d50702d290e6ec0ba30",
      "content": "func WithInfiniteLoopDetection(enabled bool) AgentOption {\n\treturn func(a *Agent) {\n\t\ta.options.EnableLoopDetection = enabled\n\t}\n}\n\n// SetTeamContext sets the team context for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetTeamContext_412": {
      "name": "SetTeamContext",
      "type": "method",
      "start_line": 412,
      "end_line": 416,
      "content_hash": "e005a3421a9410823063af0fa28586174ba9f6a7",
      "content": "func (a *Agent) SetTeamContext(team *Team) {\n\ta.teamContext = team\n}\n\n// GetTeamContext returns the team context for the agent",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetTeamContext_417": {
      "name": "GetTeamContext",
      "type": "method",
      "start_line": 417,
      "end_line": 421,
      "content_hash": "f4b72668ea3bfc506e37b4423a39a701eeecd830",
      "content": "func (a *Agent) GetTeamContext() *Team {\n\treturn a.teamContext\n}\n\n// SendMessageToAgent sends a message to another agent in the team",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SendMessageToAgent_422": {
      "name": "SendMessageToAgent",
      "type": "method",
      "start_line": 422,
      "end_line": 435,
      "content_hash": "d46f01eb81839816388158356c8d12a40e847c6c",
      "content": "func (a *Agent) SendMessageToAgent(ctx context.Context, toAgentID, content string, msgType MessageType) error {\n\tif a.teamContext == nil {\n\t\treturn fmt.Errorf(\"agent is not part of any team\")\n\t}\n\n\tif a.teamContext.messageBus == nil {\n\t\treturn fmt.Errorf(\"team message bus is not initialized\")\n\t}\n\n\tmsg := NewTeamMessage(msgType, a.getID(), toAgentID, content)\n\treturn a.teamContext.messageBus.Send(ctx, msg)\n}\n\n// BroadcastMessage sends a message to all agents in the team",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_BroadcastMessage_436": {
      "name": "BroadcastMessage",
      "type": "method",
      "start_line": 436,
      "end_line": 450,
      "content_hash": "e1a0d893b07d451378909dbc82edf3166fb5fe58",
      "content": "func (a *Agent) BroadcastMessage(ctx context.Context, content string, msgType MessageType) error {\n\tif a.teamContext == nil {\n\t\treturn fmt.Errorf(\"agent is not part of any team\")\n\t}\n\n\tif a.teamContext.messageBus == nil {\n\t\treturn fmt.Errorf(\"team message bus is not initialized\")\n\t}\n\n\tmsg := NewTeamMessage(msgType, a.getID(), \"\", content)\n\treturn a.teamContext.messageBus.Broadcast(ctx, msg)\n}\n\n// getID returns the agent's ID (for now, use a simple approach)\n// In a real implementation, agents would have proper IDs",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getID_451": {
      "name": "getID",
      "type": "method",
      "start_line": 451,
      "end_line": 457,
      "content_hash": "3b02d2bd07ea4fe34de5a83b1d6ece55c21cd5b2",
      "content": "func (a *Agent) getID() string {\n\t// For now, use the agent's pointer as a simple ID\n\t// In production, agents should have proper unique IDs\n\treturn fmt.Sprintf(\"agent-%p\", a)\n}\n\n// CreateTask creates a task and submits it to the team coordinator",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CreateTask_458": {
      "name": "CreateTask",
      "type": "method",
      "start_line": 458,
      "end_line": 473,
      "content_hash": "eff5c11abcf7cb057faec4020ab57238277c64e6",
      "content": "func (a *Agent) CreateTask(ctx context.Context, description string, priority int) (*Task, error) {\n\tif a.teamContext == nil {\n\t\treturn nil, fmt.Errorf(\"agent is not part of any team\")\n\t}\n\n\tif a.teamContext.coordinator == nil {\n\t\treturn nil, fmt.Errorf(\"team coordinator is not initialized\")\n\t}\n\n\ttask := NewTask(description, priority)\n\ttask.CreatedBy = a.getID()\n\n\treturn task, a.teamContext.coordinator.SubmitTask(ctx, task)\n}\n\n// RequestHelp requests help from other team members for a specific task",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RequestHelp_474": {
      "name": "RequestHelp",
      "type": "method",
      "start_line": 474,
      "end_line": 486,
      "content_hash": "f867d31e901236601e48d1ebce1a4e62333009c7",
      "content": "func (a *Agent) RequestHelp(ctx context.Context, taskDescription string, requiredCapabilities []string) error {\n\tif a.teamContext == nil {\n\t\treturn fmt.Errorf(\"agent is not part of any team\")\n\t}\n\n\t// Create a help request message\n\tcontent := fmt.Sprintf(\"Help needed for task: %s (Required capabilities: %v)\", taskDescription, requiredCapabilities)\n\tmsg := NewTeamMessage(MessageTypeHandoff, a.getID(), \"\", content)\n\tmsg.AddData(\"task_description\", taskDescription)\n\tmsg.AddData(\"required_capabilities\", requiredCapabilities)\n\n\treturn a.BroadcastMessage(ctx, content, MessageTypeHandoff)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}