{
  "file_path": "/work/internal/indexer/cache.go",
  "file_hash": "d9c47c528fad6c389f02872be0707b422dd865d0",
  "updated_at": "2025-12-26T17:34:21.798693",
  "symbols": {
    "struct_CacheConfig_12": {
      "name": "CacheConfig",
      "type": "struct",
      "start_line": 12,
      "end_line": 19,
      "content_hash": "226bf1e64a0996a3e560d9d93af2642e4315a6cc",
      "content": "type CacheConfig struct {\n\tMaxSize       int           `json:\"max_size\"`       // Max number of items to cache\n\tTTL           time.Duration `json:\"ttl\"`            // Time to live for cache entries\n\tCleanupPeriod time.Duration `json:\"cleanup_period\"` // How often to clean expired entries\n\tEnableMetrics bool          `json:\"enable_metrics\"` // Whether to track cache metrics\n}\n\n// DefaultCacheConfig returns a sensible default configuration",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_DefaultCacheConfig_20": {
      "name": "DefaultCacheConfig",
      "type": "function",
      "start_line": 20,
      "end_line": 29,
      "content_hash": "f1f477b5da91dc4dc98df8a4407464f840ff5695",
      "content": "func DefaultCacheConfig() CacheConfig {\n\treturn CacheConfig{\n\t\tMaxSize:       10000,\n\t\tTTL:           10 * time.Minute,\n\t\tCleanupPeriod: 5 * time.Minute,\n\t\tEnableMetrics: true,\n\t}\n}\n\n// CacheEntry represents a cached item",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CacheEntry_30": {
      "name": "CacheEntry",
      "type": "struct",
      "start_line": 30,
      "end_line": 39,
      "content_hash": "8476ea354abe006c5ea9d26dbf706232d97e0ce6",
      "content": "type CacheEntry struct {\n\tKey       string    `json:\"key\"`\n\tValue     any       `json:\"value\"`\n\tCreated   time.Time `json:\"created\"`\n\tAccessed  time.Time `json:\"accessed\"`\n\tExpiresAt time.Time `json:\"expires_at\"`\n\tHitCount  int64     `json:\"hit_count\"`\n}\n\n// IsExpired checks if the cache entry has expired",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsExpired_40": {
      "name": "IsExpired",
      "type": "method",
      "start_line": 40,
      "end_line": 44,
      "content_hash": "6af6eb919892c46c8e0b206ecc94ec2e7b796837",
      "content": "func (ce *CacheEntry) IsExpired() bool {\n\treturn time.Now().After(ce.ExpiresAt)\n}\n\n// CacheMetrics tracks cache performance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CacheMetrics_45": {
      "name": "CacheMetrics",
      "type": "struct",
      "start_line": 45,
      "end_line": 55,
      "content_hash": "7b03ff77a7e28cb22145046a37487d7fb6fcd9ab",
      "content": "type CacheMetrics struct {\n\tHits      int64   `json:\"hits\"`\n\tMisses    int64   `json:\"misses\"`\n\tEvictions int64   `json:\"evictions\"`\n\tSize      int     `json:\"size\"`\n\tMaxSize   int     `json:\"max_size\"`\n\tHitRate   float64 `json:\"hit_rate\"`\n\tmu        sync.RWMutex\n}\n\n// recordHit records a cache hit",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_recordHit_56": {
      "name": "recordHit",
      "type": "method",
      "start_line": 56,
      "end_line": 63,
      "content_hash": "8f6496e01f0973934b0220ac78d5847a92f30074",
      "content": "func (cm *CacheMetrics) recordHit() {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tcm.Hits++\n\tcm.calculateHitRate()\n}\n\n// recordMiss records a cache miss",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_recordMiss_64": {
      "name": "recordMiss",
      "type": "method",
      "start_line": 64,
      "end_line": 71,
      "content_hash": "574db0dc071238a2982d2ea839912b5de20b3f91",
      "content": "func (cm *CacheMetrics) recordMiss() {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tcm.Misses++\n\tcm.calculateHitRate()\n}\n\n// recordEviction records a cache eviction",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_recordEviction_72": {
      "name": "recordEviction",
      "type": "method",
      "start_line": 72,
      "end_line": 78,
      "content_hash": "62923476af43151af681571f92a4495f25981e41",
      "content": "func (cm *CacheMetrics) recordEviction() {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tcm.Evictions++\n}\n\n// setSize updates the current cache size",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setSize_79": {
      "name": "setSize",
      "type": "method",
      "start_line": 79,
      "end_line": 85,
      "content_hash": "22019dda01b04333a00a8db3846f8d2d692bb039",
      "content": "func (cm *CacheMetrics) setSize(size int) {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tcm.Size = size\n}\n\n// calculateHitRate calculates the hit rate",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_calculateHitRate_86": {
      "name": "calculateHitRate",
      "type": "method",
      "start_line": 86,
      "end_line": 93,
      "content_hash": "f5e44feba51596a00b2d3b63b3179dc7420e1f8e",
      "content": "func (cm *CacheMetrics) calculateHitRate() {\n\ttotal := cm.Hits + cm.Misses\n\tif total > 0 {\n\t\tcm.HitRate = float64(cm.Hits) / float64(total)\n\t}\n}\n\n// GetSnapshot returns a snapshot of current metrics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSnapshot_94": {
      "name": "GetSnapshot",
      "type": "method",
      "start_line": 94,
      "end_line": 108,
      "content_hash": "f11eb06a96d782ac8a2eb25c1a167766c857647b",
      "content": "func (cm *CacheMetrics) GetSnapshot() CacheMetrics {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\t// Return a copy without the mutex to avoid copying the lock\n\treturn CacheMetrics{\n\t\tHits:      cm.Hits,\n\t\tMisses:    cm.Misses,\n\t\tEvictions: cm.Evictions,\n\t\tSize:      cm.Size,\n\t\tMaxSize:   cm.MaxSize,\n\t\tHitRate:   cm.HitRate,\n\t}\n}\n\n// MemoryCache provides an in-memory caching layer",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MemoryCache_109": {
      "name": "MemoryCache",
      "type": "struct",
      "start_line": 109,
      "end_line": 118,
      "content_hash": "31f17da47cadfd9d1bf0e7a285f814b45baebf35",
      "content": "type MemoryCache struct {\n\tconfig  CacheConfig\n\tcache   map[string]*CacheEntry\n\tqueue   []string // LRU queue for eviction\n\tmetrics CacheMetrics\n\tmu      sync.RWMutex\n\tstop    chan struct{}\n}\n\n// NewMemoryCache creates a new memory cache",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMemoryCache_119": {
      "name": "NewMemoryCache",
      "type": "function",
      "start_line": 119,
      "end_line": 138,
      "content_hash": "16c0bccab8c8e2952e52fe04c1f066b60c3cef9d",
      "content": "func NewMemoryCache(config CacheConfig) *MemoryCache {\n\tmc := &MemoryCache{\n\t\tconfig: config,\n\t\tcache:  make(map[string]*CacheEntry),\n\t\tqueue:  make([]string, 0),\n\t\tmetrics: CacheMetrics{\n\t\t\tMaxSize: config.MaxSize,\n\t\t},\n\t\tstop: make(chan struct{}),\n\t}\n\n\t// Start cleanup routine if enabled\n\tif config.CleanupPeriod > 0 {\n\t\tgo mc.cleanupRoutine()\n\t}\n\n\treturn mc\n}\n\n// Get retrieves a value from the cache",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Get_139": {
      "name": "Get",
      "type": "method",
      "start_line": 139,
      "end_line": 175,
      "content_hash": "65c399902c10196de759013e1fd39347108615e4",
      "content": "func (mc *MemoryCache) Get(ctx context.Context, key string) (any, bool) {\n\tmc.mu.Lock()\n\tdefer mc.mu.Unlock()\n\n\tentry, exists := mc.cache[key]\n\tif !exists {\n\t\tif mc.config.EnableMetrics {\n\t\t\tmc.metrics.recordMiss()\n\t\t}\n\t\treturn nil, false\n\t}\n\n\tif entry.IsExpired() {\n\t\tdelete(mc.cache, key)\n\t\tmc.removeFromQueue(key)\n\t\tif mc.config.EnableMetrics {\n\t\t\tmc.metrics.recordMiss()\n\t\t\tmc.metrics.setSize(len(mc.cache))\n\t\t}\n\t\treturn nil, false\n\t}\n\n\t// Update access time and hit count\n\tentry.Accessed = time.Now()\n\tentry.HitCount++\n\n\t// Move to end of queue (LRU)\n\tmc.moveToEnd(key)\n\n\tif mc.config.EnableMetrics {\n\t\tmc.metrics.recordHit()\n\t}\n\n\treturn entry.Value, true\n}\n\n// Set stores a value in the cache",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Set_176": {
      "name": "Set",
      "type": "method",
      "start_line": 176,
      "end_line": 211,
      "content_hash": "5555cc3c423998fa3261f3031cfd368e98f7a228",
      "content": "func (mc *MemoryCache) Set(ctx context.Context, key string, value any) {\n\tmc.mu.Lock()\n\tdefer mc.mu.Unlock()\n\n\tnow := time.Now()\n\texpiresAt := now.Add(mc.config.TTL)\n\n\tentry := &CacheEntry{\n\t\tKey:       key,\n\t\tValue:     value,\n\t\tCreated:   now,\n\t\tAccessed:  now,\n\t\tExpiresAt: expiresAt,\n\t\tHitCount:  0,\n\t}\n\n\t// Check if updating existing entry\n\tif _, exists := mc.cache[key]; !exists {\n\t\t// Check if we need to evict\n\t\tif len(mc.cache) >= mc.config.MaxSize {\n\t\t\tmc.evictLRU()\n\t\t}\n\t\tmc.queue = append(mc.queue, key)\n\t} else {\n\t\t// Update existing\n\t\tmc.moveToEnd(key)\n\t}\n\n\tmc.cache[key] = entry\n\n\tif mc.config.EnableMetrics {\n\t\tmc.metrics.setSize(len(mc.cache))\n\t}\n}\n\n// Delete removes a value from the cache",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Delete_212": {
      "name": "Delete",
      "type": "method",
      "start_line": 212,
      "end_line": 226,
      "content_hash": "014dfd05e2b37e652bc2cb2710924e669523f302",
      "content": "func (mc *MemoryCache) Delete(ctx context.Context, key string) {\n\tmc.mu.Lock()\n\tdefer mc.mu.Unlock()\n\n\tif _, exists := mc.cache[key]; exists {\n\t\tdelete(mc.cache, key)\n\t\tmc.removeFromQueue(key)\n\n\t\tif mc.config.EnableMetrics {\n\t\t\tmc.metrics.setSize(len(mc.cache))\n\t\t}\n\t}\n}\n\n// Clear removes all entries from the cache",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Clear_227": {
      "name": "Clear",
      "type": "method",
      "start_line": 227,
      "end_line": 239,
      "content_hash": "9e31bc97b58aaeb315ad1329d1a799329c585432",
      "content": "func (mc *MemoryCache) Clear(ctx context.Context) {\n\tmc.mu.Lock()\n\tdefer mc.mu.Unlock()\n\n\tmc.cache = make(map[string]*CacheEntry)\n\tmc.queue = make([]string, 0)\n\n\tif mc.config.EnableMetrics {\n\t\tmc.metrics.setSize(0)\n\t}\n}\n\n// Close stops the cache cleanup routine",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_240": {
      "name": "Close",
      "type": "method",
      "start_line": 240,
      "end_line": 244,
      "content_hash": "0c830c5794b2528bbb30d5f433cd1742ba822acc",
      "content": "func (mc *MemoryCache) Close() {\n\tclose(mc.stop)\n}\n\n// GetMetrics returns the current cache metrics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetMetrics_245": {
      "name": "GetMetrics",
      "type": "method",
      "start_line": 245,
      "end_line": 252,
      "content_hash": "2c3b3cc3e66f78e0a6049dc1e688bfc61aedebff",
      "content": "func (mc *MemoryCache) GetMetrics() CacheMetrics {\n\tif mc.config.EnableMetrics {\n\t\treturn mc.metrics.GetSnapshot()\n\t}\n\treturn CacheMetrics{}\n}\n\n// evictLRU evicts the least recently used entry",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_evictLRU_253": {
      "name": "evictLRU",
      "type": "method",
      "start_line": 253,
      "end_line": 269,
      "content_hash": "ddc226ea4d19f30276b4286f0caf79668e02db61",
      "content": "func (mc *MemoryCache) evictLRU() {\n\tif len(mc.queue) == 0 {\n\t\treturn\n\t}\n\n\t// Remove first item (LRU)\n\tlruKey := mc.queue[0]\n\tdelete(mc.cache, lruKey)\n\tmc.queue = mc.queue[1:]\n\n\tif mc.config.EnableMetrics {\n\t\tmc.metrics.recordEviction()\n\t\tmc.metrics.setSize(len(mc.cache))\n\t}\n}\n\n// moveToEnd moves a key to the end of the LRU queue",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_moveToEnd_270": {
      "name": "moveToEnd",
      "type": "method",
      "start_line": 270,
      "end_line": 275,
      "content_hash": "9dbaa150e1b7bd30350d8d164b1df53371170eaa",
      "content": "func (mc *MemoryCache) moveToEnd(key string) {\n\tmc.removeFromQueue(key)\n\tmc.queue = append(mc.queue, key)\n}\n\n// removeFromQueue removes a key from the queue",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_removeFromQueue_276": {
      "name": "removeFromQueue",
      "type": "method",
      "start_line": 276,
      "end_line": 285,
      "content_hash": "97d886fd55534c877aa2a7a7c0e1420c4034a5b8",
      "content": "func (mc *MemoryCache) removeFromQueue(key string) {\n\tfor i, qKey := range mc.queue {\n\t\tif qKey == key {\n\t\t\tmc.queue = append(mc.queue[:i], mc.queue[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// cleanupRoutine periodically removes expired entries",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cleanupRoutine_286": {
      "name": "cleanupRoutine",
      "type": "method",
      "start_line": 286,
      "end_line": 328,
      "content_hash": "5eabd8aca0a44431d39f2a3043d840ea9b81e78c",
      "content": "func (mc *MemoryCache) cleanupRoutine() {\n\tticker := time.NewTicker(mc.config.CleanupPeriod)\n\tdefer ticker.Stop()\n\n\tremovedCount := 0\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tmc.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tkeysToRemove := make([]string, 0)\n\n\t\t\tfor key, entry := range mc.cache {\n\t\t\t\tif now.After(entry.ExpiresAt) {\n\t\t\t\t\tkeysToRemove = append(keysToRemove, key)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, key := range keysToRemove {\n\t\t\t\tdelete(mc.cache, key)\n\t\t\t\tmc.removeFromQueue(key)\n\t\t\t\tremovedCount++\n\t\t\t}\n\n\t\t\tif mc.config.EnableMetrics {\n\t\t\t\tmc.metrics.setSize(len(mc.cache))\n\t\t\t}\n\n\t\t\tmc.mu.Unlock()\n\n\t\t\tif removedCount > 0 {\n\t\t\t\tslog.Debug(\"Cache cleanup completed\", \"removed\", removedCount)\n\t\t\t\tremovedCount = 0\n\t\t\t}\n\n\t\tcase <-mc.stop:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// CachedIndexer wraps an Indexer with caching capabilities",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_CachedIndexer_329": {
      "name": "CachedIndexer",
      "type": "struct",
      "start_line": 329,
      "end_line": 336,
      "content_hash": "20016b36bd5f0d76cc3a8e480cf7bc32031787a7",
      "content": "type CachedIndexer struct {\n\tindexer *Indexer\n\tcache   *MemoryCache\n\tconfig  CacheConfig\n\tengine  *EmbeddingEngine // Add embedding engine for similar search\n}\n\n// NewCachedIndexer creates a new cached indexer",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewCachedIndexer_337": {
      "name": "NewCachedIndexer",
      "type": "function",
      "start_line": 337,
      "end_line": 346,
      "content_hash": "7be8b9c27bc1f87473ac42a1190286ffef16b0b0",
      "content": "func NewCachedIndexer(indexer *Indexer, config CacheConfig, engine *EmbeddingEngine) *CachedIndexer {\n\treturn &CachedIndexer{\n\t\tindexer: indexer,\n\t\tcache:   NewMemoryCache(config),\n\t\tconfig:  config,\n\t\tengine:  engine,\n\t}\n}\n\n// SearchSymbols searches symbols with caching",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SearchSymbols_347": {
      "name": "SearchSymbols",
      "type": "method",
      "start_line": 347,
      "end_line": 370,
      "content_hash": "6ab7bba82121036a58b870dc524975a5ed2ff5fb",
      "content": "func (ci *CachedIndexer) SearchSymbols(ctx context.Context, query string, limit int) ([]Symbol, error) {\n\tcacheKey := fmt.Sprintf(\"search_symbols:%s:%d\", query, limit)\n\n\t// Try cache first\n\tif cached, found := ci.cache.Get(ctx, cacheKey); found {\n\t\tif symbols, ok := cached.([]Symbol); ok {\n\t\t\tslog.Debug(\"Cache hit for search symbols\", \"query\", query)\n\t\t\treturn symbols, nil\n\t\t}\n\t}\n\n\t// Cache miss - perform actual search\n\tsymbols, err := ci.indexer.SearchSymbols(ctx, query, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Store in cache\n\tci.cache.Set(ctx, cacheKey, symbols)\n\n\treturn symbols, nil\n}\n\n// SearchSimilar searches similar symbols with caching",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SearchSimilar_371": {
      "name": "SearchSimilar",
      "type": "method",
      "start_line": 371,
      "end_line": 399,
      "content_hash": "f9aaafb3579b6a65b054d83f58c370320768b269",
      "content": "func (ci *CachedIndexer) SearchSimilar(ctx context.Context, query string, limit int) ([]Embedding, error) {\n\tcacheKey := fmt.Sprintf(\"search_similar:%s:%d\", query, limit)\n\n\t// Try cache first\n\tif cached, found := ci.cache.Get(ctx, cacheKey); found {\n\t\tif embeddings, ok := cached.([]Embedding); ok {\n\t\t\tslog.Debug(\"Cache hit for search similar\", \"query\", query)\n\t\t\treturn embeddings, nil\n\t\t}\n\t\t// Handle potential type assertion failure safely\n\t}\n\n\t// Cache miss - delegate to embedding engine if available\n\tif ci.engine != nil {\n\t\tembeddings, err := ci.engine.SearchSimilar(ctx, query, limit)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Store in cache\n\t\tci.cache.Set(ctx, cacheKey, embeddings)\n\t\treturn embeddings, nil\n\t}\n\n\t// Fallback: return empty result if no embedding engine\n\treturn []Embedding{}, nil\n}\n\n// GetSymbol retrieves a symbol with caching",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSymbol_400": {
      "name": "GetSymbol",
      "type": "method",
      "start_line": 400,
      "end_line": 424,
      "content_hash": "f4ae96a4b661e434528b9e5886b695e1a98dc071",
      "content": "func (ci *CachedIndexer) GetSymbol(ctx context.Context, id string) (*Symbol, error) {\n\tcacheKey := fmt.Sprintf(\"get_symbol:%s\", id)\n\n\t// Try cache first\n\tif cached, found := ci.cache.Get(ctx, cacheKey); found {\n\t\tif symbol, ok := cached.(*Symbol); ok {\n\t\t\tslog.Debug(\"Cache hit for get symbol\", \"id\", id)\n\t\t\treturn symbol, nil\n\t\t}\n\t\t// Type assertion failed, fall through to retrieve fresh data\n\t}\n\n\t// Cache miss - perform actual retrieval\n\tsymbol, err := ci.indexer.GetSymbol(ctx, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Store in cache\n\tci.cache.Set(ctx, cacheKey, symbol)\n\n\treturn symbol, nil\n}\n\n// InvalidateFile removes all cached entries for a specific file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_InvalidateFile_425": {
      "name": "InvalidateFile",
      "type": "method",
      "start_line": 425,
      "end_line": 431,
      "content_hash": "97ff2eeb526c7d1faec33d57d15e069369b26c6c",
      "content": "func (ci *CachedIndexer) InvalidateFile(ctx context.Context, filePath string) {\n\tci.cache.Clear(ctx) // For simplicity, clear all cache\n\t// In a more sophisticated implementation, we could track which cache keys\n\t// are related to which files and invalidate only those\n}\n\n// GetCacheMetrics returns the cache performance metrics",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetCacheMetrics_432": {
      "name": "GetCacheMetrics",
      "type": "method",
      "start_line": 432,
      "end_line": 436,
      "content_hash": "4506e2ede0bad0cf52eb48d729bc90fdaecd4416",
      "content": "func (ci *CachedIndexer) GetCacheMetrics() CacheMetrics {\n\treturn ci.cache.GetMetrics()\n}\n\n// Close closes the cached indexer",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_437": {
      "name": "Close",
      "type": "method",
      "start_line": 437,
      "end_line": 440,
      "content_hash": "333b5a6259a29a496ad18468f20a2ce5a19fdbb3",
      "content": "func (ci *CachedIndexer) Close() error {\n\tci.cache.Close()\n\treturn ci.indexer.Close()\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}