{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/generator/bool_ops.rs",
  "file_hash": "51705a25884dd28ec5eee09e806197ac84e4d334",
  "updated_at": "2025-12-26T17:34:22.679820",
  "symbols": {
    "enum_BoolOp_12": {
      "name": "BoolOp",
      "type": "enum",
      "start_line": 12,
      "end_line": 23,
      "content_hash": "ae0d28b8e2180a82eae48c49e82635ad4eff6d14",
      "content": "pub enum BoolOp {\n    Gt(Gt),\n    Gte(Gte),\n    Lt(Lt),\n    Lte(Lte),\n    Eq(Eq),\n    Neq(Neq),\n    Contains(Contains),\n    IsIn(IsIn),\n    PropertyEq(PropertyEq),\n    PropertyNeq(PropertyNeq),\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_24": {
      "name": "Display",
      "type": "impl",
      "start_line": 24,
      "end_line": 24,
      "content_hash": "ebcf96c0dd8d3f5604e396f33a48c9519437386d",
      "content": "impl Display for BoolOp {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_25": {
      "name": "fmt",
      "type": "method",
      "start_line": 25,
      "end_line": 41,
      "content_hash": "55417833cd705a6f65cf3430043e2a0d40204a8b",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let s = match self {\n            BoolOp::Gt(gt) => format!(\"{gt}\"),\n            BoolOp::Gte(gte) => format!(\"{gte}\"),\n            BoolOp::Lt(lt) => format!(\"{lt}\"),\n            BoolOp::Lte(lte) => format!(\"{lte}\"),\n            BoolOp::Eq(eq) => format!(\"{eq}\"),\n            BoolOp::Neq(neq) => format!(\"{neq}\"),\n            BoolOp::Contains(contains) => format!(\"v{contains}\"),\n            BoolOp::IsIn(is_in) => format!(\"v{is_in}\"),\n            BoolOp::PropertyEq(prop_eq) => format!(\"{prop_eq}\"),\n            BoolOp::PropertyNeq(prop_neq) => format!(\"{prop_neq}\"),\n        };\n        write!(f, \"map_value_or(false, |v| {s})?\")\n    }\n}\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Gt_42": {
      "name": "Gt",
      "type": "struct",
      "start_line": 42,
      "end_line": 45,
      "content_hash": "58bcec0fd7b6511d0ea79c214578bcf115b9284c",
      "content": "pub struct Gt {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_46": {
      "name": "Display",
      "type": "impl",
      "start_line": 46,
      "end_line": 46,
      "content_hash": "97c7ce571b1dcd81e935ba1556c62938f1000ff7",
      "content": "impl Display for Gt {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_47": {
      "name": "fmt",
      "type": "method",
      "start_line": 47,
      "end_line": 52,
      "content_hash": "ba9a99a8a2728c091557910aecb2df8134844906",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} > {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Gte_53": {
      "name": "Gte",
      "type": "struct",
      "start_line": 53,
      "end_line": 56,
      "content_hash": "59a40ff7f70e0cd13ed3967b29349507abcadb8c",
      "content": "pub struct Gte {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_57": {
      "name": "Display",
      "type": "impl",
      "start_line": 57,
      "end_line": 57,
      "content_hash": "6b67baa05f76364b6a01d9a3c7a1a5e143f02c51",
      "content": "impl Display for Gte {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_58": {
      "name": "fmt",
      "type": "method",
      "start_line": 58,
      "end_line": 63,
      "content_hash": "714f3e51c041df4329c5a80c45cce17f43225beb",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} >= {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Lt_64": {
      "name": "Lt",
      "type": "struct",
      "start_line": 64,
      "end_line": 67,
      "content_hash": "773f08da93192b05b6e283a07941061b5cbd2e59",
      "content": "pub struct Lt {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_68": {
      "name": "Display",
      "type": "impl",
      "start_line": 68,
      "end_line": 68,
      "content_hash": "c99bc7bfe296dfb6ee1aa4a744a75bc13668957e",
      "content": "impl Display for Lt {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_69": {
      "name": "fmt",
      "type": "method",
      "start_line": 69,
      "end_line": 74,
      "content_hash": "a9ebb24f4264bbad3fda4eda375932f0fc44cce4",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} < {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Lte_75": {
      "name": "Lte",
      "type": "struct",
      "start_line": 75,
      "end_line": 78,
      "content_hash": "1939dc145ad8972c6e601a62046ed02290ca479b",
      "content": "pub struct Lte {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_79": {
      "name": "Display",
      "type": "impl",
      "start_line": 79,
      "end_line": 79,
      "content_hash": "ce9afa9943b39c53e45b33ec01bf85b2eabcc5a9",
      "content": "impl Display for Lte {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_80": {
      "name": "fmt",
      "type": "method",
      "start_line": 80,
      "end_line": 85,
      "content_hash": "20e852ef1201e193c45a7764b16c8471b6b89da0",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} <= {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Eq_86": {
      "name": "Eq",
      "type": "struct",
      "start_line": 86,
      "end_line": 89,
      "content_hash": "22a6c719378d102777a64223c84fc14774c58f53",
      "content": "pub struct Eq {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_90": {
      "name": "Display",
      "type": "impl",
      "start_line": 90,
      "end_line": 90,
      "content_hash": "ccaa891e77296051d27aecdb9711d5d570bd3f3a",
      "content": "impl Display for Eq {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_91": {
      "name": "fmt",
      "type": "method",
      "start_line": 91,
      "end_line": 96,
      "content_hash": "e286de2f73df3c65554e9726342b8118d3b8dfc7",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} == {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Neq_97": {
      "name": "Neq",
      "type": "struct",
      "start_line": 97,
      "end_line": 100,
      "content_hash": "ad08dbb5e53cdb1aee5c8f7393ab5b4c431df494",
      "content": "pub struct Neq {\n    pub left: GeneratedValue,\n    pub right: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_101": {
      "name": "Display",
      "type": "impl",
      "start_line": 101,
      "end_line": 101,
      "content_hash": "79453afbdfb841ec9a28eaef315424509cfd797f",
      "content": "impl Display for Neq {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_102": {
      "name": "fmt",
      "type": "method",
      "start_line": 102,
      "end_line": 107,
      "content_hash": "77519928dffafd24021aacb39d58d6cf9c7020f6",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} != {}\", self.left, self.right)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PropertyEq_108": {
      "name": "PropertyEq",
      "type": "struct",
      "start_line": 108,
      "end_line": 111,
      "content_hash": "9054153e030fc320fe41c0002301e4c5e043cc79",
      "content": "pub struct PropertyEq {\n    pub var: String,\n    pub property: String,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_112": {
      "name": "Display",
      "type": "impl",
      "start_line": 112,
      "end_line": 112,
      "content_hash": "58e71b1186b9598635e857ee5a9b6bc165edfb6d",
      "content": "impl Display for PropertyEq {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_113": {
      "name": "fmt",
      "type": "method",
      "start_line": 113,
      "end_line": 118,
      "content_hash": "691d2c418dd0372563c203e4feefb651e9044759",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}.get_property(\\\"{}\\\").map_or(false, |w| w == v)\", self.var, self.property)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PropertyNeq_119": {
      "name": "PropertyNeq",
      "type": "struct",
      "start_line": 119,
      "end_line": 122,
      "content_hash": "c2b86656eaa95bd0611b95b738e891acbfb4d42b",
      "content": "pub struct PropertyNeq {\n    pub var: String,\n    pub property: String,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_123": {
      "name": "Display",
      "type": "impl",
      "start_line": 123,
      "end_line": 123,
      "content_hash": "5cdd66189eb2da1060ac8f7375bf44159546ea1e",
      "content": "impl Display for PropertyNeq {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_124": {
      "name": "fmt",
      "type": "method",
      "start_line": 124,
      "end_line": 129,
      "content_hash": "9722a519b19c3c56a634d7e74f6c4bc0f6052ec7",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}.get_property(\\\"{}\\\").map_or(false, |w| w != v)\", self.var, self.property)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Contains_130": {
      "name": "Contains",
      "type": "struct",
      "start_line": 130,
      "end_line": 132,
      "content_hash": "96b060f00ea9977201117aad198e1f0482bd48f1",
      "content": "pub struct Contains {\n    pub value: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_133": {
      "name": "Display",
      "type": "impl",
      "start_line": 133,
      "end_line": 133,
      "content_hash": "6cd6ffeb0301003a68b42204d026c53a191d993e",
      "content": "impl Display for Contains {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_134": {
      "name": "fmt",
      "type": "method",
      "start_line": 134,
      "end_line": 139,
      "content_hash": "ada9d3761458d1d245f5274a65b0244a7e965a9d",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \".contains({})\", self.value)\n    }\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IsIn_140": {
      "name": "IsIn",
      "type": "struct",
      "start_line": 140,
      "end_line": 142,
      "content_hash": "25886401d92f01971a7c3cd8bad160198bd01bfb",
      "content": "pub struct IsIn {\n    pub value: GeneratedValue,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_143": {
      "name": "Display",
      "type": "impl",
      "start_line": 143,
      "end_line": 143,
      "content_hash": "f510f938c974a021b425a6da15d780eaf59d585d",
      "content": "impl Display for IsIn {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_144": {
      "name": "fmt",
      "type": "method",
      "start_line": 144,
      "end_line": 151,
      "content_hash": "4c6cc93c68e7371755f48c0af9e79fb875f8e4d8",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \".is_in({})\", self.value)\n    }\n}\n\n/// Boolean expression is used for a traversal or set of traversals wrapped in AND/OR\n/// that resolve to a boolean value\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_BoExp_152": {
      "name": "BoExp",
      "type": "enum",
      "start_line": 152,
      "end_line": 160,
      "content_hash": "e27f89833344b7dfa69134ca2532cb0740063ecb",
      "content": "pub enum BoExp {\n    Not(Box<BoExp>),\n    And(Vec<BoExp>),\n    Or(Vec<BoExp>),\n    Exists(Traversal),\n    Expr(Traversal),\n    Empty,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_BoExp_161": {
      "name": "BoExp",
      "type": "impl",
      "start_line": 161,
      "end_line": 161,
      "content_hash": "60557677c2044fa366da7c627dcd590fe4d1557d",
      "content": "impl BoExp {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_negate_162": {
      "name": "negate",
      "type": "method",
      "start_line": 162,
      "end_line": 168,
      "content_hash": "9c1c6f36e4be6a7e0681e3ec8db0353ce5f80e9a",
      "content": "    pub fn negate(&self) -> Self {\n        match self {\n            BoExp::Not(expr) => *expr.clone(),\n            _ => BoExp::Not(Box::new(self.clone())),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_not_169": {
      "name": "is_not",
      "type": "method",
      "start_line": 169,
      "end_line": 172,
      "content_hash": "4d1d11567b26e8852537bf501530e25c1478fb25",
      "content": "    pub fn is_not(&self) -> bool {\n        matches!(self, BoExp::Not(_))\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_173": {
      "name": "Display",
      "type": "impl",
      "start_line": 173,
      "end_line": 173,
      "content_hash": "31e988c8112b521959fa2af2f59939d85175a516",
      "content": "impl Display for BoExp {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_174": {
      "name": "fmt",
      "type": "method",
      "start_line": 174,
      "end_line": 297,
      "content_hash": "009e046e2d50c97e33d484064b1cbdd562e3a47d",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            BoExp::Not(expr) => write!(f, \"!({expr})\"),\n            BoExp::And(exprs) => {\n                let displayed_exprs = exprs.iter().map(|s| format!(\"{s}\")).collect::<Vec<_>>();\n                write!(f, \"({})\", displayed_exprs.join(\" && \"))\n            }\n            BoExp::Or(exprs) => {\n                let displayed_exprs = exprs.iter().map(|s| format!(\"{s}\")).collect::<Vec<_>>();\n                write!(f, \"({})\", displayed_exprs.join(\" || \"))\n            }\n            BoExp::Exists(traversal) => {\n                // Optimize Exists expressions in filter context to use std::iter::once for single values\n                let is_val_traversal = match &traversal.traversal_type {\n                    TraversalType::FromIter(var) | TraversalType::FromSingle(var) => match var {\n                        GenRef::Std(s) | GenRef::Literal(s) => {\n                            s == \"val\"\n                                && matches!(\n                                    traversal.source_step.inner(),\n                                    SourceStep::Identifier(_) | SourceStep::Anonymous\n                                )\n                        }\n                        _ => false,\n                    },\n                    _ => false,\n                };\n\n                if is_val_traversal {\n                    // Create a modified traversal that uses FromSingle instead of FromIter\n                    // This will generate: G::from_iter(&db, &txn, std::iter::once(val.clone()), &arena)\n                    let mut optimized = traversal.clone();\n                    if let TraversalType::FromIter(var) = &traversal.traversal_type {\n                        optimized.traversal_type = TraversalType::FromSingle(var.clone());\n                    }\n                    write!(f, \"Exist::exists(&mut {optimized})\")\n                } else {\n                    write!(f, \"Exist::exists(&mut {traversal})\")\n                }\n            }\n            BoExp::Expr(traversal) => {\n                // Optimize simple property checks in filters to avoid unnecessary cloning and traversal creation\n                // Check if this is a FromVar(\"val\") or FromSingle(\"val\") traversal with just property fetch + bool op\n                let is_val_traversal = match &traversal.traversal_type {\n                    TraversalType::FromIter(var) | TraversalType::FromSingle(var) => match var {\n                        GenRef::Std(s) | GenRef::Literal(s) => s == \"val\",\n                        _ => false,\n                    },\n                    _ => false,\n                };\n\n                if is_val_traversal {\n                    // Look for PropertyFetch followed by BoolOp pattern (in any Separator type)\n                    let mut prop_info: Option<&GenRef<String>> = None;\n                    let mut bool_op_info: Option<&BoolOp> = None;\n                    let mut other_steps = 0;\n\n                    for step in traversal.steps.iter() {\n                        match step {\n                            Separator::Period(Step::PropertyFetch(prop))\n                            | Separator::Newline(Step::PropertyFetch(prop))\n                            | Separator::Empty(Step::PropertyFetch(prop))\n                            | Separator::Comma(Step::PropertyFetch(prop))\n                            | Separator::Semicolon(Step::PropertyFetch(prop)) => {\n                                if prop_info.is_none() {\n                                    prop_info = Some(prop);\n                                }\n                            }\n                            Separator::Period(Step::BoolOp(op))\n                            | Separator::Newline(Step::BoolOp(op))\n                            | Separator::Empty(Step::BoolOp(op))\n                            | Separator::Comma(Step::BoolOp(op))\n                            | Separator::Semicolon(Step::BoolOp(op)) => {\n                                if bool_op_info.is_none() {\n                                    bool_op_info = Some(op);\n                                }\n                            }\n                            _ => {\n                                other_steps += 1;\n                            }\n                        }\n                    }\n\n                    // If we found exactly one PropertyFetch and one BoolOp, and no other steps, optimize\n                    if let (Some(prop), Some(bool_op)) = (prop_info, bool_op_info)\n                        && other_steps == 0\n                    {\n                        // Generate optimized code: val.get_property(\"prop\").map_or(false, |v| ...)\n                        let bool_expr = match bool_op {\n                            BoolOp::Gt(gt) => format!(\"{gt}\"),\n                            BoolOp::Gte(gte) => format!(\"{gte}\"),\n                            BoolOp::Lt(lt) => format!(\"{lt}\"),\n                            BoolOp::Lte(lte) => format!(\"{lte}\"),\n                            BoolOp::Eq(eq) => format!(\"{eq}\"),\n                            BoolOp::Neq(neq) => format!(\"{neq}\"),\n                            BoolOp::Contains(contains) => format!(\"v{contains}\"),\n                            BoolOp::IsIn(is_in) => format!(\"v{is_in}\"),\n                            BoolOp::PropertyEq(prop_eq) => format!(\"{prop_eq}\"),\n                            BoolOp::PropertyNeq(prop_neq) => format!(\"{prop_neq}\"),\n                        };\n                        return write!(\n                            f,\n                            \"val\\n                    .get_property({})\\n                    .map_or(false, |v| {})\",\n                            prop, bool_expr\n                        );\n                    }\n                }\n                // Fall back to full traversal for complex expressions\n                write!(f, \"{traversal}\")\n            }\n            BoExp::Empty => write!(f, \"\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::helixc::generator::utils::GenRef;\n\n    // ============================================================================\n    // Comparison Operator Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_gt_display_298": {
      "name": "test_gt_display",
      "type": "method",
      "start_line": 298,
      "end_line": 306,
      "content_hash": "92d1f3dd2a84ab693b11360e364771a54c505571",
      "content": "    fn test_gt_display() {\n        let gt = Gt {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"10\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", gt), \"*v > 10\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_gte_display_307": {
      "name": "test_gte_display",
      "type": "method",
      "start_line": 307,
      "end_line": 315,
      "content_hash": "1f9649e4d3dadfe7c38d1f35aa228c94a542f4b5",
      "content": "    fn test_gte_display() {\n        let gte = Gte {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"5\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", gte), \"*v >= 5\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_lt_display_316": {
      "name": "test_lt_display",
      "type": "method",
      "start_line": 316,
      "end_line": 324,
      "content_hash": "682dd1040c4d3c24f8d121208ead0c1743639b4f",
      "content": "    fn test_lt_display() {\n        let lt = Lt {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"100\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", lt), \"*v < 100\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_lte_display_325": {
      "name": "test_lte_display",
      "type": "method",
      "start_line": 325,
      "end_line": 333,
      "content_hash": "ff595024c39939ed0cb671d22d18fb1cc9f1a5d7",
      "content": "    fn test_lte_display() {\n        let lte = Lte {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"50\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", lte), \"*v <= 50\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_eq_display_334": {
      "name": "test_eq_display",
      "type": "method",
      "start_line": 334,
      "end_line": 342,
      "content_hash": "5ee7b12cd087fe154ef4bec5dc3ed202d7545e1b",
      "content": "    fn test_eq_display() {\n        let eq = Eq {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Literal(GenRef::Literal(\"test\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", eq), \"*v == \\\"test\\\"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_neq_display_343": {
      "name": "test_neq_display",
      "type": "method",
      "start_line": 343,
      "end_line": 351,
      "content_hash": "0803ff7a4f10c64e540be3041a6826f6570addb4",
      "content": "    fn test_neq_display() {\n        let neq = Neq {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"null\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", neq), \"*v != null\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_contains_display_352": {
      "name": "test_contains_display",
      "type": "method",
      "start_line": 352,
      "end_line": 359,
      "content_hash": "13c3194fc3fd121f800eb844c9c3cad38d5ceb20",
      "content": "    fn test_contains_display() {\n        let contains = Contains {\n            value: GeneratedValue::Literal(GenRef::Literal(\"substring\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", contains), \".contains(\\\"substring\\\")\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_is_in_display_360": {
      "name": "test_is_in_display",
      "type": "method",
      "start_line": 360,
      "end_line": 371,
      "content_hash": "d536e84096360abfee2bc447dcc3e9d72a69a844",
      "content": "    fn test_is_in_display() {\n        let is_in = IsIn {\n            value: GeneratedValue::Array(GenRef::Std(\"1, 2, 3\".to_string())),\n        };\n        assert_eq!(format!(\"{}\", is_in), \".is_in(&[1, 2, 3])\");\n    }\n\n    // ============================================================================\n    // BoolOp Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boolop_gt_wrapped_372": {
      "name": "test_boolop_gt_wrapped",
      "type": "method",
      "start_line": 372,
      "end_line": 381,
      "content_hash": "cb8d9457862cfc11e2ad6c48423a9dddf56ecfa1",
      "content": "    fn test_boolop_gt_wrapped() {\n        let bool_op = BoolOp::Gt(Gt {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Primitive(GenRef::Std(\"20\".to_string())),\n        });\n        let output = format!(\"{}\", bool_op);\n        assert!(output.contains(\"map_value_or(false, |v| *v > 20)\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boolop_eq_wrapped_382": {
      "name": "test_boolop_eq_wrapped",
      "type": "method",
      "start_line": 382,
      "end_line": 391,
      "content_hash": "c06cb7823d77f6198336a241836db3b916d60a90",
      "content": "    fn test_boolop_eq_wrapped() {\n        let bool_op = BoolOp::Eq(Eq {\n            left: GeneratedValue::Primitive(GenRef::Std(\"*v\".to_string())),\n            right: GeneratedValue::Literal(GenRef::Literal(\"value\".to_string())),\n        });\n        let output = format!(\"{}\", bool_op);\n        assert!(output.contains(\"map_value_or(false, |v| *v == \\\"value\\\")\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boolop_contains_wrapped_392": {
      "name": "test_boolop_contains_wrapped",
      "type": "method",
      "start_line": 392,
      "end_line": 404,
      "content_hash": "424f306a65246afe274b09129f5c8d91923c246b",
      "content": "    fn test_boolop_contains_wrapped() {\n        let bool_op = BoolOp::Contains(Contains {\n            value: GeneratedValue::Literal(GenRef::Literal(\"text\".to_string())),\n        });\n        let output = format!(\"{}\", bool_op);\n        assert!(output.contains(\"map_value_or(false, |v| v.contains(\\\"text\\\"))\"));\n    }\n\n    // ============================================================================\n    // BoExp Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boexp_empty_405": {
      "name": "test_boexp_empty",
      "type": "method",
      "start_line": 405,
      "end_line": 410,
      "content_hash": "9ac09d7e15a4c68a144a6ce1cf9d4ed1071b2bba",
      "content": "    fn test_boexp_empty() {\n        let boexp = BoExp::Empty;\n        assert_eq!(format!(\"{}\", boexp), \"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boexp_negate_411": {
      "name": "test_boexp_negate",
      "type": "method",
      "start_line": 411,
      "end_line": 417,
      "content_hash": "8d70fa7f35c3a173e85f563f01a405f953de4c29",
      "content": "    fn test_boexp_negate() {\n        let boexp = BoExp::Empty;\n        let negated = boexp.negate();\n        assert!(negated.is_not());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boexp_double_negate_418": {
      "name": "test_boexp_double_negate",
      "type": "method",
      "start_line": 418,
      "end_line": 425,
      "content_hash": "5abf033370949932f869ccfd24d3c9f1ae442a8f",
      "content": "    fn test_boexp_double_negate() {\n        let boexp = BoExp::Empty;\n        let negated = boexp.negate();\n        let double_negated = negated.negate();\n        assert!(!double_negated.is_not());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_boexp_is_not_426": {
      "name": "test_boexp_is_not",
      "type": "method",
      "start_line": 426,
      "end_line": 433,
      "content_hash": "41d5ae59012dd42d6603a76f43cd5806a1e87a9d",
      "content": "    fn test_boexp_is_not() {\n        let not_expr = BoExp::Not(Box::new(BoExp::Empty));\n        assert!(not_expr.is_not());\n\n        let normal_expr = BoExp::Empty;\n        assert!(!normal_expr.is_not());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}