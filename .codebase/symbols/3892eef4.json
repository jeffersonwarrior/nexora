{
  "file_path": "/work/internal/tui/exp/list/items.go",
  "file_hash": "4b2251372b9e6813c3842dd51924118daf676ebe",
  "updated_at": "2025-12-26T17:34:20.376602",
  "symbols": {
    "interface_Indexable_16": {
      "name": "Indexable",
      "type": "interface",
      "start_line": 16,
      "end_line": 39,
      "content_hash": "d787721eed9ea4a7d75726d3fdeda265b7917d91",
      "content": "type Indexable interface {\n\tSetIndex(int)\n}\n\ntype CompletionItem[T any] interface {\n\tFilterableItem\n\tcore.Focusable\n\tcore.Sizeable\n\tHasMatchIndexes\n\tValue() T\n\tText() string\n}\n\ntype completionItemCmp[T any] struct {\n\twidth        int\n\tid           string\n\ttext         string\n\tvalue        T\n\tfocus        bool\n\tmatchIndexes []int\n\tbgColor      color.Color\n\tshortcut     string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_options_40": {
      "name": "options",
      "type": "struct",
      "start_line": 40,
      "end_line": 49,
      "content_hash": "24ee18be268dd4c5bf33cd42a84e8ced3e54a345",
      "content": "type options struct {\n\tid           string\n\ttext         string\n\tbgColor      color.Color\n\tmatchIndexes []int\n\tshortcut     string\n}\n\ntype CompletionItemOption func(*options)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithCompletionBackgroundColor_50": {
      "name": "WithCompletionBackgroundColor",
      "type": "function",
      "start_line": 50,
      "end_line": 55,
      "content_hash": "057b714d22a44e7efd7b975dcfa48deb0e75f5d6",
      "content": "func WithCompletionBackgroundColor(c color.Color) CompletionItemOption {\n\treturn func(cmp *options) {\n\t\tcmp.bgColor = c\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithCompletionMatchIndexes_56": {
      "name": "WithCompletionMatchIndexes",
      "type": "function",
      "start_line": 56,
      "end_line": 61,
      "content_hash": "ae226817b3c7c22728de4c8abd6b9f8bef41261f",
      "content": "func WithCompletionMatchIndexes(indexes ...int) CompletionItemOption {\n\treturn func(cmp *options) {\n\t\tcmp.matchIndexes = indexes\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithCompletionShortcut_62": {
      "name": "WithCompletionShortcut",
      "type": "function",
      "start_line": 62,
      "end_line": 67,
      "content_hash": "144599963b559af770a9515934ec4b503bac3395",
      "content": "func WithCompletionShortcut(shortcut string) CompletionItemOption {\n\treturn func(cmp *options) {\n\t\tcmp.shortcut = shortcut\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WithCompletionID_68": {
      "name": "WithCompletionID",
      "type": "function",
      "start_line": 68,
      "end_line": 266,
      "content_hash": "6023bfc881e8524e37de1b828c0aafc093a1e7e4",
      "content": "func WithCompletionID(id string) CompletionItemOption {\n\treturn func(cmp *options) {\n\t\tcmp.id = id\n\t}\n}\n\nfunc NewCompletionItem[T any](text string, value T, opts ...CompletionItemOption) CompletionItem[T] {\n\tc := &completionItemCmp[T]{\n\t\ttext:  text,\n\t\tvalue: value,\n\t}\n\to := &options{}\n\n\tfor _, opt := range opts {\n\t\topt(o)\n\t}\n\tif o.id == \"\" {\n\t\to.id = uuid.NewString()\n\t}\n\tc.id = o.id\n\tc.bgColor = o.bgColor\n\tc.matchIndexes = o.matchIndexes\n\tc.shortcut = o.shortcut\n\treturn c\n}\n\n// Init implements CommandItem.\nfunc (c *completionItemCmp[T]) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update implements CommandItem.\nfunc (c *completionItemCmp[T]) Update(tea.Msg) (util.Model, tea.Cmd) {\n\treturn c, nil\n}\n\n// View implements CommandItem.\nfunc (c *completionItemCmp[T]) View() string {\n\tt := styles.CurrentTheme()\n\n\titemStyle := t.S().Base.Padding(0, 1).Width(c.width)\n\tinnerWidth := c.width - 2 // Account for padding\n\n\tif c.shortcut != \"\" {\n\t\tinnerWidth -= lipgloss.Width(c.shortcut)\n\t}\n\n\ttitleStyle := t.S().Text.Width(innerWidth)\n\ttitleMatchStyle := t.S().Text.Underline(true)\n\tif c.bgColor != nil {\n\t\ttitleStyle = titleStyle.Background(c.bgColor)\n\t\ttitleMatchStyle = titleMatchStyle.Background(c.bgColor)\n\t\titemStyle = itemStyle.Background(c.bgColor)\n\t}\n\n\tif c.focus {\n\t\ttitleStyle = t.S().TextSelected.Width(innerWidth)\n\t\ttitleMatchStyle = t.S().TextSelected.Underline(true)\n\t\titemStyle = itemStyle.Background(t.Primary)\n\t}\n\n\tvar truncatedTitle string\n\n\tif len(c.matchIndexes) > 0 && len(c.text) > innerWidth {\n\t\t// Smart truncation: ensure the last matching part is visible\n\t\ttruncatedTitle = c.smartTruncate(c.text, innerWidth, c.matchIndexes)\n\t} else {\n\t\t// No matches, use regular truncation\n\t\ttruncatedTitle = ansi.Truncate(c.text, innerWidth, \"\u2026\")\n\t}\n\n\ttext := titleStyle.Render(truncatedTitle)\n\tif len(c.matchIndexes) > 0 {\n\t\tvar ranges []lipgloss.Range\n\t\tfor _, rng := range matchedRanges(c.matchIndexes) {\n\t\t\t// ansi.Cut is grapheme and ansi sequence aware, we match against a ansi.Stripped string, but we might still have graphemes.\n\t\t\t// all that to say that rng is byte positions, but we need to pass it down to ansi.Cut as char positions.\n\t\t\t// so we need to adjust it here:\n\t\t\tstart, stop := bytePosToVisibleCharPos(truncatedTitle, rng)\n\t\t\tranges = append(ranges, lipgloss.NewRange(start, stop+1, titleMatchStyle))\n\t\t}\n\t\ttext = lipgloss.StyleRanges(text, ranges...)\n\t}\n\tparts := []string{text}\n\tif c.shortcut != \"\" {\n\t\t// Add the shortcut at the end\n\t\tshortcutStyle := t.S().Muted\n\t\tif c.focus {\n\t\t\tshortcutStyle = t.S().TextSelected\n\t\t}\n\t\tparts = append(parts, shortcutStyle.Render(c.shortcut))\n\t}\n\titem := itemStyle.Render(\n\t\tlipgloss.JoinHorizontal(\n\t\t\tlipgloss.Left,\n\t\t\tparts...,\n\t\t),\n\t)\n\treturn item\n}\n\n// Blur implements CommandItem.\nfunc (c *completionItemCmp[T]) Blur() tea.Cmd {\n\tc.focus = false\n\treturn nil\n}\n\n// Focus implements CommandItem.\nfunc (c *completionItemCmp[T]) Focus() tea.Cmd {\n\tc.focus = true\n\treturn nil\n}\n\n// GetSize implements CommandItem.\nfunc (c *completionItemCmp[T]) GetSize() (int, int) {\n\treturn c.width, 1\n}\n\n// IsFocused implements CommandItem.\nfunc (c *completionItemCmp[T]) IsFocused() bool {\n\treturn c.focus\n}\n\n// SetSize implements CommandItem.\nfunc (c *completionItemCmp[T]) SetSize(width int, height int) tea.Cmd {\n\tc.width = width\n\treturn nil\n}\n\nfunc (c *completionItemCmp[T]) MatchIndexes(indexes []int) {\n\tc.matchIndexes = indexes\n}\n\nfunc (c *completionItemCmp[T]) FilterValue() string {\n\treturn c.text\n}\n\nfunc (c *completionItemCmp[T]) Value() T {\n\treturn c.value\n}\n\n// smartTruncate implements fzf-style truncation that ensures the last matching part is visible\nfunc (c *completionItemCmp[T]) smartTruncate(text string, width int, matchIndexes []int) string {\n\tif width <= 0 {\n\t\treturn \"\"\n\t}\n\n\ttextLen := ansi.StringWidth(text)\n\tif textLen <= width {\n\t\treturn text\n\t}\n\n\tif len(matchIndexes) == 0 {\n\t\treturn ansi.Truncate(text, width, \"\u2026\")\n\t}\n\n\t// Find the last match position\n\tlastMatchPos := matchIndexes[len(matchIndexes)-1]\n\n\t// Convert byte position to visual width position\n\tlastMatchVisualPos := 0\n\tbytePos := 0\n\tgr := uniseg.NewGraphemes(text)\n\tfor bytePos < lastMatchPos && gr.Next() {\n\t\tbytePos += len(gr.Str())\n\t\tlastMatchVisualPos += max(1, gr.Width())\n\t}\n\n\t// Calculate how much space we need for the ellipsis\n\tellipsisWidth := 1 // \"\u2026\" character width\n\tavailableWidth := width - ellipsisWidth\n\n\t// If the last match is within the available width, truncate from the end\n\tif lastMatchVisualPos < availableWidth {\n\t\treturn ansi.Truncate(text, width, \"\u2026\")\n\t}\n\n\t// Calculate the start position to ensure the last match is visible\n\t// We want to show some context before the last match if possible\n\tstartVisualPos := max(0, lastMatchVisualPos-availableWidth+1)\n\n\t// Convert visual position back to byte position\n\tstartBytePos := 0\n\tcurrentVisualPos := 0\n\tgr = uniseg.NewGraphemes(text)\n\tfor currentVisualPos < startVisualPos && gr.Next() {\n\t\tstartBytePos += len(gr.Str())\n\t\tcurrentVisualPos += max(1, gr.Width())\n\t}\n\n\t// Extract the substring starting from startBytePos\n\ttruncatedText := text[startBytePos:]\n\n\t// Truncate to fit width with ellipsis\n\ttruncatedText = ansi.Truncate(truncatedText, availableWidth, \"\")\n\ttruncatedText = \"\u2026\" + truncatedText\n\treturn truncatedText\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_matchedRanges_267": {
      "name": "matchedRanges",
      "type": "function",
      "start_line": 267,
      "end_line": 287,
      "content_hash": "3dee6b12731f6e4f50c45e6d9b7d746a213ce869",
      "content": "func matchedRanges(in []int) [][2]int {\n\tif len(in) == 0 {\n\t\treturn [][2]int{}\n\t}\n\tcurrent := [2]int{in[0], in[0]}\n\tif len(in) == 1 {\n\t\treturn [][2]int{current}\n\t}\n\tvar out [][2]int\n\tfor i := 1; i < len(in); i++ {\n\t\tif in[i] == current[1]+1 {\n\t\t\tcurrent[1] = in[i]\n\t\t} else {\n\t\t\tout = append(out, current)\n\t\t\tcurrent = [2]int{in[i], in[i]}\n\t\t}\n\t}\n\tout = append(out, current)\n\treturn out\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_bytePosToVisibleCharPos_288": {
      "name": "bytePosToVisibleCharPos",
      "type": "function",
      "start_line": 288,
      "end_line": 319,
      "content_hash": "867554fe88eb509bc8de69fc51e64f722552ebb6",
      "content": "func bytePosToVisibleCharPos(str string, rng [2]int) (int, int) {\n\tbytePos, byteStart, byteStop := 0, rng[0], rng[1]\n\tpos, start, stop := 0, 0, 0\n\tgr := uniseg.NewGraphemes(str)\n\tfor byteStart > bytePos {\n\t\tif !gr.Next() {\n\t\t\tbreak\n\t\t}\n\t\tbytePos += len(gr.Str())\n\t\tpos += max(1, gr.Width())\n\t}\n\tstart = pos\n\tfor byteStop > bytePos {\n\t\tif !gr.Next() {\n\t\t\tbreak\n\t\t}\n\t\tbytePos += len(gr.Str())\n\t\tpos += max(1, gr.Width())\n\t}\n\tstop = pos\n\treturn start, stop\n}\n\n// ID implements CompletionItem.\nfunc (c *completionItemCmp[T]) ID() string {\n\treturn c.id\n}\n\nfunc (c *completionItemCmp[T]) Text() string {\n\treturn c.text\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "interface_ItemSection_320": {
      "name": "ItemSection",
      "type": "interface",
      "start_line": 320,
      "end_line": 325,
      "content_hash": "3de06228ee0ab562ff689bd37e9df273480a2884",
      "content": "type ItemSection interface {\n\tItem\n\tcore.Sizeable\n\tIndexable\n\tSetInfo(info string)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_itemSectionModel_326": {
      "name": "itemSectionModel",
      "type": "struct",
      "start_line": 326,
      "end_line": 334,
      "content_hash": "363984528e51dac775a4b2776867e831c6f5239c",
      "content": "type itemSectionModel struct {\n\twidth int\n\ttitle string\n\tinx   int\n\tid    string\n\tinfo  string\n}\n\n// ID implements ItemSection.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ID_335": {
      "name": "ID",
      "type": "method",
      "start_line": 335,
      "end_line": 338,
      "content_hash": "480393ecd9fd9ef6d0d90312968aee8ff17950c7",
      "content": "func (m *itemSectionModel) ID() string {\n\treturn m.id\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewItemSection_339": {
      "name": "NewItemSection",
      "type": "function",
      "start_line": 339,
      "end_line": 346,
      "content_hash": "a0a7d5331c6c740853a2614e8e6d0e148d9dc20c",
      "content": "func NewItemSection(title string) ItemSection {\n\treturn &itemSectionModel{\n\t\ttitle: title,\n\t\tinx:   -1,\n\t\tid:    uuid.NewString(),\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Init_347": {
      "name": "Init",
      "type": "method",
      "start_line": 347,
      "end_line": 350,
      "content_hash": "9cabc986fdebf227038755b64d07158747545512",
      "content": "func (m *itemSectionModel) Init() tea.Cmd {\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Update_351": {
      "name": "Update",
      "type": "method",
      "start_line": 351,
      "end_line": 354,
      "content_hash": "155542d4b3dfeb7a792dfcefa36b77a45324797c",
      "content": "func (m *itemSectionModel) Update(tea.Msg) (util.Model, tea.Cmd) {\n\treturn m, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_View_355": {
      "name": "View",
      "type": "method",
      "start_line": 355,
      "end_line": 372,
      "content_hash": "82477eedbe52e3782cb22bccfd4501cc0d178b62",
      "content": "func (m *itemSectionModel) View() string {\n\tt := styles.CurrentTheme()\n\ttitle := ansi.Truncate(m.title, m.width-2, \"\u2026\")\n\tstyle := t.S().Base.Padding(1, 1, 0, 1)\n\tif m.inx == 0 {\n\t\tstyle = style.Padding(0, 1, 0, 1)\n\t}\n\ttitle = t.S().Muted.Render(title)\n\tsection := \"\"\n\tif m.info != \"\" {\n\t\tsection = core.SectionWithInfo(title, m.width-2, m.info)\n\t} else {\n\t\tsection = core.Section(title, m.width-2)\n\t}\n\n\treturn style.Render(section)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetSize_373": {
      "name": "GetSize",
      "type": "method",
      "start_line": 373,
      "end_line": 376,
      "content_hash": "6cf6ce28b77ba5c1d60218269bdf6e002db1fa0d",
      "content": "func (m *itemSectionModel) GetSize() (int, int) {\n\treturn m.width, 1\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetSize_377": {
      "name": "SetSize",
      "type": "method",
      "start_line": 377,
      "end_line": 381,
      "content_hash": "5ce2846ed3da83f5d7f540737110be380704fc9f",
      "content": "func (m *itemSectionModel) SetSize(width int, height int) tea.Cmd {\n\tm.width = width\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsSectionHeader_382": {
      "name": "IsSectionHeader",
      "type": "method",
      "start_line": 382,
      "end_line": 385,
      "content_hash": "2df6dae17cf2c19616896b04a453453298de4cf7",
      "content": "func (m *itemSectionModel) IsSectionHeader() bool {\n\treturn true\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetInfo_386": {
      "name": "SetInfo",
      "type": "method",
      "start_line": 386,
      "end_line": 389,
      "content_hash": "93f9d778c9cac72c8294d48a487128c54dae329b",
      "content": "func (m *itemSectionModel) SetInfo(info string) {\n\tm.info = info\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetIndex_390": {
      "name": "SetIndex",
      "type": "method",
      "start_line": 390,
      "end_line": 392,
      "content_hash": "3bb9f6e107375d6f1ffeed496447bd55dc7d49b9",
      "content": "func (m *itemSectionModel) SetIndex(inx int) {\n\tm.inx = inx\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}