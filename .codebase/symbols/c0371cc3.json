{
  "file_path": "/work/internal/app/app.go",
  "file_hash": "a460e56cd12ed65c87c635b1931b3ed916674d94",
  "updated_at": "2025-12-26T17:34:22.448749",
  "symbols": {
    "struct_App_42": {
      "name": "App",
      "type": "struct",
      "start_line": 42,
      "end_line": 66,
      "content_hash": "788970f13d6a7dcc7726d8eeb463c338f710ffea",
      "content": "type App struct {\n\tSessions    session.Service\n\tMessages    message.Service\n\tHistory     history.Service\n\tPermissions permission.Service\n\n\tAgentCoordinator agent.Coordinator\n\n\tLSPClients      *csync.Map[string, *lsp.Client]\n\tAIOPS           aiops.Ops\n\tResourceMonitor *resources.Monitor\n\n\tconfig *config.Config\n\n\tserviceEventsWG *sync.WaitGroup\n\teventsCtx       context.Context\n\tevents          chan tea.Msg\n\ttuiWG           *sync.WaitGroup\n\n\t// global context and cleanup functions\n\tglobalCtx    context.Context\n\tcleanupFuncs []func() error\n}\n\n// New initializes a new applcation instance.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_67": {
      "name": "New",
      "type": "function",
      "start_line": 67,
      "end_line": 141,
      "content_hash": "c7862bd72a922b2fd3dfc7cce18efc7018daf90e",
      "content": "func New(ctx context.Context, conn *sql.DB, cfg *config.Config) (*App, error) {\n\tq := db.New(conn)\n\tsessions := session.NewService(q)\n\tmessages := message.NewService(q)\n\tfiles := history.NewService(q, conn)\n\tskipPermissionsRequests := cfg.Permissions != nil && cfg.Permissions.SkipRequests\n\tallowedTools := []string{}\n\tif cfg.Permissions != nil && cfg.Permissions.AllowedTools != nil {\n\t\tallowedTools = cfg.Permissions.AllowedTools\n\t}\n\n\tapp := &App{\n\t\tSessions:    sessions,\n\t\tMessages:    messages,\n\t\tHistory:     files,\n\t\tPermissions: permission.NewPermissionService(cfg.WorkingDir(), skipPermissionsRequests, allowedTools),\n\t\tLSPClients:  csync.NewMap[string, *lsp.Client](),\n\t\tAIOPS: aiops.NewClient(aiops.Config{\n\t\t\tEnabled:  cfg.AIOPS.Enabled,\n\t\t\tEndpoint: cfg.AIOPS.Endpoint,\n\t\t\tTimeout:  cfg.AIOPS.Timeout,\n\t\t\tFallback: cfg.AIOPS.Fallback,\n\t\t}),\n\n\t\tglobalCtx: ctx,\n\n\t\tconfig: cfg,\n\n\t\tevents:          make(chan tea.Msg, 100),\n\t\tserviceEventsWG: &sync.WaitGroup{},\n\t\ttuiWG:           &sync.WaitGroup{},\n\t}\n\n\tapp.setupEvents()\n\n\t// Initialize LSP clients in the background.\n\tapp.initLSPClients(ctx)\n\n\t// Check for updates in the background.\n\tgo app.checkForUpdates(ctx)\n\n\tgo func() {\n\t\tslog.Info(\"Initializing MCP clients\")\n\t\tmcp.Initialize(ctx, app.Permissions, cfg)\n\t}()\n\n\t// Initialize resource monitor\n\tapp.ResourceMonitor = resources.NewMonitor(resources.DefaultConfig())\n\tapp.cleanupFuncs = append(app.cleanupFuncs, func() error {\n\t\tapp.ResourceMonitor.Stop()\n\t\treturn nil\n\t})\n\n\t// cleanup database upon app shutdown\n\tapp.cleanupFuncs = append(app.cleanupFuncs, conn.Close, mcp.Close)\n\n\t// Agent config cleanup - simplify configuration management for future multi-agent support\n\tif !cfg.IsConfigured() {\n\t\tslog.Warn(\"No agent configuration found\")\n\t\treturn app, nil\n\t}\n\t// Start resource monitor\n\tif err := app.ResourceMonitor.Start(ctx); err != nil {\n\t\tslog.Warn(\"Failed to start resource monitor\", \"error\", err)\n\t} else {\n\t\tslog.Info(\"Resource monitor started successfully\")\n\t}\n\n\tif err := app.InitCoderAgent(ctx); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize coder agent: %w\", err)\n\t}\n\treturn app, nil\n}\n\n// Config returns the application configuration.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Config_142": {
      "name": "Config",
      "type": "method",
      "start_line": 142,
      "end_line": 150,
      "content_hash": "21088b4f520c41226ec45e5dae30be940bf411ef",
      "content": "func (app *App) Config() *config.Config {\n\tif app.config == nil {\n\t\treturn nil\n\t}\n\treturn app.config\n}\n\n// RunNonInteractive runs the application in non-interactive mode with the\n// given prompt, printing to stdout.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RunNonInteractive_151": {
      "name": "RunNonInteractive",
      "type": "method",
      "start_line": 151,
      "end_line": 204,
      "content_hash": "6e382c190a754a24368daadee12f9c3731692d1a",
      "content": "func (app *App) RunNonInteractive(ctx context.Context, output io.Writer, prompt string, quiet bool) error {\n\tslog.Info(\"Running in non-interactive mode\")\n\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\n\tvar spinner format.SpinnerInterface\n\tif !quiet {\n\t\tt := styles.CurrentTheme()\n\n\t\t// Detect background color to set the appropriate color for the\n\t\t// spinner's 'Generating...' text. Without this, that text would be\n\t\t// unreadable in light terminals.\n\n\t\tspinner = format.NewSpinnerInterface(ctx, cancel, format.Settings{\n\t\t\tSize:       10,\n\t\t\tLabel:      \"Generating\",\n\t\t\tLabelColor: styles.ColorToHex(t.Primary),\n\t\t\tColorStart: styles.ColorToHex(t.Primary),\n\t\t\tColorEnd:   styles.ColorToHex(t.Secondary),\n\t\t})\n\t\tspinner.Start()\n\t}\n\n\t// Helper function to stop spinner once.\n\tstopSpinner := func() {\n\t\tif !quiet && spinner != nil {\n\t\t\tspinner.Stop()\n\t\t\tspinner = nil\n\t\t}\n\t}\n\tdefer stopSpinner()\n\n\tconst maxPromptLengthForTitle = 100\n\tconst titlePrefix = \"Non-interactive: \"\n\tvar titleSuffix string\n\n\tif len(prompt) > maxPromptLengthForTitle {\n\t\ttitleSuffix = prompt[:maxPromptLengthForTitle] + \"...\"\n\t} else {\n\t\ttitleSuffix = prompt\n\t}\n\ttitle := titlePrefix + titleSuffix\n\n\tsess, err := app.Sessions.Create(ctx, title)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session for non-interactive mode: %w\", err)\n\t}\n\tslog.Info(\"Created session for non-interactive run\", \"session_id\", sess.ID)\n\n\t// Automatically approve all permission requests for this non-interactive\n\t// session.\n\tapp.Permissions.AutoApproveSession(sess.ID)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_response_205": {
      "name": "response",
      "type": "struct",
      "start_line": 205,
      "end_line": 280,
      "content_hash": "17ee708fecc6a93504f025c7f8c58799a121c17c",
      "content": "\ttype response struct {\n\t\tresult *fantasy.AgentResult\n\t\terr    error\n\t}\n\tdone := make(chan response, 1)\n\n\tgo func(ctx context.Context, sessionID, prompt string) {\n\t\tresult, err := app.AgentCoordinator.Run(ctx, sess.ID, prompt)\n\t\tif err != nil {\n\t\t\tdone <- response{\n\t\t\t\terr: fmt.Errorf(\"failed to start agent processing stream: %w\", err),\n\t\t\t}\n\t\t}\n\t\tdone <- response{\n\t\t\tresult: result,\n\t\t}\n\t}(ctx, sess.ID, prompt)\n\n\tmessageEvents := app.Messages.Subscribe(ctx)\n\tmessageReadBytes := make(map[string]int)\n\tsupportsProgressBar := term.SupportsProgressBar()\n\n\tdefer func() {\n\t\tif supportsProgressBar {\n\t\t\t_, _ = fmt.Fprintf(os.Stderr, ansi.ResetProgressBar)\n\t\t}\n\n\t\t// Always print a newline at the end. If output is a TTY this will\n\t\t// prevent the prompt from overwriting the last line of output.\n\t\t_, _ = fmt.Fprintln(output)\n\t}()\n\n\tfor {\n\t\tif supportsProgressBar {\n\t\t\t// HACK: Reinitialize the terminal progress bar on every iteration so\n\t\t\t// it doesn't get hidden by the terminal due to inactivity.\n\t\t\t_, _ = fmt.Fprintf(os.Stderr, ansi.SetIndeterminateProgressBar)\n\t\t}\n\n\t\tselect {\n\t\tcase result := <-done:\n\t\t\tstopSpinner()\n\t\t\tif result.err != nil {\n\t\t\t\tif errors.Is(result.err, context.Canceled) || errors.Is(result.err, agent.ErrRequestCancelled) {\n\t\t\t\t\tslog.Info(\"Non-interactive: agent processing cancelled\", \"session_id\", sess.ID)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"agent processing failed: %w\", result.err)\n\t\t\t}\n\t\t\treturn nil\n\n\t\tcase event := <-messageEvents:\n\t\t\tmsg := event.Payload\n\t\t\tif msg.SessionID == sess.ID && msg.Role == message.Assistant && len(msg.Parts) > 0 {\n\t\t\t\tstopSpinner()\n\n\t\t\t\tcontent := msg.Content().String()\n\t\t\t\treadBytes := messageReadBytes[msg.ID]\n\n\t\t\t\tif len(content) < readBytes {\n\t\t\t\t\tslog.Error(\"Non-interactive: message content is shorter than read bytes\", \"message_length\", len(content), \"read_bytes\", readBytes)\n\t\t\t\t\treturn fmt.Errorf(\"message content is shorter than read bytes: %d < %d\", len(content), readBytes)\n\t\t\t\t}\n\n\t\t\t\tpart := content[readBytes:]\n\t\t\t\tfmt.Fprint(output, part)\n\t\t\t\tmessageReadBytes[msg.ID] = len(content)\n\t\t\t}\n\n\t\tcase <-ctx.Done():\n\t\t\tstopSpinner()\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_UpdateAgentModel_281": {
      "name": "UpdateAgentModel",
      "type": "method",
      "start_line": 281,
      "end_line": 287,
      "content_hash": "6cd644133a89ce88c6efd472b68278f8ec987ec0",
      "content": "func (app *App) UpdateAgentModel(ctx context.Context) error {\n\tif app.AgentCoordinator == nil {\n\t\treturn fmt.Errorf(\"agent configuration is missing\")\n\t}\n\treturn app.AgentCoordinator.UpdateModels(ctx)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupEvents_288": {
      "name": "setupEvents",
      "type": "method",
      "start_line": 288,
      "end_line": 338,
      "content_hash": "5e72fea300de38571104c78f30a4d94f4c789e67",
      "content": "func (app *App) setupEvents() {\n\tctx, cancel := context.WithCancel(app.globalCtx)\n\tapp.eventsCtx = ctx\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"sessions\", app.Sessions.Subscribe, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"messages\", app.Messages.Subscribe, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"permissions\", app.Permissions.Subscribe, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"permissions-notifications\", app.Permissions.SubscribeNotifications, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"history\", app.History.Subscribe, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"mcp\", mcp.SubscribeEvents, app.events)\n\tsetupSubscriber(ctx, app.serviceEventsWG, \"lsp\", SubscribeLSPEvents, app.events)\n\tcleanupFunc := func() error {\n\t\tcancel()\n\t\tapp.serviceEventsWG.Wait()\n\t\treturn nil\n\t}\n\tapp.cleanupFuncs = append(app.cleanupFuncs, cleanupFunc)\n}\n\nfunc setupSubscriber[T any](\n\tctx context.Context,\n\twg *sync.WaitGroup,\n\tname string,\n\tsubscriber func(context.Context) <-chan pubsub.Event[T],\n\toutputCh chan<- tea.Msg,\n) {\n\twg.Go(func() {\n\t\tsubCh := subscriber(ctx)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event, ok := <-subCh:\n\t\t\t\tif !ok {\n\t\t\t\t\tslog.Debug(\"subscription channel closed\", \"name\", name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar msg tea.Msg = event\n\t\t\t\tselect {\n\t\t\t\tcase outputCh <- msg:\n\t\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t\t\tslog.Warn(\"message dropped due to slow consumer\", \"name\", name)\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tslog.Debug(\"subscription cancelled\", \"name\", name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\tslog.Debug(\"subscription cancelled\", \"name\", name)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_InitCoderAgent_339": {
      "name": "InitCoderAgent",
      "type": "method",
      "start_line": 339,
      "end_line": 379,
      "content_hash": "66b20a49e7285878de94c6a0a766bc9544d6af0c",
      "content": "func (app *App) InitCoderAgent(ctx context.Context) error {\n\tcoderAgentCfg := app.config.Agents[config.AgentCoder]\n\tif coderAgentCfg.ID == \"\" {\n\t\treturn fmt.Errorf(\"coder agent configuration is missing\")\n\t}\n\tvar err error\n\t// Initialize session logging manager\n\tsessionLogMgr, err := sessionlog.NewManager(sessionlog.Config{\n\t\tPostgresConnStr: os.Getenv(\"NEXORA_SESSION_LOG_DSN\"),\n\t\tInstanceID:      os.Getenv(\"NEXORA_INSTANCE_ID\"),\n\t\tEnabled:         os.Getenv(\"NEXORA_SESSION_LOG_ENABLED\") != \"false\",\n\t\tBatchSize:       50,\n\t\tBatchTimeout:    100 * time.Millisecond,\n\t})\n\tif err != nil {\n\t\tslog.Warn(\"Failed to initialize session logging, continuing without it\", \"error\", err)\n\t\tsessionLogMgr = nil\n\t} else {\n\t\tsessionlog.SetGlobalManager(sessionLogMgr)\n\t}\n\n\tapp.AgentCoordinator, err = agent.NewCoordinator(\n\t\tctx,\n\t\tapp.config,\n\t\tapp.Sessions,\n\t\tapp.Messages,\n\t\tapp.Permissions,\n\t\tapp.History,\n\t\tapp.LSPClients,\n\t\tapp.AIOPS,\n\t\tsessionLogMgr,\n\t\tapp.ResourceMonitor,\n\t)\n\tif err != nil {\n\t\tslog.Error(\"Failed to create coder agent\", \"err\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Subscribe sends events to the TUI as tea.Msgs.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Subscribe_380": {
      "name": "Subscribe",
      "type": "method",
      "start_line": 380,
      "end_line": 411,
      "content_hash": "2912f2a012f2f4fb0274542c1d71b5c37b2a5ab3",
      "content": "func (app *App) Subscribe(program *tea.Program) {\n\tdefer log.RecoverPanic(\"app.Subscribe\", func() {\n\t\tslog.Info(\"TUI subscription panic: attempting graceful shutdown\")\n\t\tprogram.Quit()\n\t})\n\n\tapp.tuiWG.Add(1)\n\ttuiCtx, tuiCancel := context.WithCancel(app.globalCtx)\n\tapp.cleanupFuncs = append(app.cleanupFuncs, func() error {\n\t\tslog.Debug(\"Cancelling TUI message handler\")\n\t\ttuiCancel()\n\t\tapp.tuiWG.Wait()\n\t\treturn nil\n\t})\n\tdefer app.tuiWG.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase <-tuiCtx.Done():\n\t\t\tslog.Debug(\"TUI message handler shutting down\")\n\t\t\treturn\n\t\tcase msg, ok := <-app.events:\n\t\t\tif !ok {\n\t\t\t\tslog.Debug(\"TUI message channel closed\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tprogram.Send(msg)\n\t\t}\n\t}\n}\n\n// Shutdown performs a graceful shutdown of the application.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Shutdown_412": {
      "name": "Shutdown",
      "type": "method",
      "start_line": 412,
      "end_line": 455,
      "content_hash": "23587c3ba9bea765010e071d5a952aca9c822b65",
      "content": "func (app *App) Shutdown() {\n\tif app == nil {\n\t\treturn\n\t}\n\n\tstart := time.Now()\n\tdefer func() { slog.Info(\"Shutdown took \" + time.Since(start).String()) }()\n\tvar wg sync.WaitGroup\n\tif app.AgentCoordinator != nil {\n\t\twg.Go(func() {\n\t\t\tapp.AgentCoordinator.CancelAll()\n\t\t})\n\t}\n\n\t// Kill all background shells.\n\twg.Go(func() {\n\t\tshell.GetBackgroundShellManager().KillAll()\n\t})\n\n\t// Shutdown all LSP clients.\n\tfor name, client := range app.LSPClients.Seq2() {\n\t\twg.Go(func() {\n\t\t\tshutdownCtx, cancel := context.WithTimeout(app.globalCtx, 5*time.Second)\n\t\t\tdefer cancel()\n\t\t\tif err := client.Close(shutdownCtx); err != nil {\n\t\t\t\tslog.Error(\"Failed to shutdown LSP client\", \"name\", name, \"error\", err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Call call cleanup functions.\n\tfor _, cleanup := range app.cleanupFuncs {\n\t\tif cleanup != nil {\n\t\t\twg.Go(func() {\n\t\t\t\tif err := cleanup(); err != nil {\n\t\t\t\t\tslog.Error(\"Failed to cleanup app properly on shutdown\", \"error\", err)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\twg.Wait()\n}\n\n// checkForUpdates checks for available updates.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkForUpdates_456": {
      "name": "checkForUpdates",
      "type": "method",
      "start_line": 456,
      "end_line": 469,
      "content_hash": "d9cfc99fc23a99469c265d5627ee8ed04b9398db",
      "content": "func (app *App) checkForUpdates(ctx context.Context) {\n\tcheckCtx, cancel := context.WithTimeout(ctx, 30*time.Second)\n\tdefer cancel()\n\n\tinfo, err := update.Check(checkCtx, version.Version, update.Default)\n\tif err != nil || !info.Available() {\n\t\treturn\n\t}\n\tapp.events <- pubsub.UpdateAvailableMsg{\n\t\tCurrentVersion: info.Current,\n\t\tLatestVersion:  info.Latest,\n\t\tIsDevelopment:  info.IsDevelopment(),\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}