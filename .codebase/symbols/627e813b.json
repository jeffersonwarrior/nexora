{
  "file_path": "/work/context-engine/scripts/ingest/metadata.py",
  "file_hash": "e73238e2b83c07858d100f4882e6281ab74a93f1",
  "updated_at": "2025-12-26T17:34:24.172944",
  "symbols": {
    "function__git_metadata_17": {
      "name": "_git_metadata",
      "type": "function",
      "start_line": 17,
      "end_line": 55,
      "content_hash": "843bb0026d7352c32cb1619ab699b64c3477e30a",
      "content": "def _git_metadata(file_path: Path) -> Tuple[int, int, int]:\n    \"\"\"Return (last_modified_at, churn_count, author_count) using git when available.\n    \n    Falls back to fs mtime and zeros when not in a repo.\n    \"\"\"\n    try:\n        import subprocess\n\n        fp = str(file_path)\n        # last commit unix timestamp (%ct)\n        ts = subprocess.run(\n            [\"git\", \"log\", \"-1\", \"--format=%ct\", \"--\", fp],\n            capture_output=True,\n            text=True,\n            cwd=file_path.parent,\n        ).stdout.strip()\n        last_ts = int(ts) if ts.isdigit() else int(file_path.stat().st_mtime)\n        # churn: number of commits touching this file (bounded)\n        churn_s = subprocess.run(\n            [\"git\", \"rev-list\", \"--count\", \"HEAD\", \"--\", fp],\n            capture_output=True,\n            text=True,\n            cwd=file_path.parent,\n        ).stdout.strip()\n        churn = int(churn_s) if churn_s.isdigit() else 0\n        # author count\n        authors = subprocess.run(\n            [\"git\", \"shortlog\", \"-s\", \"--\", fp],\n            capture_output=True,\n            text=True,\n            cwd=file_path.parent,\n        ).stdout\n        author_count = len([ln for ln in authors.splitlines() if ln.strip()])\n        return last_ts, churn, author_count\n    except Exception:\n        try:\n            return int(file_path.stat().st_mtime), 0, 0\n        except Exception:\n            return int(time.time()), 0, 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_imports_58": {
      "name": "_extract_imports",
      "type": "function",
      "start_line": 58,
      "end_line": 200,
      "content_hash": "ef4e4dd38ae9657edf9478451770366d44242d3f",
      "content": "def _extract_imports(language: str, text: str) -> List[str]:\n    \"\"\"Lightweight import extraction per language (best-effort).\"\"\"\n    lines = text.splitlines()\n    imps: List[str] = []\n    if language == \"python\":\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+([\\w\\.]+)\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*from\\s+([\\w\\.]+)\\s+import\\s+\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language in (\"javascript\", \"typescript\"):\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+.*?from\\s+['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            # Match require statements: require('x'), const x = require('x'), etc.\n            m = re.search(r\"require\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"go\":\n        block = False\n        for ln in lines:\n            if re.match(r\"^\\s*import\\s*\\(\", ln):\n                block = True\n                continue\n            if block:\n                if \")\" in ln:\n                    block = False\n                    continue\n                m = re.match(r\"^\\s*\\\"([^\\\"]+)\\\"\", ln)\n                if m:\n                    imps.append(m.group(1))\n                    continue\n            m = re.match(r\"^\\s*import\\s+\\\"([^\\\"]+)\\\"\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"java\":\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+([\\w\\.\\*]+);\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"csharp\":\n        for ln in lines:\n            # Match: using System; using static System.Math; using Alias = System.Text;\n            m = re.match(r\"^\\s*using\\s+(?:static\\s+)?([A-Za-z_][\\w\\._]*)\\s*;\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            # Match alias: using Alias = Namespace.Type;\n            m = re.match(r\"^\\s*using\\s+\\w+\\s*=\\s*([A-Za-z_][\\w\\._]*)\\s*;\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"php\":\n        for ln in lines:\n            m = re.match(r\"^\\s*use\\s+(?:function\\s+|const\\s+)?([A-Za-z_][A-Za-z0-9_\\\\\\\\]*)\\s*;\", ln)\n            if m:\n                imps.append(m.group(1).replace(\"\\\\\\\\\", \"\\\\\"))\n                continue\n        for ln in lines:\n            m = re.match(r\"^\\s*(?:include|include_once|require|require_once)\\s*\\(?\\s*['\\\"]([^'\\\"]+)['\\\"]\\s*\\)?\\s*;\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"rust\":\n        for ln in lines:\n            m = re.match(r\"^\\s*use\\s+([^;]+);\", ln)\n            if m:\n                imps.append(m.group(1).strip())\n                continue\n    elif language in (\"c\", \"cpp\"):\n        for ln in lines:\n            m = re.match(r'^\\s*#include\\s*[<\"]([^>\"]+)[>\"]', ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"ruby\":\n        for ln in lines:\n            m = re.match(r\"^\\s*require\\s+['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*require_relative\\s+['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*load\\s+['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"kotlin\":\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+([\\w\\.\\*]+)\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"swift\":\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+(\\w+)\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"scala\":\n        for ln in lines:\n            m = re.match(r\"^\\s*import\\s+([\\w\\.\\{\\}\\,\\s_]+)\", ln)\n            if m:\n                imps.append(m.group(1).strip())\n                continue\n    elif language == \"terraform\":\n        for ln in lines:\n            m = re.match(r\"^\\s*source\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*provider\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]\", ln)\n            if m:\n                imps.append(m.group(1))\n                continue\n    elif language == \"powershell\":\n        for ln in lines:\n            m = re.match(\n                r\"^\\s*Import-Module\\s+([A-Za-z0-9_.\\-]+)\", ln, flags=re.IGNORECASE\n            )\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*using\\s+module\\s+([^\\s;]+)\", ln, flags=re.IGNORECASE)\n            if m:\n                imps.append(m.group(1))\n                continue\n            m = re.match(r\"^\\s*using\\s+namespace\\s+([^\\s;]+)\", ln, flags=re.IGNORECASE)\n            if m:\n                imps.append(m.group(1))\n                continue\n    return imps[:200]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_calls_203": {
      "name": "_extract_calls",
      "type": "function",
      "start_line": 203,
      "end_line": 222,
      "content_hash": "ad4bb752ee7d359f823570695b3e28a19811ca13",
      "content": "def _extract_calls(language: str, text: str) -> List[str]:\n    \"\"\"Lightweight call-site extraction (best-effort, language-agnostic heuristics).\"\"\"\n    names: List[str] = []\n    # Simple heuristic: word followed by '(' that isn't a keyword\n    kw = set([\n        \"if\", \"for\", \"while\", \"switch\", \"return\", \"new\",\n        \"catch\", \"func\", \"def\", \"class\", \"match\",\n    ])\n    for m in re.finditer(r\"\\b([A-Za-z_][A-Za-z0-9_]*)\\s*\\(\", text):\n        name = m.group(1)\n        if name not in kw:\n            names.append(name)\n    # Deduplicate preserving order\n    out: List[str] = []\n    seen = set()\n    for n in names:\n        if n not in seen:\n            out.append(n)\n            seen.add(n)\n    return out[:200]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_calls_generic_244": {
      "name": "_ts_extract_calls_generic",
      "type": "function",
      "start_line": 244,
      "end_line": 302,
      "content_hash": "71cebd510262998a8e979dbfcf0ac64d27a306f3",
      "content": "def _ts_extract_calls_generic(language: str, text: str) -> List[str]:\n    \"\"\"Extract function/method calls using tree-sitter for any supported language.\"\"\"\n    from scripts.ingest.tree_sitter import _ts_parser\n    \n    parser = _ts_parser(language)\n    if not parser:\n        return _extract_calls(language, text)\n    \n    data = text.encode(\"utf-8\")\n    try:\n        tree = parser.parse(data)\n        if tree is None:\n            return _extract_calls(language, text)\n        root = tree.root_node\n    except Exception:\n        return _extract_calls(language, text)\n    \n    def node_text(n):\n        return data[n.start_byte:n.end_byte].decode(\"utf-8\", errors=\"ignore\")\n    \n    calls: List[str] = []\n    call_types = set(_TS_CALL_NODE_TYPES.get(language, [\"call_expression\"]))\n    \n    def walk(n):\n        if n.type in call_types:\n            # Try to get function name from various field names\n            func = (\n                n.child_by_field_name(\"function\") or\n                n.child_by_field_name(\"method\") or\n                n.child_by_field_name(\"name\")\n            )\n            if func:\n                name = node_text(func)\n                # Extract just the function/method name, not object.method chains\n                # Split on . : -> and take the last part\n                base = re.split(r\"[\\.:>\\-]+\", name)[-1].strip()\n                if base and re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", base):\n                    calls.append(base)\n            else:\n                # Fallback: try first child for languages like Ruby\n                for child in n.children:\n                    if child.type in (\"identifier\", \"constant\"):\n                        name = node_text(child)\n                        if name and re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", name):\n                            calls.append(name)\n                        break\n        for c in n.children:\n            walk(c)\n    \n    walk(root)\n    \n    # Deduplicate preserving order\n    seen = set()\n    calls_dedup = []\n    for x in calls:\n        if x not in seen:\n            calls_dedup.append(x)\n            seen.add(x)\n    return calls_dedup[:200]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_text_261": {
      "name": "node_text",
      "type": "function",
      "start_line": 261,
      "end_line": 262,
      "content_hash": "c78f09be7187c2e706bf8895e3c38d7c86524167",
      "content": "    def node_text(n):\n        return data[n.start_byte:n.end_byte].decode(\"utf-8\", errors=\"ignore\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_267": {
      "name": "walk",
      "type": "function",
      "start_line": 267,
      "end_line": 291,
      "content_hash": "239bc20aea704400edcb42166d77446f5c2b00b7",
      "content": "    def walk(n):\n        if n.type in call_types:\n            # Try to get function name from various field names\n            func = (\n                n.child_by_field_name(\"function\") or\n                n.child_by_field_name(\"method\") or\n                n.child_by_field_name(\"name\")\n            )\n            if func:\n                name = node_text(func)\n                # Extract just the function/method name, not object.method chains\n                # Split on . : -> and take the last part\n                base = re.split(r\"[\\.:>\\-]+\", name)[-1].strip()\n                if base and re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", base):\n                    calls.append(base)\n            else:\n                # Fallback: try first child for languages like Ruby\n                for child in n.children:\n                    if child.type in (\"identifier\", \"constant\"):\n                        name = node_text(child)\n                        if name and re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", name):\n                            calls.append(name)\n                        break\n        for c in n.children:\n            walk(c)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__get_imports_calls_305": {
      "name": "_get_imports_calls",
      "type": "function",
      "start_line": 305,
      "end_line": 318,
      "content_hash": "40b47c4dc0c101b22131ce613d2021fd5324b3e4",
      "content": "def _get_imports_calls(language: str, text: str) -> Tuple[List[str], List[str]]:\n    \"\"\"Get imports and calls for a file, using tree-sitter when available.\"\"\"\n    from scripts.ingest.tree_sitter import _use_tree_sitter, _ts_parser\n    \n    # Use tree-sitter for Python (specialized) or generic for other supported languages\n    if _use_tree_sitter():\n        if language == \"python\":\n            return _ts_extract_imports_calls_python(text)\n        elif language in _TS_CALL_LANGUAGES:\n            imports = _extract_imports(language, text)\n            calls = _ts_extract_calls_generic(language, text)\n            return imports, calls\n    \n    return _extract_imports(language, text), _extract_calls(language, text)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__ts_extract_imports_calls_python_321": {
      "name": "_ts_extract_imports_calls_python",
      "type": "function",
      "start_line": 321,
      "end_line": 373,
      "content_hash": "14172909b8a1757172de6c4ddfdae771d5671e99",
      "content": "def _ts_extract_imports_calls_python(text: str) -> Tuple[List[str], List[str]]:\n    \"\"\"Extract imports and calls from Python using tree-sitter.\"\"\"\n    from scripts.ingest.tree_sitter import _ts_parser\n    \n    parser = _ts_parser(\"python\")\n    if not parser:\n        return [], []\n    data = text.encode(\"utf-8\")\n    try:\n        tree = parser.parse(data)\n        if tree is None:\n            return [], []\n        root = tree.root_node\n    except (ValueError, Exception):\n        return [], []\n\n    def node_text(n):\n        return data[n.start_byte : n.end_byte].decode(\"utf-8\", errors=\"ignore\")\n\n    imports: List[str] = []\n    calls: List[str] = []\n\n    def walk(n):\n        t = n.type\n        if t == \"import_statement\":\n            s = node_text(n)\n            m = re.search(r\"\\bimport\\s+([\\w\\.]+)\", s)\n            if m:\n                imports.append(m.group(1))\n        elif t == \"import_from_statement\":\n            s = node_text(n)\n            m = re.search(r\"\\bfrom\\s+([\\w\\.]+)\\s+import\\b\", s)\n            if m:\n                imports.append(m.group(1))\n        elif t == \"call\":\n            func = n.child_by_field_name(\"function\")\n            if func:\n                name = node_text(func)\n                base = re.split(r\"[\\.:]\", name)[-1]\n                if re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", base):\n                    calls.append(base)\n        for c in n.children:\n            walk(c)\n\n    walk(root)\n    # Deduplicate preserving order\n    seen = set()\n    calls_dedup = []\n    for x in calls:\n        if x not in seen:\n            calls_dedup.append(x)\n            seen.add(x)\n    return imports[:200], calls_dedup[:200]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_text_337": {
      "name": "node_text",
      "type": "function",
      "start_line": 337,
      "end_line": 338,
      "content_hash": "9613be95103394eefbe61850c1b35819d4554f5e",
      "content": "    def node_text(n):\n        return data[n.start_byte : n.end_byte].decode(\"utf-8\", errors=\"ignore\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_walk_343": {
      "name": "walk",
      "type": "function",
      "start_line": 343,
      "end_line": 363,
      "content_hash": "e1814b67be9a3b5fb400ba0f4620c2ba75252dc3",
      "content": "    def walk(n):\n        t = n.type\n        if t == \"import_statement\":\n            s = node_text(n)\n            m = re.search(r\"\\bimport\\s+([\\w\\.]+)\", s)\n            if m:\n                imports.append(m.group(1))\n        elif t == \"import_from_statement\":\n            s = node_text(n)\n            m = re.search(r\"\\bfrom\\s+([\\w\\.]+)\\s+import\\b\", s)\n            if m:\n                imports.append(m.group(1))\n        elif t == \"call\":\n            func = n.child_by_field_name(\"function\")\n            if func:\n                name = node_text(func)\n                base = re.split(r\"[\\.:]\", name)[-1]\n                if re.match(r\"^[A-Za-z_][A-Za-z0-9_]*$\", base):\n                    calls.append(base)\n        for c in n.children:\n            walk(c)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__get_host_path_from_origin_376": {
      "name": "_get_host_path_from_origin",
      "type": "function",
      "start_line": 376,
      "end_line": 385,
      "content_hash": "15426ae970fbb8e88ce7c680d8a6e7a612f7db93",
      "content": "def _get_host_path_from_origin(workspace_path: str, repo_name: str = None) -> Optional[str]:\n    \"\"\"Get client host_path from origin source_path in workspace state.\"\"\"\n    try:\n        from scripts.workspace_state import get_workspace_state\n        state = get_workspace_state(workspace_path, repo_name)\n        if state and state.get(\"origin\", {}).get(\"source_path\"):\n            return state[\"origin\"][\"source_path\"]\n    except Exception:\n        pass\n    return None",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__compute_host_and_container_paths_388": {
      "name": "_compute_host_and_container_paths",
      "type": "function",
      "start_line": 388,
      "end_line": 434,
      "content_hash": "7321e459c76f5c726dfb4f76004f3eb998521711",
      "content": "def _compute_host_and_container_paths(cur_path: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Compute host_path and container_path for a given absolute path.\"\"\"\n    _host_root = str(os.environ.get(\"HOST_INDEX_PATH\") or \"\").strip().rstrip(\"/\")\n    if \":\" in _host_root:\n        _host_root = \"\"\n    _host_path: Optional[str] = None\n    _container_path: Optional[str] = None\n    _origin_client_path: Optional[str] = None\n\n    try:\n        if cur_path.startswith(\"/work/\"):\n            _parts = cur_path[6:].split(\"/\")\n            if len(_parts) >= 2:\n                _repo_name = _parts[0]\n                _workspace_path = f\"/work/{_repo_name}\"\n                _origin_client_path = _get_host_path_from_origin(\n                    _workspace_path, _repo_name\n                )\n    except Exception:\n        _origin_client_path = None\n\n    try:\n        if cur_path.startswith(\"/work/\") and (_host_root or _origin_client_path):\n            _rel = cur_path[len(\"/work/\"):]\n            if _origin_client_path:\n                _parts = _rel.split(\"/\", 1)\n                _tail = _parts[1] if len(_parts) > 1 else \"\"\n                _base = _origin_client_path.rstrip(\"/\")\n                _host_path = (\n                    os.path.realpath(os.path.join(_base, _tail)) if _tail else _base\n                )\n            else:\n                _host_path = os.path.realpath(os.path.join(_host_root, _rel))\n            _container_path = cur_path\n        else:\n            _host_path = cur_path\n            if (\n                (_host_root or _origin_client_path)\n                and cur_path.startswith(((_origin_client_path or _host_root) + \"/\"))\n            ):\n                _rel = cur_path[len((_origin_client_path or _host_root)) + 1:]\n                _container_path = \"/work/\" + _rel\n    except Exception:\n        _host_path = cur_path\n        _container_path = cur_path if cur_path.startswith(\"/work/\") else None\n\n    return _host_path, _container_path",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}