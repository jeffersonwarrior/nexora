{
  "file_path": "/work/internal/agent/prompt/prompt_test.go",
  "file_hash": "bf64437772988de21fa9d6784fd6d0cc77c3ddca",
  "updated_at": "2025-12-26T17:34:23.809284",
  "symbols": {
    "function_TestPromptDataEnvironment_13": {
      "name": "TestPromptDataEnvironment",
      "type": "function",
      "start_line": 13,
      "end_line": 124,
      "content_hash": "3947d3de8f33b23e68262783373dc0280d2543d3",
      "content": "func TestPromptDataEnvironment(t *testing.T) {\n\t// Create a test config\n\ttempDir := t.TempDir()\n\tcfg, err := config.Load(tempDir, tempDir, false)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Create prompt with fixed time\n\tfixedTime := time.Date(2025, 12, 17, 22, 46, 11, 0, time.UTC)\n\tp, err := NewPrompt(\"test\", \"{{.DateTime}}\", WithTimeFunc(func() time.Time {\n\t\treturn fixedTime\n\t}), WithWorkingDir(tempDir))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create prompt: %v\", err)\n\t}\n\n\t// Get prompt data\n\tctx := context.Background()\n\tdata, err := p.promptData(ctx, \"test-provider\", \"test-model\", *cfg)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get prompt data: %v\", err)\n\t}\n\n\t// Verify new fields exist\n\tt.Run(\"DateTime\", func(t *testing.T) {\n\t\tif data.DateTime == \"\" {\n\t\t\tt.Error(\"DateTime should not be empty\")\n\t\t}\n\t\tif !strings.Contains(data.DateTime, \"2025\") {\n\t\t\tt.Errorf(\"DateTime should contain year 2025, got: %s\", data.DateTime)\n\t\t}\n\t})\n\n\tt.Run(\"CurrentUser\", func(t *testing.T) {\n\t\tif data.CurrentUser == \"\" {\n\t\t\tt.Error(\"CurrentUser should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"LocalIP\", func(t *testing.T) {\n\t\t// Should be either a valid IP or \"unavailable\"\n\t\tif data.LocalIP == \"\" {\n\t\t\tt.Error(\"LocalIP should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"RuntimeVersions\", func(t *testing.T) {\n\t\t// These should be set (either version or \"not installed\")\n\t\tif data.PythonVersion == \"\" {\n\t\t\tt.Error(\"PythonVersion should not be empty\")\n\t\t}\n\t\tif data.NodeVersion == \"\" {\n\t\t\tt.Error(\"NodeVersion should not be empty\")\n\t\t}\n\t\tif data.GoVersion == \"\" {\n\t\t\tt.Error(\"GoVersion should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"ShellType\", func(t *testing.T) {\n\t\tif data.ShellType == \"\" {\n\t\t\tt.Error(\"ShellType should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"SystemResources\", func(t *testing.T) {\n\t\tif data.MemoryInfo == \"\" {\n\t\t\tt.Error(\"MemoryInfo should not be empty\")\n\t\t}\n\t\tif data.DiskInfo == \"\" {\n\t\t\tt.Error(\"DiskInfo should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"Architecture\", func(t *testing.T) {\n\t\tif data.Architecture == \"\" {\n\t\t\tt.Error(\"Architecture should not be empty\")\n\t\t}\n\t\tt.Logf(\"Architecture: %s\", data.Architecture)\n\t})\n\n\tt.Run(\"ContainerType\", func(t *testing.T) {\n\t\tif data.ContainerType == \"\" {\n\t\t\tt.Error(\"ContainerType should not be empty\")\n\t\t}\n\t\tt.Logf(\"ContainerType: %s\", data.ContainerType)\n\t})\n\n\tt.Run(\"TerminalInfo\", func(t *testing.T) {\n\t\tif data.TerminalInfo == \"\" {\n\t\t\tt.Error(\"TerminalInfo should not be empty\")\n\t\t}\n\t\tt.Logf(\"TerminalInfo: %s\", data.TerminalInfo)\n\t})\n\n\tt.Run(\"NetworkStatus\", func(t *testing.T) {\n\t\tif data.NetworkStatus == \"\" {\n\t\t\tt.Error(\"NetworkStatus should not be empty\")\n\t\t}\n\t\tt.Logf(\"NetworkStatus: %s\", data.NetworkStatus)\n\t})\n\n\tt.Run(\"ActiveServices\", func(t *testing.T) {\n\t\tif data.ActiveServices == \"\" {\n\t\t\tt.Log(\"ActiveServices is empty (expected when NEXORA_FULL_ENV not set)\")\n\t\t} else {\n\t\t\tt.Logf(\"ActiveServices: %s\", data.ActiveServices)\n\t\t}\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestPromptBuildWithEnvironment_125": {
      "name": "TestPromptBuildWithEnvironment",
      "type": "function",
      "start_line": 125,
      "end_line": 170,
      "content_hash": "40282fd97d37c92093807f857d17713fa50d50d6",
      "content": "func TestPromptBuildWithEnvironment(t *testing.T) {\n\ttempDir := t.TempDir()\n\tcfg, err := config.Load(tempDir, tempDir, false)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\ttemplate := `## Environment\nDate/Time: {{.DateTime}}\nOS: {{.Platform}} ({{.Architecture}}){{if ne .ContainerType \"none\"}} - Running in {{.ContainerType}}{{end}}\nUser: {{.CurrentUser}}\nPython: {{.PythonVersion}}\nMemory: {{.MemoryInfo}}\nTerminal: {{.TerminalInfo}}\nNetwork: {{.NetworkStatus}}\nServices: {{.ActiveServices}}\n`\n\n\tp, err := NewPrompt(\"test\", template, WithWorkingDir(tempDir))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create prompt: %v\", err)\n\t}\n\n\tctx := context.Background()\n\toutput, err := p.Build(ctx, \"test-provider\", \"test-model\", *cfg)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to build prompt: %v\", err)\n\t}\n\n\t// Verify output contains expected sections\n\tif !strings.Contains(output, \"## Environment\") {\n\t\tt.Error(\"Output should contain Environment section\")\n\t}\n\tif !strings.Contains(output, \"Date/Time:\") {\n\t\tt.Error(\"Output should contain Date/Time\")\n\t}\n\tif !strings.Contains(output, \"OS:\") {\n\t\tt.Error(\"Output should contain OS\")\n\t}\n\tif !strings.Contains(output, \"User:\") {\n\t\tt.Error(\"Output should contain User\")\n\t}\n\n\tt.Logf(\"Generated prompt output:\\n%s\", output)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestEnvironmentHelpers_171": {
      "name": "TestEnvironmentHelpers",
      "type": "function",
      "start_line": 171,
      "end_line": 255,
      "content_hash": "61801fa15ff05205e37a5ce3fb1d44f3c3e1dc2e",
      "content": "func TestEnvironmentHelpers(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"getCurrentUser\", func(t *testing.T) {\n\t\tuser := getCurrentUser()\n\t\tif user == \"\" || user == \"unknown\" {\n\t\t\tt.Skip(\"Unable to get current user\")\n\t\t}\n\t\tt.Logf(\"Current user: %s\", user)\n\t})\n\n\tt.Run(\"getLocalIP\", func(t *testing.T) {\n\t\tip := getLocalIP(ctx)\n\t\tt.Logf(\"Local IP: %s\", ip)\n\t\tif ip == \"\" {\n\t\t\tt.Error(\"LocalIP should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"getRuntimeVersion\", func(t *testing.T) {\n\t\tpython := getRuntimeVersion(ctx, \"python3 --version\")\n\t\tt.Logf(\"Python: %s\", python)\n\n\t\tnode := getRuntimeVersion(ctx, \"node --version\")\n\t\tt.Logf(\"Node: %s\", node)\n\n\t\tgoVer := getRuntimeVersion(ctx, \"go version\")\n\t\tt.Logf(\"Go: %s\", goVer)\n\t})\n\n\tt.Run(\"getMemoryInfo\", func(t *testing.T) {\n\t\tmem := getMemoryInfo(ctx)\n\t\tt.Logf(\"Memory: %s\", mem)\n\t\tif mem == \"\" {\n\t\t\tt.Error(\"MemoryInfo should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"getDiskInfo\", func(t *testing.T) {\n\t\tcwd, _ := os.Getwd()\n\t\tdisk := getDiskInfo(ctx, cwd)\n\t\tt.Logf(\"Disk: %s\", disk)\n\t\tif disk == \"\" {\n\t\t\tt.Error(\"DiskInfo should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"getArchitecture\", func(t *testing.T) {\n\t\tarch := getArchitecture()\n\t\tt.Logf(\"Architecture: %s\", arch)\n\t\tif arch == \"\" {\n\t\t\tt.Error(\"Architecture should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"detectContainer\", func(t *testing.T) {\n\t\tcontainer := detectContainer(ctx)\n\t\tt.Logf(\"Container: %s\", container)\n\t\tif container == \"\" {\n\t\t\tt.Error(\"ContainerType should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"getTerminalInfo\", func(t *testing.T) {\n\t\tterminal := getTerminalInfo(ctx)\n\t\tt.Logf(\"Terminal: %s\", terminal)\n\t\tif terminal == \"\" {\n\t\t\tt.Error(\"TerminalInfo should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"getNetworkStatus\", func(t *testing.T) {\n\t\tnetwork := getNetworkStatus(ctx)\n\t\tt.Logf(\"Network: %s\", network)\n\t\tif network == \"\" {\n\t\t\tt.Error(\"NetworkStatus should not be empty\")\n\t\t}\n\t})\n\n\tt.Run(\"detectActiveServices\", func(t *testing.T) {\n\t\tservices := detectActiveServices(ctx)\n\t\tt.Logf(\"Services: %s\", services)\n\t\t// Services may be empty depending on system state\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}