{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/vector_serde_tests.rs",
  "file_hash": "9fb3abd8fed85d63c0a5f424e6344f565c287c4c",
  "updated_at": "2025-12-26T17:34:20.431319",
  "symbols": {
    "function_test_vector_empty_properties_roundtrip_27": {
      "name": "test_vector_empty_properties_roundtrip",
      "type": "function",
      "start_line": 27,
      "end_line": 52,
      "content_hash": "271d3f833915f8d2ee153e41cec5bc341bc8bd6a",
      "content": "    fn test_vector_empty_properties_roundtrip() {\n        let arena = Bump::new();\n        let id = 12345u128;\n        let data = vec![1.0, 2.0, 3.0, 4.0];\n\n        let vector = create_simple_vector(&arena, id, \"test_vector\", &data);\n\n        // Serialize properties (should be minimal since no properties)\n        let props_bytes = bincode::serialize(&vector).unwrap();\n\n        // Serialize vector data\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Deserialize\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_single_property_roundtrip_53": {
      "name": "test_vector_with_single_property_roundtrip",
      "type": "function",
      "start_line": 53,
      "end_line": 75,
      "content_hash": "f90c5c117ed9e34e69a4a12e12a4eb5c12aa0c70",
      "content": "    fn test_vector_with_single_property_roundtrip() {\n        let arena = Bump::new();\n        let id = 99999u128;\n        let data = vec![0.5, -0.5, 1.5, -1.5];\n        let props = vec![(\"name\", Value::String(\"test\".to_string()))];\n\n        let vector = create_arena_vector(&arena, id, \"labeled_vector\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_multiple_properties_roundtrip_76": {
      "name": "test_vector_with_multiple_properties_roundtrip",
      "type": "function",
      "start_line": 76,
      "end_line": 102,
      "content_hash": "82b32b16e798bd2db6ee5b682d01e8a8c89f0329",
      "content": "    fn test_vector_with_multiple_properties_roundtrip() {\n        let arena = Bump::new();\n        let id = 555555u128;\n        let data = vec![1.1, 2.2, 3.3, 4.4, 5.5];\n        let props = vec![\n            (\"name\", Value::String(\"multi_prop_vector\".to_string())),\n            (\"version\", Value::I32(2)),\n            (\"score\", Value::F64(0.95)),\n        ];\n\n        let vector = create_arena_vector(&arena, id, \"vector_label\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_all_value_types_103": {
      "name": "test_vector_with_all_value_types",
      "type": "function",
      "start_line": 103,
      "end_line": 125,
      "content_hash": "5fd2e19df62b2d180d3a988bd38573fe920bb9ee",
      "content": "    fn test_vector_with_all_value_types() {\n        let arena = Bump::new();\n        let id = 777777u128;\n        let data = vec![0.0; 128]; // Standard embedding dimension\n        let props = all_value_types_props();\n\n        let vector = create_arena_vector(&arena, id, \"all_types\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_nested_values_126": {
      "name": "test_vector_with_nested_values",
      "type": "function",
      "start_line": 126,
      "end_line": 157,
      "content_hash": "5cf3bf587fd0e26a5389ab9b45df915e26cc0331",
      "content": "    fn test_vector_with_nested_values() {\n        let arena = Bump::new();\n        let id = 888888u128;\n        let data = vec![1.0, 2.0, 3.0];\n        let props = nested_value_props();\n\n        let vector = create_arena_vector(&arena, id, \"nested\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(\n            &arena2,\n            Some(&props_bytes),\n            data_bytes,\n            id,\n        ).unwrap();\n\n        // Just verify basic structure instead of deep equality due to HashMap ordering\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"nested\");\n        assert_eq!(deserialized.data.len(), 3);\n        assert!(deserialized.properties.is_some());\n        assert_eq!(deserialized.properties.unwrap().len(), 3);\n    }\n\n    // ========================================================================\n    // RAW VECTOR DATA CASTING TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_to_bytes_128d_158": {
      "name": "test_vector_data_to_bytes_128d",
      "type": "function",
      "start_line": 158,
      "end_line": 169,
      "content_hash": "7995d95785470ab5aa373883198e7e9edcb0c18d",
      "content": "    fn test_vector_data_to_bytes_128d() {\n        let arena = Bump::new();\n        let id = 111111u128;\n        let data: Vec<f64> = (0..128).map(|i| i as f64 * 0.1).collect();\n\n        let vector = create_simple_vector(&arena, id, \"vector_128\", &data);\n        let bytes = vector.vector_data_to_bytes().unwrap();\n\n        assert_eq!(bytes.len(), 128 * 8); // 128 dimensions * 8 bytes per f64\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_to_bytes_384d_170": {
      "name": "test_vector_data_to_bytes_384d",
      "type": "function",
      "start_line": 170,
      "end_line": 181,
      "content_hash": "4cecb6800e18168bf62f64640baa9ae12de3f065",
      "content": "    fn test_vector_data_to_bytes_384d() {\n        let arena = Bump::new();\n        let id = 222222u128;\n        let data: Vec<f64> = (0..384).map(|i| i as f64 * 0.01).collect();\n\n        let vector = create_simple_vector(&arena, id, \"vector_384\", &data);\n        let bytes = vector.vector_data_to_bytes().unwrap();\n\n        assert_eq!(bytes.len(), 384 * 8);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_to_bytes_1536d_182": {
      "name": "test_vector_data_to_bytes_1536d",
      "type": "function",
      "start_line": 182,
      "end_line": 193,
      "content_hash": "57c4d1d0f9932e91f1f16887e1890d0e07737e5c",
      "content": "    fn test_vector_data_to_bytes_1536d() {\n        let arena = Bump::new();\n        let id = 333333u128;\n        let data: Vec<f64> = (0..1536).map(|i| (i as f64).sin()).collect();\n\n        let vector = create_simple_vector(&arena, id, \"vector_1536\", &data);\n        let bytes = vector.vector_data_to_bytes().unwrap();\n\n        assert_eq!(bytes.len(), 1536 * 8);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_cast_raw_vector_data_128d_194": {
      "name": "test_cast_raw_vector_data_128d",
      "type": "function",
      "start_line": 194,
      "end_line": 207,
      "content_hash": "91f3b4eb374196e2766249f72618d768fa3bcc10",
      "content": "    fn test_cast_raw_vector_data_128d() {\n        let arena = Bump::new();\n        let original_data: Vec<f64> = (0..128).map(|i| i as f64).collect();\n        let raw_bytes = create_vector_bytes(&original_data);\n\n        let casted_data = HVector::cast_raw_vector_data(&arena, &raw_bytes);\n\n        assert_eq!(casted_data.len(), 128);\n        for (i, &val) in casted_data.iter().enumerate() {\n            assert!((val - original_data[i]).abs() < 1e-10);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_cast_raw_vector_data_roundtrip_208": {
      "name": "test_cast_raw_vector_data_roundtrip",
      "type": "function",
      "start_line": 208,
      "end_line": 221,
      "content_hash": "8af435b7d6db7228f66f4169154813606ded9555",
      "content": "    fn test_cast_raw_vector_data_roundtrip() {\n        let arena = Bump::new();\n        let original_data = vec![3.14159, 2.71828, 1.41421, 1.73205];\n        let raw_bytes = create_vector_bytes(&original_data);\n\n        let casted_data = HVector::cast_raw_vector_data(&arena, &raw_bytes);\n\n        assert_eq!(casted_data.len(), original_data.len());\n        for (orig, casted) in original_data.iter().zip(casted_data.iter()) {\n            assert!((orig - casted).abs() < 1e-10);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_from_raw_vector_data_222": {
      "name": "test_from_raw_vector_data",
      "type": "function",
      "start_line": 222,
      "end_line": 244,
      "content_hash": "c42af41cce8ca9841d53cc46dbba254eaead96d6",
      "content": "    fn test_from_raw_vector_data() {\n        let arena = Bump::new();\n        let id = 444444u128;\n        let label = arena.alloc_str(\"raw_vector\");\n        let data = vec![1.0, 2.0, 3.0, 4.0];\n        let raw_bytes = create_vector_bytes(&data);\n\n        let vector = HVector::from_raw_vector_data(&arena, &raw_bytes, label, id).unwrap();\n\n        assert_eq!(vector.id, id);\n        assert_eq!(vector.label, label);\n        assert_eq!(vector.data.len(), 4);\n        assert_eq!(vector.version, 1);\n        assert_eq!(vector.deleted, false);\n        assert_eq!(vector.level, 0);\n        assert!(vector.properties.is_none());\n    }\n\n    // ========================================================================\n    // COMBINED PROPERTIES + RAW DATA DESERIALIZATION\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_combined_empty_props_with_data_245": {
      "name": "test_combined_empty_props_with_data",
      "type": "function",
      "start_line": 245,
      "end_line": 265,
      "content_hash": "8dc37c5a6a63b01fdfe329c8de23a206c792ce58",
      "content": "    fn test_combined_empty_props_with_data() {\n        let arena = Bump::new();\n        let id = 555666u128;\n        let data = vec![0.1, 0.2, 0.3];\n\n        let vector = create_simple_vector(&arena, id, \"combined_test\", &data);\n\n        // Serialize properties (empty)\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Deserialize combining both\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_combined_with_props_and_data_266": {
      "name": "test_combined_with_props_and_data",
      "type": "function",
      "start_line": 266,
      "end_line": 288,
      "content_hash": "84d0acb30b6f68b99deaa6eb0ae69978948c6883",
      "content": "    fn test_combined_with_props_and_data() {\n        let arena = Bump::new();\n        let id = 666777u128;\n        let data = vec![1.5, 2.5, 3.5, 4.5];\n        let props = vec![\n            (\"model\", Value::String(\"text-embedding-3\".to_string())),\n            (\"dimension\", Value::I32(4)),\n        ];\n\n        let vector = create_arena_vector(&arena, id, \"embedding\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_vectors_semantically_equal(&vector, &deserialized);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_combined_none_props_with_data_289": {
      "name": "test_combined_none_props_with_data",
      "type": "function",
      "start_line": 289,
      "end_line": 314,
      "content_hash": "f3a2af481e0f774bb8aea11c6c979aaf1fc2979f",
      "content": "    fn test_combined_none_props_with_data() {\n        let arena = Bump::new();\n        let id = 777888u128;\n        let data = vec![9.9, 8.8, 7.7];\n\n        let vector = create_simple_vector(&arena, id, \"no_props\", &data);\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        // Deserialize with serialized empty properties\n        let arena2 = Bump::new();\n        let result = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id);\n\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"no_props\");\n        assert_eq!(deserialized.data.len(), 3);\n        assert!(deserialized.properties.is_none());\n    }\n\n    // ========================================================================\n    // VECTOR WITHOUT DATA TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_without_data_serialization_315": {
      "name": "test_vector_without_data_serialization",
      "type": "function",
      "start_line": 315,
      "end_line": 349,
      "content_hash": "145e3318dccf43c90d934e4558ecd2ee4b571ecb",
      "content": "    fn test_vector_without_data_serialization() {\n        let arena = Bump::new();\n        let id = 999000u128;\n        let label = arena.alloc_str(\"metadata_only\");\n        let props = vec![(\"type\", Value::String(\"embedding\".to_string()))];\n        let len = props.len();\n        let props_iter = props.into_iter().map(|(k, v)| {\n            let key: &str = arena.alloc_str(k);\n            (key, v)\n        });\n        let props_map = crate::utils::properties::ImmutablePropertiesMap::new(len, props_iter, &arena);\n\n        let vector_without_data = VectorWithoutData {\n            id,\n            label,\n            version: 1,\n            deleted: false,\n            level: 0,\n            properties: Some(props_map),\n        };\n\n        // Serialize and deserialize\n        let bytes = bincode::serialize(&vector_without_data).unwrap();\n        let arena2 = Bump::new();\n        let result = VectorWithoutData::from_bincode_bytes(&arena2, &bytes, id);\n        println!(\"{:?}\", result);\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, label);\n        assert_eq!(deserialized.version, 1);\n        assert_eq!(deserialized.deleted, false);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_without_data_empty_properties_350": {
      "name": "test_vector_without_data_empty_properties",
      "type": "function",
      "start_line": 350,
      "end_line": 378,
      "content_hash": "5ce789dbbf7152b02c3528002e1279463b221930",
      "content": "    fn test_vector_without_data_empty_properties() {\n        let arena = Bump::new();\n        let id = 111000u128;\n        let label = arena.alloc_str(\"empty_meta\");\n\n        let vector_without_data = VectorWithoutData {\n            id,\n            label,\n            version: 1,\n            deleted: false,\n            level: 0,\n            properties: None,\n        };\n\n        let bytes = bincode::serialize(&vector_without_data).unwrap();\n        let arena2 = Bump::new();\n        let result = VectorWithoutData::from_bincode_bytes(&arena2, &bytes, id);\n\n        assert!(result.is_ok());\n        let deserialized = result.unwrap();\n        assert_eq!(deserialized.id, id);\n        assert!(deserialized.properties.is_none());\n    }\n\n    // ========================================================================\n    // VERSION AND FLAGS TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_version_field_379": {
      "name": "test_vector_with_version_field",
      "type": "function",
      "start_line": 379,
      "end_line": 395,
      "content_hash": "7bad0e83ae91a6b47434b1b3976dfbc07211ce6e",
      "content": "    fn test_vector_with_version_field() {\n        let arena = Bump::new();\n        let id = 123456u128;\n        let data = vec![1.0, 2.0];\n\n        let vector = create_arena_vector(&arena, id, \"versioned\", 5, false, 0, &data, vec![]);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.version, 5);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_deleted_flag_true_396": {
      "name": "test_vector_deleted_flag_true",
      "type": "function",
      "start_line": 396,
      "end_line": 412,
      "content_hash": "98edf0fb80f2293736eb61d05ac1fe8588d953a0",
      "content": "    fn test_vector_deleted_flag_true() {\n        let arena = Bump::new();\n        let id = 654321u128;\n        let data = vec![0.0, 1.0];\n\n        let vector = create_arena_vector(&arena, id, \"deleted\", 1, true, 0, &data, vec![]);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.deleted, true);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_deleted_flag_false_413": {
      "name": "test_vector_deleted_flag_false",
      "type": "function",
      "start_line": 413,
      "end_line": 433,
      "content_hash": "fdc0b5457145a2709dbd71210bc213054540f0d7",
      "content": "    fn test_vector_deleted_flag_false() {\n        let arena = Bump::new();\n        let id = 987654u128;\n        let data = vec![1.0, 0.0];\n\n        let vector = create_arena_vector(&arena, id, \"active\", 1, false, 0, &data, vec![]);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.deleted, false);\n    }\n\n    // ========================================================================\n    // UTF-8 AND LABEL TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_utf8_label_434": {
      "name": "test_vector_utf8_label",
      "type": "function",
      "start_line": 434,
      "end_line": 450,
      "content_hash": "47e1905eda48a65339696b9fb7eb812fe1369553",
      "content": "    fn test_vector_utf8_label() {\n        let arena = Bump::new();\n        let id = 135790u128;\n        let data = vec![1.0, 2.0, 3.0];\n\n        let vector = create_simple_vector(&arena, id, \"\u5411\u91cf\u6d4b\u8bd5\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.label, \"\u5411\u91cf\u6d4b\u8bd5\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_emoji_label_451": {
      "name": "test_vector_emoji_label",
      "type": "function",
      "start_line": 451,
      "end_line": 467,
      "content_hash": "a016937c0e9c2418302a17911c8de109c93d5109",
      "content": "    fn test_vector_emoji_label() {\n        let arena = Bump::new();\n        let id = 246801u128;\n        let data = vec![0.5];\n\n        let vector = create_simple_vector(&arena, id, \"\ud83d\ude80\ud83d\udd25\ud83d\udcaf\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.label, \"\ud83d\ude80\ud83d\udd25\ud83d\udcaf\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_empty_label_468": {
      "name": "test_vector_empty_label",
      "type": "function",
      "start_line": 468,
      "end_line": 484,
      "content_hash": "8f2797cd126768d76d594afea7c1e41a10d55718",
      "content": "    fn test_vector_empty_label() {\n        let arena = Bump::new();\n        let id = 369258u128;\n        let data = vec![1.0];\n\n        let vector = create_simple_vector(&arena, id, \"\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.label, \"\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_very_long_label_485": {
      "name": "test_vector_very_long_label",
      "type": "function",
      "start_line": 485,
      "end_line": 507,
      "content_hash": "05e6421e77d6123083294471f8f4d52af01210bf",
      "content": "    fn test_vector_very_long_label() {\n        let arena = Bump::new();\n        let id = 147258u128;\n        let data = vec![1.0, 2.0];\n        let long_label = \"a\".repeat(1000);\n\n        let vector = create_simple_vector(&arena, id, &long_label, &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.label.len(), 1000);\n        assert_eq!(deserialized.label, long_label);\n    }\n\n    // ========================================================================\n    // PROPERTY MAP SIZE TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_with_many_properties_508": {
      "name": "test_vector_with_many_properties",
      "type": "function",
      "start_line": 508,
      "end_line": 534,
      "content_hash": "3e796c6f1245f6efb6b6db730c6236c6ceeda2b5",
      "content": "    fn test_vector_with_many_properties() {\n        let arena = Bump::new();\n        let id = 753951u128;\n        let data = vec![1.0, 2.0, 3.0];\n        let props: Vec<(&str, Value)> = (0..50)\n            .map(|i| {\n                let key: &str = arena.alloc_str(&format!(\"key_{}\", i));\n                (key, Value::I32(i))\n            })\n            .collect();\n\n        let vector = create_arena_vector(&arena, id, \"many_props\", 1, false, 0, &data, props);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.properties.unwrap().len(), 50);\n    }\n\n    // ========================================================================\n    // DIMENSION EDGE CASES\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_single_dimension_535": {
      "name": "test_vector_single_dimension",
      "type": "function",
      "start_line": 535,
      "end_line": 552,
      "content_hash": "4e0fd6a15a535aca6b443b6979802e978d6d4771",
      "content": "    fn test_vector_single_dimension() {\n        let arena = Bump::new();\n        let id = 159357u128;\n        let data = vec![42.0];\n\n        let vector = create_simple_vector(&arena, id, \"1d\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.data.len(), 1);\n        assert!((deserialized.data[0] - 42.0).abs() < 1e-10);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_large_dimension_4096_553": {
      "name": "test_vector_large_dimension_4096",
      "type": "function",
      "start_line": 553,
      "end_line": 573,
      "content_hash": "2a4ad29e92195997a18ec074f8ffeebf76df53a3",
      "content": "    fn test_vector_large_dimension_4096() {\n        let arena = Bump::new();\n        let id = 951753u128;\n        let data: Vec<f64> = (0..4096).map(|i| i as f64 * 0.001).collect();\n\n        let vector = create_simple_vector(&arena, id, \"4096d\", &data);\n\n        let props_bytes = bincode::serialize(&vector).unwrap();\n        let data_bytes = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = HVector::from_bincode_bytes(&arena2, Some(&props_bytes), data_bytes, id).unwrap();\n\n        assert_eq!(deserialized.data.len(), 4096);\n    }\n\n    // ========================================================================\n    // BYTE-LEVEL VERIFICATION TESTS\n    // ========================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_byte_level_roundtrip_574": {
      "name": "test_vector_byte_level_roundtrip",
      "type": "function",
      "start_line": 574,
      "end_line": 598,
      "content_hash": "f753a449fb19558c300aa1c8bcc2aa45a4a84bfa",
      "content": "    fn test_vector_byte_level_roundtrip() {\n        let arena = Bump::new();\n        let id = 112233u128;\n        let data = vec![1.1, 2.2, 3.3];\n        let props = vec![(\"test\", Value::String(\"value\".to_string()))];\n\n        let vector = create_arena_vector(&arena, id, \"byte_test\", 1, false, 0, &data, props);\n\n        // First roundtrip\n        let props_bytes1 = bincode::serialize(&vector).unwrap();\n        let data_bytes1 = vector.vector_data_to_bytes().unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized1 = HVector::from_bincode_bytes(&arena2, Some(&props_bytes1), data_bytes1, id).unwrap();\n\n        // Second roundtrip\n        let props_bytes2 = bincode::serialize(&deserialized1).unwrap();\n        let data_bytes2 = deserialized1.vector_data_to_bytes().unwrap();\n\n        // Bytes should be identical across roundtrips\n        assert_eq!(props_bytes1, props_bytes2);\n        assert_eq!(data_bytes1, data_bytes2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_data_bytes_consistency_599": {
      "name": "test_vector_data_bytes_consistency",
      "type": "function",
      "start_line": 599,
      "end_line": 615,
      "content_hash": "afde08ea57913351750198ab07ef8299f159abd2",
      "content": "    fn test_vector_data_bytes_consistency() {\n        let arena = Bump::new();\n        let id = 445566u128;\n        let data = vec![3.14159, 2.71828, 1.41421];\n\n        let vector = create_simple_vector(&arena, id, \"consistency\", &data);\n\n        // Call vector_data_to_bytes multiple times\n        let bytes1 = vector.vector_data_to_bytes().unwrap();\n        let bytes2 = vector.vector_data_to_bytes().unwrap();\n        let bytes3 = vector.vector_data_to_bytes().unwrap();\n\n        // All calls should produce identical bytes\n        assert_eq!(bytes1, bytes2);\n        assert_eq!(bytes2, bytes3);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}