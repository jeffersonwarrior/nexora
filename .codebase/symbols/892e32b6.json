{
  "file_path": "/work/external-deps/claude-swarm/src/dashboard/server.ts",
  "file_hash": "c2fa6107cbef6a13a8345f1a2b06fbda6e74f218",
  "updated_at": "2025-12-26T17:34:22.848463",
  "symbols": {
    "function_startDashboardServer_54": {
      "name": "startDashboardServer",
      "type": "function",
      "start_line": 54,
      "end_line": 788,
      "content_hash": "d4efd88741e4a971eab6d558ca69f1afa1691bc7",
      "content": "export async function startDashboardServer(\n  getStateManager: () => StateManager | null,\n  options: DashboardServerOptions = {}\n): Promise<DashboardServer> {\n  const port = options.port || 3456;\n  const host = options.host || \"127.0.0.1\";\n\n  const app = express();\n\n  // SSE client management\n  const sseClients: SSEClient[] = [];\n  let lastSnapshot: StateSnapshot | null = null;\n  let ssePollingInterval: NodeJS.Timeout | null = null;\n\n  // Generate unique client ID\n  const generateClientId = () => `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n  // Send SSE event to all connected clients\n  const broadcastSSE = (eventType: string, data: unknown) => {\n    const message = `event: ${eventType}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n    sseClients.forEach((client) => {\n      try {\n        client.res.write(message);\n      } catch (err) {\n        // Client disconnected, will be cleaned up\n      }\n    });\n  };\n\n  // Create a snapshot of current state for change detection\n  const createSnapshot = (state: OrchestratorState | null): StateSnapshot => {\n    if (!state) {\n      return {\n        status: null,\n        features: new Map(),\n        logCount: 0,\n        workerCount: 0,\n      };\n    }\n\n    const features = new Map<string, string>();\n    let workerCount = 0;\n    for (const f of state.features) {\n      features.set(f.id, f.status);\n      if (f.status === \"in_progress\" && f.workerId) {\n        workerCount++;\n      }\n    }\n\n    return {\n      status: state.status,\n      features,\n      logCount: state.progressLog.length,\n      workerCount,\n    };\n  };\n\n  // Helper to get current state manager\n  const getState = () => {\n    const sm = getStateManager();\n    return sm ? sm.load() : null;\n  };\n\n  // Detect and broadcast changes between snapshots\n  const detectAndBroadcastChanges = (oldSnap: StateSnapshot | null, newSnap: StateSnapshot, state: OrchestratorState | null) => {\n    // Status change\n    if (!oldSnap || oldSnap.status !== newSnap.status) {\n      broadcastSSE(\"status\", {\n        status: newSnap.status,\n        projectDir: state?.projectDir,\n        taskDescription: state?.taskDescription,\n        startTime: state?.startTime,\n        lastUpdated: state?.lastUpdated,\n      });\n    }\n\n    // Feature changes\n    if (state) {\n      for (const feature of state.features) {\n        const oldStatus = oldSnap?.features.get(feature.id);\n        const newStatus = newSnap.features.get(feature.id);\n        if (oldStatus !== newStatus) {\n          broadcastSSE(\"feature\", {\n            id: feature.id,\n            description: feature.description,\n            status: feature.status,\n            attempts: feature.attempts,\n            workerId: feature.workerId,\n            startedAt: feature.startedAt,\n            completedAt: feature.completedAt,\n            lastError: feature.lastError,\n            notes: feature.notes,\n          });\n        }\n      }\n    }\n\n    // New log entries\n    if (state && oldSnap && newSnap.logCount > oldSnap.logCount) {\n      const newLogs = state.progressLog.slice(oldSnap.logCount);\n      for (const log of newLogs) {\n        const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n        broadcastSSE(\"log\", {\n          timestamp: match ? match[1] : new Date().toISOString(),\n          message: match ? match[2] : log,\n          raw: log,\n        });\n      }\n    }\n\n    // Worker count change\n    if (!oldSnap || oldSnap.workerCount !== newSnap.workerCount) {\n      broadcastSSE(\"worker\", {\n        activeCount: newSnap.workerCount,\n      });\n    }\n  };\n\n  // Start polling for state changes (called when first SSE client connects)\n  const startSSEPolling = () => {\n    if (ssePollingInterval) return;\n\n    ssePollingInterval = setInterval(() => {\n      if (sseClients.length === 0) {\n        // No clients, stop polling\n        if (ssePollingInterval) {\n          clearInterval(ssePollingInterval);\n          ssePollingInterval = null;\n        }\n        return;\n      }\n\n      const state = getState();\n      const newSnapshot = createSnapshot(state);\n      detectAndBroadcastChanges(lastSnapshot, newSnapshot, state);\n      lastSnapshot = newSnapshot;\n    }, 1000); // Check every 1 second\n  };\n\n  // CORS middleware for local development\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\");\n    res.header(\"Access-Control-Allow-Headers\", \"Content-Type\");\n    if (req.method === \"OPTIONS\") {\n      res.sendStatus(200);\n      return;\n    }\n    next();\n  });\n\n  // Serve static files from the public directory\n  // In dev: src/dashboard/public, in dist: dist/dashboard/public\n  const publicPath = path.join(__dirname, \"public\");\n  app.use(express.static(publicPath));\n\n  // Serve index.html for root path\n  app.get(\"/\", (req: Request, res: Response) => {\n    res.sendFile(path.join(publicPath, \"index.html\"));\n  });\n\n  // JSON response helper\n  const sendJson = (res: Response, data: unknown) => {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.json(data);\n  };\n\n  // Error handling wrapper\n  const asyncHandler = (\n    fn: (req: Request, res: Response) => Promise<void>\n  ) => {\n    return (req: Request, res: Response, next: NextFunction) => {\n      Promise.resolve(fn(req, res)).catch(next);\n    };\n  };\n\n  // ============================================================================\n  // GET /api/status - Session status overview\n  // ============================================================================\n  app.get(\n    \"/api/status\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const state = getState();\n\n      if (!state) {\n        sendJson(res, {\n          active: false,\n          message: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      const completed = state.features.filter((f) => f.status === \"completed\").length;\n      const failed = state.features.filter((f) => f.status === \"failed\").length;\n      const inProgress = state.features.filter((f) => f.status === \"in_progress\").length;\n      const pending = state.features.filter((f) => f.status === \"pending\").length;\n\n      const startTime = new Date(state.startTime);\n      const now = new Date();\n      const elapsedMs = now.getTime() - startTime.getTime();\n      const elapsed = formatDuration(startTime, now);\n\n      // Calculate success rate\n      const totalFinished = completed + failed;\n      const successRate = totalFinished > 0 ? completed / totalFinished : 0;\n\n      sendJson(res, {\n        active: true,\n        projectDir: state.projectDir,\n        status: state.status,\n        taskDescription: state.taskDescription,\n        startTime: state.startTime,\n        lastUpdated: state.lastUpdated,\n        completedAt: state.completedAt,\n        elapsed,\n        elapsedMs,\n        summary: {\n          total: state.features.length,\n          completed,\n          failed,\n          inProgress,\n          pending,\n          successRate: formatPercent(successRate),\n          successRateRaw: successRate,\n        },\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/features - Feature list with details\n  // ============================================================================\n  app.get(\n    \"/api/features\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const state = getState();\n\n      if (!state) {\n        sendJson(res, {\n          features: [],\n          message: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      // Optional status filter\n      const statusFilter = req.query.status as string | undefined;\n\n      let features = state.features;\n      if (statusFilter) {\n        features = features.filter((f) => f.status === statusFilter);\n      }\n\n      const featureData = features.map((f) => ({\n        id: f.id,\n        description: f.description,\n        status: f.status,\n        attempts: f.attempts,\n        workerId: f.workerId,\n        startedAt: f.startedAt,\n        completedAt: f.completedAt,\n        lastError: f.lastError,\n        notes: f.notes,\n        dependsOn: f.dependsOn,\n      }));\n\n      sendJson(res, {\n        features: featureData,\n        total: state.features.length,\n        filtered: featureData.length,\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/workers - Worker statuses\n  // ============================================================================\n  app.get(\n    \"/api/workers\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const state = getState();\n\n      if (!state) {\n        sendJson(res, {\n          workers: [],\n          message: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      // Create a temporary WorkerManager to check worker statuses\n      const sm = getStateManager();\n      if (!sm) {\n        sendJson(res, {\n          workers: [],\n          message: \"No state manager available\",\n        });\n        return;\n      }\n      const workerManager = new WorkerManager(sm.projectDir, sm);\n      const workerStatuses = await workerManager.checkAllWorkers();\n\n      const workerData = workerStatuses.map((w) => {\n        const feature = state.features.find((f) => f.id === w.featureId);\n        return {\n          sessionName: w.sessionName,\n          featureId: w.featureId,\n          featureDescription: feature?.description,\n          status: w.status,\n          startedAt: w.startedAt,\n          lastChecked: w.lastChecked,\n        };\n      });\n\n      // Summary counts\n      const running = workerData.filter((w) => w.status === \"running\").length;\n      const completed = workerData.filter((w) => w.status === \"completed\").length;\n      const crashed = workerData.filter((w) => w.status === \"crashed\").length;\n\n      sendJson(res, {\n        workers: workerData,\n        summary: {\n          total: workerData.length,\n          running,\n          completed,\n          crashed,\n        },\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/workers/:featureId/output - Stream worker terminal output via SSE\n  // ============================================================================\n  app.get(\n    \"/api/workers/:featureId/output\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const featureId = req.params.featureId;\n      const state = getState();\n\n      if (!state) {\n        res.status(404).json({\n          error: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      // Find the feature\n      const feature = state.features.find((f) => f.id === featureId);\n      if (!feature) {\n        res.status(404).json({\n          error: `Feature not found: ${featureId}`,\n        });\n        return;\n      }\n\n      // Check if feature has an active worker\n      if (!feature.workerId) {\n        res.status(404).json({\n          error: `No active worker for feature: ${featureId}`,\n        });\n        return;\n      }\n\n      // Set SSE headers\n      res.setHeader(\"Content-Type\", \"text/event-stream\");\n      res.setHeader(\"Cache-Control\", \"no-cache\");\n      res.setHeader(\"Connection\", \"keep-alive\");\n      res.setHeader(\"X-Accel-Buffering\", \"no\");\n      res.flushHeaders();\n\n      // Send initial output\n      const sendOutput = async () => {\n        try {\n          // Get the worker output using tmux capture-pane (100 lines)\n          const { execFile } = await import(\"child_process\");\n          const { promisify } = await import(\"util\");\n          const execFileAsync = promisify(execFile);\n\n          try {\n            const { stdout } = await execFileAsync(\"tmux\", [\n              \"capture-pane\",\n              \"-t\",\n              feature.workerId!,\n              \"-p\",\n              \"-S\",\n              \"-100\", // Last 100 lines\n            ]);\n\n            res.write(`event: output\\ndata: ${JSON.stringify({\n              featureId,\n              output: stdout,\n              timestamp: new Date().toISOString(),\n            })}\\n\\n`);\n          } catch (tmuxError: any) {\n            // Session might have ended\n            res.write(`event: ended\\ndata: ${JSON.stringify({\n              featureId,\n              message: \"Worker session ended or not found\",\n              timestamp: new Date().toISOString(),\n            })}\\n\\n`);\n            clearInterval(outputInterval);\n            res.end();\n          }\n        } catch (error: any) {\n          res.write(`event: error\\ndata: ${JSON.stringify({\n            featureId,\n            error: error.message,\n            timestamp: new Date().toISOString(),\n          })}\\n\\n`);\n        }\n      };\n\n      // Send initial output immediately\n      await sendOutput();\n\n      // Stream updates every 2 seconds\n      const outputInterval = setInterval(async () => {\n        // Check if feature still has active worker\n        const currentState = getState();\n        const currentFeature = currentState?.features.find((f) => f.id === featureId);\n\n        if (!currentFeature || !currentFeature.workerId) {\n          res.write(`event: ended\\ndata: ${JSON.stringify({\n            featureId,\n            message: \"Worker completed or stopped\",\n            timestamp: new Date().toISOString(),\n          })}\\n\\n`);\n          clearInterval(outputInterval);\n          res.end();\n          return;\n        }\n\n        await sendOutput();\n      }, 2000);\n\n      // Handle client disconnect\n      req.on(\"close\", () => {\n        clearInterval(outputInterval);\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/logs - Progress log entries\n  // ============================================================================\n  app.get(\n    \"/api/logs\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const state = getState();\n\n      if (!state) {\n        sendJson(res, {\n          logs: [],\n          message: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      // Optional limit parameter\n      const limitParam = req.query.limit as string | undefined;\n      const limit = limitParam ? parseInt(limitParam, 10) : undefined;\n\n      let logs = state.progressLog;\n      if (limit && limit > 0) {\n        logs = logs.slice(-limit);\n      }\n\n      // Parse logs into structured format\n      const parsedLogs = logs.map((log) => {\n        const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n        if (match) {\n          return {\n            timestamp: match[1],\n            message: match[2],\n            raw: log,\n          };\n        }\n        return {\n          timestamp: null,\n          message: log,\n          raw: log,\n        };\n      });\n\n      sendJson(res, {\n        logs: parsedLogs,\n        total: state.progressLog.length,\n        returned: parsedLogs.length,\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/stats - Session statistics\n  // ============================================================================\n  app.get(\n    \"/api/stats\",\n    asyncHandler(async (req: Request, res: Response) => {\n      const state = getState();\n\n      if (!state) {\n        sendJson(res, {\n          stats: null,\n          message: \"No active orchestration session\",\n        });\n        return;\n      }\n\n      const completed = state.features.filter((f) => f.status === \"completed\");\n      const failed = state.features.filter((f) => f.status === \"failed\");\n\n      // Calculate completion times\n      const completionTimes: number[] = [];\n      for (const feature of completed) {\n        if (feature.startedAt && feature.completedAt) {\n          const startTime = new Date(feature.startedAt).getTime();\n          const endTime = new Date(feature.completedAt).getTime();\n          if (startTime > 0 && endTime > startTime) {\n            completionTimes.push(endTime - startTime);\n          }\n        }\n      }\n\n      const avgCompletionTimeMs = calculateAverage(completionTimes);\n      const minCompletionTimeMs = completionTimes.length > 0 ? Math.min(...completionTimes) : 0;\n      const maxCompletionTimeMs = completionTimes.length > 0 ? Math.max(...completionTimes) : 0;\n\n      // Attempt statistics\n      const attemptCounts = state.features.map((f) => f.attempts);\n      const totalAttempts = attemptCounts.reduce((sum, val) => sum + val, 0);\n      const avgAttempts = calculateAverage(attemptCounts);\n      const maxAttempts = attemptCounts.length > 0 ? Math.max(...attemptCounts) : 0;\n\n      // Success rate\n      const totalFinished = completed.length + failed.length;\n      const successRate = totalFinished > 0 ? completed.length / totalFinished : 0;\n\n      // Total elapsed time\n      const startTime = new Date(state.startTime);\n      const now = new Date();\n      const totalElapsedMs = now.getTime() - startTime.getTime();\n\n      sendJson(res, {\n        stats: {\n          time: {\n            totalElapsedMs,\n            totalElapsed: formatDuration(startTime, now),\n            avgCompletionTimeMs,\n            avgCompletionTime: avgCompletionTimeMs > 0 ? formatDurationMs(avgCompletionTimeMs) : null,\n            minCompletionTimeMs,\n            minCompletionTime: minCompletionTimeMs > 0 ? formatDurationMs(minCompletionTimeMs) : null,\n            maxCompletionTimeMs,\n            maxCompletionTime: maxCompletionTimeMs > 0 ? formatDurationMs(maxCompletionTimeMs) : null,\n          },\n          success: {\n            rate: successRate,\n            rateFormatted: formatPercent(successRate),\n            completed: completed.length,\n            failed: failed.length,\n            total: state.features.length,\n          },\n          attempts: {\n            total: totalAttempts,\n            average: avgAttempts,\n            max: maxAttempts,\n          },\n        },\n      });\n    })\n  );\n\n  // ============================================================================\n  // GET /api/events - Server-Sent Events for real-time updates\n  // ============================================================================\n  app.get(\"/api/events\", (req: Request, res: Response) => {\n    // Set SSE headers\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    res.setHeader(\"X-Accel-Buffering\", \"no\"); // Disable nginx buffering\n    res.flushHeaders();\n\n    // Create client\n    const clientId = generateClientId();\n    const client: SSEClient = { id: clientId, res };\n    sseClients.push(client);\n\n    console.log(`SSE client connected: ${clientId} (total: ${sseClients.length})`);\n\n    // Send initial connection event\n    res.write(`event: connected\\ndata: ${JSON.stringify({ clientId, timestamp: new Date().toISOString() })}\\n\\n`);\n\n    // Send current state immediately\n    const state = getState();\n    if (state) {\n      // Send full status\n      res.write(`event: status\\ndata: ${JSON.stringify({\n        status: state.status,\n        projectDir: state.projectDir,\n        taskDescription: state.taskDescription,\n        startTime: state.startTime,\n        lastUpdated: state.lastUpdated,\n      })}\\n\\n`);\n\n      // Send all features\n      for (const feature of state.features) {\n        res.write(`event: feature\\ndata: ${JSON.stringify({\n          id: feature.id,\n          description: feature.description,\n          status: feature.status,\n          attempts: feature.attempts,\n          workerId: feature.workerId,\n          startedAt: feature.startedAt,\n          completedAt: feature.completedAt,\n          lastError: feature.lastError,\n          notes: feature.notes,\n        })}\\n\\n`);\n      }\n\n      // Initialize snapshot with current state\n      lastSnapshot = createSnapshot(state);\n    }\n\n    // Start SSE polling if not already running\n    startSSEPolling();\n\n    // Send heartbeat every 30 seconds to keep connection alive\n    const heartbeatInterval = setInterval(() => {\n      try {\n        res.write(`event: heartbeat\\ndata: ${JSON.stringify({ timestamp: new Date().toISOString() })}\\n\\n`);\n      } catch (err) {\n        clearInterval(heartbeatInterval);\n      }\n    }, 30000);\n\n    // Handle client disconnect\n    req.on(\"close\", () => {\n      clearInterval(heartbeatInterval);\n      const index = sseClients.findIndex((c) => c.id === clientId);\n      if (index !== -1) {\n        sseClients.splice(index, 1);\n      }\n      console.log(`SSE client disconnected: ${clientId} (remaining: ${sseClients.length})`);\n    });\n  });\n\n  // ============================================================================\n  // GET /health - Health check endpoint\n  // ============================================================================\n  app.get(\"/health\", (req: Request, res: Response) => {\n    sendJson(res, {\n      status: \"ok\",\n      timestamp: new Date().toISOString(),\n    });\n  });\n\n  // ============================================================================\n  // Error handling middleware\n  // ============================================================================\n  app.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n    console.error(\"Dashboard server error:\", err);\n    res.status(500).json({\n      error: \"Internal server error\",\n      message: err.message,\n    });\n  });\n\n  // ============================================================================\n  // 404 handler\n  // ============================================================================\n  app.use((req: Request, res: Response) => {\n    res.status(404).json({\n      error: \"Not found\",\n      path: req.path,\n      availableEndpoints: [\n        \"GET /api/status\",\n        \"GET /api/features\",\n        \"GET /api/features?status=pending|in_progress|completed|failed\",\n        \"GET /api/workers\",\n        \"GET /api/workers/:featureId/output (SSE)\",\n        \"GET /api/logs\",\n        \"GET /api/logs?limit=N\",\n        \"GET /api/stats\",\n        \"GET /api/events (SSE)\",\n        \"GET /health\",\n      ],\n    });\n  });\n\n  // Start the server\n  return new Promise((resolve, reject) => {\n    const server = app.listen(port, host, () => {\n      console.log(`Dashboard server running at http://${host}:${port}`);\n\n      const dashboardServer: DashboardServer = {\n        app,\n        server,\n        port,\n        close: async () => {\n          // Clean up SSE resources\n          if (ssePollingInterval) {\n            clearInterval(ssePollingInterval);\n            ssePollingInterval = null;\n          }\n          // Close all SSE client connections\n          for (const client of sseClients) {\n            try {\n              client.res.end();\n            } catch (err) {\n              // Ignore errors during cleanup\n            }\n          }\n          sseClients.length = 0;\n\n          return new Promise((resolveClose, rejectClose) => {\n            server.close((err) => {\n              if (err) {\n                rejectClose(err);\n              } else {\n                resolveClose();\n              }\n            });\n          });\n        },\n      };\n\n      resolve(dashboardServer);\n    });\n\n    server.on(\"error\", (err) => {\n      reject(err);\n    });\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_generateClientId_69": {
      "name": "generateClientId",
      "type": "function",
      "start_line": 69,
      "end_line": 69,
      "content_hash": "3c356faecff8d17ba5e62985e978b84cdff180e4",
      "content": "  const generateClientId = () => `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_broadcastSSE_72": {
      "name": "broadcastSSE",
      "type": "function",
      "start_line": 72,
      "end_line": 81,
      "content_hash": "103feebc6fe5f5bf9a8ef6cad068d9348811e66f",
      "content": "  const broadcastSSE = (eventType: string, data: unknown) => {\n    const message = `event: ${eventType}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n    sseClients.forEach((client) => {\n      try {\n        client.res.write(message);\n      } catch (err) {\n        // Client disconnected, will be cleaned up\n      }\n    });\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createSnapshot_84": {
      "name": "createSnapshot",
      "type": "function",
      "start_line": 84,
      "end_line": 109,
      "content_hash": "53959be536baf356372b624f2f6f40028ae4e64d",
      "content": "  const createSnapshot = (state: OrchestratorState | null): StateSnapshot => {\n    if (!state) {\n      return {\n        status: null,\n        features: new Map(),\n        logCount: 0,\n        workerCount: 0,\n      };\n    }\n\n    const features = new Map<string, string>();\n    let workerCount = 0;\n    for (const f of state.features) {\n      features.set(f.id, f.status);\n      if (f.status === \"in_progress\" && f.workerId) {\n        workerCount++;\n      }\n    }\n\n    return {\n      status: state.status,\n      features,\n      logCount: state.progressLog.length,\n      workerCount,\n    };\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getState_112": {
      "name": "getState",
      "type": "function",
      "start_line": 112,
      "end_line": 115,
      "content_hash": "8af3cf75bff6ec11d1b7bfae7ef6bfbf49f93e99",
      "content": "  const getState = () => {\n    const sm = getStateManager();\n    return sm ? sm.load() : null;\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_detectAndBroadcastChanges_118": {
      "name": "detectAndBroadcastChanges",
      "type": "function",
      "start_line": 118,
      "end_line": 170,
      "content_hash": "a55665d99873a5ed1c4d8c4e443e65589e4249b6",
      "content": "  const detectAndBroadcastChanges = (oldSnap: StateSnapshot | null, newSnap: StateSnapshot, state: OrchestratorState | null) => {\n    // Status change\n    if (!oldSnap || oldSnap.status !== newSnap.status) {\n      broadcastSSE(\"status\", {\n        status: newSnap.status,\n        projectDir: state?.projectDir,\n        taskDescription: state?.taskDescription,\n        startTime: state?.startTime,\n        lastUpdated: state?.lastUpdated,\n      });\n    }\n\n    // Feature changes\n    if (state) {\n      for (const feature of state.features) {\n        const oldStatus = oldSnap?.features.get(feature.id);\n        const newStatus = newSnap.features.get(feature.id);\n        if (oldStatus !== newStatus) {\n          broadcastSSE(\"feature\", {\n            id: feature.id,\n            description: feature.description,\n            status: feature.status,\n            attempts: feature.attempts,\n            workerId: feature.workerId,\n            startedAt: feature.startedAt,\n            completedAt: feature.completedAt,\n            lastError: feature.lastError,\n            notes: feature.notes,\n          });\n        }\n      }\n    }\n\n    // New log entries\n    if (state && oldSnap && newSnap.logCount > oldSnap.logCount) {\n      const newLogs = state.progressLog.slice(oldSnap.logCount);\n      for (const log of newLogs) {\n        const match = log.match(/^\\[([^\\]]+)\\]\\s*(.*)$/);\n        broadcastSSE(\"log\", {\n          timestamp: match ? match[1] : new Date().toISOString(),\n          message: match ? match[2] : log,\n          raw: log,\n        });\n      }\n    }\n\n    // Worker count change\n    if (!oldSnap || oldSnap.workerCount !== newSnap.workerCount) {\n      broadcastSSE(\"worker\", {\n        activeCount: newSnap.workerCount,\n      });\n    }\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_startSSEPolling_173": {
      "name": "startSSEPolling",
      "type": "function",
      "start_line": 173,
      "end_line": 191,
      "content_hash": "5feba1b7c1ffc717850ac8ffffb3d2a05f2839f9",
      "content": "  const startSSEPolling = () => {\n    if (ssePollingInterval) return;\n\n    ssePollingInterval = setInterval(() => {\n      if (sseClients.length === 0) {\n        // No clients, stop polling\n        if (ssePollingInterval) {\n          clearInterval(ssePollingInterval);\n          ssePollingInterval = null;\n        }\n        return;\n      }\n\n      const state = getState();\n      const newSnapshot = createSnapshot(state);\n      detectAndBroadcastChanges(lastSnapshot, newSnapshot, state);\n      lastSnapshot = newSnapshot;\n    }, 1000); // Check every 1 second\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_sendJson_216": {
      "name": "sendJson",
      "type": "function",
      "start_line": 216,
      "end_line": 219,
      "content_hash": "1b51c55fe2fc2ce2107ee8484eb28873b6851a8b",
      "content": "  const sendJson = (res: Response, data: unknown) => {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.json(data);\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_asyncHandler_222": {
      "name": "asyncHandler",
      "type": "function",
      "start_line": 222,
      "end_line": 228,
      "content_hash": "50f2940c9f85f02c3e8527e5a662ee8d087d81ce",
      "content": "  const asyncHandler = (\n    fn: (req: Request, res: Response) => Promise<void>\n  ) => {\n    return (req: Request, res: Response, next: NextFunction) => {\n      Promise.resolve(fn(req, res)).catch(next);\n    };\n  };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_sendOutput_426": {
      "name": "sendOutput",
      "type": "function",
      "start_line": 426,
      "end_line": 465,
      "content_hash": "b3167392bd91f034af575d649b425cc82d29930c",
      "content": "      const sendOutput = async () => {\n        try {\n          // Get the worker output using tmux capture-pane (100 lines)\n          const { execFile } = await import(\"child_process\");\n          const { promisify } = await import(\"util\");\n          const execFileAsync = promisify(execFile);\n\n          try {\n            const { stdout } = await execFileAsync(\"tmux\", [\n              \"capture-pane\",\n              \"-t\",\n              feature.workerId!,\n              \"-p\",\n              \"-S\",\n              \"-100\", // Last 100 lines\n            ]);\n\n            res.write(`event: output\\ndata: ${JSON.stringify({\n              featureId,\n              output: stdout,\n              timestamp: new Date().toISOString(),\n            })}\\n\\n`);\n          } catch (tmuxError: any) {\n            // Session might have ended\n            res.write(`event: ended\\ndata: ${JSON.stringify({\n              featureId,\n              message: \"Worker session ended or not found\",\n              timestamp: new Date().toISOString(),\n            })}\\n\\n`);\n            clearInterval(outputInterval);\n            res.end();\n          }\n        } catch (error: any) {\n          res.write(`event: error\\ndata: ${JSON.stringify({\n            featureId,\n            error: error.message,\n            timestamp: new Date().toISOString(),\n          })}\\n\\n`);\n        }\n      };",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}