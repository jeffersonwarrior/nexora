{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/storage_core/mod.rs",
  "file_hash": "8fcad9d79ee6d01e4a04e9fb4ad8583918eb0ac8",
  "updated_at": "2025-12-26T17:34:25.133722",
  "symbols": {
    "struct_StorageConfig_48": {
      "name": "StorageConfig",
      "type": "struct",
      "start_line": 48,
      "end_line": 53,
      "content_hash": "15878f1d25abf73ed0f71437955502e09c9b7635",
      "content": "pub struct StorageConfig {\n    pub schema: Option<String>,\n    pub graphvis_node_label: Option<String>,\n    pub embedding_model: Option<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HelixGraphStorage_54": {
      "name": "HelixGraphStorage",
      "type": "struct",
      "start_line": 54,
      "end_line": 69,
      "content_hash": "d80582a4900c26115028c881d462d51db9da873b",
      "content": "pub struct HelixGraphStorage {\n    pub graph_env: Env,\n\n    pub nodes_db: Database<U128<BE>, Bytes>,\n    pub edges_db: Database<U128<BE>, Bytes>,\n    pub out_edges_db: Database<Bytes, Bytes>,\n    pub in_edges_db: Database<Bytes, Bytes>,\n    pub secondary_indices: HashMap<String, Database<Bytes, U128<BE>>>,\n    pub vectors: VectorCore,\n    pub bm25: Option<HBM25Config>,\n    pub metadata_db: Database<Bytes, Bytes>,\n    pub version_info: VersionInfo,\n\n    pub storage_config: StorageConfig,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixGraphStorage_70": {
      "name": "HelixGraphStorage",
      "type": "impl",
      "start_line": 70,
      "end_line": 70,
      "content_hash": "2eaa0c4dc7625a14de9cc2078e4f9e772dd9f3d5",
      "content": "impl HelixGraphStorage {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_71": {
      "name": "new",
      "type": "method",
      "start_line": 71,
      "end_line": 204,
      "content_hash": "6fc19421448ba6cb30f4653ff17be36c6412c307",
      "content": "    pub fn new(\n        path: &str,\n        config: Config,\n        version_info: VersionInfo,\n    ) -> Result<HelixGraphStorage, GraphError> {\n        fs::create_dir_all(path)?;\n\n        let db_size = if config.db_max_size_gb.unwrap_or(100) >= 9999 {\n            9998\n        } else {\n            config.db_max_size_gb.unwrap_or(100)\n        };\n\n        let graph_env = unsafe {\n            EnvOpenOptions::new()\n                .map_size(db_size * 1024 * 1024 * 1024)\n                .max_dbs(200)\n                .max_readers(200)\n                .open(Path::new(path))?\n        };\n\n        let mut wtxn = graph_env.write_txn()?;\n\n        // creates the lmdb databases (tables)\n        // Table: [key]->[value]\n        //        [size]->[size]\n\n        // Nodes: [node_id]->[bytes array of node data]\n        //        [16 bytes]->[dynamic]\n        let nodes_db = graph_env\n            .database_options()\n            .types::<U128<BE>, Bytes>()\n            .name(DB_NODES)\n            .create(&mut wtxn)?;\n\n        // Edges: [edge_id]->[bytes array of edge data]\n        //        [16 bytes]->[dynamic]\n        let edges_db = graph_env\n            .database_options()\n            .types::<U128<BE>, Bytes>()\n            .name(DB_EDGES)\n            .create(&mut wtxn)?;\n\n        // Out edges: [from_node_id + label]->[edge_id + to_node_id]  (edge first because value is ordered by byte size)\n        //                    [20 + 4 bytes]->[16 + 16 bytes]\n        //\n        // DUP_SORT used to store all values of duplicated keys under a single key. Saves on space and requires a single read to get all values.\n        // DUP_FIXED used to ensure all values are the same size meaning 8 byte length header is discarded.\n        let out_edges_db: Database<Bytes, Bytes> = graph_env\n            .database_options()\n            .types::<Bytes, Bytes>()\n            .flags(DatabaseFlags::DUP_SORT | DatabaseFlags::DUP_FIXED)\n            .name(DB_OUT_EDGES)\n            .create(&mut wtxn)?;\n\n        // In edges: [to_node_id + label]->[edge_id + from_node_id]  (edge first because value is ordered by byte size)\n        //                 [20 + 4 bytes]->[16 + 16 bytes]\n        //\n        // DUP_SORT used to store all values of duplicated keys under a single key. Saves on space and requires a single read to get all values.\n        // DUP_FIXED used to ensure all values are the same size meaning 8 byte length header is discarded.\n        let in_edges_db: Database<Bytes, Bytes> = graph_env\n            .database_options()\n            .types::<Bytes, Bytes>()\n            .flags(DatabaseFlags::DUP_SORT | DatabaseFlags::DUP_FIXED)\n            .name(DB_IN_EDGES)\n            .create(&mut wtxn)?;\n\n        let metadata_db: Database<Bytes, Bytes> = graph_env\n            .database_options()\n            .types::<Bytes, Bytes>()\n            .name(DB_STORAGE_METADATA)\n            .create(&mut wtxn)?;\n\n        let mut secondary_indices = HashMap::new();\n        if let Some(indexes) = config.get_graph_config().secondary_indices {\n            for index in indexes {\n                secondary_indices.insert(\n                    index.clone(),\n                    graph_env\n                        .database_options()\n                        .types::<Bytes, U128<BE>>()\n                        .flags(DatabaseFlags::DUP_SORT) // DUP_SORT used to store all duplicated node keys under a single key. Saves on space and requires a single read to get all values.\n                        .name(&index)\n                        .create(&mut wtxn)?,\n                );\n            }\n        }\n        let vector_config = config.get_vector_config();\n        let vectors = VectorCore::new(\n            &graph_env,\n            &mut wtxn,\n            HNSWConfig::new(\n                vector_config.m,\n                vector_config.ef_construction,\n                vector_config.ef_search,\n            ),\n        )?;\n\n        let bm25 = config\n            .get_bm25()\n            .then(|| HBM25Config::new(&graph_env, &mut wtxn))\n            .transpose()?;\n\n        let storage_config = StorageConfig::new(\n            config.schema,\n            config.graphvis_node_label,\n            config.embedding_model,\n        );\n\n        wtxn.commit()?;\n\n        let mut storage = Self {\n            graph_env,\n            nodes_db,\n            edges_db,\n            out_edges_db,\n            in_edges_db,\n            secondary_indices,\n            vectors,\n            bm25,\n            metadata_db,\n            storage_config,\n            version_info,\n        };\n\n        storage_migration::migrate(&mut storage)?;\n\n        Ok(storage)\n    }\n\n    /// Used because in the case the key changes in the future.\n    /// Believed to not introduce any overhead being inline and using a reference.\n    #[must_use]\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_node_key_205": {
      "name": "node_key",
      "type": "method",
      "start_line": 205,
      "end_line": 212,
      "content_hash": "b18a0ccb9675a45dfad2c2b1db68381f80533039",
      "content": "    pub fn node_key(id: &u128) -> &u128 {\n        id\n    }\n\n    /// Used because in the case the key changes in the future.\n    /// Believed to not introduce any overhead being inline and using a reference.\n    #[must_use]\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_edge_key_213": {
      "name": "edge_key",
      "type": "method",
      "start_line": 213,
      "end_line": 224,
      "content_hash": "e235f095daa8a06dfbcc7fa0d1f9ca5ddd30c983",
      "content": "    pub fn edge_key(id: &u128) -> &u128 {\n        id\n    }\n\n    /// Out edge key generator. Creates a 20 byte array and copies in the node id and 4 byte label.\n    ///\n    /// key = `from-node(16)` | `label-id(4)`                 \u2190 20 B\n    ///\n    /// The generated out edge key will remain the same for the same from_node_id and label.\n    /// To save space, the key is only stored once,\n    /// with the values being stored in a sorted sub-tree, with this key being the root.\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_edge_key_225": {
      "name": "out_edge_key",
      "type": "method",
      "start_line": 225,
      "end_line": 239,
      "content_hash": "1e8e1d515121fa8eaadfc7e718ed641076123471",
      "content": "    pub fn out_edge_key(from_node_id: &u128, label: &[u8; 4]) -> [u8; 20] {\n        let mut key = [0u8; 20];\n        key[0..16].copy_from_slice(&from_node_id.to_be_bytes());\n        key[16..20].copy_from_slice(label);\n        key\n    }\n\n    /// In edge key generator. Creates a 20 byte array and copies in the node id and 4 byte label.\n    ///\n    /// key = `to-node(16)` | `label-id(4)`                 \u2190 20 B\n    ///\n    /// The generated in edge key will remain the same for the same to_node_id and label.\n    /// To save space, the key is only stored once,\n    /// with the values being stored in a sorted sub-tree, with this key being the root.\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_edge_key_240": {
      "name": "in_edge_key",
      "type": "method",
      "start_line": 240,
      "end_line": 250,
      "content_hash": "556ad0ab2ce59074b72b74764bfd34eecbfa2a38",
      "content": "    pub fn in_edge_key(to_node_id: &u128, label: &[u8; 4]) -> [u8; 20] {\n        let mut key = [0u8; 20];\n        key[0..16].copy_from_slice(&to_node_id.to_be_bytes());\n        key[16..20].copy_from_slice(label);\n        key\n    }\n\n    /// Packs the edge data into a 32 byte array.\n    ///\n    /// data = `edge-id(16)` | `node-id(16)`                 \u2190 32 B (DUPFIXED)\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_pack_edge_data_251": {
      "name": "pack_edge_data",
      "type": "method",
      "start_line": 251,
      "end_line": 262,
      "content_hash": "296fee27fcb6c74f9928c531ecc6dd66af689382",
      "content": "    pub fn pack_edge_data(edge_id: &u128, node_id: &u128) -> [u8; 32] {\n        let mut key = [0u8; 32];\n        key[0..16].copy_from_slice(&edge_id.to_be_bytes());\n        key[16..32].copy_from_slice(&node_id.to_be_bytes());\n        key\n    }\n\n    /// Unpacks the 32 byte array into an (edge_id, node_id) tuple of u128s.\n    ///\n    /// Returns (edge_id, node_id)\n    #[inline(always)]\n    // Uses Type Aliases for clarity",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_unpack_adj_edge_data_263": {
      "name": "unpack_adj_edge_data",
      "type": "method",
      "start_line": 263,
      "end_line": 277,
      "content_hash": "10abfd1703904844d661cb43c2bbe2ba5b299a14",
      "content": "    pub fn unpack_adj_edge_data(data: &[u8]) -> Result<(EdgeId, NodeId), GraphError> {\n        let edge_id = u128::from_be_bytes(\n            data[0..16]\n                .try_into()\n                .map_err(|_| GraphError::SliceLengthError)?,\n        );\n        let node_id = u128::from_be_bytes(\n            data[16..32]\n                .try_into()\n                .map_err(|_| GraphError::SliceLengthError)?,\n        );\n        Ok((edge_id, node_id))\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_StorageConfig_278": {
      "name": "StorageConfig",
      "type": "impl",
      "start_line": 278,
      "end_line": 278,
      "content_hash": "50dd03d6c93bb08b5291047432854f77aa3fc613",
      "content": "impl StorageConfig {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_279": {
      "name": "new",
      "type": "method",
      "start_line": 279,
      "end_line": 291,
      "content_hash": "04aa4387be14868306795bc437523540a8fbcb13",
      "content": "    pub fn new(\n        schema: Option<String>,\n        graphvis_node_label: Option<String>,\n        embedding_model: Option<String>,\n    ) -> StorageConfig {\n        Self {\n            schema,\n            graphvis_node_label,\n            embedding_model,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DBMethods_292": {
      "name": "DBMethods",
      "type": "impl",
      "start_line": 292,
      "end_line": 293,
      "content_hash": "05975fad3d71ca40636619d3f29068ab3cc0645f",
      "content": "impl DBMethods for HelixGraphStorage {\n    /// Creates a secondary index lmdb db (table) for a given index name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_create_secondary_index_294": {
      "name": "create_secondary_index",
      "type": "method",
      "start_line": 294,
      "end_line": 302,
      "content_hash": "e0be600e11e4828f1530a58447495134a7047b21",
      "content": "    fn create_secondary_index(&mut self, name: &str) -> Result<(), GraphError> {\n        let mut wtxn = self.graph_env.write_txn()?;\n        let db = self.graph_env.create_database(&mut wtxn, Some(name))?;\n        wtxn.commit()?;\n        self.secondary_indices.insert(name.to_string(), db);\n        Ok(())\n    }\n\n    /// Drops a secondary index lmdb db (table) for a given index name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_secondary_index_303": {
      "name": "drop_secondary_index",
      "type": "method",
      "start_line": 303,
      "end_line": 315,
      "content_hash": "df11ef9e5f4d1464dabd682df6c0dbed26e0687d",
      "content": "    fn drop_secondary_index(&mut self, name: &str) -> Result<(), GraphError> {\n        let mut wtxn = self.graph_env.write_txn()?;\n        let db = self\n            .secondary_indices\n            .get(name)\n            .ok_or(GraphError::New(format!(\"Secondary Index {name} not found\")))?;\n        db.clear(&mut wtxn)?;\n        wtxn.commit()?;\n        self.secondary_indices.remove(name);\n        Ok(())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_StorageMethods_316": {
      "name": "StorageMethods",
      "type": "impl",
      "start_line": 316,
      "end_line": 347,
      "content_hash": "ad7466cee41088f44c0db73c0de25f9b5beb3825",
      "content": "impl StorageMethods for HelixGraphStorage {\n    #[inline]\n    fn get_node<'arena>(\n        &self,\n        txn: &RoTxn,\n        id: &u128,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<Node<'arena>, GraphError> {\n        let node = match self.nodes_db.get(txn, Self::node_key(id))? {\n            Some(data) => data,\n            None => return Err(GraphError::NodeNotFound),\n        };\n        let node: Node = Node::from_bincode_bytes(*id, node, arena)?;\n        let node = self.version_info.upgrade_to_node_latest(node);\n        Ok(node)\n    }\n\n    #[inline]\n    fn get_edge<'arena>(\n        &self,\n        txn: &RoTxn,\n        id: &u128,\n        arena: &'arena bumpalo::Bump,\n    ) -> Result<Edge<'arena>, GraphError> {\n        let edge = match self.edges_db.get(txn, Self::edge_key(id))? {\n            Some(data) => data,\n            None => return Err(GraphError::EdgeNotFound),\n        };\n        let edge: Edge = Edge::from_bincode_bytes(*id, edge, arena)?;\n        Ok(self.version_info.upgrade_to_edge_latest(edge))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_node_348": {
      "name": "drop_node",
      "type": "method",
      "start_line": 348,
      "end_line": 444,
      "content_hash": "80030f1b8e733bcfd1d8d53e6430baed44a160c6",
      "content": "    fn drop_node(&self, txn: &mut RwTxn, id: &u128) -> Result<(), GraphError> {\n        let arena = bumpalo::Bump::new();\n        // Get node to get its label\n        //let node = self.get_node(txn, id)?;\n        let mut edges = HashSet::new();\n        let mut out_edges = HashSet::new();\n        let mut in_edges = HashSet::new();\n\n        let mut other_out_edges = Vec::new();\n        let mut other_in_edges = Vec::new();\n        // Delete outgoing edges\n\n        let iter = self.out_edges_db.prefix_iter(txn, &id.to_be_bytes())?;\n\n        for result in iter {\n            let (key, value) = result?;\n            assert_eq!(key.len(), 20);\n            let mut label = [0u8; 4];\n            label.copy_from_slice(&key[16..20]);\n            let (edge_id, to_node_id) = Self::unpack_adj_edge_data(value)?;\n            edges.insert(edge_id);\n            out_edges.insert(label);\n            other_in_edges.push((to_node_id, label, edge_id));\n        }\n\n        // Delete incoming edges\n\n        let iter = self.in_edges_db.prefix_iter(txn, &id.to_be_bytes())?;\n\n        for result in iter {\n            let (key, value) = result?;\n            assert_eq!(key.len(), 20);\n            let mut label = [0u8; 4];\n            label.copy_from_slice(&key[16..20]);\n            let (edge_id, from_node_id) = Self::unpack_adj_edge_data(value)?;\n            in_edges.insert(label);\n            edges.insert(edge_id);\n            other_out_edges.push((from_node_id, label, edge_id));\n        }\n\n        // println!(\"In edges: {}\", in_edges.len());\n\n        // println!(\"Deleting edges: {}\", );\n        // Delete all related data\n        for edge in edges {\n            self.edges_db.delete(txn, Self::edge_key(&edge))?;\n        }\n        for label_bytes in out_edges.iter() {\n            self.out_edges_db\n                .delete(txn, &Self::out_edge_key(id, label_bytes))?;\n        }\n        for label_bytes in in_edges.iter() {\n            self.in_edges_db\n                .delete(txn, &Self::in_edge_key(id, label_bytes))?;\n        }\n\n        for (other_node_id, label_bytes, edge_id) in other_out_edges.iter() {\n            self.out_edges_db.delete_one_duplicate(\n                txn,\n                &Self::out_edge_key(other_node_id, label_bytes),\n                &Self::pack_edge_data(edge_id, id),\n            )?;\n        }\n        for (other_node_id, label_bytes, edge_id) in other_in_edges.iter() {\n            self.in_edges_db.delete_one_duplicate(\n                txn,\n                &Self::in_edge_key(other_node_id, label_bytes),\n                &Self::pack_edge_data(edge_id, id),\n            )?;\n        }\n\n        // delete secondary indices\n        let node = self.get_node(txn, id, &arena)?;\n        for (index_name, db) in &self.secondary_indices {\n            // Use get_property like we do when adding, to handle id, label, and regular properties consistently\n            match node.get_property(index_name) {\n                Some(value) => match bincode::serialize(value) {\n                    Ok(serialized) => {\n                        if let Err(e) = db.delete_one_duplicate(txn, &serialized, &node.id) {\n                            return Err(GraphError::from(e));\n                        }\n                    }\n                    Err(e) => return Err(GraphError::from(e)),\n                },\n                None => {\n                    // Property not found - this is expected for some indices\n                    // Continue to next index\n                }\n            }\n        }\n\n        // Delete node data and label\n        self.nodes_db.delete(txn, Self::node_key(id))?;\n\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_edge_445": {
      "name": "drop_edge",
      "type": "method",
      "start_line": 445,
      "end_line": 471,
      "content_hash": "0569e796c7eccdac5c15fff6687c58d04b6fe503",
      "content": "    fn drop_edge(&self, txn: &mut RwTxn, edge_id: &u128) -> Result<(), GraphError> {\n        let arena = bumpalo::Bump::new();\n        // Get edge data first\n        let edge_data = match self.edges_db.get(txn, Self::edge_key(edge_id))? {\n            Some(data) => data,\n            None => return Err(GraphError::EdgeNotFound),\n        };\n        let edge: Edge = Edge::from_bincode_bytes(*edge_id, edge_data, &arena)?;\n        let label_hash = hash_label(edge.label, None);\n        let out_edge_value = Self::pack_edge_data(edge_id, &edge.to_node);\n        let in_edge_value = Self::pack_edge_data(edge_id, &edge.from_node);\n        // Delete all edge-related data\n        self.edges_db.delete(txn, Self::edge_key(edge_id))?;\n        self.out_edges_db.delete_one_duplicate(\n            txn,\n            &Self::out_edge_key(&edge.from_node, &label_hash),\n            &out_edge_value,\n        )?;\n        self.in_edges_db.delete_one_duplicate(\n            txn,\n            &Self::in_edge_key(&edge.to_node, &label_hash),\n            &in_edge_value,\n        )?;\n\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_vector_472": {
      "name": "drop_vector",
      "type": "method",
      "start_line": 472,
      "end_line": 546,
      "content_hash": "73f4811fe0e816a64568ca68b8eea4b1172b9e2e",
      "content": "    fn drop_vector(&self, txn: &mut RwTxn, id: &u128) -> Result<(), GraphError> {\n        let arena = bumpalo::Bump::new();\n        let mut edges = HashSet::new();\n        let mut out_edges = HashSet::new();\n        let mut in_edges = HashSet::new();\n\n        let mut other_out_edges = Vec::new();\n        let mut other_in_edges = Vec::new();\n        // Delete outgoing edges\n\n        let iter = self.out_edges_db.prefix_iter(txn, &id.to_be_bytes())?;\n\n        for result in iter {\n            let (key, value) = result?;\n            assert_eq!(key.len(), 20);\n            let mut label = [0u8; 4];\n            label.copy_from_slice(&key[16..20]);\n            let (edge_id, to_node_id) = Self::unpack_adj_edge_data(value)?;\n            edges.insert(edge_id);\n            out_edges.insert(label);\n            other_in_edges.push((to_node_id, label, edge_id));\n        }\n\n        // Delete incoming edges\n\n        let iter = self.in_edges_db.prefix_iter(txn, &id.to_be_bytes())?;\n\n        for result in iter {\n            let (key, value) = result?;\n            assert_eq!(key.len(), 20);\n            let mut label = [0u8; 4];\n            label.copy_from_slice(&key[16..20]);\n            let (edge_id, from_node_id) = Self::unpack_adj_edge_data(value)?;\n            in_edges.insert(label);\n            edges.insert(edge_id);\n            other_out_edges.push((from_node_id, label, edge_id));\n        }\n\n        // println!(\"In edges: {}\", in_edges.len());\n\n        // println!(\"Deleting edges: {}\", );\n        // Delete all related data\n        for edge in edges {\n            self.edges_db.delete(txn, Self::edge_key(&edge))?;\n        }\n        for label_bytes in out_edges.iter() {\n            self.out_edges_db\n                .delete(txn, &Self::out_edge_key(id, label_bytes))?;\n        }\n        for label_bytes in in_edges.iter() {\n            self.in_edges_db\n                .delete(txn, &Self::in_edge_key(id, label_bytes))?;\n        }\n\n        for (other_node_id, label_bytes, edge_id) in other_out_edges.iter() {\n            self.out_edges_db.delete_one_duplicate(\n                txn,\n                &Self::out_edge_key(other_node_id, label_bytes),\n                &Self::pack_edge_data(edge_id, id),\n            )?;\n        }\n        for (other_node_id, label_bytes, edge_id) in other_in_edges.iter() {\n            self.in_edges_db.delete_one_duplicate(\n                txn,\n                &Self::in_edge_key(other_node_id, label_bytes),\n                &Self::pack_edge_data(edge_id, id),\n            )?;\n        }\n\n        // Delete vector data\n        self.vectors.delete(txn, *id, &arena)?;\n\n        Ok(())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}