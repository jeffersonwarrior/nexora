{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/docker.rs",
  "file_hash": "2524402b9f09d4160c5a5c0b98e6001383a74947",
  "updated_at": "2025-12-26T17:34:24.167509",
  "symbols": {
    "enum_DockerBuildError_17": {
      "name": "DockerBuildError",
      "type": "enum",
      "start_line": 17,
      "end_line": 24,
      "content_hash": "5ea95df0b0f51da8318e4b576b16d8e1142389fb",
      "content": "pub enum DockerBuildError {\n    /// Rust compilation failed during Docker build\n    RustCompilation {\n        output: String,\n        instance_name: String,\n    },\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_fmt::Display_25": {
      "name": "fmt::Display",
      "type": "impl",
      "start_line": 25,
      "end_line": 25,
      "content_hash": "16b731f1a8d0febff148eccae5565992a796c3f5",
      "content": "impl fmt::Display for DockerBuildError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_26": {
      "name": "fmt",
      "type": "method",
      "start_line": 26,
      "end_line": 34,
      "content_hash": "f58ebc5b684eab19652d6493e2aef03e47dcbef0",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            DockerBuildError::RustCompilation { output, instance_name } => {\n                write!(f, \"Rust compilation failed for instance '{}': {}\", instance_name, output)\n            }\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_std::error::Error_35": {
      "name": "std::error::Error",
      "type": "impl",
      "start_line": 35,
      "end_line": 37,
      "content_hash": "83840b3aa75133abde3c93ca694ea00bc6e40980",
      "content": "impl std::error::Error for DockerBuildError {}\n\n/// Check if Docker build output indicates a Rust compilation error.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_rust_compilation_error_38": {
      "name": "is_rust_compilation_error",
      "type": "method",
      "start_line": 38,
      "end_line": 43,
      "content_hash": "a572ae91cc2a508ead5213478c2f955b5efdb36e",
      "content": "fn is_rust_compilation_error(output: &str) -> bool {\n    output.contains(\"error[E\")\n        || output.contains(\"error: could not compile\")\n        || (output.contains(\"cargo build\") && output.contains(\"error:\"))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_DockerManager_44": {
      "name": "DockerManager",
      "type": "struct",
      "start_line": 44,
      "end_line": 51,
      "content_hash": "21d011a9e617d78fdeb11c41f15f2908dac41009",
      "content": "pub struct DockerManager<'a> {\n    project: &'a ProjectContext,\n    /// The container runtime to use (Docker or Podman)\n    pub(crate) runtime: ContainerRuntime,\n}\n\npub const HELIX_DATA_DIR: &str = \"/data\";\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DockerManager_52": {
      "name": "DockerManager",
      "type": "impl",
      "start_line": 52,
      "end_line": 52,
      "content_hash": "a90f109442452838ce2f69817c3c88965f1793a0",
      "content": "impl<'a> DockerManager<'a> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_53": {
      "name": "new",
      "type": "method",
      "start_line": 53,
      "end_line": 62,
      "content_hash": "a42dfdf6ad1a32e12c9cb14ee99c44c85cb55e80",
      "content": "    pub fn new(project: &'a ProjectContext) -> Self {\n        Self {\n            project,\n            runtime: project.config.project.container_runtime,\n        }\n    }\n\n    // === CENTRALIZED NAMING METHODS ===\n\n    /// Get the compose project name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_compose_project_name_63": {
      "name": "compose_project_name",
      "type": "method",
      "start_line": 63,
      "end_line": 72,
      "content_hash": "5fbea28469dce485281ec3fc3f05665c18c3b98d",
      "content": "    fn compose_project_name(&self, instance_name: &str) -> String {\n        format!(\n            // has to be `-` instead of `_` because fly doesnt allow underscores in instance names\n            // abd image name must match the instance name\n            \"helix-{}-{}\",\n            self.project.config.project.name, instance_name\n        )\n    }\n\n    /// Get the service name (always \"app\")",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_service_name_73": {
      "name": "service_name",
      "type": "method",
      "start_line": 73,
      "end_line": 141,
      "content_hash": "e4d89692fd9bffb0ee75ffe04d21c28c21e8f9b6",
      "content": "    fn service_name() -> &'static str {\n        \"app\"\n    }\n\n    /// Get the image name for an instance\n    pub(crate) fn image_name(&self, instance_name: &str, build_mode: BuildMode) -> String {\n        let tag = match build_mode {\n            BuildMode::Debug => \"debug\",\n            BuildMode::Release => \"latest\",\n            BuildMode::Dev => \"dev\",\n        };\n        let project_name = self.compose_project_name(instance_name);\n        format!(\"{project_name}:{tag}\")\n    }\n\n    /// Get environment variables for an instance\n    pub(crate) fn environment_variables(&self, instance_name: &str) -> Vec<String> {\n        // Load .env from project root first (base configuration)\n        let root_env = self.project.root.join(\".env\");\n        if root_env.exists() {\n            let _ = dotenvy::from_path(&root_env);\n            print_info(&format!(\n                \"Loading environment from {}\",\n                root_env.display()\n            ));\n        }\n\n        // Load .env from db/queries directory (overrides project root)\n        let queries_dir = self.project.root.join(&self.project.config.project.queries);\n        let db_env = queries_dir.join(\".env\");\n        if db_env.exists() {\n            let _ = dotenvy::from_path_override(&db_env);\n            print_info(&format!(\n                \"Overriding environment from {}\",\n                db_env.display()\n            ));\n        }\n\n        let mut env_vars = vec![\n            {\n                let port = self\n                    .project\n                    .config\n                    .get_instance(instance_name)\n                    .unwrap()\n                    .port()\n                    .unwrap_or(6969);\n                format!(\"HELIX_PORT={port}\")\n            },\n            format!(\"HELIX_DATA_DIR={HELIX_DATA_DIR}\"),\n            format!(\"HELIX_INSTANCE={instance_name}\"),\n            {\n                let project_name = &self.project.config.project.name;\n                format!(\"HELIX_PROJECT={project_name}\")\n            },\n        ];\n\n        // Add API keys from environment (which includes .env after dotenv() call)\n        if let Ok(openai_key) = std::env::var(\"OPENAI_API_KEY\") {\n            env_vars.push(format!(\"OPENAI_API_KEY={openai_key}\"));\n        }\n        if let Ok(gemini_key) = std::env::var(\"GEMINI_API_KEY\") {\n            env_vars.push(format!(\"GEMINI_API_KEY={gemini_key}\"));\n        }\n\n        env_vars\n    }\n\n    /// Get the container name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_container_name_142": {
      "name": "container_name",
      "type": "method",
      "start_line": 142,
      "end_line": 147,
      "content_hash": "e42623e65f2e90331f63c82388d6174131b79e6e",
      "content": "    fn container_name(&self, instance_name: &str) -> String {\n        let project_name = self.compose_project_name(instance_name);\n        format!(\"{project_name}_app\")\n    }\n\n    /// Get the network name for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_network_name_148": {
      "name": "network_name",
      "type": "method",
      "start_line": 148,
      "end_line": 155,
      "content_hash": "d3c75971858ca29b0689a85a44f1355ebca6c74a",
      "content": "    fn network_name(&self, instance_name: &str) -> String {\n        let project_name = self.compose_project_name(instance_name);\n        format!(\"{project_name}_net\")\n    }\n\n    // === CENTRALIZED DOCKER/PODMAN COMMAND EXECUTION ===\n\n    /// Run a docker/podman command with consistent error handling",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_docker_command_156": {
      "name": "run_docker_command",
      "type": "method",
      "start_line": 156,
      "end_line": 170,
      "content_hash": "39ebf32231ac1d882d5f51eaf565bbd38a3a9044",
      "content": "    pub fn run_docker_command(&self, args: &[&str]) -> Result<Output> {\n        let output = Command::new(self.runtime.binary())\n            .args(args)\n            .output()\n            .map_err(|e| {\n                eyre!(\n                    \"Failed to run {} {}: {e}\",\n                    self.runtime.binary(),\n                    args.join(\" \")\n                )\n            })?;\n        Ok(output)\n    }\n\n    /// Run a docker/podman compose command with proper project naming",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_run_compose_command_171": {
      "name": "run_compose_command",
      "type": "method",
      "start_line": 171,
      "end_line": 193,
      "content_hash": "22dede9c6bdbbe508bee951f26f0827a00a245eb",
      "content": "    fn run_compose_command(&self, instance_name: &str, args: Vec<&str>) -> Result<Output> {\n        let workspace = self.project.instance_workspace(instance_name);\n        let project_name = self.compose_project_name(instance_name);\n\n        let mut full_args = vec![\"--project-name\", &project_name];\n        full_args.extend(args);\n\n        let output = Command::new(self.runtime.binary())\n            .arg(\"compose\")\n            .args(&full_args)\n            .current_dir(&workspace)\n            .output()\n            .map_err(|e| {\n                eyre!(\n                    \"Failed to run {} compose {}: {e}\",\n                    self.runtime.binary(),\n                    full_args.join(\" \")\n                )\n            })?;\n        Ok(output)\n    }\n\n    /// Detect the current operating system platform",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_detect_platform_194": {
      "name": "detect_platform",
      "type": "method",
      "start_line": 194,
      "end_line": 208,
      "content_hash": "5096625f855a855d1b75f763bf7b04f3ed6e517e",
      "content": "    fn detect_platform() -> &'static str {\n        #[cfg(target_os = \"macos\")]\n        return \"macos\";\n\n        #[cfg(target_os = \"linux\")]\n        return \"linux\";\n\n        #[cfg(target_os = \"windows\")]\n        return \"windows\";\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"linux\", target_os = \"windows\")))]\n        return \"unknown\";\n    }\n\n    /// Start the container runtime daemon based on platform and runtime",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_start_runtime_daemon_209": {
      "name": "start_runtime_daemon",
      "type": "method",
      "start_line": 209,
      "end_line": 372,
      "content_hash": "674428aabbb4e8934d617134e6d7f7089896c3cc",
      "content": "    fn start_runtime_daemon(runtime: ContainerRuntime) -> Result<()> {\n        let platform = Self::detect_platform();\n\n        match (runtime, platform) {\n            // Docker on macOS\n            (ContainerRuntime::Docker, \"macos\") => {\n                print_status(\"DOCKER\", \"Starting Docker Desktop for macOS...\");\n                Command::new(\"open\")\n                    .args([\"-a\", \"Docker\"])\n                    .output()\n                    .map_err(|e| eyre!(\"Failed to start Docker Desktop: {}\", e))?;\n            }\n\n            // Podman on macOS\n            (ContainerRuntime::Podman, \"macos\") => {\n                print_status(\"PODMAN\", \"Starting Podman machine on macOS...\");\n\n                // Check if machine exists first\n                let list_output = Command::new(\"podman\")\n                    .args([\"machine\", \"list\", \"--format\", \"{{.Name}}\"])\n                    .output()\n                    .map_err(|e| eyre!(\"Failed to list Podman machines: {}\", e))?;\n\n                let machines = String::from_utf8_lossy(&list_output.stdout);\n\n                if machines.trim().is_empty() {\n                    // No machine exists, initialize one\n                    print_status(\"PODMAN\", \"Initializing Podman machine (first time)...\");\n                    let init_output = Command::new(\"podman\")\n                        .args([\"machine\", \"init\"])\n                        .output()\n                        .map_err(|e| eyre!(\"Failed to initialize Podman machine: {}\", e))?;\n\n                    if !init_output.status.success() {\n                        let stderr = String::from_utf8_lossy(&init_output.stderr);\n                        return Err(eyre!(\"Failed to initialize Podman machine: {}\", stderr));\n                    }\n                }\n\n                // Start the machine\n                Command::new(\"podman\")\n                    .args([\"machine\", \"start\"])\n                    .output()\n                    .map_err(|e| eyre!(\"Failed to start Podman machine: {}\", e))?;\n            }\n\n            // Docker on Linux\n            (ContainerRuntime::Docker, \"linux\") => {\n                print_status(\"DOCKER\", \"Attempting to start Docker daemon on Linux...\");\n                let systemctl_result = Command::new(\"systemctl\").args([\"start\", \"docker\"]).output();\n\n                match systemctl_result {\n                    Ok(output) if output.status.success() => {}\n                    _ => {\n                        let service_result = Command::new(\"service\")\n                            .args([\"docker\", \"start\"])\n                            .output()\n                            .map_err(|e| eyre!(\"Failed to start Docker daemon: {}\", e))?;\n\n                        if !service_result.status.success() {\n                            let stderr = String::from_utf8_lossy(&service_result.stderr);\n                            return Err(eyre!(\"Failed to start Docker daemon: {}\", stderr));\n                        }\n                    }\n                }\n            }\n\n            // Podman on Linux\n            (ContainerRuntime::Podman, \"linux\") => {\n                print_status(\"PODMAN\", \"Starting Podman service on Linux...\");\n\n                // Try to start user service (rootless)\n                let user_service = Command::new(\"systemctl\")\n                    .args([\"--user\", \"start\", \"podman.socket\"])\n                    .output();\n\n                // Only skip fallback if command succeeded AND status is success\n                if !user_service.is_ok_and(|output| output.status.success()) {\n                    // Try system service (rootful) as fallback\n                    let system_service = Command::new(\"systemctl\")\n                        .args([\"start\", \"podman.socket\"])\n                        .output();\n\n                    if let Err(e) = system_service {\n                        print_warning(&format!(\"Could not start Podman service: {}\", e));\n                    }\n                }\n            }\n            // Docker on Windows\n            (ContainerRuntime::Docker, \"windows\") => {\n                print_status(\"DOCKER\", \"Starting Docker Desktop for Windows...\");\n                // Try Docker Desktop CLI (4.37+) first\n                let cli_result = Command::new(\"docker\").args([\"desktop\", \"start\"]).output();\n\n                match cli_result {\n                    Ok(output) if output.status.success() => {\n                        // Modern Docker Desktop CLI worked\n                    }\n                    _ => {\n                        // Fallback to direct executable path for older versions\n                        // Note: Empty string \"\" is required as window title parameter\n                        Command::new(\"cmd\")\n                            .args([\n                                \"/c\",\n                                \"start\",\n                                \"\",\n                                \"\\\"C:\\\\Program Files\\\\Docker\\\\Docker\\\\Docker Desktop.exe\\\"\",\n                            ])\n                            .output()\n                            .map_err(|e| eyre!(\"Failed to start Docker Desktop: {}\", e))?;\n                    }\n                }\n            }\n\n            // Podman on Windows\n            (ContainerRuntime::Podman, \"windows\") => {\n                print_status(\"PODMAN\", \"Starting Podman machine on Windows...\");\n\n                // Check if machine exists\n                let list_output = Command::new(\"podman\")\n                    .args([\"machine\", \"list\", \"--format\", \"{{.Name}}\"])\n                    .output()\n                    .map_err(|e| eyre!(\"Failed to list Podman machines: {}\", e))?;\n\n                let machines = String::from_utf8_lossy(&list_output.stdout);\n\n                if machines.trim().is_empty() {\n                    // Initialize machine first\n                    print_status(\"PODMAN\", \"Initializing Podman machine (first time)...\");\n                    let init_output = Command::new(\"podman\")\n                        .args([\"machine\", \"init\"])\n                        .output()\n                        .map_err(|e| eyre!(\"Failed to initialize Podman machine: {}\", e))?;\n\n                    if !init_output.status.success() {\n                        let stderr = String::from_utf8_lossy(&init_output.stderr);\n                        return Err(eyre!(\"Failed to initialize Podman machine: {}\", stderr));\n                    }\n                }\n\n                // Start the machine\n                let start_output = Command::new(\"podman\")\n                    .args([\"machine\", \"start\"])\n                    .output()\n                    .map_err(|e| eyre!(\"Failed to start Podman machine: {}\", e))?;\n\n                if !start_output.status.success() {\n                    let stderr = String::from_utf8_lossy(&start_output.stderr);\n                    return Err(eyre!(\"Failed to start Podman machine: {}\", stderr));\n                }\n            }\n\n            (_, platform) => {\n                return Err(eyre!(\n                    \"Unsupported platform '{}' for auto-starting {}\",\n                    platform,\n                    runtime.label()\n                ));\n            }\n        }\n\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_wait_for_runtime_373": {
      "name": "wait_for_runtime",
      "type": "method",
      "start_line": 373,
      "end_line": 399,
      "content_hash": "b80027b844e2a58ed883f5527fdfb0a8d8016bac",
      "content": "    fn wait_for_runtime(runtime: ContainerRuntime, timeout_secs: u64) -> Result<()> {\n        print_status(runtime.label(), \"Waiting for daemon to start...\");\n\n        let start = std::time::Instant::now();\n        let timeout = Duration::from_secs(timeout_secs);\n\n        while start.elapsed() < timeout {\n            let output = Command::new(runtime.binary()).args([\"info\"]).output();\n\n            if let Ok(output) = output\n                && output.status.success()\n            {\n                print_status(runtime.label(), \"Daemon is now running\");\n                return Ok(());\n            }\n\n            thread::sleep(Duration::from_millis(500));\n        }\n\n        Err(eyre!(\n            \"Timeout waiting for {} daemon to start. Please start {} manually and try again.\",\n            runtime.label(),\n            runtime.binary()\n        ))\n    }\n\n    /// Check if container runtime is installed and running, with auto-start option",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_check_runtime_available_400": {
      "name": "check_runtime_available",
      "type": "method",
      "start_line": 400,
      "end_line": 463,
      "content_hash": "2b9b3079debc224a6013b483cbeb1e2fa0a68914",
      "content": "    pub fn check_runtime_available(runtime: ContainerRuntime) -> Result<()> {\n        let cmd = runtime.binary();\n\n        let output = Command::new(cmd)\n            .args([\"--version\"])\n            .output()\n            .map_err(|_| eyre!(\"{} is not installed or not available in PATH\", cmd))?;\n\n        if !output.status.success() {\n            return Err(eyre!(\"{} is installed but not working properly\", cmd));\n        }\n\n        // Check if daemon is running\n        let output = Command::new(cmd)\n            .args([\"info\"])\n            .output()\n            .map_err(|_| eyre!(\"Failed to check {} daemon status\", cmd))?;\n\n        if !output.status.success() {\n            // Daemon not running - ask user if they want to start it\n            let message = format!(\n                \"{} daemon is not running. Would you like to start {}?\",\n                runtime.label(),\n                runtime.binary()\n            );\n            let should_start = print_confirm(&message).unwrap_or(false);\n\n            if should_start {\n                // Try to start the runtime\n                Self::start_runtime_daemon(runtime)?;\n\n                // Wait for it to be ready\n                Self::wait_for_runtime(runtime, 15)?;\n\n                // Verify it's running now\n                let verify_output = Command::new(cmd)\n                    .args([\"info\"])\n                    .output()\n                    .map_err(|_| eyre!(\"Failed to verify {} daemon status\", cmd))?;\n\n                if !verify_output.status.success() {\n                    return Err(eyre!(\n                        \"{} daemon failed to start. Please start {} manually and try again.\",\n                        runtime.label(),\n                        cmd\n                    ));\n                }\n            } else {\n                print_warning(&format!(\n                    \"{} daemon must be running to execute this command.\",\n                    runtime.label()\n                ));\n                return Err(eyre!(\n                    \"{} daemon is not running. Please start {}.\",\n                    cmd,\n                    cmd\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Generate Dockerfile for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_dockerfile_464": {
      "name": "generate_dockerfile",
      "type": "method",
      "start_line": 464,
      "end_line": 540,
      "content_hash": "03f2045884d0760d42a2c2068b7460f7d9cdc943",
      "content": "    pub fn generate_dockerfile(\n        &self,\n        instance_name: &str,\n        instance_config: InstanceInfo<'_>,\n    ) -> Result<String> {\n        let build_flag = match instance_config.build_mode() {\n            BuildMode::Debug => \"\",\n            BuildMode::Release => \"--release\",\n            BuildMode::Dev => \"--features dev\",\n        };\n        let build_mode = match instance_config.build_mode() {\n            BuildMode::Debug => \"debug\",\n            BuildMode::Release => \"release\",\n            BuildMode::Dev => \"debug\",\n        };\n\n        let dockerfile = format!(\n            r#\"# Generated Dockerfile for Helix instance: {instance_name}\nFROM lukemathwalker/cargo-chef:latest-rust-1.88 AS chef\nWORKDIR /build\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy the cached repo workspace first (contains all dependencies and Cargo.toml files)\nCOPY helix-repo-copy/ ./\n\n# Then overlay instance-specific files\nCOPY helix-container/ ./helix-container/\n\nFROM chef AS planner\n# Generate the recipe file for dependency caching\nRUN cargo chef prepare --recipe-path recipe.json --bin helix-container\n\nFROM chef AS builder\n# Copy the recipe file\nCOPY --from=planner /build/recipe.json recipe.json\n\n# Build dependencies - this is the caching Docker layer!\nRUN cargo chef cook {build_flag} --recipe-path recipe.json --bin helix-container\n\n# Copy source code and build the application\nCOPY helix-repo-copy/ ./\nCOPY helix-container/ ./helix-container/\nRUN cargo build {build_flag} --package helix-container\n\n# Runtime image\nFROM debian:bookworm-slim\n\nWORKDIR /app\n\n# Install runtime dependencies\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy the built binary\nCOPY --from=builder /build/target/{build_mode}/helix-container /usr/local/bin/helix-container\n\n# Create data directory\nRUN mkdir -p /data\n\n# Expose port (will be overridden by docker-compose)\nEXPOSE 6969\n\n# Run the application\nCMD [\"helix-container\"]\n\"#\n        );\n\n        Ok(dockerfile)\n    }\n\n    /// Generate docker-compose.yml for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_docker_compose_541": {
      "name": "generate_docker_compose",
      "type": "method",
      "start_line": 541,
      "end_line": 592,
      "content_hash": "60fc743659b4d53080f3822011c06fe348082aa5",
      "content": "    pub fn generate_docker_compose(\n        &self,\n        instance_name: &str,\n        instance_config: InstanceInfo<'_>,\n    ) -> Result<String> {\n        let port = instance_config.port().unwrap_or(6969);\n\n        // Use centralized naming methods\n        let service_name = Self::service_name();\n        let image_name = self.image_name(instance_name, instance_config.build_mode());\n        let container_name = self.container_name(instance_name);\n        let network_name = self.network_name(instance_name); // Get all environment variables dynamically\n        let env_vars = self.environment_variables(instance_name);\n        let env_section = env_vars\n            .iter()\n            .map(|var| format!(\"      - {var}\"))\n            .collect::<Vec<_>>()\n            .join(\"\\n\");\n\n        let compose = format!(\n            r#\"# Generated docker-compose.yml for Helix instance: {instance_name}\nservices:\n  {service_name}:\n    build:\n      context: .\n      dockerfile: Dockerfile\n      {platform}\n    image: {image_name}\n    container_name: {container_name}\n    ports:\n      - \"{port}:{port}\"\n    volumes:\n      - ../.volumes/{instance_name}:/data\n    environment:\n{env_section}\n    restart: unless-stopped\n    networks:\n      - {network_name}\n\nnetworks:\n  {network_name}:\n    driver: bridge\n\"#,\n            platform = instance_config\n                .docker_build_target()\n                .map_or(\"\".to_string(), |p| format!(\"platforms:\\n        - {p}\")),\n        );\n\n        Ok(compose)\n    }\n\n    /// Build Docker/Podman image for an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_build_image_593": {
      "name": "build_image",
      "type": "method",
      "start_line": 593,
      "end_line": 621,
      "content_hash": "1a6bd6e83b160b5719053cae7f9e255b7abe9afe",
      "content": "    pub fn build_image(&self, instance_name: &str, _build_target: Option<&str>) -> Result<()> {\n        print_status(\n            self.runtime.label(),\n            &format!(\"Building image for instance '{instance_name}'...\"),\n        );\n        let output = self.run_compose_command(instance_name, vec![\"build\"])?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n            let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n            let full_output = format!(\"{}\\n{}\", stderr, stdout);\n\n            // Check if this is a Rust compilation error\n            if is_rust_compilation_error(&full_output) {\n                return Err(DockerBuildError::RustCompilation {\n                    output: full_output,\n                    instance_name: instance_name.to_string(),\n                }\n                .into());\n            }\n\n            return Err(eyre!(\"{} build failed:\\n{stderr}\", self.runtime.binary()));\n        }\n        print_status(self.runtime.label(), \"Image built successfully\");\n\n        Ok(())\n    }\n\n    /// Start instance using docker/podman compose",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_start_instance_622": {
      "name": "start_instance",
      "type": "method",
      "start_line": 622,
      "end_line": 642,
      "content_hash": "a1d88dbfd2836ab699457d907475e6db68189197",
      "content": "    pub fn start_instance(&self, instance_name: &str) -> Result<()> {\n        print_status(\n            self.runtime.label(),\n            &format!(\"Starting instance '{instance_name}'...\"),\n        );\n\n        let output = self.run_compose_command(instance_name, vec![\"up\", \"-d\"])?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to start instance:\\n{stderr}\"));\n        }\n\n        print_status(\n            self.runtime.label(),\n            &format!(\"Instance '{instance_name}' started successfully\"),\n        );\n        Ok(())\n    }\n\n    /// Stop instance using docker/podman compose",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stop_instance_643": {
      "name": "stop_instance",
      "type": "method",
      "start_line": 643,
      "end_line": 663,
      "content_hash": "81cb11f4eba7107e2f9f902e722a9608894d5497",
      "content": "    pub fn stop_instance(&self, instance_name: &str) -> Result<()> {\n        print_status(\n            self.runtime.label(),\n            &format!(\"Stopping instance '{instance_name}'...\"),\n        );\n\n        let output = self.run_compose_command(instance_name, vec![\"down\"])?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to stop instance:\\n{stderr}\"));\n        }\n\n        print_status(\n            self.runtime.label(),\n            &format!(\"Instance '{instance_name}' stopped successfully\"),\n        );\n        Ok(())\n    }\n\n    /// Check if an instance container exists (running or stopped)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_instance_exists_664": {
      "name": "instance_exists",
      "type": "method",
      "start_line": 664,
      "end_line": 673,
      "content_hash": "96d6b11b27b7b083527916af1e08644cbf418ae9",
      "content": "    pub fn instance_exists(&self, instance_name: &str) -> Result<bool> {\n        let statuses = self.get_project_status()?;\n        let target_container_name = format!(\"helix_{instance_name}_app\");\n\n        Ok(statuses\n            .iter()\n            .any(|status| status.container_name.contains(&target_container_name)))\n    }\n\n    /// Get status of all Docker/Podman containers for this project",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_project_status_674": {
      "name": "get_project_status",
      "type": "method",
      "start_line": 674,
      "end_line": 730,
      "content_hash": "8e5f179e5e53bff9ee579cbb9070d57c657b4636",
      "content": "    pub fn get_project_status(&self) -> Result<Vec<ContainerStatus>> {\n        let project_name = &self.project.config.project.name;\n        let filter = format!(\"name=helix-{project_name}-\");\n\n        let output = self.run_docker_command(&[\n            \"ps\",\n            \"-a\",\n            \"--format\",\n            \"{{.Names}}\\t{{.Status}}\\t{{.Ports}}\\t{{.Image}}\",\n            \"--filter\",\n            &filter,\n        ])?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to get container status:\\n{stderr}\"));\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let mut statuses = Vec::new();\n\n        // Process each line (no header with non-table format)\n        for line in stdout.lines() {\n            if line.trim().is_empty() {\n                continue;\n            }\n\n            // Tab-separated output since we removed \"table\" format\n            let parts: Vec<&str> = line.split('\\t').collect();\n            if parts.len() >= 3 {\n                let name = parts[0].trim();\n                let status = parts[1].trim();\n                let ports = parts[2].trim();\n\n                // Extract instance name from new container naming scheme: helix-{project}-{instance}-app\n                let expected_prefix = format!(\"helix-{project_name}-\");\n\n                let instance_name = if let Some(suffix) = name.strip_prefix(&expected_prefix) {\n                    // Remove the trailing \"-app\" if it exists\n                    suffix.strip_suffix(\"-app\").unwrap_or(suffix)\n                } else {\n                    name\n                };\n\n                statuses.push(ContainerStatus {\n                    instance_name: instance_name.to_string(),\n                    container_name: name.to_string(),\n                    status: status.to_string(),\n                    ports: ports.to_string(),\n                });\n            }\n        }\n\n        Ok(statuses)\n    }\n\n    /// Remove instance containers and optionally volumes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_prune_instance_731": {
      "name": "prune_instance",
      "type": "method",
      "start_line": 731,
      "end_line": 803,
      "content_hash": "f0166e474ba5453eeeddbc934d31de64733341bd",
      "content": "    pub fn prune_instance(&self, instance_name: &str, remove_volumes: bool) -> Result<()> {\n        print_status(\n            self.runtime.label(),\n            &format!(\"Pruning instance '{instance_name}'...\"),\n        );\n\n        // Check if workspace exists - if not, there's nothing to prune\n        let workspace = self.project.instance_workspace(instance_name);\n        if !workspace.exists() {\n            print_status(\n                self.runtime.label(),\n                &format!(\"No workspace found for instance '{instance_name}', nothing to prune\"),\n            );\n            return Ok(());\n        }\n\n        // Check if docker-compose file exists\n        let compose_file = workspace.join(\"docker-compose.yml\");\n        if !compose_file.exists() {\n            print_status(\n                self.runtime.label(),\n                &format!(\n                    \"No docker-compose.yml found for instance '{instance_name}', nothing to prune\"\n                ),\n            );\n            return Ok(());\n        }\n\n        // Stop and remove containers\n        let mut args = vec![\"down\"];\n        if remove_volumes {\n            args.push(\"--volumes\");\n            args.push(\"--remove-orphans\");\n        }\n\n        let output = self.run_compose_command(instance_name, args)?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            // Don't fail if containers are already down\n            if stderr.contains(\"No such container\") || stderr.contains(\"not running\") {\n                print_status(\n                    self.runtime.label(),\n                    &format!(\"Instance '{instance_name}' containers already stopped\"),\n                );\n            } else {\n                return Err(eyre!(\"Failed to prune instance:\\n{stderr}\"));\n            }\n        } else {\n            print_status(\n                self.runtime.label(),\n                &format!(\"Instance '{instance_name}' pruned successfully\"),\n            );\n        }\n\n        // Clean up orphaned named volumes from old CLI versions\n        // Old volume naming pattern: helix_{project_name}_{instance_name}_data\n        if remove_volumes {\n            let old_volume_name = format!(\n                \"helix_{}_{}\",\n                self.project.config.project.name.replace(\"-\", \"_\"),\n                instance_name.replace(\"-\", \"_\")\n            );\n\n            // Try to remove old-style named volume (ignore errors if it doesn't exist)\n            let volume_to_remove = format!(\"{old_volume_name}_data\");\n            let _ = self.run_docker_command(&[\"volume\", \"rm\", &volume_to_remove]);\n        }\n\n        Ok(())\n    }\n\n    /// Remove Docker/Podman images associated with an instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_remove_instance_images_804": {
      "name": "remove_instance_images",
      "type": "method",
      "start_line": 804,
      "end_line": 825,
      "content_hash": "bc47020572c1abbaedd5a2b2f1b32756a5177251",
      "content": "    pub fn remove_instance_images(&self, instance_name: &str) -> Result<()> {\n        print_status(\n            self.runtime.label(),\n            &format!(\"Removing images for instance '{instance_name}'...\"),\n        );\n\n        // Get image names for both debug and release modes\n        let debug_image = self.image_name(instance_name, BuildMode::Debug);\n        let release_image = self.image_name(instance_name, BuildMode::Release);\n\n        // Try to remove both images (ignore errors if they don't exist)\n        for image in [debug_image, release_image] {\n            let output = self.run_docker_command(&[\"rmi\", \"-f\", &image])?;\n            if output.status.success() {\n                print_status(self.runtime.label(), &format!(\"Removed image: {image}\"));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get all Helix-related images from the system",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_helix_images_826": {
      "name": "get_helix_images",
      "type": "method",
      "start_line": 826,
      "end_line": 853,
      "content_hash": "056d5ef689781c9f0939885827ee3e2570416fea",
      "content": "    pub fn get_helix_images(runtime: ContainerRuntime) -> Result<Vec<String>> {\n        let output = Command::new(runtime.binary())\n            .args([\n                \"images\",\n                \"--format\",\n                \"{{.Repository}}:{{.Tag}}\",\n                \"--filter\",\n                \"reference=helix-*\",\n            ])\n            .output()\n            .map_err(|e| eyre!(\"Failed to list {} images: {e}\", runtime.binary()))?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to list images:\\n{stderr}\"));\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let images: Vec<String> = stdout\n            .lines()\n            .filter(|line| !line.trim().is_empty())\n            .map(|line| line.trim().to_string())\n            .collect();\n\n        Ok(images)\n    }\n\n    /// Remove all Helix-related images from the system",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_clean_all_helix_images_854": {
      "name": "clean_all_helix_images",
      "type": "method",
      "start_line": 854,
      "end_line": 889,
      "content_hash": "5ebcc115575d9016c823bb808de01b233a43af23",
      "content": "    pub fn clean_all_helix_images(runtime: ContainerRuntime) -> Result<()> {\n        print_status(runtime.label(), \"Finding all Helix images on system...\");\n\n        let images = Self::get_helix_images(runtime)?;\n\n        if images.is_empty() {\n            print_status(runtime.label(), \"No Helix images found to clean\");\n            return Ok(());\n        }\n\n        let count = images.len();\n        print_status(\n            runtime.label(),\n            &format!(\"Found {count} Helix images to remove\"),\n        );\n\n        for image in images {\n            let output = Command::new(runtime.binary())\n                .args([\"rmi\", \"-f\", &image])\n                .output()\n                .map_err(|e| eyre!(\"Failed to remove image {image}: {e}\"))?;\n\n            if output.status.success() {\n                print_status(runtime.label(), &format!(\"Removed image: {image}\"));\n            } else {\n                let stderr = String::from_utf8_lossy(&output.stderr);\n                print_status(\n                    runtime.label(),\n                    &format!(\"Warning: Failed to remove {image}: {stderr}\"),\n                );\n            }\n        }\n\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tag_890": {
      "name": "tag",
      "type": "method",
      "start_line": 890,
      "end_line": 900,
      "content_hash": "98f8d42c26d1c1517ce3f20f19b3d535add46daa",
      "content": "    pub fn tag(&self, image_name: &str, registry_url: &str) -> Result<()> {\n        let registry_image = format!(\"{registry_url}/{image_name}\");\n        Command::new(self.runtime.binary())\n            .arg(\"tag\")\n            .arg(image_name)\n            .arg(&registry_image)\n            .output()?;\n\n        Ok(())\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_push_901": {
      "name": "push",
      "type": "method",
      "start_line": 901,
      "end_line": 921,
      "content_hash": "f2fd7726305532fc9606f8063caeecca1832c396",
      "content": "    pub fn push(&self, image_name: &str, registry_url: &str) -> Result<()> {\n        let registry_image = format!(\"{registry_url}/{image_name}\");\n        print_status(\n            self.runtime.label(),\n            &format!(\"Pushing image: {registry_image}\"),\n        );\n        let output = Command::new(self.runtime.binary())\n            .arg(\"push\")\n            .arg(&registry_image)\n            .output()?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            return Err(eyre!(\"Failed to push image: {}\", stderr));\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ContainerStatus_922": {
      "name": "ContainerStatus",
      "type": "struct",
      "start_line": 922,
      "end_line": 927,
      "content_hash": "0d4c1f281e25ef587b49fad025f5fca9ad55b179",
      "content": "pub struct ContainerStatus {\n    pub instance_name: String,\n    pub container_name: String,\n    pub status: String,\n    pub ports: String,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}