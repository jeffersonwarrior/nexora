{
  "file_path": "/work/internal/lsp/client.go",
  "file_hash": "e8e9c88daecd2498ed59df0b0be32aaa6773971c",
  "updated_at": "2025-12-26T17:34:21.024526",
  "symbols": {
    "struct_Client_24": {
      "name": "Client",
      "type": "struct",
      "start_line": 24,
      "end_line": 47,
      "content_hash": "d9c9860b580a631e6e4e2dbcf0b665cf3182583e",
      "content": "type Client struct {\n\tclient *powernap.Client\n\tname   string\n\n\t// File types this LSP server handles (e.g., .go, .rs, .py)\n\tfileTypes []string\n\n\t// Configuration for this LSP client\n\tconfig config.LSPConfig\n\n\t// Diagnostic change callback\n\tonDiagnosticsChanged func(name string, count int)\n\n\t// Diagnostic cache\n\tdiagnostics *csync.VersionedMap[protocol.DocumentURI, []protocol.Diagnostic]\n\n\t// Files are currently opened by the LSP\n\topenFiles *csync.Map[string, *OpenFileInfo]\n\n\t// Server state\n\tserverState atomic.Value\n}\n\n// New creates a new LSP client using the powernap implementation.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_New_48": {
      "name": "New",
      "type": "function",
      "start_line": 48,
      "end_line": 103,
      "content_hash": "9ff970dff22ee5890bcd8c2d0eebd8a11c22c27f",
      "content": "func New(ctx context.Context, name string, config config.LSPConfig, resolver config.VariableResolver) (*Client, error) {\n\t// Convert working directory to file URI\n\tworkDir, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get working directory: %w\", err)\n\t}\n\n\trootURI := string(protocol.URIFromPath(workDir))\n\n\tcommand, err := resolver.ResolveValue(config.Command)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid lsp command: %w\", err)\n\t}\n\n\t// Create powernap client config\n\tclientConfig := powernap.ClientConfig{\n\t\tCommand: home.Long(command),\n\t\tArgs:    config.Args,\n\t\tRootURI: rootURI,\n\t\tEnvironment: func() map[string]string {\n\t\t\tenv := make(map[string]string)\n\t\t\tmaps.Copy(env, config.Env)\n\t\t\treturn env\n\t\t}(),\n\t\tSettings:    config.Options,\n\t\tInitOptions: config.InitOptions,\n\t\tWorkspaceFolders: []protocol.WorkspaceFolder{\n\t\t\t{\n\t\t\t\tURI:  rootURI,\n\t\t\t\tName: filepath.Base(workDir),\n\t\t\t},\n\t\t},\n\t}\n\n\t// Create the powernap client\n\tpowernapClient, err := powernap.NewClient(clientConfig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create lsp client: %w\", err)\n\t}\n\n\tclient := &Client{\n\t\tclient:      powernapClient,\n\t\tname:        name,\n\t\tfileTypes:   config.FileTypes,\n\t\tdiagnostics: csync.NewVersionedMap[protocol.DocumentURI, []protocol.Diagnostic](),\n\t\topenFiles:   csync.NewMap[string, *OpenFileInfo](),\n\t\tconfig:      config,\n\t}\n\n\t// Initialize server state\n\tclient.serverState.Store(StateStarting)\n\n\treturn client, nil\n}\n\n// Initialize initializes the LSP client and returns the server capabilities.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Initialize_104": {
      "name": "Initialize",
      "type": "method",
      "start_line": 104,
      "end_line": 140,
      "content_hash": "a6510cbba7221d1c3bb675866ebb327ed551afb8",
      "content": "func (c *Client) Initialize(ctx context.Context, workspaceDir string) (*protocol.InitializeResult, error) {\n\tif err := c.client.Initialize(ctx, false); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize the lsp client: %w\", err)\n\t}\n\n\t// Convert powernap capabilities to protocol capabilities\n\tcaps := c.client.GetCapabilities()\n\tprotocolCaps := protocol.ServerCapabilities{\n\t\tTextDocumentSync: caps.TextDocumentSync,\n\t\tCompletionProvider: func() *protocol.CompletionOptions {\n\t\t\tif caps.CompletionProvider != nil {\n\t\t\t\treturn &protocol.CompletionOptions{\n\t\t\t\t\tTriggerCharacters:   caps.CompletionProvider.TriggerCharacters,\n\t\t\t\t\tAllCommitCharacters: caps.CompletionProvider.AllCommitCharacters,\n\t\t\t\t\tResolveProvider:     caps.CompletionProvider.ResolveProvider,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}(),\n\t}\n\n\tresult := &protocol.InitializeResult{\n\t\tCapabilities: protocolCaps,\n\t}\n\n\tc.RegisterServerRequestHandler(\"workspace/applyEdit\", HandleApplyEdit)\n\tc.RegisterServerRequestHandler(\"workspace/configuration\", HandleWorkspaceConfiguration)\n\tc.RegisterServerRequestHandler(\"client/registerCapability\", HandleRegisterCapability)\n\tc.RegisterNotificationHandler(\"window/showMessage\", HandleServerMessage)\n\tc.RegisterNotificationHandler(\"textDocument/publishDiagnostics\", func(_ context.Context, _ string, params json.RawMessage) {\n\t\tHandleDiagnostics(c, params)\n\t})\n\n\treturn result, nil\n}\n\n// Close closes the LSP client.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Close_141": {
      "name": "Close",
      "type": "method",
      "start_line": 141,
      "end_line": 166,
      "content_hash": "fefe202526437f80d2b2ef961dc9daccdcfd1651",
      "content": "func (c *Client) Close(ctx context.Context) error {\n\t// Try to close all open files first\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tc.CloseAllFiles(ctx)\n\n\t// Shutdown and exit the client\n\tif err := c.client.Shutdown(ctx); err != nil {\n\t\tslog.Warn(\"Failed to shutdown LSP client\", \"error\", err)\n\t}\n\n\treturn c.client.Exit()\n}\n\n// ServerState represents the state of an LSP server\ntype ServerState int\n\nconst (\n\tStateStarting ServerState = iota\n\tStateReady\n\tStateError\n\tStateDisabled\n)\n\n// GetServerState returns the current state of the LSP server",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetServerState_167": {
      "name": "GetServerState",
      "type": "method",
      "start_line": 167,
      "end_line": 174,
      "content_hash": "70f5e949cc82734cae1d30c04d16223eba68b732",
      "content": "func (c *Client) GetServerState() ServerState {\n\tif val := c.serverState.Load(); val != nil {\n\t\treturn val.(ServerState)\n\t}\n\treturn StateStarting\n}\n\n// SetServerState sets the current state of the LSP server",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetServerState_175": {
      "name": "SetServerState",
      "type": "method",
      "start_line": 175,
      "end_line": 179,
      "content_hash": "3907afd41cbea7a530dfd50aacc187ab3556daee",
      "content": "func (c *Client) SetServerState(state ServerState) {\n\tc.serverState.Store(state)\n}\n\n// GetName returns the name of the LSP client",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetName_180": {
      "name": "GetName",
      "type": "method",
      "start_line": 180,
      "end_line": 184,
      "content_hash": "089c7b97b53128ec5e7afedc33c6479c41754c35",
      "content": "func (c *Client) GetName() string {\n\treturn c.name\n}\n\n// SetDiagnosticsCallback sets the callback function for diagnostic changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetDiagnosticsCallback_185": {
      "name": "SetDiagnosticsCallback",
      "type": "method",
      "start_line": 185,
      "end_line": 189,
      "content_hash": "47ab1ef3533fbba9d7076115e798ab23a6d4a114",
      "content": "func (c *Client) SetDiagnosticsCallback(callback func(name string, count int)) {\n\tc.onDiagnosticsChanged = callback\n}\n\n// WaitForServerReady waits for the server to be ready",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_WaitForServerReady_190": {
      "name": "WaitForServerReady",
      "type": "method",
      "start_line": 190,
      "end_line": 234,
      "content_hash": "70791a5764e7f90b5ffd9cbbba6faf95e7aca3c6",
      "content": "func (c *Client) WaitForServerReady(ctx context.Context) error {\n\tcfg := config.Get()\n\n\t// Set initial state\n\tc.SetServerState(StateStarting)\n\n\t// Create a context with timeout\n\tctx, cancel := context.WithTimeout(ctx, 30*time.Second)\n\tdefer cancel()\n\n\t// Try to ping the server with a simple request\n\tticker := time.NewTicker(500 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tif cfg != nil && cfg.Options.DebugLSP {\n\t\tslog.Debug(\"Waiting for LSP server to be ready...\")\n\t}\n\n\tc.openKeyConfigFiles(ctx)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tc.SetServerState(StateError)\n\t\t\treturn fmt.Errorf(\"timeout waiting for LSP server to be ready\")\n\t\tcase <-ticker.C:\n\t\t\t// Check if client is running\n\t\t\tif !c.client.IsRunning() {\n\t\t\t\tif cfg != nil && cfg.Options.DebugLSP {\n\t\t\t\t\tslog.Debug(\"LSP server not ready yet\", \"server\", c.name)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Server is ready\n\t\t\tc.SetServerState(StateReady)\n\t\t\tif cfg != nil && cfg.Options.DebugLSP {\n\t\t\t\tslog.Debug(\"LSP server is ready\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// OpenFileInfo contains information about an open file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OpenFileInfo_235": {
      "name": "OpenFileInfo",
      "type": "struct",
      "start_line": 235,
      "end_line": 240,
      "content_hash": "331896feec07f17f11fa2bbde95d7915f6c149ff",
      "content": "type OpenFileInfo struct {\n\tVersion int32\n\tURI     protocol.DocumentURI\n}\n\n// HandlesFile checks if this LSP client handles the given file based on its extension.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_HandlesFile_241": {
      "name": "HandlesFile",
      "type": "method",
      "start_line": 241,
      "end_line": 262,
      "content_hash": "323e09bc75214e3b0cee2a76a61eb1502215522b",
      "content": "func (c *Client) HandlesFile(path string) bool {\n\t// If no file types are specified, handle all files (backward compatibility)\n\tif len(c.fileTypes) == 0 {\n\t\treturn true\n\t}\n\n\tname := strings.ToLower(filepath.Base(path))\n\tfor _, filetype := range c.fileTypes {\n\t\tsuffix := strings.ToLower(filetype)\n\t\tif !strings.HasPrefix(suffix, \".\") {\n\t\t\tsuffix = \".\" + suffix\n\t\t}\n\t\tif strings.HasSuffix(name, suffix) {\n\t\t\tslog.Debug(\"handles file\", \"name\", c.name, \"file\", name, \"filetype\", filetype)\n\t\t\treturn true\n\t\t}\n\t}\n\tslog.Debug(\"doesn't handle file\", \"name\", c.name, \"file\", name)\n\treturn false\n}\n\n// OpenFile opens a file in the LSP server.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_OpenFile_263": {
      "name": "OpenFile",
      "type": "method",
      "start_line": 263,
      "end_line": 293,
      "content_hash": "b61e84259d75fc5ddbc3892085b07edd6bdaf314",
      "content": "func (c *Client) OpenFile(ctx context.Context, filepath string) error {\n\tif !c.HandlesFile(filepath) {\n\t\treturn nil\n\t}\n\n\turi := string(protocol.URIFromPath(filepath))\n\n\tif _, exists := c.openFiles.Get(uri); exists {\n\t\treturn nil // Already open\n\t}\n\n\t// Skip files that do not exist or cannot be read\n\tcontent, err := os.ReadFile(filepath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading file: %w\", err)\n\t}\n\n\t// Notify the server about the opened document\n\tif err = c.client.NotifyDidOpenTextDocument(ctx, uri, string(DetectLanguageID(uri)), 1, string(content)); err != nil {\n\t\treturn err\n\t}\n\n\tc.openFiles.Set(uri, &OpenFileInfo{\n\t\tVersion: 1,\n\t\tURI:     protocol.DocumentURI(uri),\n\t})\n\n\treturn nil\n}\n\n// NotifyChange notifies the server about a file change.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_NotifyChange_294": {
      "name": "NotifyChange",
      "type": "method",
      "start_line": 294,
      "end_line": 322,
      "content_hash": "abd9f1ace92728432c8fa009c92c4548af7cac86",
      "content": "func (c *Client) NotifyChange(ctx context.Context, filepath string) error {\n\turi := string(protocol.URIFromPath(filepath))\n\n\tcontent, err := os.ReadFile(filepath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading file: %w\", err)\n\t}\n\n\tfileInfo, isOpen := c.openFiles.Get(uri)\n\tif !isOpen {\n\t\treturn fmt.Errorf(\"cannot notify change for unopened file: %s\", filepath)\n\t}\n\n\t// Increment version\n\tfileInfo.Version++\n\n\t// Create change event\n\tchanges := []protocol.TextDocumentContentChangeEvent{\n\t\t{\n\t\t\tValue: protocol.TextDocumentContentChangeWholeDocument{\n\t\t\t\tText: string(content),\n\t\t\t},\n\t\t},\n\t}\n\n\treturn c.client.NotifyDidChangeTextDocument(ctx, uri, int(fileInfo.Version), changes)\n}\n\n// IsFileOpen checks if a file is currently open.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsFileOpen_323": {
      "name": "IsFileOpen",
      "type": "method",
      "start_line": 323,
      "end_line": 329,
      "content_hash": "ce573a4974227f28ea3051e5b5589fad6e215640",
      "content": "func (c *Client) IsFileOpen(filepath string) bool {\n\turi := string(protocol.URIFromPath(filepath))\n\t_, exists := c.openFiles.Get(uri)\n\treturn exists\n}\n\n// CloseAllFiles closes all currently open files.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CloseAllFiles_330": {
      "name": "CloseAllFiles",
      "type": "method",
      "start_line": 330,
      "end_line": 345,
      "content_hash": "09300a1d5b63b84a29903e16708f0b40eddfb683",
      "content": "func (c *Client) CloseAllFiles(ctx context.Context) {\n\tcfg := config.Get()\n\tdebugLSP := cfg != nil && cfg.Options.DebugLSP\n\tfor uri := range c.openFiles.Seq2() {\n\t\tif debugLSP {\n\t\t\tslog.Debug(\"Closing file\", \"file\", uri)\n\t\t}\n\t\tif err := c.client.NotifyDidCloseTextDocument(ctx, uri); err != nil {\n\t\t\tslog.Warn(\"Error closing rile\", \"uri\", uri, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t\tc.openFiles.Del(uri)\n\t}\n}\n\n// GetFileDiagnostics returns diagnostics for a specific file.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetFileDiagnostics_346": {
      "name": "GetFileDiagnostics",
      "type": "method",
      "start_line": 346,
      "end_line": 351,
      "content_hash": "19ef677d42ca5e3729c4112028f3c5c114685d6a",
      "content": "func (c *Client) GetFileDiagnostics(uri protocol.DocumentURI) []protocol.Diagnostic {\n\tdiags, _ := c.diagnostics.Get(uri)\n\treturn diags\n}\n\n// GetDiagnostics returns all diagnostics for all files.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetDiagnostics_352": {
      "name": "GetDiagnostics",
      "type": "method",
      "start_line": 352,
      "end_line": 356,
      "content_hash": "5d9a983effcb25fac0c95a0e33c4dc6c7f3f37d9",
      "content": "func (c *Client) GetDiagnostics() map[protocol.DocumentURI][]protocol.Diagnostic {\n\treturn maps.Collect(c.diagnostics.Seq2())\n}\n\n// OpenFileOnDemand opens a file only if it's not already open.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_OpenFileOnDemand_357": {
      "name": "OpenFileOnDemand",
      "type": "method",
      "start_line": 357,
      "end_line": 367,
      "content_hash": "87b90c6f7b86527af6464892994fad3eea570423",
      "content": "func (c *Client) OpenFileOnDemand(ctx context.Context, filepath string) error {\n\t// Check if the file is already open\n\tif c.IsFileOpen(filepath) {\n\t\treturn nil\n\t}\n\n\t// Open the file\n\treturn c.OpenFile(ctx, filepath)\n}\n\n// GetDiagnosticsForFile ensures a file is open and returns its diagnostics.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetDiagnosticsForFile_368": {
      "name": "GetDiagnosticsForFile",
      "type": "method",
      "start_line": 368,
      "end_line": 387,
      "content_hash": "01f86ef4b7bbf2b057a971d44026df99657d7ef4",
      "content": "func (c *Client) GetDiagnosticsForFile(ctx context.Context, filepath string) ([]protocol.Diagnostic, error) {\n\tdocumentURI := protocol.URIFromPath(filepath)\n\n\t// Make sure the file is open\n\tif !c.IsFileOpen(filepath) {\n\t\tif err := c.OpenFile(ctx, filepath); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to open file for diagnostics: %w\", err)\n\t\t}\n\n\t\t// Give the LSP server a moment to process the file\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\n\t// Get diagnostics\n\tdiagnostics, _ := c.diagnostics.Get(documentURI)\n\n\treturn diagnostics, nil\n}\n\n// ClearDiagnosticsForURI removes diagnostics for a specific URI from the cache.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ClearDiagnosticsForURI_388": {
      "name": "ClearDiagnosticsForURI",
      "type": "method",
      "start_line": 388,
      "end_line": 392,
      "content_hash": "c2c3c6e402d2e2c79dd13efc49fae90a6cf39d19",
      "content": "func (c *Client) ClearDiagnosticsForURI(uri protocol.DocumentURI) {\n\tc.diagnostics.Del(uri)\n}\n\n// RegisterNotificationHandler registers a notification handler.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RegisterNotificationHandler_393": {
      "name": "RegisterNotificationHandler",
      "type": "method",
      "start_line": 393,
      "end_line": 397,
      "content_hash": "8f93878f4a992fa3341cd7e6d498acc125af80fb",
      "content": "func (c *Client) RegisterNotificationHandler(method string, handler transport.NotificationHandler) {\n\tc.client.RegisterNotificationHandler(method, handler)\n}\n\n// RegisterServerRequestHandler handles server requests.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RegisterServerRequestHandler_398": {
      "name": "RegisterServerRequestHandler",
      "type": "method",
      "start_line": 398,
      "end_line": 402,
      "content_hash": "2dde4ebf96d267ac5909fdfb5a841de9d005976c",
      "content": "func (c *Client) RegisterServerRequestHandler(method string, handler transport.Handler) {\n\tc.client.RegisterHandler(method, handler)\n}\n\n// DidChangeWatchedFiles sends a workspace/didChangeWatchedFiles notification to the server.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_DidChangeWatchedFiles_403": {
      "name": "DidChangeWatchedFiles",
      "type": "method",
      "start_line": 403,
      "end_line": 407,
      "content_hash": "3158c11a7b2217633b5b176ed01881722ef13300",
      "content": "func (c *Client) DidChangeWatchedFiles(ctx context.Context, params protocol.DidChangeWatchedFilesParams) error {\n\treturn c.client.NotifyDidChangeWatchedFiles(ctx, params.Changes)\n}\n\n// openKeyConfigFiles opens important configuration files that help initialize the server.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_openKeyConfigFiles_408": {
      "name": "openKeyConfigFiles",
      "type": "method",
      "start_line": 408,
      "end_line": 428,
      "content_hash": "00e1660c49a16ec098ccfb4864e9802718ecc0d5",
      "content": "func (c *Client) openKeyConfigFiles(ctx context.Context) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Try to open each file, ignoring errors if they don't exist\n\tfor _, file := range c.config.RootMarkers {\n\t\tfile = filepath.Join(wd, file)\n\t\tif _, err := os.Stat(file); err == nil {\n\t\t\t// File exists, try to open it\n\t\t\tif err := c.OpenFile(ctx, file); err != nil {\n\t\t\t\tslog.Error(\"Failed to open key config file\", \"file\", file, \"error\", err)\n\t\t\t} else {\n\t\t\t\tslog.Debug(\"Opened key config file for initialization\", \"file\", file)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// WaitForDiagnostics waits until diagnostics change or the timeout is reached.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_WaitForDiagnostics_429": {
      "name": "WaitForDiagnostics",
      "type": "method",
      "start_line": 429,
      "end_line": 448,
      "content_hash": "305babbd6fbde693ec5c24b8d7fac3abeda81bc4",
      "content": "func (c *Client) WaitForDiagnostics(ctx context.Context, d time.Duration) {\n\tticker := time.NewTicker(200 * time.Millisecond)\n\tdefer ticker.Stop()\n\ttimeout := time.After(d)\n\tpv := c.diagnostics.Version()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-timeout:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tif pv != c.diagnostics.Version() {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// FindReferences finds all references to the symbol at the given position.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_FindReferences_449": {
      "name": "FindReferences",
      "type": "method",
      "start_line": 449,
      "end_line": 459,
      "content_hash": "50a38813631a61dc9d4ada716577e8c8793319cd",
      "content": "func (c *Client) FindReferences(ctx context.Context, filepath string, line, character int, includeDeclaration bool) ([]protocol.Location, error) {\n\tif err := c.OpenFileOnDemand(ctx, filepath); err != nil {\n\t\treturn nil, err\n\t}\n\t// NOTE: line and character should be 0-based.\n\t// See: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#position\n\treturn c.client.FindReferences(ctx, filepath, line-1, character-1, includeDeclaration)\n}\n\n// HasRootMarkers checks if any of the specified root marker patterns exist in the given directory.\n// Uses glob patterns to match files, allowing for more flexible matching.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_HasRootMarkers_460": {
      "name": "HasRootMarkers",
      "type": "function",
      "start_line": 460,
      "end_line": 472,
      "content_hash": "bf789e4db6eac449603f6fa7a5deb51f7dc648a4",
      "content": "func HasRootMarkers(dir string, rootMarkers []string) bool {\n\tif len(rootMarkers) == 0 {\n\t\treturn true\n\t}\n\tfor _, pattern := range rootMarkers {\n\t\t// Use fsext.GlobWithDoubleStar to find matches\n\t\tmatches, _, err := fsext.GlobWithDoubleStar(pattern, dir, 1)\n\t\tif err == nil && len(matches) > 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}