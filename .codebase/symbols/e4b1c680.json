{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/graph_step_parse_methods.rs",
  "file_hash": "da62f8291e4b9b34d0de955c56a6085cc10721f6",
  "updated_at": "2025-12-26T17:34:20.955175",
  "symbols": {
    "impl_HelixParser_14": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 14,
      "end_line": 737,
      "content_hash": "43b087fdc6efb2305d7923b529dabf48603410bb",
      "content": "impl HelixParser {\n    /// Parses an order by step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::ORDER<Asc>(_::{age})\n    /// ```\n    pub(super) fn parse_order_by(&self, pair: Pair<Rule>) -> Result<OrderBy, ParserError> {\n        let mut inner = pair.clone().into_inner();\n        let order_by_rule = inner.try_next_inner().try_next()?;\n        let order_by_type = match order_by_rule.as_rule() {\n            Rule::asc => OrderByType::Asc,\n            Rule::desc => OrderByType::Desc,\n            other => return Err(ParserError::from(format!(\n                \"Unexpected rule in parse_order_by: {:?}\",\n                other\n            ))),\n        };\n        let expression = self.parse_expression(inner.try_next()?)?;\n        Ok(OrderBy {\n            loc: pair.loc(),\n            order_by_type,\n            expression: Box::new(expression),\n        })\n    }\n\n    /// Parses a range step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::RANGE(1, 10)\n    /// ```\n    #[track_caller]\n    pub(super) fn parse_range(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<(Expression, Expression), ParserError> {\n        let mut inner = pair.into_inner();\n        let start = self.parse_expression(inner.try_next()?)?;\n        let end = self.parse_expression(inner.try_next()?)?;\n\n        Ok((start, end))\n    }\n\n    /// Parses a boolean operation\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::GT(1)\n    /// ```\n    pub(super) fn parse_bool_operation(&self, pair: Pair<Rule>) -> Result<BooleanOp, ParserError> {\n        let inner = pair.clone().try_inner_next()?;\n        let expr = match inner.as_rule() {\n            Rule::GT => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::GreaterThan(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::GTE => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::GreaterThanOrEqual(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::LT => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::LessThan(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::LTE => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::LessThanOrEqual(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::EQ => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::Equal(Box::new(self.parse_expression(inner.try_inner_next()?)?)),\n            },\n            Rule::NEQ => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::NotEqual(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::CONTAINS => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::Contains(Box::new(\n                    self.parse_expression(inner.try_inner_next()?)?,\n                )),\n            },\n            Rule::IS_IN => BooleanOp {\n                loc: pair.loc(),\n                op: BooleanOpType::IsIn(Box::new(self.parse_expression(inner)?)),\n            },\n            _ => return Err(ParserError::from(\"Invalid boolean operation\")),\n        };\n        Ok(expr)\n    }\n\n    /// Parses an update step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::UPDATE({age: 1})\n    /// ```\n    pub(super) fn parse_update(&self, pair: Pair<Rule>) -> Result<Update, ParserError> {\n        let fields = self.parse_object_fields(pair.clone())?;\n        Ok(Update {\n            fields,\n            loc: pair.loc(),\n        })\n    }\n\n    /// Parses an object step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::{username: name}\n    /// ```\n    pub(super) fn parse_object_step(&self, pair: Pair<Rule>) -> Result<Object, ParserError> {\n        let mut fields = Vec::new();\n        let mut should_spread = false;\n        for p in pair.clone().into_inner() {\n            if p.as_rule() == Rule::spread_object {\n                should_spread = true;\n                continue;\n            }\n            let mut pairs = p.clone().into_inner();\n            let prop_key = pairs.try_next()?.as_str().to_string();\n            let field_addition = match pairs.next() {\n                Some(p) => match p.as_rule() {\n                    Rule::evaluates_to_anything => FieldValue {\n                        loc: p.loc(),\n                        value: FieldValueType::Expression(self.parse_expression(p)?),\n                    },\n                    Rule::anonymous_traversal => FieldValue {\n                        loc: p.loc(),\n                        value: FieldValueType::Traversal(Box::new(self.parse_anon_traversal(p)?)),\n                    },\n                    Rule::id_traversal => FieldValue {\n                        loc: p.loc(),\n                        value: FieldValueType::Traversal(Box::new(self.parse_traversal(p)?)),\n                    },\n                    Rule::mapping_field => FieldValue {\n                        loc: p.loc(),\n                        value: FieldValueType::Fields(self.parse_object_fields(p)?),\n                    },\n                    Rule::object_step => FieldValue {\n                        loc: p.clone().loc(),\n                        value: FieldValueType::Fields(self.parse_object_step(p.clone())?.fields),\n                    },\n                    _ => self.parse_new_field_value(p)?,\n                },\n                None if !prop_key.is_empty() => FieldValue {\n                    loc: p.loc(),\n                    value: FieldValueType::Identifier(prop_key.clone()),\n                },\n                None => FieldValue {\n                    loc: p.loc(),\n                    value: FieldValueType::Empty,\n                },\n            };\n            fields.push(FieldAddition {\n                loc: p.loc(),\n                key: prop_key,\n                value: field_addition,\n            });\n        }\n        Ok(Object {\n            loc: pair.loc(),\n            fields,\n            should_spread,\n        })\n    }\n\n    /// Parses a closure step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::|user|{user_age: user::{age}}\n    /// ```\n    pub(super) fn parse_closure(&self, pair: Pair<Rule>) -> Result<Closure, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let identifier = pairs.try_next()?.as_str().to_string();\n        let object = self.parse_object_step(pairs.try_next()?)?;\n        Ok(Closure {\n            loc: pair.loc(),\n            identifier,\n            object,\n        })\n    }\n\n    /// Parses an exclude step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::!{age, name}\n    /// ```\n    pub(super) fn parse_exclude(&self, pair: Pair<Rule>) -> Result<Exclude, ParserError> {\n        let mut fields = Vec::new();\n        for p in pair.clone().into_inner() {\n            fields.push((p.loc(), p.as_str().to_string()));\n        }\n        Ok(Exclude {\n            loc: pair.loc(),\n            fields,\n        })\n    }\n\n    pub(super) fn parse_aggregate(&self, pair: Pair<Rule>) -> Result<Aggregate, ParserError> {\n        let loc = pair.loc();\n        let identifiers = pair\n            .into_inner()\n            .map(|i| i.as_str().to_string())\n            .collect::<Vec<_>>();\n\n        Ok(Aggregate {\n            loc,\n            properties: identifiers,\n        })\n    }\n\n    pub(super) fn parse_group_by(&self, pair: Pair<Rule>) -> Result<GroupBy, ParserError> {\n        let loc = pair.loc();\n        let identifiers = pair\n            .into_inner()\n            .map(|i| i.as_str().to_string())\n            .collect::<Vec<_>>();\n\n        Ok(GroupBy {\n            loc,\n            properties: identifiers,\n        })\n    }\n\n    pub(super) fn parse_step(&self, pair: Pair<Rule>) -> Result<Step, ParserError> {\n        let step_pair = pair.clone().try_inner_next()?;\n        match step_pair.as_rule() {\n            Rule::graph_step => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Node(self.parse_graph_step(step_pair)?),\n            }),\n            Rule::object_step => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Object(self.parse_object_step(step_pair)?),\n            }),\n            Rule::closure_step => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Closure(self.parse_closure(step_pair)?),\n            }),\n            Rule::where_step => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Where(Box::new(self.parse_expression(step_pair)?)),\n            }),\n            Rule::range_step => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Range(self.parse_range(step_pair)?),\n            }),\n\n            Rule::bool_operations => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::BooleanOperation(self.parse_bool_operation(step_pair)?),\n            }),\n            Rule::count => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Count,\n            }),\n            Rule::ID => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Object(Object {\n                    fields: vec![FieldAddition {\n                        key: \"id\".to_string(),\n                        value: FieldValue {\n                            loc: step_pair.loc(),\n                            value: FieldValueType::Identifier(\"id\".to_string()),\n                        },\n                        loc: step_pair.loc(),\n                    }],\n                    should_spread: false,\n                    loc: step_pair.loc(),\n                }),\n            }),\n            Rule::update => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Update(self.parse_update(step_pair)?),\n            }),\n            Rule::exclude_field => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Exclude(self.parse_exclude(step_pair)?),\n            }),\n            Rule::AddE => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::AddEdge(self.parse_add_edge(step_pair, true)?),\n            }),\n            Rule::order_by => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::OrderBy(self.parse_order_by(step_pair)?),\n            }),\n            Rule::aggregate => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::Aggregate(self.parse_aggregate(step_pair)?),\n            }),\n            Rule::group_by => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::GroupBy(self.parse_group_by(step_pair)?),\n            }),\n            Rule::first => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::First,\n            }),\n            Rule::rerank_rrf => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::RerankRRF(self.parse_rerank_rrf(step_pair)?),\n            }),\n            Rule::rerank_mmr => Ok(Step {\n                loc: step_pair.loc(),\n                step: StepType::RerankMMR(self.parse_rerank_mmr(step_pair)?),\n            }),\n            _ => Err(ParserError::from(format!(\n                \"Unexpected step type: {:?}\",\n                step_pair.as_rule()\n            ))),\n        }\n    }\n\n    pub(super) fn parse_graph_step(&self, pair: Pair<Rule>) -> Result<GraphStep, ParserError> {\n        let types = |pair: &Pair<Rule>| -> Result<String, ParserError> {\n            pair.clone()\n                .into_inner()\n                .next()\n                .map(|p| p.as_str().to_string())\n                .ok_or_else(|| ParserError::from(format!(\"Expected type for {:?}\", pair.as_rule())))\n        };\n        let pair = pair.clone().try_inner_next()?;\n        let step = match pair.as_rule() {\n            Rule::out_e => {\n                let types = types(&pair)?;\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::OutE(types),\n                }\n            }\n            Rule::in_e => {\n                let types = types(&pair)?;\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::InE(types),\n                }\n            }\n            Rule::from_n => GraphStep {\n                loc: pair.loc(),\n                step: GraphStepType::FromN,\n            },\n            Rule::to_n => GraphStep {\n                loc: pair.loc(),\n                step: GraphStepType::ToN,\n            },\n            Rule::from_v => GraphStep {\n                loc: pair.loc(),\n                step: GraphStepType::FromV,\n            },\n            Rule::to_v => GraphStep {\n                loc: pair.loc(),\n                step: GraphStepType::ToV,\n            },\n            Rule::out => {\n                let types = types(&pair)?;\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::Out(types),\n                }\n            }\n            Rule::in_nodes => {\n                let types = types(&pair)?;\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::In(types),\n                }\n            }\n            Rule::shortest_path => {\n                let (type_arg, from, to) = match pair.clone().into_inner().try_fold(\n                    (None, None, None),\n                    |(type_arg, from, to), p| match p.as_rule() {\n                        Rule::type_args => {\n                            Ok((Some(p.try_inner_next()?.as_str().to_string()), from, to))\n                        }\n                        Rule::to_from => match p.into_inner().next() {\n                            Some(p) => match p.as_rule() {\n                                Rule::to => Ok((\n                                    type_arg,\n                                    from,\n                                    Some(p.try_inner_next()?.as_str().to_string()),\n                                )),\n                                Rule::from => Ok((\n                                    type_arg,\n                                    Some(p.try_inner_next()?.as_str().to_string()),\n                                    to,\n                                )),\n                                other => Err(ParserError::from(format!(\n                                    \"Unexpected rule in shortest_path to_from: {:?}\",\n                                    other\n                                ))),\n                            },\n                            None => Ok((type_arg, from, to)),\n                        },\n                        _ => Ok((type_arg, from, to)),\n                    },\n                ) {\n                    Ok((type_arg, from, to)) => (type_arg, from, to),\n                    Err(e) => return Err(e),\n                };\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::ShortestPath(ShortestPath {\n                        loc: pair.loc(),\n                        from: from.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        to: to.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        type_arg,\n                    }),\n                }\n            }\n            Rule::shortest_path_dijkstras => {\n                let (type_arg, weight_expression, from, to) =\n                    match pair.clone().into_inner().try_fold(\n                        (None, None, None, None),\n                        |(type_arg, weight_expr, from, to), p| match p.as_rule() {\n                            Rule::type_args => Ok((\n                                Some(p.try_inner_next()?.as_str().to_string()),\n                                weight_expr,\n                                from,\n                                to,\n                            )),\n                            Rule::math_expression => {\n                                // Parse the math_expression into an Expression\n                                let expr = self.parse_math_expression(p)?;\n                                Ok((\n                                    type_arg,\n                                    Some(expr),\n                                    from,\n                                    to,\n                                ))\n                            },\n                            Rule::to_from => match p.into_inner().next() {\n                                Some(p) => match p.as_rule() {\n                                    Rule::to => Ok((\n                                        type_arg,\n                                        weight_expr,\n                                        from,\n                                        Some(p.into_inner().next().unwrap().as_str().to_string()),\n                                    )),\n                                    Rule::from => Ok((\n                                        type_arg,\n                                        weight_expr,\n                                        Some(p.into_inner().next().unwrap().as_str().to_string()),\n                                        to,\n                                    )),\n                                    other => Err(ParserError::from(format!(\n                                        \"Unexpected rule in shortest_path_dijkstras to_from: {:?}\",\n                                        other\n                                    ))),\n                                },\n                                None => Ok((type_arg, weight_expr, from, to)),\n                            },\n                            _ => Ok((type_arg, weight_expr, from, to)),\n                        },\n                    ) {\n                        Ok((type_arg, weight_expr, from, to)) => {\n                            (type_arg, weight_expr, from, to)\n                        }\n                        Err(e) => return Err(e),\n                    };\n\n                // Determine weight expression type\n                let (inner_traversal, weight_expr_typed) = if let Some(expr) = weight_expression {\n                    // Check if it's a simple property access or a complex expression\n                    let weight_type = match &expr.expr {\n                        ExpressionType::Traversal(_trav) => {\n                            // For now, keep the traversal and create a Property weight expression\n                            // TODO: Extract property name from traversal for simple cases\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                        ExpressionType::MathFunctionCall(_) => {\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                        _ => {\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                    };\n                    (None, weight_type)\n                } else {\n                    (None, Some(crate::helixc::parser::types::WeightExpression::Default))\n                };\n\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::ShortestPathDijkstras(ShortestPathDijkstras {\n                        loc: pair.loc(),\n                        from: from.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        to: to.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        type_arg,\n                        inner_traversal,\n                        weight_expr: weight_expr_typed,\n                    }),\n                }\n            }\n            Rule::shortest_path_bfs => {\n                let (type_arg, from, to) = match pair.clone().into_inner().try_fold(\n                    (None, None, None),\n                    |(type_arg, from, to), p| match p.as_rule() {\n                        Rule::type_args => Ok((\n                            Some(p.into_inner().next().unwrap().as_str().to_string()),\n                            from,\n                            to,\n                        )),\n                        Rule::to_from => match p.into_inner().next() {\n                            Some(p) => match p.as_rule() {\n                                Rule::to => Ok((\n                                    type_arg,\n                                    from,\n                                    Some(p.into_inner().next().unwrap().as_str().to_string()),\n                                )),\n                                Rule::from => Ok((\n                                    type_arg,\n                                    Some(p.into_inner().next().unwrap().as_str().to_string()),\n                                    to,\n                                )),\n                                other => Err(ParserError::from(format!(\n                                    \"Unexpected rule in shortest_path_bfs to_from: {:?}\",\n                                    other\n                                ))),\n                            },\n                            None => Ok((type_arg, from, to)),\n                        },\n                        _ => Ok((type_arg, from, to)),\n                    },\n                ) {\n                    Ok((type_arg, from, to)) => (type_arg, from, to),\n                    Err(e) => return Err(e),\n                };\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::ShortestPathBFS(ShortestPathBFS {\n                        loc: pair.loc(),\n                        from: from.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        to: to.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        type_arg,\n                    }),\n                }\n            }\n            Rule::shortest_path_astar => {\n                // Parse: ShortestPathAStar<Type>(weight_expr, \"heuristic_property\")\n                let mut type_arg: Option<String> = None;\n                let mut weight_expression: Option<Expression> = None;\n                let mut heuristic_property: Option<String> = None;\n                let mut from: Option<String> = None;\n                let mut to: Option<String> = None;\n\n                for inner_pair in pair.clone().into_inner() {\n                    match inner_pair.as_rule() {\n                        Rule::type_args => {\n                            type_arg = Some(inner_pair.into_inner().next().unwrap().as_str().to_string());\n                        }\n                        Rule::math_expression => {\n                            weight_expression = Some(self.parse_expression(inner_pair)?);\n                        }\n                        Rule::string_literal => {\n                            // Extract string content (remove quotes)\n                            let literal = inner_pair.as_str();\n                            heuristic_property = Some(literal[1..literal.len() - 1].to_string());\n                        }\n                        Rule::to_from => {\n                            if let Some(p) = inner_pair.into_inner().next() { match p.as_rule() {\n                                Rule::to => {\n                                    to = Some(p.into_inner().next().unwrap().as_str().to_string());\n                                }\n                                Rule::from => {\n                                    from = Some(p.into_inner().next().unwrap().as_str().to_string());\n                                }\n                                _ => {}\n                            } }\n                        }\n                        _ => {}\n                    }\n                }\n\n                // Determine weight expression type\n                let (inner_traversal, weight_expr_typed) = if let Some(expr) = weight_expression {\n                    let weight_type = match &expr.expr {\n                        ExpressionType::Traversal(_trav) => {\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                        ExpressionType::MathFunctionCall(_) => {\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                        _ => {\n                            Some(crate::helixc::parser::types::WeightExpression::Expression(Box::new(expr.clone())))\n                        }\n                    };\n                    (None, weight_type)\n                } else {\n                    (None, Some(crate::helixc::parser::types::WeightExpression::Default))\n                };\n\n                GraphStep {\n                    loc: pair.loc(),\n                    step: GraphStepType::ShortestPathAStar(ShortestPathAStar {\n                        loc: pair.loc(),\n                        from: from.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        to: to.map(|id| IdType::Identifier {\n                            value: id,\n                            loc: pair.loc(),\n                        }),\n                        type_arg,\n                        inner_traversal,\n                        weight_expr: weight_expr_typed,\n                        heuristic_property: heuristic_property.unwrap_or_else(|| \"h\".to_string()),\n                    }),\n                }\n            }\n\n            Rule::search_vector => GraphStep {\n                loc: pair.loc(),\n                step: GraphStepType::SearchVector(self.parse_search_vector(pair)?),\n            },\n            _ => {\n                return Err(ParserError::from(format!(\n                    \"Unexpected graph step type: {:?}\",\n                    pair.as_rule()\n                )));\n            }\n        };\n        Ok(step)\n    }\n\n    /// Parses a RerankRRF step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::RerankRRF(k: 60)\n    /// ::RerankRRF()\n    /// ```\n    pub(super) fn parse_rerank_rrf(&self, pair: Pair<Rule>) -> Result<RerankRRF, ParserError> {\n        let loc = pair.loc();\n        let mut k = None;\n\n        // Parse optional k parameter\n        for inner in pair.into_inner() {\n            // The grammar is: \"k\" ~ \":\" ~ evaluates_to_number\n            // We need to parse the evaluates_to_number part\n            k = Some(self.parse_expression(inner)?);\n        }\n\n        Ok(RerankRRF { loc, k })\n    }\n\n    /// Parses a RerankMMR step\n    ///\n    /// #### Example\n    /// ```rs\n    /// ::RerankMMR(lambda: 0.7)\n    /// ::RerankMMR(lambda: 0.5, distance: \"euclidean\")\n    /// ```\n    pub(super) fn parse_rerank_mmr(&self, pair: Pair<Rule>) -> Result<RerankMMR, ParserError> {\n        let loc = pair.loc();\n        let mut lambda = None;\n        let mut distance = None;\n\n        // Parse parameters\n        let mut inner = pair.into_inner();\n\n        // First parameter is always lambda (required)\n        if let Some(lambda_expr) = inner.next() {\n            lambda = Some(self.parse_expression(lambda_expr)?);\n        }\n\n        // Second parameter is optional distance\n        if let Some(distance_pair) = inner.next() {\n            let dist_str = match distance_pair.as_rule() {\n                Rule::string_literal => {\n                    // Remove quotes from string literal\n                    let s = distance_pair.as_str();\n                    s.trim_matches('\"').to_string()\n                }\n                Rule::identifier => distance_pair.as_str().to_string(),\n                _ => distance_pair.as_str().to_string(),\n            };\n\n            distance = Some(match dist_str.as_str() {\n                \"cosine\" => MMRDistance::Cosine,\n                \"euclidean\" => MMRDistance::Euclidean,\n                \"dotproduct\" => MMRDistance::DotProduct,\n                _ => MMRDistance::Identifier(dist_str),\n            });\n        }\n\n        let lambda = lambda.ok_or_else(|| ParserError::from(\"lambda parameter required for RerankMMR\"))?;\n\n        Ok(RerankMMR { loc, lambda, distance })\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}