{
  "file_path": "/work/external-deps/claude-swarm/dist/workers/manager.d.ts",
  "file_hash": "858fb716c0a5a80a98cea5374368fbd5c206f83a",
  "updated_at": "2025-12-26T17:34:22.434793",
  "symbols": {
    "class_WorkerManager_37": {
      "name": "WorkerManager",
      "type": "class",
      "start_line": 37,
      "end_line": 136,
      "content_hash": "3b6e58c7cfe00e8498164d9beb66358f32c7588d",
      "content": "export declare class WorkerManager {\n    private projectDir;\n    private stateManager;\n    private workerDir;\n    private monitorInterval;\n    private completionCallbacks;\n    private lastKnownStatus;\n    constructor(projectDir: string, stateManager: StateManager);\n    /**\n     * Generate a unique session name for a worker\n     */\n    private generateSessionName;\n    /**\n     * Extract feature ID from session name\n     */\n    private extractFeatureId;\n    /**\n     * Read project context files (CLAUDE.md, .clauderc, etc.)\n     * Returns combined content or empty string if none found\n     */\n    private readProjectContext;\n    /**\n     * Build the prompt for a worker\n     */\n    private buildWorkerPrompt;\n    /**\n     * Build a specialized prompt for planning mode workers\n     * These workers create implementation plans without writing code\n     */\n    private buildPlannerPrompt;\n    /**\n     * Start a worker in planning mode\n     * Returns a unique session name for tracking\n     */\n    startPlannerWorker(feature: Feature, role: \"A\" | \"B\", customPrompt?: string): Promise<StartWorkerResult>;\n    /**\n     * Check if a plan file exists for a feature/role\n     */\n    planExists(featureId: string, role: \"A\" | \"B\"): boolean;\n    /**\n     * Read a plan file for a feature\n     */\n    readPlanFile(featureId: string): any | null;\n    /**\n     * Start a worker in a tmux session\n     * Security: Uses file-based prompt passing to avoid shell injection\n     */\n    startWorker(feature: Feature, customPrompt?: string, model?: \"haiku\" | \"sonnet\" | \"opus\"): Promise<StartWorkerResult>;\n    /**\n     * Check the status and output of a worker\n     */\n    checkWorker(sessionName: string, lines?: number): Promise<CheckWorkerResult>;\n    /**\n     * Check all workers and return their statuses\n     */\n    checkAllWorkers(): Promise<WorkerStatus[]>;\n    /**\n     * Get lightweight heartbeat info for a worker (no full output)\n     * Parses log file to extract tool usage, file modifications, and activity\n     */\n    getHeartbeatInfo(sessionName: string, startedAt?: string): Promise<HeartbeatInfo>;\n    /**\n     * Register a callback to be notified when workers complete or crash\n     */\n    onWorkerCompletion(callback: CompletionCallback): void;\n    /**\n     * Start monitoring workers for completion\n     * Polls every 10 seconds to detect session exits\n     */\n    startCompletionMonitor(): void;\n    /**\n     * Stop the completion monitor\n     */\n    stopCompletionMonitor(): void;\n    /**\n     * Check all tracked workers for completion and notify callbacks\n     */\n    private checkForCompletions;\n    /**\n     * Analyze potential conflicts between features for parallel execution\n     * Extracts file/component hints from descriptions and detects overlaps\n     */\n    analyzeFeatureConflicts(features: Feature[]): Array<{\n        feature1: string;\n        feature2: string;\n        reason: string;\n    }>;\n    /**\n     * Kill a specific worker session\n     */\n    killWorker(sessionName: string): Promise<void>;\n    /**\n     * Kill all worker sessions for this project\n     */\n    killAllWorkers(): Promise<void>;\n    /**\n     * Wait for a worker to complete (blocking)\n     */\n    waitForWorker(sessionName: string, timeoutMs?: number): Promise<CheckWorkerResult>;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}