{
  "file_path": "/work/internal/csync/maps_test.go",
  "file_hash": "c26d758128ba0806069665952b5c268eb23d891a",
  "updated_at": "2025-12-26T17:34:23.287126",
  "symbols": {
    "function_TestNewMap_14": {
      "name": "TestNewMap",
      "type": "function",
      "start_line": 14,
      "end_line": 22,
      "content_hash": "ebbf637bc6ad3ed8fc44d8a1e6441786a3bdb7d8",
      "content": "func TestNewMap(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\trequire.NotNil(t, m)\n\trequire.NotNil(t, m.inner)\n\trequire.Equal(t, 0, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewMapFrom_23": {
      "name": "TestNewMapFrom",
      "type": "function",
      "start_line": 23,
      "end_line": 40,
      "content_hash": "ac79e2ff2475351b6ee61855266ff42fc5753b3e",
      "content": "func TestNewMapFrom(t *testing.T) {\n\tt.Parallel()\n\n\toriginal := map[string]int{\n\t\t\"key1\": 1,\n\t\t\"key2\": 2,\n\t}\n\n\tm := NewMapFrom(original)\n\trequire.NotNil(t, m)\n\trequire.Equal(t, original, m.inner)\n\trequire.Equal(t, 2, m.Len())\n\n\tvalue, ok := m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 1, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewLazyMap_41": {
      "name": "TestNewLazyMap",
      "type": "function",
      "start_line": 41,
      "end_line": 74,
      "content_hash": "834976a74dd565a90ef609257619930ef50f5eed",
      "content": "func TestNewLazyMap(t *testing.T) {\n\tt.Parallel()\n\n\tsynctest.Test(t, func(t *testing.T) {\n\t\tt.Helper()\n\n\t\twaiter := sync.Mutex{}\n\t\twaiter.Lock()\n\t\tloadCalled := false\n\n\t\tloadFunc := func() map[string]int {\n\t\t\twaiter.Lock()\n\t\t\tdefer waiter.Unlock()\n\t\t\tloadCalled = true\n\t\t\treturn map[string]int{\n\t\t\t\t\"key1\": 1,\n\t\t\t\t\"key2\": 2,\n\t\t\t}\n\t\t}\n\n\t\tm := NewLazyMap(loadFunc)\n\t\trequire.NotNil(t, m)\n\n\t\twaiter.Unlock() // Allow the load function to proceed\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\trequire.True(t, loadCalled)\n\t\trequire.Equal(t, 2, m.Len())\n\n\t\tvalue, ok := m.Get(\"key1\")\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, 1, value)\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Reset_75": {
      "name": "TestMap_Reset",
      "type": "function",
      "start_line": 75,
      "end_line": 90,
      "content_hash": "081fd3eff381ccebd08ea8504b38310e495d337c",
      "content": "func TestMap_Reset(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMapFrom(map[string]int{\n\t\t\"a\": 10,\n\t})\n\n\tm.Reset(map[string]int{\n\t\t\"b\": 20,\n\t})\n\tvalue, ok := m.Get(\"b\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 20, value)\n\trequire.Equal(t, 1, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Set_91": {
      "name": "TestMap_Set",
      "type": "function",
      "start_line": 91,
      "end_line": 108,
      "content_hash": "38a1954162dfc1cee6e24e7b36b36339b1b6a03f",
      "content": "func TestMap_Set(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tm.Set(\"key1\", 42)\n\tvalue, ok := m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n\trequire.Equal(t, 1, m.Len())\n\n\tm.Set(\"key1\", 100)\n\tvalue, ok = m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 100, value)\n\trequire.Equal(t, 1, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_GetOrSet_109": {
      "name": "TestMap_GetOrSet",
      "type": "function",
      "start_line": 109,
      "end_line": 118,
      "content_hash": "6c1e7a31a270b922a1df8c5cf5080a53ac1dd9da",
      "content": "func TestMap_GetOrSet(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\trequire.Equal(t, 42, m.GetOrSet(\"key1\", func() int { return 42 }))\n\trequire.Equal(t, 42, m.GetOrSet(\"key1\", func() int { return 99999 }))\n\trequire.Equal(t, 1, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Get_119": {
      "name": "TestMap_Get",
      "type": "function",
      "start_line": 119,
      "end_line": 133,
      "content_hash": "fef7c962a7de162b66d86d93fbb5d274872fdb8b",
      "content": "func TestMap_Get(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tvalue, ok := m.Get(\"nonexistent\")\n\trequire.False(t, ok)\n\trequire.Equal(t, 0, value)\n\n\tm.Set(\"key1\", 42)\n\tvalue, ok = m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Del_134": {
      "name": "TestMap_Del",
      "type": "function",
      "start_line": 134,
      "end_line": 155,
      "content_hash": "906015ec14c123388855b8072fb2af7e5703382a",
      "content": "func TestMap_Del(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 42)\n\tm.Set(\"key2\", 100)\n\n\trequire.Equal(t, 2, m.Len())\n\n\tm.Del(\"key1\")\n\t_, ok := m.Get(\"key1\")\n\trequire.False(t, ok)\n\trequire.Equal(t, 1, m.Len())\n\n\tvalue, ok := m.Get(\"key2\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 100, value)\n\n\tm.Del(\"nonexistent\")\n\trequire.Equal(t, 1, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Len_156": {
      "name": "TestMap_Len",
      "type": "function",
      "start_line": 156,
      "end_line": 174,
      "content_hash": "e0023cc915537f50bbb31ef0aa1036bf338e86c3",
      "content": "func TestMap_Len(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\trequire.Equal(t, 0, m.Len())\n\n\tm.Set(\"key1\", 1)\n\trequire.Equal(t, 1, m.Len())\n\n\tm.Set(\"key2\", 2)\n\trequire.Equal(t, 2, m.Len())\n\n\tm.Del(\"key1\")\n\trequire.Equal(t, 1, m.Len())\n\n\tm.Del(\"key2\")\n\trequire.Equal(t, 0, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Take_175": {
      "name": "TestMap_Take",
      "type": "function",
      "start_line": 175,
      "end_line": 196,
      "content_hash": "0d70e6292565e6a70b142e6667e1223ae19edbf5",
      "content": "func TestMap_Take(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 42)\n\tm.Set(\"key2\", 100)\n\n\trequire.Equal(t, 2, m.Len())\n\n\tvalue, ok := m.Take(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n\trequire.Equal(t, 1, m.Len())\n\n\t_, exists := m.Get(\"key1\")\n\trequire.False(t, exists)\n\n\tvalue, ok = m.Get(\"key2\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 100, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Take_NonexistentKey_197": {
      "name": "TestMap_Take_NonexistentKey",
      "type": "function",
      "start_line": 197,
      "end_line": 212,
      "content_hash": "25878c1506d04dc5378e30148f8cd2f96e6e0823",
      "content": "func TestMap_Take_NonexistentKey(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 42)\n\n\tvalue, ok := m.Take(\"nonexistent\")\n\trequire.False(t, ok)\n\trequire.Equal(t, 0, value)\n\trequire.Equal(t, 1, m.Len())\n\n\tvalue, ok = m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Take_EmptyMap_213": {
      "name": "TestMap_Take_EmptyMap",
      "type": "function",
      "start_line": 213,
      "end_line": 223,
      "content_hash": "0fe4b8d0ed9597bb11e29a09789798a1a89db7ef",
      "content": "func TestMap_Take_EmptyMap(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tvalue, ok := m.Take(\"key1\")\n\trequire.False(t, ok)\n\trequire.Equal(t, 0, value)\n\trequire.Equal(t, 0, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Take_SameKeyTwice_224": {
      "name": "TestMap_Take_SameKeyTwice",
      "type": "function",
      "start_line": 224,
      "end_line": 240,
      "content_hash": "95f65ae11239ac4cd2ccad1a6f12d780b75c6444",
      "content": "func TestMap_Take_SameKeyTwice(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 42)\n\n\tvalue, ok := m.Take(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n\trequire.Equal(t, 0, m.Len())\n\n\tvalue, ok = m.Take(\"key1\")\n\trequire.False(t, ok)\n\trequire.Equal(t, 0, value)\n\trequire.Equal(t, 0, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq2_241": {
      "name": "TestMap_Seq2",
      "type": "function",
      "start_line": 241,
      "end_line": 256,
      "content_hash": "584bfadae1538af38effab7b6d8ae9c322136580",
      "content": "func TestMap_Seq2(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 1)\n\tm.Set(\"key2\", 2)\n\tm.Set(\"key3\", 3)\n\n\tcollected := maps.Collect(m.Seq2())\n\n\trequire.Equal(t, 3, len(collected))\n\trequire.Equal(t, 1, collected[\"key1\"])\n\trequire.Equal(t, 2, collected[\"key2\"])\n\trequire.Equal(t, 3, collected[\"key3\"])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq2_EarlyReturn_257": {
      "name": "TestMap_Seq2_EarlyReturn",
      "type": "function",
      "start_line": 257,
      "end_line": 275,
      "content_hash": "bc2089588d2cccd118a35bf9b896983f1e825f9d",
      "content": "func TestMap_Seq2_EarlyReturn(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 1)\n\tm.Set(\"key2\", 2)\n\tm.Set(\"key3\", 3)\n\n\tcount := 0\n\tfor range m.Seq2() {\n\t\tcount++\n\t\tif count == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\trequire.Equal(t, 2, count)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq2_EmptyMap_276": {
      "name": "TestMap_Seq2_EmptyMap",
      "type": "function",
      "start_line": 276,
      "end_line": 288,
      "content_hash": "c9966664f5555e7bf204396fa26bbb93aa975452",
      "content": "func TestMap_Seq2_EmptyMap(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tcount := 0\n\tfor range m.Seq2() {\n\t\tcount++\n\t}\n\n\trequire.Equal(t, 0, count)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq_289": {
      "name": "TestMap_Seq",
      "type": "function",
      "start_line": 289,
      "end_line": 307,
      "content_hash": "66cc39629a36ea10aa951a1e286f96449d26a4cf",
      "content": "func TestMap_Seq(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 1)\n\tm.Set(\"key2\", 2)\n\tm.Set(\"key3\", 3)\n\n\tcollected := make([]int, 0)\n\tfor v := range m.Seq() {\n\t\tcollected = append(collected, v)\n\t}\n\n\trequire.Equal(t, 3, len(collected))\n\trequire.Contains(t, collected, 1)\n\trequire.Contains(t, collected, 2)\n\trequire.Contains(t, collected, 3)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq_EarlyReturn_308": {
      "name": "TestMap_Seq_EarlyReturn",
      "type": "function",
      "start_line": 308,
      "end_line": 326,
      "content_hash": "297e5f0d72ab5795a8b8c0563f0c4c7d5fd3501e",
      "content": "func TestMap_Seq_EarlyReturn(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 1)\n\tm.Set(\"key2\", 2)\n\tm.Set(\"key3\", 3)\n\n\tcount := 0\n\tfor range m.Seq() {\n\t\tcount++\n\t\tif count == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\trequire.Equal(t, 2, count)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_Seq_EmptyMap_327": {
      "name": "TestMap_Seq_EmptyMap",
      "type": "function",
      "start_line": 327,
      "end_line": 339,
      "content_hash": "4d715cab8913ce728a99f9d5984fae38826dd98f",
      "content": "func TestMap_Seq_EmptyMap(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tcount := 0\n\tfor range m.Seq() {\n\t\tcount++\n\t}\n\n\trequire.Equal(t, 0, count)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_MarshalJSON_340": {
      "name": "TestMap_MarshalJSON",
      "type": "function",
      "start_line": 340,
      "end_line": 359,
      "content_hash": "eb6ef277bd2553a112fed403388cab0608538690",
      "content": "func TestMap_MarshalJSON(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"key1\", 1)\n\tm.Set(\"key2\", 2)\n\n\tdata, err := json.Marshal(m)\n\trequire.NoError(t, err)\n\n\tresult := &Map[string, int]{}\n\terr = json.Unmarshal(data, result)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, result.Len())\n\tv1, _ := result.Get(\"key1\")\n\tv2, _ := result.Get(\"key2\")\n\trequire.Equal(t, 1, v1)\n\trequire.Equal(t, 2, v2)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_MarshalJSON_EmptyMap_360": {
      "name": "TestMap_MarshalJSON_EmptyMap",
      "type": "function",
      "start_line": 360,
      "end_line": 369,
      "content_hash": "747bd70eb77ad56ab5566275c6a4aded5dd1c5c6",
      "content": "func TestMap_MarshalJSON_EmptyMap(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\n\tdata, err := json.Marshal(m)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"{}\", string(data))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_UnmarshalJSON_370": {
      "name": "TestMap_UnmarshalJSON",
      "type": "function",
      "start_line": 370,
      "end_line": 388,
      "content_hash": "7120cc5757009f9530d4c0251e4e863c1e7ef5ed",
      "content": "func TestMap_UnmarshalJSON(t *testing.T) {\n\tt.Parallel()\n\n\tjsonData := `{\"key1\": 1, \"key2\": 2}`\n\n\tm := NewMap[string, int]()\n\terr := json.Unmarshal([]byte(jsonData), m)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 2, m.Len())\n\tvalue, ok := m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 1, value)\n\n\tvalue, ok = m.Get(\"key2\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 2, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_UnmarshalJSON_EmptyJSON_389": {
      "name": "TestMap_UnmarshalJSON_EmptyJSON",
      "type": "function",
      "start_line": 389,
      "end_line": 399,
      "content_hash": "1294a29cec4b474083e16d9b2ce735002c97845d",
      "content": "func TestMap_UnmarshalJSON_EmptyJSON(t *testing.T) {\n\tt.Parallel()\n\n\tjsonData := `{}`\n\n\tm := NewMap[string, int]()\n\terr := json.Unmarshal([]byte(jsonData), m)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 0, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_UnmarshalJSON_InvalidJSON_400": {
      "name": "TestMap_UnmarshalJSON_InvalidJSON",
      "type": "function",
      "start_line": 400,
      "end_line": 409,
      "content_hash": "f05def210731a1f7581bbde0b904f3fc4e9895dd",
      "content": "func TestMap_UnmarshalJSON_InvalidJSON(t *testing.T) {\n\tt.Parallel()\n\n\tjsonData := `{\"key1\": 1, \"key2\":}`\n\n\tm := NewMap[string, int]()\n\terr := json.Unmarshal([]byte(jsonData), m)\n\trequire.Error(t, err)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_UnmarshalJSON_OverwritesExistingData_410": {
      "name": "TestMap_UnmarshalJSON_OverwritesExistingData",
      "type": "function",
      "start_line": 410,
      "end_line": 428,
      "content_hash": "cb6b48fa32cc0be880624ef5562d93b0ffc2ebb7",
      "content": "func TestMap_UnmarshalJSON_OverwritesExistingData(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[string, int]()\n\tm.Set(\"existing\", 999)\n\n\tjsonData := `{\"key1\": 1, \"key2\": 2}`\n\terr := json.Unmarshal([]byte(jsonData), m)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 2, m.Len())\n\t_, ok := m.Get(\"existing\")\n\trequire.False(t, ok)\n\n\tvalue, ok := m.Get(\"key1\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 1, value)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_JSONRoundTrip_429": {
      "name": "TestMap_JSONRoundTrip",
      "type": "function",
      "start_line": 429,
      "end_line": 452,
      "content_hash": "0254017670437129a607b118d3b5d6f611b173e7",
      "content": "func TestMap_JSONRoundTrip(t *testing.T) {\n\tt.Parallel()\n\n\toriginal := NewMap[string, int]()\n\toriginal.Set(\"key1\", 1)\n\toriginal.Set(\"key2\", 2)\n\toriginal.Set(\"key3\", 3)\n\n\tdata, err := json.Marshal(original)\n\trequire.NoError(t, err)\n\n\trestored := NewMap[string, int]()\n\terr = json.Unmarshal(data, restored)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, original.Len(), restored.Len())\n\n\tfor k, v := range original.Seq2() {\n\t\trestoredValue, ok := restored.Get(k)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, v, restoredValue)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_ConcurrentAccess_453": {
      "name": "TestMap_ConcurrentAccess",
      "type": "function",
      "start_line": 453,
      "end_line": 480,
      "content_hash": "8327c78be2ba0f3dbeab9bb5b2804495c892edfa",
      "content": "func TestMap_ConcurrentAccess(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[int, int]()\n\tconst numGoroutines = 100\n\tconst numOperations = 100\n\n\tvar wg sync.WaitGroup\n\twg.Add(numGoroutines)\n\n\tfor i := range numGoroutines {\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := range numOperations {\n\t\t\t\tkey := id*numOperations + j\n\t\t\t\tm.Set(key, key*2)\n\t\t\t\tvalue, ok := m.Get(key)\n\t\t\t\trequire.True(t, ok)\n\t\t\t\trequire.Equal(t, key*2, value)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\trequire.Equal(t, numGoroutines*numOperations, m.Len())\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_ConcurrentReadWrite_481": {
      "name": "TestMap_ConcurrentReadWrite",
      "type": "function",
      "start_line": 481,
      "end_line": 525,
      "content_hash": "e617e3cfcfbf8aa2196635f551a90eac45929386",
      "content": "func TestMap_ConcurrentReadWrite(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[int, int]()\n\tconst numReaders = 50\n\tconst numWriters = 50\n\tconst numOperations = 100\n\n\tfor i := range 1000 {\n\t\tm.Set(i, i)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(numReaders + numWriters)\n\n\tfor range numReaders {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := range numOperations {\n\t\t\t\tkey := j % 1000\n\t\t\t\tvalue, ok := m.Get(key)\n\t\t\t\tif ok {\n\t\t\t\t\trequire.Equal(t, key, value)\n\t\t\t\t}\n\t\t\t\t_ = m.Len()\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := range numWriters {\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := range numOperations {\n\t\t\t\tkey := 1000 + id*numOperations + j\n\t\t\t\tm.Set(key, key)\n\t\t\t\tif j%10 == 0 {\n\t\t\t\t\tm.Del(key)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_ConcurrentSeq2_526": {
      "name": "TestMap_ConcurrentSeq2",
      "type": "function",
      "start_line": 526,
      "end_line": 552,
      "content_hash": "48d171987334cabcfe023c89e6f38bbd0cfe9c28",
      "content": "func TestMap_ConcurrentSeq2(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[int, int]()\n\tfor i := range 100 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tvar wg sync.WaitGroup\n\tconst numIterators = 10\n\n\twg.Add(numIterators)\n\tfor range numIterators {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tcount := 0\n\t\t\tfor k, v := range m.Seq2() {\n\t\t\t\trequire.Equal(t, k*2, v)\n\t\t\t\tcount++\n\t\t\t}\n\t\t\trequire.Equal(t, 100, count)\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_ConcurrentSeq_553": {
      "name": "TestMap_ConcurrentSeq",
      "type": "function",
      "start_line": 553,
      "end_line": 583,
      "content_hash": "ab0ebc3ca8baef289a9275bbd09bb51c985d601d",
      "content": "func TestMap_ConcurrentSeq(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[int, int]()\n\tfor i := range 100 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tvar wg sync.WaitGroup\n\tconst numIterators = 10\n\n\twg.Add(numIterators)\n\tfor range numIterators {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tcount := 0\n\t\t\tvalues := make(map[int]bool)\n\t\t\tfor v := range m.Seq() {\n\t\t\t\tvalues[v] = true\n\t\t\t\tcount++\n\t\t\t}\n\t\t\trequire.Equal(t, 100, count)\n\t\t\tfor i := range 100 {\n\t\t\t\trequire.True(t, values[i*2])\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_ConcurrentTake_584": {
      "name": "TestMap_ConcurrentTake",
      "type": "function",
      "start_line": 584,
      "end_line": 628,
      "content_hash": "fbae038e05a232d7e62b365b5cdc95ab6c3e1ffe",
      "content": "func TestMap_ConcurrentTake(t *testing.T) {\n\tt.Parallel()\n\n\tm := NewMap[int, int]()\n\tconst numItems = 1000\n\n\tfor i := range numItems {\n\t\tm.Set(i, i*2)\n\t}\n\n\tvar wg sync.WaitGroup\n\tconst numWorkers = 10\n\ttaken := make([][]int, numWorkers)\n\n\twg.Add(numWorkers)\n\tfor i := range numWorkers {\n\t\tgo func(workerID int) {\n\t\t\tdefer wg.Done()\n\t\t\ttaken[workerID] = make([]int, 0)\n\t\t\tfor j := workerID; j < numItems; j += numWorkers {\n\t\t\t\tif value, ok := m.Take(j); ok {\n\t\t\t\t\ttaken[workerID] = append(taken[workerID], value)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\trequire.Equal(t, 0, m.Len())\n\n\tallTaken := make(map[int]bool)\n\tfor _, workerTaken := range taken {\n\t\tfor _, value := range workerTaken {\n\t\t\trequire.False(t, allTaken[value], \"Value %d was taken multiple times\", value)\n\t\t\tallTaken[value] = true\n\t\t}\n\t}\n\n\trequire.Equal(t, numItems, len(allTaken))\n\tfor i := range numItems {\n\t\trequire.True(t, allTaken[i*2], \"Expected value %d to be taken\", i*2)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_TypeSafety_629": {
      "name": "TestMap_TypeSafety",
      "type": "function",
      "start_line": 629,
      "end_line": 650,
      "content_hash": "1e2c769204b78c88761b215b4f7873c9cd55f915",
      "content": "func TestMap_TypeSafety(t *testing.T) {\n\tt.Parallel()\n\n\tstringIntMap := NewMap[string, int]()\n\tstringIntMap.Set(\"key\", 42)\n\tvalue, ok := stringIntMap.Get(\"key\")\n\trequire.True(t, ok)\n\trequire.Equal(t, 42, value)\n\n\tintStringMap := NewMap[int, string]()\n\tintStringMap.Set(42, \"value\")\n\tstrValue, ok := intStringMap.Get(42)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"value\", strValue)\n\n\tstructMap := NewMap[string, struct{ Name string }]()\n\tstructMap.Set(\"key\", struct{ Name string }{Name: \"test\"})\n\tstructValue, ok := structMap.Get(\"key\")\n\trequire.True(t, ok)\n\trequire.Equal(t, \"test\", structValue.Name)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMap_InterfaceCompliance_651": {
      "name": "TestMap_InterfaceCompliance",
      "type": "function",
      "start_line": 651,
      "end_line": 657,
      "content_hash": "f4b333fbc8ea69511050633418db6f012bbc2e58",
      "content": "func TestMap_InterfaceCompliance(t *testing.T) {\n\tt.Parallel()\n\n\tvar _ json.Marshaler = &Map[string, any]{}\n\tvar _ json.Unmarshaler = &Map[string, any]{}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_Set_658": {
      "name": "BenchmarkMap_Set",
      "type": "function",
      "start_line": 658,
      "end_line": 665,
      "content_hash": "be0f511182306f4a14133d91658bb1beb34cfcb8",
      "content": "func BenchmarkMap_Set(b *testing.B) {\n\tm := NewMap[int, int]()\n\n\tfor i := 0; b.Loop(); i++ {\n\t\tm.Set(i, i*2)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_Get_666": {
      "name": "BenchmarkMap_Get",
      "type": "function",
      "start_line": 666,
      "end_line": 676,
      "content_hash": "e36f8fc683f20080a66849d8b56e769bed1fa932",
      "content": "func BenchmarkMap_Get(b *testing.B) {\n\tm := NewMap[int, int]()\n\tfor i := range 1000 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tfor i := 0; b.Loop(); i++ {\n\t\tm.Get(i % 1000)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_Seq2_677": {
      "name": "BenchmarkMap_Seq2",
      "type": "function",
      "start_line": 677,
      "end_line": 688,
      "content_hash": "b95cf7b1464a86b27c3137dc38e9b226673ad420",
      "content": "func BenchmarkMap_Seq2(b *testing.B) {\n\tm := NewMap[int, int]()\n\tfor i := range 1000 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tfor b.Loop() {\n\t\tfor range m.Seq2() {\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_Seq_689": {
      "name": "BenchmarkMap_Seq",
      "type": "function",
      "start_line": 689,
      "end_line": 700,
      "content_hash": "3f5a32e6c652ef5a46be08d9032a04420a216d57",
      "content": "func BenchmarkMap_Seq(b *testing.B) {\n\tm := NewMap[int, int]()\n\tfor i := range 1000 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tfor b.Loop() {\n\t\tfor range m.Seq() {\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_Take_701": {
      "name": "BenchmarkMap_Take",
      "type": "function",
      "start_line": 701,
      "end_line": 720,
      "content_hash": "d909264387c0a2f979e585bbf640b5ecf08f45b3",
      "content": "func BenchmarkMap_Take(b *testing.B) {\n\tm := NewMap[int, int]()\n\tfor i := range 1000 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; b.Loop(); i++ {\n\t\tkey := i % 1000\n\t\tm.Take(key)\n\t\tif i%1000 == 999 {\n\t\t\tb.StopTimer()\n\t\t\tfor j := range 1000 {\n\t\t\t\tm.Set(j, j*2)\n\t\t\t}\n\t\t\tb.StartTimer()\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_BenchmarkMap_ConcurrentReadWrite_721": {
      "name": "BenchmarkMap_ConcurrentReadWrite",
      "type": "function",
      "start_line": 721,
      "end_line": 739,
      "content_hash": "32b6c590d1fbcdf21c5f2b809a8a4a304453de95",
      "content": "func BenchmarkMap_ConcurrentReadWrite(b *testing.B) {\n\tm := NewMap[int, int]()\n\tfor i := range 1000 {\n\t\tm.Set(i, i*2)\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\ti := 0\n\t\tfor pb.Next() {\n\t\t\tif i%2 == 0 {\n\t\t\t\tm.Get(i % 1000)\n\t\t\t} else {\n\t\t\t\tm.Set(i+1000, i*2)\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}