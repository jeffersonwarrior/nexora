{
  "file_path": "/work/external-deps/helix-db/helix-macros/src/lib.rs",
  "file_hash": "6686cf1595f71c073fde70f7b3ece4f99aaeb51a",
  "updated_at": "2025-12-26T17:34:22.147080",
  "symbols": {
    "struct_HandlerArgs_11": {
      "name": "HandlerArgs",
      "type": "struct",
      "start_line": 11,
      "end_line": 14,
      "content_hash": "378306fa32dd3ac71a4210789f3ea737ecac7b10",
      "content": "struct HandlerArgs {\n    is_write: bool,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Parse_15": {
      "name": "Parse",
      "type": "impl",
      "start_line": 15,
      "end_line": 15,
      "content_hash": "6a2d972e0ede9ec64011423d5713c402c2a00596",
      "content": "impl Parse for HandlerArgs {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_16": {
      "name": "parse",
      "type": "method",
      "start_line": 16,
      "end_line": 29,
      "content_hash": "9122c5f8d677ecd4ed6881620600fb20c8f8757b",
      "content": "    fn parse(input: ParseStream) -> syn::Result<Self> {\n        if input.is_empty() {\n            return Ok(HandlerArgs { is_write: false });\n        }\n        let ident: Ident = input.parse()?;\n        if ident == \"is_write\" {\n            Ok(HandlerArgs { is_write: true })\n        } else {\n            Err(syn::Error::new(ident.span(), \"expected `is_write`\"))\n        }\n    }\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handler_30": {
      "name": "handler",
      "type": "method",
      "start_line": 30,
      "end_line": 62,
      "content_hash": "3fdb56299dff6c84d7f2bb0ab86b2e4183e48ed3",
      "content": "pub fn handler(args: TokenStream, item: TokenStream) -> TokenStream {\n    let args = parse_macro_input!(args as HandlerArgs);\n    let input_fn = parse_macro_input!(item as ItemFn);\n    let fn_name = &input_fn.sig.ident;\n    let fn_name_str = fn_name.to_string();\n    let is_write = args.is_write;\n    // Create a unique static name for each handler\n    let static_name = quote::format_ident!(\n        \"_MAIN_HANDLER_REGISTRATION_{}\",\n        fn_name.to_string().to_uppercase()\n    );\n\n    let expanded = quote! {\n        #input_fn\n\n        #[doc(hidden)]\n        #[used]\n        static #static_name: () = {\n            inventory::submit! {\n                ::helix_db::helix_gateway::router::router::HandlerSubmission(\n                    ::helix_db::helix_gateway::router::router::Handler::new(\n                        #fn_name_str,\n                        #fn_name,\n                        #is_write\n                    )\n                )\n            }\n        };\n    };\n    expanded.into()\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_mcp_handler_63": {
      "name": "mcp_handler",
      "type": "method",
      "start_line": 63,
      "end_line": 92,
      "content_hash": "7e1c6962cea828b90149746bf97032c0a9d744e9",
      "content": "pub fn mcp_handler(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    let input_fn = parse_macro_input!(item as ItemFn);\n    let fn_name = &input_fn.sig.ident;\n    let fn_name_str = fn_name.to_string();\n    // Create a unique static name for each handler\n    let static_name = quote::format_ident!(\n        \"_MCP_HANDLER_REGISTRATION_{}\",\n        fn_name.to_string().to_uppercase()\n    );\n\n    let expanded = quote! {\n        #input_fn\n\n        #[doc(hidden)]\n        #[used]\n        static #static_name: () = {\n            inventory::submit! {\n                MCPHandlerSubmission(\n                    MCPHandler::new(\n                        #fn_name_str,\n                        #fn_name\n                    )\n                )\n            }\n        };\n    };\n    expanded.into()\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_handler_93": {
      "name": "get_handler",
      "type": "method",
      "start_line": 93,
      "end_line": 123,
      "content_hash": "3d2f0151efc61278ef48fa349d2a107c57592a0f",
      "content": "pub fn get_handler(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    let input_fn = parse_macro_input!(item as ItemFn);\n    let fn_name = &input_fn.sig.ident;\n    let fn_name_str = fn_name.to_string();\n    let static_name = quote::format_ident!(\n        \"__GET_HANDLER_REGISTRATION_{}\",\n        fn_name.to_string().to_uppercase()\n    );\n\n    let expanded = quote! {\n        #input_fn\n\n        #[doc(hidden)]\n        #[used]\n        static #static_name: () = {\n            inventory::submit! {\n                ::helix_db::helix_gateway::router::router::HandlerSubmission(\n                    ::helix_db::helix_gateway::router::router::Handler::new(\n                        #fn_name_str,\n                        #fn_name,\n                        false\n                    )\n                )\n            }\n        };\n    };\n    expanded.into()\n}\n\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tool_calls_124": {
      "name": "tool_calls",
      "type": "method",
      "start_line": 124,
      "end_line": 197,
      "content_hash": "542307965225be2ecf0ec09dee29a248873e6f88",
      "content": "pub fn tool_calls(_attr: TokenStream, input: TokenStream) -> TokenStream {\n    let input_trait = parse_macro_input!(input as ItemTrait);\n    let mut impl_methods = Vec::new();\n\n    for item in input_trait.clone().items {\n        if let TraitItem::Fn(method) = item {\n            let fn_name = &method.sig.ident;\n\n            // Extract method parameters (skip &self and txn)\n            let method_params: Vec<_> = method.sig.inputs.iter().skip(3).collect();\n            let (field_names, struct_fields): (Vec<_>, Vec<_>) = method_params\n                .iter()\n                .filter_map(|param| {\n                    if let FnArg::Typed(pat_type) = param {\n                        let field_name = if let Pat::Ident(pat_ident) = &*pat_type.pat {\n                            &pat_ident.ident\n                        } else {\n                            return None;\n                        };\n\n                        let field_type = &pat_type.ty;\n                        Some((quote! { #field_name }, quote! { #field_name: #field_type }))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n\n            let struct_name = quote::format_ident!(\"{}Data\", fn_name);\n            let mcp_struct_name = quote::format_ident!(\"{}McpInput\", fn_name);\n            let expanded = quote! {\n\n                #[derive(Debug, Deserialize)]\n                #[allow(non_camel_case_types)]\n                pub struct #mcp_struct_name {\n                    #(#struct_fields),*\n                }\n\n                #[derive(Debug, Deserialize)]\n                #[allow(non_camel_case_types)]\n                struct #struct_name {\n                    connection_id: String,\n                    data: #mcp_struct_name,\n                }\n\n                #[mcp_handler]\n                #[allow(non_camel_case_types)]\n                pub fn #fn_name<'a>(\n                    input: &'a mut MCPToolInput,\n                ) -> Result<Response, GraphError> {\n                    let data = input.request.in_fmt.deserialize_owned::<#struct_name>(&input.request.body)?;\n\n                    let mut connections = input.mcp_connections.lock().unwrap();\n                    let mut connection = match connections.remove_connection(&data.connection_id) {\n                        Some(conn) => conn,\n                        None => return Err(GraphError::Default),\n                    };\n                    drop(connections);\n\n                    let txn = input.mcp_backend.db.graph_env.read_txn()?;\n\n                    let result = input.mcp_backend.#fn_name(&txn, &connection, #(data.data.#field_names),*)?;\n\n                    let first = result.first().unwrap_or(&TraversalValue::Empty).clone();\n\n                    connection.iter = result.into_iter();\n                    let mut connections = input.mcp_connections.lock().unwrap();\n                    connections.add_connection(connection);\n                    drop(connections);\n\n                    Ok(crate::protocol::format::Format::Json.create_response(&ReturnValue::from(first)))\n                }\n            };\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl__methods_198": {
      "name": "_methods",
      "type": "impl",
      "start_line": 198,
      "end_line": 209,
      "content_hash": "59edcf14b9c4d4f02728a4c754070a748bbb854c",
      "content": "            impl_methods.push(expanded);\n        }\n    }\n\n    let expanded = quote! {\n        #(#impl_methods)*\n        #input_trait\n    };\n\n    TokenStream::from(expanded)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ToolCallArgs_210": {
      "name": "ToolCallArgs",
      "type": "struct",
      "start_line": 210,
      "end_line": 214,
      "content_hash": "51219ae4a387fe554046a08111e6a3bb299ffab5",
      "content": "struct ToolCallArgs {\n    name: Ident,\n    _comma: Token![,],\n    txn_type: Ident,\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Parse_215": {
      "name": "Parse",
      "type": "impl",
      "start_line": 215,
      "end_line": 215,
      "content_hash": "10385fe6400f056de401a7a1811a5f095aaeee92",
      "content": "impl Parse for ToolCallArgs {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_216": {
      "name": "parse",
      "type": "method",
      "start_line": 216,
      "end_line": 225,
      "content_hash": "13b59b33cc0c1587698dd20403578201acd2a47e",
      "content": "    fn parse(input: ParseStream) -> syn::Result<Self> {\n        Ok(ToolCallArgs {\n            name: input.parse()?,\n            _comma: input.parse()?,\n            txn_type: input.parse()?,\n        })\n    }\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_tool_call_226": {
      "name": "tool_call",
      "type": "method",
      "start_line": 226,
      "end_line": 311,
      "content_hash": "9299e25c2f5af3c8fa4f51272c9104f4f0af67d7",
      "content": "pub fn tool_call(args: TokenStream, input: TokenStream) -> TokenStream {\n    let args = parse_macro_input!(args as ToolCallArgs);\n    let method = parse_macro_input!(input as ItemFn);\n\n    let name = args.name;\n    let txn_type = match args.txn_type.to_string().as_str() {\n        \"with_read\" => quote! { let txn = db.graph_env.read_txn().unwrap(); },\n        \"with_write\" => quote! { let mut txn = db.graph_env.write_txn().unwrap(); },\n        _ => panic!(\"Invalid transaction type: expected 'with_read' or 'with_write'\"),\n    };\n\n    let fn_name = &method.sig.ident;\n    let fn_block = &method.block.stmts;\n\n    let struct_name = quote::format_ident!(\"{}Input\", fn_name);\n    let mcp_function_name = quote::format_ident!(\"{}Mcp\", fn_name);\n    let mcp_struct_name = quote::format_ident!(\"{}McpInput\", fn_name);\n\n    let query_stmts = match fn_block.first() {\n        Some(Stmt::Expr(Expr::Block(block), _)) => block.block.stmts.clone(),\n        _ => panic!(\"Query block not found\"),\n    };\n\n    let mcp_query_block = quote! {\n        {\n\n            let mut remapping_vals = RemappingMap::new();\n            let db = Arc::clone(&input.mcp_backend.db);\n            #txn_type\n            let data: #struct_name = data.data;\n            #(#query_stmts)*\n            txn.commit().unwrap();\n            #name.into_iter()\n        }\n    };\n\n    let new_method = quote! {\n\n        #[derive(Deserialize)]\n        #[allow(non_camel_case_types)]\n        struct #mcp_struct_name{\n            connection_id: String,\n            data: #struct_name,\n        }\n\n        #[mcp_handler]\n        #[allow(non_camel_case_types)]\n        pub fn #mcp_function_name<'a>(\n            input: &'a mut MCPToolInput,\n        ) -> Result<Response, GraphError> {\n            let data = &*input.request.in_fmt.deserialize::<#mcp_struct_name>(&input.request.body)?;\n\n            let mut connections = input.mcp_connections.lock().unwrap();\n            let mut connection = match connections.remove_connection(&data.connection_id) {\n                Some(conn) => conn,\n                None => return Err(GraphError::Default),\n            };\n            drop(connections);\n\n            let mut result = #mcp_query_block;\n\n            let first = result.next().unwrap_or(TraversalValue::Empty);\n\n            connection.iter = result.into_iter();\n            let mut connections = input.mcp_connections.lock().unwrap();\n            connections.add_connection(connection);\n            drop(connections);\n            Ok(crate::protocol::format::Format::Json.create_response(&ReturnValue::from(first)))\n        }\n    };\n\n    let expanded = quote! {\n        #method\n        #new_method\n    };\n\n    TokenStream::from(expanded)\n}\n\n// example:\n// #[migration(User, 1 -> 2)]\n// pub fn __migration_User_1_2(props: HashMap<String, Value>) -> HashMap<String, Value> {\n//     field_addition_from_old_field!(props, \"username\", \"username\");\n//     props\n// }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Parse_312": {
      "name": "Parse",
      "type": "impl",
      "start_line": 312,
      "end_line": 312,
      "content_hash": "936da6b3a9bdc05c8d0fd137c666ea727b55c469",
      "content": "impl Parse for MigrationArgs {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_313": {
      "name": "parse",
      "type": "method",
      "start_line": 313,
      "end_line": 323,
      "content_hash": "ddd8306490364d9650eec9a484bdbfe1c39a22f6",
      "content": "    fn parse(input: ParseStream) -> syn::Result<Self> {\n        Ok(MigrationArgs {\n            item: input.parse()?,\n            _comma: input.parse()?,\n            from_version: input.parse()?,\n            _arrow: input.parse()?,\n            to_version: input.parse()?,\n        })\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MigrationArgs_324": {
      "name": "MigrationArgs",
      "type": "struct",
      "start_line": 324,
      "end_line": 332,
      "content_hash": "997dfaf038263bd1a7c3c803667bde7b08250c37",
      "content": "struct MigrationArgs {\n    item: Ident,\n    _comma: Token![,],\n    from_version: LitInt,\n    _arrow: Token![->],\n    to_version: LitInt,\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_migration_333": {
      "name": "migration",
      "type": "method",
      "start_line": 333,
      "end_line": 371,
      "content_hash": "3b222d290f17d9b456f5b7ab122df43ed26d6842",
      "content": "pub fn migration(args: TokenStream, item: TokenStream) -> TokenStream {\n    let args = parse_macro_input!(args as MigrationArgs);\n\n    let input_fn = parse_macro_input!(item as ItemFn);\n    let fn_name = &input_fn.sig.ident;\n\n    // Create a unique static name for each handler\n    let static_name = quote::format_ident!(\n        \"_MAIN_HANDLER_REGISTRATION_{}\",\n        fn_name.to_string().to_uppercase()\n    );\n\n    let item = &args.item;\n    let from_version = &args.from_version;\n    let to_version = &args.to_version;\n\n    let expanded = quote! {\n        #input_fn\n\n\n        #[doc(hidden)]\n        #[used]\n        static #static_name: () = {\n            inventory::submit! {\n                ::helix_db::helix_engine::graph_core::ops::version_info::TransitionSubmission(\n                    ::helix_db::helix_engine::graph_core::ops::version_info::Transition::new(\n                        stringify!(#item),\n                        #from_version,\n                        #to_version,\n                        #fn_name\n                    )\n                )\n            }\n        };\n    };\n    expanded.into()\n}\n\n#[proc_macro_attribute]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_helix_node_372": {
      "name": "helix_node",
      "type": "method",
      "start_line": 372,
      "end_line": 387,
      "content_hash": "502a3c19794cacdcfb22ffb5d2a4b33c26edd752",
      "content": "pub fn helix_node(_attr: TokenStream, input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as ItemStruct);\n    let name = &input.ident;\n    let fields = input.fields.iter();\n\n    let expanded = quote! {\n        pub struct #name {\n            id: String,\n            #(#fields),*\n        }\n    };\n\n    TokenStream::from(expanded)\n}\n\n#[proc_macro_derive(Traversable)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_traversable_derive_388": {
      "name": "traversable_derive",
      "type": "method",
      "start_line": 388,
      "end_line": 421,
      "content_hash": "86f60ccc97c204df0c5c8028bf48bd2b01b0480b",
      "content": "pub fn traversable_derive(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    let name = &input.ident;\n\n    // Verify that the struct has an 'id' field\n    let has_id_field = match &input.data {\n        Data::Struct(data) => {\n            data.fields.iter().any(|field| {\n                field.ident.as_ref().map(|i| i == \"id\").unwrap_or(false)\n            })\n        }\n        _ => false,\n    };\n\n    if !has_id_field {\n        return TokenStream::from(\n            quote! {\n                compile_error!(\"Traversable can only be derived for structs with an 'id: &'a str' field\");\n            }\n        );\n    }\n\n    // Extract lifetime parameter if present\n    let lifetime = if let Some(param) = input.generics.lifetimes().next() {\n        let lifetime = &param.lifetime;\n        quote! { #lifetime }\n    } else {\n        quote! { 'a }\n    };\n\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n\n    let expanded = quote! {\n        impl #impl_generics #name #ty_generics #where_clause {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_id_422": {
      "name": "id",
      "type": "method",
      "start_line": 422,
      "end_line": 429,
      "content_hash": "c3d079f006574c4f467de7c587aca0f0c9144fef",
      "content": "            pub fn id(&self) -> &#lifetime str {\n                self.id\n            }\n        }\n    };\n\n    TokenStream::from(expanded)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}