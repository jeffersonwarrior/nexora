{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/concurrency_tests/integration_stress_tests.rs",
  "file_hash": "ce1cb1b3b368f289ec0129298e6cf87a2df60965",
  "updated_at": "2025-12-26T17:34:24.257630",
  "symbols": {
    "function_setup_stress_storage_35": {
      "name": "setup_stress_storage",
      "type": "function",
      "start_line": 35,
      "end_line": 47,
      "content_hash": "26db7011b1625da04008232fea59ee761bfdaf76",
      "content": "fn setup_stress_storage() -> (Arc<HelixGraphStorage>, TempDir) {\n    let temp_dir = tempfile::tempdir().unwrap();\n    let path = temp_dir.path().to_str().unwrap();\n\n    let mut config = Config::default();\n    config.db_max_size_gb = Some(20); // Large size for stress tests\n\n    let storage = HelixGraphStorage::new(path, config, Default::default()).unwrap();\n    (Arc::new(storage), temp_dir)\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_mixed_read_write_operations_48": {
      "name": "test_stress_mixed_read_write_operations",
      "type": "function",
      "start_line": 48,
      "end_line": 141,
      "content_hash": "fe2ffc2fa0f7815a12e0f5acafa8e023dafe7bf6",
      "content": "fn test_stress_mixed_read_write_operations() {\n    // Stress test: Simultaneous graph reads and writes under high load\n    //\n    // EXPECTED: Both operations function correctly under load\n\n    let (storage, _temp_dir) = setup_stress_storage();\n\n    let duration = Duration::from_secs(3);\n    let start = std::time::Instant::now();\n\n    let write_ops = Arc::new(AtomicUsize::new(0));\n    let read_ops = Arc::new(AtomicUsize::new(0));\n\n    let mut handles = vec![];\n\n    // Graph writers - create nodes and edges\n    for writer_id in 0..4 {\n        let storage = Arc::clone(&storage);\n        let write_ops = Arc::clone(&write_ops);\n\n        handles.push(thread::spawn(move || {\n            let mut count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                let label1 = format!(\"node_w{}_n{}_a\", writer_id, count);\n                let label2 = format!(\"node_w{}_n{}_b\", writer_id, count);\n\n                let id1 = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label1, None, None)\n                    .collect::<Result<Vec<_>, _>>()\n                    .unwrap()[0]\n                    .id();\n\n                let id2 = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label2, None, None)\n                    .collect::<Result<Vec<_>, _>>()\n                    .unwrap()[0]\n                    .id();\n\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"connects\", None, id1, id2, false)\n                    .collect_to_obj().unwrap();\n\n                wtxn.commit().unwrap();\n                write_ops.fetch_add(1, Ordering::Relaxed);\n                count += 1;\n            }\n            count\n        }));\n    }\n\n    // Graph readers - monitor graph growth\n    for _reader_id in 0..4 {\n        let storage = Arc::clone(&storage);\n        let read_ops = Arc::clone(&read_ops);\n\n        handles.push(thread::spawn(move || {\n            let mut count = 0;\n            while start.elapsed() < duration {\n                let rtxn = storage.graph_env.read_txn().unwrap();\n                let node_count = storage.nodes_db.len(&rtxn).unwrap();\n                let edge_count = storage.edges_db.len(&rtxn).unwrap();\n                if node_count > 0 && edge_count > 0 {\n                    read_ops.fetch_add(1, Ordering::Relaxed);\n                    count += 1;\n                }\n            }\n            count\n        }));\n    }\n\n    let mut counts = vec![];\n    for handle in handles {\n        counts.push(handle.join().unwrap());\n    }\n\n    let total_writes = write_ops.load(Ordering::Relaxed);\n    let total_reads = read_ops.load(Ordering::Relaxed);\n\n    println!(\n        \"Stress test: {} writes, {} reads in {:?}\",\n        total_writes, total_reads, duration\n    );\n    println!(\"Thread counts: {:?}\", counts);\n\n    // Verify significant work was done\n    assert!(total_writes > 100, \"Should perform many write operations\");\n    assert!(total_reads > 100, \"Should perform many read operations\");\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_rapid_graph_growth_142": {
      "name": "test_stress_rapid_graph_growth",
      "type": "function",
      "start_line": 142,
      "end_line": 273,
      "content_hash": "433eb4f5c30e6e77244c895c7808b93132156e6a",
      "content": "fn test_stress_rapid_graph_growth() {\n    // Stress test: Rapidly growing graph with immediate traversals\n    //\n    // EXPECTED: Graph remains traversable and consistent\n\n    let (storage, _temp_dir) = setup_stress_storage();\n\n    // Create root nodes\n    let root_ids: Vec<u128> = {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        let ids = (0..5)\n            .map(|i| {\n                let label = format!(\"root_{}\", i);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>, _>>()\n                    .unwrap()[0]\n                    .id()\n            })\n            .collect();\n\n        wtxn.commit().unwrap();\n        ids\n    };\n\n    let duration = Duration::from_secs(3);\n    let start = std::time::Instant::now();\n    let root_ids = Arc::new(root_ids);\n\n    let write_count = Arc::new(AtomicUsize::new(0));\n    let read_count = Arc::new(AtomicUsize::new(0));\n\n    let mut handles = vec![];\n\n    // Writers - rapidly add nodes and edges\n    for writer_id in 0..3 {\n        let storage = Arc::clone(&storage);\n        let root_ids = Arc::clone(&root_ids);\n        let write_count = Arc::clone(&write_count);\n\n        handles.push(thread::spawn(move || {\n            let mut local_count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                // Add new node\n                let label = format!(\"w{}_n{}\", writer_id, local_count);\n                let new_id = G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>, _>>()\n                    .unwrap()[0]\n                    .id();\n\n                // Connect to random root\n                let root_idx = local_count % root_ids.len();\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_edge(\"child_of\", None, root_ids[root_idx], new_id, false)\n                    .collect_to_obj().unwrap();\n\n                wtxn.commit().unwrap();\n                write_count.fetch_add(1, Ordering::Relaxed);\n                local_count += 1;\n            }\n            local_count\n        }));\n    }\n\n    // Readers - continuously traverse from roots\n    for _reader_id in 0..3 {\n        let storage = Arc::clone(&storage);\n        let root_ids = Arc::clone(&root_ids);\n        let read_count = Arc::clone(&read_count);\n\n        handles.push(thread::spawn(move || {\n            let mut local_count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let rtxn = storage.graph_env.read_txn().unwrap();\n\n                // Traverse from each root\n                for root_id in root_ids.iter() {\n                    let _children = G::new(&storage, &rtxn, &arena)\n                        .n_from_id(root_id)\n                        .out_node(\"child_of\")\n                        .collect::<Result<Vec<_>, _>>()\n                        .unwrap();\n                    local_count += 1;\n                }\n\n                read_count.fetch_add(root_ids.len(), Ordering::Relaxed);\n            }\n            local_count\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    let total_writes = write_count.load(Ordering::Relaxed);\n    let total_reads = read_count.load(Ordering::Relaxed);\n\n    println!(\n        \"Rapid growth: {} writes, {} reads in {:?}\",\n        total_writes, total_reads, duration\n    );\n\n    // Verify significant work done\n    assert!(total_writes > 100, \"Should create many nodes\");\n    assert!(total_reads > 100, \"Should perform many traversals\");\n\n    // Verify graph integrity\n    let _arena = Bump::new();\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let final_node_count = storage.nodes_db.len(&rtxn).unwrap();\n    let final_edge_count = storage.edges_db.len(&rtxn).unwrap();\n\n    println!(\n        \"Final: {} nodes, {} edges\",\n        final_node_count, final_edge_count\n    );\n    assert!(\n        final_node_count > 100,\n        \"Graph should have grown significantly\"\n    );\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_transaction_contention_274": {
      "name": "test_stress_transaction_contention",
      "type": "function",
      "start_line": 274,
      "end_line": 347,
      "content_hash": "e5cea7e9b2c1f1589289eed6ba48032f2232d4e7",
      "content": "fn test_stress_transaction_contention() {\n    // Stress test: High contention on write transactions\n    //\n    // EXPECTED: LMDB single-writer enforced, no corruption\n\n    let (storage, _temp_dir) = setup_stress_storage();\n\n    let num_threads = 8;\n    let duration = Duration::from_secs(2);\n    let start = std::time::Instant::now();\n    let barrier = Arc::new(Barrier::new(num_threads));\n\n    let success_count = Arc::new(AtomicUsize::new(0));\n\n    let handles: Vec<_> = (0..num_threads)\n        .map(|thread_id| {\n            let storage = Arc::clone(&storage);\n            let barrier = Arc::clone(&barrier);\n            let success_count = Arc::clone(&success_count);\n\n            thread::spawn(move || {\n                barrier.wait();\n\n                let mut local_count = 0;\n                while start.elapsed() < duration {\n                    let arena = Bump::new();\n\n                    // Try to acquire write transaction\n                    if let Ok(mut wtxn) = storage.graph_env.write_txn() {\n                        let label = format!(\"t{}_n{}\", thread_id, local_count);\n                        G::new_mut(&storage, &arena, &mut wtxn)\n                            .add_n(&label, None, None)\n                            .collect::<Result<Vec<_>, _>>()\n                            .unwrap();\n\n                        wtxn.commit().unwrap();\n                        success_count.fetch_add(1, Ordering::Relaxed);\n                        local_count += 1;\n                    }\n\n                    // Small delay to allow other threads\n                    thread::sleep(Duration::from_micros(50));\n                }\n                local_count\n            })\n        })\n        .collect();\n\n    let mut per_thread_counts = vec![];\n    for handle in handles {\n        per_thread_counts.push(handle.join().unwrap());\n    }\n\n    let total_success = success_count.load(Ordering::Relaxed);\n\n    println!(\n        \"Transaction contention: {} successful writes in {:?}\",\n        total_success, duration\n    );\n    println!(\"Per thread: {:?}\", per_thread_counts);\n\n    // Verify all writes succeeded\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let final_count = storage.nodes_db.len(&rtxn).unwrap();\n\n    assert_eq!(\n        final_count, total_success as u64,\n        \"All commits should be visible\"\n    );\n    assert!(total_success > 50, \"Should handle significant contention\");\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_long_running_transactions_348": {
      "name": "test_stress_long_running_transactions",
      "type": "function",
      "start_line": 348,
      "end_line": 442,
      "content_hash": "485f03029b0f66c2f0a1931a207dc9bdb5851d4a",
      "content": "fn test_stress_long_running_transactions() {\n    // Stress test: Long-lived read transactions with concurrent writes\n    //\n    // EXPECTED: MVCC snapshot isolation maintained, no blocking\n\n    let (storage, _temp_dir) = setup_stress_storage();\n\n    // Create initial data\n    {\n        let arena = Bump::new();\n        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n        for i in 0..20 {\n            let label = format!(\"initial_{}\", i);\n            G::new_mut(&storage, &arena, &mut wtxn)\n                .add_n(&label, None, None)\n                .collect::<Result<Vec<_>, _>>()\n                .unwrap();\n        }\n\n        wtxn.commit().unwrap();\n    }\n\n    let duration = Duration::from_secs(2);\n    let start = std::time::Instant::now();\n\n    let write_count = Arc::new(AtomicUsize::new(0));\n\n    let mut handles = vec![];\n\n    // Long-running reader - holds transaction open\n    let storage_clone = Arc::clone(&storage);\n    handles.push(thread::spawn(move || {\n        let rtxn = storage_clone.graph_env.read_txn().unwrap();\n        let initial_count = storage_clone.nodes_db.len(&rtxn).unwrap();\n\n        // Hold transaction for entire duration\n        while start.elapsed() < duration {\n            thread::sleep(Duration::from_millis(100));\n        }\n\n        // Should still see initial count (snapshot isolation)\n        let final_count = storage_clone.nodes_db.len(&rtxn).unwrap();\n        assert_eq!(\n            final_count, initial_count,\n            \"Long-lived txn should see consistent snapshot\"\n        );\n\n        final_count\n    }));\n\n    // Writers - continuously add data\n    for writer_id in 0..3 {\n        let storage = Arc::clone(&storage);\n        let write_count = Arc::clone(&write_count);\n\n        handles.push(thread::spawn(move || {\n            let mut count = 0;\n            while start.elapsed() < duration {\n                let arena = Bump::new();\n                let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                let label = format!(\"w{}_n{}\", writer_id, count);\n                G::new_mut(&storage, &arena, &mut wtxn)\n                    .add_n(&label, None, None)\n                    .collect::<Result<Vec<_>, _>>()\n                    .unwrap();\n\n                wtxn.commit().unwrap();\n                write_count.fetch_add(1, Ordering::Relaxed);\n                count += 1;\n            }\n            count\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    let total_writes = write_count.load(Ordering::Relaxed);\n\n    println!(\n        \"Long txns: {} writes completed during long-lived read\",\n        total_writes\n    );\n\n    // New transaction should see all writes\n    let rtxn = storage.graph_env.read_txn().unwrap();\n    let final_count = storage.nodes_db.len(&rtxn).unwrap();\n    assert_eq!(final_count, 20 + total_writes as u64);\n}\n\n#[test]\n#[serial(lmdb_stress)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_stress_memory_stability_443": {
      "name": "test_stress_memory_stability",
      "type": "function",
      "start_line": 443,
      "end_line": 507,
      "content_hash": "32d332332ca36ade2e5bfcd52c27f6136536d5ae",
      "content": "fn test_stress_memory_stability() {\n    // Stress test: Verify no memory leaks under sustained load\n    //\n    // EXPECTED: System remains stable, no unbounded growth\n\n    let (storage, _temp_dir) = setup_stress_storage();\n\n    let duration = Duration::from_secs(3);\n    let iterations = 3;\n\n    for iteration in 0..iterations {\n        let start = std::time::Instant::now();\n        let op_count = Arc::new(AtomicUsize::new(0));\n\n        let mut handles = vec![];\n\n        // Multiple worker threads doing various operations\n        for worker_id in 0..4 {\n            let storage = Arc::clone(&storage);\n            let op_count = Arc::clone(&op_count);\n\n            handles.push(thread::spawn(move || {\n                let mut count = 0;\n                while start.elapsed() < duration {\n                    // Create short-lived transaction\n                    {\n                        let arena = Bump::new();\n                        let mut wtxn = storage.graph_env.write_txn().unwrap();\n\n                        let label = format!(\"iter{}_w{}_n{}\", iteration, worker_id, count);\n                        G::new_mut(&storage, &arena, &mut wtxn)\n                            .add_n(&label, None, None)\n                            .collect::<Result<Vec<_>, _>>()\n                            .unwrap();\n\n                        wtxn.commit().unwrap();\n                    }\n\n                    // Perform read\n                    {\n                        let rtxn = storage.graph_env.read_txn().unwrap();\n                        let _count = storage.nodes_db.len(&rtxn).unwrap();\n                    }\n\n                    op_count.fetch_add(1, Ordering::Relaxed);\n                    count += 1;\n                }\n                count\n            }));\n        }\n\n        for handle in handles {\n            handle.join().unwrap();\n        }\n\n        let ops = op_count.load(Ordering::Relaxed);\n        println!(\n            \"Memory stability iteration {}: {} ops in {:?}\",\n            iteration, ops, duration\n        );\n    }\n\n    // If we reach here without panic/OOM, memory is stable\n    println!(\"Memory stability test completed successfully\");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}