{
  "file_path": "/work/internal/agent/tools/mcp/init.go",
  "file_hash": "f74c8ac3d41c0e715f6f9955e4459c7270edecb0",
  "updated_at": "2025-12-26T17:34:25.095522",
  "symbols": {
    "method_String_47": {
      "name": "String",
      "type": "method",
      "start_line": 47,
      "end_line": 71,
      "content_hash": "b84d88e9c23236006f7b71b130728315125252e9",
      "content": "func (s State) String() string {\n\tswitch s {\n\tcase StateDisabled:\n\t\treturn \"disabled\"\n\tcase StateStarting:\n\t\treturn \"starting\"\n\tcase StateConnected:\n\t\treturn \"connected\"\n\tcase StateError:\n\t\treturn \"error\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// EventType represents the type of MCP event\ntype EventType uint\n\nconst (\n\tEventStateChanged EventType = iota\n\tEventToolsListChanged\n\tEventPromptsListChanged\n)\n\n// Event represents an event in the MCP system",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Event_72": {
      "name": "Event",
      "type": "struct",
      "start_line": 72,
      "end_line": 80,
      "content_hash": "8efdcf44b9d35be40ff91a227913f4cb2635c308",
      "content": "type Event struct {\n\tType   EventType\n\tName   string\n\tState  State\n\tError  error\n\tCounts Counts\n}\n\n// Counts number of available tools, prompts, etc.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Counts_81": {
      "name": "Counts",
      "type": "struct",
      "start_line": 81,
      "end_line": 86,
      "content_hash": "840acdf8f4befcdb55c41ca608e728d2d58f1214",
      "content": "type Counts struct {\n\tTools   int\n\tPrompts int\n}\n\n// ClientInfo holds information about an MCP client's state",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ClientInfo_87": {
      "name": "ClientInfo",
      "type": "struct",
      "start_line": 87,
      "end_line": 96,
      "content_hash": "fce29dc0621411ff16cc2a89dd85852d7a5f135c",
      "content": "type ClientInfo struct {\n\tName        string\n\tState       State\n\tError       error\n\tClient      *mcp.ClientSession\n\tCounts      Counts\n\tConnectedAt time.Time\n}\n\n// SubscribeEvents returns a channel for MCP events",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_SubscribeEvents_97": {
      "name": "SubscribeEvents",
      "type": "function",
      "start_line": 97,
      "end_line": 101,
      "content_hash": "e8ae10c6676e577fab2fde862e85f3c998ae914f",
      "content": "func SubscribeEvents(ctx context.Context) <-chan pubsub.Event[Event] {\n\treturn broker.Subscribe(ctx)\n}\n\n// GetStates returns the current state of all MCP clients",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GetStates_102": {
      "name": "GetStates",
      "type": "function",
      "start_line": 102,
      "end_line": 106,
      "content_hash": "cefc0a70cc9ac398b1f1388c212c8e7425b75578",
      "content": "func GetStates() map[string]ClientInfo {\n\treturn maps.Collect(states.Seq2())\n}\n\n// GetState returns the state of a specific MCP client",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GetState_107": {
      "name": "GetState",
      "type": "function",
      "start_line": 107,
      "end_line": 111,
      "content_hash": "6256ddb4b0618238c9b6e573ce06a1dd84fb2e60",
      "content": "func GetState(name string) (ClientInfo, bool) {\n\treturn states.Get(name)\n}\n\n// Close closes all MCP clients. This should be called during application shutdown.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Close_112": {
      "name": "Close",
      "type": "function",
      "start_line": 112,
      "end_line": 146,
      "content_hash": "7bf64a7965fc7f32987fcdb53265eaf25a23a93d",
      "content": "func Close() error {\n\t// Close Z.ai manager if initialized\n\tif zaiManager != nil {\n\t\tif err := zaiManager.Stop(); err != nil {\n\t\t\tslog.Error(\"error stopping Z.ai MCP manager\", \"error\", err)\n\t\t}\n\t\tzaiManager = nil\n\t}\n\n\tvar errs []error\n\tvar wg sync.WaitGroup\n\tfor name, session := range sessions.Seq2() {\n\t\twg.Go(func() {\n\t\t\tdone := make(chan bool, 1)\n\t\t\tgo func() {\n\t\t\t\tif err := session.Close(); err != nil &&\n\t\t\t\t\t!errors.Is(err, io.EOF) &&\n\t\t\t\t\t!errors.Is(err, context.Canceled) &&\n\t\t\t\t\terr.Error() != \"signal: killed\" {\n\t\t\t\t\terrs = append(errs, fmt.Errorf(\"close mcp: %s: %w\", name, err))\n\t\t\t\t}\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Millisecond * 250):\n\t\t\t}\n\t\t})\n\t}\n\twg.Wait()\n\tbroker.Shutdown()\n\treturn errors.Join(errs...)\n}\n\n// initializeZAI initializes the Z.ai Vision MCP if configured",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_initializeZAI_147": {
      "name": "initializeZAI",
      "type": "function",
      "start_line": 147,
      "end_line": 197,
      "content_hash": "5c8918e0952202f7b844d4de7301751adc68f6de",
      "content": "func initializeZAI(ctx context.Context, cfg *config.Config) {\n\t// Check if Z.ai API key is available\n\tif err := zai.ValidateConfig(); err != nil {\n\t\tslog.Debug(\"Z.ai MCP not configured\", \"error\", err)\n\t\treturn\n\t}\n\n\tslog.Info(\"initializing Z.ai Vision MCP\")\n\n\t// Create Z.ai manager\n\tzaiManager = zai.NewManager(*cfg)\n\n\t// Start the manager (non-blocking)\n\tgo func() {\n\t\tif err := zaiManager.Start(ctx); err != nil {\n\t\t\tslog.Error(\"failed to start Z.ai MCP manager\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Get available tools and register them\n\t\ttools, err := zaiManager.GetAvailableTools()\n\t\tif err != nil {\n\t\t\tslog.Error(\"failed to get Z.ai tools\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tslog.Info(\"Z.ai Vision MCP initialized successfully\", \"tools_count\", len(tools))\n\n\t\t// Convert MCP tools to our format\n\t\tmcpTools := make([]*mcp.Tool, len(tools))\n\t\tfor i, toolName := range tools {\n\t\t\tmcpTools[i] = &mcp.Tool{\n\t\t\t\tName:        toolName,\n\t\t\t\tDescription: zai.GetToolDescription(toolName),\n\t\t\t\t// In a full implementation, we'd include the actual input schema\n\t\t\t\tInputSchema: map[string]any{\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// Register tools with the MCP system\n\t\tupdateTools(\"zai-vision\", mcpTools)\n\t\tupdateState(\"zai-vision\", StateConnected, nil, nil, Counts{\n\t\t\tTools:   len(mcpTools),\n\t\t\tPrompts: 0,\n\t\t})\n\t}()\n}\n\n// GetZAIManager returns the Z.ai MCP manager",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GetZAIManager_198": {
      "name": "GetZAIManager",
      "type": "function",
      "start_line": 198,
      "end_line": 202,
      "content_hash": "e78102776e0c97ecfbe265e0aa360f4bd193a481",
      "content": "func GetZAIManager() *zai.Manager {\n\treturn zaiManager\n}\n\n// IsZAITool checks if a tool name is a Z.ai vision tool",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_IsZAITool_203": {
      "name": "IsZAITool",
      "type": "function",
      "start_line": 203,
      "end_line": 207,
      "content_hash": "166930ee8ee6d3df19bb1971145f9a44e0b865b7",
      "content": "func IsZAITool(toolName string) bool {\n\treturn zai.IsVisionTool(toolName)\n}\n\n// RunZAITool executes a Z.ai vision tool",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_RunZAITool_208": {
      "name": "RunZAITool",
      "type": "function",
      "start_line": 208,
      "end_line": 224,
      "content_hash": "1258bdbcd409854e8d1c94ab716045b6698f0e04",
      "content": "func RunZAITool(ctx context.Context, toolName string, arguments map[string]interface{}) (*mcp.CallToolResult, error) {\n\tif zaiManager == nil {\n\t\treturn nil, fmt.Errorf(\"Z.ai MCP manager not initialized\")\n\t}\n\n\tclient, err := zaiManager.GetClient()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get Z.ai MCP client: %w\", err)\n\t}\n\n\treturn client.CallTool(ctx, &mcp.CallToolParams{\n\t\tName:      toolName,\n\t\tArguments: arguments,\n\t})\n}\n\n// Initialize initializes MCP clients based on the provided configuration.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Initialize_225": {
      "name": "Initialize",
      "type": "function",
      "start_line": 225,
      "end_line": 295,
      "content_hash": "9c67f898e3ca1615f4198bfa7301cde381a05715",
      "content": "func Initialize(ctx context.Context, permissions permission.Service, cfg *config.Config) {\n\tvar wg sync.WaitGroup\n\n\t// Initialize Z.ai Vision MCP if API key is available\n\tinitializeZAI(ctx, cfg)\n\n\t// Initialize states for all configured MCPs\n\tfor name, m := range cfg.MCP {\n\t\tif m.Disabled {\n\t\t\tupdateState(name, StateDisabled, nil, nil, Counts{})\n\t\t\tslog.Debug(\"skipping disabled mcp\", \"name\", name)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Set initial starting state\n\t\tupdateState(name, StateStarting, nil, nil, Counts{})\n\n\t\twg.Add(1)\n\t\tgo func(name string, m config.MCPConfig) {\n\t\t\tdefer func() {\n\t\t\t\twg.Done()\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tvar err error\n\t\t\t\t\tswitch v := r.(type) {\n\t\t\t\t\tcase error:\n\t\t\t\t\t\terr = v\n\t\t\t\t\tcase string:\n\t\t\t\t\t\terr = fmt.Errorf(\"panic: %s\", v)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terr = fmt.Errorf(\"panic: %v\", v)\n\t\t\t\t\t}\n\t\t\t\t\tupdateState(name, StateError, err, nil, Counts{})\n\t\t\t\t\tslog.Error(\"panic in mcp client initialization\", \"error\", err, \"name\", name)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// createSession handles its own timeout internally.\n\t\t\tsession, err := createSession(ctx, name, m, cfg.Resolver())\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttools, err := getTools(ctx, session)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"error listing tools\", \"error\", err)\n\t\t\t\tupdateState(name, StateError, err, nil, Counts{})\n\t\t\t\tsession.Close()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tprompts, err := getPrompts(ctx, session)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"error listing prompts\", \"error\", err)\n\t\t\t\tupdateState(name, StateError, err, nil, Counts{})\n\t\t\t\tsession.Close()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tupdateTools(name, tools)\n\t\t\tupdatePrompts(name, prompts)\n\t\t\tsessions.Set(name, session)\n\n\t\t\tupdateState(name, StateConnected, nil, session, Counts{\n\t\t\t\tTools:   len(tools),\n\t\t\t\tPrompts: len(prompts),\n\t\t\t})\n\t\t}(name, m)\n\t}\n\twg.Wait()\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getOrRenewClient_296": {
      "name": "getOrRenewClient",
      "type": "function",
      "start_line": 296,
      "end_line": 325,
      "content_hash": "1bf7bcfa86dcb6c7b88d32c9273026a5024d6e1b",
      "content": "func getOrRenewClient(ctx context.Context, name string) (*mcp.ClientSession, error) {\n\tsess, ok := sessions.Get(name)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"mcp '%s' not available\", name)\n\t}\n\n\tcfg := config.Get()\n\tm := cfg.MCP[name]\n\tstate, _ := states.Get(name)\n\n\ttimeout := mcpTimeout(m)\n\tpingCtx, cancel := context.WithTimeout(ctx, timeout)\n\tdefer cancel()\n\terr := sess.Ping(pingCtx, nil)\n\tif err == nil {\n\t\treturn sess, nil\n\t}\n\tupdateState(name, StateError, maybeTimeoutErr(err, timeout), nil, state.Counts)\n\n\tsess, err = createSession(ctx, name, m, cfg.Resolver())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tupdateState(name, StateConnected, nil, sess, state.Counts)\n\tsessions.Set(name, sess)\n\treturn sess, nil\n}\n\n// updateState updates the state of an MCP client and publishes an event",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_updateState_326": {
      "name": "updateState",
      "type": "function",
      "start_line": 326,
      "end_line": 351,
      "content_hash": "06d605526a390ed4c40615ed30addd6845c71ab9",
      "content": "func updateState(name string, state State, err error, client *mcp.ClientSession, counts Counts) {\n\tinfo := ClientInfo{\n\t\tName:   name,\n\t\tState:  state,\n\t\tError:  err,\n\t\tClient: client,\n\t\tCounts: counts,\n\t}\n\tswitch state {\n\tcase StateConnected:\n\t\tinfo.ConnectedAt = time.Now()\n\tcase StateError:\n\t\tsessions.Del(name)\n\t}\n\tstates.Set(name, info)\n\n\t// Publish state change event\n\tbroker.Publish(pubsub.UpdatedEvent, Event{\n\t\tType:   EventStateChanged,\n\t\tName:   name,\n\t\tState:  state,\n\t\tError:  err,\n\t\tCounts: counts,\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createSession_352": {
      "name": "createSession",
      "type": "function",
      "start_line": 352,
      "end_line": 412,
      "content_hash": "20727b39dbf1406ff440819c9c58ff85fe3d4aab",
      "content": "func createSession(ctx context.Context, name string, m config.MCPConfig, resolver config.VariableResolver) (*mcp.ClientSession, error) {\n\ttimeout := mcpTimeout(m)\n\tmcpCtx, cancel := context.WithCancel(ctx)\n\tcancelTimer := time.AfterFunc(timeout, cancel)\n\n\ttransport, err := createTransport(mcpCtx, m, resolver)\n\tif err != nil {\n\t\tupdateState(name, StateError, err, nil, Counts{})\n\t\tslog.Error(\"error creating mcp client\", \"error\", err, \"name\", name)\n\t\tcancel()\n\t\tcancelTimer.Stop()\n\t\treturn nil, err\n\t}\n\n\tclient := mcp.NewClient(\n\t\t&mcp.Implementation{\n\t\t\tName:    \"nexora\",\n\t\t\tVersion: version.Version,\n\t\t\tTitle:   \"Nexora\",\n\t\t},\n\t\t&mcp.ClientOptions{\n\t\t\tToolListChangedHandler: func(context.Context, *mcp.ToolListChangedRequest) {\n\t\t\t\tbroker.Publish(pubsub.UpdatedEvent, Event{\n\t\t\t\t\tType: EventToolsListChanged,\n\t\t\t\t\tName: name,\n\t\t\t\t})\n\t\t\t},\n\t\t\tPromptListChangedHandler: func(context.Context, *mcp.PromptListChangedRequest) {\n\t\t\t\tbroker.Publish(pubsub.UpdatedEvent, Event{\n\t\t\t\t\tType: EventPromptsListChanged,\n\t\t\t\t\tName: name,\n\t\t\t\t})\n\t\t\t},\n\t\t\tLoggingMessageHandler: func(_ context.Context, req *mcp.LoggingMessageRequest) {\n\t\t\t\tslog.Info(\"MCP log\", \"name\", name, \"data\", req.Params.Data)\n\t\t\t},\n\t\t},\n\t)\n\n\tsession, err := client.Connect(mcpCtx, transport, nil)\n\tif err != nil {\n\t\terr = maybeStdioErr(err, transport)\n\t\tupdateState(name, StateError, maybeTimeoutErr(err, timeout), nil, Counts{})\n\t\tslog.Error(\"MCP client failed to initialize\", \"error\", err, \"name\", name)\n\t\tcancel()\n\t\tcancelTimer.Stop()\n\t\treturn nil, err\n\t}\n\n\tcancelTimer.Stop()\n\tslog.Info(\"MCP client initialized\", \"name\", name)\n\treturn session, nil\n}\n\n// maybeStdioErr if a stdio mcp prints an error in non-json format, it'll fail\n// to parse, and the cli will then close it, causing the EOF error.\n// so, if we got an EOF err, and the transport is STDIO, we try to exec it\n// again with a timeout and collect the output so we can add details to the\n// error.\n// this happens particularly when starting things with npx, e.g. if node can't\n// be found or some other error like that.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_maybeStdioErr_413": {
      "name": "maybeStdioErr",
      "type": "function",
      "start_line": 413,
      "end_line": 426,
      "content_hash": "1f7e21a99d40c3b2ef1d71b2908dd617a3ad47c5",
      "content": "func maybeStdioErr(err error, transport mcp.Transport) error {\n\tif !errors.Is(err, io.EOF) {\n\t\treturn err\n\t}\n\tct, ok := transport.(*mcp.CommandTransport)\n\tif !ok {\n\t\treturn err\n\t}\n\tif err2 := stdioCheck(ct.Command); err2 != nil {\n\t\terr = errors.Join(err, err2)\n\t}\n\treturn err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_maybeTimeoutErr_427": {
      "name": "maybeTimeoutErr",
      "type": "function",
      "start_line": 427,
      "end_line": 433,
      "content_hash": "a5d593f8a669dc28941c83d3eaea1295f037997b",
      "content": "func maybeTimeoutErr(err error, timeout time.Duration) error {\n\tif errors.Is(err, context.Canceled) {\n\t\treturn fmt.Errorf(\"timed out after %s\", timeout)\n\t}\n\treturn err\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createTransport_434": {
      "name": "createTransport",
      "type": "function",
      "start_line": 434,
      "end_line": 479,
      "content_hash": "8bc823e939d166fa28617e84aefa9199a281c7e4",
      "content": "func createTransport(ctx context.Context, m config.MCPConfig, resolver config.VariableResolver) (mcp.Transport, error) {\n\tswitch m.Type {\n\tcase config.MCPStdio:\n\t\tcommand, err := resolver.ResolveValue(m.Command)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid mcp command: %w\", err)\n\t\t}\n\t\tif strings.TrimSpace(command) == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"mcp stdio config requires a non-empty 'command' field\")\n\t\t}\n\t\tcmd := exec.CommandContext(ctx, home.Long(command), m.Args...)\n\t\tcmd.Env = append(os.Environ(), m.ResolvedEnv()...)\n\t\treturn &mcp.CommandTransport{\n\t\t\tCommand: cmd,\n\t\t}, nil\n\tcase config.MCPHttp:\n\t\tif strings.TrimSpace(m.URL) == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"mcp http config requires a non-empty 'url' field\")\n\t\t}\n\t\tclient := &http.Client{\n\t\t\tTransport: &headerRoundTripper{\n\t\t\t\theaders: m.ResolvedHeaders(),\n\t\t\t},\n\t\t}\n\t\treturn &mcp.StreamableClientTransport{\n\t\t\tEndpoint:   m.URL,\n\t\t\tHTTPClient: client,\n\t\t}, nil\n\tcase config.MCPSSE:\n\t\tif strings.TrimSpace(m.URL) == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"mcp sse config requires a non-empty 'url' field\")\n\t\t}\n\t\tclient := &http.Client{\n\t\t\tTransport: &headerRoundTripper{\n\t\t\t\theaders: m.ResolvedHeaders(),\n\t\t\t},\n\t\t}\n\t\treturn &mcp.SSEClientTransport{\n\t\t\tEndpoint:   m.URL,\n\t\t\tHTTPClient: client,\n\t\t}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported mcp type: %s\", m.Type)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_headerRoundTripper_480": {
      "name": "headerRoundTripper",
      "type": "struct",
      "start_line": 480,
      "end_line": 483,
      "content_hash": "7fcb7ba9097fa4f4bd4b50832dea391f587c2061",
      "content": "type headerRoundTripper struct {\n\theaders map[string]string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_RoundTrip_484": {
      "name": "RoundTrip",
      "type": "method",
      "start_line": 484,
      "end_line": 490,
      "content_hash": "5471d1d14d413070ebc9a5d2421d1d592ac50621",
      "content": "func (rt headerRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tfor k, v := range rt.headers {\n\t\treq.Header.Set(k, v)\n\t}\n\treturn http.DefaultTransport.RoundTrip(req)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_mcpTimeout_491": {
      "name": "mcpTimeout",
      "type": "function",
      "start_line": 491,
      "end_line": 494,
      "content_hash": "6ffc5bfffc32fdcac67c8374e31760e56789e0fa",
      "content": "func mcpTimeout(m config.MCPConfig) time.Duration {\n\treturn time.Duration(cmp.Or(m.Timeout, 15)) * time.Second\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_stdioCheck_495": {
      "name": "stdioCheck",
      "type": "function",
      "start_line": 495,
      "end_line": 505,
      "content_hash": "9aad1a132fbc0d72cc6f9fcd2721638fb34ecf33",
      "content": "func stdioCheck(old *exec.Cmd) error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\tcmd := exec.CommandContext(ctx, old.Path, old.Args...)\n\tcmd.Env = old.Env\n\tout, err := cmd.CombinedOutput()\n\tif err == nil || errors.Is(ctx.Err(), context.DeadlineExceeded) {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%w: %s\", err, string(out))\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}