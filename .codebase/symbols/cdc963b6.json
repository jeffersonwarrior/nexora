{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/return_value_parse_methods.rs",
  "file_hash": "a11a70fc9ddd595d40c6ff69bf90a0e3e7078455",
  "updated_at": "2025-12-26T17:34:21.567486",
  "symbols": {
    "impl_HelixParser_11": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 11,
      "end_line": 106,
      "content_hash": "1cbeab19baa6e40a438d8733a6478353add78269",
      "content": "impl HelixParser {\n    pub(super) fn parse_return_statement(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<Vec<ReturnType>, ParserError> {\n        let inner = pair.into_inner();\n        let mut return_types = Vec::new();\n        for pair in inner {\n            match pair.as_rule() {\n                Rule::array_creation => {\n                    return_types.push(ReturnType::Array(self.parse_array_creation(pair)?));\n                }\n                Rule::object_creation => {\n                    return_types.push(ReturnType::Object(self.parse_object_creation(pair)?));\n                }\n                Rule::evaluates_to_anything => {\n                    return_types.push(ReturnType::Expression(self.parse_expression(pair)?));\n                }\n                _ => {\n                    return Err(ParserError::from(format!(\n                        \"Unexpected rule in return statement: {:?}\",\n                        pair.as_rule()\n                    )));\n                }\n            }\n        }\n        Ok(return_types)\n    }\n\n    pub(super) fn parse_array_creation(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<Vec<ReturnType>, ParserError> {\n        let pairs = pair.into_inner();\n        let mut objects = Vec::new();\n        for p in pairs {\n            match p.as_rule() {\n                Rule::identifier => {\n                    objects.push(ReturnType::Expression(Expression {\n                        loc: p.loc(),\n                        expr: ExpressionType::Identifier(p.as_str().to_string()),\n                    }));\n                }\n                _ => {\n                    objects.push(ReturnType::Object(self.parse_object_creation(p)?));\n                }\n            }\n        }\n        Ok(objects)\n    }\n\n    pub(super) fn parse_object_creation(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<HashMap<String, ReturnType>, ParserError> {\n        pair.into_inner()\n            .map(|p| {\n                let mut object_inner = p.into_inner();\n                let key = object_inner\n                    .next()\n                    .ok_or_else(|| ParserError::from(\"Missing object inner\"))?;\n                let value = object_inner\n                    .next()\n                    .ok_or_else(|| ParserError::from(\"Missing object inner\"))?;\n                let value = self.parse_object_inner(value)?;\n                Ok((key.as_str().to_string(), value))\n            })\n            .collect::<Result<HashMap<String, ReturnType>, _>>()\n    }\n\n    pub(super) fn parse_object_inner(\n        &self,\n        object_field: Pair<Rule>,\n    ) -> Result<ReturnType, ParserError> {\n        let object_field_inner = object_field\n            .into_inner()\n            .next()\n            .ok_or_else(|| ParserError::from(\"Missing object inner\"))?;\n\n        match object_field_inner.as_rule() {\n            Rule::evaluates_to_anything => Ok(ReturnType::Expression(\n                self.parse_expression(object_field_inner)?,\n            )),\n            Rule::object_creation => Ok(ReturnType::Object(\n                self.parse_object_creation(object_field_inner)?,\n            )),\n            Rule::array_creation => Ok(ReturnType::Array(\n                self.parse_array_creation(object_field_inner)?,\n            )),\n            _ => Err(ParserError::from(format!(\n                \"Unexpected rule in parse_object_inner: {:?}\",\n                object_field_inner.as_rule()\n            ))),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}