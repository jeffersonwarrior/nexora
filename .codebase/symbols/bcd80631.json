{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/object_validation.rs",
  "file_hash": "82c755c76d7eead81ec09bbc3d6678c112b93927",
  "updated_at": "2025-12-26T17:34:24.990501",
  "symbols": {
    "function_mark_vector_steps_for_data_fetch_32": {
      "name": "mark_vector_steps_for_data_fetch",
      "type": "function",
      "start_line": 32,
      "end_line": 460,
      "content_hash": "772d7e84df3cfaec18b884394a9e53eaca5e6031",
      "content": "fn mark_vector_steps_for_data_fetch(gen_traversal: &mut GeneratedTraversal) {\n    use crate::helixc::generator::traversal_steps::{EdgeType, Step};\n    use crate::helixc::generator::utils::Separator;\n\n    match &mut gen_traversal.source_step {\n        Separator::Period(step)\n        | Separator::Semicolon(step)\n        | Separator::Empty(step)\n        | Separator::Comma(step)\n        | Separator::Newline(step) => match step {\n            SourceStep::VFromID(v_from_id) => {\n                v_from_id.get_vector_data = true;\n            }\n            SourceStep::VFromType(v_from_type) => {\n                v_from_type.get_vector_data = true;\n            }\n            _ => {}\n        },\n    }\n\n    for step_sep in &mut gen_traversal.steps {\n        match step_sep {\n            Separator::Period(step)\n            | Separator::Semicolon(step)\n            | Separator::Empty(step)\n            | Separator::Comma(step)\n            | Separator::Newline(step) => match step {\n                Step::Out(out) if matches!(out.edge_type, EdgeType::Vec) => {\n                    out.get_vector_data = true;\n                }\n                Step::In(in_step) if matches!(in_step.edge_type, EdgeType::Vec) => {\n                    in_step.get_vector_data = true;\n                }\n                Step::ToV(to_v) => {\n                    to_v.get_vector_data = true;\n                }\n                Step::FromV(from_v) => {\n                    from_v.get_vector_data = true;\n                }\n\n                _ => {}\n            },\n        }\n    }\n}\n\n/// Validates the object step (e.g. `::{ name }`)\n///\n/// # Arguments\n///\n/// * `ctx` - The context of the query\n/// * `cur_ty` - The current type of the traversal\n/// * `obj` - The object to validate\n/// * `original_query` - The original query\n/// * `gen_traversal` - The generated traversal\n/// * `fields_out` - Output parameter to collect the fields being selected\n/// * `scope` - The scope for variable lookups (needed for nested traversals)\n/// * `gen_query` - The generated query (needed for nested traversals)\npub(crate) fn validate_object<'a>(\n    ctx: &mut Ctx<'a>,\n    cur_ty: &Type,\n    obj: &'a Object,\n    original_query: &'a Query,\n    gen_traversal: &mut GeneratedTraversal,\n    fields_out: &mut Vec<ReturnValueField>,\n    scope: &mut std::collections::HashMap<&'a str, crate::helixc::analyzer::utils::VariableInfo>,\n    gen_query: &mut crate::helixc::generator::queries::Query,\n) -> Result<Type, ParserError> {\n    match &cur_ty {\n        Type::Node(Some(node_ty)) | Type::Nodes(Some(node_ty)) => validate_property_access(\n            ctx,\n            obj,\n            original_query,\n            gen_traversal,\n            cur_ty,\n            ctx.node_fields.get(node_ty.as_str()).cloned(),\n            fields_out,\n            scope,\n            gen_query,\n        ),\n        Type::Edge(Some(edge_ty)) | Type::Edges(Some(edge_ty)) => validate_property_access(\n            ctx,\n            obj,\n            original_query,\n            gen_traversal,\n            cur_ty,\n            ctx.edge_fields.get(edge_ty.as_str()).cloned(),\n            fields_out,\n            scope,\n            gen_query,\n        ),\n        Type::Vector(Some(vector_ty)) | Type::Vectors(Some(vector_ty)) => validate_property_access(\n            ctx,\n            obj,\n            original_query,\n            gen_traversal,\n            cur_ty,\n            ctx.vector_fields.get(vector_ty.as_str()).cloned(),\n            fields_out,\n            scope,\n            gen_query,\n        ),\n        Type::Anonymous(ty) => validate_object(\n            ctx,\n            ty,\n            obj,\n            original_query,\n            gen_traversal,\n            fields_out,\n            scope,\n            gen_query,\n        ),\n        _ => {\n            generate_error!(\n                ctx,\n                original_query,\n                obj.fields[0].value.loc.clone(),\n                E203,\n                &obj.fields[0].value.loc.span\n            );\n            Ok(Type::Unknown)\n        }\n    }\n}\n\n/// Extracts the fields from an object selection\n/// This is used when the query selects specific fields like N<User>::{id, name, email}\n/// Returns true if the 'data' field was selected (for Vector types)\nfn extract_fields_from_object<'a>(\n    ctx: &mut Ctx<'a>,\n    obj: &'a Vec<FieldAddition>,\n    original_query: &'a Query,\n    parent_ty: &Type,\n    fields_out: &mut Vec<ReturnValueField>,\n) -> bool {\n    let mut data_field_accessed = false;\n\n    for FieldAddition { key, value, .. } in obj {\n        match &value.value {\n            FieldValueType::Identifier(identifier) => {\n                // Check if accessing 'data' field\n                if identifier.as_str() == \"data\" {\n                    data_field_accessed = true;\n                }\n\n                // Validate the field exists\n                is_valid_identifier(ctx, original_query, value.loc.clone(), identifier.as_str());\n\n                // Get the field type from the schema\n                if let Some(field_type) =\n                    get_field_type_from_item_fields(ctx, parent_ty, identifier.as_str())\n                {\n                    fields_out.push(ReturnValueField::new(\n                        key.clone(),\n                        format!(\"{}\", field_type),\n                    ));\n                }\n            }\n            // For other field value types, we just track that the field was selected\n            // The actual value will be computed at runtime\n            _ => {\n                // For now, we'll just track these as dynamic values\n                // The code generator will handle extracting the actual values\n                fields_out.push(ReturnValueField::new(key.clone(), \"Value\".to_string()));\n            }\n        }\n    }\n\n    data_field_accessed\n}\n\n/// Validates the property access\n///\n/// # Arguments\n///\n/// * `ctx` - The context of the query\n/// * `obj` - The object to validate\n/// * `original_query` - The original query\n/// * `gen_traversal` - The generated traversal\n/// * `cur_ty` - The current type of the traversal\n/// * `fields` - The fields of the object from schema\n/// * `fields_out` - Output parameter to collect selected fields\nfn validate_property_access<'a>(\n    ctx: &mut Ctx<'a>,\n    obj: &'a Object,\n    original_query: &'a Query,\n    gen_traversal: &mut GeneratedTraversal,\n    cur_ty: &Type,\n    fields: Option<HashMap<&'a str, Cow<'a, Field>>>,\n    fields_out: &mut Vec<ReturnValueField>,\n    scope: &mut std::collections::HashMap<&'a str, crate::helixc::analyzer::utils::VariableInfo>,\n    gen_query: &mut crate::helixc::generator::queries::Query,\n) -> Result<Type, ParserError> {\n    match fields {\n        Some(_) => {\n            // if there is only one field then it is a single property access\n            // e.g. N<User>::{name}\n            if obj.fields.len() == 1\n                && matches!(obj.fields[0].value.value, FieldValueType::Identifier(_))\n            {\n                match &obj.fields[0].value.value {\n                    FieldValueType::Identifier(lit) => {\n                        is_valid_identifier(\n                            ctx,\n                            original_query,\n                            obj.fields[0].value.loc.clone(),\n                            lit.as_str(),\n                        );\n                        validate_field_name_existence_for_item_type(\n                            ctx,\n                            original_query,\n                            obj.fields[0].value.loc.clone(),\n                            cur_ty,\n                            lit.as_str(),\n                        );\n                        // Check if we're accessing the 'data' field on a Vector type\n                        // If so, we need to mark vector traversal steps to fetch the data\n                        if lit.as_str() == \"data\"\n                            && matches!(cur_ty, Type::Vector(_) | Type::Vectors(_))\n                        {\n                            mark_vector_steps_for_data_fetch(gen_traversal);\n                        }\n\n                        gen_traversal\n                            .steps\n                            .push(Separator::Period(gen_property_access(lit.as_str())));\n\n                        // Store the field name so nested traversal code generation can access it\n                        gen_traversal.object_fields.push(lit.as_str().to_string());\n\n                        match cur_ty {\n                            Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_) => {\n                                gen_traversal.should_collect = ShouldCollect::ToVec;\n                            }\n                            Type::Node(_) | Type::Edge(_) | Type::Vector(_) => {\n                                gen_traversal.should_collect = ShouldCollect::ToObj;\n                            }\n                            _ => {\n                                unreachable!()\n                            }\n                        }\n                        let field_type = get_field_type_from_item_fields(ctx, cur_ty, lit.as_str());\n                        Ok(Type::Scalar(field_type.ok_or(ParserError::ParseError(\n                            \"field is none\".to_string(),\n                        ))?))\n                    }\n                    _ => unreachable!(),\n                }\n            } else if !obj.fields.is_empty() {\n                // Multiple fields selected - extract them for return value generation\n                // e.g. N<User>::{id, name, email}\n                let data_field_accessed = extract_fields_from_object(\n                    ctx,\n                    &obj.fields,\n                    original_query,\n                    cur_ty,\n                    fields_out,\n                );\n\n                // If accessing 'data' field on Vector type, mark vector steps to fetch data\n                if data_field_accessed && matches!(cur_ty, Type::Vector(_) | Type::Vectors(_)) {\n                    mark_vector_steps_for_data_fetch(gen_traversal);\n                }\n\n                // Populate projection metadata for new struct-based return generation\n                gen_traversal.has_object_step = true;\n                gen_traversal.has_spread = obj.should_spread;\n\n                // Collect field names and nested traversals\n                for field_addition in &obj.fields {\n                    match &field_addition.value.value {\n                        FieldValueType::Identifier(id) => {\n                            gen_traversal.object_fields.push(id.clone());\n                        }\n                        FieldValueType::Traversal(tr) => {\n                            // Nested traversal - validate it now to get the type\n                            use crate::helixc::analyzer::methods::traversal_validation::validate_traversal;\n                            use crate::helixc::generator::traversal_steps::NestedTraversalInfo;\n                            use crate::helixc::parser::types::StartNode;\n\n                            // Check if this traversal starts with a closure parameter or anonymous identifier\n                            // For example: usr::ID where usr is in scope, or _::In<Created>::ID\n                            let (closure_param, closure_source) = match &tr.start {\n                                StartNode::Identifier(ident) => {\n                                    if let Some(var_info) = scope.get(ident.as_str()) {\n                                        // Found a closure parameter - capture its name and the actual source variable\n                                        let source_var = var_info\n                                            .source_var\n                                            .clone()\n                                            .unwrap_or_else(|| ident.clone());\n                                        (Some(ident.clone()), Some(source_var))\n                                    } else {\n                                        (None, None)\n                                    }\n                                }\n                                StartNode::Anonymous => (\n                                    Some(DEFAULT_VAR_NAME.to_string()),\n                                    Some(DEFAULT_VAR_NAME.to_string()),\n                                ),\n                                _ => (None, None),\n                            };\n\n                            // Validate the nested traversal\n                            let mut nested_gen_traversal =\n                                crate::helixc::generator::traversal_steps::Traversal::default();\n                            let nested_type = validate_traversal(\n                                ctx,\n                                tr.as_ref(),\n                                scope,\n                                original_query,\n                                Some(cur_ty.clone()),\n                                &mut nested_gen_traversal,\n                                gen_query,\n                            );\n\n                            // Check if this nested traversal ends with a Closure step\n                            let own_closure_param = tr.steps.last()\n                                .and_then(|step| match &step.step {\n                                    crate::helixc::parser::types::StepType::Closure(cl) => Some(cl.identifier.clone()),\n                                    _ => None,\n                                });\n\n                            let nested_info = NestedTraversalInfo {\n                                traversal: Box::new(nested_gen_traversal),\n                                return_type: nested_type.clone(),\n                                field_name: field_addition.key.clone(),\n                                parsed_traversal: Some(tr.clone()),\n                                closure_param_name: closure_param,\n                                closure_source_var: closure_source,\n                                own_closure_param,\n                            };\n                            gen_traversal\n                                .nested_traversals\n                                .insert(field_addition.key.clone(), nested_info);\n                            gen_traversal.object_fields.push(field_addition.key.clone());\n                        }\n                        FieldValueType::Expression(expr) => {\n                            // Check if this expression contains a traversal\n                            use crate::helixc::analyzer::methods::traversal_validation::validate_traversal;\n                            use crate::helixc::generator::traversal_steps::NestedTraversalInfo;\n                            use crate::helixc::parser::types::ExpressionType;\n\n                            if let ExpressionType::Traversal(tr) = &expr.expr {\n                                // Nested traversal within expression - validate it\n                                let mut nested_gen_traversal =\n                                    crate::helixc::generator::traversal_steps::Traversal::default();\n                                let nested_type = validate_traversal(\n                                    ctx,\n                                    tr.as_ref(),\n                                    scope,\n                                    original_query,\n                                    Some(cur_ty.clone()),\n                                    &mut nested_gen_traversal,\n                                    gen_query,\n                                );\n\n                                // Check if this nested traversal ends with a Closure step\n                                let own_closure_param = tr.steps.last()\n                                    .and_then(|step| match &step.step {\n                                        crate::helixc::parser::types::StepType::Closure(cl) => Some(cl.identifier.clone()),\n                                        _ => None,\n                                    });\n\n                                let nested_info = NestedTraversalInfo {\n                                    traversal: Box::new(nested_gen_traversal),\n                                    return_type: nested_type,\n                                    field_name: field_addition.key.clone(),\n                                    parsed_traversal: Some(tr.clone()),\n                                    closure_param_name: None, // Will be set by closure handling code\n                                    closure_source_var: None, // Will be set by closure handling code\n                                    own_closure_param,\n                                };\n                                gen_traversal\n                                    .nested_traversals\n                                    .insert(field_addition.key.clone(), nested_info);\n                                gen_traversal.object_fields.push(field_addition.key.clone());\n                            } else {\n                                // Other expression types (identifiers, literals, etc.)\n                                gen_traversal.object_fields.push(field_addition.key.clone());\n                            }\n                        }\n                        _ => {\n                            // Other field types (literals, etc.)\n                            gen_traversal.object_fields.push(field_addition.key.clone());\n                        }\n                    }\n                }\n\n                // Set collection behavior based on current type\n                match cur_ty {\n                    Type::Nodes(_) | Type::Edges(_) | Type::Vectors(_) => {\n                        gen_traversal.should_collect = ShouldCollect::ToVec;\n                    }\n                    Type::Node(_) | Type::Edge(_) | Type::Vector(_) => {\n                        gen_traversal.should_collect = ShouldCollect::ToObj;\n                    }\n                    _ => {}\n                }\n\n                // Return the current type as we're just selecting fields from it\n                Ok(cur_ty.clone())\n            } else {\n                // error - empty object\n                generate_error!(ctx, original_query, obj.fields[0].value.loc.clone(), E645);\n                Ok(Type::Unknown)\n            }\n        }\n        None => {\n            generate_error!(\n                ctx,\n                original_query,\n                obj.fields[0].value.loc.clone(),\n                E201,\n                &cur_ty.get_type_name()\n            );\n            Ok(Type::Unknown)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::helixc::parser::{HelixParser, write_to_temp_file};\n\n    // ============================================================================\n    // Property Access Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_single_property_access_461": {
      "name": "test_single_property_access",
      "type": "function",
      "start_line": 461,
      "end_line": 480,
      "content_hash": "2874e46d1585ffabe19b230cb320a9240fcf0b26",
      "content": "    fn test_single_property_access() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                name <- person::{name}\n                RETURN name\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_multiple_property_accesses_481": {
      "name": "test_multiple_property_accesses",
      "type": "function",
      "start_line": 481,
      "end_line": 502,
      "content_hash": "355df2d8fde371375daa257a0698810b5989876e",
      "content": "    fn test_multiple_property_accesses() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                name <- person::{name}\n                age <- person::{age}\n                email <- person::{email}\n                RETURN name, age, email\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_implicit_id_field_access_503": {
      "name": "test_implicit_id_field_access",
      "type": "function",
      "start_line": 503,
      "end_line": 521,
      "content_hash": "3a65c0ba2aaabd59f9c37b3881d9e3e2d8363adc",
      "content": "    fn test_implicit_id_field_access() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                personId <- person::{id}\n                RETURN personId\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}