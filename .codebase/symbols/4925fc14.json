{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/generator/math_functions.rs",
  "file_hash": "1e282e2a4d30e40edda1a03ee6514cd9c89a681a",
  "updated_at": "2025-12-26T17:34:23.825144",
  "symbols": {
    "enum_MathExpr_10": {
      "name": "MathExpr",
      "type": "enum",
      "start_line": 10,
      "end_line": 18,
      "content_hash": "b59668869b29b02988458a9d5ca33f7e41772df2",
      "content": "pub enum MathExpr {\n    FunctionCall(MathFunctionCallGen),\n    NumericLiteral(NumericLiteral),\n    PropertyAccess(PropertyAccess),\n    Identifier(String),\n}\n\n/// Context for property access in weight calculations\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_PropertyContext_19": {
      "name": "PropertyContext",
      "type": "enum",
      "start_line": 19,
      "end_line": 26,
      "content_hash": "a9e3327e44676f397bde154a4a26590335417197",
      "content": "pub enum PropertyContext {\n    Edge,       // _::{property}\n    SourceNode, // _::From::{property}\n    TargetNode, // _::To::{property}\n    Current,    // Default context (from traversal value)\n}\n\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MathFunctionCallGen_27": {
      "name": "MathFunctionCallGen",
      "type": "struct",
      "start_line": 27,
      "end_line": 32,
      "content_hash": "82b2b8a6f3c4bd4894b9bfdb8130cc82b6b79ff9",
      "content": "pub struct MathFunctionCallGen {\n    pub function: MathFunction,\n    pub args: Vec<MathExpr>,\n}\n\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_NumericLiteral_33": {
      "name": "NumericLiteral",
      "type": "struct",
      "start_line": 33,
      "end_line": 37,
      "content_hash": "c3db7dbc40fc46b424ab369a792b129cd13c36af",
      "content": "pub struct NumericLiteral {\n    pub value: f64,\n}\n\n#[derive(Debug, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PropertyAccess_38": {
      "name": "PropertyAccess",
      "type": "struct",
      "start_line": 38,
      "end_line": 42,
      "content_hash": "b391cb7ded05bec9395617a354d61f407633b21c",
      "content": "pub struct PropertyAccess {\n    pub context: PropertyContext,\n    pub property: GenRef<String>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_43": {
      "name": "Display",
      "type": "impl",
      "start_line": 43,
      "end_line": 43,
      "content_hash": "3bb10ab4c6e0b2aa1be1a60981d347cc3047105f",
      "content": "impl Display for MathExpr {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_44": {
      "name": "fmt",
      "type": "method",
      "start_line": 44,
      "end_line": 53,
      "content_hash": "216332a1ac0621a0ee427fff05b41397d95a9bfc",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            MathExpr::FunctionCall(call) => write!(f, \"{}\", call),\n            MathExpr::NumericLiteral(n) => write!(f, \"{}\", n),\n            MathExpr::PropertyAccess(prop) => write!(f, \"{}\", prop),\n            MathExpr::Identifier(id) => write!(f, \"{}\", id),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_54": {
      "name": "Display",
      "type": "impl",
      "start_line": 54,
      "end_line": 54,
      "content_hash": "3ab4b9722446baa443c873a313b5d1d246b8894f",
      "content": "impl Display for NumericLiteral {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_55": {
      "name": "fmt",
      "type": "method",
      "start_line": 55,
      "end_line": 64,
      "content_hash": "84c499cd42d8f4e5691f483471a3dcbba56b3785",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Handle special formatting for cleaner output\n        if self.value.fract() == 0.0 && self.value.abs() < i64::MAX as f64 {\n            write!(f, \"{}_f64\", self.value as i64)\n        } else {\n            write!(f, \"{}_f64\", self.value)\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_65": {
      "name": "Display",
      "type": "impl",
      "start_line": 65,
      "end_line": 65,
      "content_hash": "10efb6bda291c44ede60b6d094be849c4be6c42f",
      "content": "impl Display for PropertyAccess {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_66": {
      "name": "fmt",
      "type": "method",
      "start_line": 66,
      "end_line": 83,
      "content_hash": "4507ec1fafdc14bd82d6b4758de4b7ef5f9da281",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.context {\n            PropertyContext::Edge => {\n                write!(f, \"(edge.get_property({}).ok_or(GraphError::Default)?.as_f64())\", self.property)\n            }\n            PropertyContext::SourceNode => {\n                write!(f, \"(src_node.get_property({}).ok_or(GraphError::Default)?.as_f64())\", self.property)\n            }\n            PropertyContext::TargetNode => {\n                write!(f, \"(dst_node.get_property({}).ok_or(GraphError::Default)?.as_f64())\", self.property)\n            }\n            PropertyContext::Current => {\n                write!(f, \"(v.get_property({}).ok_or(GraphError::Default)?.as_f64())\", self.property)\n            }\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_84": {
      "name": "Display",
      "type": "impl",
      "start_line": 84,
      "end_line": 84,
      "content_hash": "a36350e66bcd721abbae97a9a6bb179d98c5d579",
      "content": "impl Display for MathFunctionCallGen {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_85": {
      "name": "fmt",
      "type": "method",
      "start_line": 85,
      "end_line": 247,
      "content_hash": "5718fe86b49f3297a09e4815751ef210fb7f76f4",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.function {\n            // Binary operators\n            MathFunction::Add => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({} + {})\", self.args[0], self.args[1])\n            }\n            MathFunction::Sub => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({} - {})\", self.args[0], self.args[1])\n            }\n            MathFunction::Mul => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({} * {})\", self.args[0], self.args[1])\n            }\n            MathFunction::Div => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({} / {})\", self.args[0], self.args[1])\n            }\n            MathFunction::Pow => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).powf({})\", self.args[0], self.args[1])\n            }\n            MathFunction::Mod => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}) % ({})\", self.args[0], self.args[1])\n            }\n\n            // Unary functions\n            MathFunction::Abs => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).abs()\", self.args[0])\n            }\n            MathFunction::Sqrt => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).sqrt()\", self.args[0])\n            }\n            MathFunction::Ln => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).ln()\", self.args[0])\n            }\n            MathFunction::Log10 => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).log10()\", self.args[0])\n            }\n            MathFunction::Log => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).log({})\", self.args[0], self.args[1])\n            }\n            MathFunction::Exp => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).exp()\", self.args[0])\n            }\n            MathFunction::Ceil => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).ceil()\", self.args[0])\n            }\n            MathFunction::Floor => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).floor()\", self.args[0])\n            }\n            MathFunction::Round => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).round()\", self.args[0])\n            }\n\n            // Trigonometry\n            MathFunction::Sin => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).sin()\", self.args[0])\n            }\n            MathFunction::Cos => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).cos()\", self.args[0])\n            }\n            MathFunction::Tan => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).tan()\", self.args[0])\n            }\n            MathFunction::Asin => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).asin()\", self.args[0])\n            }\n            MathFunction::Acos => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).acos()\", self.args[0])\n            }\n            MathFunction::Atan => {\n                if self.args.len() != 1 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).atan()\", self.args[0])\n            }\n            MathFunction::Atan2 => {\n                if self.args.len() != 2 {\n                    return Err(fmt::Error);\n                }\n                write!(f, \"({}).atan2({})\", self.args[0], self.args[1])\n            }\n\n            // Constants (nullary)\n            MathFunction::Pi => write!(f, \"std::f64::consts::PI\"),\n            MathFunction::E => write!(f, \"std::f64::consts::E\"),\n\n            // Aggregates (special handling needed)\n            MathFunction::Min\n            | MathFunction::Max\n            | MathFunction::Sum\n            | MathFunction::Avg\n            | MathFunction::Count => {\n                // For now, these will need special implementation in the context they're used\n                write!(\n                    f,\n                    \"/* Aggregate function {} not yet implemented */\",\n                    self.function.name()\n                )\n            }\n        }\n    }\n}\n\n/// Expression context for code generation\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ExpressionContext_248": {
      "name": "ExpressionContext",
      "type": "enum",
      "start_line": 248,
      "end_line": 254,
      "content_hash": "0966f21d60534e6587af2ada8da7b24799047a51",
      "content": "pub enum ExpressionContext {\n    WeightCalculation, // Has access to edge, src_node, dst_node\n    Filter,            // Has access to current traversal value\n    General,           // Standard expression context\n}\n\n/// Convert AST expression to generated math expression",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_math_expr_255": {
      "name": "generate_math_expr",
      "type": "method",
      "start_line": 255,
      "end_line": 291,
      "content_hash": "117a333cd734a63ec384873b819e1a3f05ed5aca",
      "content": "pub fn generate_math_expr(\n    expr: &Expression,\n    context: ExpressionContext,\n) -> Result<MathExpr, String> {\n    match &expr.expr {\n        ExpressionType::MathFunctionCall(call) => {\n            let args = call\n                .args\n                .iter()\n                .map(|arg| generate_math_expr(arg, context))\n                .collect::<Result<Vec<_>, _>>()?;\n\n            Ok(MathExpr::FunctionCall(MathFunctionCallGen {\n                function: call.function.clone(),\n                args,\n            }))\n        }\n        ExpressionType::IntegerLiteral(i) => Ok(MathExpr::NumericLiteral(NumericLiteral {\n            value: *i as f64,\n        })),\n        ExpressionType::FloatLiteral(f) => {\n            Ok(MathExpr::NumericLiteral(NumericLiteral { value: *f }))\n        }\n        ExpressionType::Identifier(id) => Ok(MathExpr::Identifier(id.clone())),\n        ExpressionType::Traversal(traversal) => {\n            // Parse property access from traversal\n            // This is where we'd handle _::{prop}, _::From::{prop}, _::To::{prop}\n            parse_property_access_from_traversal(traversal, context)\n        }\n        _ => Err(format!(\n            \"Unsupported expression type in math expression: {:?}\",\n            expr.expr\n        )),\n    }\n}\n\n/// Parse property access from traversal to determine context",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parse_property_access_from_traversal_292": {
      "name": "parse_property_access_from_traversal",
      "type": "method",
      "start_line": 292,
      "end_line": 347,
      "content_hash": "293467400a97932c7b75e91f520a77c00aecb5fa",
      "content": "fn parse_property_access_from_traversal(\n    traversal: &crate::helixc::parser::types::Traversal,\n    context: ExpressionContext,\n) -> Result<MathExpr, String> {\n    use crate::helixc::parser::types::{GraphStepType, StartNode, StepType};\n\n    // Check if this is an anonymous traversal (_::...)\n    if !matches!(traversal.start, StartNode::Anonymous) {\n        return Err(\"Expected anonymous traversal starting with _::\".to_string());\n    }\n\n    // Determine property context based on traversal steps\n    let (prop_context, property_step_idx) = if traversal.steps.len() == 1 {\n        // Simple case: _::{property}\n        (PropertyContext::Edge, 0)\n    } else if traversal.steps.len() == 2 {\n        // Check if first step is FromN or ToN\n        match &traversal.steps[0].step {\n            StepType::Node(graph_step) => {\n                match &graph_step.step {\n                    GraphStepType::FromN => (PropertyContext::SourceNode, 1),\n                    GraphStepType::ToN => (PropertyContext::TargetNode, 1),\n                    _ => return Err(format!(\"Unexpected node step type in property access: {:?}\", graph_step.step)),\n                }\n            }\n            _ => return Err(format!(\"Expected FromN or ToN step, got: {:?}\", traversal.steps[0].step)),\n        }\n    } else {\n        return Err(format!(\"Invalid traversal length for property access: {}\", traversal.steps.len()));\n    };\n\n    // Extract property name from the Object step\n    if let StepType::Object(obj) = &traversal.steps[property_step_idx].step\n        && obj.fields.len() == 1 && !obj.should_spread {\n        let property_name = obj.fields[0].key.clone();\n\n        // Override context if specified by ExpressionContext\n        let final_context = match context {\n            ExpressionContext::WeightCalculation => prop_context,\n            ExpressionContext::Filter | ExpressionContext::General => PropertyContext::Current,\n        };\n\n        return Ok(MathExpr::PropertyAccess(PropertyAccess {\n            context: final_context,\n            property: GenRef::Literal(property_name),\n        }));\n    }\n\n    Err(\"Failed to extract property name from traversal\".to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_numeric_literal_integer_348": {
      "name": "test_numeric_literal_integer",
      "type": "method",
      "start_line": 348,
      "end_line": 353,
      "content_hash": "aa8b67d589e3d9c12d1f7c94704a170676e639c8",
      "content": "    fn test_numeric_literal_integer() {\n        let lit = NumericLiteral { value: 5.0 };\n        assert_eq!(lit.to_string(), \"5_f64\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_numeric_literal_float_354": {
      "name": "test_numeric_literal_float",
      "type": "method",
      "start_line": 354,
      "end_line": 359,
      "content_hash": "b310736331330550dc930d94df64e1db785d1cc0",
      "content": "    fn test_numeric_literal_float() {\n        let lit = NumericLiteral { value: 3.14 };\n        assert_eq!(lit.to_string(), \"3.14_f64\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_add_function_360": {
      "name": "test_add_function",
      "type": "method",
      "start_line": 360,
      "end_line": 371,
      "content_hash": "d102cfa42802f5f1d3828011d20b99fd165231aa",
      "content": "    fn test_add_function() {\n        let add = MathFunctionCallGen {\n            function: MathFunction::Add,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 5.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 3.0 }),\n            ],\n        };\n        assert_eq!(add.to_string(), \"(5_f64 + 3_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_pow_function_372": {
      "name": "test_pow_function",
      "type": "method",
      "start_line": 372,
      "end_line": 383,
      "content_hash": "dc7fe5a8bd1bcb3c06573b0efa2ae87fc9ee1acd",
      "content": "    fn test_pow_function() {\n        let pow = MathFunctionCallGen {\n            function: MathFunction::Pow,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 0.95 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 30.0 }),\n            ],\n        };\n        assert_eq!(pow.to_string(), \"(0.95_f64).powf(30_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_nested_functions_384": {
      "name": "test_nested_functions",
      "type": "method",
      "start_line": 384,
      "end_line": 401,
      "content_hash": "c6b962ad7983780dc75f6cc9ac2baf79f8fc2274",
      "content": "    fn test_nested_functions() {\n        let nested = MathFunctionCallGen {\n            function: MathFunction::Pow,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 0.95 }),\n                MathExpr::FunctionCall(MathFunctionCallGen {\n                    function: MathFunction::Div,\n                    args: vec![\n                        MathExpr::NumericLiteral(NumericLiteral { value: 10.0 }),\n                        MathExpr::NumericLiteral(NumericLiteral { value: 30.0 }),\n                    ],\n                }),\n            ],\n        };\n        assert_eq!(nested.to_string(), \"(0.95_f64).powf((10_f64 / 30_f64))\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_sqrt_function_402": {
      "name": "test_sqrt_function",
      "type": "method",
      "start_line": 402,
      "end_line": 410,
      "content_hash": "8b2fc6b73d1623e2d6ce858596470edc20e6e0b3",
      "content": "    fn test_sqrt_function() {\n        let sqrt = MathFunctionCallGen {\n            function: MathFunction::Sqrt,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 16.0 })],\n        };\n        assert_eq!(sqrt.to_string(), \"(16_f64).sqrt()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_trig_functions_411": {
      "name": "test_trig_functions",
      "type": "method",
      "start_line": 411,
      "end_line": 419,
      "content_hash": "ec07bea276f57b7cc63e4bafd3db8c93c2a7b4a1",
      "content": "    fn test_trig_functions() {\n        let sin = MathFunctionCallGen {\n            function: MathFunction::Sin,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 1.57 })],\n        };\n        assert_eq!(sin.to_string(), \"(1.57_f64).sin()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_constants_420": {
      "name": "test_constants",
      "type": "method",
      "start_line": 420,
      "end_line": 434,
      "content_hash": "687f2c6a0ad527ba4c109f03b97ade65bbad42a9",
      "content": "    fn test_constants() {\n        let pi = MathFunctionCallGen {\n            function: MathFunction::Pi,\n            args: vec![],\n        };\n        assert_eq!(pi.to_string(), \"std::f64::consts::PI\");\n\n        let e = MathFunctionCallGen {\n            function: MathFunction::E,\n            args: vec![],\n        };\n        assert_eq!(e.to_string(), \"std::f64::consts::E\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_property_access_contexts_435": {
      "name": "test_property_access_contexts",
      "type": "method",
      "start_line": 435,
      "end_line": 467,
      "content_hash": "fefb3527d21cd628b7d9f8a17e59ed40c4ca4055",
      "content": "    fn test_property_access_contexts() {\n        // Test Edge context\n        let edge_prop = PropertyAccess {\n            context: PropertyContext::Edge,\n            property: GenRef::Literal(\"distance\".to_string()),\n        };\n        assert_eq!(\n            edge_prop.to_string(),\n            \"(edge.get_property(\\\"distance\\\").ok_or(GraphError::Default)?.as_f64())\"\n        );\n\n        // Test SourceNode context\n        let src_prop = PropertyAccess {\n            context: PropertyContext::SourceNode,\n            property: GenRef::Literal(\"traffic_factor\".to_string()),\n        };\n        assert_eq!(\n            src_prop.to_string(),\n            \"(src_node.get_property(\\\"traffic_factor\\\").ok_or(GraphError::Default)?.as_f64())\"\n        );\n\n        // Test TargetNode context\n        let dst_prop = PropertyAccess {\n            context: PropertyContext::TargetNode,\n            property: GenRef::Literal(\"popularity\".to_string()),\n        };\n        assert_eq!(\n            dst_prop.to_string(),\n            \"(dst_node.get_property(\\\"popularity\\\").ok_or(GraphError::Default)?.as_f64())\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_complex_weight_expression_468": {
      "name": "test_complex_weight_expression",
      "type": "method",
      "start_line": 468,
      "end_line": 503,
      "content_hash": "b732fdfed31d72f504590412d5c116125657e897",
      "content": "    fn test_complex_weight_expression() {\n        // Test: MUL(_::{distance}, POW(0.95, DIV(_::{days}, 30)))\n        // Should generate: ((edge.get_property(\"distance\").ok_or(GraphError::Default)?.as_f64()) * (0.95_f64).powf(((edge.get_property(\"days\").ok_or(GraphError::Default)?.as_f64()) / 30_f64)))\n        let expr = MathFunctionCallGen {\n            function: MathFunction::Mul,\n            args: vec![\n                MathExpr::PropertyAccess(PropertyAccess {\n                    context: PropertyContext::Edge,\n                    property: GenRef::Literal(\"distance\".to_string()),\n                }),\n                MathExpr::FunctionCall(MathFunctionCallGen {\n                    function: MathFunction::Pow,\n                    args: vec![\n                        MathExpr::NumericLiteral(NumericLiteral { value: 0.95 }),\n                        MathExpr::FunctionCall(MathFunctionCallGen {\n                            function: MathFunction::Div,\n                            args: vec![\n                                MathExpr::PropertyAccess(PropertyAccess {\n                                    context: PropertyContext::Edge,\n                                    property: GenRef::Literal(\"days\".to_string()),\n                                }),\n                                MathExpr::NumericLiteral(NumericLiteral { value: 30.0 }),\n                            ],\n                        }),\n                    ],\n                }),\n            ],\n        };\n\n        assert_eq!(\n            expr.to_string(),\n            \"((edge.get_property(\\\"distance\\\").ok_or(GraphError::Default)?.as_f64()) * (0.95_f64).powf(((edge.get_property(\\\"days\\\").ok_or(GraphError::Default)?.as_f64()) / 30_f64)))\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_multi_context_expression_504": {
      "name": "test_multi_context_expression",
      "type": "method",
      "start_line": 504,
      "end_line": 531,
      "content_hash": "6513425363fd8c80785f444859152d69a58044a7",
      "content": "    fn test_multi_context_expression() {\n        // Test: MUL(_::{distance}, _::From::{traffic_factor})\n        // Should generate: ((edge.get_property(\"distance\").ok_or(GraphError::Default)?.as_f64()) * (src_node.get_property(\"traffic_factor\").ok_or(GraphError::Default)?.as_f64()))\n        let expr = MathFunctionCallGen {\n            function: MathFunction::Mul,\n            args: vec![\n                MathExpr::PropertyAccess(PropertyAccess {\n                    context: PropertyContext::Edge,\n                    property: GenRef::Literal(\"distance\".to_string()),\n                }),\n                MathExpr::PropertyAccess(PropertyAccess {\n                    context: PropertyContext::SourceNode,\n                    property: GenRef::Literal(\"traffic_factor\".to_string()),\n                }),\n            ],\n        };\n\n        assert_eq!(\n            expr.to_string(),\n            \"((edge.get_property(\\\"distance\\\").ok_or(GraphError::Default)?.as_f64()) * (src_node.get_property(\\\"traffic_factor\\\").ok_or(GraphError::Default)?.as_f64()))\"\n        );\n    }\n\n    // ============================================================================\n    // Additional Math Function Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_mod_function_532": {
      "name": "test_mod_function",
      "type": "method",
      "start_line": 532,
      "end_line": 543,
      "content_hash": "714574410323755a7aa6973209463f6cac4344f3",
      "content": "    fn test_mod_function() {\n        let modulo = MathFunctionCallGen {\n            function: MathFunction::Mod,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 17.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 5.0 }),\n            ],\n        };\n        assert_eq!(modulo.to_string(), \"(17_f64) % (5_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_abs_function_544": {
      "name": "test_abs_function",
      "type": "method",
      "start_line": 544,
      "end_line": 552,
      "content_hash": "a0332d9a1e8a8b84d86332dd76899ca169d8f7b6",
      "content": "    fn test_abs_function() {\n        let abs = MathFunctionCallGen {\n            function: MathFunction::Abs,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: -5.5 })],\n        };\n        assert_eq!(abs.to_string(), \"(-5.5_f64).abs()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_ln_function_553": {
      "name": "test_ln_function",
      "type": "method",
      "start_line": 553,
      "end_line": 561,
      "content_hash": "5407487f8ee301f0943dcb48d00b4fc53d5f2ce5",
      "content": "    fn test_ln_function() {\n        let ln = MathFunctionCallGen {\n            function: MathFunction::Ln,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 2.71828 })],\n        };\n        assert_eq!(ln.to_string(), \"(2.71828_f64).ln()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_log10_function_562": {
      "name": "test_log10_function",
      "type": "method",
      "start_line": 562,
      "end_line": 570,
      "content_hash": "4b324ba03b170a5d5ca128e23213c505f3c67f62",
      "content": "    fn test_log10_function() {\n        let log10 = MathFunctionCallGen {\n            function: MathFunction::Log10,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 100.0 })],\n        };\n        assert_eq!(log10.to_string(), \"(100_f64).log10()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_log_function_571": {
      "name": "test_log_function",
      "type": "method",
      "start_line": 571,
      "end_line": 582,
      "content_hash": "ab86c142c2ec7d756137d02e90a33dbf08ec951e",
      "content": "    fn test_log_function() {\n        let log = MathFunctionCallGen {\n            function: MathFunction::Log,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 8.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 2.0 }),\n            ],\n        };\n        assert_eq!(log.to_string(), \"(8_f64).log(2_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_exp_function_583": {
      "name": "test_exp_function",
      "type": "method",
      "start_line": 583,
      "end_line": 591,
      "content_hash": "d51384124e809fdb781072614f1ff2bd1cb54219",
      "content": "    fn test_exp_function() {\n        let exp = MathFunctionCallGen {\n            function: MathFunction::Exp,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 1.0 })],\n        };\n        assert_eq!(exp.to_string(), \"(1_f64).exp()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_ceil_function_592": {
      "name": "test_ceil_function",
      "type": "method",
      "start_line": 592,
      "end_line": 600,
      "content_hash": "3f3485f5defc1a315e2e5018b8cc71958a89f65e",
      "content": "    fn test_ceil_function() {\n        let ceil = MathFunctionCallGen {\n            function: MathFunction::Ceil,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 4.3 })],\n        };\n        assert_eq!(ceil.to_string(), \"(4.3_f64).ceil()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_floor_function_601": {
      "name": "test_floor_function",
      "type": "method",
      "start_line": 601,
      "end_line": 609,
      "content_hash": "ce9bb3ea067e9d127fa7935ffa3e0dfa0fe88b70",
      "content": "    fn test_floor_function() {\n        let floor = MathFunctionCallGen {\n            function: MathFunction::Floor,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 4.9 })],\n        };\n        assert_eq!(floor.to_string(), \"(4.9_f64).floor()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_round_function_610": {
      "name": "test_round_function",
      "type": "method",
      "start_line": 610,
      "end_line": 618,
      "content_hash": "803833076e95c86b3849a2ef2221e959258ff148",
      "content": "    fn test_round_function() {\n        let round = MathFunctionCallGen {\n            function: MathFunction::Round,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 4.5 })],\n        };\n        assert_eq!(round.to_string(), \"(4.5_f64).round()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_asin_function_619": {
      "name": "test_asin_function",
      "type": "method",
      "start_line": 619,
      "end_line": 627,
      "content_hash": "e119d94e881775afca7c641d9e75a47cb2ad01e1",
      "content": "    fn test_asin_function() {\n        let asin = MathFunctionCallGen {\n            function: MathFunction::Asin,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 0.5 })],\n        };\n        assert_eq!(asin.to_string(), \"(0.5_f64).asin()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_acos_function_628": {
      "name": "test_acos_function",
      "type": "method",
      "start_line": 628,
      "end_line": 636,
      "content_hash": "81f3e42c6f66e6555bc96b9243713f43c7472c0c",
      "content": "    fn test_acos_function() {\n        let acos = MathFunctionCallGen {\n            function: MathFunction::Acos,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 0.5 })],\n        };\n        assert_eq!(acos.to_string(), \"(0.5_f64).acos()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_atan_function_637": {
      "name": "test_atan_function",
      "type": "method",
      "start_line": 637,
      "end_line": 645,
      "content_hash": "3a7857391310a52e61ff29dad8c1db4ae8276f2d",
      "content": "    fn test_atan_function() {\n        let atan = MathFunctionCallGen {\n            function: MathFunction::Atan,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 1.0 })],\n        };\n        assert_eq!(atan.to_string(), \"(1_f64).atan()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_atan2_function_646": {
      "name": "test_atan2_function",
      "type": "method",
      "start_line": 646,
      "end_line": 657,
      "content_hash": "730993ef83b35de0183cd7e32d597d174f270b12",
      "content": "    fn test_atan2_function() {\n        let atan2 = MathFunctionCallGen {\n            function: MathFunction::Atan2,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 1.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 1.0 }),\n            ],\n        };\n        assert_eq!(atan2.to_string(), \"(1_f64).atan2(1_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_sub_function_658": {
      "name": "test_sub_function",
      "type": "method",
      "start_line": 658,
      "end_line": 669,
      "content_hash": "b8a7d93c39a5dd3f9a67349c42024bccd8c049b8",
      "content": "    fn test_sub_function() {\n        let sub = MathFunctionCallGen {\n            function: MathFunction::Sub,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 10.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 3.0 }),\n            ],\n        };\n        assert_eq!(sub.to_string(), \"(10_f64 - 3_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_div_function_670": {
      "name": "test_div_function",
      "type": "method",
      "start_line": 670,
      "end_line": 681,
      "content_hash": "a8e3ed5d3c38836bc97069fba7ffb6d7f29f28fa",
      "content": "    fn test_div_function() {\n        let div = MathFunctionCallGen {\n            function: MathFunction::Div,\n            args: vec![\n                MathExpr::NumericLiteral(NumericLiteral { value: 20.0 }),\n                MathExpr::NumericLiteral(NumericLiteral { value: 4.0 }),\n            ],\n        };\n        assert_eq!(div.to_string(), \"(20_f64 / 4_f64)\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_cos_function_682": {
      "name": "test_cos_function",
      "type": "method",
      "start_line": 682,
      "end_line": 690,
      "content_hash": "dcb6bf92d8edc94540a8d5780d76f411dffc7d95",
      "content": "    fn test_cos_function() {\n        let cos = MathFunctionCallGen {\n            function: MathFunction::Cos,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 0.0 })],\n        };\n        assert_eq!(cos.to_string(), \"(0_f64).cos()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_tan_function_691": {
      "name": "test_tan_function",
      "type": "method",
      "start_line": 691,
      "end_line": 699,
      "content_hash": "4b47544759918622c435a2030521d883aac0c9d2",
      "content": "    fn test_tan_function() {\n        let tan = MathFunctionCallGen {\n            function: MathFunction::Tan,\n            args: vec![MathExpr::NumericLiteral(NumericLiteral { value: 0.785 })],\n        };\n        assert_eq!(tan.to_string(), \"(0.785_f64).tan()\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_current_context_property_access_700": {
      "name": "test_current_context_property_access",
      "type": "method",
      "start_line": 700,
      "end_line": 711,
      "content_hash": "edf46c911b8ed71ccf2fbb410cc20253e6f5058b",
      "content": "    fn test_current_context_property_access() {\n        let current_prop = PropertyAccess {\n            context: PropertyContext::Current,\n            property: GenRef::Literal(\"score\".to_string()),\n        };\n        assert_eq!(\n            current_prop.to_string(),\n            \"(v.get_property(\\\"score\\\").ok_or(GraphError::Default)?.as_f64())\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_math_expr_identifier_712": {
      "name": "test_math_expr_identifier",
      "type": "method",
      "start_line": 712,
      "end_line": 716,
      "content_hash": "109c229a96c85efc1794df2eca80d15ded3caa47",
      "content": "    fn test_math_expr_identifier() {\n        let expr = MathExpr::Identifier(\"custom_var\".to_string());\n        assert_eq!(expr.to_string(), \"custom_var\");\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}