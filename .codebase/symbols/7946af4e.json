{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/format.rs",
  "file_hash": "386c0cbe2e2f1a3318e274cb57bf84ddaca6effd",
  "updated_at": "2025-12-26T17:34:21.277952",
  "symbols": {
    "enum_Format_15": {
      "name": "Format",
      "type": "enum",
      "start_line": 15,
      "end_line": 22,
      "content_hash": "0a433040ea97f51b2e48f00434af659610ef2ac8",
      "content": "pub enum Format {\n    /// JSON (JavaScript Object Notation)\n    /// The current implementation uses sonic_rs\n    #[default]\n    Json,\n}\n\n/// Methods using to format for serialization/deserialization",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Format_23": {
      "name": "Format",
      "type": "impl",
      "start_line": 23,
      "end_line": 83,
      "content_hash": "442d12d7b730f633e7bd339fa02f32987068b1a6",
      "content": "impl Format {\n    /// Serialize the value to bytes.\n    /// If using a zero-copy format it will return a Cow::Borrowed, with a lifetime corresponding to the value.\n    /// Otherwise, it returns a Cow::Owned.\n    ///\n    /// # Panics\n    /// This method will panic if serialization fails. Ensure that the value being serialized\n    /// is compatible with the chosen format to avoid panics.\n    pub fn serialize<T: Serialize>(self, val: &T) -> Cow<'_, [u8]> {\n        match self {\n            Format::Json => sonic_rs::to_vec(val).unwrap().into(),\n        }\n    }\n\n    /// Serialize the value to the supplied async writer.\n    /// This will use an underlying async implementation if possible, otherwise it will buffer it\n    pub async fn serialize_to_async<T: Serialize>(\n        self,\n        val: &T,\n        writer: &mut BufWriter<impl AsyncWrite + Unpin>,\n    ) -> Result<(), Box<dyn Error>> {\n        match self {\n            Format::Json => {\n                let encoded = sonic_rs::to_vec(val)?;\n                writer.write_all(&encoded).await?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn create_response<T: Serialize>(self, val: &T) -> Response {\n        Response {\n            body: self.serialize(val).to_vec(),\n            fmt: self,\n        }\n    }\n\n    /// Deserialize the provided value\n    /// Returns a MaybeOwned::Borrowed if using a zero-copy format\n    /// or a MaybeOwned::Owned otherwise\n    pub fn deserialize<'a, T: Deserialize<'a>>(\n        self,\n        val: &'a [u8],\n    ) -> Result<MaybeOwned<'a, T>, GraphError> {\n        match self {\n            Format::Json => Ok(MaybeOwned::Owned(\n                sonic_rs::from_slice::<T>(val)\n                    .map_err(|e| GraphError::DecodeError(e.to_string()))?,\n            )),\n        }\n    }\n\n    /// Deserialize the provided value\n    pub fn deserialize_owned<'a, T: Deserialize<'a>>(self, val: &'a [u8]) -> Result<T, GraphError> {\n        match self {\n            Format::Json => Ok(sonic_rs::from_slice::<T>(val)\n                .map_err(|e| GraphError::DecodeError(e.to_string()))?),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FromStr_84": {
      "name": "FromStr",
      "type": "impl",
      "start_line": 84,
      "end_line": 86,
      "content_hash": "5a797b0809fcf46806e3f023117694c62c1f34b4",
      "content": "impl FromStr for Format {\n    type Err = ();\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_str_87": {
      "name": "from_str",
      "type": "method",
      "start_line": 87,
      "end_line": 94,
      "content_hash": "c3c5ad02d2a55801541a873a2ed228a901385284",
      "content": "    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"application/json\" => Ok(Format::Json),\n            _ => Err(()),\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_95": {
      "name": "Display",
      "type": "impl",
      "start_line": 95,
      "end_line": 95,
      "content_hash": "aa2f17146850698bac3b303e5c85af2c3e3fec63",
      "content": "impl Display for Format {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_96": {
      "name": "fmt",
      "type": "method",
      "start_line": 96,
      "end_line": 104,
      "content_hash": "0f7f06e86098e569d80454359abd0a3c4bceac62",
      "content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Format::Json => write!(f, \"application/json\"),\n        }\n    }\n}\n\n/// A wrapper for a value which might be owned or borrowed\n/// The key difference from Cow, is that this doesn't require the value to implement Clone",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_MaybeOwned_105": {
      "name": "MaybeOwned",
      "type": "enum",
      "start_line": 105,
      "end_line": 109,
      "content_hash": "dfc757362798141030d730ad57b30e67e7e833bb",
      "content": "pub enum MaybeOwned<'a, T> {\n    Owned(T),\n    Borrowed(&'a T),\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deref_110": {
      "name": "Deref",
      "type": "impl",
      "start_line": 110,
      "end_line": 112,
      "content_hash": "905aea4c1cd75bc9d7fa21e84777240ffd21abc5",
      "content": "impl<'a, T> Deref for MaybeOwned<'a, T> {\n    type Target = T;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_deref_113": {
      "name": "deref",
      "type": "method",
      "start_line": 113,
      "end_line": 120,
      "content_hash": "4337328edd921e74dd8e4f2bd65cce33715644cd",
      "content": "    fn deref(&self) -> &Self::Target {\n        match self {\n            MaybeOwned::Owned(v) => v,\n            MaybeOwned::Borrowed(v) => v,\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_MaybeOwned_121": {
      "name": "MaybeOwned",
      "type": "impl",
      "start_line": 121,
      "end_line": 121,
      "content_hash": "c130bc2cde121956055d1a93ca6f6ba2ed3667d5",
      "content": "impl<'a, T: Clone> MaybeOwned<'a, T> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_owned_122": {
      "name": "into_owned",
      "type": "method",
      "start_line": 122,
      "end_line": 135,
      "content_hash": "ed9bb32b3614e1cd00871792d31a8355c2f02f06",
      "content": "    pub fn into_owned(self) -> T {\n        match self {\n            MaybeOwned::Owned(v) => v,\n            MaybeOwned::Borrowed(v) => v.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TestData_136": {
      "name": "TestData",
      "type": "struct",
      "start_line": 136,
      "end_line": 145,
      "content_hash": "fad45a1770dee97b77395cb6a6df111f66aa4992",
      "content": "    struct TestData {\n        name: String,\n        value: i32,\n    }\n\n    // ============================================================================\n    // Format::serialize and deserialize tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_json_146": {
      "name": "test_format_serialize_json",
      "type": "method",
      "start_line": 146,
      "end_line": 161,
      "content_hash": "a4426bc577123ef8dccd5ec8a8acbbc9fc8271b9",
      "content": "    fn test_format_serialize_json() {\n        let data = TestData {\n            name: \"test\".to_string(),\n            value: 42,\n        };\n\n        let bytes = Format::Json.serialize(&data);\n        assert!(!bytes.is_empty());\n\n        // Verify it's valid JSON\n        let json_str = std::str::from_utf8(&bytes).unwrap();\n        assert!(json_str.contains(\"test\"));\n        assert!(json_str.contains(\"42\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_deserialize_json_162": {
      "name": "test_format_deserialize_json",
      "type": "method",
      "start_line": 162,
      "end_line": 174,
      "content_hash": "4c0ac94d1d2bc184a2e4445a423bbea85fd4e2a0",
      "content": "    fn test_format_deserialize_json() {\n        let json = r#\"{\"name\":\"test\",\"value\":42}\"#;\n        let bytes = json.as_bytes();\n\n        let result: Result<MaybeOwned<TestData>, GraphError> = Format::Json.deserialize(bytes);\n        assert!(result.is_ok());\n\n        let data = result.unwrap();\n        assert_eq!(data.name, \"test\");\n        assert_eq!(data.value, 42);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_deserialize_roundtrip_175": {
      "name": "test_format_serialize_deserialize_roundtrip",
      "type": "method",
      "start_line": 175,
      "end_line": 187,
      "content_hash": "3be6bdf1653064766e24172a54540b1f4ae0e3a5",
      "content": "    fn test_format_serialize_deserialize_roundtrip() {\n        let original = TestData {\n            name: \"roundtrip\".to_string(),\n            value: 123,\n        };\n\n        let bytes = Format::Json.serialize(&original);\n        let result: MaybeOwned<TestData> = Format::Json.deserialize(&bytes).unwrap();\n\n        assert_eq!(*result, original);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_deserialize_owned_188": {
      "name": "test_format_deserialize_owned",
      "type": "method",
      "start_line": 188,
      "end_line": 200,
      "content_hash": "e4e111ea612386e857bed0ca1ec50a6a1deeb86d",
      "content": "    fn test_format_deserialize_owned() {\n        let json = r#\"{\"name\":\"owned\",\"value\":99}\"#;\n        let bytes = json.as_bytes();\n\n        let result: Result<TestData, GraphError> = Format::Json.deserialize_owned(bytes);\n        assert!(result.is_ok());\n\n        let data = result.unwrap();\n        assert_eq!(data.name, \"owned\");\n        assert_eq!(data.value, 99);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_deserialize_invalid_json_201": {
      "name": "test_format_deserialize_invalid_json",
      "type": "method",
      "start_line": 201,
      "end_line": 214,
      "content_hash": "861514933ee4042cb98c6e20b1fa3af0992bd9ab",
      "content": "    fn test_format_deserialize_invalid_json() {\n        let invalid_json = b\"not valid json {\";\n\n        let result: Result<MaybeOwned<TestData>, GraphError> = Format::Json.deserialize(invalid_json);\n        assert!(result.is_err());\n\n        if let Err(GraphError::DecodeError(msg)) = result {\n            assert!(!msg.is_empty());\n        } else {\n            panic!(\"Expected DecodeError\");\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_deserialize_owned_invalid_json_215": {
      "name": "test_format_deserialize_owned_invalid_json",
      "type": "method",
      "start_line": 215,
      "end_line": 222,
      "content_hash": "bc5492b5528212cee97cc93e35a18d123608f543",
      "content": "    fn test_format_deserialize_owned_invalid_json() {\n        let invalid_json = b\"{ invalid }\";\n\n        let result: Result<TestData, GraphError> = Format::Json.deserialize_owned(invalid_json);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_create_response_223": {
      "name": "test_format_create_response",
      "type": "method",
      "start_line": 223,
      "end_line": 243,
      "content_hash": "f1b83873d168f384d6edd8a827a4f349c5e1f133",
      "content": "    fn test_format_create_response() {\n        let data = TestData {\n            name: \"response\".to_string(),\n            value: 77,\n        };\n\n        let response = Format::Json.create_response(&data);\n\n        assert!(!response.body.is_empty());\n        assert!(matches!(response.fmt, Format::Json));\n\n        // Verify we can deserialize the response body\n        let decoded: TestData = Format::Json.deserialize_owned(&response.body).unwrap();\n        assert_eq!(decoded, data);\n    }\n\n    // ============================================================================\n    // Format::FromStr and Display tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_from_str_json_244": {
      "name": "test_format_from_str_json",
      "type": "method",
      "start_line": 244,
      "end_line": 250,
      "content_hash": "76666251e3c8de329e9debaa78b9baffb30e6f64",
      "content": "    fn test_format_from_str_json() {\n        let result = \"application/json\".parse::<Format>();\n        assert!(result.is_ok());\n        assert!(matches!(result.unwrap(), Format::Json));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_from_str_invalid_251": {
      "name": "test_format_from_str_invalid",
      "type": "method",
      "start_line": 251,
      "end_line": 262,
      "content_hash": "aa6e513df6a726e30230ba394919702e68d9d7f4",
      "content": "    fn test_format_from_str_invalid() {\n        let result = \"application/xml\".parse::<Format>();\n        assert!(result.is_err());\n\n        let result = \"text/plain\".parse::<Format>();\n        assert!(result.is_err());\n\n        let result = \"invalid\".parse::<Format>();\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_display_263": {
      "name": "test_format_display",
      "type": "method",
      "start_line": 263,
      "end_line": 268,
      "content_hash": "b695888ed4e6929c30ee55438faa040568066949",
      "content": "    fn test_format_display() {\n        let fmt = Format::Json;\n        assert_eq!(fmt.to_string(), \"application/json\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_default_269": {
      "name": "test_format_default",
      "type": "method",
      "start_line": 269,
      "end_line": 278,
      "content_hash": "86a82b1cf211814cfccfd7fdda6ba3d6965dd877",
      "content": "    fn test_format_default() {\n        let fmt = Format::default();\n        assert!(matches!(fmt, Format::Json));\n    }\n\n    // ============================================================================\n    // MaybeOwned tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_maybe_owned_deref_owned_279": {
      "name": "test_maybe_owned_deref_owned",
      "type": "method",
      "start_line": 279,
      "end_line": 290,
      "content_hash": "c7d52e5cef113e5a59a91be668bb8c9b4d5d187c",
      "content": "    fn test_maybe_owned_deref_owned() {\n        let data = TestData {\n            name: \"owned\".to_string(),\n            value: 100,\n        };\n\n        let maybe_owned = MaybeOwned::Owned(data.clone());\n        assert_eq!(maybe_owned.name, \"owned\");\n        assert_eq!(maybe_owned.value, 100);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_maybe_owned_deref_borrowed_291": {
      "name": "test_maybe_owned_deref_borrowed",
      "type": "method",
      "start_line": 291,
      "end_line": 302,
      "content_hash": "ff7c4da9e5c20413d7a591d7cafc872989d85272",
      "content": "    fn test_maybe_owned_deref_borrowed() {\n        let data = TestData {\n            name: \"borrowed\".to_string(),\n            value: 200,\n        };\n\n        let maybe_owned = MaybeOwned::Borrowed(&data);\n        assert_eq!(maybe_owned.name, \"borrowed\");\n        assert_eq!(maybe_owned.value, 200);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_maybe_owned_into_owned_from_owned_303": {
      "name": "test_maybe_owned_into_owned_from_owned",
      "type": "method",
      "start_line": 303,
      "end_line": 315,
      "content_hash": "271dd1db60ffdc48b414e954b2fed291cd0ab10d",
      "content": "    fn test_maybe_owned_into_owned_from_owned() {\n        let data = TestData {\n            name: \"test\".to_string(),\n            value: 42,\n        };\n\n        let maybe_owned = MaybeOwned::Owned(data.clone());\n        let owned = maybe_owned.into_owned();\n\n        assert_eq!(owned, data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_maybe_owned_into_owned_from_borrowed_316": {
      "name": "test_maybe_owned_into_owned_from_borrowed",
      "type": "method",
      "start_line": 316,
      "end_line": 332,
      "content_hash": "d6b1c01b6a472c7726b0680169d9c192f786413b",
      "content": "    fn test_maybe_owned_into_owned_from_borrowed() {\n        let data = TestData {\n            name: \"test\".to_string(),\n            value: 42,\n        };\n\n        let maybe_owned = MaybeOwned::Borrowed(&data);\n        let owned = maybe_owned.into_owned();\n\n        assert_eq!(owned, data);\n    }\n\n    // ============================================================================\n    // UTF-8 and Edge Cases\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_utf8_333": {
      "name": "test_format_serialize_utf8",
      "type": "method",
      "start_line": 333,
      "end_line": 334,
      "content_hash": "90a03fecf745a5718b073930947d9d708b1a576b",
      "content": "    fn test_format_serialize_utf8() {\n        #[derive(Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Utf8Data_335": {
      "name": "Utf8Data",
      "type": "struct",
      "start_line": 335,
      "end_line": 349,
      "content_hash": "c8f29d1675c01c351df052b9353ef1706b1502f4",
      "content": "        struct Utf8Data {\n            text: String,\n        }\n\n        let data = Utf8Data {\n            text: \"Hello \u4e16\u754c \ud83d\ude80\".to_string(),\n        };\n\n        let bytes = Format::Json.serialize(&data);\n        let decoded: Utf8Data = Format::Json.deserialize_owned(&bytes).unwrap();\n\n        assert_eq!(decoded, data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_empty_struct_350": {
      "name": "test_format_serialize_empty_struct",
      "type": "method",
      "start_line": 350,
      "end_line": 351,
      "content_hash": "bf4a661119051b96b71b0e0b2cdfde66ddc42042",
      "content": "    fn test_format_serialize_empty_struct() {\n        #[derive(Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Empty_352": {
      "name": "Empty",
      "type": "struct",
      "start_line": 352,
      "end_line": 361,
      "content_hash": "bbaa7cb476be8d2542daec24e7e666ac61ac8ff3",
      "content": "        struct Empty {}\n\n        let data = Empty {};\n        let bytes = Format::Json.serialize(&data);\n        let decoded: Empty = Format::Json.deserialize_owned(&bytes).unwrap();\n\n        assert_eq!(decoded, data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_nested_structures_362": {
      "name": "test_format_serialize_nested_structures",
      "type": "method",
      "start_line": 362,
      "end_line": 363,
      "content_hash": "9a221cfbf839df5a43a04be935fde1e2f0221756",
      "content": "    fn test_format_serialize_nested_structures() {\n        #[derive(Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Inner_364": {
      "name": "Inner",
      "type": "struct",
      "start_line": 364,
      "end_line": 368,
      "content_hash": "5d14c733798a1c6e8ef49ae5907e5cd8dabb992f",
      "content": "        struct Inner {\n            value: i32,\n        }\n\n        #[derive(Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Outer_369": {
      "name": "Outer",
      "type": "struct",
      "start_line": 369,
      "end_line": 385,
      "content_hash": "cca1fc0b3cb1fd0b2e52da199ae3c499e7b44e87",
      "content": "        struct Outer {\n            inner: Inner,\n            name: String,\n        }\n\n        let data = Outer {\n            inner: Inner { value: 42 },\n            name: \"nested\".to_string(),\n        };\n\n        let bytes = Format::Json.serialize(&data);\n        let decoded: Outer = Format::Json.deserialize_owned(&bytes).unwrap();\n\n        assert_eq!(decoded, data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_vec_386": {
      "name": "test_format_serialize_vec",
      "type": "method",
      "start_line": 386,
      "end_line": 394,
      "content_hash": "0c561d498261a244da1c8f600070ccf04aff1105",
      "content": "    fn test_format_serialize_vec() {\n        let data = vec![1, 2, 3, 4, 5];\n        let bytes = Format::Json.serialize(&data);\n        let decoded: Vec<i32> = Format::Json.deserialize_owned(&bytes).unwrap();\n\n        assert_eq!(decoded, data);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_format_serialize_option_395": {
      "name": "test_format_serialize_option",
      "type": "method",
      "start_line": 395,
      "end_line": 396,
      "content_hash": "c8a657d2e3de13f4a62b6bdf05d0503ca7e4e7b0",
      "content": "    fn test_format_serialize_option() {\n        #[derive(Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_WithOption_397": {
      "name": "WithOption",
      "type": "struct",
      "start_line": 397,
      "end_line": 411,
      "content_hash": "82a5fad8490eec7b8ebaa4c50f7a161e6fc30d06",
      "content": "        struct WithOption {\n            value: Option<i32>,\n        }\n\n        let with_some = WithOption { value: Some(42) };\n        let bytes = Format::Json.serialize(&with_some);\n        let decoded: WithOption = Format::Json.deserialize_owned(&bytes).unwrap();\n        assert_eq!(decoded, with_some);\n\n        let with_none = WithOption { value: None };\n        let bytes = Format::Json.serialize(&with_none);\n        let decoded: WithOption = Format::Json.deserialize_owned(&bytes).unwrap();\n        assert_eq!(decoded, with_none);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}