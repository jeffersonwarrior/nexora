{
  "file_path": "/work/internal/fsext/lookup_test.go",
  "file_hash": "d017ab8c57513c7682ce0d2b52298e19346f1867",
  "updated_at": "2025-12-26T17:34:20.563677",
  "symbols": {
    "function_TestLookupClosest_13": {
      "name": "TestLookupClosest",
      "type": "function",
      "start_line": 13,
      "end_line": 124,
      "content_hash": "11d1d6e765997eec54922547e02d5fa8f8904a5a",
      "content": "func TestLookupClosest(t *testing.T) {\n\ttempDir := t.TempDir()\n\tt.Chdir(tempDir)\n\n\tt.Run(\"target found in starting directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create target file in current directory\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\terr := os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfoundPath, found := LookupClosest(testDir, \"target.txt\")\n\t\trequire.True(t, found)\n\t\trequire.Equal(t, targetFile, foundPath)\n\t})\n\n\tt.Run(\"target found in parent directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create subdirectory\n\t\tsubDir := filepath.Join(testDir, \"subdir\")\n\t\terr := os.Mkdir(subDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Create target file in parent directory\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\terr = os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfoundPath, found := LookupClosest(subDir, \"target.txt\")\n\t\trequire.True(t, found)\n\t\trequire.Equal(t, targetFile, foundPath)\n\t})\n\n\tt.Run(\"target found in grandparent directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create nested subdirectories\n\t\tsubDir := filepath.Join(testDir, \"subdir\")\n\t\terr := os.Mkdir(subDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\tsubSubDir := filepath.Join(subDir, \"subsubdir\")\n\t\terr = os.Mkdir(subSubDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Create target file in grandparent directory\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\terr = os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfoundPath, found := LookupClosest(subSubDir, \"target.txt\")\n\t\trequire.True(t, found)\n\t\trequire.Equal(t, targetFile, foundPath)\n\t})\n\n\tt.Run(\"target not found\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfoundPath, found := LookupClosest(testDir, \"nonexistent.txt\")\n\t\trequire.False(t, found)\n\t\trequire.Empty(t, foundPath)\n\t})\n\n\tt.Run(\"target directory found\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create target directory in current directory\n\t\ttargetDir := filepath.Join(testDir, \"targetdir\")\n\t\terr := os.Mkdir(targetDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\tfoundPath, found := LookupClosest(testDir, \"targetdir\")\n\t\trequire.True(t, found)\n\t\trequire.Equal(t, targetDir, foundPath)\n\t})\n\n\tt.Run(\"stops at home directory\", func(t *testing.T) {\n\t\t// This test is limited as we can't easily create files above home directory\n\t\t// but we can test the behavior by searching from home directory itself\n\t\thomeDir := home.Dir()\n\n\t\t// Search for a file that doesn't exist from home directory\n\t\tfoundPath, found := LookupClosest(homeDir, \"nonexistent_file_12345.txt\")\n\t\trequire.False(t, found)\n\t\trequire.Empty(t, foundPath)\n\t})\n\n\tt.Run(\"invalid starting directory\", func(t *testing.T) {\n\t\tfoundPath, found := LookupClosest(\"/invalid/path/that/does/not/exist\", \"target.txt\")\n\t\trequire.False(t, found)\n\t\trequire.Empty(t, foundPath)\n\t})\n\n\tt.Run(\"relative path handling\", func(t *testing.T) {\n\t\t// Create target file in current directory\n\t\trequire.NoError(t, os.WriteFile(\"target.txt\", []byte(\"test\"), 0o644))\n\n\t\t// Search using relative path\n\t\tfoundPath, found := LookupClosest(\".\", \"target.txt\")\n\t\trequire.True(t, found)\n\n\t\t// Resolve symlinks to handle macOS /private/var vs /var discrepancy\n\t\texpectedPath, err := filepath.EvalSymlinks(filepath.Join(tempDir, \"target.txt\"))\n\t\trequire.NoError(t, err)\n\t\tactualPath, err := filepath.EvalSymlinks(foundPath)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expectedPath, actualPath)\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestLookupClosestWithOwnership_125": {
      "name": "TestLookupClosestWithOwnership",
      "type": "function",
      "start_line": 125,
      "end_line": 152,
      "content_hash": "d1d349c0afc10b06d8c5e24dccf28f205adc7b84",
      "content": "func TestLookupClosestWithOwnership(t *testing.T) {\n\t// Note: Testing ownership boundaries is difficult in a cross-platform way\n\t// without creating complex directory structures with different owners.\n\t// This test focuses on the basic functionality when ownership checks pass.\n\n\ttempDir := t.TempDir()\n\tt.Chdir(tempDir)\n\n\tt.Run(\"search respects same ownership\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create subdirectory structure\n\t\tsubDir := filepath.Join(testDir, \"subdir\")\n\t\terr := os.Mkdir(subDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Create target file in parent directory\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\terr = os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Search should find the target assuming same ownership\n\t\tfoundPath, found := LookupClosest(subDir, \"target.txt\")\n\t\trequire.True(t, found)\n\t\trequire.Equal(t, targetFile, foundPath)\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestLookup_153": {
      "name": "TestLookup",
      "type": "function",
      "start_line": 153,
      "end_line": 355,
      "content_hash": "f37f588a0b6ad86d44d7b4de4d7b9892ed85d6eb",
      "content": "func TestLookup(t *testing.T) {\n\ttempDir := t.TempDir()\n\tt.Chdir(tempDir)\n\n\tt.Run(\"no targets returns empty slice\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfound, err := Lookup(testDir)\n\t\trequire.NoError(t, err)\n\t\trequire.Empty(t, found)\n\t})\n\n\tt.Run(\"single target found in starting directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create target file in current directory\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\terr := os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(testDir, \"target.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 1)\n\t\trequire.Equal(t, targetFile, found[0])\n\t})\n\n\tt.Run(\"multiple targets found in starting directory\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create multiple target files in current directory\n\t\ttargetFile1 := filepath.Join(testDir, \"target1.txt\")\n\t\ttargetFile2 := filepath.Join(testDir, \"target2.txt\")\n\t\ttargetFile3 := filepath.Join(testDir, \"target3.txt\")\n\n\t\terr := os.WriteFile(targetFile1, []byte(\"test1\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile2, []byte(\"test2\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile3, []byte(\"test3\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(testDir, \"target1.txt\", \"target2.txt\", \"target3.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 3)\n\t\trequire.Contains(t, found, targetFile1)\n\t\trequire.Contains(t, found, targetFile2)\n\t\trequire.Contains(t, found, targetFile3)\n\t})\n\n\tt.Run(\"targets found in parent directories\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create subdirectory\n\t\tsubDir := filepath.Join(testDir, \"subdir\")\n\t\terr := os.Mkdir(subDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Create target files in parent directory\n\t\ttargetFile1 := filepath.Join(testDir, \"target1.txt\")\n\t\ttargetFile2 := filepath.Join(testDir, \"target2.txt\")\n\t\terr = os.WriteFile(targetFile1, []byte(\"test1\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile2, []byte(\"test2\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(subDir, \"target1.txt\", \"target2.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 2)\n\t\trequire.Contains(t, found, targetFile1)\n\t\trequire.Contains(t, found, targetFile2)\n\t})\n\n\tt.Run(\"targets found across multiple directory levels\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create nested subdirectories\n\t\tsubDir := filepath.Join(testDir, \"subdir\")\n\t\terr := os.Mkdir(subDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\tsubSubDir := filepath.Join(subDir, \"subsubdir\")\n\t\terr = os.Mkdir(subSubDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Create target files at different levels\n\t\ttargetFile1 := filepath.Join(testDir, \"target1.txt\")\n\t\ttargetFile2 := filepath.Join(subDir, \"target2.txt\")\n\t\ttargetFile3 := filepath.Join(subSubDir, \"target3.txt\")\n\n\t\terr = os.WriteFile(targetFile1, []byte(\"test1\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile2, []byte(\"test2\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile3, []byte(\"test3\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(subSubDir, \"target1.txt\", \"target2.txt\", \"target3.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 3)\n\t\trequire.Contains(t, found, targetFile1)\n\t\trequire.Contains(t, found, targetFile2)\n\t\trequire.Contains(t, found, targetFile3)\n\t})\n\n\tt.Run(\"some targets not found\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create only some target files\n\t\ttargetFile1 := filepath.Join(testDir, \"target1.txt\")\n\t\ttargetFile2 := filepath.Join(testDir, \"target2.txt\")\n\n\t\terr := os.WriteFile(targetFile1, []byte(\"test1\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.WriteFile(targetFile2, []byte(\"test2\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Search for existing and non-existing targets\n\t\tfound, err := Lookup(testDir, \"target1.txt\", \"nonexistent.txt\", \"target2.txt\", \"another_nonexistent.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 2)\n\t\trequire.Contains(t, found, targetFile1)\n\t\trequire.Contains(t, found, targetFile2)\n\t})\n\n\tt.Run(\"no targets found\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\tfound, err := Lookup(testDir, \"nonexistent1.txt\", \"nonexistent2.txt\", \"nonexistent3.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Empty(t, found)\n\t})\n\n\tt.Run(\"target directories found\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create target directories\n\t\ttargetDir1 := filepath.Join(testDir, \"targetdir1\")\n\t\ttargetDir2 := filepath.Join(testDir, \"targetdir2\")\n\t\terr := os.Mkdir(targetDir1, 0o755)\n\t\trequire.NoError(t, err)\n\t\terr = os.Mkdir(targetDir2, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(testDir, \"targetdir1\", \"targetdir2\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 2)\n\t\trequire.Contains(t, found, targetDir1)\n\t\trequire.Contains(t, found, targetDir2)\n\t})\n\n\tt.Run(\"mixed files and directories\", func(t *testing.T) {\n\t\ttestDir := t.TempDir()\n\n\t\t// Create target files and directories\n\t\ttargetFile := filepath.Join(testDir, \"target.txt\")\n\t\ttargetDir := filepath.Join(testDir, \"targetdir\")\n\t\terr := os.WriteFile(targetFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\t\terr = os.Mkdir(targetDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\tfound, err := Lookup(testDir, \"target.txt\", \"targetdir\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 2)\n\t\trequire.Contains(t, found, targetFile)\n\t\trequire.Contains(t, found, targetDir)\n\t})\n\n\tt.Run(\"invalid starting directory\", func(t *testing.T) {\n\t\tfound, err := Lookup(\"/invalid/path/that/does/not/exist\", \"target.txt\")\n\t\trequire.Error(t, err)\n\t\trequire.Empty(t, found)\n\t})\n\n\tt.Run(\"relative path handling\", func(t *testing.T) {\n\t\t// Create target files in current directory\n\t\trequire.NoError(t, os.WriteFile(\"target1.txt\", []byte(\"test1\"), 0o644))\n\t\trequire.NoError(t, os.WriteFile(\"target2.txt\", []byte(\"test2\"), 0o644))\n\n\t\t// Search using relative path\n\t\tfound, err := Lookup(\".\", \"target1.txt\", \"target2.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, found, 2)\n\n\t\t// Resolve symlinks to handle macOS /private/var vs /var discrepancy\n\t\texpectedPath1, err := filepath.EvalSymlinks(filepath.Join(tempDir, \"target1.txt\"))\n\t\trequire.NoError(t, err)\n\t\texpectedPath2, err := filepath.EvalSymlinks(filepath.Join(tempDir, \"target2.txt\"))\n\t\trequire.NoError(t, err)\n\n\t\t// Check that found paths match expected paths (order may vary)\n\t\tfoundEvalSymlinks := make([]string, len(found))\n\t\tfor i, path := range found {\n\t\t\tevalPath, err := filepath.EvalSymlinks(path)\n\t\t\trequire.NoError(t, err)\n\t\t\tfoundEvalSymlinks[i] = evalPath\n\t\t}\n\n\t\trequire.Contains(t, foundEvalSymlinks, expectedPath1)\n\t\trequire.Contains(t, foundEvalSymlinks, expectedPath2)\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProbeEnt_356": {
      "name": "TestProbeEnt",
      "type": "function",
      "start_line": 356,
      "end_line": 437,
      "content_hash": "29190712b678394cfad7551d6f7a5f47ec7fcfb6",
      "content": "func TestProbeEnt(t *testing.T) {\n\tt.Run(\"existing file with correct owner\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Create test file\n\t\ttestFile := filepath.Join(tempDir, \"test.txt\")\n\t\terr := os.WriteFile(testFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Get owner of temp directory\n\t\towner, err := Owner(tempDir)\n\t\trequire.NoError(t, err)\n\n\t\t// Test probeEnt with correct owner\n\t\terr = probeEnt(testFile, owner)\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"existing directory with correct owner\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Create test directory\n\t\ttestDir := filepath.Join(tempDir, \"testdir\")\n\t\terr := os.Mkdir(testDir, 0o755)\n\t\trequire.NoError(t, err)\n\n\t\t// Get owner of temp directory\n\t\towner, err := Owner(tempDir)\n\t\trequire.NoError(t, err)\n\n\t\t// Test probeEnt with correct owner\n\t\terr = probeEnt(testDir, owner)\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"nonexistent file\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\tnonexistentFile := filepath.Join(tempDir, \"nonexistent.txt\")\n\t\towner, err := Owner(tempDir)\n\t\trequire.NoError(t, err)\n\n\t\terr = probeEnt(nonexistentFile, owner)\n\t\trequire.Error(t, err)\n\t\trequire.True(t, errors.Is(err, os.ErrNotExist))\n\t})\n\n\tt.Run(\"nonexistent file in nonexistent directory\", func(t *testing.T) {\n\t\tnonexistentFile := \"/this/directory/does/not/exists/nonexistent.txt\"\n\n\t\terr := probeEnt(nonexistentFile, -1)\n\t\trequire.Error(t, err)\n\t\trequire.True(t, errors.Is(err, os.ErrNotExist))\n\t})\n\n\tt.Run(\"ownership bypass with -1\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Create test file\n\t\ttestFile := filepath.Join(tempDir, \"test.txt\")\n\t\terr := os.WriteFile(testFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Test probeEnt with -1 (bypass ownership check)\n\t\terr = probeEnt(testFile, -1)\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"ownership mismatch returns permission error\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Create test file\n\t\ttestFile := filepath.Join(tempDir, \"test.txt\")\n\t\terr := os.WriteFile(testFile, []byte(\"test\"), 0o644)\n\t\trequire.NoError(t, err)\n\n\t\t// Test probeEnt with different owner (use 9999 which is unlikely to be the actual owner)\n\t\terr = probeEnt(testFile, 9999)\n\t\trequire.Error(t, err)\n\t\trequire.True(t, errors.Is(err, os.ErrPermission))\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}