{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/traversal_core/ops/out/out.rs",
  "file_hash": "97418c104b2cc53a554eff6e29ade39ae355a019",
  "updated_at": "2025-12-26T17:34:21.250016",
  "symbols": {
    "trait_OutAdapter_10": {
      "name": "OutAdapter",
      "type": "trait",
      "start_line": 10,
      "end_line": 18,
      "content_hash": "b7b70d8eae5b8a204512bc5aff22da7fc2ff9478",
      "content": "pub trait OutAdapter<'db, 'arena, 'txn, 's>:\n    Iterator<Item = Result<TraversalValue<'arena>, GraphError>>\n{\n    /// Returns an iterator containing the nodes that have an outgoing edge with the given label.\n    ///\n    /// Note that the `edge_label` cannot be empty and must be a valid, existing edge label.\n    ///\n    /// To provide safety, you cannot get all outgoing nodes as it would be ambiguous as to what\n    /// type that resulting node would be.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_out_vec_19": {
      "name": "out_vec",
      "type": "function",
      "start_line": 19,
      "end_line": 26,
      "content_hash": "27d3c29922645d53232257daab42ef006b5cad2d",
      "content": "    fn out_vec(\n        self,\n        edge_label: &'s str,\n        get_vector_data: bool,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_27": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 27,
      "end_line": 29,
      "content_hash": "8773007e76fbde46c81641c22c1a5fbbac716149",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_node_30": {
      "name": "out_node",
      "type": "method",
      "start_line": 30,
      "end_line": 36,
      "content_hash": "d683adf699fd4c3c78370c7cd2cd05a8e7893983",
      "content": "    fn out_node(\n        self,\n        edge_label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_37": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 37,
      "end_line": 44,
      "content_hash": "dea3f5460b819662ac7243815e4f9662af84c47f",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n}\n\nimpl<'db, 'arena, 'txn, 's, I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>>\n    OutAdapter<'db, 'arena, 'txn, 's> for RoTraversalIterator<'db, 'arena, 'txn, I>\n{\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_vec_45": {
      "name": "out_vec",
      "type": "method",
      "start_line": 45,
      "end_line": 52,
      "content_hash": "27d3c29922645d53232257daab42ef006b5cad2d",
      "content": "    fn out_vec(\n        self,\n        edge_label: &'s str,\n        get_vector_data: bool,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_53": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 53,
      "end_line": 116,
      "content_hash": "9dbfc6e806b9adb17ac7fd51887162b55bcd8efb",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let iter = self\n            .inner\n            .filter_map(move |item| {\n                let edge_label_hash = hash_label(edge_label, None);\n                let prefix = HelixGraphStorage::out_edge_key(\n                    &match item {\n                        Ok(item) => item.id(),\n                        Err(_) => return None,\n                    },\n                    &edge_label_hash,\n                );\n\n                match self.storage.out_edges_db.get_duplicates(self.txn, &prefix) {\n                    Ok(Some(iter)) => Some(iter.filter_map(move |item| {\n                        if let Ok((_, value)) = item {\n                            let (_, item_id) = match HelixGraphStorage::unpack_adj_edge_data(value)\n                            {\n                                Ok(data) => data,\n                                Err(e) => {\n                                    println!(\"Error unpacking edge data: {e:?}\");\n                                    return Some(Err(e));\n                                }\n                            };\n                            if get_vector_data {\n                                if let Ok(vec) = self\n                                    .storage\n                                    .vectors\n                                    .get_full_vector(self.txn, item_id, self.arena)\n                                {\n                                    return Some(Ok(TraversalValue::Vector(vec)));\n                                }\n                            } else if let Ok(Some(vec)) = self\n                                .storage\n                                .vectors\n                                .get_vector_properties(self.txn, item_id, self.arena)\n                            {\n                                return Some(Ok(TraversalValue::VectorNodeWithoutVectorData(vec)));\n                            }\n                            None\n                        } else {\n                            None\n                        }\n                    })),\n                    Ok(None) => None,\n                    Err(e) => {\n                        println!(\"{} Error getting out edges: {:?}\", line!(), e);\n                        // return Err(e);\n                        None\n                    }\n                }\n            })\n            .flatten();\n\n        RoTraversalIterator {\n            inner: iter,\n            storage: self.storage,\n            arena: self.arena,\n            txn: self.txn,\n        }\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_out_node_117": {
      "name": "out_node",
      "type": "method",
      "start_line": 117,
      "end_line": 123,
      "content_hash": "d683adf699fd4c3c78370c7cd2cd05a8e7893983",
      "content": "    fn out_node(\n        self,\n        edge_label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_124": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 124,
      "end_line": 171,
      "content_hash": "e8dc55c0e8dca683e62151431651cd5326e550b4",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let iter = self\n            .inner\n            .filter_map(move |item| {\n                let edge_label_hash = hash_label(edge_label, None);\n                let prefix = HelixGraphStorage::out_edge_key(\n                    &match item {\n                        Ok(item) => item.id(),\n                        Err(_) => return None,\n                    },\n                    &edge_label_hash,\n                );\n                match self.storage.out_edges_db.get_duplicates(self.txn, &prefix) {\n                    Ok(Some(iter)) => Some(iter.filter_map(move |item| {\n                        if let Ok((_, data)) = item {\n                            let (_, item_id) = match HelixGraphStorage::unpack_adj_edge_data(data) {\n                                Ok(data) => data,\n                                Err(e) => {\n                                    println!(\"Error unpacking edge data: {e:?}\");\n                                    return Some(Err(e));\n                                }\n                            };\n                            if let Ok(node) = self.storage.get_node(self.txn, &item_id, self.arena)\n                            {\n                                return Some(Ok(TraversalValue::Node(node)));\n                            }\n                        }\n                        None\n                    })),\n                    Ok(None) => None,\n                    Err(e) => {\n                        println!(\"{} Error getting out nodes: {:?}\", line!(), e);\n                        // return Err(e);\n                        None\n                    }\n                }\n            })\n            .flatten();\n\n        RoTraversalIterator {\n            inner: iter,\n            storage: self.storage,\n            arena: self.arena,\n            txn: self.txn,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}