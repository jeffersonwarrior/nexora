{
  "file_path": "/work/context-engine/tests/test_fname_boost.py",
  "file_hash": "8b7cf0735dc6d53f39eaf97ce88539adc8fb25c2",
  "updated_at": "2025-12-26T17:34:21.252591",
  "symbols": {
    "class_TestSplitIdentifier_16": {
      "name": "TestSplitIdentifier",
      "type": "class",
      "start_line": 16,
      "end_line": 64,
      "content_hash": "35b635c983725e5134e5fd5155f2fbd270770df3",
      "content": "class TestSplitIdentifier:\n    \"\"\"Test identifier tokenization across naming conventions.\"\"\"\n\n    def test_camel_case(self):\n        assert _split_identifier(\"userAuthHandler\") == [\"user\", \"auth\", \"handler\"]\n\n    def test_pascal_case(self):\n        assert _split_identifier(\"UserAuthHandler\") == [\"user\", \"auth\", \"handler\"]\n\n    def test_snake_case(self):\n        assert _split_identifier(\"user_auth_handler\") == [\"user\", \"auth\", \"handler\"]\n\n    def test_kebab_case(self):\n        assert _split_identifier(\"user-auth-handler\") == [\"user\", \"auth\", \"handler\"]\n\n    def test_screaming_snake(self):\n        assert _split_identifier(\"USER_AUTH_HANDLER\") == [\"user\", \"auth\", \"handler\"]\n\n    def test_acronym_prefix(self):\n        \"\"\"XMLParser should split into xml, parser.\"\"\"\n        assert _split_identifier(\"XMLParser\") == [\"xml\", \"parser\"]\n\n    def test_acronym_suffix(self):\n        \"\"\"parseJSON should split into parse, json.\"\"\"\n        assert _split_identifier(\"parseJSON\") == [\"parse\", \"json\"]\n\n    def test_http_client(self):\n        \"\"\"HTTPClient should split properly.\"\"\"\n        assert _split_identifier(\"HTTPClient\") == [\"http\", \"client\"]\n\n    def test_interface_prefix_stripped(self):\n        \"\"\"IUserService -> user, service (I prefix stripped).\"\"\"\n        assert _split_identifier(\"IUserService\") == [\"user\", \"service\"]\n\n    def test_private_prefix_stripped(self):\n        \"\"\"_privateMethod -> private, method.\"\"\"\n        assert _split_identifier(\"_privateMethod\") == [\"private\", \"method\"]\n\n    def test_dollar_prefix_stripped(self):\n        \"\"\"$scope -> scope.\"\"\"\n        assert _split_identifier(\"$scope\") == [\"scope\"]\n\n    def test_numbers_separated(self):\n        \"\"\"handler2 -> handler (numbers stripped).\"\"\"\n        assert _split_identifier(\"handler2\") == [\"handler\"]\n\n    def test_dot_notation(self):\n        \"\"\"com.company.auth -> com, company, auth.\"\"\"\n        assert _split_identifier(\"com.company.auth\") == [\"com\", \"company\", \"auth\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_camel_case_19": {
      "name": "test_camel_case",
      "type": "method",
      "start_line": 19,
      "end_line": 20,
      "content_hash": "87d9a9ffbe191b968401ca8e432b8ae5e8dc247f",
      "content": "    def test_camel_case(self):\n        assert _split_identifier(\"userAuthHandler\") == [\"user\", \"auth\", \"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_pascal_case_22": {
      "name": "test_pascal_case",
      "type": "method",
      "start_line": 22,
      "end_line": 23,
      "content_hash": "cf1f742f33fe4a08c388f6c7d829a1b14d6566df",
      "content": "    def test_pascal_case(self):\n        assert _split_identifier(\"UserAuthHandler\") == [\"user\", \"auth\", \"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_snake_case_25": {
      "name": "test_snake_case",
      "type": "method",
      "start_line": 25,
      "end_line": 26,
      "content_hash": "ab135640d3d180186938f22c78cb820399465e06",
      "content": "    def test_snake_case(self):\n        assert _split_identifier(\"user_auth_handler\") == [\"user\", \"auth\", \"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_kebab_case_28": {
      "name": "test_kebab_case",
      "type": "method",
      "start_line": 28,
      "end_line": 29,
      "content_hash": "25e2032677795023849db9ea43900b02cdd8623e",
      "content": "    def test_kebab_case(self):\n        assert _split_identifier(\"user-auth-handler\") == [\"user\", \"auth\", \"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_screaming_snake_31": {
      "name": "test_screaming_snake",
      "type": "method",
      "start_line": 31,
      "end_line": 32,
      "content_hash": "cf2bd8b1bcb0a3c43f663b044e57537daa66d9e6",
      "content": "    def test_screaming_snake(self):\n        assert _split_identifier(\"USER_AUTH_HANDLER\") == [\"user\", \"auth\", \"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_acronym_prefix_34": {
      "name": "test_acronym_prefix",
      "type": "method",
      "start_line": 34,
      "end_line": 36,
      "content_hash": "3108dea5a3272e7891c692e88abeb7585c59eda1",
      "content": "    def test_acronym_prefix(self):\n        \"\"\"XMLParser should split into xml, parser.\"\"\"\n        assert _split_identifier(\"XMLParser\") == [\"xml\", \"parser\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_acronym_suffix_38": {
      "name": "test_acronym_suffix",
      "type": "method",
      "start_line": 38,
      "end_line": 40,
      "content_hash": "13a05a244c68d0636c964cb774e24f1cca3dfacc",
      "content": "    def test_acronym_suffix(self):\n        \"\"\"parseJSON should split into parse, json.\"\"\"\n        assert _split_identifier(\"parseJSON\") == [\"parse\", \"json\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_http_client_42": {
      "name": "test_http_client",
      "type": "method",
      "start_line": 42,
      "end_line": 44,
      "content_hash": "894a86d66c894d1500272afb987e91f44c96afb1",
      "content": "    def test_http_client(self):\n        \"\"\"HTTPClient should split properly.\"\"\"\n        assert _split_identifier(\"HTTPClient\") == [\"http\", \"client\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_interface_prefix_stripped_46": {
      "name": "test_interface_prefix_stripped",
      "type": "method",
      "start_line": 46,
      "end_line": 48,
      "content_hash": "12d28cf6fe356221b58d63532c25025b2bc7c8c4",
      "content": "    def test_interface_prefix_stripped(self):\n        \"\"\"IUserService -> user, service (I prefix stripped).\"\"\"\n        assert _split_identifier(\"IUserService\") == [\"user\", \"service\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_private_prefix_stripped_50": {
      "name": "test_private_prefix_stripped",
      "type": "method",
      "start_line": 50,
      "end_line": 52,
      "content_hash": "476fe0cac2ae74a569af145030f613a8753597c6",
      "content": "    def test_private_prefix_stripped(self):\n        \"\"\"_privateMethod -> private, method.\"\"\"\n        assert _split_identifier(\"_privateMethod\") == [\"private\", \"method\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_dollar_prefix_stripped_54": {
      "name": "test_dollar_prefix_stripped",
      "type": "method",
      "start_line": 54,
      "end_line": 56,
      "content_hash": "acc8698efce891baad57c271be2d1538f7971ac6",
      "content": "    def test_dollar_prefix_stripped(self):\n        \"\"\"$scope -> scope.\"\"\"\n        assert _split_identifier(\"$scope\") == [\"scope\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_numbers_separated_58": {
      "name": "test_numbers_separated",
      "type": "method",
      "start_line": 58,
      "end_line": 60,
      "content_hash": "f5ca4b41879f1349808bac51d5fe993f87045a8b",
      "content": "    def test_numbers_separated(self):\n        \"\"\"handler2 -> handler (numbers stripped).\"\"\"\n        assert _split_identifier(\"handler2\") == [\"handler\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_dot_notation_62": {
      "name": "test_dot_notation",
      "type": "method",
      "start_line": 62,
      "end_line": 64,
      "content_hash": "19a46127dfe65cb3006eeff37b1d6e51f487c066",
      "content": "    def test_dot_notation(self):\n        \"\"\"com.company.auth -> com, company, auth.\"\"\"\n        assert _split_identifier(\"com.company.auth\") == [\"com\", \"company\", \"auth\"]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestNormalizeToken_67": {
      "name": "TestNormalizeToken",
      "type": "class",
      "start_line": 67,
      "end_line": 81,
      "content_hash": "1d1e1fd209e88c9f2d90c40bcd28ec01475a7639",
      "content": "class TestNormalizeToken:\n    \"\"\"Test plural normalization.\"\"\"\n\n    def test_no_abbrev_expansion(self):\n        forms = _normalize_token(\"auth\")\n        assert \"auth\" in forms\n        assert \"authenticate\" not in forms\n\n    def test_plural_normalized(self):\n        forms = _normalize_token(\"services\")\n        assert \"service\" in forms\n\n    def test_singular_gets_plural(self):\n        forms = _normalize_token(\"service\")\n        assert \"services\" in forms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_no_abbrev_expansion_70": {
      "name": "test_no_abbrev_expansion",
      "type": "method",
      "start_line": 70,
      "end_line": 73,
      "content_hash": "5733438f6f28d2f4ed339e7a9292df9c4c2b8812",
      "content": "    def test_no_abbrev_expansion(self):\n        forms = _normalize_token(\"auth\")\n        assert \"auth\" in forms\n        assert \"authenticate\" not in forms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_plural_normalized_75": {
      "name": "test_plural_normalized",
      "type": "method",
      "start_line": 75,
      "end_line": 77,
      "content_hash": "7e778597314bd53f8addcb42294186c11881ca8a",
      "content": "    def test_plural_normalized(self):\n        forms = _normalize_token(\"services\")\n        assert \"service\" in forms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_singular_gets_plural_79": {
      "name": "test_singular_gets_plural",
      "type": "method",
      "start_line": 79,
      "end_line": 81,
      "content_hash": "b6c0a804dbd0852b4132cce69c2eee41fd23d67a",
      "content": "    def test_singular_gets_plural(self):\n        forms = _normalize_token(\"service\")\n        assert \"services\" in forms",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_TestComputeFnameBoost_84": {
      "name": "TestComputeFnameBoost",
      "type": "class",
      "start_line": 84,
      "end_line": 200,
      "content_hash": "383554c64bd4ae367de2b74d2b4a2e5d3badb14f",
      "content": "class TestComputeFnameBoost:\n    \"\"\"Test the full filename boost computation.\"\"\"\n\n    def test_basic_snake_case_match(self):\n        \"\"\"Basic snake_case filename matching.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 2 exact filename matches with bonus\n\n    def test_rel_path_fallback(self):\n        \"\"\"Should work with rel_path key.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"rel_path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4\n\n    def test_metadata_path_fallback(self):\n        \"\"\"Should work with metadata.path.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"metadata\": {\"path\": \"scripts/hybrid_search.py\"}}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4\n\n    def test_disabled_when_factor_zero(self):\n        \"\"\"Factor of 0 should return 0.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        assert _compute_fname_boost(q, cand, 0.0) == 0.0\n\n    def test_requires_two_matches(self):\n        \"\"\"Single token match should not trigger boost.\"\"\"\n        q = \"hybrid fusion scoring\"  # only 'hybrid' matches\n        cand = {\"path\": \"scripts/hybrid_utils.py\"}\n        assert _compute_fname_boost(q, cand, 0.15) == 0.0\n\n    def test_camel_case_tokenization(self):\n        \"\"\"CamelCase filenames should be properly tokenized.\"\"\"\n        q = \"user auth handler\"\n        cand = {\"path\": \"services/UserAuthHandler.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.5  # 3 matches with filename bonus\n\n    def test_pascal_case_tokenization(self):\n        \"\"\"PascalCase filenames should be properly tokenized.\"\"\"\n        q = \"database connection pool\"\n        cand = {\"path\": \"lib/DatabaseConnectionPool.java\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.5  # 3 matches\n\n    def test_acronym_matching(self):\n        \"\"\"Acronyms like XMLParser should match 'xml parser'.\"\"\"\n        q = \"xml parser\"\n        cand = {\"path\": \"utils/XMLParser.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 2 exact matches\n\n    def test_substring_matching_authenticate_auth(self):\n        \"\"\"'authenticate' contains 'auth', so substring tier can still match it.\"\"\"\n        q = \"authenticate user\"\n        cand = {\"path\": \"auth/UserAuth.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3\n\n    def test_substring_matching_configuration_config(self):\n        \"\"\"'configuration' contains 'config', so substring tier can still match it.\"\"\"\n        q = \"configuration manager\"\n        cand = {\"path\": \"config/ConfigManager.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3\n\n    def test_directory_matching(self):\n        \"\"\"Query tokens should match directory names.\"\"\"\n        q = \"auth services controller\"\n        cand = {\"path\": \"services/auth/controller.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 3 matches across path\n\n    def test_filename_bonus(self):\n        \"\"\"Filename matches should score higher than directory matches.\"\"\"\n        q = \"auth handler\"\n        # Filename match\n        cand1 = {\"path\": \"services/AuthHandler.py\"}\n        # Directory match only\n        cand2 = {\"path\": \"auth/handler/index.py\"}\n        score1 = _compute_fname_boost(q, cand1, 0.15)\n        score2 = _compute_fname_boost(q, cand2, 0.15)\n        assert score1 > score2  # Filename match wins\n\n    def test_deep_path_handling(self):\n        \"\"\"Deep Java-style paths should work.\"\"\"\n        q = \"user service implementation\"\n        cand = {\"path\": \"src/main/java/com/company/user/service/UserServiceImpl.java\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3  # Should find matches\n\n    def test_interface_prefix_stripped(self):\n        \"\"\"IUserService should match 'user service'.\"\"\"\n        q = \"user service\"\n        cand = {\"path\": \"interfaces/IUserService.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3\n\n    def test_common_tokens_penalized(self):\n        \"\"\"Common tokens like 'utils', 'index' should be penalized.\"\"\"\n        q = \"auth utils\"\n        cand = {\"path\": \"utils/AuthUtils.py\"}  # common token 'utils'\n        score = _compute_fname_boost(q, cand, 0.15)\n        # Should still match, but common token gets penalty\n        assert score > 0\n\n    def test_jsonish_query(self):\n        \"\"\"Handle queries wrapped in JSON-like brackets.\"\"\"\n        q = '[\"hybrid search fusion\"]'\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_basic_snake_case_match_87": {
      "name": "test_basic_snake_case_match",
      "type": "method",
      "start_line": 87,
      "end_line": 92,
      "content_hash": "7857e421ae65f12933fef54a83c7d71692ff74ee",
      "content": "    def test_basic_snake_case_match(self):\n        \"\"\"Basic snake_case filename matching.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 2 exact filename matches with bonus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_rel_path_fallback_94": {
      "name": "test_rel_path_fallback",
      "type": "method",
      "start_line": 94,
      "end_line": 99,
      "content_hash": "08d71e4428d77c78e973ef0623bd2b6f1de9624a",
      "content": "    def test_rel_path_fallback(self):\n        \"\"\"Should work with rel_path key.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"rel_path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_metadata_path_fallback_101": {
      "name": "test_metadata_path_fallback",
      "type": "method",
      "start_line": 101,
      "end_line": 106,
      "content_hash": "58df501e8ead99ce522e054d8f94979e3f4dd4d1",
      "content": "    def test_metadata_path_fallback(self):\n        \"\"\"Should work with metadata.path.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"metadata\": {\"path\": \"scripts/hybrid_search.py\"}}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_disabled_when_factor_zero_108": {
      "name": "test_disabled_when_factor_zero",
      "type": "method",
      "start_line": 108,
      "end_line": 112,
      "content_hash": "aaa821fcb0380f9c9b997cca63d29db36554504a",
      "content": "    def test_disabled_when_factor_zero(self):\n        \"\"\"Factor of 0 should return 0.\"\"\"\n        q = \"hybrid search\"\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        assert _compute_fname_boost(q, cand, 0.0) == 0.0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_requires_two_matches_114": {
      "name": "test_requires_two_matches",
      "type": "method",
      "start_line": 114,
      "end_line": 118,
      "content_hash": "ef2e873d4267a7cff5a07042a301475327e3a58f",
      "content": "    def test_requires_two_matches(self):\n        \"\"\"Single token match should not trigger boost.\"\"\"\n        q = \"hybrid fusion scoring\"  # only 'hybrid' matches\n        cand = {\"path\": \"scripts/hybrid_utils.py\"}\n        assert _compute_fname_boost(q, cand, 0.15) == 0.0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_camel_case_tokenization_120": {
      "name": "test_camel_case_tokenization",
      "type": "method",
      "start_line": 120,
      "end_line": 125,
      "content_hash": "168417b2645c24b71ed3842cea2c9b4d0e161416",
      "content": "    def test_camel_case_tokenization(self):\n        \"\"\"CamelCase filenames should be properly tokenized.\"\"\"\n        q = \"user auth handler\"\n        cand = {\"path\": \"services/UserAuthHandler.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.5  # 3 matches with filename bonus",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_pascal_case_tokenization_127": {
      "name": "test_pascal_case_tokenization",
      "type": "method",
      "start_line": 127,
      "end_line": 132,
      "content_hash": "43dc694e1fac62e619be48dd7f6c9c80b3a89b33",
      "content": "    def test_pascal_case_tokenization(self):\n        \"\"\"PascalCase filenames should be properly tokenized.\"\"\"\n        q = \"database connection pool\"\n        cand = {\"path\": \"lib/DatabaseConnectionPool.java\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.5  # 3 matches",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_acronym_matching_134": {
      "name": "test_acronym_matching",
      "type": "method",
      "start_line": 134,
      "end_line": 139,
      "content_hash": "79b7e2d28d499a2dd3b3efbfa869725fd320010f",
      "content": "    def test_acronym_matching(self):\n        \"\"\"Acronyms like XMLParser should match 'xml parser'.\"\"\"\n        q = \"xml parser\"\n        cand = {\"path\": \"utils/XMLParser.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 2 exact matches",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_substring_matching_authenticate_auth_141": {
      "name": "test_substring_matching_authenticate_auth",
      "type": "method",
      "start_line": 141,
      "end_line": 146,
      "content_hash": "94a6dfe00ac4595ce7762671092159862ca8dd45",
      "content": "    def test_substring_matching_authenticate_auth(self):\n        \"\"\"'authenticate' contains 'auth', so substring tier can still match it.\"\"\"\n        q = \"authenticate user\"\n        cand = {\"path\": \"auth/UserAuth.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_substring_matching_configuration_config_148": {
      "name": "test_substring_matching_configuration_config",
      "type": "method",
      "start_line": 148,
      "end_line": 153,
      "content_hash": "731f111f23e464c81c048090800da75e1ffd982b",
      "content": "    def test_substring_matching_configuration_config(self):\n        \"\"\"'configuration' contains 'config', so substring tier can still match it.\"\"\"\n        q = \"configuration manager\"\n        cand = {\"path\": \"config/ConfigManager.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_directory_matching_155": {
      "name": "test_directory_matching",
      "type": "method",
      "start_line": 155,
      "end_line": 160,
      "content_hash": "aff68ec367996bd5e6dca5d72fcf355c87879411",
      "content": "    def test_directory_matching(self):\n        \"\"\"Query tokens should match directory names.\"\"\"\n        q = \"auth services controller\"\n        cand = {\"path\": \"services/auth/controller.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.4  # 3 matches across path",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_filename_bonus_162": {
      "name": "test_filename_bonus",
      "type": "method",
      "start_line": 162,
      "end_line": 171,
      "content_hash": "cb7f6f7f6bb46c92b85e62c07573e927a5a86b1f",
      "content": "    def test_filename_bonus(self):\n        \"\"\"Filename matches should score higher than directory matches.\"\"\"\n        q = \"auth handler\"\n        # Filename match\n        cand1 = {\"path\": \"services/AuthHandler.py\"}\n        # Directory match only\n        cand2 = {\"path\": \"auth/handler/index.py\"}\n        score1 = _compute_fname_boost(q, cand1, 0.15)\n        score2 = _compute_fname_boost(q, cand2, 0.15)\n        assert score1 > score2  # Filename match wins",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_deep_path_handling_173": {
      "name": "test_deep_path_handling",
      "type": "method",
      "start_line": 173,
      "end_line": 178,
      "content_hash": "6b8ce0e1168d60ebc2a596cbab7f94e398c27706",
      "content": "    def test_deep_path_handling(self):\n        \"\"\"Deep Java-style paths should work.\"\"\"\n        q = \"user service implementation\"\n        cand = {\"path\": \"src/main/java/com/company/user/service/UserServiceImpl.java\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3  # Should find matches",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_interface_prefix_stripped_180": {
      "name": "test_interface_prefix_stripped",
      "type": "method",
      "start_line": 180,
      "end_line": 185,
      "content_hash": "35bfab100295f2d98003ff8a1eb83953f34b7ec2",
      "content": "    def test_interface_prefix_stripped(self):\n        \"\"\"IUserService should match 'user service'.\"\"\"\n        q = \"user service\"\n        cand = {\"path\": \"interfaces/IUserService.ts\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_common_tokens_penalized_187": {
      "name": "test_common_tokens_penalized",
      "type": "method",
      "start_line": 187,
      "end_line": 193,
      "content_hash": "5ffafe39522130e9c17ce19dd9ff03f945911173",
      "content": "    def test_common_tokens_penalized(self):\n        \"\"\"Common tokens like 'utils', 'index' should be penalized.\"\"\"\n        q = \"auth utils\"\n        cand = {\"path\": \"utils/AuthUtils.py\"}  # common token 'utils'\n        score = _compute_fname_boost(q, cand, 0.15)\n        # Should still match, but common token gets penalty\n        assert score > 0",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_jsonish_query_195": {
      "name": "test_jsonish_query",
      "type": "method",
      "start_line": 195,
      "end_line": 200,
      "content_hash": "454e9adabe0bba45b7109b8e8e871841699a6d03",
      "content": "    def test_jsonish_query(self):\n        \"\"\"Handle queries wrapped in JSON-like brackets.\"\"\"\n        q = '[\"hybrid search fusion\"]'\n        cand = {\"path\": \"scripts/hybrid_search.py\"}\n        result = _compute_fname_boost(q, cand, 0.15)\n        assert result > 0.3",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}