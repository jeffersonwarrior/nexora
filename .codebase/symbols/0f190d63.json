{
  "file_path": "/work/.local/tools/modelscan/providers/mistral_test.go",
  "file_hash": "8f2587edc16387895675eacf55a1e5ad90bf304a",
  "updated_at": "2025-12-26T17:34:22.123421",
  "symbols": {
    "function_TestMistralProvider_TestModel_12": {
      "name": "TestMistralProvider_TestModel",
      "type": "function",
      "start_line": 12,
      "end_line": 46,
      "content_hash": "7a8ffd6f909280745feaeef18e66cd5684f5ed09",
      "content": "func TestMistralProvider_TestModel(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Bearer test-key\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\n\t\t\t\"id\": \"chat-test\",\n\t\t\t\"object\": \"chat.completion\",\n\t\t\t\"created\": 1234567890,\n\t\t\t\"model\": \"mistral-small-latest\",\n\t\t\t\"choices\": [{\n\t\t\t\t\"index\": 0,\n\t\t\t\t\"message\": {\"role\": \"assistant\", \"content\": \"test successful\"},\n\t\t\t\t\"finish_reason\": \"stop\"\n\t\t\t}],\n\t\t\t\"usage\": {\"prompt_tokens\": 5, \"completion_tokens\": 10, \"total_tokens\": 15}\n\t\t}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\t_ = provider.TestModel(ctx, \"mistral-small-latest\", false)\n\t_ = provider.TestModel(ctx, \"mistral-small-latest\", true)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_TestModel_Error_47": {
      "name": "TestMistralProvider_TestModel_Error",
      "type": "function",
      "start_line": 47,
      "end_line": 66,
      "content_hash": "24fd9c2abe0c5aa19ecffdd107d29b0cd4e79e9f",
      "content": "func TestMistralProvider_TestModel_Error(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(`{\"message\": \"invalid model\"}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\terr := provider.TestModel(ctx, \"invalid-model\", false)\n\tif err == nil {\n\t\tt.Error(\"Expected error for invalid model\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_TestModel_NetworkError_67": {
      "name": "TestMistralProvider_TestModel_NetworkError",
      "type": "function",
      "start_line": 67,
      "end_line": 80,
      "content_hash": "6b6ddadebd09c098c1df976bb81eff0a5ca448f5",
      "content": "func TestMistralProvider_TestModel_NetworkError(t *testing.T) {\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: \"http://invalid-url-test-case.local\",\n\t\tclient:  &http.Client{Timeout: 1 * time.Second},\n\t}\n\n\tctx := context.Background()\n\terr := provider.TestModel(ctx, \"mistral-small-latest\", false)\n\tif err == nil {\n\t\tt.Error(\"Expected error for network failure\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_HTTPMock_81": {
      "name": "TestMistralProvider_ListModels_HTTPMock",
      "type": "function",
      "start_line": 81,
      "end_line": 132,
      "content_hash": "c4fed2e2ad793cbde898ad3249bf4bb70c617fde",
      "content": "func TestMistralProvider_ListModels_HTTPMock(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Bearer test-key\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\n\t\t\t\"object\": \"list\",\n\t\t\t\"data\": [{\n\t\t\t\t\"id\": \"mistral-small-latest\",\n\t\t\t\t\"object\": \"model\",\n\t\t\t\t\"created\": 1234567890,\n\t\t\t\t\"owned_by\": \"mistralai\",\n\t\t\t\t\"capabilities\": {\n\t\t\t\t\t\"chat_completion\": true,\n\t\t\t\t\t\"text_embedding\": false,\n\t\t\t\t\t\"vision_capability\": \"limited\"\n\t\t\t\t}\n\t\t\t}]\n\t\t}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\tmodels, err := provider.ListModels(ctx, false)\n\tif err != nil {\n\t\tt.Fatalf(\"ListModels failed: %v\", err)\n\t}\n\n\tif len(models) != 1 {\n\t\tt.Errorf(\"Expected 1 model, got %d\", len(models))\n\t}\n\n\tif models[0].ID != \"mistral-small-latest\" {\n\t\tt.Errorf(\"Expected model ID mistral-small-latest, got %s\", models[0].ID)\n\t}\n\n\t// Check capabilities were parsed\n\tif models[0].Capabilities[\"chat_completion\"] != \"true\" {\n\t\tt.Error(\"Expected chat_completion capability to be 'true'\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_Verbose_133": {
      "name": "TestMistralProvider_ListModels_Verbose",
      "type": "function",
      "start_line": 133,
      "end_line": 179,
      "content_hash": "276a44dd28b1efe028ecba546fabb54df81bb5ef",
      "content": "func TestMistralProvider_ListModels_Verbose(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Bearer test-key\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\n\t\t\t\"object\": \"list\",\n\t\t\t\"data\": [{\n\t\t\t\t\"id\": \"mistral-large-latest\",\n\t\t\t\t\"object\": \"model\",\n\t\t\t\t\"created\": 1234567890,\n\t\t\t\t\"owned_by\": \"mistralai\"\n\t\t\t}]\n\t\t}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\tmodels, err := provider.ListModels(ctx, true)\n\tif err != nil {\n\t\tt.Fatalf(\"ListModels (verbose) failed: %v\", err)\n\t}\n\n\tif len(models) != 1 {\n\t\tt.Errorf(\"Expected 1 model in verbose mode, got %d\", len(models))\n\t}\n\n\t// Check that model details are preserved/enriched\n\tif models[0].Name == \"\" {\n\t\tt.Error(\"Expected model name to be populated in verbose mode\")\n\t}\n\n\tif models[0].Description == \"\" {\n\t\tt.Error(\"Expected model description to be populated in verbose mode\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_CapabilityTypes_180": {
      "name": "TestMistralProvider_ListModels_CapabilityTypes",
      "type": "function",
      "start_line": 180,
      "end_line": 225,
      "content_hash": "e5dba8c42af8dae754594c7d0956828f5206e272",
      "content": "func TestMistralProvider_ListModels_CapabilityTypes(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\n\t\t\t\"object\": \"list\",\n\t\t\t\"data\": [{\n\t\t\t\t\"id\": \"test-model\",\n\t\t\t\t\"capabilities\": {\n\t\t\t\t\t\"bool_true\": true,\n\t\t\t\t\t\"bool_false\": false,\n\t\t\t\t\t\"string_val\": \"supported\",\n\t\t\t\t\t\"number_val\": 12345\n\t\t\t\t}\n\t\t\t}]\n\t\t}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\tmodels, err := provider.ListModels(ctx, false)\n\tif err != nil {\n\t\tt.Fatalf(\"ListModels failed: %v\", err)\n\t}\n\n\t// Check all capability type conversions\n\tif models[0].Capabilities[\"bool_true\"] != \"true\" {\n\t\tt.Error(\"Expected bool_true to be 'true'\")\n\t}\n\tif models[0].Capabilities[\"bool_false\"] != \"false\" {\n\t\tt.Error(\"Expected bool_false to be 'false'\")\n\t}\n\tif models[0].Capabilities[\"string_val\"] != \"supported\" {\n\t\tt.Error(\"Expected string_val to be 'supported'\")\n\t}\n\tif models[0].Capabilities[\"number_val\"] == \"\" {\n\t\tt.Error(\"Expected number_val to be converted to string\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_EmptyResponse_226": {
      "name": "TestMistralProvider_ListModels_EmptyResponse",
      "type": "function",
      "start_line": 226,
      "end_line": 253,
      "content_hash": "407aac8e2ba48c2c12e42fe3d5b0607e6434b123",
      "content": "func TestMistralProvider_ListModels_EmptyResponse(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\n\t\t\t\"object\": \"list\",\n\t\t\t\"data\": []\n\t\t}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\tmodels, err := provider.ListModels(ctx, false)\n\tif err != nil {\n\t\tt.Fatalf(\"ListModels failed: %v\", err)\n\t}\n\n\tif len(models) != 0 {\n\t\tt.Errorf(\"Expected 0 models, got %d\", len(models))\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_InvalidJSON_254": {
      "name": "TestMistralProvider_ListModels_InvalidJSON",
      "type": "function",
      "start_line": 254,
      "end_line": 278,
      "content_hash": "ce5bf716f7171cc913a83973d24c5a2c91f288c2",
      "content": "func TestMistralProvider_ListModels_InvalidJSON(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`invalid json`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\t_, err := provider.ListModels(ctx, false)\n\tif err == nil {\n\t\tt.Error(\"Expected error for invalid JSON\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"invalid\") {\n\t\tt.Errorf(\"Expected error to contain 'invalid', got: %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ListModels_HTTPError_279": {
      "name": "TestMistralProvider_ListModels_HTTPError",
      "type": "function",
      "start_line": 279,
      "end_line": 302,
      "content_hash": "97ef1e3a2f6718d21b0f1a3b15e803edf9c28578",
      "content": "func TestMistralProvider_ListModels_HTTPError(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tw.Write([]byte(`{\"message\": \"unauthorized\"}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\t_, err := provider.ListModels(ctx, false)\n\tif err == nil {\n\t\tt.Error(\"Expected error for HTTP error\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"401\") {\n\t\tt.Errorf(\"Expected error to contain '401', got: %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestGuessMistralModelCategories_303": {
      "name": "TestGuessMistralModelCategories",
      "type": "function",
      "start_line": 303,
      "end_line": 322,
      "content_hash": "d48316bbb42cea163f1682bd2e5614ad58577e82",
      "content": "func TestGuessMistralModelCategories(t *testing.T) {\n\ttests := []struct {\n\t\tmodelID            string\n\t\texpectedCategories []string\n\t}{\n\t\t{\"codestral-latest\", []string{\"coding\"}},\n\t\t{\"mistral-small-latest\", []string{\"chat\"}},\n\t\t{\"mistral-embed\", []string{\"embedding\"}},\n\t\t{\"voxtral-1\", []string{\"audio\"}},\n\t\t{\"unknown-model\", []string{\"general\"}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tcategories := guessMistralModelCategories(tt.modelID)\n\t\tif len(categories) == 0 {\n\t\t\tt.Errorf(\"Expected categories for %s\", tt.modelID)\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_testPostEndpoint_ErrorHandling_323": {
      "name": "TestMistralProvider_testPostEndpoint_ErrorHandling",
      "type": "function",
      "start_line": 323,
      "end_line": 429,
      "content_hash": "3a0d891dbac80b53c0997cc90fe58dc7e2e1f94f",
      "content": "func TestMistralProvider_testPostEndpoint_ErrorHandling(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tstatusCode    int\n\t\tresponseBody  string\n\t\texpectedError bool\n\t\terrorContains string\n\t}{\n\t\t{\n\t\t\tname:          \"401 Unauthorized\",\n\t\t\tstatusCode:    401,\n\t\t\tresponseBody:  `{\"message\": \"unauthorized\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"401\",\n\t\t},\n\t\t{\n\t\t\tname:          \"403 Forbidden\",\n\t\t\tstatusCode:    403,\n\t\t\tresponseBody:  `{\"message\": \"forbidden\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"403\",\n\t\t},\n\t\t{\n\t\t\tname:          \"404 Not Found\",\n\t\t\tstatusCode:    404,\n\t\t\tresponseBody:  `{\"message\": \"not found\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"404\",\n\t\t},\n\t\t{\n\t\t\tname:          \"429 Rate Limited\",\n\t\t\tstatusCode:    429,\n\t\t\tresponseBody:  `{\"message\": \"rate limit exceeded\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"429\",\n\t\t},\n\t\t{\n\t\t\tname:          \"500 Server Error\",\n\t\t\tstatusCode:    500,\n\t\t\tresponseBody:  `{\"message\": \"internal server error\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"500\",\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid JSON Response\",\n\t\t\tstatusCode:    200,\n\t\t\tresponseBody:  `invalid json response`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:          \"Empty Response\",\n\t\t\tstatusCode:    200,\n\t\t\tresponseBody:  ``,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"empty\",\n\t\t},\n\t\t{\n\t\t\tname:          \"Valid Response\",\n\t\t\tstatusCode:    200,\n\t\t\tresponseBody:  `{\"id\": \"test\"}`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t// Verify Authorization header\n\t\t\t\tif r.Header.Get(\"Authorization\") != \"Bearer test-key\" {\n\t\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tw.WriteHeader(tt.statusCode)\n\t\t\t\tw.Write([]byte(tt.responseBody))\n\t\t\t}))\n\t\t\tdefer server.Close()\n\n\t\t\tprovider := &MistralProvider{\n\t\t\t\tapiKey:  \"test-key\",\n\t\t\t\tbaseURL: server.URL,\n\t\t\t\tclient:  &http.Client{Timeout: 1 * time.Second},\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tendpoint := &Endpoint{Path: \"/v1/chat/completions\", Method: \"POST\"}\n\n\t\t\terr := provider.testPostEndpoint(ctx, endpoint)\n\n\t\t\tif tt.expectedError && err == nil {\n\t\t\t\tt.Errorf(\"Expected error for %s, but got none\", tt.name)\n\t\t\t}\n\n\t\t\tif !tt.expectedError && err != nil {\n\t\t\t\tt.Errorf(\"Expected no error for %s, but got: %v\", tt.name, err)\n\t\t\t}\n\n\t\t\tif tt.expectedError && err != nil && tt.errorContains != \"\" {\n\t\t\t\tif !strings.Contains(err.Error(), tt.errorContains) {\n\t\t\t\t\tt.Errorf(\"Expected error to contain '%s', got: %v\", tt.errorContains, err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_testGetEndpoint_ErrorHandling_430": {
      "name": "TestMistralProvider_testGetEndpoint_ErrorHandling",
      "type": "function",
      "start_line": 430,
      "end_line": 501,
      "content_hash": "6070f4de6c13583aba102a33f2707c41b05d0ec8",
      "content": "func TestMistralProvider_testGetEndpoint_ErrorHandling(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tstatusCode    int\n\t\tresponseBody  string\n\t\texpectedError bool\n\t\terrorContains string\n\t}{\n\t\t{\n\t\t\tname:          \"401 Unauthorized\",\n\t\t\tstatusCode:    401,\n\t\t\tresponseBody:  `{\"message\": \"unauthorized\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"401\",\n\t\t},\n\t\t{\n\t\t\tname:          \"404 Not Found\",\n\t\t\tstatusCode:    404,\n\t\t\tresponseBody:  `{\"message\": \"not found\"}`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"404\",\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid JSON\",\n\t\t\tstatusCode:    200,\n\t\t\tresponseBody:  `invalid json`,\n\t\t\texpectedError: true,\n\t\t\terrorContains: \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:          \"Valid Response\",\n\t\t\tstatusCode:    200,\n\t\t\tresponseBody:  `{\"models\": []}`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tif r.Header.Get(\"Authorization\") != \"Bearer test-key\" {\n\t\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tw.WriteHeader(tt.statusCode)\n\t\t\t\tw.Write([]byte(tt.responseBody))\n\t\t\t}))\n\t\t\tdefer server.Close()\n\n\t\t\tprovider := &MistralProvider{\n\t\t\t\tapiKey:  \"test-key\",\n\t\t\t\tbaseURL: server.URL,\n\t\t\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tendpoint := &Endpoint{Path: \"/v1/models\", Method: \"GET\"}\n\n\t\t\terr := provider.testGetEndpoint(ctx, endpoint)\n\n\t\t\tif tt.expectedError && err == nil {\n\t\t\t\tt.Errorf(\"Expected error for %s, but got none\", tt.name)\n\t\t\t}\n\n\t\t\tif !tt.expectedError && err != nil {\n\t\t\t\tt.Errorf(\"Expected no error for %s, but got: %v\", tt.name, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_testEndpoint_InvalidMethod_502": {
      "name": "TestMistralProvider_testEndpoint_InvalidMethod",
      "type": "function",
      "start_line": 502,
      "end_line": 520,
      "content_hash": "8960f4dbbf8bb09c05d6fb39c218c4c643eb7a61",
      "content": "func TestMistralProvider_testEndpoint_InvalidMethod(t *testing.T) {\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: \"https://api.mistral.ai\",\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\n\t// Test with invalid method\n\tendpoint := &Endpoint{Path: \"/v1/test\", Method: \"INVALID\"}\n\terr := provider.testEndpoint(ctx, endpoint)\n\n\t// Should not panic and should handle gracefully\n\tif err == nil {\n\t\tt.Error(\"Expected error for invalid method, got nil\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ValidateEndpoints_521": {
      "name": "TestMistralProvider_ValidateEndpoints",
      "type": "function",
      "start_line": 521,
      "end_line": 542,
      "content_hash": "496b9143ad781a80c3a04a8835642d8c6291f6f4",
      "content": "func TestMistralProvider_ValidateEndpoints(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\"object\": \"list\", \"data\": []}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\terr := provider.ValidateEndpoints(ctx, false)\n\n\t// Should return nil (success) for valid setup\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, got: %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_ValidateEndpoints_WithErrors_543": {
      "name": "TestMistralProvider_ValidateEndpoints_WithErrors",
      "type": "function",
      "start_line": 543,
      "end_line": 565,
      "content_hash": "a8a932c42a6770486fbde2a68bffd7d85256517f",
      "content": "func TestMistralProvider_ValidateEndpoints_WithErrors(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Simulate 401 error\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tw.Write([]byte(`{\"error\": \"unauthorized\"}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"invalid-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 10 * time.Second},\n\t}\n\n\tctx := context.Background()\n\terr := provider.ValidateEndpoints(ctx, false)\n\n\t// Should return error for invalid key\n\tif err == nil {\n\t\tt.Error(\"Expected error for invalid API key\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_testEndpoint_Timeout_566": {
      "name": "TestMistralProvider_testEndpoint_Timeout",
      "type": "function",
      "start_line": 566,
      "end_line": 591,
      "content_hash": "9ee867b9e5b43b60d199e0918a5e96085fbd091b",
      "content": "func TestMistralProvider_testEndpoint_Timeout(t *testing.T) {\n\t// Create a server that delays response\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(5 * time.Second) // Delay longer than timeout\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\"message\": \"delayed response\"}`))\n\t}))\n\tdefer server.Close()\n\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: server.URL,\n\t\tclient:  &http.Client{Timeout: 1 * time.Second}, // Short timeout\n\t}\n\n\tctx := context.Background()\n\tendpoint := &Endpoint{Path: \"/v1/models\", Method: \"GET\"}\n\n\terr := provider.testEndpoint(ctx, endpoint)\n\n\t// Should timeout and return error\n\tif err == nil {\n\t\tt.Error(\"Expected timeout error, got nil\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_testEndpoint_NetworkError_592": {
      "name": "TestMistralProvider_testEndpoint_NetworkError",
      "type": "function",
      "start_line": 592,
      "end_line": 610,
      "content_hash": "4120f2a0f673b0505eafc96931a1f065b561b420",
      "content": "func TestMistralProvider_testEndpoint_NetworkError(t *testing.T) {\n\t// Create provider with invalid URL to simulate network error\n\tprovider := &MistralProvider{\n\t\tapiKey:  \"test-key\",\n\t\tbaseURL: \"http://invalid-url-that-does-not-exist.local\",\n\t\tclient:  &http.Client{Timeout: 5 * time.Second},\n\t}\n\n\tctx := context.Background()\n\tendpoint := &Endpoint{Path: \"/v1/models\", Method: \"GET\"}\n\n\terr := provider.testEndpoint(ctx, endpoint)\n\n\t// Should get network error\n\tif err == nil {\n\t\tt.Error(\"Expected network error, got nil\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMistralProvider_EnhanceModelInfo_Categories_611": {
      "name": "TestMistralProvider_EnhanceModelInfo_Categories",
      "type": "function",
      "start_line": 611,
      "end_line": 706,
      "content_hash": "624968057f1a2e8f7365af5cbe0dbf09f06183c1",
      "content": "func TestMistralProvider_EnhanceModelInfo_Categories(t *testing.T) {\n\tprovider := NewMistralProvider(\"test-key\")\n\tmistralProvider := provider.(*MistralProvider)\n\n\ttests := []struct {\n\t\tname              string\n\t\tmodelID           string\n\t\tsupportsImages    bool\n\t\tsupportsTools     bool\n\t\tcanReason         bool\n\t\texpectedCategory  string\n\t\texpectedVision    bool\n\t\texpectedFunction  bool\n\t\texpectedReasoning bool\n\t}{\n\t\t{\n\t\t\tname:             \"codestral\",\n\t\t\tmodelID:          \"codestral-latest\",\n\t\t\texpectedCategory: \"coding\",\n\t\t},\n\t\t{\n\t\t\tname:             \"mistral-small\",\n\t\t\tmodelID:          \"mistral-small-latest\",\n\t\t\texpectedCategory: \"chat\",\n\t\t},\n\t\t{\n\t\t\tname:             \"embed\",\n\t\t\tmodelID:          \"mistral-embed\",\n\t\t\texpectedCategory: \"embedding\",\n\t\t},\n\t\t{\n\t\t\tname:             \"voxtral\",\n\t\t\tmodelID:          \"voxtral-latest\",\n\t\t\texpectedCategory: \"audio\",\n\t\t},\n\t\t{\n\t\t\tname:             \"with vision capabilities\",\n\t\t\tmodelID:          \"custom-vision-model\",\n\t\t\tsupportsImages:   true,\n\t\t\texpectedCategory: \"\", // No category for unknown model\n\t\t\texpectedVision:   true,\n\t\t},\n\t\t{\n\t\t\tname:             \"with tools\",\n\t\t\tmodelID:          \"mistral-large-latest\",\n\t\t\tsupportsTools:    true,\n\t\t\texpectedCategory: \"chat\",\n\t\t\texpectedFunction: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"with reasoning\",\n\t\t\tmodelID:           \"mistral-large-latest\",\n\t\t\tcanReason:         true,\n\t\t\texpectedCategory:  \"chat\",\n\t\t\texpectedReasoning: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tmodel := &Model{\n\t\t\t\tID:             tt.modelID,\n\t\t\t\tSupportsImages: tt.supportsImages,\n\t\t\t\tSupportsTools:  tt.supportsTools,\n\t\t\t\tCanReason:      tt.canReason,\n\t\t\t}\n\n\t\t\tmistralProvider.enhanceModelInfo(model)\n\n\t\t\t// Check category (skip if empty expected)\n\t\t\tif tt.expectedCategory != \"\" {\n\t\t\t\tfound := false\n\t\t\t\tfor _, cat := range model.Categories {\n\t\t\t\t\tif cat == tt.expectedCategory {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !found {\n\t\t\t\t\tt.Errorf(\"Expected category %s in categories %v\", tt.expectedCategory, model.Categories)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check capabilities\n\t\t\tif tt.expectedVision && !model.SupportsImages {\n\t\t\t\tt.Error(\"Expected SupportsImages to be true\")\n\t\t\t}\n\t\t\tif tt.expectedFunction && !model.SupportsTools {\n\t\t\t\tt.Error(\"Expected SupportsTools to be true\")\n\t\t\t}\n\t\t\tif tt.expectedReasoning && !model.CanReason {\n\t\t\t\tt.Error(\"Expected CanReason to be true\")\n\t\t\t}\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}