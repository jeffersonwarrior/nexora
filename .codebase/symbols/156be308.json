{
  "file_path": "/work/external-deps/claude-mem/src/bin/import-xml-observations.ts",
  "file_hash": "e1ec9a06173b08bd6bfc9473128b66395c080569",
  "updated_at": "2025-12-26T17:34:21.432561",
  "symbols": {
    "function_buildTimestampMap_45": {
      "name": "buildTimestampMap",
      "type": "function",
      "start_line": 45,
      "end_line": 85,
      "content_hash": "3c3e5e27aed6a71d9608d95bbe8f3436c0c991a7",
      "content": "function buildTimestampMap(): TimestampMapping {\n  const transcriptDir = join(homedir(), '.claude', 'projects', '-Users-alexnewman-Scripts-claude-mem');\n  const map: TimestampMapping = {};\n\n  console.log(`Reading transcript files from ${transcriptDir}...`);\n\n  const files = readdirSync(transcriptDir).filter(f => f.endsWith('.jsonl'));\n  console.log(`Found ${files.length} transcript files`);\n\n  for (const filename of files) {\n    const filepath = join(transcriptDir, filename);\n    const content = readFileSync(filepath, 'utf-8');\n    const lines = content.split('\\n').filter(l => l.trim());\n\n    for (const line of lines) {\n      try {\n        const data = JSON.parse(line);\n        const timestamp = data.timestamp;\n        const sessionId = data.sessionId;\n        const project = data.cwd;\n\n        if (timestamp && sessionId) {\n          // Round timestamp to second for matching with XML timestamps\n          const roundedTimestamp = new Date(timestamp);\n          roundedTimestamp.setMilliseconds(0);\n          const key = roundedTimestamp.toISOString();\n\n          // Only store first occurrence for each second (they're all the same session anyway)\n          if (!map[key]) {\n            map[key] = { sessionId, project };\n          }\n        }\n      } catch (e) {\n        // Skip invalid JSON lines\n      }\n    }\n  }\n\n  console.log(`Built timestamp map with ${Object.keys(map).length} unique seconds`);\n  return map;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractTag_90": {
      "name": "extractTag",
      "type": "function",
      "start_line": 90,
      "end_line": 94,
      "content_hash": "2d4d6812ed30a323734b93be1e75f4d3baa4c869",
      "content": "function extractTag(xml: string, tagName: string): string {\n  const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)</${tagName}>`, 'i');\n  const match = xml.match(regex);\n  return match ? match[1].trim() : '';\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractArrayTags_99": {
      "name": "extractArrayTags",
      "type": "function",
      "start_line": 99,
      "end_line": 117,
      "content_hash": "472d49ebf94733ce0a53049e8222b561c10322f6",
      "content": "function extractArrayTags(xml: string, containerTag: string, itemTag: string): string[] {\n  const containerRegex = new RegExp(`<${containerTag}>([\\\\s\\\\S]*?)</${containerTag}>`, 'i');\n  const containerMatch = xml.match(containerRegex);\n\n  if (!containerMatch) {\n    return [];\n  }\n\n  const containerContent = containerMatch[1];\n  const itemRegex = new RegExp(`<${itemTag}>([\\\\s\\\\S]*?)</${itemTag}>`, 'gi');\n  const items: string[] = [];\n  let match;\n\n  while ((match = itemRegex.exec(containerContent)) !== null) {\n    items.push(match[1].trim());\n  }\n\n  return items;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_parseObservation_122": {
      "name": "parseObservation",
      "type": "function",
      "start_line": 122,
      "end_line": 150,
      "content_hash": "a3a10317411ccd8681d7cda9fd143caa296d708a",
      "content": "function parseObservation(xml: string): ObservationData | null {\n  // Must be a complete observation block\n  if (!xml.includes('<observation>') || !xml.includes('</observation>')) {\n    return null;\n  }\n\n  try {\n    const observation: ObservationData = {\n      type: extractTag(xml, 'type'),\n      title: extractTag(xml, 'title'),\n      subtitle: extractTag(xml, 'subtitle'),\n      facts: extractArrayTags(xml, 'facts', 'fact'),\n      narrative: extractTag(xml, 'narrative'),\n      concepts: extractArrayTags(xml, 'concepts', 'concept'),\n      files_read: extractArrayTags(xml, 'files_read', 'file'),\n      files_modified: extractArrayTags(xml, 'files_modified', 'file'),\n    };\n\n    // Validate required fields\n    if (!observation.type || !observation.title) {\n      return null;\n    }\n\n    return observation;\n  } catch (e) {\n    console.error('Error parsing observation:', e);\n    return null;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_parseSummary_155": {
      "name": "parseSummary",
      "type": "function",
      "start_line": 155,
      "end_line": 181,
      "content_hash": "b3b0896c7d14b7870ffc1eb9f8d633e3b38e5122",
      "content": "function parseSummary(xml: string): SummaryData | null {\n  // Must be a complete summary block\n  if (!xml.includes('<summary>') || !xml.includes('</summary>')) {\n    return null;\n  }\n\n  try {\n    const summary: SummaryData = {\n      request: extractTag(xml, 'request'),\n      investigated: extractTag(xml, 'investigated'),\n      learned: extractTag(xml, 'learned'),\n      completed: extractTag(xml, 'completed'),\n      next_steps: extractTag(xml, 'next_steps'),\n      notes: extractTag(xml, 'notes') || null,\n    };\n\n    // Validate required fields\n    if (!summary.request) {\n      return null;\n    }\n\n    return summary;\n  } catch (e) {\n    console.error('Error parsing summary:', e);\n    return null;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractTimestamp_187": {
      "name": "extractTimestamp",
      "type": "function",
      "start_line": 187,
      "end_line": 195,
      "content_hash": "f365c880eeb9ad63013d2517784cb5c96b6a4904",
      "content": "function extractTimestamp(commentLine: string): string | null {\n  const match = commentLine.match(/<!-- Block \\d+ \\| (.+?) -->/);\n  if (match) {\n    // Convert \"2025-10-19 03:03:23 UTC\" to ISO format\n    const dateStr = match[1].replace(' UTC', '').replace(' ', 'T') + 'Z';\n    return new Date(dateStr).toISOString();\n  }\n  return null;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_main_200": {
      "name": "main",
      "type": "function",
      "start_line": 200,
      "end_line": 377,
      "content_hash": "b011acf8d4dcb93996a99029c9666204fe696e86",
      "content": "function main() {\n  console.log('Starting XML observation import...\\n');\n\n  // Build timestamp map\n  const timestampMap = buildTimestampMap();\n\n  // Open database connection\n  const db = new SessionStore();\n\n  // Create SDK sessions for all unique Claude Code sessions\n  console.log('\\nCreating SDK sessions for imported data...');\n  const claudeSessionToSdkSession = new Map<string, string>();\n\n  for (const sessionMeta of Object.values(timestampMap)) {\n    if (!claudeSessionToSdkSession.has(sessionMeta.sessionId)) {\n      const syntheticSdkSessionId = `imported-${sessionMeta.sessionId}`;\n\n      // Try to find existing session first\n      const existingQuery = db['db'].prepare(`\n        SELECT sdk_session_id\n        FROM sdk_sessions\n        WHERE claude_session_id = ?\n      `);\n      const existing = existingQuery.get(sessionMeta.sessionId) as { sdk_session_id: string | null } | undefined;\n\n      if (existing && existing.sdk_session_id) {\n        // Use existing SDK session ID\n        claudeSessionToSdkSession.set(sessionMeta.sessionId, existing.sdk_session_id);\n      } else if (existing && !existing.sdk_session_id) {\n        // Session exists but sdk_session_id is NULL, update it\n        const dbId = (db['db'].prepare('SELECT id FROM sdk_sessions WHERE claude_session_id = ?').get(sessionMeta.sessionId) as { id: number }).id;\n        db.updateSDKSessionId(dbId, syntheticSdkSessionId);\n        claudeSessionToSdkSession.set(sessionMeta.sessionId, syntheticSdkSessionId);\n      } else {\n        // Create new SDK session\n        const dbId = db.createSDKSession(\n          sessionMeta.sessionId,\n          sessionMeta.project,\n          'Imported from transcript XML'\n        );\n\n        // Update with synthetic SDK session ID\n        db.updateSDKSessionId(dbId, syntheticSdkSessionId);\n\n        claudeSessionToSdkSession.set(sessionMeta.sessionId, syntheticSdkSessionId);\n      }\n    }\n  }\n\n  console.log(`Prepared ${claudeSessionToSdkSession.size} SDK sessions\\n`);\n\n  // Read XML file\n  const xmlPath = join(process.cwd(), 'actual_xml_only_with_timestamps.xml');\n  console.log(`Reading XML file: ${xmlPath}`);\n  const xmlContent = readFileSync(xmlPath, 'utf-8');\n\n  // Split into blocks by comment markers\n  const blocks = xmlContent.split(/(?=<!-- Block \\d+)/);\n  console.log(`Found ${blocks.length} blocks in XML file\\n`);\n\n  let importedObs = 0;\n  let importedSum = 0;\n  let skipped = 0;\n  let duplicateObs = 0;\n  let duplicateSum = 0;\n  let noSession = 0;\n\n  for (const block of blocks) {\n    if (!block.trim() || block.startsWith('<?xml') || block.startsWith('<transcript_extracts')) {\n      continue;\n    }\n\n    // Extract timestamp from comment\n    const timestampIso = extractTimestamp(block);\n    if (!timestampIso) {\n      skipped++;\n      continue;\n    }\n\n    // Look up session metadata\n    const sessionMeta = timestampMap[timestampIso];\n    if (!sessionMeta) {\n      noSession++;\n      if (noSession <= 5) {\n        console.log(`\u26a0\ufe0f  No session found for timestamp: ${timestampIso}`);\n      }\n      skipped++;\n      continue;\n    }\n\n    // Get SDK session ID\n    const sdkSessionId = claudeSessionToSdkSession.get(sessionMeta.sessionId);\n    if (!sdkSessionId) {\n      skipped++;\n      continue;\n    }\n\n    // Try parsing as observation first\n    const observation = parseObservation(block);\n    if (observation) {\n      // Check for duplicate\n      const existingObs = db['db'].prepare(`\n        SELECT id FROM observations\n        WHERE sdk_session_id = ? AND title = ? AND subtitle = ? AND type = ?\n      `).get(sdkSessionId, observation.title, observation.subtitle, observation.type);\n\n      if (existingObs) {\n        duplicateObs++;\n        continue;\n      }\n\n      try {\n        db.storeObservation(\n          sdkSessionId,\n          sessionMeta.project,\n          observation\n        );\n        importedObs++;\n\n        if (importedObs % 50 === 0) {\n          console.log(`Imported ${importedObs} observations...`);\n        }\n      } catch (e) {\n        console.error(`Error storing observation:`, e);\n        skipped++;\n      }\n      continue;\n    }\n\n    // Try parsing as summary\n    const summary = parseSummary(block);\n    if (summary) {\n      // Check for duplicate\n      const existingSum = db['db'].prepare(`\n        SELECT id FROM session_summaries\n        WHERE sdk_session_id = ? AND request = ? AND completed = ? AND learned = ?\n      `).get(sdkSessionId, summary.request, summary.completed, summary.learned);\n\n      if (existingSum) {\n        duplicateSum++;\n        continue;\n      }\n\n      try {\n        db.storeSummary(\n          sdkSessionId,\n          sessionMeta.project,\n          summary\n        );\n        importedSum++;\n\n        if (importedSum % 10 === 0) {\n          console.log(`Imported ${importedSum} summaries...`);\n        }\n      } catch (e) {\n        console.error(`Error storing summary:`, e);\n        skipped++;\n      }\n      continue;\n    }\n\n    // Neither observation nor summary - skip\n    skipped++;\n  }\n\n  db.close();\n\n  console.log('\\n' + '='.repeat(60));\n  console.log('Import Complete!');\n  console.log('='.repeat(60));\n  console.log(`\u2713 Imported: ${importedObs} observations`);\n  console.log(`\u2713 Imported: ${importedSum} summaries`);\n  console.log(`\u2713 Total: ${importedObs + importedSum} items`);\n  console.log(`\u2298 Skipped: ${skipped} blocks (not full observations or summaries)`);\n  console.log(`\u2298 Duplicates skipped: ${duplicateObs} observations, ${duplicateSum} summaries`);\n  console.log(`\u26a0\ufe0f  No session: ${noSession} blocks (timestamp not in transcripts)`);\n  console.log('='.repeat(60));\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}