{
  "file_path": "/work/external-deps/claude-mem/src/services/sqlite/SessionSearch.ts",
  "file_hash": "9c636277d5113e18ad90615453ef466c8cc415f6",
  "updated_at": "2025-12-26T17:34:23.911503",
  "symbols": {
    "class_SessionSearch_20": {
      "name": "SessionSearch",
      "type": "class",
      "start_line": 20,
      "end_line": 528,
      "content_hash": "e8fac70503e33756bd98010dbb364df64676731d",
      "content": "export class SessionSearch {\n  private db: Database;\n\n  constructor(dbPath?: string) {\n    if (!dbPath) {\n      ensureDir(DATA_DIR);\n      dbPath = DB_PATH;\n    }\n    this.db = new Database(dbPath);\n    this.db.run('PRAGMA journal_mode = WAL');\n\n    // Ensure FTS tables exist\n    this.ensureFTSTables();\n  }\n\n  /**\n   * Ensure FTS5 tables exist (backward compatibility only - no longer used for search)\n   *\n   * FTS5 tables are maintained for backward compatibility but not used for search.\n   * Vector search (Chroma) is now the primary search mechanism.\n   *\n   * Retention Rationale:\n   * - Prevents breaking existing installations with FTS5 tables\n   * - Allows graceful migration path for users\n   * - Tables maintained but search paths removed\n   * - Triggers still fire to keep tables synchronized\n   *\n   * Note: Using console.log for migration messages since they run during constructor\n   * before structured logger is available. Actual errors use console.error.\n   *\n   * TODO: Remove FTS5 infrastructure in future major version (v7.0.0)\n   */\n  private ensureFTSTables(): void {\n    // Check if FTS tables already exist\n    const tables = this.db.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%_fts'\").all() as TableNameRow[];\n    const hasFTS = tables.some(t => t.name === 'observations_fts' || t.name === 'session_summaries_fts');\n\n    if (hasFTS) {\n      // Already migrated\n      return;\n    }\n\n    console.log('[SessionSearch] Creating FTS5 tables...');\n\n    // Create observations_fts virtual table\n    this.db.run(`\n      CREATE VIRTUAL TABLE IF NOT EXISTS observations_fts USING fts5(\n        title,\n        subtitle,\n        narrative,\n        text,\n        facts,\n        concepts,\n        content='observations',\n        content_rowid='id'\n      );\n    `);\n\n    // Populate with existing data\n    this.db.run(`\n      INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n      SELECT id, title, subtitle, narrative, text, facts, concepts\n      FROM observations;\n    `);\n\n    // Create triggers for observations\n    this.db.run(`\n      CREATE TRIGGER IF NOT EXISTS observations_ai AFTER INSERT ON observations BEGIN\n        INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES (new.id, new.title, new.subtitle, new.narrative, new.text, new.facts, new.concepts);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS observations_ad AFTER DELETE ON observations BEGIN\n        INSERT INTO observations_fts(observations_fts, rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES('delete', old.id, old.title, old.subtitle, old.narrative, old.text, old.facts, old.concepts);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS observations_au AFTER UPDATE ON observations BEGIN\n        INSERT INTO observations_fts(observations_fts, rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES('delete', old.id, old.title, old.subtitle, old.narrative, old.text, old.facts, old.concepts);\n        INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES (new.id, new.title, new.subtitle, new.narrative, new.text, new.facts, new.concepts);\n      END;\n    `);\n\n    // Create session_summaries_fts virtual table\n    this.db.run(`\n      CREATE VIRTUAL TABLE IF NOT EXISTS session_summaries_fts USING fts5(\n        request,\n        investigated,\n        learned,\n        completed,\n        next_steps,\n        notes,\n        content='session_summaries',\n        content_rowid='id'\n      );\n    `);\n\n    // Populate with existing data\n    this.db.run(`\n      INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n      SELECT id, request, investigated, learned, completed, next_steps, notes\n      FROM session_summaries;\n    `);\n\n    // Create triggers for session_summaries\n    this.db.run(`\n      CREATE TRIGGER IF NOT EXISTS session_summaries_ai AFTER INSERT ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES (new.id, new.request, new.investigated, new.learned, new.completed, new.next_steps, new.notes);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS session_summaries_ad AFTER DELETE ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(session_summaries_fts, rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES('delete', old.id, old.request, old.investigated, old.learned, old.completed, old.next_steps, old.notes);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS session_summaries_au AFTER UPDATE ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(session_summaries_fts, rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES('delete', old.id, old.request, old.investigated, old.learned, old.completed, old.next_steps, old.notes);\n        INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES (new.id, new.request, new.investigated, new.learned, new.completed, new.next_steps, new.notes);\n      END;\n    `);\n\n    console.log('[SessionSearch] FTS5 tables created successfully');\n  }\n\n\n  /**\n   * Build WHERE clause for structured filters\n   */\n  private buildFilterClause(\n    filters: SearchFilters,\n    params: any[],\n    tableAlias: string = 'o'\n  ): string {\n    const conditions: string[] = [];\n\n    // Project filter\n    if (filters.project) {\n      conditions.push(`${tableAlias}.project = ?`);\n      params.push(filters.project);\n    }\n\n    // Type filter (for observations only)\n    if (filters.type) {\n      if (Array.isArray(filters.type)) {\n        const placeholders = filters.type.map(() => '?').join(',');\n        conditions.push(`${tableAlias}.type IN (${placeholders})`);\n        params.push(...filters.type);\n      } else {\n        conditions.push(`${tableAlias}.type = ?`);\n        params.push(filters.type);\n      }\n    }\n\n    // Date range filter\n    if (filters.dateRange) {\n      const { start, end } = filters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        conditions.push(`${tableAlias}.created_at_epoch >= ?`);\n        params.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        conditions.push(`${tableAlias}.created_at_epoch <= ?`);\n        params.push(endEpoch);\n      }\n    }\n\n    // Concepts filter (JSON array search)\n    if (filters.concepts) {\n      const concepts = Array.isArray(filters.concepts) ? filters.concepts : [filters.concepts];\n      const conceptConditions = concepts.map(() => {\n        return `EXISTS (SELECT 1 FROM json_each(${tableAlias}.concepts) WHERE value = ?)`;\n      });\n      if (conceptConditions.length > 0) {\n        conditions.push(`(${conceptConditions.join(' OR ')})`);\n        params.push(...concepts);\n      }\n    }\n\n    // Files filter (JSON array search)\n    if (filters.files) {\n      const files = Array.isArray(filters.files) ? filters.files : [filters.files];\n      const fileConditions = files.map(() => {\n        return `(\n          EXISTS (SELECT 1 FROM json_each(${tableAlias}.files_read) WHERE value LIKE ?)\n          OR EXISTS (SELECT 1 FROM json_each(${tableAlias}.files_modified) WHERE value LIKE ?)\n        )`;\n      });\n      if (fileConditions.length > 0) {\n        conditions.push(`(${fileConditions.join(' OR ')})`);\n        files.forEach(file => {\n          params.push(`%${file}%`, `%${file}%`);\n        });\n      }\n    }\n\n    return conditions.length > 0 ? conditions.join(' AND ') : '';\n  }\n\n  /**\n   * Build ORDER BY clause\n   */\n  private buildOrderClause(orderBy: SearchOptions['orderBy'] = 'relevance', hasFTS: boolean = true, ftsTable: string = 'observations_fts'): string {\n    switch (orderBy) {\n      case 'relevance':\n        return hasFTS ? `ORDER BY ${ftsTable}.rank ASC` : 'ORDER BY o.created_at_epoch DESC';\n      case 'date_desc':\n        return 'ORDER BY o.created_at_epoch DESC';\n      case 'date_asc':\n        return 'ORDER BY o.created_at_epoch ASC';\n      default:\n        return 'ORDER BY o.created_at_epoch DESC';\n    }\n  }\n\n  /**\n   * Search observations using filter-only direct SQLite query.\n   * Vector search is handled by ChromaDB - this only supports filtering without query text.\n   */\n  searchObservations(query: string | undefined, options: SearchOptions = {}): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // FILTER-ONLY PATH: When no query text, query table directly\n    // This enables date filtering which Chroma cannot do (requires direct SQLite access)\n    if (!query) {\n      const filterClause = this.buildFilterClause(filters, params, 'o');\n      if (!filterClause) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const orderClause = this.buildOrderClause(orderBy, false);\n\n      const sql = `\n        SELECT o.*, o.discovery_tokens\n        FROM observations o\n        WHERE ${filterClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }\n\n  /**\n   * Search session summaries using filter-only direct SQLite query.\n   * Vector search is handled by ChromaDB - this only supports filtering without query text.\n   */\n  searchSessions(query: string | undefined, options: SearchOptions = {}): SessionSummarySearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // FILTER-ONLY PATH: When no query text, query session_summaries table directly\n    if (!query) {\n      const filterOptions = { ...filters };\n      delete filterOptions.type;\n      const filterClause = this.buildFilterClause(filterOptions, params, 's');\n      if (!filterClause) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const orderClause = orderBy === 'date_asc'\n        ? 'ORDER BY s.created_at_epoch ASC'\n        : 'ORDER BY s.created_at_epoch DESC';\n\n      const sql = `\n        SELECT s.*, s.discovery_tokens\n        FROM session_summaries s\n        WHERE ${filterClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as SessionSummarySearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }\n\n  /**\n   * Find observations by concept tag\n   */\n  findByConcept(concept: string, options: SearchOptions = {}): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add concept to filters\n    const conceptFilters = { ...filters, concepts: concept };\n    const filterClause = this.buildFilterClause(conceptFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const sql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n  }\n\n  /**\n   * Find observations and summaries by file path\n   */\n  findByFile(filePath: string, options: SearchOptions = {}): {\n    observations: ObservationSearchResult[];\n    sessions: SessionSummarySearchResult[];\n  } {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add file to filters\n    const fileFilters = { ...filters, files: filePath };\n    const filterClause = this.buildFilterClause(fileFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const observationsSql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    const observations = this.db.prepare(observationsSql).all(...params) as ObservationSearchResult[];\n\n    // For session summaries, search files_read and files_edited\n    const sessionParams: any[] = [];\n    const sessionFilters = { ...filters };\n    delete sessionFilters.type; // Remove type filter for sessions\n\n    const baseConditions: string[] = [];\n    if (sessionFilters.project) {\n      baseConditions.push('s.project = ?');\n      sessionParams.push(sessionFilters.project);\n    }\n\n    if (sessionFilters.dateRange) {\n      const { start, end } = sessionFilters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        baseConditions.push('s.created_at_epoch >= ?');\n        sessionParams.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        baseConditions.push('s.created_at_epoch <= ?');\n        sessionParams.push(endEpoch);\n      }\n    }\n\n    // File condition\n    baseConditions.push(`(\n      EXISTS (SELECT 1 FROM json_each(s.files_read) WHERE value LIKE ?)\n      OR EXISTS (SELECT 1 FROM json_each(s.files_edited) WHERE value LIKE ?)\n    )`);\n    sessionParams.push(`%${filePath}%`, `%${filePath}%`);\n\n    const sessionsSql = `\n      SELECT s.*, s.discovery_tokens\n      FROM session_summaries s\n      WHERE ${baseConditions.join(' AND ')}\n      ORDER BY s.created_at_epoch DESC\n      LIMIT ? OFFSET ?\n    `;\n\n    sessionParams.push(limit, offset);\n\n    const sessions = this.db.prepare(sessionsSql).all(...sessionParams) as SessionSummarySearchResult[];\n\n    return { observations, sessions };\n  }\n\n  /**\n   * Find observations by type\n   */\n  findByType(\n    type: ObservationRow['type'] | ObservationRow['type'][],\n    options: SearchOptions = {}\n  ): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add type to filters\n    const typeFilters = { ...filters, type };\n    const filterClause = this.buildFilterClause(typeFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const sql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n  }\n\n  /**\n   * Search user prompts using filter-only direct SQLite query.\n   * Vector search is handled by ChromaDB - this only supports filtering without query text.\n   */\n  searchUserPrompts(query: string | undefined, options: SearchOptions = {}): UserPromptSearchResult[] {\n    const params: any[] = [];\n    const { limit = 20, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // Build filter conditions (join with sdk_sessions for project filtering)\n    const baseConditions: string[] = [];\n    if (filters.project) {\n      baseConditions.push('s.project = ?');\n      params.push(filters.project);\n    }\n\n    if (filters.dateRange) {\n      const { start, end } = filters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        baseConditions.push('up.created_at_epoch >= ?');\n        params.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        baseConditions.push('up.created_at_epoch <= ?');\n        params.push(endEpoch);\n      }\n    }\n\n    // FILTER-ONLY PATH: When no query text, query user_prompts table directly\n    if (!query) {\n      if (baseConditions.length === 0) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const whereClause = `WHERE ${baseConditions.join(' AND ')}`;\n      const orderClause = orderBy === 'date_asc'\n        ? 'ORDER BY up.created_at_epoch ASC'\n        : 'ORDER BY up.created_at_epoch DESC';\n\n      const sql = `\n        SELECT up.*\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        ${whereClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as UserPromptSearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }\n\n  /**\n   * Get all prompts for a session by claude_session_id\n   */\n  getUserPromptsBySession(claudeSessionId: string): UserPromptRow[] {\n    const stmt = this.db.prepare(`\n      SELECT\n        id,\n        claude_session_id,\n        prompt_number,\n        prompt_text,\n        created_at,\n        created_at_epoch\n      FROM user_prompts\n      WHERE claude_session_id = ?\n      ORDER BY prompt_number ASC\n    `);\n\n    return stmt.all(claudeSessionId) as UserPromptRow[];\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    this.db.close();\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_23": {
      "name": "constructor",
      "type": "method",
      "start_line": 23,
      "end_line": 33,
      "content_hash": "ac6bf6aeaaff6224793c568adcc615d508faefa1",
      "content": "  constructor(dbPath?: string) {\n    if (!dbPath) {\n      ensureDir(DATA_DIR);\n      dbPath = DB_PATH;\n    }\n    this.db = new Database(dbPath);\n    this.db.run('PRAGMA journal_mode = WAL');\n\n    // Ensure FTS tables exist\n    this.ensureFTSTables();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureFTSTables_52": {
      "name": "ensureFTSTables",
      "type": "method",
      "start_line": 52,
      "end_line": 147,
      "content_hash": "f326047c29c4daf43165c1ff76f24f04d13fa1dd",
      "content": "  private ensureFTSTables(): void {\n    // Check if FTS tables already exist\n    const tables = this.db.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%_fts'\").all() as TableNameRow[];\n    const hasFTS = tables.some(t => t.name === 'observations_fts' || t.name === 'session_summaries_fts');\n\n    if (hasFTS) {\n      // Already migrated\n      return;\n    }\n\n    console.log('[SessionSearch] Creating FTS5 tables...');\n\n    // Create observations_fts virtual table\n    this.db.run(`\n      CREATE VIRTUAL TABLE IF NOT EXISTS observations_fts USING fts5(\n        title,\n        subtitle,\n        narrative,\n        text,\n        facts,\n        concepts,\n        content='observations',\n        content_rowid='id'\n      );\n    `);\n\n    // Populate with existing data\n    this.db.run(`\n      INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n      SELECT id, title, subtitle, narrative, text, facts, concepts\n      FROM observations;\n    `);\n\n    // Create triggers for observations\n    this.db.run(`\n      CREATE TRIGGER IF NOT EXISTS observations_ai AFTER INSERT ON observations BEGIN\n        INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES (new.id, new.title, new.subtitle, new.narrative, new.text, new.facts, new.concepts);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS observations_ad AFTER DELETE ON observations BEGIN\n        INSERT INTO observations_fts(observations_fts, rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES('delete', old.id, old.title, old.subtitle, old.narrative, old.text, old.facts, old.concepts);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS observations_au AFTER UPDATE ON observations BEGIN\n        INSERT INTO observations_fts(observations_fts, rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES('delete', old.id, old.title, old.subtitle, old.narrative, old.text, old.facts, old.concepts);\n        INSERT INTO observations_fts(rowid, title, subtitle, narrative, text, facts, concepts)\n        VALUES (new.id, new.title, new.subtitle, new.narrative, new.text, new.facts, new.concepts);\n      END;\n    `);\n\n    // Create session_summaries_fts virtual table\n    this.db.run(`\n      CREATE VIRTUAL TABLE IF NOT EXISTS session_summaries_fts USING fts5(\n        request,\n        investigated,\n        learned,\n        completed,\n        next_steps,\n        notes,\n        content='session_summaries',\n        content_rowid='id'\n      );\n    `);\n\n    // Populate with existing data\n    this.db.run(`\n      INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n      SELECT id, request, investigated, learned, completed, next_steps, notes\n      FROM session_summaries;\n    `);\n\n    // Create triggers for session_summaries\n    this.db.run(`\n      CREATE TRIGGER IF NOT EXISTS session_summaries_ai AFTER INSERT ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES (new.id, new.request, new.investigated, new.learned, new.completed, new.next_steps, new.notes);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS session_summaries_ad AFTER DELETE ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(session_summaries_fts, rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES('delete', old.id, old.request, old.investigated, old.learned, old.completed, old.next_steps, old.notes);\n      END;\n\n      CREATE TRIGGER IF NOT EXISTS session_summaries_au AFTER UPDATE ON session_summaries BEGIN\n        INSERT INTO session_summaries_fts(session_summaries_fts, rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES('delete', old.id, old.request, old.investigated, old.learned, old.completed, old.next_steps, old.notes);\n        INSERT INTO session_summaries_fts(rowid, request, investigated, learned, completed, next_steps, notes)\n        VALUES (new.id, new.request, new.investigated, new.learned, new.completed, new.next_steps, new.notes);\n      END;\n    `);\n\n    console.log('[SessionSearch] FTS5 tables created successfully');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildFilterClause_153": {
      "name": "buildFilterClause",
      "type": "method",
      "start_line": 153,
      "end_line": 223,
      "content_hash": "db178c59b827a6812fbce7f4af8bc93eeec3e790",
      "content": "  private buildFilterClause(\n    filters: SearchFilters,\n    params: any[],\n    tableAlias: string = 'o'\n  ): string {\n    const conditions: string[] = [];\n\n    // Project filter\n    if (filters.project) {\n      conditions.push(`${tableAlias}.project = ?`);\n      params.push(filters.project);\n    }\n\n    // Type filter (for observations only)\n    if (filters.type) {\n      if (Array.isArray(filters.type)) {\n        const placeholders = filters.type.map(() => '?').join(',');\n        conditions.push(`${tableAlias}.type IN (${placeholders})`);\n        params.push(...filters.type);\n      } else {\n        conditions.push(`${tableAlias}.type = ?`);\n        params.push(filters.type);\n      }\n    }\n\n    // Date range filter\n    if (filters.dateRange) {\n      const { start, end } = filters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        conditions.push(`${tableAlias}.created_at_epoch >= ?`);\n        params.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        conditions.push(`${tableAlias}.created_at_epoch <= ?`);\n        params.push(endEpoch);\n      }\n    }\n\n    // Concepts filter (JSON array search)\n    if (filters.concepts) {\n      const concepts = Array.isArray(filters.concepts) ? filters.concepts : [filters.concepts];\n      const conceptConditions = concepts.map(() => {\n        return `EXISTS (SELECT 1 FROM json_each(${tableAlias}.concepts) WHERE value = ?)`;\n      });\n      if (conceptConditions.length > 0) {\n        conditions.push(`(${conceptConditions.join(' OR ')})`);\n        params.push(...concepts);\n      }\n    }\n\n    // Files filter (JSON array search)\n    if (filters.files) {\n      const files = Array.isArray(filters.files) ? filters.files : [filters.files];\n      const fileConditions = files.map(() => {\n        return `(\n          EXISTS (SELECT 1 FROM json_each(${tableAlias}.files_read) WHERE value LIKE ?)\n          OR EXISTS (SELECT 1 FROM json_each(${tableAlias}.files_modified) WHERE value LIKE ?)\n        )`;\n      });\n      if (fileConditions.length > 0) {\n        conditions.push(`(${fileConditions.join(' OR ')})`);\n        files.forEach(file => {\n          params.push(`%${file}%`, `%${file}%`);\n        });\n      }\n    }\n\n    return conditions.length > 0 ? conditions.join(' AND ') : '';\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildOrderClause_228": {
      "name": "buildOrderClause",
      "type": "method",
      "start_line": 228,
      "end_line": 239,
      "content_hash": "cd71a5450943a50a17abac6517f5e80f3960f62b",
      "content": "  private buildOrderClause(orderBy: SearchOptions['orderBy'] = 'relevance', hasFTS: boolean = true, ftsTable: string = 'observations_fts'): string {\n    switch (orderBy) {\n      case 'relevance':\n        return hasFTS ? `ORDER BY ${ftsTable}.rank ASC` : 'ORDER BY o.created_at_epoch DESC';\n      case 'date_desc':\n        return 'ORDER BY o.created_at_epoch DESC';\n      case 'date_asc':\n        return 'ORDER BY o.created_at_epoch ASC';\n      default:\n        return 'ORDER BY o.created_at_epoch DESC';\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchObservations_245": {
      "name": "searchObservations",
      "type": "method",
      "start_line": 245,
      "end_line": 275,
      "content_hash": "f2a74bea22dd64dca32f48d2a859c14d9a616023",
      "content": "  searchObservations(query: string | undefined, options: SearchOptions = {}): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // FILTER-ONLY PATH: When no query text, query table directly\n    // This enables date filtering which Chroma cannot do (requires direct SQLite access)\n    if (!query) {\n      const filterClause = this.buildFilterClause(filters, params, 'o');\n      if (!filterClause) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const orderClause = this.buildOrderClause(orderBy, false);\n\n      const sql = `\n        SELECT o.*, o.discovery_tokens\n        FROM observations o\n        WHERE ${filterClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchSessions_281": {
      "name": "searchSessions",
      "type": "method",
      "start_line": 281,
      "end_line": 314,
      "content_hash": "073c03d285c11b4dc719789f1c9962d68013a857",
      "content": "  searchSessions(query: string | undefined, options: SearchOptions = {}): SessionSummarySearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // FILTER-ONLY PATH: When no query text, query session_summaries table directly\n    if (!query) {\n      const filterOptions = { ...filters };\n      delete filterOptions.type;\n      const filterClause = this.buildFilterClause(filterOptions, params, 's');\n      if (!filterClause) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const orderClause = orderBy === 'date_asc'\n        ? 'ORDER BY s.created_at_epoch ASC'\n        : 'ORDER BY s.created_at_epoch DESC';\n\n      const sql = `\n        SELECT s.*, s.discovery_tokens\n        FROM session_summaries s\n        WHERE ${filterClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as SessionSummarySearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByConcept_319": {
      "name": "findByConcept",
      "type": "method",
      "start_line": 319,
      "end_line": 339,
      "content_hash": "d2f3f8ff859c848d384a12a4c675c5e94c00dae3",
      "content": "  findByConcept(concept: string, options: SearchOptions = {}): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add concept to filters\n    const conceptFilters = { ...filters, concepts: concept };\n    const filterClause = this.buildFilterClause(conceptFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const sql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByFile_344": {
      "name": "findByFile",
      "type": "method",
      "start_line": 344,
      "end_line": 413,
      "content_hash": "1936f499d08b31ebcc042f8ff197dc73129b345d",
      "content": "  findByFile(filePath: string, options: SearchOptions = {}): {\n    observations: ObservationSearchResult[];\n    sessions: SessionSummarySearchResult[];\n  } {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add file to filters\n    const fileFilters = { ...filters, files: filePath };\n    const filterClause = this.buildFilterClause(fileFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const observationsSql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    const observations = this.db.prepare(observationsSql).all(...params) as ObservationSearchResult[];\n\n    // For session summaries, search files_read and files_edited\n    const sessionParams: any[] = [];\n    const sessionFilters = { ...filters };\n    delete sessionFilters.type; // Remove type filter for sessions\n\n    const baseConditions: string[] = [];\n    if (sessionFilters.project) {\n      baseConditions.push('s.project = ?');\n      sessionParams.push(sessionFilters.project);\n    }\n\n    if (sessionFilters.dateRange) {\n      const { start, end } = sessionFilters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        baseConditions.push('s.created_at_epoch >= ?');\n        sessionParams.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        baseConditions.push('s.created_at_epoch <= ?');\n        sessionParams.push(endEpoch);\n      }\n    }\n\n    // File condition\n    baseConditions.push(`(\n      EXISTS (SELECT 1 FROM json_each(s.files_read) WHERE value LIKE ?)\n      OR EXISTS (SELECT 1 FROM json_each(s.files_edited) WHERE value LIKE ?)\n    )`);\n    sessionParams.push(`%${filePath}%`, `%${filePath}%`);\n\n    const sessionsSql = `\n      SELECT s.*, s.discovery_tokens\n      FROM session_summaries s\n      WHERE ${baseConditions.join(' AND ')}\n      ORDER BY s.created_at_epoch DESC\n      LIMIT ? OFFSET ?\n    `;\n\n    sessionParams.push(limit, offset);\n\n    const sessions = this.db.prepare(sessionsSql).all(...sessionParams) as SessionSummarySearchResult[];\n\n    return { observations, sessions };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByType_418": {
      "name": "findByType",
      "type": "method",
      "start_line": 418,
      "end_line": 441,
      "content_hash": "f507ca0538d34d41940a948d18442087624179a9",
      "content": "  findByType(\n    type: ObservationRow['type'] | ObservationRow['type'][],\n    options: SearchOptions = {}\n  ): ObservationSearchResult[] {\n    const params: any[] = [];\n    const { limit = 50, offset = 0, orderBy = 'date_desc', ...filters } = options;\n\n    // Add type to filters\n    const typeFilters = { ...filters, type };\n    const filterClause = this.buildFilterClause(typeFilters, params, 'o');\n    const orderClause = this.buildOrderClause(orderBy, false);\n\n    const sql = `\n      SELECT o.*, o.discovery_tokens\n      FROM observations o\n      WHERE ${filterClause}\n      ${orderClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    params.push(limit, offset);\n\n    return this.db.prepare(sql).all(...params) as ObservationSearchResult[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchUserPrompts_447": {
      "name": "searchUserPrompts",
      "type": "method",
      "start_line": 447,
      "end_line": 500,
      "content_hash": "b02081e8c4cbd46ed0967e29a4ec2e24c4776219",
      "content": "  searchUserPrompts(query: string | undefined, options: SearchOptions = {}): UserPromptSearchResult[] {\n    const params: any[] = [];\n    const { limit = 20, offset = 0, orderBy = 'relevance', ...filters } = options;\n\n    // Build filter conditions (join with sdk_sessions for project filtering)\n    const baseConditions: string[] = [];\n    if (filters.project) {\n      baseConditions.push('s.project = ?');\n      params.push(filters.project);\n    }\n\n    if (filters.dateRange) {\n      const { start, end } = filters.dateRange;\n      if (start) {\n        const startEpoch = typeof start === 'number' ? start : new Date(start).getTime();\n        baseConditions.push('up.created_at_epoch >= ?');\n        params.push(startEpoch);\n      }\n      if (end) {\n        const endEpoch = typeof end === 'number' ? end : new Date(end).getTime();\n        baseConditions.push('up.created_at_epoch <= ?');\n        params.push(endEpoch);\n      }\n    }\n\n    // FILTER-ONLY PATH: When no query text, query user_prompts table directly\n    if (!query) {\n      if (baseConditions.length === 0) {\n        throw new Error('Either query or filters required for search');\n      }\n\n      const whereClause = `WHERE ${baseConditions.join(' AND ')}`;\n      const orderClause = orderBy === 'date_asc'\n        ? 'ORDER BY up.created_at_epoch ASC'\n        : 'ORDER BY up.created_at_epoch DESC';\n\n      const sql = `\n        SELECT up.*\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        ${whereClause}\n        ${orderClause}\n        LIMIT ? OFFSET ?\n      `;\n\n      params.push(limit, offset);\n      return this.db.prepare(sql).all(...params) as UserPromptSearchResult[];\n    }\n\n    // Vector search with query text should be handled by ChromaDB\n    // This method only supports filter-only queries (query=undefined)\n    console.warn('[SessionSearch] Text search not supported - use ChromaDB for vector search');\n    return [];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getUserPromptsBySession_505": {
      "name": "getUserPromptsBySession",
      "type": "method",
      "start_line": 505,
      "end_line": 520,
      "content_hash": "f30cc6f4b58cfbc7e18002ebba0d1c9ad338ab5d",
      "content": "  getUserPromptsBySession(claudeSessionId: string): UserPromptRow[] {\n    const stmt = this.db.prepare(`\n      SELECT\n        id,\n        claude_session_id,\n        prompt_number,\n        prompt_text,\n        created_at,\n        created_at_epoch\n      FROM user_prompts\n      WHERE claude_session_id = ?\n      ORDER BY prompt_number ASC\n    `);\n\n    return stmt.all(claudeSessionId) as UserPromptRow[];\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_close_525": {
      "name": "close",
      "type": "method",
      "start_line": 525,
      "end_line": 527,
      "content_hash": "dc791efba3a659c6cd0f129154be1ecbbae87054",
      "content": "  close(): void {\n    this.db.close();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}