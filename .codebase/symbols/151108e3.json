{
  "file_path": "/work/internal/fsext/ls.go",
  "file_hash": "36e860883470213d65a4ed43398eb0228166da2d",
  "updated_at": "2025-12-26T17:34:21.771261",
  "symbols": {
    "struct_directoryLister_98": {
      "name": "directoryLister",
      "type": "struct",
      "start_line": 98,
      "end_line": 102,
      "content_hash": "a3340351bcfc4de786f011e7d140fd36354f274d",
      "content": "type directoryLister struct {\n\tignores  *csync.Map[string, ignore.IgnoreParser]\n\trootPath string\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewDirectoryLister_103": {
      "name": "NewDirectoryLister",
      "type": "function",
      "start_line": 103,
      "end_line": 124,
      "content_hash": "955da2fa04d30c11fc740089363b121627d757b3",
      "content": "func NewDirectoryLister(rootPath string) *directoryLister {\n\tdl := &directoryLister{\n\t\trootPath: rootPath,\n\t\tignores:  csync.NewMap[string, ignore.IgnoreParser](),\n\t}\n\tdl.getIgnore(rootPath)\n\treturn dl\n}\n\n// git checks, in order:\n// - ./.gitignore, ../.gitignore, etc, until repo root\n// ~/.config/git/ignore\n// ~/.gitignore\n//\n// This will do the following:\n// - the given ignorePatterns\n// - [commonIgnorePatterns]\n// - ./.gitignore, ../.gitignore, etc, until dl.rootPath\n// - ./.nexoraignore, ../.nexoraignore, etc, until dl.rootPath\n// ~/.config/git/ignore\n// ~/.gitignore\n// ~/.config/nexora/ignore",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldIgnore_125": {
      "name": "shouldIgnore",
      "type": "method",
      "start_line": 125,
      "end_line": 175,
      "content_hash": "67f4d6ce5fc8fb73a0569a8ed508068e449dd297",
      "content": "func (dl *directoryLister) shouldIgnore(path string, ignorePatterns []string) bool {\n\tif len(ignorePatterns) > 0 {\n\t\tbase := filepath.Base(path)\n\t\tfor _, pattern := range ignorePatterns {\n\t\t\tif matched, err := filepath.Match(pattern, base); err == nil && matched {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// Don't apply gitignore rules to the root directory itself\n\t// In gitignore semantics, patterns don't apply to the repo root\n\tif path == dl.rootPath {\n\t\treturn false\n\t}\n\n\trelPath, err := filepath.Rel(dl.rootPath, path)\n\tif err != nil {\n\t\trelPath = path\n\t}\n\n\tif commonIgnorePatterns().MatchesPath(relPath) {\n\t\tslog.Debug(\"ignoring common pattern\", \"path\", relPath)\n\t\treturn true\n\t}\n\n\tparentDir := filepath.Dir(path)\n\tignoreParser := dl.getIgnore(parentDir)\n\tif ignoreParser.MatchesPath(relPath) {\n\t\tslog.Debug(\"ignoring dir pattern\", \"path\", relPath, \"dir\", parentDir)\n\t\treturn true\n\t}\n\n\t// For directories, also check with trailing slash (gitignore convention)\n\tif ignoreParser.MatchesPath(relPath + \"/\") {\n\t\tslog.Debug(\"ignoring dir pattern with slash\", \"path\", relPath+\"/\", \"dir\", parentDir)\n\t\treturn true\n\t}\n\n\tif dl.checkParentIgnores(relPath) {\n\t\treturn true\n\t}\n\n\tif homeIgnore().MatchesPath(relPath) {\n\t\tslog.Debug(\"ignoring home dir pattern\", \"path\", relPath)\n\t\treturn true\n\t}\n\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkParentIgnores_176": {
      "name": "checkParentIgnores",
      "type": "method",
      "start_line": 176,
      "end_line": 190,
      "content_hash": "b49964a078430359efb880385464da6557a70921",
      "content": "func (dl *directoryLister) checkParentIgnores(path string) bool {\n\tparent := filepath.Dir(filepath.Dir(path))\n\tfor parent != \".\" && path != \".\" {\n\t\tif dl.getIgnore(parent).MatchesPath(path) {\n\t\t\tslog.Debug(\"ingoring parent dir pattern\", \"path\", path, \"dir\", parent)\n\t\t\treturn true\n\t\t}\n\t\tif parent == dl.rootPath {\n\t\t\tbreak\n\t\t}\n\t\tparent = filepath.Dir(parent)\n\t}\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getIgnore_191": {
      "name": "getIgnore",
      "type": "method",
      "start_line": 191,
      "end_line": 208,
      "content_hash": "9064a2f350f454313b8597bb4e6923bc723ff00f",
      "content": "func (dl *directoryLister) getIgnore(path string) ignore.IgnoreParser {\n\treturn dl.ignores.GetOrSet(path, func() ignore.IgnoreParser {\n\t\tvar lines []string\n\t\tfor _, ign := range []string{\".nexoraignore\", \".gitignore\"} {\n\t\t\tname := filepath.Join(path, ign)\n\t\t\tif content, err := os.ReadFile(name); err == nil {\n\t\t\t\tlines = append(lines, strings.Split(string(content), \"\\n\")...)\n\t\t\t}\n\t\t}\n\t\tif len(lines) == 0 {\n\t\t\t// Return a no-op parser to avoid nil checks\n\t\t\treturn ignore.CompileIgnoreLines()\n\t\t}\n\t\treturn ignore.CompileIgnoreLines(lines...)\n\t})\n}\n\n// ListDirectory lists files and directories in the specified path,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ListDirectory_209": {
      "name": "ListDirectory",
      "type": "function",
      "start_line": 209,
      "end_line": 253,
      "content_hash": "96b6446ecce097365f8573f80519bdad46e411d5",
      "content": "func ListDirectory(initialPath string, ignorePatterns []string, depth, limit int) ([]string, bool, error) {\n\tfound := csync.NewSlice[string]()\n\tdl := NewDirectoryLister(initialPath)\n\n\tslog.Debug(\"listing directory\", \"path\", initialPath, \"depth\", depth, \"limit\", limit, \"ignorePatterns\", ignorePatterns)\n\n\tconf := fastwalk.Config{\n\t\tFollow:   true,\n\t\tToSlash:  fastwalk.DefaultToSlash(),\n\t\tSort:     fastwalk.SortDirsFirst,\n\t\tMaxDepth: depth,\n\t}\n\n\terr := fastwalk.Walk(&conf, initialPath, func(path string, d os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn nil // Skip files we don't have permission to access\n\t\t}\n\n\t\tif dl.shouldIgnore(path, ignorePatterns) {\n\t\t\tif d.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif path != initialPath {\n\t\t\tif d.IsDir() {\n\t\t\t\tpath = path + string(filepath.Separator)\n\t\t\t}\n\t\t\tfound.Append(path)\n\t\t}\n\n\t\tif limit > 0 && found.Len() >= limit {\n\t\t\treturn filepath.SkipAll\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil && !errors.Is(err, filepath.SkipAll) {\n\t\treturn nil, false, err\n\t}\n\n\tmatches, truncated := truncate(slices.Collect(found.Seq()), limit)\n\treturn matches, truncated || errors.Is(err, filepath.SkipAll), nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}