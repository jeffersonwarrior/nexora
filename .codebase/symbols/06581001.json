{
  "file_path": "/work/internal/agent/tools/mcp/reliability.go",
  "file_hash": "ec6d772560528cb200442ae6483822f1a0de65a8",
  "updated_at": "2025-12-26T17:34:20.458452",
  "symbols": {
    "struct_RetryConfig_19": {
      "name": "RetryConfig",
      "type": "struct",
      "start_line": 19,
      "end_line": 36,
      "content_hash": "f13ed0acaab13aa827d500600278ef59b02dca51",
      "content": "type RetryConfig struct {\n\t// MaxRetries is the maximum number of retry attempts (0 = no retries)\n\tMaxRetries int\n\n\t// InitialDelay is the initial delay between retries\n\tInitialDelay time.Duration\n\n\t// MaxDelay is the maximum delay between retries\n\tMaxDelay time.Duration\n\n\t// Multiplier is the factor by which delay increases each retry\n\tMultiplier float64\n\n\t// Jitter adds randomness to prevent thundering herd (0.0 to 1.0)\n\tJitter float64\n}\n\n// DefaultRetryConfig returns sensible defaults for MCP retry behavior",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_DefaultRetryConfig_37": {
      "name": "DefaultRetryConfig",
      "type": "function",
      "start_line": 37,
      "end_line": 47,
      "content_hash": "29a77711de9c8b4e0fc5f14dee91429cb43b655d",
      "content": "func DefaultRetryConfig() RetryConfig {\n\treturn RetryConfig{\n\t\tMaxRetries:   3,\n\t\tInitialDelay: 1 * time.Second,\n\t\tMaxDelay:     30 * time.Second,\n\t\tMultiplier:   2.0,\n\t\tJitter:       0.1,\n\t}\n}\n\n// calculateBackoff calculates the delay for a given retry attempt using exponential backoff",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_calculateBackoff_48": {
      "name": "calculateBackoff",
      "type": "function",
      "start_line": 48,
      "end_line": 64,
      "content_hash": "b6c381fcb8e3d3aeb1a9aeadf85c0f455cc39818",
      "content": "func calculateBackoff(cfg RetryConfig, attempt int) time.Duration {\n\tif attempt <= 0 {\n\t\treturn cfg.InitialDelay\n\t}\n\n\tdelay := float64(cfg.InitialDelay) * math.Pow(cfg.Multiplier, float64(attempt))\n\tif delay > float64(cfg.MaxDelay) {\n\t\tdelay = float64(cfg.MaxDelay)\n\t}\n\n\t// Note: jitter would require randomness but we keep it deterministic for testing\n\t// In production, you might add: delay += delay * cfg.Jitter * (rand.Float64()*2 - 1)\n\n\treturn time.Duration(delay)\n}\n\n// ConnectionError wraps MCP connection errors with additional context",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ConnectionError_65": {
      "name": "ConnectionError",
      "type": "struct",
      "start_line": 65,
      "end_line": 72,
      "content_hash": "26a29340293635078f6a3f0288b93118a1741ff2",
      "content": "type ConnectionError struct {\n\tMCPName   string\n\tType      string\n\tAttempt   int\n\tCause     error\n\tTimestamp time.Time\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Error_73": {
      "name": "Error",
      "type": "method",
      "start_line": 73,
      "end_line": 76,
      "content_hash": "e24942e71a9729e9cb85c7072c3039f36bf49fd1",
      "content": "func (e *ConnectionError) Error() string {\n\treturn fmt.Sprintf(\"MCP '%s' connection error (attempt %d): %v\", e.MCPName, e.Attempt, e.Cause)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Unwrap_77": {
      "name": "Unwrap",
      "type": "method",
      "start_line": 77,
      "end_line": 81,
      "content_hash": "5b845b1d65e38ca1096cbd312a7ad7e479d1b234",
      "content": "func (e *ConnectionError) Unwrap() error {\n\treturn e.Cause\n}\n\n// IsRetryable checks if the error is retryable",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsRetryable_82": {
      "name": "IsRetryable",
      "type": "method",
      "start_line": 82,
      "end_line": 112,
      "content_hash": "734b925315c649f55d88705a263ba9f35a250166",
      "content": "func (e *ConnectionError) IsRetryable() bool {\n\tif e.Cause == nil {\n\t\treturn false\n\t}\n\n\t// Context cancelled/deadline exceeded are not retryable\n\tif errors.Is(e.Cause, context.Canceled) || errors.Is(e.Cause, context.DeadlineExceeded) {\n\t\treturn false\n\t}\n\n\t// Check for common retryable conditions\n\terrStr := e.Cause.Error()\n\tretryablePatterns := []string{\n\t\t\"connection refused\",\n\t\t\"connection reset\",\n\t\t\"EOF\",\n\t\t\"timeout\",\n\t\t\"temporary failure\",\n\t\t\"no such host\",\n\t\t\"network is unreachable\",\n\t}\n\n\tfor _, pattern := range retryablePatterns {\n\t\tif containsIgnoreCase(errStr, pattern) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_containsIgnoreCase_113": {
      "name": "containsIgnoreCase",
      "type": "function",
      "start_line": 113,
      "end_line": 116,
      "content_hash": "36694b80fa2732f433c93bed681c1940418d218b",
      "content": "func containsIgnoreCase(s, substr string) bool {\n\treturn len(s) >= len(substr) && (s == substr || len(s) > len(substr) && findIgnoreCase(s, substr))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_findIgnoreCase_117": {
      "name": "findIgnoreCase",
      "type": "function",
      "start_line": 117,
      "end_line": 135,
      "content_hash": "0e180f9f60155eff591fe8e4c954c290feddf753",
      "content": "func findIgnoreCase(s, substr string) bool {\n\tfor i := 0; i <= len(s)-len(substr); i++ {\n\t\tmatch := true\n\t\tfor j := 0; j < len(substr); j++ {\n\t\t\tsc, subc := s[i+j], substr[j]\n\t\t\t// Simple ASCII case-insensitive comparison\n\t\t\tif sc != subc && (sc^32) != subc && sc != (subc^32) {\n\t\t\t\tmatch = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif match {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// HealthStatus represents the health status of an MCP connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HealthStatus_136": {
      "name": "HealthStatus",
      "type": "struct",
      "start_line": 136,
      "end_line": 145,
      "content_hash": "5a932a5de550e96e85359609fef7421ec9aaf69d",
      "content": "type HealthStatus struct {\n\tName          string\n\tHealthy       bool\n\tLastCheck     time.Time\n\tLastError     error\n\tConsecutiveFails int\n\tLatency       time.Duration\n}\n\n// HealthMonitor monitors the health of MCP connections",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_HealthMonitor_146": {
      "name": "HealthMonitor",
      "type": "struct",
      "start_line": 146,
      "end_line": 154,
      "content_hash": "7ad2796bb4ae68c169ff1d618c1592a32ecd5090",
      "content": "type HealthMonitor struct {\n\tmu           sync.RWMutex\n\thealthStatus map[string]*HealthStatus\n\tcheckInterval time.Duration\n\tcancel       context.CancelFunc\n\trunning      bool\n}\n\n// NewHealthMonitor creates a new health monitor",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewHealthMonitor_155": {
      "name": "NewHealthMonitor",
      "type": "function",
      "start_line": 155,
      "end_line": 165,
      "content_hash": "2a95db62587b08b5f085150a46f52249a294b768",
      "content": "func NewHealthMonitor(checkInterval time.Duration) *HealthMonitor {\n\tif checkInterval <= 0 {\n\t\tcheckInterval = 30 * time.Second\n\t}\n\treturn &HealthMonitor{\n\t\thealthStatus: make(map[string]*HealthStatus),\n\t\tcheckInterval: checkInterval,\n\t}\n}\n\n// Start begins periodic health checks for all MCP connections",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Start_166": {
      "name": "Start",
      "type": "method",
      "start_line": 166,
      "end_line": 181,
      "content_hash": "883f74790f1c3b45a8aa06f46d876755b05b98c5",
      "content": "func (m *HealthMonitor) Start(ctx context.Context) {\n\tm.mu.Lock()\n\tif m.running {\n\t\tm.mu.Unlock()\n\t\treturn\n\t}\n\tm.running = true\n\n\tmonitorCtx, cancel := context.WithCancel(ctx)\n\tm.cancel = cancel\n\tm.mu.Unlock()\n\n\tgo m.runHealthChecks(monitorCtx)\n}\n\n// Stop stops the health monitor",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Stop_182": {
      "name": "Stop",
      "type": "method",
      "start_line": 182,
      "end_line": 192,
      "content_hash": "6bdd7bf39834766d9f9654fa15eec06aa16206c5",
      "content": "func (m *HealthMonitor) Stop() {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tif m.cancel != nil {\n\t\tm.cancel()\n\t}\n\tm.running = false\n}\n\n// runHealthChecks performs periodic health checks",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_runHealthChecks_193": {
      "name": "runHealthChecks",
      "type": "method",
      "start_line": 193,
      "end_line": 207,
      "content_hash": "ad9446fd9905764af74f38c7e7779dc33ff38ab2",
      "content": "func (m *HealthMonitor) runHealthChecks(ctx context.Context) {\n\tticker := time.NewTicker(m.checkInterval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tm.checkAllConnections(ctx)\n\t\t}\n\t}\n}\n\n// checkAllConnections checks the health of all active MCP connections",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkAllConnections_208": {
      "name": "checkAllConnections",
      "type": "method",
      "start_line": 208,
      "end_line": 214,
      "content_hash": "c6cb5e6023b77ac1cc011966abf85375d08b7eaf",
      "content": "func (m *HealthMonitor) checkAllConnections(ctx context.Context) {\n\tfor name := range sessions.Seq2() {\n\t\tgo m.checkConnection(ctx, name)\n\t}\n}\n\n// checkConnection checks the health of a single MCP connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkConnection_215": {
      "name": "checkConnection",
      "type": "method",
      "start_line": 215,
      "end_line": 262,
      "content_hash": "2d2b0dbabeaff4bc78bd49eb1696862501e76a30",
      "content": "func (m *HealthMonitor) checkConnection(ctx context.Context, name string) {\n\tsession, ok := sessions.Get(name)\n\tif !ok {\n\t\treturn\n\t}\n\n\tcheckCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tstart := time.Now()\n\terr := session.Ping(checkCtx, nil)\n\tlatency := time.Since(start)\n\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tstatus, exists := m.healthStatus[name]\n\tif !exists {\n\t\tstatus = &HealthStatus{Name: name}\n\t\tm.healthStatus[name] = status\n\t}\n\n\tstatus.LastCheck = time.Now()\n\tstatus.Latency = latency\n\n\tif err != nil {\n\t\tstatus.Healthy = false\n\t\tstatus.LastError = err\n\t\tstatus.ConsecutiveFails++\n\n\t\tslog.Warn(\"MCP health check failed\",\n\t\t\t\"name\", name,\n\t\t\t\"error\", err,\n\t\t\t\"consecutive_fails\", status.ConsecutiveFails,\n\t\t)\n\n\t\t// Trigger reconnection if too many consecutive failures\n\t\tif status.ConsecutiveFails >= 3 {\n\t\t\tgo m.triggerReconnect(context.Background(), name)\n\t\t}\n\t} else {\n\t\tstatus.Healthy = true\n\t\tstatus.LastError = nil\n\t\tstatus.ConsecutiveFails = 0\n\t}\n}\n\n// triggerReconnect attempts to reconnect an unhealthy MCP connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_triggerReconnect_263": {
      "name": "triggerReconnect",
      "type": "method",
      "start_line": 263,
      "end_line": 367,
      "content_hash": "92339842058487c57d42cfcab7a540149fbbb7c1",
      "content": "func (m *HealthMonitor) triggerReconnect(ctx context.Context, name string) {\n\tcfg := config.Get()\n\tmcpConfig, ok := cfg.MCP[name]\n\tif !ok || mcpConfig.Disabled {\n\t\treturn\n\t}\n\n\tslog.Info(\"Attempting to reconnect MCP\", \"name\", name)\n\n\tretryCfg := DefaultRetryConfig()\n\tvar lastErr error\n\n\tfor attempt := 0; attempt <= retryCfg.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tdelay := calculateBackoff(retryCfg, attempt-1)\n\t\t\tslog.Debug(\"Waiting before retry\", \"name\", name, \"delay\", delay, \"attempt\", attempt)\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-time.After(delay):\n\t\t\t}\n\t\t}\n\n\t\tupdateState(name, StateStarting, nil, nil, Counts{})\n\n\t\tsession, err := createSession(ctx, name, mcpConfig, cfg.Resolver())\n\t\tif err != nil {\n\t\t\tlastErr = &ConnectionError{\n\t\t\t\tMCPName:   name,\n\t\t\t\tType:      string(mcpConfig.Type),\n\t\t\t\tAttempt:   attempt + 1,\n\t\t\t\tCause:     err,\n\t\t\t\tTimestamp: time.Now(),\n\t\t\t}\n\n\t\t\tconnErr, ok := lastErr.(*ConnectionError)\n\t\t\tif !ok || !connErr.IsRetryable() {\n\t\t\t\tslog.Error(\"MCP reconnection failed (non-retryable)\",\n\t\t\t\t\t\"name\", name,\n\t\t\t\t\t\"error\", err,\n\t\t\t\t)\n\t\t\t\tupdateState(name, StateError, lastErr, nil, Counts{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tslog.Warn(\"MCP reconnection attempt failed\",\n\t\t\t\t\"name\", name,\n\t\t\t\t\"attempt\", attempt+1,\n\t\t\t\t\"error\", err,\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get tools and prompts for the new session\n\t\ttools, err := getTools(ctx, session)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Error listing tools after reconnection\", \"name\", name, \"error\", err)\n\t\t\tsession.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tprompts, err := getPrompts(ctx, session)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Error listing prompts after reconnection\", \"name\", name, \"error\", err)\n\t\t\tsession.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tupdateTools(name, tools)\n\t\tupdatePrompts(name, prompts)\n\t\tsessions.Set(name, session)\n\n\t\tupdateState(name, StateConnected, nil, session, Counts{\n\t\t\tTools:   len(tools),\n\t\t\tPrompts: len(prompts),\n\t\t})\n\n\t\tslog.Info(\"MCP reconnected successfully\",\n\t\t\t\"name\", name,\n\t\t\t\"tools\", len(tools),\n\t\t\t\"prompts\", len(prompts),\n\t\t)\n\n\t\t// Reset health status\n\t\tm.mu.Lock()\n\t\tif status, exists := m.healthStatus[name]; exists {\n\t\t\tstatus.Healthy = true\n\t\t\tstatus.LastError = nil\n\t\t\tstatus.ConsecutiveFails = 0\n\t\t}\n\t\tm.mu.Unlock()\n\n\t\treturn\n\t}\n\n\t// All retries exhausted\n\tupdateState(name, StateError, lastErr, nil, Counts{})\n\tslog.Error(\"MCP reconnection failed after all retries\",\n\t\t\"name\", name,\n\t\t\"max_retries\", retryCfg.MaxRetries,\n\t)\n}\n\n// GetHealthStatus returns the health status of an MCP connection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetHealthStatus_368": {
      "name": "GetHealthStatus",
      "type": "method",
      "start_line": 368,
      "end_line": 379,
      "content_hash": "4bbcc1c2822dd678181b79617085dde3f2d0a1a2",
      "content": "func (m *HealthMonitor) GetHealthStatus(name string) (HealthStatus, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tstatus, ok := m.healthStatus[name]\n\tif !ok {\n\t\treturn HealthStatus{}, false\n\t}\n\treturn *status, true\n}\n\n// GetAllHealthStatus returns the health status of all MCP connections",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetAllHealthStatus_380": {
      "name": "GetAllHealthStatus",
      "type": "method",
      "start_line": 380,
      "end_line": 397,
      "content_hash": "3310b9ccca533dd384b89f176801d8e7d88c2163",
      "content": "func (m *HealthMonitor) GetAllHealthStatus() map[string]HealthStatus {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tresult := make(map[string]HealthStatus, len(m.healthStatus))\n\tfor name, status := range m.healthStatus {\n\t\tresult[name] = *status\n\t}\n\treturn result\n}\n\n// Global health monitor instance\nvar (\n\tglobalHealthMonitor     *HealthMonitor\n\tglobalHealthMonitorOnce sync.Once\n)\n\n// GetHealthMonitor returns the global health monitor instance",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_GetHealthMonitor_398": {
      "name": "GetHealthMonitor",
      "type": "function",
      "start_line": 398,
      "end_line": 405,
      "content_hash": "f5e4793d6f16ff7b6b389eb329791073db76d4ca",
      "content": "func GetHealthMonitor() *HealthMonitor {\n\tglobalHealthMonitorOnce.Do(func() {\n\t\tglobalHealthMonitor = NewHealthMonitor(30 * time.Second)\n\t})\n\treturn globalHealthMonitor\n}\n\n// StartHealthMonitoring starts the global health monitor",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_StartHealthMonitoring_406": {
      "name": "StartHealthMonitoring",
      "type": "function",
      "start_line": 406,
      "end_line": 410,
      "content_hash": "df847543b76f1e2a0ce2cf17305bbfce73885743",
      "content": "func StartHealthMonitoring(ctx context.Context) {\n\tGetHealthMonitor().Start(ctx)\n}\n\n// StopHealthMonitoring stops the global health monitor",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_StopHealthMonitoring_411": {
      "name": "StopHealthMonitoring",
      "type": "function",
      "start_line": 411,
      "end_line": 417,
      "content_hash": "13add53bcfb70eabe5787b86f1b578389af99291",
      "content": "func StopHealthMonitoring() {\n\tif globalHealthMonitor != nil {\n\t\tglobalHealthMonitor.Stop()\n\t}\n}\n\n// getOrRenewClientWithRetry is a drop-in replacement for getOrRenewClient with retry logic",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_getOrRenewClientWithRetry_418": {
      "name": "getOrRenewClientWithRetry",
      "type": "function",
      "start_line": 418,
      "end_line": 459,
      "content_hash": "9a4b9dd3a82edc2bf590c3029d607a15afe0509e",
      "content": "func getOrRenewClientWithRetry(ctx context.Context, name string, retryCfg RetryConfig) (*mcp.ClientSession, error) {\n\tvar lastErr error\n\n\tfor attempt := 0; attempt <= retryCfg.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tdelay := calculateBackoff(retryCfg, attempt-1)\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn nil, ctx.Err()\n\t\t\tcase <-time.After(delay):\n\t\t\t}\n\t\t}\n\n\t\tsession, err := getOrRenewClient(ctx, name)\n\t\tif err == nil {\n\t\t\treturn session, nil\n\t\t}\n\n\t\tlastErr = &ConnectionError{\n\t\t\tMCPName:   name,\n\t\t\tAttempt:   attempt + 1,\n\t\t\tCause:     err,\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\n\t\tconnErr := lastErr.(*ConnectionError)\n\t\tif !connErr.IsRetryable() {\n\t\t\treturn nil, lastErr\n\t\t}\n\n\t\tslog.Debug(\"MCP client operation failed, retrying\",\n\t\t\t\"name\", name,\n\t\t\t\"attempt\", attempt+1,\n\t\t\t\"error\", err,\n\t\t)\n\t}\n\n\treturn nil, lastErr\n}\n\n// EnsureConnection ensures an MCP connection is available, attempting to establish one if needed",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_EnsureConnection_460": {
      "name": "EnsureConnection",
      "type": "function",
      "start_line": 460,
      "end_line": 540,
      "content_hash": "6e37346451282b4f638fb1b54268514798be956c",
      "content": "func EnsureConnection(ctx context.Context, name string) error {\n\tstate, ok := states.Get(name)\n\tif !ok {\n\t\treturn fmt.Errorf(\"MCP '%s' not configured\", name)\n\t}\n\n\tif state.State == StateConnected {\n\t\t// Verify connection is still valid\n\t\tif session, sessionOk := sessions.Get(name); sessionOk {\n\t\t\tpingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tif err := session.Ping(pingCtx, nil); err == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif state.State == StateDisabled {\n\t\treturn fmt.Errorf(\"MCP '%s' is disabled\", name)\n\t}\n\n\t// Try to reconnect\n\tcfg := config.Get()\n\tmcpConfig, ok := cfg.MCP[name]\n\tif !ok {\n\t\treturn fmt.Errorf(\"MCP '%s' configuration not found\", name)\n\t}\n\n\tretryCfg := DefaultRetryConfig()\n\tvar lastErr error\n\n\tfor attempt := 0; attempt <= retryCfg.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tdelay := calculateBackoff(retryCfg, attempt-1)\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase <-time.After(delay):\n\t\t\t}\n\t\t}\n\n\t\tsession, err := createSession(ctx, name, mcpConfig, cfg.Resolver())\n\t\tif err != nil {\n\t\t\tlastErr = &ConnectionError{\n\t\t\t\tMCPName:   name,\n\t\t\t\tType:      string(mcpConfig.Type),\n\t\t\t\tAttempt:   attempt + 1,\n\t\t\t\tCause:     err,\n\t\t\t\tTimestamp: time.Now(),\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\ttools, err := getTools(ctx, session)\n\t\tif err != nil {\n\t\t\tsession.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tprompts, err := getPrompts(ctx, session)\n\t\tif err != nil {\n\t\t\tsession.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tupdateTools(name, tools)\n\t\tupdatePrompts(name, prompts)\n\t\tsessions.Set(name, session)\n\t\tupdateState(name, StateConnected, nil, session, Counts{\n\t\t\tTools:   len(tools),\n\t\t\tPrompts: len(prompts),\n\t\t})\n\n\t\treturn nil\n\t}\n\n\treturn lastErr\n}\n\n// MCPError represents a categorized MCP error",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_MCPError_541": {
      "name": "MCPError",
      "type": "struct",
      "start_line": 541,
      "end_line": 562,
      "content_hash": "c6580e35fe644285e79b696d1a3787cb922d40c2",
      "content": "type MCPError struct {\n\tCode    MCPErrorCode\n\tMessage string\n\tDetails map[string]any\n\tCause   error\n}\n\n// MCPErrorCode categorizes MCP errors\ntype MCPErrorCode int\n\nconst (\n\tErrCodeUnknown MCPErrorCode = iota\n\tErrCodeNotConfigured\n\tErrCodeDisabled\n\tErrCodeConnectionFailed\n\tErrCodeTimeout\n\tErrCodeToolNotFound\n\tErrCodeToolExecutionFailed\n\tErrCodeInvalidInput\n\tErrCodePermissionDenied\n)\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Error_563": {
      "name": "Error",
      "type": "method",
      "start_line": 563,
      "end_line": 569,
      "content_hash": "f95f46180d76347488a7601a7026efa21f9439a8",
      "content": "func (e *MCPError) Error() string {\n\tif e.Cause != nil {\n\t\treturn fmt.Sprintf(\"[%s] %s: %v\", e.Code.String(), e.Message, e.Cause)\n\t}\n\treturn fmt.Sprintf(\"[%s] %s\", e.Code.String(), e.Message)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Unwrap_570": {
      "name": "Unwrap",
      "type": "method",
      "start_line": 570,
      "end_line": 573,
      "content_hash": "0874b952a096a49d909bbf45f4a0023ac1e80ae1",
      "content": "func (e *MCPError) Unwrap() error {\n\treturn e.Cause\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_String_574": {
      "name": "String",
      "type": "method",
      "start_line": 574,
      "end_line": 597,
      "content_hash": "48441935074234d9a0abff390389c6c84e51415d",
      "content": "func (c MCPErrorCode) String() string {\n\tswitch c {\n\tcase ErrCodeNotConfigured:\n\t\treturn \"NOT_CONFIGURED\"\n\tcase ErrCodeDisabled:\n\t\treturn \"DISABLED\"\n\tcase ErrCodeConnectionFailed:\n\t\treturn \"CONNECTION_FAILED\"\n\tcase ErrCodeTimeout:\n\t\treturn \"TIMEOUT\"\n\tcase ErrCodeToolNotFound:\n\t\treturn \"TOOL_NOT_FOUND\"\n\tcase ErrCodeToolExecutionFailed:\n\t\treturn \"TOOL_EXECUTION_FAILED\"\n\tcase ErrCodeInvalidInput:\n\t\treturn \"INVALID_INPUT\"\n\tcase ErrCodePermissionDenied:\n\t\treturn \"PERMISSION_DENIED\"\n\tdefault:\n\t\treturn \"UNKNOWN\"\n\t}\n}\n\n// NewMCPError creates a new categorized MCP error",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMCPError_598": {
      "name": "NewMCPError",
      "type": "function",
      "start_line": 598,
      "end_line": 606,
      "content_hash": "9358f6510e85a3b1d5e303aed778a13c29ce7f95",
      "content": "func NewMCPError(code MCPErrorCode, message string, cause error) *MCPError {\n\treturn &MCPError{\n\t\tCode:    code,\n\t\tMessage: message,\n\t\tCause:   cause,\n\t}\n}\n\n// NewMCPErrorWithDetails creates a new categorized MCP error with additional details",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMCPErrorWithDetails_607": {
      "name": "NewMCPErrorWithDetails",
      "type": "function",
      "start_line": 607,
      "end_line": 616,
      "content_hash": "0f61ffc71e7963b9ea355f1d1a97d06826f7d529",
      "content": "func NewMCPErrorWithDetails(code MCPErrorCode, message string, details map[string]any, cause error) *MCPError {\n\treturn &MCPError{\n\t\tCode:    code,\n\t\tMessage: message,\n\t\tDetails: details,\n\t\tCause:   cause,\n\t}\n}\n\n// WrapError wraps an error with MCP context",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_WrapError_617": {
      "name": "WrapError",
      "type": "function",
      "start_line": 617,
      "end_line": 645,
      "content_hash": "43e19863bdabc8b601194a4f87a44e1be7f8d391",
      "content": "func WrapError(err error, mcpName string) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// Detect error type and categorize\n\tif errors.Is(err, context.DeadlineExceeded) {\n\t\treturn NewMCPError(ErrCodeTimeout, fmt.Sprintf(\"MCP '%s' operation timed out\", mcpName), err)\n\t}\n\n\tif errors.Is(err, context.Canceled) {\n\t\treturn NewMCPError(ErrCodeConnectionFailed, fmt.Sprintf(\"MCP '%s' operation was canceled\", mcpName), err)\n\t}\n\n\terrStr := err.Error()\n\tif containsIgnoreCase(errStr, \"not configured\") || containsIgnoreCase(errStr, \"not found\") {\n\t\treturn NewMCPError(ErrCodeNotConfigured, fmt.Sprintf(\"MCP '%s' is not configured\", mcpName), err)\n\t}\n\n\tif containsIgnoreCase(errStr, \"disabled\") {\n\t\treturn NewMCPError(ErrCodeDisabled, fmt.Sprintf(\"MCP '%s' is disabled\", mcpName), err)\n\t}\n\n\tif containsIgnoreCase(errStr, \"connection\") || containsIgnoreCase(errStr, \"EOF\") {\n\t\treturn NewMCPError(ErrCodeConnectionFailed, fmt.Sprintf(\"MCP '%s' connection failed\", mcpName), err)\n\t}\n\n\treturn NewMCPError(ErrCodeUnknown, fmt.Sprintf(\"MCP '%s' error\", mcpName), err)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}