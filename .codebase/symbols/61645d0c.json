{
  "file_path": "/work/internal/cmd/root.go",
  "file_hash": "ef0a49dc3e92bee114768e38fe61b4d327c803c5",
  "updated_at": "2025-12-26T17:34:21.823872",
  "symbols": {
    "function_init_33": {
      "name": "init",
      "type": "function",
      "start_line": 33,
      "end_line": 146,
      "content_hash": "f122667c43ace7ad7dbf88a62b557fdec51836d9",
      "content": "func init() {\n\trootCmd.PersistentFlags().StringP(\"cwd\", \"c\", \"\", \"Current working directory\")\n\trootCmd.PersistentFlags().StringP(\"data-dir\", \"D\", \"\", \"Custom nexora data directory\")\n\trootCmd.PersistentFlags().BoolP(\"debug\", \"d\", false, \"Debug\")\n\trootCmd.Flags().BoolP(\"help\", \"h\", false, \"Help\")\n\trootCmd.Flags().BoolP(\"yolo\", \"y\", false, \"Automatically accept all permissions (dangerous mode)\")\n\n\trootCmd.AddCommand(\n\t\trunCmd,\n\t\tdirsCmd,\n\t\tupdateProvidersCmd,\n\t\tlogsCmd,\n\t\tschemaCmd,\n\t\tloginCmd,\n\t\tsuggestToolsCmd,\n\t\tindexCmd,\n\t\taiopsCmd,\n\t)\n}\n\nvar rootCmd = &cobra.Command{\n\tUse:   \"nexora\",\n\tShort: \"Terminal-based AI assistant for software development\",\n\tLong: `Nexora is a powerful terminal-based AI assistant that helps with software development tasks.\nIt provides an interactive chat interface with AI capabilities, code analysis, and LSP integration\nto assist developers in writing, debugging, and understanding code directly from the terminal.`,\n\tExample: `\n# Run in interactive mode\nnexora\n\n# Run with debug logging\nnexora -d\n\n# Run with debug logging in a specific directory\nnexora -d -c /path/to/project\n\n# Run with custom data directory\nnexora -D /path/to/custom/.nexora\n\n# Print version\nnexora -v\n\n# Run a single non-interactive prompt\nnexora run \"Explain the use of context in Go\"\n\n# Run in dangerous mode (auto-accept all permissions)\nnexora -y\n  `,\n\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t// Ensure working directory is set correctly for all commands\n\t\t_, err := ResolveCwd(cmd)\n\t\treturn err\n\t},\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tif flag.Lookup(\"test.v\") != nil {\n\t\t\t// Don't run the TUI or setup the app in tests.\n\t\t\treturn nil\n\t\t}\n\n\t\tvar runErr error\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\t// Convert panic to error\n\t\t\t\tif rerr, ok := r.(error); ok {\n\t\t\t\t\trunErr = fmt.Errorf(\"unexpected panic: %w\", rerr)\n\t\t\t\t} else {\n\t\t\t\t\trunErr = fmt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t\tslog.Error(\"Root command panic\", \"error\", runErr)\n\t\t\t}\n\t\t}()\n\n\t\tapp, err := setupAppWithProgressBar(cmd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer app.Shutdown()\n\n\t\t// Set up the TUI with minimal configuration to avoid epoll issues\n\t\tui := tui.New(app)\n\t\tui.QueryVersion = shouldQueryTerminalVersion(os.Environ())\n\n\t\tprogram := tea.NewProgram(ui)\n\t\tgo app.Subscribe(program)\n\n\t\tif _, err := program.Run(); err != nil {\n\t\t\tslog.Error(\"TUI run error\", \"error\", err)\n\t\t\treturn err\n\t\t}\n\t\treturn runErr\n\t},\n\tPostRun: func(cmd *cobra.Command, args []string) {\n\t},\n}\n\nvar heartbit = lipgloss.NewStyle().Foreground(charmtone.Dolly).SetString(`\n    \u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584    \u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n       \u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\n           \u2580\u2580\u2580\u2580\u2580\u2580\n`)\n\n// copied from cobra:\nconst defaultVersionTemplate = `{{with .DisplayName}}{{printf \"%s \" .}}{{end}}{{printf \"version %s\" .Version}}\n`\n\n// isInputAvailable checks if stdin is available for reading",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_isInputAvailable_147": {
      "name": "isInputAvailable",
      "type": "function",
      "start_line": 147,
      "end_line": 157,
      "content_hash": "9309b0984794c49cf39b2524540a0c13e788faf1",
      "content": "func isInputAvailable() bool {\n\tstat, err := os.Stdin.Stat()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// Check if it's a character device (terminal) or other valid input\n\treturn (stat.Mode()&os.ModeCharDevice) != 0 ||\n\t\t(stat.Mode()&os.ModeNamedPipe) != 0\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_Execute_158": {
      "name": "Execute",
      "type": "function",
      "start_line": 158,
      "end_line": 183,
      "content_hash": "07a3dbf030d9f02cbd9660278142343df31a2ba9",
      "content": "func Execute() error {\n\t// NOTE: very hacky: we create a colorprofile writer with STDOUT, then make\n\t// it forward to a bytes.Buffer, write the colored heartbit to it, and then\n\t// finally prepend it in the version template.\n\t// Unfortunately cobra doesn't give us a way to set a function to handle\n\t// printing the version, and PreRunE runs after the version is already\n\t// handled, so that doesn't work either.\n\t// This is the only way I could find that works relatively well.\n\tif term.IsTerminal(os.Stdout.Fd()) {\n\t\tvar b bytes.Buffer\n\t\tw := colorprofile.NewWriter(os.Stdout, os.Environ())\n\t\tw.Forward = &b\n\t\t_, _ = w.WriteString(heartbit.String())\n\t\trootCmd.SetVersionTemplate(b.String() + \"\\n\" + defaultVersionTemplate)\n\t}\n\tif err := fang.Execute(\n\t\tcontext.Background(),\n\t\trootCmd,\n\t\tfang.WithVersion(version.Version),\n\t\tfang.WithNotifySignal(os.Interrupt),\n\t); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setupAppWithProgressBar_184": {
      "name": "setupAppWithProgressBar",
      "type": "function",
      "start_line": 184,
      "end_line": 194,
      "content_hash": "144195ef3569a46b3db03774c18e8decd8e7e4ae",
      "content": "func setupAppWithProgressBar(cmd *cobra.Command) (*app.App, error) {\n\tif termutil.SupportsProgressBar() {\n\t\t_, _ = fmt.Fprintf(os.Stderr, ansi.SetIndeterminateProgressBar)\n\t\tdefer func() { _, _ = fmt.Fprintf(os.Stderr, ansi.ResetProgressBar) }()\n\t}\n\n\treturn setupApp(cmd)\n}\n\n// setupApp handles the common setup logic for both interactive and non-interactive modes.\n// It returns the app instance, config, cleanup function, and any error.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setupApp_195": {
      "name": "setupApp",
      "type": "function",
      "start_line": 195,
      "end_line": 264,
      "content_hash": "66dc0048984e9789b7ce6c358eb27cb90bbfaafe",
      "content": "func setupApp(cmd *cobra.Command) (*app.App, error) {\n\tdebug, _ := cmd.Flags().GetBool(\"debug\")\n\tyolo, _ := cmd.Flags().GetBool(\"yolo\")\n\tdataDir, _ := cmd.Flags().GetString(\"data-dir\")\n\tctx := cmd.Context()\n\n\tcwd, err := ResolveCwd(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcfg, err := config.Init(cwd, dataDir, debug)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Permissions == nil {\n\t\tcfg.Permissions = &config.Permissions{}\n\t}\n\tcfg.Permissions.SkipRequests = yolo\n\n\tif err := createDotNexoraDir(cfg.Options.DataDirectory); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check and install essential tools for AI operations\n\tinstallManager := tools.NewInstallManager()\n\tif err := installManager.CheckAndInstallAIRelevantTools(ctx); err != nil {\n\t\tslog.Warn(\"Failed to install some AI-relevant tools\", \"error\", err)\n\t\t// Continue anyway - tools not strictly required\n\t}\n\n\t// Connect to DB; this will also run migrations.\n\tconn, err := db.Connect(ctx, cfg.Options.DataDirectory)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tappInstance, err := app.New(ctx, conn, cfg)\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"large model provider not configured\") ||\n\t\t\tstrings.Contains(err.Error(), \"small model provider not configured\") ||\n\t\t\tstrings.Contains(err.Error(), \"large model not selected\") ||\n\t\t\tstrings.Contains(err.Error(), \"small model not selected\") {\n\t\t\t// Models are not configured, but we'll still create the app and let the TUI handle it\n\t\t\tslog.Info(\"Models not configured, will show setup dialog\")\n\t\t\t// Need to create the app anyway, so retry with a more permissive app creation\n\t\t\tif cfg.Models == nil {\n\t\t\t\tcfg.Models = make(map[config.SelectedModelType]config.SelectedModel)\n\t\t\t}\n\t\t\tif _, exists := cfg.Models[config.SelectedModelTypeLarge]; !exists {\n\t\t\t\tcfg.Models[config.SelectedModelTypeLarge] = config.SelectedModel{}\n\t\t\t}\n\t\t\tif _, exists := cfg.Models[config.SelectedModelTypeSmall]; !exists {\n\t\t\t\tcfg.Models[config.SelectedModelTypeSmall] = config.SelectedModel{}\n\t\t\t}\n\t\t\tappInstance, err = app.New(ctx, conn, cfg)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"Failed to create app instance with fallback config\", \"error\", err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tslog.Error(\"Failed to create app instance\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn appInstance, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_MaybePrependStdin_265": {
      "name": "MaybePrependStdin",
      "type": "function",
      "start_line": 265,
      "end_line": 282,
      "content_hash": "457c6347e31456d8fe29f49ad67a4ddf0d1e7abd",
      "content": "func MaybePrependStdin(prompt string) (string, error) {\n\tif term.IsTerminal(os.Stdin.Fd()) {\n\t\treturn prompt, nil\n\t}\n\tfi, err := os.Stdin.Stat()\n\tif err != nil {\n\t\treturn prompt, err\n\t}\n\tif fi.Mode()&os.ModeNamedPipe == 0 {\n\t\treturn prompt, nil\n\t}\n\tbts, err := io.ReadAll(os.Stdin)\n\tif err != nil {\n\t\treturn prompt, err\n\t}\n\treturn string(bts) + \"\\n\\n\" + prompt, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ResolveCwd_283": {
      "name": "ResolveCwd",
      "type": "function",
      "start_line": 283,
      "end_line": 298,
      "content_hash": "56d0c172c9924ff0ba14be3083af30cf9c773f47",
      "content": "func ResolveCwd(cmd *cobra.Command) (string, error) {\n\tcwd, _ := cmd.Flags().GetString(\"cwd\")\n\tif cwd != \"\" {\n\t\terr := os.Chdir(cwd)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to change directory: %v\", err)\n\t\t}\n\t\treturn cwd, nil\n\t}\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get current working directory: %v\", err)\n\t}\n\treturn cwd, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_createDotNexoraDir_299": {
      "name": "createDotNexoraDir",
      "type": "function",
      "start_line": 299,
      "end_line": 313,
      "content_hash": "6f3c4bf3093d9140c1390825d07f86a118b6515f",
      "content": "func createDotNexoraDir(dir string) error {\n\tif err := os.MkdirAll(dir, 0o700); err != nil {\n\t\treturn fmt.Errorf(\"failed to create data directory: %q %w\", dir, err)\n\t}\n\n\tgitIgnorePath := filepath.Join(dir, \".gitignore\")\n\tif _, err := os.Stat(gitIgnorePath); os.IsNotExist(err) {\n\t\tif err := os.WriteFile(gitIgnorePath, []byte(\"*\\n\"), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create .gitignore file: %q %w\", gitIgnorePath, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_shouldQueryTerminalVersion_314": {
      "name": "shouldQueryTerminalVersion",
      "type": "function",
      "start_line": 314,
      "end_line": 322,
      "content_hash": "e61d6063389260cfbfc400bcfef49f5bdc2cfc57",
      "content": "func shouldQueryTerminalVersion(env uv.Environ) bool {\n\ttermType := env.Getenv(\"TERM\")\n\ttermProg, okTermProg := env.LookupEnv(\"TERM_PROGRAM\")\n\t_, okSSHTTY := env.LookupEnv(\"SSH_TTY\")\n\treturn (!okTermProg && !okSSHTTY) ||\n\t\t(!strings.Contains(termProg, \"Apple\") && !okSSHTTY) ||\n\t\t// Terminals that do support XTVERSION.\n\t\tstringext.ContainsAny(termType, \"alacritty\", \"ghostty\", \"kitty\", \"rio\", \"wezterm\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}