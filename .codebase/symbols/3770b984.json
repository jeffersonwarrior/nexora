{
  "file_path": "/work/.local/tools/modelscan/sdk/cli/cli_test.go",
  "file_hash": "f2219ccd19a14338bf1b410d6ec7c6cc30df1291",
  "updated_at": "2025-12-26T17:34:23.039838",
  "symbols": {
    "function_TestConfig_15": {
      "name": "TestConfig",
      "type": "function",
      "start_line": 15,
      "end_line": 35,
      "content_hash": "1726e2a053beda529642813ed4e9b27e28d03008",
      "content": "func TestConfig(t *testing.T) {\n\tconfig := DefaultConfig()\n\n\tif config.DatabasePath == \"\" {\n\t\tt.Error(\"Default config database path should not be empty\")\n\t}\n\n\tif config.LogLevel == \"\" {\n\t\tt.Error(\"Default log level should not be empty\")\n\t}\n\n\tif config.DataRetention == 0 {\n\t\tt.Error(\"Default data retention should not be zero\")\n\t}\n\n\tif config.MaxConcurrency == 0 {\n\t\tt.Error(\"Default max concurrency should not be zero\")\n\t}\n}\n\n// TestOrchestrator tests orchestrator functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOrchestrator_36": {
      "name": "TestOrchestrator",
      "type": "function",
      "start_line": 36,
      "end_line": 85,
      "content_hash": "33ceecff392d2ab811645a98fdda14189eabe1c8",
      "content": "func TestOrchestrator(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\t// Create orchestrator\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\n\t// Test starting\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start orchestrator: %v\", err)\n\t}\n\n\tif !orchestrator.IsRunning() {\n\t\tt.Error(\"Orchestrator should be running\")\n\t}\n\n\t// Test storage access\n\tstorage := orchestrator.GetStorage()\n\tif storage == nil {\n\t\tt.Error(\"Storage should not be nil\")\n\t}\n\n\t// Test configuration access\n\tconfigReturned := orchestrator.GetConfig()\n\tif configReturned.LogLevel != config.LogLevel {\n\t\tt.Errorf(\"Expected log level %s, got %s\", config.LogLevel, configReturned.LogLevel)\n\t}\n\n\t// Test stopping\n\tif err := orchestrator.Stop(); err != nil {\n\t\tt.Fatalf(\"Failed to stop orchestrator: %v\", err)\n\t}\n\n\tif orchestrator.IsRunning() {\n\t\tt.Error(\"Orchestrator should not be running\")\n\t}\n}\n\n// TestCommands tests command functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCommands_86": {
      "name": "TestCommands",
      "type": "function",
      "start_line": 86,
      "end_line": 191,
      "content_hash": "5078abb9f0680d2b57e32cd97b116f8fc9ea21d3",
      "content": "func TestCommands(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start orchestrator: %v\", err)\n\t}\n\n\tdefer orchestrator.Stop()\n\n\tctx := context.Background()\n\n\t// Test create agent command\n\tcreateAgentCmd := &CreateAgentCommand{}\n\terr = createAgentCmd.Execute(ctx, orchestrator, []string{\"test-agent\", \"llm\", \"text-generation\", \"analysis\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create agent: %v\", err)\n\t}\n\n\t// Test list agents command\n\tlistAgentsCmd := &ListAgentsCommand{}\n\terr = listAgentsCmd.Execute(ctx, orchestrator, []string{})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to list agents: %v\", err)\n\t}\n\n\t// Test create team command\n\tcreateTeamCmd := &CreateTeamCommand{}\n\terr = createTeamCmd.Execute(ctx, orchestrator, []string{\"test-team\", \"A test team for testing\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create team: %v\", err)\n\t}\n\n\t// Test list teams command\n\tlistTeamsCmd := &ListTeamsCommand{}\n\terr = listTeamsCmd.Execute(ctx, orchestrator, []string{})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to list teams: %v\", err)\n\t}\n\n\t// Test add to team command (we need to get the agent and team IDs first)\n\torchestrator.mu.RLock()\n\tvar agentID, teamID string\n\tfor _, agent := range orchestrator.agents {\n\t\tif agent.Name == \"test-agent\" {\n\t\t\tagentID = agent.ID\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, team := range orchestrator.teams {\n\t\tif team.Name == \"test-team\" {\n\t\t\tteamID = team.ID\n\t\t\tbreak\n\t\t}\n\t}\n\torchestrator.mu.RUnlock()\n\n\tif agentID == \"\" {\n\t\tt.Fatal(\"Failed to find test agent\")\n\t}\n\tif teamID == \"\" {\n\t\tt.Fatal(\"Failed to find test team\")\n\t}\n\n\taddToTeamCmd := &AddToTeamCommand{}\n\terr = addToTeamCmd.Execute(ctx, orchestrator, []string{teamID, agentID, \"member\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to add agent to team: %v\", err)\n\t}\n\n\t// Test list tasks command (should show initial task creation messages)\n\tlistTasksCmd := &ListTasksCommand{}\n\terr = listTasksCmd.Execute(ctx, orchestrator, []string{})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to list tasks: %v\", err)\n\t}\n\n\t// Test status command\n\tstatusCmd := &StatusCommand{}\n\terr = statusCmd.Execute(ctx, orchestrator, []string{})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get status: %v\", err)\n\t}\n\n\t// Test cleanup command\n\tcleanupCmd := &CleanupCommand{}\n\terr = cleanupCmd.Execute(ctx, orchestrator, []string{})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to perform cleanup: %v\", err)\n\t}\n}\n\n// TestCLI tests the CLI interface",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_192": {
      "name": "TestCLI",
      "type": "function",
      "start_line": 192,
      "end_line": 214,
      "content_hash": "a30a3349f8026fe74c2ff091e0463365d6367749",
      "content": "func TestCLI(t *testing.T) {\n\tcli := NewCLI()\n\n\tif cli.IsInitialized() {\n\t\tt.Error(\"CLI should not be initialized initially\")\n\t}\n\n\t// Test command registry\n\tcommands := cli.GetCommands()\n\tif len(commands) == 0 {\n\t\tt.Error(\"CLI should have registered commands\")\n\t}\n\n\t// Check that key commands exist\n\tkeyCommands := []string{\"help\", \"list-agents\", \"create-agent\", \"status\"}\n\tfor _, cmdName := range keyCommands {\n\t\tif _, exists := commands[cmdName]; !exists {\n\t\t\tt.Errorf(\"Command %s should be registered\", cmdName)\n\t\t}\n\t}\n}\n\n// TestHelpCommand tests help functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHelpCommand_215": {
      "name": "TestHelpCommand",
      "type": "function",
      "start_line": 215,
      "end_line": 235,
      "content_hash": "1e00913c66ebcaab6bce5c97831509057f9828b4",
      "content": "func TestHelpCommand(t *testing.T) {\n\tcommands := make(map[string]Command)\n\tcommands[\"test-cmd\"] = &CreateAgentCommand{}\n\n\thelpCmd := NewHelpCommand(commands)\n\n\t// Test help command name and properties\n\tif helpCmd.Name() != \"help\" {\n\t\tt.Errorf(\"Expected help command name 'help', got '%s'\", helpCmd.Name())\n\t}\n\n\tif helpCmd.Description() != \"Show help\" {\n\t\tt.Errorf(\"Expected help command description 'Show help', got '%s'\", helpCmd.Description())\n\t}\n\n\t// Test actual help execution (in a real scenario with an orchestrator)\n\t// This would need a full orchestrator setup, so we'll just test structure\n\t_ = helpCmd.Usage()\n}\n\n// TestConfigurationPersistence tests that configurations are properly persisted",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestConfigurationPersistence_236": {
      "name": "TestConfigurationPersistence",
      "type": "function",
      "start_line": 236,
      "end_line": 292,
      "content_hash": "cd42731b6b9cae0a2363a268e3649944d6c84e6e",
      "content": "func TestConfigurationPersistence(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"debug\",\n\t\tDataRetention:  2 * time.Hour,\n\t\tMaxConcurrency: 3,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\t// Create and start first orchestrator\n\torchestrator1, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create first orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator1.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start first orchestrator: %v\", err)\n\t}\n\n\t// Create an agent\n\tcreateAgentCmd := &CreateAgentCommand{}\n\terr = createAgentCmd.Execute(context.Background(), orchestrator1, []string{\"persistent-agent\", \"test-type\", \"test-cap\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create agent: %v\", err)\n\t}\n\n\t// Stop orchestrator\n\tif err := orchestrator1.Stop(); err != nil {\n\t\tt.Fatalf(\"Failed to stop first orchestrator: %v\", err)\n\t}\n\n\t// Create and start second orchestrator with same config\n\torchestrator2, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create second orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator2.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start second orchestrator: %v\", err)\n\t}\n\n\tdefer orchestrator2.Stop()\n\n\t// Verify agent was loaded from storage\n\torchestrator2.mu.RLock()\n\tagentCount := len(orchestrator2.agents)\n\torchestrator2.mu.RUnlock()\n\n\tif agentCount != 1 {\n\t\tt.Errorf(\"Expected 1 agent to be loaded from storage, got %d\", agentCount)\n\t}\n}\n\n// TestZeroState tests zero-state initialization",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestZeroState_293": {
      "name": "TestZeroState",
      "type": "function",
      "start_line": 293,
      "end_line": 352,
      "content_hash": "b5abf616de9369c078c6ca18e4baa782d55374b3",
      "content": "func TestZeroState(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test_zero_state.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\t// Create and start first orchestrator\n\torchestrator1, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create first orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator1.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start first orchestrator: %v\", err)\n\t}\n\n\t// Create some pending work\n\tcreateAgentCmd := &CreateAgentCommand{}\n\terr = createAgentCmd.Execute(context.Background(), orchestrator1, []string{\"agent1\", \"test\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create agent: %v\", err)\n\t}\n\n\t// Don't explicitly stop - simulate crash by creating new orchestrator\n\n\t// Create second orchestrator (should trigger zero-state)\n\torchestrator2, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create second orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator2.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start second orchestrator: %v\", err)\n\t}\n\n\tdefer orchestrator2.Stop()\n\n\t// Verify that zero-state was applied (all agents should be idle)\n\torchestrator2.mu.RLock()\n\tallIdle := true\n\tfor _, agent := range orchestrator2.agents {\n\t\tif agent.Status != \"idle\" {\n\t\t\tallIdle = false\n\t\t\tbreak\n\t\t}\n\t}\n\torchestrator2.mu.RUnlock()\n\n\tif !allIdle {\n\t\tt.Error(\"Expected all agents to be idle after zero-state initialization\")\n\t}\n}\n\n// TestErrorCases tests various error scenarios",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestErrorCases_353": {
      "name": "TestErrorCases",
      "type": "function",
      "start_line": 353,
      "end_line": 406,
      "content_hash": "66409ca9bc0ee57270e61c81cbc5bb3ef065ef78",
      "content": "func TestErrorCases(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test_errors.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start orchestrator: %v\", err)\n\t}\n\n\tdefer orchestrator.Stop()\n\n\tctx := context.Background()\n\n\t// Test invalid agent creation\n\tcreateAgentCmd := &CreateAgentCommand{}\n\terr = createAgentCmd.Execute(ctx, orchestrator, []string{}) // Missing required args\n\tif err == nil {\n\t\tt.Error(\"Expected error when creating agent without arguments\")\n\t}\n\n\t// Test invalid team creation\n\tcreateTeamCmd := &CreateTeamCommand{}\n\terr = createTeamCmd.Execute(ctx, orchestrator, []string{}) // Missing required args\n\tif err == nil {\n\t\tt.Error(\"Expected error when creating team without arguments\")\n\t}\n\n\t// Test invalid add to team\n\taddToTeamCmd := &AddToTeamCommand{}\n\terr = addToTeamCmd.Execute(ctx, orchestrator, []string{}) // Missing required args\n\tif err == nil {\n\t\tt.Error(\"Expected error when adding to team without arguments\")\n\t}\n\n\t// Test adding agent to non-existent team\n\terr = addToTeamCmd.Execute(ctx, orchestrator, []string{\"non-existent-team\", \"non-existent-agent\"})\n\tif err == nil {\n\t\tt.Error(\"Expected error when adding to non-existent team\")\n\t}\n}\n\n// Example usage test to demonstrate CLI functionality",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ExampleCLI_407": {
      "name": "ExampleCLI",
      "type": "function",
      "start_line": 407,
      "end_line": 441,
      "content_hash": "4800e3e6316f0ab31047f9d9bd96175fa43f83af",
      "content": "func ExampleCLI() {\n\t// This example demonstrates how to use the CLI programmatically\n\tcli := NewCLI()\n\n\t// Add custom command\n\tcmd := &CreateAgentCommand{}\n\tcli.AddCommand(cmd)\n\n\t// Set up temporary database for example\n\ttempDir := os.TempDir()\n\tdbPath := filepath.Join(tempDir, \"modelscan_example.db\")\n\tcli.rootCmd.PersistentFlags().Set(\"database\", dbPath)\n\n\t// Execute with command line arguments\n\tos.Args = []string{\"modelscan\", \"help\"}\n\tif err := cli.Execute(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Output:\n\t// ModelScan CLI Commands\n\t// =======================\n\t//\n\t// add-to-team          Add agents to a team\n\t// cleanup              Perform cleanup of old data\n\t// create-agent         Create a new agent\n\t// create-team          Create a new team\n\t// help                 Show help\n\t// list-agents          List all registered agents\n\t// list-tasks           List all tasks\n\t// list-teams           List all teams\n\t// status               Show system status\n\t//\n\t// Use 'help <command>' for detailed usage information\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCommand_UsageMethods_442": {
      "name": "TestCommand_UsageMethods",
      "type": "function",
      "start_line": 442,
      "end_line": 444,
      "content_hash": "fbaa4ddcadabaa7f8c743c51d8e93afd0e7523f0",
      "content": "func TestCommand_UsageMethods(t *testing.T) {\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_GettersAndSetters_445": {
      "name": "TestCLI_GettersAndSetters",
      "type": "function",
      "start_line": 445,
      "end_line": 465,
      "content_hash": "6884219967d01965e6e7e18f4da49fbe04860b75",
      "content": "func TestCLI_GettersAndSetters(t *testing.T) {\n\tcli := NewCLI()\n\n\t// Test IsInitialized before init\n\tif cli.IsInitialized() {\n\t\tt.Error(\"Expected IsInitialized to be false before initialization\")\n\t}\n\n\t// Test GetOrchestrator before init\n\torch := cli.GetOrchestrator()\n\tif orch != nil {\n\t\tt.Error(\"Expected nil orchestrator before initialization\")\n\t}\n\n\t// Test GetCommands\n\tcommands := cli.GetCommands()\n\tif len(commands) == 0 {\n\t\tt.Error(\"Expected some builtin commands\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_AddCommand_466": {
      "name": "TestCLI_AddCommand",
      "type": "function",
      "start_line": 466,
      "end_line": 489,
      "content_hash": "8a9c94d5e8c1fd9b308511a860f80118c860ee62",
      "content": "func TestCLI_AddCommand(t *testing.T) {\n\tcli := NewCLI()\n\n\t// Create a simple test command\n\ttestCmd := &ListAgentsCommand{}\n\n\t// Add command\n\tcli.AddCommand(testCmd)\n\n\t// Verify it was added\n\tcommands := cli.GetCommands()\n\tfound := false\n\tfor _, cmd := range commands {\n\t\tif cmd.Name() == testCmd.Name() {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tt.Error(\"Command was not added successfully\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestBuiltinCommands_Interfaces_490": {
      "name": "TestBuiltinCommands_Interfaces",
      "type": "function",
      "start_line": 490,
      "end_line": 522,
      "content_hash": "65bfc7647b2db68bbda930a4eb4a62804e05fdb0",
      "content": "func TestBuiltinCommands_Interfaces(t *testing.T) {\n\t// Test that builtin commands implement Command interface\n\tcommands := []Command{\n\t\t&ListAgentsCommand{},\n\t\t&CreateAgentCommand{},\n\t\t&ListTeamsCommand{},\n\t\t&CreateTeamCommand{},\n\t\t&AddToTeamCommand{},\n\t}\n\n\tfor _, cmd := range commands {\n\t\tt.Run(cmd.Name(), func(t *testing.T) {\n\t\t\t// Test Name\n\t\t\tif cmd.Name() == \"\" {\n\t\t\t\tt.Error(\"Name() returned empty string\")\n\t\t\t}\n\n\t\t\t// Test Description\n\t\t\tif cmd.Description() == \"\" {\n\t\t\t\tt.Error(\"Description() returned empty string\")\n\t\t\t}\n\n\t\t\t// Test Usage\n\t\t\tusage := cmd.Usage()\n\t\t\tif usage == \"\" {\n\t\t\t\tt.Error(\"Usage() returned empty string\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ptr[T any](v T) *T { return &v }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOrchestrator_LoadTeams_WithMembersAndMetadata_523": {
      "name": "TestOrchestrator_LoadTeams_WithMembersAndMetadata",
      "type": "function",
      "start_line": 523,
      "end_line": 589,
      "content_hash": "f16fc741c967c0e5925c4e2946707829c5431ffb",
      "content": "func TestOrchestrator_LoadTeams_WithMembersAndMetadata(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test_load_teams.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"NewOrchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Start: %v\", err)\n\t}\n\n\tctx := context.Background()\n\n\tteam := orchestrator.storage.NewTeamWithDefaults(\"test-team\", \"Test team\")\n\tteam.Metadata[\"key\"] = \"value\"\n\terr = orchestrator.storage.Teams.Create(ctx, team)\n\tif err != nil {\n\t\tt.Fatalf(\"Create team: %v\", err)\n\t}\n\n\tagent := orchestrator.storage.NewAgentWithDefaults(\"test-agent\", \"test\", []string{})\n\terr = orchestrator.storage.Agents.Create(ctx, agent)\n\tif err != nil {\n\t\tt.Fatalf(\"Create agent: %v\", err)\n\t}\n\n\terr = orchestrator.storage.Teams.AddMember(ctx, team.ID, agent.ID, \"member\")\n\tif err != nil {\n\t\tt.Fatalf(\"Add member: %v\", err)\n\t}\n\n\torchestrator.Stop()\n\torchestrator, err = NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"NewOrchestrator2: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Start2: %v\", err)\n\t}\n\n\tif len(orchestrator.teams) != 1 {\n\t\tt.Errorf(\"Expected 1 team, got %d\", len(orchestrator.teams))\n\t}\n\tloadedTeam, ok := orchestrator.teams[team.ID]\n\tif !ok {\n\t\tt.Error(\"Expected test-team\")\n\t}\n\tif _, ok := loadedTeam.Metadata[\"key\"]; !ok {\n\t\tt.Error(\"Expected metadata\")\n\t}\n\tif len(loadedTeam.Agents) != 1 {\n\t\tt.Errorf(\"Expected 1 member, got %d\", len(loadedTeam.Agents))\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__TestOrchestrator_LoadTasks_WithOptionalFields_590": {
      "name": "_TestOrchestrator_LoadTasks_WithOptionalFields",
      "type": "function",
      "start_line": 590,
      "end_line": 691,
      "content_hash": "6d79349557a62f40f25979fc4449d11dc0c8ecfe",
      "content": "func _TestOrchestrator_LoadTasks_WithOptionalFields(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test_load_tasks.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"NewOrchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Start: %v\", err)\n\t}\n\n\tctx := context.Background()\n\n\tagent := orchestrator.storage.NewAgentWithDefaults(\"test-agent-tasks\", \"test\", nil)\n\terr = orchestrator.storage.Agents.Create(ctx, agent)\n\tif err != nil {\n\t\tt.Fatalf(\"Create agent: %v\", err)\n\t}\n\n\tpendingTask := orchestrator.storage.NewTaskWithDefaults(agent.ID, \"pending-test\", \"input\", 1)\n\terr = orchestrator.storage.Tasks.Create(ctx, pendingTask)\n\tif err != nil {\n\t\tt.Fatalf(\"Create pending task: %v\", err)\n\t}\n\n\t// Create team for task with team_id\n\tteam := orchestrator.storage.NewTeamWithDefaults(\"test-team\", \"Test Team\")\n\terr = orchestrator.storage.Teams.Create(ctx, team)\n\tif err != nil {\n\t\tt.Fatalf(\"Create team: %v\", err)\n\t}\n\n\tstartedAt := time.Now()\n\trunningTask := &storage.Task{\n\t\tID:        \"running-task\",\n\t\tAgentID:   agent.ID,\n\t\tType:      \"running-test\",\n\t\tStatus:    \"running\",\n\t\tPriority:  2,\n\t\tInput:     \"running input\",\n\t\tMetadata:  map[string]interface{}{\"key\": \"value\"},\n\t\tCreatedAt: time.Now(),\n\t\tUpdatedAt: time.Now(),\n\t\tStartedAt: &startedAt,\n\t\tTeamID:    &team.ID,\n\t}\n\terr = orchestrator.storage.Tasks.Create(ctx, runningTask)\n\tif err != nil {\n\t\tt.Fatalf(\"Create running task: %v\", err)\n\t}\n\n\torchestrator.Stop()\n\ttime.Sleep(100 * time.Millisecond) // Let WAL checkpoint complete\n\torchestrator, err = NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"NewOrchestrator2: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Start2: %v\", err)\n\t}\n\n\t// Check if tasks are in DB\n\tdbTasks, err := orchestrator.storage.Tasks.ListByStatus(ctx, \"pending\", 100, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"List pending tasks: %v\", err)\n\t}\n\tt.Logf(\"Found %d pending tasks in DB\", len(dbTasks))\n\n\trunningDbTasks, err := orchestrator.storage.Tasks.ListByStatus(ctx, \"running\", 100, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"List running tasks: %v\", err)\n\t}\n\tt.Logf(\"Found %d running tasks in DB\", len(runningDbTasks))\n\n\tif len(orchestrator.tasks) != 2 {\n\t\tt.Errorf(\"Expected 2 tasks, got %d\", len(orchestrator.tasks))\n\t}\n\tif task, ok := orchestrator.tasks[\"running-task\"]; ok {\n\t\tif task.TeamID != \"test-team\" {\n\t\t\tt.Errorf(\"Expected TeamID test-team, got %s\", task.TeamID)\n\t\t}\n\t\tif task.StartedAt.IsZero() {\n\t\t\tt.Error(\"Expected StartedAt\")\n\t\t}\n\t\tif _, ok := task.Metadata[\"key\"]; !ok {\n\t\t\tt.Error(\"Expected metadata\")\n\t\t}\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_runOrchestrator_Standalone_692": {
      "name": "TestCLI_runOrchestrator_Standalone",
      "type": "function",
      "start_line": 692,
      "end_line": 726,
      "content_hash": "211543adca6606b00b147e02ff234ace665527ca",
      "content": "func TestCLI_runOrchestrator_Standalone(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start orchestrator: %v\", err)\n\t}\n\n\tcli := NewCLI()\n\tcli.initialized = true\n\tcli.orchestrator = orchestrator\n\n\t// Register status command\n\tcli.commands[\"status\"] = &StatusCommand{}\n\n\terr = cli.runOrchestrator([]string{})\n\tif err != nil {\n\t\tt.Errorf(\"Expected nil for standalone, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_executeCommandLine_Success_727": {
      "name": "TestCLI_executeCommandLine_Success",
      "type": "function",
      "start_line": 727,
      "end_line": 738,
      "content_hash": "e1aa85e29ae51d4cb36de55b1975a65c795de939",
      "content": "func TestCLI_executeCommandLine_Success(t *testing.T) {\n\tcli := NewCLI()\n\tcli.initialized = true\n\tcli.orchestrator = &Orchestrator{}\n\tcli.commands[\"list-agents\"] = &ListAgentsCommand{}\n\n\terr := cli.executeCommandLine(\"list-agents\")\n\tif err != nil {\n\t\tt.Errorf(\"Expected success, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_executeCommandLine_Unknown_739": {
      "name": "TestCLI_executeCommandLine_Unknown",
      "type": "function",
      "start_line": 739,
      "end_line": 748,
      "content_hash": "8ef5c20a49968b52354314d4359e325fc11cb433",
      "content": "func TestCLI_executeCommandLine_Unknown(t *testing.T) {\n\tcli := NewCLI()\n\tcli.initialized = true\n\n\terr := cli.executeCommandLine(\"unknown\")\n\tif err == nil || !strings.Contains(err.Error(), \"unknown\") {\n\t\tt.Errorf(\"Expected unknown cmd error, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_Shutdown_749": {
      "name": "TestCLI_Shutdown",
      "type": "function",
      "start_line": 749,
      "end_line": 760,
      "content_hash": "dbd8b4c8703ae4ce77748e5ac36c7517ddd1328e",
      "content": "func TestCLI_Shutdown(t *testing.T) {\n\tcli := NewCLI()\n\tcli.orchestrator = &Orchestrator{}\n\n\terr := cli.Shutdown()\n\tif err != nil {\n\t\tt.Errorf(\"Expected nil, got %v\", err)\n\t}\n}\n\n// Phase 2 tests for 80%+ coverage\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestOrchestrator_cleanupRoutine_ContextCancel_761": {
      "name": "TestOrchestrator_cleanupRoutine_ContextCancel",
      "type": "function",
      "start_line": 761,
      "end_line": 800,
      "content_hash": "3cba21a04bddba2e8ed69b572ebfec3e51fb8aea",
      "content": "func TestOrchestrator_cleanupRoutine_ContextCancel(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\n\t// Start and immediately stop to trigger context cancellation\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start: %v\", err)\n\t}\n\n\t// Launch cleanup routine in background\n\tdone := make(chan struct{})\n\tgo func() {\n\t\torchestrator.cleanupRoutine()\n\t\tclose(done)\n\t}()\n\n\t// Stop should cancel context\n\torchestrator.Stop()\n\n\t// Wait for cleanup to exit\n\tselect {\n\tcase <-done:\n\t\t// Success - routine exited on context cancel\n\tcase <-time.After(2 * time.Second):\n\t\tt.Error(\"cleanupRoutine did not exit on context cancel\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestStatusCommand_Execute_WithArgs_801": {
      "name": "TestStatusCommand_Execute_WithArgs",
      "type": "function",
      "start_line": 801,
      "end_line": 829,
      "content_hash": "93a87c16a3031a5a432835fbbddf25bcce2e6372",
      "content": "func TestStatusCommand_Execute_WithArgs(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start: %v\", err)\n\t}\n\n\tcmd := &StatusCommand{}\n\terr = cmd.Execute(context.Background(), orchestrator, []string{\"extra\"})\n\tif err == nil || !strings.Contains(err.Error(), \"too many arguments\") {\n\t\tt.Errorf(\"Expected too many arguments error, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCLI_runOrchestrator_WithCommand_830": {
      "name": "TestCLI_runOrchestrator_WithCommand",
      "type": "function",
      "start_line": 830,
      "end_line": 865,
      "content_hash": "f70d51575c1244b12b1fe21ee462f943878857bd",
      "content": "func TestCLI_runOrchestrator_WithCommand(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start: %v\", err)\n\t}\n\n\tcli := NewCLI()\n\tcli.initialized = true\n\tcli.orchestrator = orchestrator\n\n\t// Register list-agents command\n\tcli.commands[\"list-agents\"] = &ListAgentsCommand{}\n\n\t// Test with command args\n\terr = cli.runOrchestrator([]string{\"list-agents\"})\n\tif err != nil {\n\t\tt.Errorf(\"Expected success with command, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCleanupCommand_Execute_Success_866": {
      "name": "TestCleanupCommand_Execute_Success",
      "type": "function",
      "start_line": 866,
      "end_line": 894,
      "content_hash": "ed1006bf4105845e218cf200fe71fac0c06a8195",
      "content": "func TestCleanupCommand_Execute_Success(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start: %v\", err)\n\t}\n\n\tcmd := &CleanupCommand{}\n\terr = cmd.Execute(context.Background(), orchestrator, []string{})\n\tif err != nil {\n\t\tt.Errorf(\"Expected success, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestCommand_Usage_Methods_895": {
      "name": "TestCommand_Usage_Methods",
      "type": "function",
      "start_line": 895,
      "end_line": 916,
      "content_hash": "81f1391c42c6641be3a71cfdc229f9e6d6a1d8e0",
      "content": "func TestCommand_Usage_Methods(t *testing.T) {\n\t// Test all Usage methods to get 0% funcs to 100%\n\ttests := []struct {\n\t\tname string\n\t\tcmd  Command\n\t\twant string\n\t}{\n\t\t{\"ListTasks\", &ListTasksCommand{}, \"list-tasks [status]\"},\n\t\t{\"Status\", &StatusCommand{}, \"status\"},\n\t\t{\"Cleanup\", &CleanupCommand{}, \"cleanup\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.cmd.Usage()\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Usage() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestListTasksCommand_Execute_WithStatus_917": {
      "name": "TestListTasksCommand_Execute_WithStatus",
      "type": "function",
      "start_line": 917,
      "end_line": 953,
      "content_hash": "0098c2dceb1810834513e5526351ecc124fd83ce",
      "content": "func TestListTasksCommand_Execute_WithStatus(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t\tStartupAction:  \"zero-state\",\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tif err := orchestrator.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start: %v\", err)\n\t}\n\n\tcmd := &ListTasksCommand{}\n\n\t// Test with status filter\n\terr = cmd.Execute(context.Background(), orchestrator, []string{\"pending\"})\n\tif err != nil {\n\t\tt.Errorf(\"Expected success with status, got %v\", err)\n\t}\n\n\t// Test with no args\n\terr = cmd.Execute(context.Background(), orchestrator, []string{})\n\tif err != nil {\n\t\tt.Errorf(\"Expected success without args, got %v\", err)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHelpCommand_Execute_WithCommand_954": {
      "name": "TestHelpCommand_Execute_WithCommand",
      "type": "function",
      "start_line": 954,
      "end_line": 986,
      "content_hash": "b2dc55ea1eebdd35438e6822df3ac6df19579ad6",
      "content": "func TestHelpCommand_Execute_WithCommand(t *testing.T) {\n\ttempDir := t.TempDir()\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\tconfig := &Config{\n\t\tDatabasePath:   dbPath,\n\t\tLogLevel:       \"info\",\n\t\tDataRetention:  24 * time.Hour,\n\t\tMaxConcurrency: 5,\n\t}\n\n\torchestrator, err := NewOrchestrator(config)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create orchestrator: %v\", err)\n\t}\n\tdefer orchestrator.Stop()\n\n\tcmd := &HelpCommand{commands: map[string]Command{\n\t\t\"test\": &ListAgentsCommand{},\n\t}}\n\n\t// Test with specific command\n\terr = cmd.Execute(context.Background(), orchestrator, []string{\"test\"})\n\tif err != nil {\n\t\tt.Errorf(\"Expected success, got %v\", err)\n\t}\n\n\t// Test with unknown command\n\terr = cmd.Execute(context.Background(), orchestrator, []string{\"unknown\"})\n\tif err == nil || !strings.Contains(err.Error(), \"unknown\") {\n\t\tt.Errorf(\"Expected unknown command error, got %v\", err)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}