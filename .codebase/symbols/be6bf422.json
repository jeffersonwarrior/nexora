{
  "file_path": "/work/internal/agent/agentic_fetch_tool.go",
  "file_hash": "9e8c64ba0ae49387944ca1353b536d873da3ac56",
  "updated_at": "2025-12-26T17:34:21.804787",
  "symbols": {
    "struct_agenticFetchValidationResult_24": {
      "name": "agenticFetchValidationResult",
      "type": "struct",
      "start_line": 24,
      "end_line": 29,
      "content_hash": "99eb04d3784ffca82928177e3499c75dc3aaad73",
      "content": "type agenticFetchValidationResult struct {\n\tSessionID      string\n\tAgentMessageID string\n}\n\n// validateAgenticFetchParams validates the tool call parameters and extracts required context values.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_validateAgenticFetchParams_30": {
      "name": "validateAgenticFetchParams",
      "type": "function",
      "start_line": 30,
      "end_line": 53,
      "content_hash": "5acb68ac751e55b4657433bb90dcec83660e3e1f",
      "content": "func validateAgenticFetchParams(ctx context.Context, params tools.AgenticFetchParams) (agenticFetchValidationResult, error) {\n\tif params.Prompt == \"\" {\n\t\treturn agenticFetchValidationResult{}, errors.New(\"prompt is required\")\n\t}\n\n\tsessionID := tools.GetSessionFromContext(ctx)\n\tif sessionID == \"\" {\n\t\treturn agenticFetchValidationResult{}, errors.New(\"session id missing from context\")\n\t}\n\n\tagentMessageID := tools.GetMessageFromContext(ctx)\n\tif agentMessageID == \"\" {\n\t\treturn agenticFetchValidationResult{}, errors.New(\"agent message id missing from context\")\n\t}\n\n\treturn agenticFetchValidationResult{\n\t\tSessionID:      sessionID,\n\t\tAgentMessageID: agentMessageID,\n\t}, nil\n}\n\n//go:embed templates/agentic_fetch_prompt.md.tpl\nvar agenticFetchPromptTmpl []byte\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_agenticFetchTool_54": {
      "name": "agenticFetchTool",
      "type": "method",
      "start_line": 54,
      "end_line": 237,
      "content_hash": "e1922e3ef916af96bf8a877d856d42b0da1d75b8",
      "content": "func (c *coordinator) agenticFetchTool(_ context.Context, client *http.Client) (fantasy.AgentTool, error) {\n\tif client == nil {\n\t\tclient = &http.Client{\n\t\t\tTimeout: 30 * time.Second,\n\t\t\tTransport: &http.Transport{\n\t\t\t\tMaxIdleConns:        100,\n\t\t\t\tMaxIdleConnsPerHost: 10,\n\t\t\t\tIdleConnTimeout:     90 * time.Second,\n\t\t\t},\n\t\t}\n\t}\n\n\treturn fantasy.NewParallelAgentTool(\n\t\ttools.AgenticFetchToolName,\n\t\tstring(agenticFetchToolDescription),\n\t\tfunc(ctx context.Context, params tools.AgenticFetchParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\tvalidationResult, err := validateAgenticFetchParams(ctx, params)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(err.Error()), nil\n\t\t\t}\n\n\t\t\t// Determine description based on mode.\n\t\t\tvar description string\n\t\t\tif params.URL != \"\" {\n\t\t\t\tdescription = fmt.Sprintf(\"Fetch and analyze content from URL: %s\", params.URL)\n\t\t\t} else {\n\t\t\t\tdescription = \"Search the web and analyze results\"\n\t\t\t}\n\n\t\t\tp := c.permissions.Request(\n\t\t\t\tpermission.CreatePermissionRequest{\n\t\t\t\t\tSessionID:   validationResult.SessionID,\n\t\t\t\t\tPath:        c.cfg.WorkingDir(),\n\t\t\t\t\tToolCallID:  call.ID,\n\t\t\t\t\tToolName:    tools.AgenticFetchToolName,\n\t\t\t\t\tAction:      \"fetch\",\n\t\t\t\t\tDescription: description,\n\t\t\t\t\tParams:      tools.AgenticFetchPermissionsParams(params),\n\t\t\t\t},\n\t\t\t)\n\n\t\t\tif !p {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"Permission denied to use agentic_fetch tool\"), nil\n\t\t\t}\n\n\t\t\ttmpDir, err := os.MkdirTemp(c.cfg.Options.DataDirectory, \"nexora-fetch-*\")\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"Failed to create temporary directory: %s\", err)), nil\n\t\t\t}\n\t\t\tdefer os.RemoveAll(tmpDir)\n\n\t\t\tvar fullPrompt string\n\n\t\t\tif params.URL != \"\" {\n\t\t\t\t// URL mode: fetch the URL content first.\n\t\t\t\tcontent, err := tools.FetchURLAndConvert(ctx, client, params.URL)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"Failed to fetch URL: %s\", err)), nil\n\t\t\t\t}\n\n\t\t\t\thasLargeContent := len(content) > tools.LargeContentThreshold\n\n\t\t\t\tif hasLargeContent {\n\t\t\t\t\ttempFile, err := os.CreateTemp(tmpDir, \"page-*.md\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"Failed to create temporary file: %s\", err)), nil\n\t\t\t\t\t}\n\t\t\t\t\ttempFilePath := tempFile.Name()\n\n\t\t\t\t\tif _, err := tempFile.WriteString(content); err != nil {\n\t\t\t\t\t\ttempFile.Close()\n\t\t\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"Failed to write content to file: %s\", err)), nil\n\t\t\t\t\t}\n\t\t\t\t\ttempFile.Close()\n\n\t\t\t\t\tfullPrompt = fmt.Sprintf(\"%s\\n\\nThe web page from %s has been saved to: %s\\n\\nUse the view and grep tools to analyze this file and extract the requested information.\", params.Prompt, params.URL, tempFilePath)\n\t\t\t\t} else {\n\t\t\t\t\tfullPrompt = fmt.Sprintf(\"%s\\n\\nWeb page URL: %s\\n\\n<webpage_content>\\n%s\\n</webpage_content>\", params.Prompt, params.URL, content)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Search mode: let the sub-agent search and fetch as needed.\n\t\t\t\tfullPrompt = fmt.Sprintf(\"%s\\n\\nUse the web_search tool to find relevant information. Break down the question into smaller, focused searches if needed. After searching, use web_fetch to get detailed content from the most relevant results.\", params.Prompt)\n\t\t\t}\n\n\t\t\tpromptOpts := []prompt.Option{\n\t\t\t\tprompt.WithWorkingDir(tmpDir),\n\t\t\t}\n\n\t\t\tpromptTemplate, err := prompt.NewPrompt(\"agentic_fetch\", string(agenticFetchPromptTmpl), promptOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error creating prompt: %s\", err)), nil\n\t\t\t}\n\n\t\t\t_, small, err := c.buildAgentModels(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error building models: %s\", err)), nil\n\t\t\t}\n\n\t\t\tsystemPrompt, err := promptTemplate.Build(ctx, small.Model.Provider(), small.Model.Model(), *c.cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error building system prompt: %s\", err)), nil\n\t\t\t}\n\n\t\t\tsmallProviderCfg, ok := c.cfg.Providers.Get(small.ModelCfg.Provider)\n\t\t\tif !ok {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"small model provider not configured\"), nil\n\t\t\t}\n\n\t\t\twebFetchTool := tools.NewWebFetchTool(tmpDir, client)\n\t\t\twebSearchTool := tools.NewWebSearchTool(client)\n\t\t\tfetchTools := []fantasy.AgentTool{\n\t\t\t\twebFetchTool,\n\t\t\t\twebSearchTool,\n\t\t\t\ttools.NewGlobTool(tmpDir),\n\t\t\t\ttools.NewGrepTool(tmpDir),\n\t\t\t\ttools.NewSourcegraphTool(client),\n\t\t\t\ttools.NewViewTool(c.lspClients, c.permissions, tmpDir),\n\t\t\t}\n\n\t\t\tagent := NewSessionAgent(SessionAgentOptions{\n\t\t\t\tLargeModel:           small, // Use small model for both (fetch doesn't need large)\n\t\t\t\tSmallModel:           small,\n\t\t\t\tSystemPromptPrefix:   smallProviderCfg.SystemPromptPrefix,\n\t\t\t\tSystemPrompt:         systemPrompt,\n\t\t\t\tDisableAutoSummarize: c.cfg.Options.DisableAutoSummarize,\n\t\t\t\tIsYolo:               c.permissions.SkipRequests(),\n\t\t\t\tSessions:             c.sessions,\n\t\t\t\tMessages:             c.messages,\n\t\t\t\tTools:                fetchTools,\n\t\t\t})\n\n\t\t\tagentToolSessionID := c.sessions.CreateAgentToolSessionID(validationResult.AgentMessageID, call.ID)\n\t\t\tsession, err := c.sessions.CreateTaskSession(ctx, agentToolSessionID, validationResult.SessionID, \"Fetch Analysis\")\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error creating session: %s\", err)), nil\n\t\t\t}\n\n\t\t\tc.permissions.AutoApproveSession(session.ID)\n\n\t\t\t// Use small model for web content analysis (faster and cheaper)\n\t\t\tmaxTokens := small.CatwalkCfg.DefaultMaxTokens\n\t\t\tif small.ModelCfg.MaxTokens != 0 {\n\t\t\t\tmaxTokens = small.ModelCfg.MaxTokens\n\t\t\t}\n\t\t\t// Ensure max tokens is at least 1\n\t\t\tif maxTokens < 1 {\n\t\t\t\tmaxTokens = 4096\n\t\t\t\tslog.Warn(\"agentic_fetch: MaxTokens < 1, using fallback\", \"original\", maxTokens, \"fallback\", 4096)\n\t\t\t}\n\n\t\t\tresult, err := agent.Run(ctx, SessionAgentCall{\n\t\t\t\tSessionID:        session.ID,\n\t\t\t\tPrompt:           fullPrompt,\n\t\t\t\tMaxOutputTokens:  maxTokens,\n\t\t\t\tProviderOptions:  getProviderOptions(small, smallProviderCfg),\n\t\t\t\tTemperature:      small.ModelCfg.Temperature,\n\t\t\t\tTopP:             small.ModelCfg.TopP,\n\t\t\t\tTopK:             small.ModelCfg.TopK,\n\t\t\t\tFrequencyPenalty: small.ModelCfg.FrequencyPenalty,\n\t\t\t\tPresencePenalty:  small.ModelCfg.PresencePenalty,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"error generating response\"), nil\n\t\t\t}\n\n\t\t\tupdatedSession, err := c.sessions.Get(ctx, session.ID)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error getting session: %s\", err)), nil\n\t\t\t}\n\t\t\tparentSession, err := c.sessions.Get(ctx, validationResult.SessionID)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error getting parent session: %s\", err)), nil\n\t\t\t}\n\n\t\t\tparentSession.Cost += updatedSession.Cost\n\n\t\t\t_, err = c.sessions.Save(ctx, parentSession)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.NewTextErrorResponse(fmt.Sprintf(\"error saving parent session: %s\", err)), nil\n\t\t\t}\n\n\t\t\treturn fantasy.NewTextResponse(result.Response.Content.Text()), nil\n\t\t}), nil\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}