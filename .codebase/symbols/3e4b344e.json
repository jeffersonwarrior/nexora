{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/error.rs",
  "file_hash": "99f19001928bc7b78237218150183a012f68cabe",
  "updated_at": "2025-12-26T17:34:19.684173",
  "symbols": {
    "struct_ErrorResponse_12": {
      "name": "ErrorResponse",
      "type": "struct",
      "start_line": 12,
      "end_line": 17,
      "content_hash": "985303fcacea995e3c6417a8a977b67e88dcd55c",
      "content": "struct ErrorResponse {\n    error: String,\n    code: &'static str,\n}\n\n#[derive(Debug, Error)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_HelixError_18": {
      "name": "HelixError",
      "type": "enum",
      "start_line": 18,
      "end_line": 28,
      "content_hash": "36b4b3c7ca1407cc577386b5eb78540ff0a51b7a",
      "content": "pub enum HelixError {\n    #[error(\"{0}\")]\n    Graph(#[from] GraphError),\n    #[error(\"{0}\")]\n    Vector(#[from] VectorError),\n    #[error(\"Couldn't find `{name}` of type {ty:?}\")]\n    NotFound { ty: RequestType, name: String },\n    #[error(\"Invalid API key\")]\n    InvalidApiKey,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixError_29": {
      "name": "HelixError",
      "type": "impl",
      "start_line": 29,
      "end_line": 29,
      "content_hash": "360c75ac4f005157e0649985a85ffaa764c6fc6f",
      "content": "impl HelixError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_code_30": {
      "name": "code",
      "type": "method",
      "start_line": 30,
      "end_line": 39,
      "content_hash": "5f12207ba8536977e155e6ab601cbe2655cf6447",
      "content": "    fn code(&self) -> &'static str {\n        match self {\n            HelixError::Graph(_) => \"GRAPH_ERROR\",\n            HelixError::Vector(_) => \"VECTOR_ERROR\",\n            HelixError::NotFound { .. } => \"NOT_FOUND\",\n            HelixError::InvalidApiKey => \"INVALID_API_KEY\",\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoResponse_40": {
      "name": "IntoResponse",
      "type": "impl",
      "start_line": 40,
      "end_line": 40,
      "content_hash": "4c9c9e13a59b991c3914bb7994de5745fa6c28ae",
      "content": "impl IntoResponse for HelixError {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_response_41": {
      "name": "into_response",
      "type": "method",
      "start_line": 41,
      "end_line": 81,
      "content_hash": "0da40935d2ad8e9a0acc093fd840ffbf4f4e35b9",
      "content": "    fn into_response(self) -> axum::response::Response {\n        let status = match &self {\n            HelixError::Graph(_) | HelixError::Vector(_) => 500,\n            HelixError::NotFound { .. } => 404,\n            HelixError::InvalidApiKey => 403,\n        };\n\n        let error_response = ErrorResponse {\n            error: self.to_string(),\n            code: self.code(),\n        };\n\n        let body = sonic_rs::to_vec(&error_response)\n            .unwrap_or_else(|_| br#\"{\"error\":\"Internal serialization error\",\"code\":\"INTERNAL_ERROR\"}\"#.to_vec());\n\n        axum::response::Response::builder()\n            .status(status)\n            .header(CONTENT_TYPE, \"application/json\")\n            .body(Body::from(body))\n            .unwrap_or_else(|e| {\n                // This should never happen with valid HTTP headers, but handle gracefully\n                tracing::error!(\"Failed to build error response: {e:?}\");\n                axum::response::Response::builder()\n                    .status(500)\n                    .body(Body::from(\n                        r#\"{\"error\":\"Internal server error\",\"code\":\"INTERNAL_ERROR\"}\"#,\n                    ))\n                    .expect(\"static response should always build\")\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // HelixError Variant Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_not_found_82": {
      "name": "test_helix_error_not_found",
      "type": "method",
      "start_line": 82,
      "end_line": 93,
      "content_hash": "bec26fdaa91c235f73312307f944368278d7d1c1",
      "content": "    fn test_helix_error_not_found() {\n        let error = HelixError::NotFound {\n            ty: RequestType::Query,\n            name: \"test_query\".to_string(),\n        };\n\n        let error_string = error.to_string();\n        assert!(error_string.contains(\"test_query\"));\n        assert!(error_string.contains(\"Couldn't find\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_not_found_mcp_94": {
      "name": "test_helix_error_not_found_mcp",
      "type": "method",
      "start_line": 94,
      "end_line": 105,
      "content_hash": "c5b59eabaa25bafd2ecd2f76c35c97bcfc13dda1",
      "content": "    fn test_helix_error_not_found_mcp() {\n        let error = HelixError::NotFound {\n            ty: RequestType::MCP,\n            name: \"test_mcp\".to_string(),\n        };\n\n        let error_string = error.to_string();\n        assert!(error_string.contains(\"test_mcp\"));\n        assert!(error_string.contains(\"MCP\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_graph_106": {
      "name": "test_helix_error_graph",
      "type": "method",
      "start_line": 106,
      "end_line": 115,
      "content_hash": "13464bc3e932769e57b42bc1a22721ab14c6da40",
      "content": "    fn test_helix_error_graph() {\n        let graph_err = GraphError::DecodeError(\"test decode error\".to_string());\n        let helix_err = HelixError::from(graph_err);\n\n        assert!(matches!(helix_err, HelixError::Graph(_)));\n        let error_string = helix_err.to_string();\n        assert!(error_string.contains(\"test decode error\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_vector_116": {
      "name": "test_helix_error_vector",
      "type": "method",
      "start_line": 116,
      "end_line": 127,
      "content_hash": "0d34d502db56a26bba8f607e4b777f57d776ef45",
      "content": "    fn test_helix_error_vector() {\n        let vector_err = VectorError::InvalidVectorLength;\n        let helix_err = HelixError::from(vector_err);\n\n        assert!(matches!(helix_err, HelixError::Vector(_)));\n    }\n\n    // ============================================================================\n    // IntoResponse Tests (HTTP Status Codes and JSON Format)\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_into_response_not_found_128": {
      "name": "test_helix_error_into_response_not_found",
      "type": "method",
      "start_line": 128,
      "end_line": 142,
      "content_hash": "4144b9932db31d9d7a5382611cd075c5eb5a41fb",
      "content": "    fn test_helix_error_into_response_not_found() {\n        let error = HelixError::NotFound {\n            ty: RequestType::Query,\n            name: \"missing\".to_string(),\n        };\n\n        let response = error.into_response();\n        assert_eq!(response.status(), 404);\n        assert_eq!(\n            response.headers().get(CONTENT_TYPE).unwrap(),\n            \"application/json\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_into_response_graph_error_143": {
      "name": "test_helix_error_into_response_graph_error",
      "type": "method",
      "start_line": 143,
      "end_line": 155,
      "content_hash": "0d76a7b60fc30976726883d0458bc6443f21d61c",
      "content": "    fn test_helix_error_into_response_graph_error() {\n        let graph_err = GraphError::DecodeError(\"decode failed\".to_string());\n        let helix_err = HelixError::from(graph_err);\n\n        let response = helix_err.into_response();\n        assert_eq!(response.status(), 500);\n        assert_eq!(\n            response.headers().get(CONTENT_TYPE).unwrap(),\n            \"application/json\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_into_response_vector_error_156": {
      "name": "test_helix_error_into_response_vector_error",
      "type": "method",
      "start_line": 156,
      "end_line": 172,
      "content_hash": "e748016b79135ab88b4aef318de2725112701391",
      "content": "    fn test_helix_error_into_response_vector_error() {\n        let vector_err = VectorError::InvalidVectorData;\n        let helix_err = HelixError::from(vector_err);\n\n        let response = helix_err.into_response();\n        assert_eq!(response.status(), 500);\n        assert_eq!(\n            response.headers().get(CONTENT_TYPE).unwrap(),\n            \"application/json\"\n        );\n    }\n\n    // ============================================================================\n    // Error Code Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_code_graph_173": {
      "name": "test_helix_error_code_graph",
      "type": "method",
      "start_line": 173,
      "end_line": 178,
      "content_hash": "2a422bc2f0498a78292d74580700188e9c5ce51c",
      "content": "    fn test_helix_error_code_graph() {\n        let error = HelixError::Graph(GraphError::NodeNotFound);\n        assert_eq!(error.code(), \"GRAPH_ERROR\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_code_vector_179": {
      "name": "test_helix_error_code_vector",
      "type": "method",
      "start_line": 179,
      "end_line": 184,
      "content_hash": "cbfd7f57e2dcf45a14a1fed3143c81c1d41151b9",
      "content": "    fn test_helix_error_code_vector() {\n        let error = HelixError::Vector(VectorError::InvalidVectorLength);\n        assert_eq!(error.code(), \"VECTOR_ERROR\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_code_not_found_185": {
      "name": "test_helix_error_code_not_found",
      "type": "method",
      "start_line": 185,
      "end_line": 193,
      "content_hash": "6722f72f442f8993c73601f4c5fd648043101ca7",
      "content": "    fn test_helix_error_code_not_found() {\n        let error = HelixError::NotFound {\n            ty: RequestType::Query,\n            name: \"test\".to_string(),\n        };\n        assert_eq!(error.code(), \"NOT_FOUND\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_code_invalid_api_key_194": {
      "name": "test_helix_error_code_invalid_api_key",
      "type": "method",
      "start_line": 194,
      "end_line": 203,
      "content_hash": "d39973d5bd26a271e5a3ba8f4e6800be4d1e5c5f",
      "content": "    fn test_helix_error_code_invalid_api_key() {\n        let error = HelixError::InvalidApiKey;\n        assert_eq!(error.code(), \"INVALID_API_KEY\");\n    }\n\n    // ============================================================================\n    // Error Trait Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_is_error_trait_204": {
      "name": "test_helix_error_is_error_trait",
      "type": "method",
      "start_line": 204,
      "end_line": 215,
      "content_hash": "c4b85569546a17a12c23e06b77fc544858466250",
      "content": "    fn test_helix_error_is_error_trait() {\n        let error = HelixError::NotFound {\n            ty: RequestType::Query,\n            name: \"test\".to_string(),\n        };\n\n        // Test that it implements std::error::Error\n        fn assert_error<T: std::error::Error>(_: T) {}\n        assert_error(error);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_debug_216": {
      "name": "test_helix_error_debug",
      "type": "method",
      "start_line": 216,
      "end_line": 231,
      "content_hash": "0e59c56ce57f21587c99b4c07b85d80e6ec4e9fa",
      "content": "    fn test_helix_error_debug() {\n        let error = HelixError::NotFound {\n            ty: RequestType::Query,\n            name: \"debug_test\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"NotFound\"));\n        assert!(debug_str.contains(\"debug_test\"));\n    }\n\n    // ============================================================================\n    // InvalidApiKey Tests\n    // ============================================================================\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_invalid_api_key_232": {
      "name": "test_helix_error_invalid_api_key",
      "type": "method",
      "start_line": 232,
      "end_line": 238,
      "content_hash": "def4bd41b5d8392507cc136eeeb98a1ded55aed8",
      "content": "    fn test_helix_error_invalid_api_key() {\n        let error = HelixError::InvalidApiKey;\n        let error_string = error.to_string();\n        assert_eq!(error_string, \"Invalid API key\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_invalid_api_key_into_response_239": {
      "name": "test_helix_error_invalid_api_key_into_response",
      "type": "method",
      "start_line": 239,
      "end_line": 245,
      "content_hash": "e0c22bc333ce7df29e2e1aaef4eeecd7aa6381a2",
      "content": "    fn test_helix_error_invalid_api_key_into_response() {\n        let error = HelixError::InvalidApiKey;\n        let response = error.into_response();\n        assert_eq!(response.status(), 403);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_helix_error_invalid_api_key_debug_246": {
      "name": "test_helix_error_invalid_api_key_debug",
      "type": "method",
      "start_line": 246,
      "end_line": 251,
      "content_hash": "7c902046bb0aae77773dfe779f315a9c61191fed",
      "content": "    fn test_helix_error_invalid_api_key_debug() {\n        let error = HelixError::InvalidApiKey;\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"InvalidApiKey\"));\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}