{
  "file_path": "/work/internal/agent/tools/hooks_test.go",
  "file_hash": "0513e3568775815ad2a313415d8ac3a37a214377",
  "updated_at": "2025-12-26T17:34:19.716838",
  "symbols": {
    "function_TestNewHookChain_12": {
      "name": "TestNewHookChain",
      "type": "function",
      "start_line": 12,
      "end_line": 20,
      "content_hash": "d2621b6aeeafddd747e7620ef6dc5e3307f39263",
      "content": "func TestNewHookChain(t *testing.T) {\n\thook1 := NewSecurityHook([]string{\"bash\"}, []string{})\n\thook2 := NewMetricsHook()\n\n\tchain := NewHookChain(hook1, hook2)\n\tassert.NotNil(t, chain)\n\tassert.Len(t, chain.hooks, 2)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHookChain_BeforeCall_21": {
      "name": "TestHookChain_BeforeCall",
      "type": "function",
      "start_line": 21,
      "end_line": 36,
      "content_hash": "e473f5054c3e149a57db907cbbf4bfeaba172ef7",
      "content": "func TestHookChain_BeforeCall(t *testing.T) {\n\thook := NewSecurityHook([]string{\"bash\"}, []string{})\n\tchain := NewHookChain(hook)\n\n\tctx := context.Background()\n\n\t// Allowed tool\n\terr := chain.BeforeCall(ctx, \"bash\", map[string]interface{}{})\n\tassert.NoError(t, err)\n\n\t// Disallowed tool\n\terr = chain.BeforeCall(ctx, \"forbidden\", map[string]interface{}{})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"not allowed\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHookChain_AfterCall_37": {
      "name": "TestHookChain_AfterCall",
      "type": "function",
      "start_line": 37,
      "end_line": 51,
      "content_hash": "8e6b3de9a991a7f92b8d8516cd6853c967643835",
      "content": "func TestHookChain_AfterCall(t *testing.T) {\n\thook := NewMetricsHook()\n\tchain := NewHookChain(hook)\n\n\tctx := context.Background()\n\n\t// Must call BeforeCall first to initialize metrics\n\tchain.BeforeCall(ctx, \"test-tool\", nil)\n\n\tresp := fantasy.NewTextResponse(\"test\")\n\n\tresult := chain.AfterCall(ctx, \"test-tool\", resp)\n\tassert.Equal(t, resp, result)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHookChain_OnError_52": {
      "name": "TestHookChain_OnError",
      "type": "function",
      "start_line": 52,
      "end_line": 66,
      "content_hash": "b261f1c50fcfe945da912a157f27fdb81f06eff6",
      "content": "func TestHookChain_OnError(t *testing.T) {\n\thook := NewMetricsHook()\n\tchain := NewHookChain(hook)\n\n\tctx := context.Background()\n\n\t// Must call BeforeCall first to initialize metrics\n\tchain.BeforeCall(ctx, \"test-tool\", nil)\n\n\ttestErr := assert.AnError\n\n\terr := chain.OnError(ctx, \"test-tool\", testErr)\n\tassert.Error(t, err)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSecurityHook_AllowedTools_67": {
      "name": "TestSecurityHook_AllowedTools",
      "type": "function",
      "start_line": 67,
      "end_line": 104,
      "content_hash": "6044e07b1489f431a056480cf3dc093b873d7edf",
      "content": "func TestSecurityHook_AllowedTools(t *testing.T) {\n\thook := NewSecurityHook([]string{\"bash\", \"read\", \"write\"}, []string{})\n\n\ttests := []struct {\n\t\tname      string\n\t\ttoolName  string\n\t\twantError bool\n\t}{\n\t\t{\n\t\t\tname:      \"allowed bash\",\n\t\t\ttoolName:  \"bash\",\n\t\t\twantError: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"allowed read\",\n\t\t\ttoolName:  \"read\",\n\t\t\twantError: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"disallowed tool\",\n\t\t\ttoolName:  \"dangerous\",\n\t\t\twantError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := hook.BeforeCall(context.Background(), tt.toolName, nil)\n\t\t\tif tt.wantError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), \"not allowed\")\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSecurityHook_EmptyAllowList_105": {
      "name": "TestSecurityHook_EmptyAllowList",
      "type": "function",
      "start_line": 105,
      "end_line": 112,
      "content_hash": "675d44d42c1f5d4252398c99736a2fe5660711ee",
      "content": "func TestSecurityHook_EmptyAllowList(t *testing.T) {\n\t// Empty allow list means all tools allowed\n\thook := NewSecurityHook([]string{}, []string{})\n\n\terr := hook.BeforeCall(context.Background(), \"any-tool\", nil)\n\tassert.NoError(t, err)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSecurityHook_AfterCallPassthrough_113": {
      "name": "TestSecurityHook_AfterCallPassthrough",
      "type": "function",
      "start_line": 113,
      "end_line": 120,
      "content_hash": "50123d3c6406ab745d6ff6e43148caafbb271260",
      "content": "func TestSecurityHook_AfterCallPassthrough(t *testing.T) {\n\thook := NewSecurityHook([]string{\"bash\"}, []string{})\n\tresp := fantasy.NewTextResponse(\"test\")\n\n\tresult := hook.AfterCall(context.Background(), \"bash\", resp)\n\tassert.Equal(t, resp, result)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestSecurityHook_OnErrorPassthrough_121": {
      "name": "TestSecurityHook_OnErrorPassthrough",
      "type": "function",
      "start_line": 121,
      "end_line": 128,
      "content_hash": "bf915d40c05de9fef5bf98f5a2f991a2456684fb",
      "content": "func TestSecurityHook_OnErrorPassthrough(t *testing.T) {\n\thook := NewSecurityHook([]string{\"bash\"}, []string{})\n\ttestErr := assert.AnError\n\n\terr := hook.OnError(context.Background(), \"bash\", testErr)\n\tassert.Equal(t, testErr, err)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMetricsHook_TracksCalls_129": {
      "name": "TestMetricsHook_TracksCalls",
      "type": "function",
      "start_line": 129,
      "end_line": 152,
      "content_hash": "b2ad14536ae5ef8badaa531b83d11a09745495fa",
      "content": "func TestMetricsHook_TracksCalls(t *testing.T) {\n\thook := NewMetricsHook()\n\tctx := context.Background()\n\n\t// Make multiple calls\n\terr := hook.BeforeCall(ctx, \"bash\", nil)\n\trequire.NoError(t, err)\n\n\terr = hook.BeforeCall(ctx, \"bash\", nil)\n\trequire.NoError(t, err)\n\n\terr = hook.BeforeCall(ctx, \"read\", nil)\n\trequire.NoError(t, err)\n\n\t// Check metrics\n\tbashMetrics := hook.GetMetrics(\"bash\")\n\tassert.NotNil(t, bashMetrics)\n\tassert.Equal(t, int64(2), bashMetrics.CallCount)\n\n\treadMetrics := hook.GetMetrics(\"read\")\n\tassert.NotNil(t, readMetrics)\n\tassert.Equal(t, int64(1), readMetrics.CallCount)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMetricsHook_TracksSuccess_153": {
      "name": "TestMetricsHook_TracksSuccess",
      "type": "function",
      "start_line": 153,
      "end_line": 168,
      "content_hash": "d300ec5a07d42e3d4811b36bdb057840be891fa2",
      "content": "func TestMetricsHook_TracksSuccess(t *testing.T) {\n\thook := NewMetricsHook()\n\tctx := context.Background()\n\n\t// Setup tool\n\thook.BeforeCall(ctx, \"test\", nil)\n\n\t// Successful response\n\tresp := fantasy.NewTextResponse(\"success\")\n\thook.AfterCall(ctx, \"test\", resp)\n\n\tmetrics := hook.GetMetrics(\"test\")\n\tassert.Equal(t, int64(1), metrics.SuccessCount)\n\tassert.Equal(t, int64(0), metrics.ErrorCount)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMetricsHook_TracksErrors_169": {
      "name": "TestMetricsHook_TracksErrors",
      "type": "function",
      "start_line": 169,
      "end_line": 182,
      "content_hash": "77265eb4bc8f5486e276834c016136f7a7be04bc",
      "content": "func TestMetricsHook_TracksErrors(t *testing.T) {\n\thook := NewMetricsHook()\n\tctx := context.Background()\n\n\t// Setup tool\n\thook.BeforeCall(ctx, \"test\", nil)\n\n\t// Error\n\thook.OnError(ctx, \"test\", assert.AnError)\n\n\tmetrics := hook.GetMetrics(\"test\")\n\tassert.Equal(t, int64(1), metrics.ErrorCount)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMetricsHook_AllMetrics_183": {
      "name": "TestMetricsHook_AllMetrics",
      "type": "function",
      "start_line": 183,
      "end_line": 198,
      "content_hash": "229ef3aa77bcd173c00a5d40b562a9801c442bbc",
      "content": "func TestMetricsHook_AllMetrics(t *testing.T) {\n\thook := NewMetricsHook()\n\tctx := context.Background()\n\n\t// Track multiple tools\n\thook.BeforeCall(ctx, \"bash\", nil)\n\thook.BeforeCall(ctx, \"read\", nil)\n\thook.BeforeCall(ctx, \"write\", nil)\n\n\tallMetrics := hook.AllMetrics()\n\tassert.Len(t, allMetrics, 3)\n\tassert.Contains(t, allMetrics, \"bash\")\n\tassert.Contains(t, allMetrics, \"read\")\n\tassert.Contains(t, allMetrics, \"write\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestMetricsHook_GetMetricsReturnsNil_199": {
      "name": "TestMetricsHook_GetMetricsReturnsNil",
      "type": "function",
      "start_line": 199,
      "end_line": 205,
      "content_hash": "4289c4c52ac963705287b612319e933c6a54b7b0",
      "content": "func TestMetricsHook_GetMetricsReturnsNil(t *testing.T) {\n\thook := NewMetricsHook()\n\n\tmetrics := hook.GetMetrics(\"nonexistent\")\n\tassert.Nil(t, metrics)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNameOfHook_206": {
      "name": "TestNameOfHook",
      "type": "function",
      "start_line": 206,
      "end_line": 231,
      "content_hash": "68e0ee63f9f2d447274e89fc7da647d3755ad5fd",
      "content": "func TestNameOfHook(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\thook     ToolHook\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"security hook\",\n\t\t\thook:     NewSecurityHook([]string{}, []string{}),\n\t\t\texpected: \"SecurityHook\",\n\t\t},\n\t\t{\n\t\t\tname:     \"metrics hook\",\n\t\t\thook:     NewMetricsHook(),\n\t\t\texpected: \"MetricsHook\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := nameOfHook(tt.hook)\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestErrToolNotAllowed_232": {
      "name": "TestErrToolNotAllowed",
      "type": "function",
      "start_line": 232,
      "end_line": 238,
      "content_hash": "5f1551a4033ed2c382a9bf8ffee7bbda8bcbe364",
      "content": "func TestErrToolNotAllowed(t *testing.T) {\n\terr := ErrToolNotAllowed(\"dangerous-tool\")\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"dangerous-tool\")\n\tassert.Contains(t, err.Error(), \"not allowed\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHookChain_MultipleHooksSequential_239": {
      "name": "TestHookChain_MultipleHooksSequential",
      "type": "function",
      "start_line": 239,
      "end_line": 263,
      "content_hash": "6245772e4790d8caaeab4bde5f6b271161286026",
      "content": "func TestHookChain_MultipleHooksSequential(t *testing.T) {\n\tsecurity := NewSecurityHook([]string{\"allowed\"}, []string{})\n\tmetrics := NewMetricsHook()\n\tchain := NewHookChain(security, metrics)\n\n\tctx := context.Background()\n\n\t// Allowed tool - both hooks should execute\n\terr := chain.BeforeCall(ctx, \"allowed\", nil)\n\tassert.NoError(t, err)\n\n\t// Verify metrics hook was called\n\tm := metrics.GetMetrics(\"allowed\")\n\tassert.NotNil(t, m)\n\tassert.Equal(t, int64(1), m.CallCount)\n\n\t// Disallowed tool - should stop at security hook\n\terr = chain.BeforeCall(ctx, \"disallowed\", nil)\n\tassert.Error(t, err)\n\n\t// Metrics should still be zero for disallowed\n\tm = metrics.GetMetrics(\"disallowed\")\n\tassert.Nil(t, m)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestHookChain_EmptyChain_264": {
      "name": "TestHookChain_EmptyChain",
      "type": "function",
      "start_line": 264,
      "end_line": 279,
      "content_hash": "07727a44b716c164bf001d54d4f1106ce1dbfa9e",
      "content": "func TestHookChain_EmptyChain(t *testing.T) {\n\tchain := NewHookChain()\n\n\tctx := context.Background()\n\n\t// Should not error with empty chain\n\terr := chain.BeforeCall(ctx, \"any\", nil)\n\tassert.NoError(t, err)\n\n\tresp := fantasy.NewTextResponse(\"test\")\n\tresult := chain.AfterCall(ctx, \"any\", resp)\n\tassert.Equal(t, resp, result)\n\n\terr = chain.OnError(ctx, \"any\", assert.AnError)\n\tassert.Error(t, err)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}