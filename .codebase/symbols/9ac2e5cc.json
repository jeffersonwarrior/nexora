{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/builtin/node_by_id.rs",
  "file_hash": "6034bc12f27e5bd9dfd04869a07e3e983a99b0c3",
  "updated_at": "2025-12-26T17:34:22.431955",
  "symbols": {
    "struct_NodeDetailsQuery_21": {
      "name": "NodeDetailsQuery",
      "type": "struct",
      "start_line": 21,
      "end_line": 54,
      "content_hash": "64a55f4d7487f17db88b6e296413546763e2ec4e",
      "content": "pub struct NodeDetailsQuery {\n    id: String,\n}\n\npub async fn node_details_handler(\n    State(state): State<Arc<AppState>>,\n    Query(params): Query<NodeDetailsQuery>,\n) -> axum::http::Response<Body> {\n    let mut req = protocol::request::Request {\n        name: \"node_details\".to_string(),\n        req_type: RequestType::Query,\n        api_key: None,\n        body: axum::body::Bytes::new(),\n        in_fmt: protocol::Format::default(),\n        out_fmt: protocol::Format::default(),\n    };\n\n    if let Ok(params_json) = sonic_rs::to_vec(&json!({\n        \"id\": params.id\n    })) {\n        req.body = axum::body::Bytes::from(params_json);\n    }\n\n    let res = state.worker_pool.process(req).await;\n\n    match res {\n        Ok(r) => r.into_response(),\n        Err(e) => {\n            info!(?e, \"Got error\");\n            e.into_response()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_node_details_inner_55": {
      "name": "node_details_inner",
      "type": "function",
      "start_line": 55,
      "end_line": 147,
      "content_hash": "eb87c47ed8c74bb7251e6c3f1e3b49dd5f0be9cb",
      "content": "pub fn node_details_inner(input: HandlerInput) -> Result<protocol::Response, GraphError> {\n    let db = Arc::clone(&input.graph.storage);\n    let txn = db.graph_env.read_txn().map_err(GraphError::from)?;\n    let arena = bumpalo::Bump::new();\n\n    let node_id_str = if !input.request.body.is_empty() {\n        match sonic_rs::from_slice::<sonic_rs::Value>(&input.request.body) {\n            Ok(params) => params\n                .get(\"id\")\n                .and_then(|v| v.as_str())\n                .map(|s| s.to_string()),\n            Err(_) => None,\n        }\n    } else {\n        None\n    };\n\n    let node_id_str = node_id_str.ok_or_else(|| GraphError::New(\"id is required\".to_string()))?;\n\n    let node_id = match uuid::Uuid::parse_str(&node_id_str) {\n        Ok(uuid) => uuid.as_u128(),\n        Err(_) => match node_id_str.parse::<u128>() {\n            Ok(id) => id,\n            Err(_) => {\n                return Err(GraphError::New(\n                    \"invalid ID format: must be UUID or u128\".to_string(),\n                ));\n            }\n        },\n    };\n\n    let result = match db.get_node(&txn, &node_id, &arena) {\n        Ok(node) => {\n            let id_str = ID::from(node_id).stringify();\n\n            let mut node_json = json!({\n                \"id\": id_str.clone(),\n                \"label\": node.label,\n                \"title\": id_str\n            });\n\n            if let Some(properties) = &node.properties {\n                for (key, value) in properties.iter() {\n                    node_json[key] = sonic_rs::to_value(&value.inner_stringify())\n                        .unwrap_or_else(|_| sonic_rs::Value::from(\"\"));\n                }\n            }\n\n            json!({\n                \"node\": node_json,\n                \"found\": true\n            })\n        }\n        Err(_) => {\n            json!({\n                \"node\": null,\n                \"found\": false\n            })\n        }\n    };\n\n    Ok(protocol::Response {\n        body: sonic_rs::to_vec(&result).map_err(|e| GraphError::New(e.to_string()))?,\n        fmt: Default::default(),\n    })\n}\n\ninventory::submit! {\n    HandlerSubmission(\n        Handler::new(\"node_details\", node_details_inner, false)\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        helix_engine::{\n            storage_core::version_info::VersionInfo,\n            traversal_core::{\n                HelixGraphEngine, HelixGraphEngineOpts,\n                config::Config,\n                ops::{g::G, source::add_n::AddNAdapter},\n            },\n        },\n        helix_gateway::router::router::HandlerInput,\n        protocol::{Format, request::Request, request::RequestType, value::Value},\n        utils::id::ID,\n    };\n    use axum::body::Bytes;\n    use std::sync::Arc;\n    use tempfile::TempDir;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_setup_test_engine_148": {
      "name": "setup_test_engine",
      "type": "function",
      "start_line": 148,
      "end_line": 160,
      "content_hash": "bc59db59deca98ae1700862874b6d2114ed21047",
      "content": "    fn setup_test_engine() -> (HelixGraphEngine, TempDir) {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().to_str().unwrap();\n        let opts = HelixGraphEngineOpts {\n            path: db_path.to_string(),\n            config: Config::default(),\n            version_info: VersionInfo::default(),\n        };\n        let engine = HelixGraphEngine::new(opts).unwrap();\n        (engine, temp_dir)\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_details_found_161": {
      "name": "test_node_details_found",
      "type": "function",
      "start_line": 161,
      "end_line": 209,
      "content_hash": "c601ef8ebc4782c62b884d804b2434d100c95e8c",
      "content": "    fn test_node_details_found() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let props = vec![(\"name\", Value::String(\"Alice\".to_string()))];\n        let props_map = ImmutablePropertiesMap::new(\n            props.len(),\n            props\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let node = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map), None)\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let node_id_str = ID::from(node.id()).stringify();\n        let params_json = sonic_rs::to_vec(&json!({\"id\": node_id_str})).unwrap();\n\n        let request = Request {\n            name: \"node_details\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = node_details_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"found\\\":true\"));\n        Ok(())\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_details_not_found_210": {
      "name": "test_node_details_not_found",
      "type": "function",
      "start_line": 210,
      "end_line": 238,
      "content_hash": "f8f900154d17922ae291a9c2f2d1b3926927c2ca",
      "content": "    fn test_node_details_not_found() {\n        let (engine, _temp_dir) = setup_test_engine();\n\n        let fake_id = uuid::Uuid::new_v4().to_string();\n        let params_json = sonic_rs::to_vec(&json!({\"id\": fake_id})).unwrap();\n\n        let request = Request {\n            name: \"node_details\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = node_details_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"\\\"found\\\":false\"));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_details_invalid_id_format_239": {
      "name": "test_node_details_invalid_id_format",
      "type": "function",
      "start_line": 239,
      "end_line": 262,
      "content_hash": "5971eb8560937d0c1001dbb83656d029e6c7d85a",
      "content": "    fn test_node_details_invalid_id_format() {\n        let (engine, _temp_dir) = setup_test_engine();\n\n        let params_json = sonic_rs::to_vec(&json!({\"id\": \"not-a-valid-id\"})).unwrap();\n\n        let request = Request {\n            name: \"node_details\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = node_details_inner(input);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_details_missing_id_263": {
      "name": "test_node_details_missing_id",
      "type": "function",
      "start_line": 263,
      "end_line": 284,
      "content_hash": "b2979a7ab2fea2832fb7cfb3bc9942e4e5c0ae61",
      "content": "    fn test_node_details_missing_id() {\n        let (engine, _temp_dir) = setup_test_engine();\n\n        let request = Request {\n            name: \"node_details\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::new(),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = node_details_inner(input);\n        assert!(result.is_err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_details_with_properties_285": {
      "name": "test_node_details_with_properties",
      "type": "function",
      "start_line": 285,
      "end_line": 336,
      "content_hash": "59f1e8a5ac9b312f089359f6e3c6fa6ad44364e9",
      "content": "    fn test_node_details_with_properties() -> Result<(), Box<dyn std::error::Error>> {\n        use crate::utils::properties::ImmutablePropertiesMap;\n\n        let (engine, _temp_dir) = setup_test_engine();\n        let mut txn = engine.storage.graph_env.write_txn().unwrap();\n        let arena = bumpalo::Bump::new();\n\n        let props = vec![\n            (\"name\", Value::String(\"Alice\".to_string())),\n            (\"age\", Value::I64(30)),\n        ];\n        let props_map = ImmutablePropertiesMap::new(\n            props.len(),\n            props\n                .iter()\n                .map(|(k, v)| (arena.alloc_str(k) as &str, v.clone())),\n            &arena,\n        );\n\n        let node = G::new_mut(&engine.storage, &arena, &mut txn)\n            .add_n(arena.alloc_str(\"person\"), Some(props_map), None)\n            .collect_to_obj()?;\n\n        txn.commit().unwrap();\n\n        let node_id_str = ID::from(node.id()).stringify();\n        let params_json = sonic_rs::to_vec(&json!({\"id\": node_id_str})).unwrap();\n\n        let request = Request {\n            name: \"node_details\".to_string(),\n            req_type: RequestType::Query,\n            api_key: None,\n            body: Bytes::from(params_json),\n            in_fmt: Format::Json,\n            out_fmt: Format::Json,\n        };\n\n        let input = HandlerInput {\n            graph: Arc::new(engine),\n            request,\n        };\n\n        let result = node_details_inner(input);\n        assert!(result.is_ok());\n\n        let response = result.unwrap();\n        let body_str = String::from_utf8(response.body).unwrap();\n        assert!(body_str.contains(\"Alice\"));\n        assert!(body_str.contains(\"30\"));\n        Ok(())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}