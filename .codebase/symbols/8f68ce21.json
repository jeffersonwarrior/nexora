{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/http/routes/DataRoutes.ts",
  "file_hash": "ea1344d3a3878e82948728cfba45aba1d00c3475",
  "updated_at": "2025-12-26T17:34:21.783571",
  "symbols": {
    "class_DataRoutes_21": {
      "name": "DataRoutes",
      "type": "class",
      "start_line": 21,
      "end_line": 367,
      "content_hash": "39d5cf145ca694e1657397b5425a203a97870635",
      "content": "export class DataRoutes extends BaseRouteHandler {\n  constructor(\n    private paginationHelper: PaginationHelper,\n    private dbManager: DatabaseManager,\n    private sessionManager: SessionManager,\n    private sseBroadcaster: SSEBroadcaster,\n    private workerService: WorkerService,\n    private startTime: number\n  ) {\n    super();\n  }\n\n  setupRoutes(app: express.Application): void {\n    // Pagination endpoints\n    app.get('/api/observations', this.handleGetObservations.bind(this));\n    app.get('/api/summaries', this.handleGetSummaries.bind(this));\n    app.get('/api/prompts', this.handleGetPrompts.bind(this));\n\n    // Fetch by ID endpoints\n    app.get('/api/observation/:id', this.handleGetObservationById.bind(this));\n    app.post('/api/observations/batch', this.handleGetObservationsByIds.bind(this));\n    app.get('/api/session/:id', this.handleGetSessionById.bind(this));\n    app.post('/api/sdk-sessions/batch', this.handleGetSdkSessionsByIds.bind(this));\n    app.get('/api/prompt/:id', this.handleGetPromptById.bind(this));\n\n    // Metadata endpoints\n    app.get('/api/stats', this.handleGetStats.bind(this));\n    app.get('/api/projects', this.handleGetProjects.bind(this));\n\n    // Processing status endpoints\n    app.get('/api/processing-status', this.handleGetProcessingStatus.bind(this));\n    app.post('/api/processing', this.handleSetProcessing.bind(this));\n\n    // Import endpoint\n    app.post('/api/import', this.handleImport.bind(this));\n  }\n\n  /**\n   * Get paginated observations\n   */\n  private handleGetObservations = this.wrapHandler((req: Request, res: Response): void => {\n    const { offset, limit, project } = this.parsePaginationParams(req);\n    const result = this.paginationHelper.getObservations(offset, limit, project);\n    res.json(result);\n  });\n\n  /**\n   * Get paginated summaries\n   */\n  private handleGetSummaries = this.wrapHandler((req: Request, res: Response): void => {\n    const { offset, limit, project } = this.parsePaginationParams(req);\n    const result = this.paginationHelper.getSummaries(offset, limit, project);\n    res.json(result);\n  });\n\n  /**\n   * Get paginated user prompts\n   */\n  private handleGetPrompts = this.wrapHandler((req: Request, res: Response): void => {\n    const { offset, limit, project } = this.parsePaginationParams(req);\n    const result = this.paginationHelper.getPrompts(offset, limit, project);\n    res.json(result);\n  });\n\n  /**\n   * Get observation by ID\n   * GET /api/observation/:id\n   */\n  private handleGetObservationById = this.wrapHandler((req: Request, res: Response): void => {\n    const id = this.parseIntParam(req, res, 'id');\n    if (id === null) return;\n\n    const store = this.dbManager.getSessionStore();\n    const observation = store.getObservationById(id);\n\n    if (!observation) {\n      this.notFound(res, `Observation #${id} not found`);\n      return;\n    }\n\n    res.json(observation);\n  });\n\n  /**\n   * Get observations by array of IDs\n   * POST /api/observations/batch\n   * Body: { ids: number[], orderBy?: 'date_desc' | 'date_asc', limit?: number, project?: string }\n   */\n  private handleGetObservationsByIds = this.wrapHandler((req: Request, res: Response): void => {\n    const { ids, orderBy, limit, project } = req.body;\n\n    if (!ids || !Array.isArray(ids)) {\n      this.badRequest(res, 'ids must be an array of numbers');\n      return;\n    }\n\n    if (ids.length === 0) {\n      res.json([]);\n      return;\n    }\n\n    // Validate all IDs are numbers\n    if (!ids.every(id => typeof id === 'number' && Number.isInteger(id))) {\n      this.badRequest(res, 'All ids must be integers');\n      return;\n    }\n\n    const store = this.dbManager.getSessionStore();\n    const observations = store.getObservationsByIds(ids, { orderBy, limit, project });\n\n    res.json(observations);\n  });\n\n  /**\n   * Get session by ID\n   * GET /api/session/:id\n   */\n  private handleGetSessionById = this.wrapHandler((req: Request, res: Response): void => {\n    const id = this.parseIntParam(req, res, 'id');\n    if (id === null) return;\n\n    const store = this.dbManager.getSessionStore();\n    const sessions = store.getSessionSummariesByIds([id]);\n\n    if (sessions.length === 0) {\n      this.notFound(res, `Session #${id} not found`);\n      return;\n    }\n\n    res.json(sessions[0]);\n  });\n\n  /**\n   * Get SDK sessions by SDK session IDs\n   * POST /api/sdk-sessions/batch\n   * Body: { sdkSessionIds: string[] }\n   */\n  private handleGetSdkSessionsByIds = this.wrapHandler((req: Request, res: Response): void => {\n    const { sdkSessionIds } = req.body;\n\n    if (!Array.isArray(sdkSessionIds)) {\n      this.badRequest(res, 'sdkSessionIds must be an array');\n      return;\n    }\n\n    const store = this.dbManager.getSessionStore();\n    const sessions = store.getSdkSessionsBySessionIds(sdkSessionIds);\n    res.json(sessions);\n  });\n\n  /**\n   * Get user prompt by ID\n   * GET /api/prompt/:id\n   */\n  private handleGetPromptById = this.wrapHandler((req: Request, res: Response): void => {\n    const id = this.parseIntParam(req, res, 'id');\n    if (id === null) return;\n\n    const store = this.dbManager.getSessionStore();\n    const prompts = store.getUserPromptsByIds([id]);\n\n    if (prompts.length === 0) {\n      this.notFound(res, `Prompt #${id} not found`);\n      return;\n    }\n\n    res.json(prompts[0]);\n  });\n\n  /**\n   * Get database statistics (with worker metadata)\n   */\n  private handleGetStats = this.wrapHandler((req: Request, res: Response): void => {\n    const db = this.dbManager.getSessionStore().db;\n\n    // Read version from package.json\n    const packageRoot = getPackageRoot();\n    const packageJsonPath = path.join(packageRoot, 'package.json');\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));\n    const version = packageJson.version;\n\n    // Get database stats\n    const totalObservations = db.prepare('SELECT COUNT(*) as count FROM observations').get() as { count: number };\n    const totalSessions = db.prepare('SELECT COUNT(*) as count FROM sdk_sessions').get() as { count: number };\n    const totalSummaries = db.prepare('SELECT COUNT(*) as count FROM session_summaries').get() as { count: number };\n\n    // Get database file size and path\n    const dbPath = path.join(homedir(), '.claude-mem', 'claude-mem.db');\n    let dbSize = 0;\n    if (existsSync(dbPath)) {\n      dbSize = statSync(dbPath).size;\n    }\n\n    // Worker metadata\n    const uptime = Math.floor((Date.now() - this.startTime) / 1000);\n    const activeSessions = this.sessionManager.getActiveSessionCount();\n    const sseClients = this.sseBroadcaster.getClientCount();\n\n    res.json({\n      worker: {\n        version,\n        uptime,\n        activeSessions,\n        sseClients,\n        port: getWorkerPort()\n      },\n      database: {\n        path: dbPath,\n        size: dbSize,\n        observations: totalObservations.count,\n        sessions: totalSessions.count,\n        summaries: totalSummaries.count\n      }\n    });\n  });\n\n  /**\n   * Get list of distinct projects from observations\n   * GET /api/projects\n   */\n  private handleGetProjects = this.wrapHandler((req: Request, res: Response): void => {\n    const db = this.dbManager.getSessionStore().db;\n\n    const rows = db.prepare(`\n      SELECT DISTINCT project\n      FROM observations\n      WHERE project IS NOT NULL\n      GROUP BY project\n      ORDER BY MAX(created_at_epoch) DESC\n    `).all() as Array<{ project: string }>;\n\n    const projects = rows.map(row => row.project);\n\n    res.json({ projects });\n  });\n\n  /**\n   * Get current processing status\n   * GET /api/processing-status\n   */\n  private handleGetProcessingStatus = this.wrapHandler((req: Request, res: Response): void => {\n    const isProcessing = this.sessionManager.isAnySessionProcessing();\n    const queueDepth = this.sessionManager.getTotalActiveWork(); // Includes queued + actively processing\n    res.json({ isProcessing, queueDepth });\n  });\n\n  /**\n   * Set processing status (called by hooks)\n   * NOTE: This now broadcasts computed status based on active processing (ignores input)\n   */\n  private handleSetProcessing = this.wrapHandler((req: Request, res: Response): void => {\n    // Broadcast current computed status (ignores manual input)\n    this.workerService.broadcastProcessingStatus();\n\n    const isProcessing = this.sessionManager.isAnySessionProcessing();\n    const queueDepth = this.sessionManager.getTotalQueueDepth();\n    const activeSessions = this.sessionManager.getActiveSessionCount();\n\n    res.json({ status: 'ok', isProcessing, queueDepth, activeSessions });\n  });\n\n  /**\n   * Parse pagination parameters from request query\n   */\n  private parsePaginationParams(req: Request): { offset: number; limit: number; project?: string } {\n    const offset = parseInt(req.query.offset as string, 10) || 0;\n    const limit = Math.min(parseInt(req.query.limit as string, 10) || 20, 100); // Max 100\n    const project = req.query.project as string | undefined;\n\n    return { offset, limit, project };\n  }\n\n  /**\n   * Import memories from export file\n   * POST /api/import\n   * Body: { sessions: [], summaries: [], observations: [], prompts: [] }\n   */\n  private handleImport = this.wrapHandler((req: Request, res: Response): void => {\n    const { sessions, summaries, observations, prompts } = req.body;\n\n    const stats = {\n      sessionsImported: 0,\n      sessionsSkipped: 0,\n      summariesImported: 0,\n      summariesSkipped: 0,\n      observationsImported: 0,\n      observationsSkipped: 0,\n      promptsImported: 0,\n      promptsSkipped: 0\n    };\n\n    const store = this.dbManager.getSessionStore();\n\n    // Import sessions first (dependency for everything else)\n    if (Array.isArray(sessions)) {\n      for (const session of sessions) {\n        const result = store.importSdkSession(session);\n        if (result.imported) {\n          stats.sessionsImported++;\n        } else {\n          stats.sessionsSkipped++;\n        }\n      }\n    }\n\n    // Import summaries (depends on sessions)\n    if (Array.isArray(summaries)) {\n      for (const summary of summaries) {\n        const result = store.importSessionSummary(summary);\n        if (result.imported) {\n          stats.summariesImported++;\n        } else {\n          stats.summariesSkipped++;\n        }\n      }\n    }\n\n    // Import observations (depends on sessions)\n    if (Array.isArray(observations)) {\n      for (const obs of observations) {\n        const result = store.importObservation(obs);\n        if (result.imported) {\n          stats.observationsImported++;\n        } else {\n          stats.observationsSkipped++;\n        }\n      }\n    }\n\n    // Import prompts (depends on sessions)\n    if (Array.isArray(prompts)) {\n      for (const prompt of prompts) {\n        const result = store.importUserPrompt(prompt);\n        if (result.imported) {\n          stats.promptsImported++;\n        } else {\n          stats.promptsSkipped++;\n        }\n      }\n    }\n\n    res.json({\n      success: true,\n      stats\n    });\n  });\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_22": {
      "name": "constructor",
      "type": "method",
      "start_line": 22,
      "end_line": 31,
      "content_hash": "119a7a99a748e4349e6cab6bbabc39a5026a85c8",
      "content": "  constructor(\n    private paginationHelper: PaginationHelper,\n    private dbManager: DatabaseManager,\n    private sessionManager: SessionManager,\n    private sseBroadcaster: SSEBroadcaster,\n    private workerService: WorkerService,\n    private startTime: number\n  ) {\n    super();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupRoutes_33": {
      "name": "setupRoutes",
      "type": "method",
      "start_line": 33,
      "end_line": 56,
      "content_hash": "de3b1a9348f068b289c80052be5c9898964ac971",
      "content": "  setupRoutes(app: express.Application): void {\n    // Pagination endpoints\n    app.get('/api/observations', this.handleGetObservations.bind(this));\n    app.get('/api/summaries', this.handleGetSummaries.bind(this));\n    app.get('/api/prompts', this.handleGetPrompts.bind(this));\n\n    // Fetch by ID endpoints\n    app.get('/api/observation/:id', this.handleGetObservationById.bind(this));\n    app.post('/api/observations/batch', this.handleGetObservationsByIds.bind(this));\n    app.get('/api/session/:id', this.handleGetSessionById.bind(this));\n    app.post('/api/sdk-sessions/batch', this.handleGetSdkSessionsByIds.bind(this));\n    app.get('/api/prompt/:id', this.handleGetPromptById.bind(this));\n\n    // Metadata endpoints\n    app.get('/api/stats', this.handleGetStats.bind(this));\n    app.get('/api/projects', this.handleGetProjects.bind(this));\n\n    // Processing status endpoints\n    app.get('/api/processing-status', this.handleGetProcessingStatus.bind(this));\n    app.post('/api/processing', this.handleSetProcessing.bind(this));\n\n    // Import endpoint\n    app.post('/api/import', this.handleImport.bind(this));\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parsePaginationParams_285": {
      "name": "parsePaginationParams",
      "type": "method",
      "start_line": 285,
      "end_line": 291,
      "content_hash": "b3b59cf3315d19997f69121e02b304ddd08903ef",
      "content": "  private parsePaginationParams(req: Request): { offset: number; limit: number; project?: string } {\n    const offset = parseInt(req.query.offset as string, 10) || 0;\n    const limit = Math.min(parseInt(req.query.limit as string, 10) || 20, 100); // Max 100\n    const project = req.query.project as string | undefined;\n\n    return { offset, limit, project };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}