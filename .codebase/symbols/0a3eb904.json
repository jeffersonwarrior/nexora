{
  "file_path": "/work/.local/tools/modelscan/sdk/agent/agent_test.go",
  "file_hash": "c230817b4d807ae964e795d5ff4b953e5bbd6a92",
  "updated_at": "2025-12-26T17:34:22.096311",
  "symbols": {
    "struct_MockTool_13": {
      "name": "MockTool",
      "type": "struct",
      "start_line": 13,
      "end_line": 19,
      "content_hash": "b0b8f0f53fcc179bb7442278a1034dbb06188f67",
      "content": "type MockTool struct {\n\tname        string\n\tdescription string\n\texecutor    func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error)\n}\n\n// NewMockTool creates a new mock tool",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewMockTool_20": {
      "name": "NewMockTool",
      "type": "function",
      "start_line": 20,
      "end_line": 28,
      "content_hash": "7d9c6d51519b7d67f4d8f59fbbae2237ccbc9306",
      "content": "func NewMockTool(name, description string, executor func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error)) *MockTool {\n\treturn &MockTool{\n\t\tname:        name,\n\t\tdescription: description,\n\t\texecutor:    executor,\n\t}\n}\n\n// Name returns the tool name",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_29": {
      "name": "Name",
      "type": "method",
      "start_line": 29,
      "end_line": 33,
      "content_hash": "e78bbdefd20ec11033fb6fef149ab978890d6a39",
      "content": "func (m *MockTool) Name() string {\n\treturn m.name\n}\n\n// Description returns the tool description",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Description_34": {
      "name": "Description",
      "type": "method",
      "start_line": 34,
      "end_line": 38,
      "content_hash": "87963a23d8e788b5fb3e85dc482d926b31d3055e",
      "content": "func (m *MockTool) Description() string {\n\treturn m.description\n}\n\n// Execute executes the mock tool",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Execute_39": {
      "name": "Execute",
      "type": "method",
      "start_line": 39,
      "end_line": 45,
      "content_hash": "cc9795309f83a1ec28ea2a868021cb65e8462b33",
      "content": "func (m *MockTool) Execute(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\tif m.executor != nil {\n\t\treturn m.executor(ctx, input)\n\t}\n\treturn map[string]interface{}{\"result\": \"mock executed\"}, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_ExecutesTool_Successfully_46": {
      "name": "TestAgent_ExecutesTool_Successfully",
      "type": "function",
      "start_line": 46,
      "end_line": 64,
      "content_hash": "7b1b4670909c8c5716abc7da660ed4465596199d",
      "content": "func TestAgent_ExecutesTool_Successfully(t *testing.T) {\n\t// Setup a simple mock tool that returns a known response\n\ttool := NewMockTool(\"test_tool\", \"A test tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\"result\": \"success\"}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(5),\n\t\tWithTimeout(10*time.Second),\n\t)\n\n\tctx := context.Background()\n\tresult, err := agent.Execute(ctx, \"Use the test tool\")\n\n\trequire.NoError(t, err)\n\tassert.Contains(t, result, \"mock\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_Retries_OnToolError_65": {
      "name": "TestAgent_Retries_OnToolError",
      "type": "function",
      "start_line": 65,
      "end_line": 92,
      "content_hash": "77bbb48886b4b68c8a0511432d5a4ea2eaf07fc2",
      "content": "func TestAgent_Retries_OnToolError(t *testing.T) {\n\t// Tool that fails twice then succeeds\n\tcallCount := 0\n\ttool := NewMockTool(\"flaky_tool\", \"A flaky tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\tcallCount++\n\t\tif callCount <= 2 {\n\t\t\treturn nil, &ToolError{Message: \"temporary failure\"}\n\t\t}\n\t\treturn map[string]interface{}{\"result\": \"success_after_retry\"}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(5),\n\t\tWithRetryOptions(RetryOptions{\n\t\t\tMaxRetries: 3,\n\t\t\tBackoff:    100 * time.Millisecond,\n\t\t}),\n\t)\n\n\tctx := context.Background()\n\tresult, err := agent.Execute(ctx, \"Use the flaky tool\")\n\n\trequire.NoError(t, err)\n\tassert.Contains(t, result, \"mock\")\n\tassert.Equal(t, 3, callCount) // Called twice for failures + once for success\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_Stops_OnBudgetExceeded_93": {
      "name": "TestAgent_Stops_OnBudgetExceeded",
      "type": "function",
      "start_line": 93,
      "end_line": 113,
      "content_hash": "d57830d2bcd1b5267b787dcc597ba72a11fadbc0",
      "content": "func TestAgent_Stops_OnBudgetExceeded(t *testing.T) {\n\ttool := NewMockTool(\"expensive_tool\", \"An expensive tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\"result\": \"expensive_result\"}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithBudget(0.01), // Very low budget\n\t\tWithMaxIterations(5),\n\t\tWithCostEstimator(func(prompt string) float64 {\n\t\t\treturn 1.0 // $1 per request - will exceed budget\n\t\t}),\n\t)\n\n\tctx := context.Background()\n\t_, err := agent.Execute(ctx, \"Use the expensive tool\")\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"budget exceeded\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_Stops_OnMaxIterations_114": {
      "name": "TestAgent_Stops_OnMaxIterations",
      "type": "function",
      "start_line": 114,
      "end_line": 132,
      "content_hash": "807f25cdd04590c33cd56f325bdebd00c0ddba7e",
      "content": "func TestAgent_Stops_OnMaxIterations(t *testing.T) {\n\t// Tool that always requires more iterations\n\ttool := NewMockTool(\"endless_tool\", \"An endless tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\"needs_more\": true}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(3),           // Low limit\n\t\tWithPlanner(NewReActPlanner()), // ReAct will keep trying\n\t)\n\n\tctx := context.Background()\n\t_, err := agent.Execute(ctx, \"Use the endless tool\")\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"max iterations exceeded\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_HandlesToolTimeout_133": {
      "name": "TestAgent_HandlesToolTimeout",
      "type": "function",
      "start_line": 133,
      "end_line": 160,
      "content_hash": "f8b155be28dbe30406637c92925413512f997450",
      "content": "func TestAgent_HandlesToolTimeout(t *testing.T) {\n\t// Tool that takes too long\n\ttool := NewMockTool(\"slow_tool\", \"A slow tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\t// Simulate slow operation\n\t\tselect {\n\t\tcase <-time.After(5 * time.Second):\n\t\t\treturn map[string]interface{}{\"result\": \"too_late\"}, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(1),\n\t\tWithTimeout(1*time.Second), // Short timeout\n\t)\n\n\tctx := context.Background()\n\tstart := time.Now()\n\t_, err := agent.Execute(ctx, \"Use the slow tool\")\n\telapsed := time.Since(start)\n\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"timeout\")\n\tassert.Less(t, elapsed, 2*time.Second) // Should timeout quickly\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_TracksTokenUsage_161": {
      "name": "TestAgent_TracksTokenUsage",
      "type": "function",
      "start_line": 161,
      "end_line": 184,
      "content_hash": "8af79eeb9ac5a14513bcb80be0fb5a143c300233",
      "content": "func TestAgent_TracksTokenUsage(t *testing.T) {\n\ttool := NewMockTool(\"token_tool\", \"A token tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\"result\": \"token_result\"}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(2),\n\t\tWithTokenCounter(func(prompt string) int {\n\t\t\t// Simple estimation: 1 token per 4 characters\n\t\t\treturn len(prompt) / 4\n\t\t}),\n\t)\n\n\tctx := context.Background()\n\t_, err := agent.Execute(ctx, \"Use the token tool\")\n\n\trequire.NoError(t, err)\n\tusage := agent.TokenUsage()\n\tassert.Greater(t, usage.TotalTokens, 0)\n\tassert.Greater(t, usage.InputTokens, 0)\n\tassert.Greater(t, usage.OutputTokens, 0)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestAgent_UseReActPlanner_185": {
      "name": "TestAgent_UseReActPlanner",
      "type": "function",
      "start_line": 185,
      "end_line": 235,
      "content_hash": "ef93bba3dd1d2b9c2c6efb76599ec6776cfd8d23",
      "content": "func TestAgent_UseReActPlanner(t *testing.T) {\n\ttool := NewMockTool(\"calculator\", \"A calculator tool\", func(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {\n\t\t// Handle missing parameters gracefully\n\t\tvar a, b float64\n\t\tvar op string\n\n\t\tif val, ok := input[\"a\"].(float64); ok {\n\t\t\ta = val\n\t\t} else {\n\t\t\ta = 5 // default value\n\t\t}\n\n\t\tif val, ok := input[\"b\"].(float64); ok {\n\t\t\tb = val\n\t\t} else {\n\t\t\tb = 7 // default value\n\t\t}\n\n\t\tif val, ok := input[\"op\"].(string); ok {\n\t\t\top = val\n\t\t} else {\n\t\t\top = \"*\" // default operation\n\t\t}\n\n\t\tvar result float64\n\t\tswitch op {\n\t\tcase \"+\":\n\t\t\tresult = a + b\n\t\tcase \"*\":\n\t\t\tresult = a * b\n\t\tdefault:\n\t\t\treturn nil, &ToolError{Message: \"unknown operation\"}\n\t\t}\n\n\t\treturn map[string]interface{}{\"result\": result}, nil\n\t})\n\n\tagent := NewAgent(\n\t\tWithTools(tool),\n\t\tWithMaxIterations(5),\n\t\tWithPlanner(NewReActPlanner()),\n\t)\n\n\tctx := context.Background()\n\tresult, err := agent.Execute(ctx, \"calculate 5 * 7\")\n\n\trequire.NoError(t, err)\n\tassert.Contains(t, result, \"mock\")\n}\n\n// Mock ReAct planner removed - using real implementation from react_planner.go",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}