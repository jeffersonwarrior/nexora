{
  "file_path": "/work/external-deps/claude-mem/src/services/sync/ChromaSync.ts",
  "file_hash": "62400a82b05f01b2ecc38c90eac918d9086ef517",
  "updated_at": "2025-12-26T17:34:20.152649",
  "symbols": {
    "class_ChromaSync_73": {
      "name": "ChromaSync",
      "type": "class",
      "start_line": 73,
      "end_line": 867,
      "content_hash": "1196c9f101e7723edb0f45e9695dfb8b79d95230",
      "content": "export class ChromaSync {\n  private client: Client | null = null;\n  private transport: StdioClientTransport | null = null;\n  private connected: boolean = false;\n  private project: string;\n  private collectionName: string;\n  private readonly VECTOR_DB_DIR: string;\n  private readonly BATCH_SIZE = 100;\n\n  constructor(project: string) {\n    this.project = project;\n    this.collectionName = `cm__${project}`;\n    this.VECTOR_DB_DIR = path.join(os.homedir(), '.claude-mem', 'vector-db');\n  }\n\n  /**\n   * Ensure MCP client is connected to Chroma server\n   * Throws error if connection fails\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.connected && this.client) {\n      return;\n    }\n\n    logger.info('CHROMA_SYNC', 'Connecting to Chroma MCP server...', { project: this.project });\n\n    try {\n      // Use Python 3.13 by default to avoid onnxruntime compatibility issues with Python 3.14+\n      // See: https://github.com/thedotmack/claude-mem/issues/170 (Python 3.14 incompatibility)\n      const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n      const pythonVersion = settings.CLAUDE_MEM_PYTHON_VERSION;\n      const isWindows = process.platform === 'win32';\n\n      const transportOptions: any = {\n        command: 'uvx',\n        args: [\n          '--python', pythonVersion,\n          'chroma-mcp',\n          '--client-type', 'persistent',\n          '--data-dir', this.VECTOR_DB_DIR\n        ],\n        stderr: 'ignore'\n      };\n\n      // CRITICAL: On Windows, try to hide console window to prevent PowerShell popups\n      // Note: windowsHide may not be supported by MCP SDK's StdioClientTransport\n      if (isWindows) {\n        transportOptions.windowsHide = true;\n        logger.debug('CHROMA_SYNC', 'Windows detected, attempting to hide console window', { project: this.project });\n      }\n\n      this.transport = new StdioClientTransport(transportOptions);\n\n      this.client = new Client({\n        name: 'claude-mem-chroma-sync',\n        version: '1.0.0'\n      }, {\n        capabilities: {}\n      });\n\n      await this.client.connect(this.transport);\n      this.connected = true;\n\n      logger.info('CHROMA_SYNC', 'Connected to Chroma MCP server', { project: this.project });\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to connect to Chroma MCP server', { project: this.project }, error as Error);\n      throw new Error(`Chroma connection failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Ensure collection exists, create if needed\n   * Throws error if collection creation fails\n   */\n  private async ensureCollection(): Promise<void> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    try {\n      // Try to get collection info (will fail if doesn't exist)\n      await this.client.callTool({\n        name: 'chroma_get_collection_info',\n        arguments: {\n          collection_name: this.collectionName\n        }\n      });\n\n      logger.debug('CHROMA_SYNC', 'Collection exists', { collection: this.collectionName });\n    } catch (error) {\n      // Collection doesn't exist, create it\n      logger.info('CHROMA_SYNC', 'Creating collection', { collection: this.collectionName });\n\n      try {\n        await this.client.callTool({\n          name: 'chroma_create_collection',\n          arguments: {\n            collection_name: this.collectionName,\n            embedding_function_name: 'default'\n          }\n        });\n\n        logger.info('CHROMA_SYNC', 'Collection created', { collection: this.collectionName });\n      } catch (createError) {\n        logger.error('CHROMA_SYNC', 'Failed to create collection', { collection: this.collectionName }, createError as Error);\n        throw new Error(`Collection creation failed: ${createError instanceof Error ? createError.message : String(createError)}`);\n      }\n    }\n  }\n\n  /**\n   * Format observation into Chroma documents (granular approach)\n   * Each semantic field becomes a separate vector document\n   */\n  private formatObservationDocs(obs: StoredObservation): ChromaDocument[] {\n    const documents: ChromaDocument[] = [];\n\n    // Parse JSON fields\n    const facts = obs.facts ? JSON.parse(obs.facts) : [];\n    const concepts = obs.concepts ? JSON.parse(obs.concepts) : [];\n    const files_read = obs.files_read ? JSON.parse(obs.files_read) : [];\n    const files_modified = obs.files_modified ? JSON.parse(obs.files_modified) : [];\n\n    const baseMetadata: Record<string, string | number> = {\n      sqlite_id: obs.id,\n      doc_type: 'observation',\n      sdk_session_id: obs.sdk_session_id,\n      project: obs.project,\n      created_at_epoch: obs.created_at_epoch,\n      type: obs.type || 'discovery',\n      title: obs.title || 'Untitled'\n    };\n\n    // Add optional metadata fields\n    if (obs.subtitle) {\n      baseMetadata.subtitle = obs.subtitle;\n    }\n    if (concepts.length > 0) {\n      baseMetadata.concepts = concepts.join(',');\n    }\n    if (files_read.length > 0) {\n      baseMetadata.files_read = files_read.join(',');\n    }\n    if (files_modified.length > 0) {\n      baseMetadata.files_modified = files_modified.join(',');\n    }\n\n    // Narrative as separate document\n    if (obs.narrative) {\n      documents.push({\n        id: `obs_${obs.id}_narrative`,\n        document: obs.narrative,\n        metadata: { ...baseMetadata, field_type: 'narrative' }\n      });\n    }\n\n    // Text as separate document (legacy field)\n    if (obs.text) {\n      documents.push({\n        id: `obs_${obs.id}_text`,\n        document: obs.text,\n        metadata: { ...baseMetadata, field_type: 'text' }\n      });\n    }\n\n    // Each fact as separate document\n    facts.forEach((fact: string, index: number) => {\n      documents.push({\n        id: `obs_${obs.id}_fact_${index}`,\n        document: fact,\n        metadata: { ...baseMetadata, field_type: 'fact', fact_index: index }\n      });\n    });\n\n    return documents;\n  }\n\n  /**\n   * Format summary into Chroma documents (granular approach)\n   * Each summary field becomes a separate vector document\n   */\n  private formatSummaryDocs(summary: StoredSummary): ChromaDocument[] {\n    const documents: ChromaDocument[] = [];\n\n    const baseMetadata: Record<string, string | number> = {\n      sqlite_id: summary.id,\n      doc_type: 'session_summary',\n      sdk_session_id: summary.sdk_session_id,\n      project: summary.project,\n      created_at_epoch: summary.created_at_epoch,\n      prompt_number: summary.prompt_number || 0\n    };\n\n    // Each field becomes a separate document\n    if (summary.request) {\n      documents.push({\n        id: `summary_${summary.id}_request`,\n        document: summary.request,\n        metadata: { ...baseMetadata, field_type: 'request' }\n      });\n    }\n\n    if (summary.investigated) {\n      documents.push({\n        id: `summary_${summary.id}_investigated`,\n        document: summary.investigated,\n        metadata: { ...baseMetadata, field_type: 'investigated' }\n      });\n    }\n\n    if (summary.learned) {\n      documents.push({\n        id: `summary_${summary.id}_learned`,\n        document: summary.learned,\n        metadata: { ...baseMetadata, field_type: 'learned' }\n      });\n    }\n\n    if (summary.completed) {\n      documents.push({\n        id: `summary_${summary.id}_completed`,\n        document: summary.completed,\n        metadata: { ...baseMetadata, field_type: 'completed' }\n      });\n    }\n\n    if (summary.next_steps) {\n      documents.push({\n        id: `summary_${summary.id}_next_steps`,\n        document: summary.next_steps,\n        metadata: { ...baseMetadata, field_type: 'next_steps' }\n      });\n    }\n\n    if (summary.notes) {\n      documents.push({\n        id: `summary_${summary.id}_notes`,\n        document: summary.notes,\n        metadata: { ...baseMetadata, field_type: 'notes' }\n      });\n    }\n\n    return documents;\n  }\n\n  /**\n   * Add documents to Chroma in batch\n   * Throws error if batch add fails\n   */\n  private async addDocuments(documents: ChromaDocument[]): Promise<void> {\n    if (documents.length === 0) {\n      return;\n    }\n\n    await this.ensureCollection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    try {\n      await this.client.callTool({\n        name: 'chroma_add_documents',\n        arguments: {\n          collection_name: this.collectionName,\n          documents: documents.map(d => d.document),\n          ids: documents.map(d => d.id),\n          metadatas: documents.map(d => d.metadata)\n        }\n      });\n\n      logger.debug('CHROMA_SYNC', 'Documents added', {\n        collection: this.collectionName,\n        count: documents.length\n      });\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to add documents', {\n        collection: this.collectionName,\n        count: documents.length\n      }, error as Error);\n      throw new Error(`Document add failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Sync a single observation to Chroma\n   * Blocks until sync completes, throws on error\n   */\n  async syncObservation(\n    observationId: number,\n    sdkSessionId: string,\n    project: string,\n    obs: ParsedObservation,\n    promptNumber: number,\n    createdAtEpoch: number,\n    discoveryTokens: number = 0\n  ): Promise<void> {\n    // Convert ParsedObservation to StoredObservation format\n    const stored: StoredObservation = {\n      id: observationId,\n      sdk_session_id: sdkSessionId,\n      project: project,\n      text: null, // Legacy field, not used\n      type: obs.type,\n      title: obs.title,\n      subtitle: obs.subtitle,\n      facts: JSON.stringify(obs.facts),\n      narrative: obs.narrative,\n      concepts: JSON.stringify(obs.concepts),\n      files_read: JSON.stringify(obs.files_read),\n      files_modified: JSON.stringify(obs.files_modified),\n      prompt_number: promptNumber,\n      discovery_tokens: discoveryTokens,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch\n    };\n\n    const documents = this.formatObservationDocs(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing observation', {\n      observationId,\n      documentCount: documents.length,\n      project\n    });\n\n    await this.addDocuments(documents);\n  }\n\n  /**\n   * Sync a single summary to Chroma\n   * Blocks until sync completes, throws on error\n   */\n  async syncSummary(\n    summaryId: number,\n    sdkSessionId: string,\n    project: string,\n    summary: ParsedSummary,\n    promptNumber: number,\n    createdAtEpoch: number,\n    discoveryTokens: number = 0\n  ): Promise<void> {\n    // Convert ParsedSummary to StoredSummary format\n    const stored: StoredSummary = {\n      id: summaryId,\n      sdk_session_id: sdkSessionId,\n      project: project,\n      request: summary.request,\n      investigated: summary.investigated,\n      learned: summary.learned,\n      completed: summary.completed,\n      next_steps: summary.next_steps,\n      notes: summary.notes,\n      prompt_number: promptNumber,\n      discovery_tokens: discoveryTokens,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch\n    };\n\n    const documents = this.formatSummaryDocs(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing summary', {\n      summaryId,\n      documentCount: documents.length,\n      project\n    });\n\n    await this.addDocuments(documents);\n  }\n\n  /**\n   * Format user prompt into Chroma document\n   * Each prompt becomes a single document (unlike observations/summaries which split by field)\n   */\n  private formatUserPromptDoc(prompt: StoredUserPrompt): ChromaDocument {\n    return {\n      id: `prompt_${prompt.id}`,\n      document: prompt.prompt_text,\n      metadata: {\n        sqlite_id: prompt.id,\n        doc_type: 'user_prompt',\n        sdk_session_id: prompt.sdk_session_id,\n        project: prompt.project,\n        created_at_epoch: prompt.created_at_epoch,\n        prompt_number: prompt.prompt_number\n      }\n    };\n  }\n\n  /**\n   * Sync a single user prompt to Chroma\n   * Blocks until sync completes, throws on error\n   */\n  async syncUserPrompt(\n    promptId: number,\n    sdkSessionId: string,\n    project: string,\n    promptText: string,\n    promptNumber: number,\n    createdAtEpoch: number\n  ): Promise<void> {\n    // Create StoredUserPrompt format\n    const stored: StoredUserPrompt = {\n      id: promptId,\n      claude_session_id: '', // Not needed for Chroma sync\n      prompt_number: promptNumber,\n      prompt_text: promptText,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch,\n      sdk_session_id: sdkSessionId,\n      project: project\n    };\n\n    const document = this.formatUserPromptDoc(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing user prompt', {\n      promptId,\n      project\n    });\n\n    await this.addDocuments([document]);\n  }\n\n  /**\n   * Fetch all existing document IDs from Chroma collection\n   * Returns Sets of SQLite IDs for observations, summaries, and prompts\n   */\n  private async getExistingChromaIds(): Promise<{\n    observations: Set<number>;\n    summaries: Set<number>;\n    prompts: Set<number>;\n  }> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    const observationIds = new Set<number>();\n    const summaryIds = new Set<number>();\n    const promptIds = new Set<number>();\n\n    let offset = 0;\n    const limit = 1000; // Large batches, metadata only = fast\n\n    logger.info('CHROMA_SYNC', 'Fetching existing Chroma document IDs...', { project: this.project });\n\n    while (true) {\n      try {\n        const result = await this.client.callTool({\n          name: 'chroma_get_documents',\n          arguments: {\n            collection_name: this.collectionName,\n            limit,\n            offset,\n            where: { project: this.project }, // Filter by project\n            include: ['metadatas']\n          }\n        });\n\n        const data = result.content[0];\n        if (data.type !== 'text') {\n          throw new Error('Unexpected response type from chroma_get_documents');\n        }\n\n        const parsed = JSON.parse(data.text);\n        const metadatas = parsed.metadatas || [];\n\n        if (metadatas.length === 0) {\n          break; // No more documents\n        }\n\n        // Extract SQLite IDs from metadata\n        for (const meta of metadatas) {\n          if (meta.sqlite_id) {\n            if (meta.doc_type === 'observation') {\n              observationIds.add(meta.sqlite_id);\n            } else if (meta.doc_type === 'session_summary') {\n              summaryIds.add(meta.sqlite_id);\n            } else if (meta.doc_type === 'user_prompt') {\n              promptIds.add(meta.sqlite_id);\n            }\n          }\n        }\n\n        offset += limit;\n\n        logger.debug('CHROMA_SYNC', 'Fetched batch of existing IDs', {\n          project: this.project,\n          offset,\n          batchSize: metadatas.length\n        });\n      } catch (error) {\n        logger.error('CHROMA_SYNC', 'Failed to fetch existing IDs', { project: this.project }, error as Error);\n        throw error;\n      }\n    }\n\n    logger.info('CHROMA_SYNC', 'Existing IDs fetched', {\n      project: this.project,\n      observations: observationIds.size,\n      summaries: summaryIds.size,\n      prompts: promptIds.size\n    });\n\n    return { observations: observationIds, summaries: summaryIds, prompts: promptIds };\n  }\n\n  /**\n   * Backfill: Sync all observations missing from Chroma\n   * Reads from SQLite and syncs in batches\n   * Throws error if backfill fails\n   */\n  async ensureBackfilled(): Promise<void> {\n    logger.info('CHROMA_SYNC', 'Starting smart backfill', { project: this.project });\n\n    await this.ensureCollection();\n\n    // Fetch existing IDs from Chroma (fast, metadata only)\n    const existing = await this.getExistingChromaIds();\n\n    const db = new SessionStore();\n\n    try {\n      // Build exclusion list for observations\n      const existingObsIds = Array.from(existing.observations);\n      const obsExclusionClause = existingObsIds.length > 0\n        ? `AND id NOT IN (${existingObsIds.join(',')})`\n        : '';\n\n      // Get only observations missing from Chroma\n      const observations = db.db.prepare(`\n        SELECT * FROM observations\n        WHERE project = ? ${obsExclusionClause}\n        ORDER BY id ASC\n      `).all(this.project) as StoredObservation[];\n\n      const totalObsCount = db.db.prepare(`\n        SELECT COUNT(*) as count FROM observations WHERE project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling observations', {\n        project: this.project,\n        missing: observations.length,\n        existing: existing.observations.size,\n        total: totalObsCount.count\n      });\n\n      // Format all observation documents\n      const allDocs: ChromaDocument[] = [];\n      for (const obs of observations) {\n        allDocs.push(...this.formatObservationDocs(obs));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < allDocs.length; i += this.BATCH_SIZE) {\n        const batch = allDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, allDocs.length)}/${allDocs.length}`\n        });\n      }\n\n      // Build exclusion list for summaries\n      const existingSummaryIds = Array.from(existing.summaries);\n      const summaryExclusionClause = existingSummaryIds.length > 0\n        ? `AND id NOT IN (${existingSummaryIds.join(',')})`\n        : '';\n\n      // Get only summaries missing from Chroma\n      const summaries = db.db.prepare(`\n        SELECT * FROM session_summaries\n        WHERE project = ? ${summaryExclusionClause}\n        ORDER BY id ASC\n      `).all(this.project) as StoredSummary[];\n\n      const totalSummaryCount = db.db.prepare(`\n        SELECT COUNT(*) as count FROM session_summaries WHERE project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling summaries', {\n        project: this.project,\n        missing: summaries.length,\n        existing: existing.summaries.size,\n        total: totalSummaryCount.count\n      });\n\n      // Format all summary documents\n      const summaryDocs: ChromaDocument[] = [];\n      for (const summary of summaries) {\n        summaryDocs.push(...this.formatSummaryDocs(summary));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < summaryDocs.length; i += this.BATCH_SIZE) {\n        const batch = summaryDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, summaryDocs.length)}/${summaryDocs.length}`\n        });\n      }\n\n      // Build exclusion list for prompts\n      const existingPromptIds = Array.from(existing.prompts);\n      const promptExclusionClause = existingPromptIds.length > 0\n        ? `AND up.id NOT IN (${existingPromptIds.join(',')})`\n        : '';\n\n      // Get only user prompts missing from Chroma\n      const prompts = db.db.prepare(`\n        SELECT\n          up.*,\n          s.project,\n          s.sdk_session_id\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        WHERE s.project = ? ${promptExclusionClause}\n        ORDER BY up.id ASC\n      `).all(this.project) as StoredUserPrompt[];\n\n      const totalPromptCount = db.db.prepare(`\n        SELECT COUNT(*) as count\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        WHERE s.project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling user prompts', {\n        project: this.project,\n        missing: prompts.length,\n        existing: existing.prompts.size,\n        total: totalPromptCount.count\n      });\n\n      // Format all prompt documents\n      const promptDocs: ChromaDocument[] = [];\n      for (const prompt of prompts) {\n        promptDocs.push(this.formatUserPromptDoc(prompt));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < promptDocs.length; i += this.BATCH_SIZE) {\n        const batch = promptDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, promptDocs.length)}/${promptDocs.length}`\n        });\n      }\n\n      logger.info('CHROMA_SYNC', 'Smart backfill complete', {\n        project: this.project,\n        synced: {\n          observationDocs: allDocs.length,\n          summaryDocs: summaryDocs.length,\n          promptDocs: promptDocs.length\n        },\n        skipped: {\n          observations: existing.observations.size,\n          summaries: existing.summaries.size,\n          prompts: existing.prompts.size\n        }\n      });\n\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Backfill failed', { project: this.project }, error as Error);\n      throw new Error(`Backfill failed: ${error instanceof Error ? error.message : String(error)}`);\n    } finally {\n      db.close();\n    }\n  }\n\n  /**\n   * Query Chroma collection for semantic search\n   * Used by SearchManager for vector-based search\n   */\n  async queryChroma(\n    query: string,\n    limit: number,\n    whereFilter?: Record<string, any>\n  ): Promise<{ ids: number[]; distances: number[]; metadatas: any[] }> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    const whereStringified = whereFilter ? JSON.stringify(whereFilter) : undefined;\n\n    const arguments_obj = {\n      collection_name: this.collectionName,\n      query_texts: [query],\n      n_results: limit,\n      include: ['documents', 'metadatas', 'distances'],\n      where: whereStringified\n    };\n\n    const result = await this.client.callTool({\n      name: 'chroma_query_documents',\n      arguments: arguments_obj\n    });\n\n    const resultText = logger.happyPathError(\n      'CHROMA',\n      'Missing text in MCP chroma_query_documents result',\n      { project: this.project },\n      { query_text: query },\n      result.content[0]?.text || ''\n    );\n\n    // Parse JSON response\n    let parsed: any;\n    try {\n      parsed = JSON.parse(resultText);\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to parse Chroma response', { project: this.project }, error as Error);\n      return { ids: [], distances: [], metadatas: [] };\n    }\n\n    // Extract unique IDs from document IDs\n    const ids: number[] = [];\n    const docIds = parsed.ids?.[0] || [];\n    for (const docId of docIds) {\n      // Extract sqlite_id from document ID (supports three formats):\n      // - obs_{id}_narrative, obs_{id}_fact_0, etc (observations)\n      // - summary_{id}_request, summary_{id}_learned, etc (session summaries)\n      // - prompt_{id} (user prompts)\n      const obsMatch = docId.match(/obs_(\\d+)_/);\n      const summaryMatch = docId.match(/summary_(\\d+)_/);\n      const promptMatch = docId.match(/prompt_(\\d+)/);\n\n      let sqliteId: number | null = null;\n      if (obsMatch) {\n        sqliteId = parseInt(obsMatch[1], 10);\n      } else if (summaryMatch) {\n        sqliteId = parseInt(summaryMatch[1], 10);\n      } else if (promptMatch) {\n        sqliteId = parseInt(promptMatch[1], 10);\n      }\n\n      if (sqliteId !== null && !ids.includes(sqliteId)) {\n        ids.push(sqliteId);\n      }\n    }\n\n    const distances = parsed.distances?.[0] || [];\n    const metadatas = parsed.metadatas?.[0] || [];\n\n    return { ids, distances, metadatas };\n  }\n\n  /**\n   * Close the Chroma client connection and cleanup subprocess\n   */\n  async close(): Promise<void> {\n    if (!this.connected && !this.client && !this.transport) {\n      return;\n    }\n\n    // Close client first\n    if (this.client) {\n      await this.client.close();\n    }\n\n    // Explicitly close transport to kill subprocess\n    if (this.transport) {\n      await this.transport.close();\n    }\n\n    logger.info('CHROMA_SYNC', 'Chroma client and subprocess closed', { project: this.project });\n\n    // Always reset state\n    this.connected = false;\n    this.client = null;\n    this.transport = null;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_82": {
      "name": "constructor",
      "type": "method",
      "start_line": 82,
      "end_line": 86,
      "content_hash": "5a98099f8355dbe49a8a7e42ba5c7a7aece65644",
      "content": "  constructor(project: string) {\n    this.project = project;\n    this.collectionName = `cm__${project}`;\n    this.VECTOR_DB_DIR = path.join(os.homedir(), '.claude-mem', 'vector-db');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureConnection_92": {
      "name": "ensureConnection",
      "type": "method",
      "start_line": 92,
      "end_line": 141,
      "content_hash": "94d706b965ec64445b68e5a27e2f6dd2be1c02e4",
      "content": "  private async ensureConnection(): Promise<void> {\n    if (this.connected && this.client) {\n      return;\n    }\n\n    logger.info('CHROMA_SYNC', 'Connecting to Chroma MCP server...', { project: this.project });\n\n    try {\n      // Use Python 3.13 by default to avoid onnxruntime compatibility issues with Python 3.14+\n      // See: https://github.com/thedotmack/claude-mem/issues/170 (Python 3.14 incompatibility)\n      const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n      const pythonVersion = settings.CLAUDE_MEM_PYTHON_VERSION;\n      const isWindows = process.platform === 'win32';\n\n      const transportOptions: any = {\n        command: 'uvx',\n        args: [\n          '--python', pythonVersion,\n          'chroma-mcp',\n          '--client-type', 'persistent',\n          '--data-dir', this.VECTOR_DB_DIR\n        ],\n        stderr: 'ignore'\n      };\n\n      // CRITICAL: On Windows, try to hide console window to prevent PowerShell popups\n      // Note: windowsHide may not be supported by MCP SDK's StdioClientTransport\n      if (isWindows) {\n        transportOptions.windowsHide = true;\n        logger.debug('CHROMA_SYNC', 'Windows detected, attempting to hide console window', { project: this.project });\n      }\n\n      this.transport = new StdioClientTransport(transportOptions);\n\n      this.client = new Client({\n        name: 'claude-mem-chroma-sync',\n        version: '1.0.0'\n      }, {\n        capabilities: {}\n      });\n\n      await this.client.connect(this.transport);\n      this.connected = true;\n\n      logger.info('CHROMA_SYNC', 'Connected to Chroma MCP server', { project: this.project });\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to connect to Chroma MCP server', { project: this.project }, error as Error);\n      throw new Error(`Chroma connection failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureCollection_147": {
      "name": "ensureCollection",
      "type": "method",
      "start_line": 147,
      "end_line": 186,
      "content_hash": "cdaefe9492e3d8f03b779c83b89113c6ef3477e7",
      "content": "  private async ensureCollection(): Promise<void> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    try {\n      // Try to get collection info (will fail if doesn't exist)\n      await this.client.callTool({\n        name: 'chroma_get_collection_info',\n        arguments: {\n          collection_name: this.collectionName\n        }\n      });\n\n      logger.debug('CHROMA_SYNC', 'Collection exists', { collection: this.collectionName });\n    } catch (error) {\n      // Collection doesn't exist, create it\n      logger.info('CHROMA_SYNC', 'Creating collection', { collection: this.collectionName });\n\n      try {\n        await this.client.callTool({\n          name: 'chroma_create_collection',\n          arguments: {\n            collection_name: this.collectionName,\n            embedding_function_name: 'default'\n          }\n        });\n\n        logger.info('CHROMA_SYNC', 'Collection created', { collection: this.collectionName });\n      } catch (createError) {\n        logger.error('CHROMA_SYNC', 'Failed to create collection', { collection: this.collectionName }, createError as Error);\n        throw new Error(`Collection creation failed: ${createError instanceof Error ? createError.message : String(createError)}`);\n      }\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatObservationDocs_192": {
      "name": "formatObservationDocs",
      "type": "method",
      "start_line": 192,
      "end_line": 253,
      "content_hash": "fdc6b529604dd305edb06ada02e5bbd4ac839ef7",
      "content": "  private formatObservationDocs(obs: StoredObservation): ChromaDocument[] {\n    const documents: ChromaDocument[] = [];\n\n    // Parse JSON fields\n    const facts = obs.facts ? JSON.parse(obs.facts) : [];\n    const concepts = obs.concepts ? JSON.parse(obs.concepts) : [];\n    const files_read = obs.files_read ? JSON.parse(obs.files_read) : [];\n    const files_modified = obs.files_modified ? JSON.parse(obs.files_modified) : [];\n\n    const baseMetadata: Record<string, string | number> = {\n      sqlite_id: obs.id,\n      doc_type: 'observation',\n      sdk_session_id: obs.sdk_session_id,\n      project: obs.project,\n      created_at_epoch: obs.created_at_epoch,\n      type: obs.type || 'discovery',\n      title: obs.title || 'Untitled'\n    };\n\n    // Add optional metadata fields\n    if (obs.subtitle) {\n      baseMetadata.subtitle = obs.subtitle;\n    }\n    if (concepts.length > 0) {\n      baseMetadata.concepts = concepts.join(',');\n    }\n    if (files_read.length > 0) {\n      baseMetadata.files_read = files_read.join(',');\n    }\n    if (files_modified.length > 0) {\n      baseMetadata.files_modified = files_modified.join(',');\n    }\n\n    // Narrative as separate document\n    if (obs.narrative) {\n      documents.push({\n        id: `obs_${obs.id}_narrative`,\n        document: obs.narrative,\n        metadata: { ...baseMetadata, field_type: 'narrative' }\n      });\n    }\n\n    // Text as separate document (legacy field)\n    if (obs.text) {\n      documents.push({\n        id: `obs_${obs.id}_text`,\n        document: obs.text,\n        metadata: { ...baseMetadata, field_type: 'text' }\n      });\n    }\n\n    // Each fact as separate document\n    facts.forEach((fact: string, index: number) => {\n      documents.push({\n        id: `obs_${obs.id}_fact_${index}`,\n        document: fact,\n        metadata: { ...baseMetadata, field_type: 'fact', fact_index: index }\n      });\n    });\n\n    return documents;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatSummaryDocs_259": {
      "name": "formatSummaryDocs",
      "type": "method",
      "start_line": 259,
      "end_line": 321,
      "content_hash": "7edd5c02b225e96071e8e66e3f23079bb33b09de",
      "content": "  private formatSummaryDocs(summary: StoredSummary): ChromaDocument[] {\n    const documents: ChromaDocument[] = [];\n\n    const baseMetadata: Record<string, string | number> = {\n      sqlite_id: summary.id,\n      doc_type: 'session_summary',\n      sdk_session_id: summary.sdk_session_id,\n      project: summary.project,\n      created_at_epoch: summary.created_at_epoch,\n      prompt_number: summary.prompt_number || 0\n    };\n\n    // Each field becomes a separate document\n    if (summary.request) {\n      documents.push({\n        id: `summary_${summary.id}_request`,\n        document: summary.request,\n        metadata: { ...baseMetadata, field_type: 'request' }\n      });\n    }\n\n    if (summary.investigated) {\n      documents.push({\n        id: `summary_${summary.id}_investigated`,\n        document: summary.investigated,\n        metadata: { ...baseMetadata, field_type: 'investigated' }\n      });\n    }\n\n    if (summary.learned) {\n      documents.push({\n        id: `summary_${summary.id}_learned`,\n        document: summary.learned,\n        metadata: { ...baseMetadata, field_type: 'learned' }\n      });\n    }\n\n    if (summary.completed) {\n      documents.push({\n        id: `summary_${summary.id}_completed`,\n        document: summary.completed,\n        metadata: { ...baseMetadata, field_type: 'completed' }\n      });\n    }\n\n    if (summary.next_steps) {\n      documents.push({\n        id: `summary_${summary.id}_next_steps`,\n        document: summary.next_steps,\n        metadata: { ...baseMetadata, field_type: 'next_steps' }\n      });\n    }\n\n    if (summary.notes) {\n      documents.push({\n        id: `summary_${summary.id}_notes`,\n        document: summary.notes,\n        metadata: { ...baseMetadata, field_type: 'notes' }\n      });\n    }\n\n    return documents;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_addDocuments_327": {
      "name": "addDocuments",
      "type": "method",
      "start_line": 327,
      "end_line": 363,
      "content_hash": "4222aacdd4411f53c9dec8957e429fb5c3328ebf",
      "content": "  private async addDocuments(documents: ChromaDocument[]): Promise<void> {\n    if (documents.length === 0) {\n      return;\n    }\n\n    await this.ensureCollection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    try {\n      await this.client.callTool({\n        name: 'chroma_add_documents',\n        arguments: {\n          collection_name: this.collectionName,\n          documents: documents.map(d => d.document),\n          ids: documents.map(d => d.id),\n          metadatas: documents.map(d => d.metadata)\n        }\n      });\n\n      logger.debug('CHROMA_SYNC', 'Documents added', {\n        collection: this.collectionName,\n        count: documents.length\n      });\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to add documents', {\n        collection: this.collectionName,\n        count: documents.length\n      }, error as Error);\n      throw new Error(`Document add failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_syncObservation_369": {
      "name": "syncObservation",
      "type": "method",
      "start_line": 369,
      "end_line": 407,
      "content_hash": "350dd6057f15a3f1bae8faf53146b745d78b82a7",
      "content": "  async syncObservation(\n    observationId: number,\n    sdkSessionId: string,\n    project: string,\n    obs: ParsedObservation,\n    promptNumber: number,\n    createdAtEpoch: number,\n    discoveryTokens: number = 0\n  ): Promise<void> {\n    // Convert ParsedObservation to StoredObservation format\n    const stored: StoredObservation = {\n      id: observationId,\n      sdk_session_id: sdkSessionId,\n      project: project,\n      text: null, // Legacy field, not used\n      type: obs.type,\n      title: obs.title,\n      subtitle: obs.subtitle,\n      facts: JSON.stringify(obs.facts),\n      narrative: obs.narrative,\n      concepts: JSON.stringify(obs.concepts),\n      files_read: JSON.stringify(obs.files_read),\n      files_modified: JSON.stringify(obs.files_modified),\n      prompt_number: promptNumber,\n      discovery_tokens: discoveryTokens,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch\n    };\n\n    const documents = this.formatObservationDocs(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing observation', {\n      observationId,\n      documentCount: documents.length,\n      project\n    });\n\n    await this.addDocuments(documents);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_syncSummary_413": {
      "name": "syncSummary",
      "type": "method",
      "start_line": 413,
      "end_line": 448,
      "content_hash": "2290a6dfd1b598321fd171fa5d42a419b6b6a4d3",
      "content": "  async syncSummary(\n    summaryId: number,\n    sdkSessionId: string,\n    project: string,\n    summary: ParsedSummary,\n    promptNumber: number,\n    createdAtEpoch: number,\n    discoveryTokens: number = 0\n  ): Promise<void> {\n    // Convert ParsedSummary to StoredSummary format\n    const stored: StoredSummary = {\n      id: summaryId,\n      sdk_session_id: sdkSessionId,\n      project: project,\n      request: summary.request,\n      investigated: summary.investigated,\n      learned: summary.learned,\n      completed: summary.completed,\n      next_steps: summary.next_steps,\n      notes: summary.notes,\n      prompt_number: promptNumber,\n      discovery_tokens: discoveryTokens,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch\n    };\n\n    const documents = this.formatSummaryDocs(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing summary', {\n      summaryId,\n      documentCount: documents.length,\n      project\n    });\n\n    await this.addDocuments(documents);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_formatUserPromptDoc_454": {
      "name": "formatUserPromptDoc",
      "type": "method",
      "start_line": 454,
      "end_line": 467,
      "content_hash": "bbfcdc2474827bacf87c063ee8abfde317aa9288",
      "content": "  private formatUserPromptDoc(prompt: StoredUserPrompt): ChromaDocument {\n    return {\n      id: `prompt_${prompt.id}`,\n      document: prompt.prompt_text,\n      metadata: {\n        sqlite_id: prompt.id,\n        doc_type: 'user_prompt',\n        sdk_session_id: prompt.sdk_session_id,\n        project: prompt.project,\n        created_at_epoch: prompt.created_at_epoch,\n        prompt_number: prompt.prompt_number\n      }\n    };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_syncUserPrompt_473": {
      "name": "syncUserPrompt",
      "type": "method",
      "start_line": 473,
      "end_line": 501,
      "content_hash": "c1d3de3ffdb2ae9ce329e06ea243739e51e77af6",
      "content": "  async syncUserPrompt(\n    promptId: number,\n    sdkSessionId: string,\n    project: string,\n    promptText: string,\n    promptNumber: number,\n    createdAtEpoch: number\n  ): Promise<void> {\n    // Create StoredUserPrompt format\n    const stored: StoredUserPrompt = {\n      id: promptId,\n      claude_session_id: '', // Not needed for Chroma sync\n      prompt_number: promptNumber,\n      prompt_text: promptText,\n      created_at: new Date(createdAtEpoch * 1000).toISOString(),\n      created_at_epoch: createdAtEpoch,\n      sdk_session_id: sdkSessionId,\n      project: project\n    };\n\n    const document = this.formatUserPromptDoc(stored);\n\n    logger.info('CHROMA_SYNC', 'Syncing user prompt', {\n      promptId,\n      project\n    });\n\n    await this.addDocuments([document]);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getExistingChromaIds_507": {
      "name": "getExistingChromaIds",
      "type": "method",
      "start_line": 507,
      "end_line": 589,
      "content_hash": "46468bc6395177384f10a204b3e5da63d20d3b56",
      "content": "  private async getExistingChromaIds(): Promise<{\n    observations: Set<number>;\n    summaries: Set<number>;\n    prompts: Set<number>;\n  }> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    const observationIds = new Set<number>();\n    const summaryIds = new Set<number>();\n    const promptIds = new Set<number>();\n\n    let offset = 0;\n    const limit = 1000; // Large batches, metadata only = fast\n\n    logger.info('CHROMA_SYNC', 'Fetching existing Chroma document IDs...', { project: this.project });\n\n    while (true) {\n      try {\n        const result = await this.client.callTool({\n          name: 'chroma_get_documents',\n          arguments: {\n            collection_name: this.collectionName,\n            limit,\n            offset,\n            where: { project: this.project }, // Filter by project\n            include: ['metadatas']\n          }\n        });\n\n        const data = result.content[0];\n        if (data.type !== 'text') {\n          throw new Error('Unexpected response type from chroma_get_documents');\n        }\n\n        const parsed = JSON.parse(data.text);\n        const metadatas = parsed.metadatas || [];\n\n        if (metadatas.length === 0) {\n          break; // No more documents\n        }\n\n        // Extract SQLite IDs from metadata\n        for (const meta of metadatas) {\n          if (meta.sqlite_id) {\n            if (meta.doc_type === 'observation') {\n              observationIds.add(meta.sqlite_id);\n            } else if (meta.doc_type === 'session_summary') {\n              summaryIds.add(meta.sqlite_id);\n            } else if (meta.doc_type === 'user_prompt') {\n              promptIds.add(meta.sqlite_id);\n            }\n          }\n        }\n\n        offset += limit;\n\n        logger.debug('CHROMA_SYNC', 'Fetched batch of existing IDs', {\n          project: this.project,\n          offset,\n          batchSize: metadatas.length\n        });\n      } catch (error) {\n        logger.error('CHROMA_SYNC', 'Failed to fetch existing IDs', { project: this.project }, error as Error);\n        throw error;\n      }\n    }\n\n    logger.info('CHROMA_SYNC', 'Existing IDs fetched', {\n      project: this.project,\n      observations: observationIds.size,\n      summaries: summaryIds.size,\n      prompts: promptIds.size\n    });\n\n    return { observations: observationIds, summaries: summaryIds, prompts: promptIds };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureBackfilled_596": {
      "name": "ensureBackfilled",
      "type": "method",
      "start_line": 596,
      "end_line": 758,
      "content_hash": "ce99bbe67bbfa2f3906cdc0e8acd1ffbd347da9e",
      "content": "  async ensureBackfilled(): Promise<void> {\n    logger.info('CHROMA_SYNC', 'Starting smart backfill', { project: this.project });\n\n    await this.ensureCollection();\n\n    // Fetch existing IDs from Chroma (fast, metadata only)\n    const existing = await this.getExistingChromaIds();\n\n    const db = new SessionStore();\n\n    try {\n      // Build exclusion list for observations\n      const existingObsIds = Array.from(existing.observations);\n      const obsExclusionClause = existingObsIds.length > 0\n        ? `AND id NOT IN (${existingObsIds.join(',')})`\n        : '';\n\n      // Get only observations missing from Chroma\n      const observations = db.db.prepare(`\n        SELECT * FROM observations\n        WHERE project = ? ${obsExclusionClause}\n        ORDER BY id ASC\n      `).all(this.project) as StoredObservation[];\n\n      const totalObsCount = db.db.prepare(`\n        SELECT COUNT(*) as count FROM observations WHERE project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling observations', {\n        project: this.project,\n        missing: observations.length,\n        existing: existing.observations.size,\n        total: totalObsCount.count\n      });\n\n      // Format all observation documents\n      const allDocs: ChromaDocument[] = [];\n      for (const obs of observations) {\n        allDocs.push(...this.formatObservationDocs(obs));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < allDocs.length; i += this.BATCH_SIZE) {\n        const batch = allDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, allDocs.length)}/${allDocs.length}`\n        });\n      }\n\n      // Build exclusion list for summaries\n      const existingSummaryIds = Array.from(existing.summaries);\n      const summaryExclusionClause = existingSummaryIds.length > 0\n        ? `AND id NOT IN (${existingSummaryIds.join(',')})`\n        : '';\n\n      // Get only summaries missing from Chroma\n      const summaries = db.db.prepare(`\n        SELECT * FROM session_summaries\n        WHERE project = ? ${summaryExclusionClause}\n        ORDER BY id ASC\n      `).all(this.project) as StoredSummary[];\n\n      const totalSummaryCount = db.db.prepare(`\n        SELECT COUNT(*) as count FROM session_summaries WHERE project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling summaries', {\n        project: this.project,\n        missing: summaries.length,\n        existing: existing.summaries.size,\n        total: totalSummaryCount.count\n      });\n\n      // Format all summary documents\n      const summaryDocs: ChromaDocument[] = [];\n      for (const summary of summaries) {\n        summaryDocs.push(...this.formatSummaryDocs(summary));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < summaryDocs.length; i += this.BATCH_SIZE) {\n        const batch = summaryDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, summaryDocs.length)}/${summaryDocs.length}`\n        });\n      }\n\n      // Build exclusion list for prompts\n      const existingPromptIds = Array.from(existing.prompts);\n      const promptExclusionClause = existingPromptIds.length > 0\n        ? `AND up.id NOT IN (${existingPromptIds.join(',')})`\n        : '';\n\n      // Get only user prompts missing from Chroma\n      const prompts = db.db.prepare(`\n        SELECT\n          up.*,\n          s.project,\n          s.sdk_session_id\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        WHERE s.project = ? ${promptExclusionClause}\n        ORDER BY up.id ASC\n      `).all(this.project) as StoredUserPrompt[];\n\n      const totalPromptCount = db.db.prepare(`\n        SELECT COUNT(*) as count\n        FROM user_prompts up\n        JOIN sdk_sessions s ON up.claude_session_id = s.claude_session_id\n        WHERE s.project = ?\n      `).get(this.project) as { count: number };\n\n      logger.info('CHROMA_SYNC', 'Backfilling user prompts', {\n        project: this.project,\n        missing: prompts.length,\n        existing: existing.prompts.size,\n        total: totalPromptCount.count\n      });\n\n      // Format all prompt documents\n      const promptDocs: ChromaDocument[] = [];\n      for (const prompt of prompts) {\n        promptDocs.push(this.formatUserPromptDoc(prompt));\n      }\n\n      // Sync in batches\n      for (let i = 0; i < promptDocs.length; i += this.BATCH_SIZE) {\n        const batch = promptDocs.slice(i, i + this.BATCH_SIZE);\n        await this.addDocuments(batch);\n\n        logger.info('CHROMA_SYNC', 'Backfill progress', {\n          project: this.project,\n          progress: `${Math.min(i + this.BATCH_SIZE, promptDocs.length)}/${promptDocs.length}`\n        });\n      }\n\n      logger.info('CHROMA_SYNC', 'Smart backfill complete', {\n        project: this.project,\n        synced: {\n          observationDocs: allDocs.length,\n          summaryDocs: summaryDocs.length,\n          promptDocs: promptDocs.length\n        },\n        skipped: {\n          observations: existing.observations.size,\n          summaries: existing.summaries.size,\n          prompts: existing.prompts.size\n        }\n      });\n\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Backfill failed', { project: this.project }, error as Error);\n      throw new Error(`Backfill failed: ${error instanceof Error ? error.message : String(error)}`);\n    } finally {\n      db.close();\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_queryChroma_764": {
      "name": "queryChroma",
      "type": "method",
      "start_line": 764,
      "end_line": 840,
      "content_hash": "94df49a9c7a5afbf0f139f295fa37fc2e64d6b65",
      "content": "  async queryChroma(\n    query: string,\n    limit: number,\n    whereFilter?: Record<string, any>\n  ): Promise<{ ids: number[]; distances: number[]; metadatas: any[] }> {\n    await this.ensureConnection();\n\n    if (!this.client) {\n      throw new Error(\n        'Chroma client not initialized. Call ensureConnection() before using client methods.' +\n        ` Project: ${this.project}`\n      );\n    }\n\n    const whereStringified = whereFilter ? JSON.stringify(whereFilter) : undefined;\n\n    const arguments_obj = {\n      collection_name: this.collectionName,\n      query_texts: [query],\n      n_results: limit,\n      include: ['documents', 'metadatas', 'distances'],\n      where: whereStringified\n    };\n\n    const result = await this.client.callTool({\n      name: 'chroma_query_documents',\n      arguments: arguments_obj\n    });\n\n    const resultText = logger.happyPathError(\n      'CHROMA',\n      'Missing text in MCP chroma_query_documents result',\n      { project: this.project },\n      { query_text: query },\n      result.content[0]?.text || ''\n    );\n\n    // Parse JSON response\n    let parsed: any;\n    try {\n      parsed = JSON.parse(resultText);\n    } catch (error) {\n      logger.error('CHROMA_SYNC', 'Failed to parse Chroma response', { project: this.project }, error as Error);\n      return { ids: [], distances: [], metadatas: [] };\n    }\n\n    // Extract unique IDs from document IDs\n    const ids: number[] = [];\n    const docIds = parsed.ids?.[0] || [];\n    for (const docId of docIds) {\n      // Extract sqlite_id from document ID (supports three formats):\n      // - obs_{id}_narrative, obs_{id}_fact_0, etc (observations)\n      // - summary_{id}_request, summary_{id}_learned, etc (session summaries)\n      // - prompt_{id} (user prompts)\n      const obsMatch = docId.match(/obs_(\\d+)_/);\n      const summaryMatch = docId.match(/summary_(\\d+)_/);\n      const promptMatch = docId.match(/prompt_(\\d+)/);\n\n      let sqliteId: number | null = null;\n      if (obsMatch) {\n        sqliteId = parseInt(obsMatch[1], 10);\n      } else if (summaryMatch) {\n        sqliteId = parseInt(summaryMatch[1], 10);\n      } else if (promptMatch) {\n        sqliteId = parseInt(promptMatch[1], 10);\n      }\n\n      if (sqliteId !== null && !ids.includes(sqliteId)) {\n        ids.push(sqliteId);\n      }\n    }\n\n    const distances = parsed.distances?.[0] || [];\n    const metadatas = parsed.metadatas?.[0] || [];\n\n    return { ids, distances, metadatas };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_close_845": {
      "name": "close",
      "type": "method",
      "start_line": 845,
      "end_line": 866,
      "content_hash": "30db3e8a376744eaae9fe7b83cdc419953421a9e",
      "content": "  async close(): Promise<void> {\n    if (!this.connected && !this.client && !this.transport) {\n      return;\n    }\n\n    // Close client first\n    if (this.client) {\n      await this.client.close();\n    }\n\n    // Explicitly close transport to kill subprocess\n    if (this.transport) {\n      await this.transport.close();\n    }\n\n    logger.info('CHROMA_SYNC', 'Chroma client and subprocess closed', { project: this.project });\n\n    // Always reset state\n    this.connected = false;\n    this.client = null;\n    this.transport = null;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}