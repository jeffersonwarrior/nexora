{
  "file_path": "/work/internal/indexer/ast_parser.go",
  "file_hash": "30347b5925d5fe3f15ce8217b4feb9bbdc1dff59",
  "updated_at": "2025-12-26T17:34:21.033240",
  "symbols": {
    "struct_Symbol_17": {
      "name": "Symbol",
      "type": "struct",
      "start_line": 17,
      "end_line": 35,
      "content_hash": "424b7ad566dd2c9eed17f6fa53b99090318241f8",
      "content": "type Symbol struct {\n\tName      string   `json:\"name\"`\n\tType      string   `json:\"type\"` // func, struct, interface, var, const\n\tPackage   string   `json:\"package\"`\n\tFile      string   `json:\"file\"`\n\tLine      int      `json:\"line\"`\n\tColumn    int      `json:\"column\"`\n\tSignature string   `json:\"signature\"`\n\tDoc       string   `json:\"doc\"`\n\tImports   []string `json:\"imports\"`\n\tCallers   []string `json:\"callers\"`\n\tCalls     []string `json:\"calls\"`\n\tPublic    bool     `json:\"public\"`\n\tParams    []Param  `json:\"params,omitempty\"`\n\tReturns   []string `json:\"returns,omitempty\"`\n\tFields    []Field  `json:\"fields,omitempty\"`\n\tMethods   []string `json:\"methods,omitempty\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Param_36": {
      "name": "Param",
      "type": "struct",
      "start_line": 36,
      "end_line": 40,
      "content_hash": "d424901504c1b5df69b90c32b44583ae963ae7ca",
      "content": "type Param struct {\n\tName string `json:\"name\"`\n\tType string `json:\"type\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Field_41": {
      "name": "Field",
      "type": "struct",
      "start_line": 41,
      "end_line": 46,
      "content_hash": "bab8c21e5bb62dc02815ae46dde556e579126ed2",
      "content": "type Field struct {\n\tName string `json:\"name\"`\n\tType string `json:\"type\"`\n}\n\n// ASTParser extracts symbols from Go source code",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ASTParser_47": {
      "name": "ASTParser",
      "type": "struct",
      "start_line": 47,
      "end_line": 51,
      "content_hash": "4f24c26327475b48f4fbe458fc710e2127f3ffcf",
      "content": "type ASTParser struct {\n\tfset    *token.FileSet\n\tsymbols []Symbol\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewASTParser_52": {
      "name": "NewASTParser",
      "type": "function",
      "start_line": 52,
      "end_line": 60,
      "content_hash": "d1f930f9e70c075dc58486eb065e4d41900a31aa",
      "content": "func NewASTParser() *ASTParser {\n\treturn &ASTParser{\n\t\tfset:    token.NewFileSet(),\n\t\tsymbols: make([]Symbol, 0),\n\t}\n}\n\n// ParseDirectory parses all Go files in a directory using golang.org/x/tools/go/packages\n// for better build tag support and module awareness",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ParseDirectory_61": {
      "name": "ParseDirectory",
      "type": "method",
      "start_line": 61,
      "end_line": 148,
      "content_hash": "05ed5776c085a50811f186deb2fdcaa2d75ef551",
      "content": "func (p *ASTParser) ParseDirectory(ctx context.Context, dir string) ([]Symbol, error) {\n\tp.symbols = make([]Symbol, 0)\n\n\t// Check if there's a go.mod file to determine if we should use packages.Load\n\tgoModPath := filepath.Join(dir, \"go.mod\")\n\tif _, err := os.Stat(goModPath); os.IsNotExist(err) {\n\t\t// No go.mod file, use legacy parser.ParseDir approach\n\t\treturn p.parseDirectoryLegacy(ctx, dir)\n\t}\n\n\t// Use packages.Load for better build tag support and module awareness\n\tconfig := &packages.Config{\n\t\tMode:  packages.NeedSyntax | packages.NeedFiles | packages.NeedCompiledGoFiles,\n\t\tDir:   dir,\n\t\tTests: false,\n\t}\n\n\t// Load packages with pattern \".\" to get current directory package\n\tpkgs, err := packages.Load(config, \".\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load packages from directory %s: %w\", dir, err)\n\t}\n\n\t// Process all loaded packages\n\tfor _, pkg := range pkgs {\n\t\tif pkg.Errors != nil {\n\t\t\t// If packages.Load has errors, fall back to the legacy parser.ParseDir approach\n\t\t\treturn p.parseDirectoryLegacy(ctx, dir)\n\t\t}\n\n\t\t// Extract package name from the package\n\t\tpkgName := pkg.Name\n\n\t\t// Process each syntax tree (Go file) in the package\n\t\tfor _, file := range pkg.Syntax {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn nil, ctx.Err()\n\t\t\tdefault:\n\t\t\t\t// Find the corresponding filename\n\t\t\t\tfilename := \"\"\n\t\t\t\tif len(pkg.CompiledGoFiles) > 0 {\n\t\t\t\t\t// Use compiled Go files if available (better with build tags)\n\t\t\t\t\tfor i, syntax := range pkg.Syntax {\n\t\t\t\t\t\tif syntax == file {\n\t\t\t\t\t\t\tif i < len(pkg.CompiledGoFiles) {\n\t\t\t\t\t\t\t\tfilename = pkg.CompiledGoFiles[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fallback to Go files if compiled file not found\n\t\t\t\tif filename == \"\" {\n\t\t\t\t\tfor i, syntax := range pkg.Syntax {\n\t\t\t\t\t\tif syntax == file {\n\t\t\t\t\t\t\tif i < len(pkg.GoFiles) {\n\t\t\t\t\t\t\t\tfilename = pkg.GoFiles[i]\n\t\t\t\t\t\t\t\t// Make absolute path relative to the directory\n\t\t\t\t\t\t\t\tif !filepath.IsAbs(filename) {\n\t\t\t\t\t\t\t\t\tfilename = filepath.Join(dir, filepath.Base(filename))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Final fallback to generate filename\n\t\t\t\tif filename == \"\" {\n\t\t\t\t\tfilename = filepath.Join(dir, \"generated.go\")\n\t\t\t\t}\n\n\t\t\t\tp.parseFile(ctx, pkgName, filename, file)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no packages were found, try legacy approach\n\tif len(p.symbols) == 0 {\n\t\treturn p.parseDirectoryLegacy(ctx, dir)\n\t}\n\n\treturn p.symbols, nil\n}\n\n// parseDirectoryLegacy falls back to parser.ParseDir for compatibility",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseDirectoryLegacy_149": {
      "name": "parseDirectoryLegacy",
      "type": "method",
      "start_line": 149,
      "end_line": 171,
      "content_hash": "8075f4bfefae890d92f31bdd3b5080b531246e3d",
      "content": "func (p *ASTParser) parseDirectoryLegacy(ctx context.Context, dir string) ([]Symbol, error) {\n\tp.symbols = make([]Symbol, 0)\n\n\tpkgs, err := parser.ParseDir(p.fset, dir, nil, parser.ParseComments)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse directory %s: %w\", dir, err)\n\t}\n\n\tfor pkgName, pkg := range pkgs {\n\t\tfor filename, file := range pkg.Files {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn nil, ctx.Err()\n\t\t\tdefault:\n\t\t\t\tp.parseFile(ctx, pkgName, filename, file)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.symbols, nil\n}\n\n// ParseFile extracts symbols from a single Go file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ParseFile_172": {
      "name": "ParseFile",
      "type": "method",
      "start_line": 172,
      "end_line": 190,
      "content_hash": "f840598f3e9ac9cb40fe95f11b021e7425c37ff4",
      "content": "func (p *ASTParser) ParseFile(ctx context.Context, filename string) ([]Symbol, error) {\n\tp.symbols = make([]Symbol, 0)\n\n\t// Parse the single file\n\tfile, err := parser.ParseFile(p.fset, filename, nil, parser.ParseComments)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse file %s: %w\", filename, err)\n\t}\n\n\t// Extract package name\n\tpkgName := file.Name.Name\n\n\t// Parse the file\n\tp.parseFile(ctx, pkgName, filename, file)\n\n\treturn p.symbols, nil\n}\n\n// parseFile extracts symbols from a single Go file (internal method)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseFile_191": {
      "name": "parseFile",
      "type": "method",
      "start_line": 191,
      "end_line": 216,
      "content_hash": "4422ba530291607555fefb87504e697ed44f66db",
      "content": "func (p *ASTParser) parseFile(ctx context.Context, pkgName, filename string, file *ast.File) {\n\tdoc := extractFileDoc(file)\n\timports := extractImports(file)\n\n\t// Visit all nodes in the AST\n\tast.Inspect(file, func(n ast.Node) bool {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn false\n\t\tdefault:\n\t\t}\n\n\t\tswitch node := n.(type) {\n\t\tcase *ast.FuncDecl:\n\t\t\tp.parseFunction(pkgName, filename, node, doc, imports)\n\t\tcase *ast.GenDecl:\n\t\t\tp.parseGenDecl(pkgName, filename, node, doc, imports)\n\t\tcase *ast.TypeSpec:\n\t\t\tp.parseTypeSpec(pkgName, filename, node, file, doc, imports)\n\t\t}\n\n\t\treturn true\n\t})\n}\n\n// parseFunction extracts function information",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseFunction_217": {
      "name": "parseFunction",
      "type": "method",
      "start_line": 217,
      "end_line": 257,
      "content_hash": "967278cda6c89fb2cb5333caee6a2e9769bebeef",
      "content": "func (p *ASTParser) parseFunction(pkgName, filename string, decl *ast.FuncDecl, fileDoc string, imports []string) {\n\tpos := p.fset.Position(decl.Pos())\n\tsignature := formatFunctionSignature(decl)\n\tdoc := extractNodeDoc(decl.Doc)\n\n\tsym := Symbol{\n\t\tName:      decl.Name.Name,\n\t\tType:      \"function\",\n\t\tPackage:   pkgName,\n\t\tFile:      filename,\n\t\tLine:      pos.Line,\n\t\tColumn:    pos.Column,\n\t\tSignature: signature,\n\t\tDoc:       doc,\n\t\tImports:   imports,\n\t\tPublic:    decl.Name.IsExported(),\n\t\tParams:    extractParams(decl.Type.Params),\n\t\tReturns:   extractReturns(decl.Type.Results),\n\t}\n\n\t// Handle methods\n\tif decl.Recv != nil && len(decl.Recv.List) > 0 {\n\t\trecvType := extractRecvType(decl.Recv.List[0].Type)\n\t\tsym.Name = recvType + \".\" + sym.Name\n\t\tsym.Type = \"method\"\n\t}\n\n\t// Extract function calls within this function\n\tast.Inspect(decl, func(n ast.Node) bool {\n\t\tif call, ok := n.(*ast.CallExpr); ok {\n\t\t\tif ident, ok := call.Fun.(*ast.Ident); ok {\n\t\t\t\tsym.Calls = append(sym.Calls, ident.Name)\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n\n\tp.symbols = append(p.symbols, sym)\n}\n\n// parseGenDecl handles general declarations (var, const)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseGenDecl_258": {
      "name": "parseGenDecl",
      "type": "method",
      "start_line": 258,
      "end_line": 296,
      "content_hash": "7e09e4a4875b21380b464d494ef558fc6e9d6583",
      "content": "func (p *ASTParser) parseGenDecl(pkgName, filename string, decl *ast.GenDecl, fileDoc string, imports []string) {\n\tdoc := extractNodeDoc(decl.Doc)\n\tdeclType := \"var\"\n\tif decl.Tok == token.CONST {\n\t\tdeclType = \"const\"\n\t}\n\n\tfor _, spec := range decl.Specs {\n\t\tif valueSpec, ok := spec.(*ast.ValueSpec); ok {\n\t\t\tfor _, name := range valueSpec.Names {\n\t\t\t\tpos := p.fset.Position(name.Pos())\n\t\t\t\tvarType := \"\"\n\t\t\t\tif valueSpec.Type != nil {\n\t\t\t\t\tvarType = formatType(valueSpec.Type)\n\t\t\t\t}\n\n\t\t\t\tsym := Symbol{\n\t\t\t\t\tName:    name.Name,\n\t\t\t\t\tType:    declType,\n\t\t\t\t\tPackage: pkgName,\n\t\t\t\t\tFile:    filename,\n\t\t\t\t\tLine:    pos.Line,\n\t\t\t\t\tColumn:  pos.Column,\n\t\t\t\t\tDoc:     doc,\n\t\t\t\t\tImports: imports,\n\t\t\t\t\tPublic:  name.IsExported(),\n\t\t\t\t}\n\n\t\t\t\tif varType != \"\" {\n\t\t\t\t\tsym.Signature = fmt.Sprintf(\"%s %s\", name.Name, varType)\n\t\t\t\t}\n\n\t\t\t\tp.symbols = append(p.symbols, sym)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// parseTypeSpec handles type declarations",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_parseTypeSpec_297": {
      "name": "parseTypeSpec",
      "type": "method",
      "start_line": 297,
      "end_line": 329,
      "content_hash": "a3e1be7063f652d193e3d3a7972b4aa709253b7a",
      "content": "func (p *ASTParser) parseTypeSpec(pkgName, filename string, spec *ast.TypeSpec, file *ast.File, fileDoc string, imports []string) {\n\tpos := p.fset.Position(spec.Pos())\n\tdoc := extractNodeDoc(spec.Doc)\n\ttypeDef := formatType(spec.Type)\n\n\tsym := Symbol{\n\t\tName:      spec.Name.Name,\n\t\tType:      \"type\",\n\t\tPackage:   pkgName,\n\t\tFile:      filename,\n\t\tLine:      pos.Line,\n\t\tColumn:    pos.Column,\n\t\tSignature: fmt.Sprintf(\"type %s %s\", spec.Name.Name, typeDef),\n\t\tDoc:       doc,\n\t\tImports:   imports,\n\t\tPublic:    spec.Name.IsExported(),\n\t}\n\n\t// Extract specific type information\n\tswitch t := spec.Type.(type) {\n\tcase *ast.StructType:\n\t\tsym.Type = \"struct\"\n\t\tsym.Fields = extractStructFields(t)\n\tcase *ast.InterfaceType:\n\t\tsym.Type = \"interface\"\n\t\tsym.Methods = extractInterfaceMethods(t)\n\t}\n\n\tp.symbols = append(p.symbols, sym)\n}\n\n// Helper functions for extracting information\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractFileDoc_330": {
      "name": "extractFileDoc",
      "type": "function",
      "start_line": 330,
      "end_line": 336,
      "content_hash": "46a3c1379cfc0e080c67cc3bfe5fd8341893c11e",
      "content": "func extractFileDoc(file *ast.File) string {\n\tif len(file.Comments) > 0 {\n\t\treturn file.Comments[0].Text()\n\t}\n\treturn \"\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractNodeDoc_337": {
      "name": "extractNodeDoc",
      "type": "function",
      "start_line": 337,
      "end_line": 343,
      "content_hash": "8f0a30051b636a65345adb3aa9a0fd465bdb281a",
      "content": "func extractNodeDoc(doc *ast.CommentGroup) string {\n\tif doc != nil {\n\t\treturn doc.Text()\n\t}\n\treturn \"\"\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractImports_344": {
      "name": "extractImports",
      "type": "function",
      "start_line": 344,
      "end_line": 352,
      "content_hash": "77c74858454f37a54ac560f84df1e9af00debebc",
      "content": "func extractImports(file *ast.File) []string {\n\timports := make([]string, 0)\n\tfor _, imp := range file.Imports {\n\t\timportPath := strings.Trim(imp.Path.Value, `\"`)\n\t\timports = append(imports, importPath)\n\t}\n\treturn imports\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractParams_353": {
      "name": "extractParams",
      "type": "function",
      "start_line": 353,
      "end_line": 376,
      "content_hash": "d890c6662552c1d9cab2cbc58319308f5233abfe",
      "content": "func extractParams(params *ast.FieldList) []Param {\n\tif params == nil {\n\t\treturn nil\n\t}\n\tresult := make([]Param, 0)\n\tfor _, field := range params.List {\n\t\tparamType := formatType(field.Type)\n\t\tfor _, name := range field.Names {\n\t\t\tresult = append(result, Param{\n\t\t\t\tName: name.Name,\n\t\t\t\tType: paramType,\n\t\t\t})\n\t\t}\n\t\t// Handle unnamed parameters\n\t\tif len(field.Names) == 0 {\n\t\t\tresult = append(result, Param{\n\t\t\t\tName: \"\",\n\t\t\t\tType: paramType,\n\t\t\t})\n\t\t}\n\t}\n\treturn result\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractReturns_377": {
      "name": "extractReturns",
      "type": "function",
      "start_line": 377,
      "end_line": 394,
      "content_hash": "1dee069dbaafa4c65bc996d6f18ff1c6f48cb03e",
      "content": "func extractReturns(results *ast.FieldList) []string {\n\tif results == nil {\n\t\treturn nil\n\t}\n\treturnValues := make([]string, 0)\n\tfor _, field := range results.List {\n\t\ttypeStr := formatType(field.Type)\n\t\tif len(field.Names) > 0 {\n\t\t\tfor _, name := range field.Names {\n\t\t\t\treturnValues = append(returnValues, fmt.Sprintf(\"%s %s\", name.Name, typeStr))\n\t\t\t}\n\t\t} else {\n\t\t\treturnValues = append(returnValues, typeStr)\n\t\t}\n\t}\n\treturn returnValues\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractStructFields_395": {
      "name": "extractStructFields",
      "type": "function",
      "start_line": 395,
      "end_line": 408,
      "content_hash": "752b36b4bc9501cab8a3b17821e6f00091c1aa68",
      "content": "func extractStructFields(structType *ast.StructType) []Field {\n\tfields := make([]Field, 0)\n\tfor _, field := range structType.Fields.List {\n\t\tfieldType := formatType(field.Type)\n\t\tfor _, name := range field.Names {\n\t\t\tfields = append(fields, Field{\n\t\t\t\tName: name.Name,\n\t\t\t\tType: fieldType,\n\t\t\t})\n\t\t}\n\t}\n\treturn fields\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractInterfaceMethods_409": {
      "name": "extractInterfaceMethods",
      "type": "function",
      "start_line": 409,
      "end_line": 425,
      "content_hash": "7dfbe06dabf8809e39fb462d89250aaf86e74e81",
      "content": "func extractInterfaceMethods(iface *ast.InterfaceType) []string {\n\tmethods := make([]string, 0)\n\tfor _, method := range iface.Methods.List {\n\t\tswitch m := method.Type.(type) {\n\t\tcase *ast.FuncType:\n\t\t\tfuncName := \"\"\n\t\t\tif len(method.Names) > 0 {\n\t\t\t\tfuncName = method.Names[0].Name\n\t\t\t}\n\t\t\tmethods = append(methods, funcName)\n\t\tcase *ast.Ident:\n\t\t\tmethods = append(methods, m.Name)\n\t\t}\n\t}\n\treturn methods\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_extractRecvType_426": {
      "name": "extractRecvType",
      "type": "function",
      "start_line": 426,
      "end_line": 436,
      "content_hash": "e204b32d685502c92025686b695cafd86abaf3c6",
      "content": "func extractRecvType(expr ast.Expr) string {\n\tswitch t := expr.(type) {\n\tcase *ast.StarExpr:\n\t\treturn extractRecvType(t.X)\n\tcase *ast.Ident:\n\t\treturn t.Name\n\tdefault:\n\t\treturn formatType(expr)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatFunctionSignature_437": {
      "name": "formatFunctionSignature",
      "type": "function",
      "start_line": 437,
      "end_line": 464,
      "content_hash": "2e37d9b207d8514acc6e953308d0ed942a60a035",
      "content": "func formatFunctionSignature(decl *ast.FuncDecl) string {\n\tvar params []string\n\tif decl.Type.Params != nil {\n\t\tfor _, field := range decl.Type.Params.List {\n\t\t\tparamType := formatType(field.Type)\n\t\t\tif len(field.Names) > 0 {\n\t\t\t\tfor _, name := range field.Names {\n\t\t\t\t\tparams = append(params, fmt.Sprintf(\"%s %s\", name.Name, paramType))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams = append(params, paramType)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar returns []string\n\tif decl.Type.Results != nil {\n\t\treturns = extractReturns(decl.Type.Results)\n\t}\n\n\tsignature := fmt.Sprintf(\"func %s(%s)\", decl.Name.Name, strings.Join(params, \", \"))\n\tif len(returns) > 0 {\n\t\tsignature += fmt.Sprintf(\" (%s)\", strings.Join(returns, \", \"))\n\t}\n\n\treturn signature\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatType_465": {
      "name": "formatType",
      "type": "function",
      "start_line": 465,
      "end_line": 498,
      "content_hash": "8c313b80b7c35266b647cbdcd5bd3ed1f0031acb",
      "content": "func formatType(expr ast.Expr) string {\n\t// Simplified type formatting - can be expanded for more complex types\n\tswitch t := expr.(type) {\n\tcase *ast.Ident:\n\t\treturn t.Name\n\tcase *ast.StarExpr:\n\t\treturn \"*\" + formatType(t.X)\n\tcase *ast.SelectorExpr:\n\t\treturn formatType(t.X) + \".\" + t.Sel.Name\n\tcase *ast.ArrayType:\n\t\tif t.Len != nil {\n\t\t\treturn fmt.Sprintf(\"[%s]%s\", formatExpr(t.Len), formatType(t.Elt))\n\t\t}\n\t\treturn \"[]\" + formatType(t.Elt)\n\tcase *ast.MapType:\n\t\treturn fmt.Sprintf(\"map[%s]%s\", formatType(t.Key), formatType(t.Value))\n\tcase *ast.InterfaceType:\n\t\treturn \"interface{}\"\n\tcase *ast.ChanType:\n\t\tswitch t.Dir {\n\t\tcase ast.SEND:\n\t\t\treturn \"chan<- \" + formatType(t.Value)\n\t\tcase ast.RECV:\n\t\t\treturn \"<-chan \" + formatType(t.Value)\n\t\tdefault:\n\t\t\treturn \"chan \" + formatType(t.Value)\n\t\t}\n\tcase *ast.FuncType:\n\t\treturn \"func()\" // Simplified for now\n\tdefault:\n\t\treturn fmt.Sprintf(\"%T\", expr) // Fallback\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_formatExpr_499": {
      "name": "formatExpr",
      "type": "function",
      "start_line": 499,
      "end_line": 509,
      "content_hash": "dbc4f07e1f91b0c81bf7bbe05d8ce1ca7c5444ba",
      "content": "func formatExpr(expr ast.Expr) string {\n\t// Simplified expression formatting\n\tswitch t := expr.(type) {\n\tcase *ast.Ident:\n\t\treturn t.Name\n\tcase *ast.BasicLit:\n\t\treturn t.Value\n\tdefault:\n\t\treturn fmt.Sprintf(\"%T\", expr)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}