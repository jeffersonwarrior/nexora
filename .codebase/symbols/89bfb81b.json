{
  "file_path": "/work/internal/lsp/util/edit.go",
  "file_hash": "afa9f3ff91d2f2f53720c212544d7b55076ee2ac",
  "updated_at": "2025-12-26T17:34:20.218495",
  "symbols": {
    "function_applyTextEdits_13": {
      "name": "applyTextEdits",
      "type": "function",
      "start_line": 13,
      "end_line": 87,
      "content_hash": "4bf6307daa0b9e5e0e051ceeea7eb192f7b01d56",
      "content": "func applyTextEdits(uri protocol.DocumentURI, edits []protocol.TextEdit) error {\n\tpath, err := uri.Path()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid URI: %w\", err)\n\t}\n\n\t// Read the file content\n\tcontent, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\t// Detect line ending style\n\tvar lineEnding string\n\tif bytes.Contains(content, []byte(\"\\r\\n\")) {\n\t\tlineEnding = \"\\r\\n\"\n\t} else {\n\t\tlineEnding = \"\\n\"\n\t}\n\n\t// Track if file ends with a newline\n\tendsWithNewline := len(content) > 0 && bytes.HasSuffix(content, []byte(lineEnding))\n\n\t// Split into lines without the endings\n\tlines := strings.Split(string(content), lineEnding)\n\n\t// Check for overlapping edits\n\tfor i, edit1 := range edits {\n\t\tfor j := i + 1; j < len(edits); j++ {\n\t\t\tif rangesOverlap(edit1.Range, edits[j].Range) {\n\t\t\t\treturn fmt.Errorf(\"overlapping edits detected between edit %d and %d\", i, j)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort edits in reverse order\n\tsortedEdits := make([]protocol.TextEdit, len(edits))\n\tcopy(sortedEdits, edits)\n\tsort.Slice(sortedEdits, func(i, j int) bool {\n\t\tif sortedEdits[i].Range.Start.Line != sortedEdits[j].Range.Start.Line {\n\t\t\treturn sortedEdits[i].Range.Start.Line > sortedEdits[j].Range.Start.Line\n\t\t}\n\t\treturn sortedEdits[i].Range.Start.Character > sortedEdits[j].Range.Start.Character\n\t})\n\n\t// Apply each edit\n\tfor _, edit := range sortedEdits {\n\t\tnewLines, err := applyTextEdit(lines, edit)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to apply edit: %w\", err)\n\t\t}\n\t\tlines = newLines\n\t}\n\n\t// Join lines with proper line endings\n\tvar newContent strings.Builder\n\tfor i, line := range lines {\n\t\tif i > 0 {\n\t\t\tnewContent.WriteString(lineEnding)\n\t\t}\n\t\tnewContent.WriteString(line)\n\t}\n\n\t// Only add a newline if the original file had one and we haven't already added it\n\tif endsWithNewline && !strings.HasSuffix(newContent.String(), lineEnding) {\n\t\tnewContent.WriteString(lineEnding)\n\t}\n\n\tif err := os.WriteFile(path, []byte(newContent.String()), 0o644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyTextEdit_88": {
      "name": "applyTextEdit",
      "type": "function",
      "start_line": 88,
      "end_line": 151,
      "content_hash": "9c487a98f7efbb82e856ceba148f7e60a205afd2",
      "content": "func applyTextEdit(lines []string, edit protocol.TextEdit) ([]string, error) {\n\tstartLine := int(edit.Range.Start.Line)\n\tendLine := int(edit.Range.End.Line)\n\tstartChar := int(edit.Range.Start.Character)\n\tendChar := int(edit.Range.End.Character)\n\n\t// Validate positions\n\tif startLine < 0 || startLine >= len(lines) {\n\t\treturn nil, fmt.Errorf(\"invalid start line: %d\", startLine)\n\t}\n\tif endLine < 0 || endLine >= len(lines) {\n\t\tendLine = len(lines) - 1\n\t}\n\n\t// Create result slice with initial capacity\n\tresult := make([]string, 0, len(lines))\n\n\t// Copy lines before edit\n\tresult = append(result, lines[:startLine]...)\n\n\t// Get the prefix of the start line\n\tstartLineContent := lines[startLine]\n\tif startChar < 0 || startChar > len(startLineContent) {\n\t\tstartChar = len(startLineContent)\n\t}\n\tprefix := startLineContent[:startChar]\n\n\t// Get the suffix of the end line\n\tendLineContent := lines[endLine]\n\tif endChar < 0 || endChar > len(endLineContent) {\n\t\tendChar = len(endLineContent)\n\t}\n\tsuffix := endLineContent[endChar:]\n\n\t// Handle the edit\n\tif edit.NewText == \"\" {\n\t\tif prefix+suffix != \"\" {\n\t\t\tresult = append(result, prefix+suffix)\n\t\t}\n\t} else {\n\t\t// Split new text into lines, being careful not to add extra newlines\n\t\t// newLines := strings.Split(strings.TrimRight(edit.NewText, \"\\n\"), \"\\n\")\n\t\tnewLines := strings.Split(edit.NewText, \"\\n\")\n\n\t\tif len(newLines) == 1 {\n\t\t\t// Single line change\n\t\t\tresult = append(result, prefix+newLines[0]+suffix)\n\t\t} else {\n\t\t\t// Multi-line change\n\t\t\tresult = append(result, prefix+newLines[0])\n\t\t\tresult = append(result, newLines[1:len(newLines)-1]...)\n\t\t\tresult = append(result, newLines[len(newLines)-1]+suffix)\n\t\t}\n\t}\n\n\t// Add remaining lines\n\tif endLine+1 < len(lines) {\n\t\tresult = append(result, lines[endLine+1:]...)\n\t}\n\n\treturn result, nil\n}\n\n// applyDocumentChange applies a DocumentChange (create/rename/delete operations)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_applyDocumentChange_152": {
      "name": "applyDocumentChange",
      "type": "function",
      "start_line": 152,
      "end_line": 231,
      "content_hash": "03e061f919065b82e6f96421a858b59e15026d72",
      "content": "func applyDocumentChange(change protocol.DocumentChange) error {\n\tif change.CreateFile != nil {\n\t\tpath, err := change.CreateFile.URI.Path()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid URI: %w\", err)\n\t\t}\n\n\t\tif change.CreateFile.Options != nil {\n\t\t\tif change.CreateFile.Options.Overwrite {\n\t\t\t\t// Proceed with overwrite\n\t\t\t} else if change.CreateFile.Options.IgnoreIfExists {\n\t\t\t\tif _, err := os.Stat(path); err == nil {\n\t\t\t\t\treturn nil // File exists and we're ignoring it\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif err := os.WriteFile(path, []byte(\"\"), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create file: %w\", err)\n\t\t}\n\t}\n\n\tif change.DeleteFile != nil {\n\t\tpath, err := change.DeleteFile.URI.Path()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid URI: %w\", err)\n\t\t}\n\n\t\tif change.DeleteFile.Options != nil && change.DeleteFile.Options.Recursive {\n\t\t\tif err := os.RemoveAll(path); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to delete directory recursively: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err := os.Remove(path); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to delete file: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif change.RenameFile != nil {\n\t\tvar newPath, oldPath string\n\t\tvar err error\n\n\t\toldPath, err = change.RenameFile.OldURI.Path()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewPath, err = change.RenameFile.NewURI.Path()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif change.RenameFile.Options != nil {\n\t\t\tif !change.RenameFile.Options.Overwrite {\n\t\t\t\tif _, err := os.Stat(newPath); err == nil {\n\t\t\t\t\treturn fmt.Errorf(\"target file already exists and overwrite is not allowed: %s\", newPath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif err := os.Rename(oldPath, newPath); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to rename file: %w\", err)\n\t\t}\n\t}\n\n\tif change.TextDocumentEdit != nil {\n\t\ttextEdits := make([]protocol.TextEdit, len(change.TextDocumentEdit.Edits))\n\t\tfor i, edit := range change.TextDocumentEdit.Edits {\n\t\t\tvar err error\n\t\t\ttextEdits[i], err = edit.AsTextEdit()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid edit type: %w\", err)\n\t\t\t}\n\t\t}\n\t\treturn applyTextEdits(change.TextDocumentEdit.TextDocument.URI, textEdits)\n\t}\n\n\treturn nil\n}\n\n// ApplyWorkspaceEdit applies the given WorkspaceEdit to the filesystem",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_ApplyWorkspaceEdit_232": {
      "name": "ApplyWorkspaceEdit",
      "type": "function",
      "start_line": 232,
      "end_line": 249,
      "content_hash": "27084a674a86e21bbf774b80fb2fd10afe8d533e",
      "content": "func ApplyWorkspaceEdit(edit protocol.WorkspaceEdit) error {\n\t// Handle Changes field\n\tfor uri, textEdits := range edit.Changes {\n\t\tif err := applyTextEdits(uri, textEdits); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to apply text edits: %w\", err)\n\t\t}\n\t}\n\n\t// Handle DocumentChanges field\n\tfor _, change := range edit.DocumentChanges {\n\t\tif err := applyDocumentChange(change); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to apply document change: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_rangesOverlap_250": {
      "name": "rangesOverlap",
      "type": "function",
      "start_line": 250,
      "end_line": 261,
      "content_hash": "838af6fd19f22e19e555ec4218881b1c88ea2ad0",
      "content": "func rangesOverlap(r1, r2 protocol.Range) bool {\n\tif r1.Start.Line > r2.End.Line || r2.Start.Line > r1.End.Line {\n\t\treturn false\n\t}\n\tif r1.Start.Line == r2.End.Line && r1.Start.Character > r2.End.Character {\n\t\treturn false\n\t}\n\tif r2.Start.Line == r1.End.Line && r2.Start.Character > r1.End.Character {\n\t\treturn false\n\t}\n\treturn true\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}