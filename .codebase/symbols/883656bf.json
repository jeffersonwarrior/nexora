{
  "file_path": "/work/external-deps/helix-db/helix-cli/src/sse_client.rs",
  "file_hash": "743344b050a020dec6bf7db3ddb0209e225c5d6d",
  "updated_at": "2025-12-26T17:34:24.151456",
  "symbols": {
    "enum_SseEvent_11": {
      "name": "SseEvent",
      "type": "enum",
      "start_line": 11,
      "end_line": 84,
      "content_hash": "fa2021b4635510391332da91fbf424f77f4b5ff4",
      "content": "pub enum SseEvent {\n    /// GitHub login: Contains user code and verification URI\n    UserVerification {\n        user_code: String,\n        verification_uri: String,\n    },\n\n    /// Successful authentication/operation\n    Success {\n        #[serde(flatten)]\n        data: serde_json::Value,\n    },\n\n    /// Device code timeout (5-minute window expired)\n    DeviceCodeTimeout { message: String },\n\n    /// Error event\n    Error { error: String },\n\n    /// Progress update with percentage\n    Progress {\n        percentage: f64,\n        message: Option<String>,\n    },\n\n    /// Log message from operation\n    Log {\n        message: String,\n        level: Option<String>,\n    },\n\n    /// Status transition (e.g., PENDING \u2192 PROVISIONING \u2192 READY)\n    StatusTransition {\n        from: Option<String>,\n        to: String,\n        message: Option<String>,\n    },\n\n    /// Cluster creation: Checkout required (Stripe)\n    CheckoutRequired { url: String },\n\n    /// Cluster creation: Payment confirmed\n    PaymentConfirmed,\n\n    /// Cluster creation: Creating project\n    CreatingProject,\n\n    /// Cluster creation: Project created successfully\n    ProjectCreated { cluster_id: String },\n\n    // Deploy events\n    /// Deploy: Validating queries\n    ValidatingQueries,\n\n    /// Deploy: Building with progress\n    Building { estimated_percentage: u16 },\n\n    /// Deploy: Deploying to infrastructure\n    Deploying,\n\n    /// Deploy: Successfully deployed (new instance)\n    Deployed { url: String, auth_key: String },\n\n    /// Deploy: Successfully redeployed (existing instance)\n    Redeployed { url: String },\n\n    /// Deploy: Bad request error\n    BadRequest { error: String },\n\n    /// Deploy: Query validation error\n    QueryValidationError { error: String },\n}\n\n/// SSE client for streaming events from Helix Cloud",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SseClient_85": {
      "name": "SseClient",
      "type": "struct",
      "start_line": 85,
      "end_line": 91,
      "content_hash": "978d1d98986fc97a1a96368883924c282c302ff5",
      "content": "pub struct SseClient {\n    url: String,\n    headers: Vec<(String, String)>,\n    timeout: Duration,\n    use_post: bool,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_SseClient_92": {
      "name": "SseClient",
      "type": "impl",
      "start_line": 92,
      "end_line": 93,
      "content_hash": "1a0129e6e71b95531af14daec6cc11b395445fa4",
      "content": "impl SseClient {\n    /// Create a new SSE client",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_94": {
      "name": "new",
      "type": "method",
      "start_line": 94,
      "end_line": 104,
      "content_hash": "3595b8f8e8b204499408d858a4d6907f4bad2d31",
      "content": "    pub fn new(url: String) -> Self {\n        Self {\n            url,\n            headers: Vec::new(),\n            timeout: Duration::from_secs(300), // 5 minutes default\n            use_post: false,\n        }\n    }\n\n    /// Add a header to the request\n    #[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_header_105": {
      "name": "header",
      "type": "method",
      "start_line": 105,
      "end_line": 111,
      "content_hash": "98223a1c5419b95935ba6140a5d431f27b3d4226",
      "content": "    pub fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n        self.headers.push((key.into(), value.into()));\n        self\n    }\n\n    /// Set the timeout duration\n    #[allow(dead_code)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_timeout_112": {
      "name": "timeout",
      "type": "method",
      "start_line": 112,
      "end_line": 117,
      "content_hash": "401de47f5b10ee358deb4c5a7af7f8320de3f6a1",
      "content": "    pub fn timeout(mut self, timeout: Duration) -> Self {\n        self.timeout = timeout;\n        self\n    }\n\n    /// Use POST method instead of GET",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_post_118": {
      "name": "post",
      "type": "method",
      "start_line": 118,
      "end_line": 168,
      "content_hash": "c080550f26f402ae428bfd2b92ee5558013529f0",
      "content": "    pub fn post(mut self) -> Self {\n        self.use_post = true;\n        self\n    }\n\n    /// Connect to SSE stream and process events\n    pub async fn connect<F>(&self, mut handler: F) -> Result<()>\n    where\n        F: FnMut(SseEvent) -> Result<bool>,\n    {\n        let client = reqwest::Client::builder().timeout(self.timeout).build()?;\n\n        let mut request = if self.use_post {\n            client.post(&self.url)\n        } else {\n            client.get(&self.url)\n        };\n        for (key, value) in &self.headers {\n            request = request.header(key, value);\n        }\n\n        let mut event_source = request.eventsource()?;\n\n        while let Some(event) = event_source.next().await {\n            match event {\n                Ok(Event::Open) => {\n                    // Connection opened\n                }\n                Ok(Event::Message(message)) => {\n                    // Parse the SSE event\n                    let sse_event: SseEvent = serde_json::from_str(&message.data)\n                        .map_err(|e| eyre!(\"Failed to parse SSE event: {}\", e))?;\n\n                    // Call handler - if it returns false, stop processing\n                    if !handler(sse_event)? {\n                        event_source.close();\n                        break;\n                    }\n                }\n                Err(err) => {\n                    event_source.close();\n                    return Err(eyre!(\"SSE stream error: {}\", err));\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// Progress bar handler for SSE events with real-time progress",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_SseProgressHandler_169": {
      "name": "SseProgressHandler",
      "type": "struct",
      "start_line": 169,
      "end_line": 172,
      "content_hash": "73b807cf8a91360849748434f0ad93a92a75c0de",
      "content": "pub struct SseProgressHandler {\n    progress_bar: ProgressBar,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_SseProgressHandler_173": {
      "name": "SseProgressHandler",
      "type": "impl",
      "start_line": 173,
      "end_line": 174,
      "content_hash": "e98969fa1e4e0a10c0d27f10864e77ae5559a311",
      "content": "impl SseProgressHandler {\n    /// Create a new progress handler with a message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_175": {
      "name": "new",
      "type": "method",
      "start_line": 175,
      "end_line": 188,
      "content_hash": "fd9e5ad148f0cd3db9621cc861d141d03b83b97b",
      "content": "    pub fn new(message: &str) -> Self {\n        let progress_bar = ProgressBar::new(100);\n        progress_bar.set_style(\n            ProgressStyle::default_bar()\n                .template(\"{msg}\\n{bar:40.cyan/blue} {pos}%\")\n                .expect(\"Invalid progress bar template\")\n                .progress_chars(\"=>-\"),\n        );\n        progress_bar.set_message(message.to_string());\n\n        Self { progress_bar }\n    }\n\n    /// Update progress percentage",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_progress_189": {
      "name": "set_progress",
      "type": "method",
      "start_line": 189,
      "end_line": 193,
      "content_hash": "b66fcf24ebad188d8a3957d8c35ee9bb421f4b0c",
      "content": "    pub fn set_progress(&self, percentage: f64) {\n        self.progress_bar.set_position(percentage as u64);\n    }\n\n    /// Update progress message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_set_message_194": {
      "name": "set_message",
      "type": "method",
      "start_line": 194,
      "end_line": 198,
      "content_hash": "f5fc222308a31057fd0f6cdb19cefb82307b6ad5",
      "content": "    pub fn set_message(&self, message: &str) {\n        self.progress_bar.set_message(message.to_string());\n    }\n\n    /// Print a log message below the progress bar",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_println_199": {
      "name": "println",
      "type": "method",
      "start_line": 199,
      "end_line": 203,
      "content_hash": "e32f0c0ccb17366d7e22e3860d9f4e9d7af95054",
      "content": "    pub fn println(&self, message: &str) {\n        self.progress_bar.println(message);\n    }\n\n    /// Finish the progress bar with a message",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_finish_204": {
      "name": "finish",
      "type": "method",
      "start_line": 204,
      "end_line": 208,
      "content_hash": "29314cfa8cf59aa428eb62ce968b4a126f313f57",
      "content": "    pub fn finish(&self, message: &str) {\n        self.progress_bar.finish_with_message(message.to_string());\n    }\n\n    /// Finish with error",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_finish_error_209": {
      "name": "finish_error",
      "type": "method",
      "start_line": 209,
      "end_line": 218,
      "content_hash": "a08c264085ade9f378d93f5293ec9414c7783863",
      "content": "    pub fn finish_error(&self, message: &str) {\n        self.progress_bar.abandon_with_message(message.to_string());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_sse_event_deserialization_219": {
      "name": "test_sse_event_deserialization",
      "type": "method",
      "start_line": 219,
      "end_line": 250,
      "content_hash": "d02d2a20280a6eb85cdc4bce6495f52392c789de",
      "content": "    fn test_sse_event_deserialization() {\n        // Test UserVerification (externally-tagged format with snake_case)\n        let json = r#\"{\n            \"user_verification\": {\n                \"user_code\": \"ABC-123\",\n                \"verification_uri\": \"https://github.com/login/device\"\n            }\n        }\"#;\n        let event: SseEvent = serde_json::from_str(json).unwrap();\n        match event {\n            SseEvent::UserVerification { user_code, .. } => {\n                assert_eq!(user_code, \"ABC-123\");\n            }\n            _ => panic!(\"Wrong event type\"),\n        }\n\n        // Test Progress (externally-tagged format with snake_case)\n        let json = r#\"{\n            \"progress\": {\n                \"percentage\": 45.5,\n                \"message\": \"Building...\"\n            }\n        }\"#;\n        let event: SseEvent = serde_json::from_str(json).unwrap();\n        match event {\n            SseEvent::Progress { percentage, .. } => {\n                assert_eq!(percentage, 45.5);\n            }\n            _ => panic!(\"Wrong event type\"),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}