{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/methods/exclude_validation.rs",
  "file_hash": "e68155aae3e59457e93cf62e319d8d0f89be3943",
  "updated_at": "2025-12-26T17:34:21.592365",
  "symbols": {
    "function_test_exclude_valid_field_145": {
      "name": "test_exclude_valid_field",
      "type": "function",
      "start_line": 145,
      "end_line": 163,
      "content_hash": "d038ecaceebb93a47fcaf6116661918d1faf96e7",
      "content": "    fn test_exclude_valid_field() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test() =>\n                people <- N<Person>::!{email}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_multiple_fields_164": {
      "name": "test_exclude_multiple_fields",
      "type": "function",
      "start_line": 164,
      "end_line": 182,
      "content_hash": "d4b72739c0ef7231d6bc5289a444c992844a4bb2",
      "content": "    fn test_exclude_multiple_fields() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String, phone: String }\n\n            QUERY test() =>\n                people <- N<Person>::!{email, phone}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_nonexistent_field_183": {
      "name": "test_exclude_nonexistent_field",
      "type": "function",
      "start_line": 183,
      "end_line": 201,
      "content_hash": "f2e89804acb354719b57921295cacd84f7d5d46d",
      "content": "    fn test_exclude_nonexistent_field() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n\n            QUERY test() =>\n                people <- N<Person>::!{nonexistent}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.iter().any(|d| d.error_code == ErrorCode::E202));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_on_edge_202": {
      "name": "test_exclude_on_edge",
      "type": "function",
      "start_line": 202,
      "end_line": 222,
      "content_hash": "95aa501cd10894fb3d0ab86ad582c31cefd5bffe",
      "content": "    fn test_exclude_on_edge() {\n        let source = r#\"\n            N::Person { name: String }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                person <- N<Person>(id)\n                edges <- person::OutE<Knows>::!{id}\n                RETURN edges\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_after_filter_223": {
      "name": "test_exclude_after_filter",
      "type": "function",
      "start_line": 223,
      "end_line": 241,
      "content_hash": "5f6038a8cb1b83d0c377b236187c69cd17e7dfab",
      "content": "    fn test_exclude_after_filter() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test(minAge: U32, maxAge: U32) =>\n                people <- N<Person>::WHERE(AND(_::{age}::GTE(minAge), _::{age}::LTE(maxAge)))::!{email}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_with_traversal_242": {
      "name": "test_exclude_with_traversal",
      "type": "function",
      "start_line": 242,
      "end_line": 261,
      "content_hash": "bfde8a6b49f82e2b94705dc3d8d57b73a22e2296",
      "content": "    fn test_exclude_with_traversal() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                friends <- N<Person>(id)::Out<Knows>::!{age}\n                RETURN friends\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_single_field_keeps_others_262": {
      "name": "test_exclude_single_field_keeps_others",
      "type": "function",
      "start_line": 262,
      "end_line": 280,
      "content_hash": "4d380f56bc00c0cf39134de89b318f83fdc6e5df",
      "content": "    fn test_exclude_single_field_keeps_others() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test() =>\n                people <- N<Person>::!{age}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_implicit_field_281": {
      "name": "test_exclude_implicit_field",
      "type": "function",
      "start_line": 281,
      "end_line": 299,
      "content_hash": "a7ccb8e385ecd182647667dfe2d38ffd1d86dcf8",
      "content": "    fn test_exclude_implicit_field() {\n        let source = r#\"\n            N::Person { name: String }\n\n            QUERY test() =>\n                people <- N<Person>::!{id}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_after_where_300": {
      "name": "test_exclude_after_where",
      "type": "function",
      "start_line": 300,
      "end_line": 318,
      "content_hash": "1c3b23b9169cb00393883931fdce57a0508b639b",
      "content": "    fn test_exclude_after_where() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test(minAge: U32) =>\n                people <- N<Person>::WHERE(_::{age}::GT(minAge))::!{email}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_on_nodes_collection_319": {
      "name": "test_exclude_on_nodes_collection",
      "type": "function",
      "start_line": 319,
      "end_line": 337,
      "content_hash": "4fed1da402d834a83135c677312c78efff8723fe",
      "content": "    fn test_exclude_on_nodes_collection() {\n        let source = r#\"\n            N::Person { name: String, age: U32, email: String }\n\n            QUERY test() =>\n                people <- N<Person>::!{email, age}\n                RETURN people\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_exclude_with_multi_hop_traversal_338": {
      "name": "test_exclude_with_multi_hop_traversal",
      "type": "function",
      "start_line": 338,
      "end_line": 358,
      "content_hash": "894e238ddefe37168c3c6c2c27ccbec17625f467",
      "content": "    fn test_exclude_with_multi_hop_traversal() {\n        let source = r#\"\n            N::Person { name: String, age: U32 }\n            N::Company { companyName: String }\n            E::WorksAt { From: Person, To: Company }\n            E::Knows { From: Person, To: Person }\n\n            QUERY test(id: ID) =>\n                colleagues <- N<Person>(id)::Out<WorksAt>::In<WorksAt>::!{age}\n                RETURN colleagues\n        \"#;\n\n        let content = write_to_temp_file(vec![source]);\n        let parsed = HelixParser::parse_source(&content).unwrap();\n        let result = crate::helixc::analyzer::analyze(&parsed);\n\n        assert!(result.is_ok());\n        let (diagnostics, _) = result.unwrap();\n        assert!(diagnostics.is_empty());\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}