{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/vector_distance.rs",
  "file_hash": "12c8944e4da96409ed74a1201323b9bdda95db4e",
  "updated_at": "2025-12-26T17:34:21.822269",
  "symbols": {
    "trait_DistanceCalc_7": {
      "name": "DistanceCalc",
      "type": "trait",
      "start_line": 7,
      "end_line": 7,
      "content_hash": "6cd1a1afefb2af0a3f697dc1ffb41f52010e3f32",
      "content": "pub trait DistanceCalc {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_distance_8": {
      "name": "distance",
      "type": "function",
      "start_line": 8,
      "end_line": 9,
      "content_hash": "7e2d8f671cc2e3b56e43c34cdb9afb7bb6da5cd0",
      "content": "    fn distance(from: &HVector, to: &HVector) -> Result<f64, VectorError>;\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DistanceCalc_10": {
      "name": "DistanceCalc",
      "type": "impl",
      "start_line": 10,
      "end_line": 19,
      "content_hash": "22e0753f829d00d5d3753ac0edbd69aded08fa5d",
      "content": "impl<'a> DistanceCalc for HVector<'a> {\n    /// Calculates the distance between two vectors.\n    ///\n    /// It normalizes the distance to be between 0 and 2.\n    ///\n    /// - 1.0 (most similar) \u2192 Distance 0.0 (closest)\n    /// - 0.0 (orthogonal) \u2192 Distance 1.0\n    /// - -1.0 (most dissimilar) \u2192 Distance 2.0 (furthest)\n    #[inline(always)]\n    #[cfg(feature = \"cosine\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_distance_20": {
      "name": "distance",
      "type": "method",
      "start_line": 20,
      "end_line": 26,
      "content_hash": "0142c520091a742f4c292bfbcd48655114a84e38",
      "content": "    fn distance(from: &HVector, to: &HVector) -> Result<f64, VectorError> {\n        cosine_similarity(from.data, to.data).map(|sim| 1.0 - sim)\n    }\n}\n\n#[inline]\n#[cfg(feature = \"cosine\")]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cosine_similarity_27": {
      "name": "cosine_similarity",
      "type": "method",
      "start_line": 27,
      "end_line": 90,
      "content_hash": "623b95851f272e2d68433b1bfdda010657995daa",
      "content": "pub fn cosine_similarity(from: &[f64], to: &[f64]) -> Result<f64, VectorError> {\n    let len = from.len();\n    let other_len = to.len();\n\n    if len != other_len {\n        println!(\"mis-match in vector dimensions!\\n{len} != {other_len}\");\n        return Err(VectorError::InvalidVectorLength);\n    }\n    //debug_assert_eq!(len, other.data.len(), \"Vectors must have the same length\");\n\n    #[cfg(target_feature = \"avx2\")]\n    {\n        return cosine_similarity_avx2(from, to);\n    }\n\n    let mut dot_product = 0.0;\n    let mut magnitude_a = 0.0;\n    let mut magnitude_b = 0.0;\n\n    const CHUNK_SIZE: usize = 8;\n    let chunks = len / CHUNK_SIZE;\n    let remainder = len % CHUNK_SIZE;\n\n    for i in 0..chunks {\n        let offset = i * CHUNK_SIZE;\n        let a_chunk = &from[offset..offset + CHUNK_SIZE];\n        let b_chunk = &to[offset..offset + CHUNK_SIZE];\n\n        let mut local_dot = 0.0;\n        let mut local_mag_a = 0.0;\n        let mut local_mag_b = 0.0;\n\n        for j in 0..CHUNK_SIZE {\n            let a_val = a_chunk[j];\n            let b_val = b_chunk[j];\n            local_dot += a_val * b_val;\n            local_mag_a += a_val * a_val;\n            local_mag_b += b_val * b_val;\n        }\n\n        dot_product += local_dot;\n        magnitude_a += local_mag_a;\n        magnitude_b += local_mag_b;\n    }\n\n    let remainder_offset = chunks * CHUNK_SIZE;\n    for i in 0..remainder {\n        let a_val = from[remainder_offset + i];\n        let b_val = to[remainder_offset + i];\n        dot_product += a_val * b_val;\n        magnitude_a += a_val * a_val;\n        magnitude_b += b_val * b_val;\n    }\n\n    if magnitude_a.abs() == 0.0 || magnitude_b.abs() == 0.0 {\n        return Ok(-1.0);\n    }\n\n    Ok(dot_product / (magnitude_a.sqrt() * magnitude_b.sqrt()))\n}\n\n// SIMD implementation using AVX2 (256-bit vectors)\n#[cfg(target_feature = \"avx2\")]\n#[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cosine_similarity_avx2_91": {
      "name": "cosine_similarity_avx2",
      "type": "method",
      "start_line": 91,
      "end_line": 157,
      "content_hash": "1a504cb5fcabe21b63c0a86784ee138d5b518861",
      "content": "pub fn cosine_similarity_avx2(a: &[f64], b: &[f64]) -> f64 {\n    use std::arch::x86_64::*;\n\n    let len = a.len();\n    let chunks = len / 4; // AVX2 processes 4 f64 values at once\n\n    unsafe {\n        let mut dot_product = _mm256_setzero_pd();\n        let mut magnitude_a = _mm256_setzero_pd();\n        let mut magnitude_b = _mm256_setzero_pd();\n\n        for i in 0..chunks {\n            let offset = i * 4;\n\n            // Load data - handle unaligned data\n            let a_chunk = _mm256_loadu_pd(&a[offset]);\n            let b_chunk = _mm256_loadu_pd(&b[offset]);\n\n            // Calculate dot product and magnitudes in parallel\n            dot_product = _mm256_add_pd(dot_product, _mm256_mul_pd(a_chunk, b_chunk));\n            magnitude_a = _mm256_add_pd(magnitude_a, _mm256_mul_pd(a_chunk, a_chunk));\n            magnitude_b = _mm256_add_pd(magnitude_b, _mm256_mul_pd(b_chunk, b_chunk));\n        }\n\n        // Horizontal sum of 4 doubles in each vector\n        let dot_sum = horizontal_sum_pd(dot_product);\n        let mag_a_sum = horizontal_sum_pd(magnitude_a);\n        let mag_b_sum = horizontal_sum_pd(magnitude_b);\n\n        // Handle remainder elements\n        let mut dot_remainder = 0.0;\n        let mut mag_a_remainder = 0.0;\n        let mut mag_b_remainder = 0.0;\n\n        let remainder_offset = chunks * 4;\n        for i in remainder_offset..len {\n            let a_val = a[i];\n            let b_val = b[i];\n            dot_remainder += a_val * b_val;\n            mag_a_remainder += a_val * a_val;\n            mag_b_remainder += b_val * b_val;\n        }\n\n        // Combine SIMD and scalar results\n        let dot_product_total = dot_sum + dot_remainder;\n        let magnitude_a_total = (mag_a_sum + mag_a_remainder).sqrt();\n        let magnitude_b_total = (mag_b_sum + mag_b_remainder).sqrt();\n\n        dot_product_total / (magnitude_a_total * magnitude_b_total)\n    }\n}\n\n// Helper function to sum the 4 doubles in an AVX2 vector\n#[cfg(target_feature = \"avx2\")]\n#[inline(always)]\nunsafe fn horizontal_sum_pd(__v: __m256d) -> f64 {\n    use std::arch::x86_64::*;\n\n    // Extract the high 128 bits and add to the low 128 bits\n    let sum_hi_lo = _mm_add_pd(_mm256_castpd256_pd128(__v), _mm256_extractf128_pd(__v, 1));\n\n    // Add the high 64 bits to the low 64 bits\n    let sum = _mm_add_sd(sum_hi_lo, _mm_unpackhi_pd(sum_hi_lo, sum_hi_lo));\n\n    // Extract the low 64 bits as a scalar\n    _mm_cvtsd_f64(sum)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}