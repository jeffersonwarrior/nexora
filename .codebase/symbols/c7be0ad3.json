{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/binary_heap.rs",
  "file_hash": "1d264f5fed35d4ec6b265310a3c6d947dcc067a6",
  "updated_at": "2025-12-26T17:34:24.526453",
  "symbols": {
    "struct_BinaryHeap_5": {
      "name": "BinaryHeap",
      "type": "struct",
      "start_line": 5,
      "end_line": 9,
      "content_hash": "bc99147eb7908b2d334a81f573015af24f717252",
      "content": "pub struct BinaryHeap<'arena, T> {\n    pub arena: &'arena bumpalo::Bump,\n    data: bumpalo::collections::Vec<'arena, T>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_BinaryHeap_10": {
      "name": "BinaryHeap",
      "type": "impl",
      "start_line": 10,
      "end_line": 10,
      "content_hash": "075b8641da23f0a10aa47180565b7b19deee4b43",
      "content": "impl<'arena, T: Ord> BinaryHeap<'arena, T> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_11": {
      "name": "new",
      "type": "method",
      "start_line": 11,
      "end_line": 17,
      "content_hash": "b37639c285151da9ea466353b684072dad64a8d8",
      "content": "    pub fn new(arena: &'arena bumpalo::Bump) -> BinaryHeap<'arena, T> {\n        BinaryHeap {\n            arena,\n            data: bumpalo::collections::Vec::with_capacity_in(0, arena),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_capacity_18": {
      "name": "with_capacity",
      "type": "method",
      "start_line": 18,
      "end_line": 33,
      "content_hash": "226b59cda96ac987075fbc8225adb070a57255a7",
      "content": "    pub fn with_capacity(arena: &'arena bumpalo::Bump, capacity: usize) -> BinaryHeap<'arena, T> {\n        BinaryHeap {\n            arena,\n            data: bumpalo::collections::Vec::with_capacity_in(capacity, arena),\n        }\n    }\n\n    #[inline]\n    pub fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        let guard = RebuildOnDrop {\n            rebuild_from: self.len(),\n            heap: self,\n        };\n        guard.heap.data.extend(iter);\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_pop_34": {
      "name": "pop",
      "type": "method",
      "start_line": 34,
      "end_line": 45,
      "content_hash": "5b5c5b66648560c286ac0e22aa36028feeb5a113",
      "content": "    pub fn pop(&mut self) -> Option<T> {\n        self.data.pop().map(|mut item| {\n            if !self.is_empty() {\n                swap(&mut item, &mut self.data[0]);\n                // SAFETY: !self.is_empty() means that self.len() > 0\n                unsafe { self.sift_down_to_bottom(0) };\n            }\n            item\n        })\n    }\n\n    #[must_use]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_peek_46": {
      "name": "peek",
      "type": "method",
      "start_line": 46,
      "end_line": 49,
      "content_hash": "fde551365e266595037970c6547153e4ae5fc395",
      "content": "    pub fn peek(&self) -> Option<&T> {\n        self.data.first()\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_50": {
      "name": "from",
      "type": "method",
      "start_line": 50,
      "end_line": 56,
      "content_hash": "30827887c4ba700b7626da933b491abd09a9aafa",
      "content": "    pub fn from(\n        arena: &'arena bumpalo::Bump,\n        data: bumpalo::collections::Vec<'arena, T>,\n    ) -> BinaryHeap<'arena, T> {\n        BinaryHeap { arena, data }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_push_57": {
      "name": "push",
      "type": "method",
      "start_line": 57,
      "end_line": 204,
      "content_hash": "17b54e2afbd9ea9dbea7dec2322c9fa25284993d",
      "content": "    pub fn push(&mut self, item: T) {\n        let old_len = self.len();\n        self.data.push(item);\n        // SAFETY: Since we pushed a new item it means that\n        //  old_len = self.len() - 1 < self.len()\n        unsafe { self.sift_up(0, old_len) };\n    }\n\n    // The implementations of sift_up and sift_down use unsafe blocks in\n    // order to move an element out of the vector (leaving behind a\n    // hole), shift along the others and move the removed element back into the\n    // vector at the final location of the hole.\n    // The `Hole` type is used to represent this, and make sure\n    // the hole is filled back at the end of its scope, even on panic.\n    // Using a hole reduces the constant factor compared to using swaps,\n    // which involves twice as many moves.\n\n    /// # Safety\n    ///\n    /// The caller must guarantee that `pos < self.len()`.\n    ///\n    /// Returns the new position of the element.\n    unsafe fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n        // Take out the value at `pos` and create a hole.\n        // SAFETY: The caller guarantees that pos < self.len()\n        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n\n        while hole.pos() > start {\n            let parent = (hole.pos() - 1) / 2;\n\n            // SAFETY: hole.pos() > start >= 0, which means hole.pos() > 0\n            //  and so hole.pos() - 1 can't underflow.\n            //  This guarantees that parent < hole.pos() so\n            //  it's a valid index and also != hole.pos().\n            if hole.element() <= unsafe { hole.get(parent) } {\n                break;\n            }\n\n            // SAFETY: Same as above\n            unsafe { hole.move_to(parent) };\n        }\n\n        hole.pos()\n    }\n\n    /// Take an element at `pos` and move it down the heap,\n    /// while its children are larger.\n    ///\n    /// Returns the new position of the element.\n    ///\n    /// # Safety\n    ///\n    /// The caller must guarantee that `pos < end <= self.len()`.\n    unsafe fn sift_down_range(&mut self, pos: usize, end: usize) -> usize {\n        // SAFETY: The caller guarantees that pos < end <= self.len().\n        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n        let mut child = 2 * hole.pos() + 1;\n\n        // Loop invariant: child == 2 * hole.pos() + 1.\n        while child <= end.saturating_sub(2) {\n            // compare with the greater of the two children\n            // SAFETY: child < end - 1 < self.len() and\n            //  child + 1 < end <= self.len(), so they're valid indexes.\n            //  child == 2 * hole.pos() + 1 != hole.pos() and\n            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n            //  if T is a ZST\n            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n\n            // if we are already in order, stop.\n            // SAFETY: child is now either the old child or the old child+1\n            //  We already proven that both are < self.len() and != hole.pos()\n            if hole.element() >= unsafe { hole.get(child) } {\n                return hole.pos();\n            }\n\n            // SAFETY: same as above.\n            unsafe { hole.move_to(child) };\n            child = 2 * hole.pos() + 1;\n        }\n\n        // SAFETY: && short circuit, which means that in the\n        //  second condition it's already true that child == end - 1 < self.len().\n        if child == end - 1 && hole.element() < unsafe { hole.get(child) } {\n            // SAFETY: child is already proven to be a valid index and\n            //  child == 2 * hole.pos() + 1 != hole.pos().\n            unsafe { hole.move_to(child) };\n        }\n\n        hole.pos()\n    }\n\n    /// # Safety\n    ///\n    /// The caller must guarantee that `pos < self.len()`.\n    unsafe fn sift_down(&mut self, pos: usize) -> usize {\n        let len = self.len();\n        // SAFETY: pos < len is guaranteed by the caller and\n        //  obviously len = self.len() <= self.len().\n        unsafe { self.sift_down_range(pos, len) }\n    }\n\n    /// Take an element at `pos` and move it all the way down the heap,\n    /// then sift it up to its position.\n    ///\n    /// Note: This is faster when the element is known to be large / should\n    /// be closer to the bottom.\n    ///\n    /// # Safety\n    ///\n    /// The caller must guarantee that `pos < self.len()`.\n    unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {\n        let end = self.len();\n        let start = pos;\n\n        // SAFETY: The caller guarantees that pos < self.len().\n        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n        let mut child = 2 * hole.pos() + 1;\n\n        // Loop invariant: child == 2 * hole.pos() + 1.\n        while child <= end.saturating_sub(2) {\n            // SAFETY: child < end - 1 < self.len() and\n            //  child + 1 < end <= self.len(), so they're valid indexes.\n            //  child == 2 * hole.pos() + 1 != hole.pos() and\n            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n            //  if T is a ZST\n            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n\n            // SAFETY: Same as above\n            unsafe { hole.move_to(child) };\n            child = 2 * hole.pos() + 1;\n        }\n\n        if child == end - 1 {\n            // SAFETY: child == end - 1 < self.len(), so it's a valid index\n            //  and child == 2 * hole.pos() + 1 != hole.pos().\n            unsafe { hole.move_to(child) };\n        }\n        pos = hole.pos();\n        drop(hole);\n\n        // SAFETY: pos is the position in the hole and was already proven\n        //  to be a valid index.\n        unsafe { self.sift_up(start, pos) };\n    }\n\n    /// Rebuild assuming data[0..start] is still a proper heap.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_rebuild_tail_205": {
      "name": "rebuild_tail",
      "type": "method",
      "start_line": 205,
      "end_line": 212,
      "content_hash": "0cf79ae76fc84739d810320f6d67c542c9316ef4",
      "content": "    fn rebuild_tail(&mut self, start: usize) {\n        if start == self.len() {\n            return;\n        }\n\n        let tail_len = self.len() - start;\n\n        #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_log2_fast_213": {
      "name": "log2_fast",
      "type": "method",
      "start_line": 213,
      "end_line": 240,
      "content_hash": "5e71ae0e950ba8d7641444cc5ff9e6d7e7fac669",
      "content": "        fn log2_fast(x: usize) -> usize {\n            (usize::BITS - x.leading_zeros() - 1) as usize\n        }\n\n        // `rebuild` takes O(self.len()) operations\n        // and about 2 * self.len() comparisons in the worst case\n        // while repeating `sift_up` takes O(tail_len * log(start)) operations\n        // and about 1 * tail_len * log_2(start) comparisons in the worst case,\n        // assuming start >= tail_len. For larger heaps, the crossover point\n        // no longer follows this reasoning and was determined empirically.\n        let better_to_rebuild = if start < tail_len {\n            true\n        } else if self.len() <= 2048 {\n            2 * self.len() < tail_len * log2_fast(start)\n        } else {\n            2 * self.len() < tail_len * 11\n        };\n\n        if better_to_rebuild {\n            self.rebuild();\n        } else {\n            for i in start..self.len() {\n                // SAFETY: The index `i` is always less than self.len().\n                unsafe { self.sift_up(0, i) };\n            }\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_rebuild_241": {
      "name": "rebuild",
      "type": "method",
      "start_line": 241,
      "end_line": 268,
      "content_hash": "3dd37874bfbf2760c8e58f3fd4433ae38485033a",
      "content": "    fn rebuild(&mut self) {\n        let mut n = self.len() / 2;\n        while n > 0 {\n            n -= 1;\n            // SAFETY: n starts from self.len() / 2 and goes down to 0.\n            //  The only case when !(n < self.len()) is if\n            //  self.len() == 0, but it's ruled out by the loop condition.\n            unsafe { self.sift_down(n) };\n        }\n    }\n\n    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    ///\n    /// let mut a = BinaryHeap::from([-10, 1, 2, 3, 3]);\n    /// let mut b = BinaryHeap::from([-20, 5, 43]);\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n    /// assert!(b.is_empty());\n    /// ```",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_append_269": {
      "name": "append",
      "type": "method",
      "start_line": 269,
      "end_line": 293,
      "content_hash": "1fb2ed9cd8d97702b04e7e198063083ff7fb1f38",
      "content": "    pub fn append(&mut self, other: &mut Self) {\n        if self.len() < other.len() {\n            swap(self, other);\n        }\n\n        let start = self.data.len();\n\n        self.data.append(&mut other.data);\n\n        self.rebuild_tail(start);\n    }\n\n    /// Returns the length of the binary heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from([1, 3]);\n    ///\n    /// assert_eq!(heap.len(), 2);\n    /// ```\n    #[must_use]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_len_294": {
      "name": "len",
      "type": "method",
      "start_line": 294,
      "end_line": 316,
      "content_hash": "d8b24a8f5ba549dc1e11dba5baa4162ef18d093b",
      "content": "    pub fn len(&self) -> usize {\n        self.data.len()\n    }\n\n    /// Checks if the binary heap is empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    ///\n    /// assert!(heap.is_empty());\n    ///\n    /// heap.push(3);\n    /// heap.push(5);\n    /// heap.push(1);\n    ///\n    /// assert!(!heap.is_empty());\n    /// ```\n    #[must_use]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_is_empty_317": {
      "name": "is_empty",
      "type": "method",
      "start_line": 317,
      "end_line": 344,
      "content_hash": "880293a7e06bcd66e48e51e6569d13d0fa482b5c",
      "content": "    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Clears the binary heap, returning an iterator over the removed elements\n    /// in arbitrary order. If the iterator is dropped before being fully\n    /// consumed, it drops the remaining elements in arbitrary order.\n    ///\n    /// The returned iterator keeps a mutable borrow on the heap to optimize\n    /// its implementation.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::from([1, 3]);\n    ///\n    /// assert!(!heap.is_empty());\n    ///\n    /// for x in heap.drain() {\n    ///     println!(\"{x}\");\n    /// }\n    ///\n    /// assert!(heap.is_empty());\n    /// ```\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drain_345": {
      "name": "drain",
      "type": "method",
      "start_line": 345,
      "end_line": 350,
      "content_hash": "15f4e3f4d918c8850b7c9f4051e9830d6a012063",
      "content": "    pub fn drain(&'arena mut self) -> Drain<'arena, 'arena, T> {\n        Drain {\n            iter: self.data.drain(..),\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_reserve_351": {
      "name": "reserve",
      "type": "method",
      "start_line": 351,
      "end_line": 354,
      "content_hash": "fbb6e3b7e117e04e4187db7bcc753e1bfca4da57",
      "content": "    pub fn reserve(&mut self, additional: usize) {\n        self.data.reserve(additional);\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_iter_355": {
      "name": "iter",
      "type": "method",
      "start_line": 355,
      "end_line": 365,
      "content_hash": "4ccb53015510c1b97135e46ce07122a256824498",
      "content": "    pub fn iter(&self) -> Iter<'_, T> {\n        Iter {\n            iter: self.data.iter(),\n        }\n    }\n}\n\n/// Hole represents a hole in a slice i.e., an index without valid value\n/// (because it was moved from or duplicated).\n/// In drop, `Hole` will restore the slice by filling the hole\n/// position with the value that was originally removed.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Hole_366": {
      "name": "Hole",
      "type": "struct",
      "start_line": 366,
      "end_line": 371,
      "content_hash": "f89e3cc8da7df7b65fad193f3264e47de7d6e1a2",
      "content": "struct Hole<'a, T: 'a> {\n    data: &'a mut [T],\n    elt: ManuallyDrop<T>,\n    pos: usize,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Hole_372": {
      "name": "Hole",
      "type": "impl",
      "start_line": 372,
      "end_line": 388,
      "content_hash": "79213efc01600b66088cbe4c106d3e76ddf27169",
      "content": "impl<'a, T> Hole<'a, T> {\n    /// Creates a new `Hole` at index `pos`.\n    ///\n    /// Unsafe because pos must be within the data slice.\n    #[inline]\n    unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n        debug_assert!(pos < data.len());\n        // SAFE: pos should be inside the slice\n        let elt = unsafe { ptr::read(data.get_unchecked(pos)) };\n        Hole {\n            data,\n            elt: ManuallyDrop::new(elt),\n            pos,\n        }\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_pos_389": {
      "name": "pos",
      "type": "method",
      "start_line": 389,
      "end_line": 394,
      "content_hash": "c68b9565881a468d9dc47f6b79763d54688c1d20",
      "content": "    fn pos(&self) -> usize {\n        self.pos\n    }\n\n    /// Returns a reference to the element removed.\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_element_395": {
      "name": "element",
      "type": "method",
      "start_line": 395,
      "end_line": 425,
      "content_hash": "53cc3151ec7170260593a88fc0e9a41c5d50c329",
      "content": "    fn element(&self) -> &T {\n        &self.elt\n    }\n\n    /// Returns a reference to the element at `index`.\n    ///\n    /// Unsafe because index must be within the data slice and not equal to pos.\n    #[inline]\n    unsafe fn get(&self, index: usize) -> &T {\n        debug_assert!(index != self.pos);\n        debug_assert!(index < self.data.len());\n        unsafe { self.data.get_unchecked(index) }\n    }\n\n    /// Move hole to new location\n    ///\n    /// Unsafe because index must be within the data slice and not equal to pos.\n    #[inline]\n    unsafe fn move_to(&mut self, index: usize) {\n        debug_assert!(index != self.pos);\n        debug_assert!(index < self.data.len());\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            let index_ptr: *const _ = ptr.add(index);\n            let hole_ptr = ptr.add(self.pos);\n            ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n        }\n        self.pos = index;\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Drop_426": {
      "name": "Drop",
      "type": "impl",
      "start_line": 426,
      "end_line": 427,
      "content_hash": "e37e8b417c66bc1376b8747981c930091312f4c2",
      "content": "impl<T> Drop for Hole<'_, T> {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_428": {
      "name": "drop",
      "type": "method",
      "start_line": 428,
      "end_line": 437,
      "content_hash": "05645acc62f12e8fc4ccf3648bdba319847bf463",
      "content": "    fn drop(&mut self) {\n        // fill the hole again\n        unsafe {\n            let pos = self.pos;\n            ptr::copy_nonoverlapping(&*self.elt, self.data.get_unchecked_mut(pos), 1);\n        }\n    }\n}\n\n#[derive(Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Drain_438": {
      "name": "Drain",
      "type": "struct",
      "start_line": 438,
      "end_line": 441,
      "content_hash": "2ef9c8e3c5def528de5ef99e45c4e2aa0fb91a20",
      "content": "pub struct Drain<'a, 'arena, T: 'a> {\n    iter: bumpalo::collections::vec::Drain<'a, 'arena, T>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_442": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 442,
      "end_line": 445,
      "content_hash": "cd659b7d9a1df9a5403ce31d66fe71a0adcc9963",
      "content": "impl<'arena, T> Iterator for Drain<'_, 'arena, T> {\n    type Item = T;\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_446": {
      "name": "next",
      "type": "method",
      "start_line": 446,
      "end_line": 450,
      "content_hash": "b7b54dfe202acd00f90897eeb785e1c90182a4b1",
      "content": "    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_size_hint_451": {
      "name": "size_hint",
      "type": "method",
      "start_line": 451,
      "end_line": 455,
      "content_hash": "d2591e3af9208b9e3110a05989eb406041ff998d",
      "content": "    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DoubleEndedIterator_456": {
      "name": "DoubleEndedIterator",
      "type": "impl",
      "start_line": 456,
      "end_line": 457,
      "content_hash": "5d4cefc586177570d71b5c1597e9dfbee5975927",
      "content": "impl<'arena, T> DoubleEndedIterator for Drain<'_, 'arena, T> {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_back_458": {
      "name": "next_back",
      "type": "method",
      "start_line": 458,
      "end_line": 462,
      "content_hash": "11921cf646e14a830e6edddecc467cf693b7b02e",
      "content": "    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FusedIterator_463": {
      "name": "FusedIterator",
      "type": "impl",
      "start_line": 463,
      "end_line": 464,
      "content_hash": "1c3df11c1610788574f8870d59075dcb4ac15db6",
      "content": "impl<'arena, T> FusedIterator for Drain<'_, 'arena, T> {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Iter_465": {
      "name": "Iter",
      "type": "struct",
      "start_line": 465,
      "end_line": 468,
      "content_hash": "ab2c4fff22b727190e34541806415884a2b2544a",
      "content": "pub struct Iter<'a, T: 'a> {\n    iter: slice::Iter<'a, T>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_469": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 469,
      "end_line": 472,
      "content_hash": "98d3ba8ee0ee9a4aacafd79564d6ffa54c85ba02",
      "content": "impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_473": {
      "name": "next",
      "type": "method",
      "start_line": 473,
      "end_line": 477,
      "content_hash": "bde0ac570dad543933ddd3a6122b1ccfa6482e77",
      "content": "    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_size_hint_478": {
      "name": "size_hint",
      "type": "method",
      "start_line": 478,
      "end_line": 482,
      "content_hash": "2e917151d5447e12b45ac63954039adbd2716ae7",
      "content": "    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_last_483": {
      "name": "last",
      "type": "method",
      "start_line": 483,
      "end_line": 487,
      "content_hash": "3549a7fc9174de0db76f40989e1d10e7138ef92a",
      "content": "    fn last(self) -> Option<&'a T> {\n        self.iter.last()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DoubleEndedIterator_488": {
      "name": "DoubleEndedIterator",
      "type": "impl",
      "start_line": 488,
      "end_line": 489,
      "content_hash": "efe4d2b2ba4da2d2c406a6386a32e6aab72a7bf1",
      "content": "impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_back_490": {
      "name": "next_back",
      "type": "method",
      "start_line": 490,
      "end_line": 493,
      "content_hash": "8073ab17dc72d4a834331f771e08f78da8f8973a",
      "content": "    fn next_back(&mut self) -> Option<&'a T> {\n        self.iter.next_back()\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FusedIterator_494": {
      "name": "FusedIterator",
      "type": "impl",
      "start_line": 494,
      "end_line": 495,
      "content_hash": "5563495a632b54120e9bb3f3768ccb855cfe69fd",
      "content": "impl<T> FusedIterator for Iter<'_, T> {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_RebuildOnDrop_496": {
      "name": "RebuildOnDrop",
      "type": "struct",
      "start_line": 496,
      "end_line": 500,
      "content_hash": "537a9514e0ad6fec6195642500d30856fc34a91f",
      "content": "struct RebuildOnDrop<'a, 'arena, T: Ord> {\n    heap: &'a mut BinaryHeap<'arena, T>,\n    rebuild_from: usize,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Drop_501": {
      "name": "Drop",
      "type": "impl",
      "start_line": 501,
      "end_line": 501,
      "content_hash": "1618abc9a521bec2f2b904621c5482e9ee323513",
      "content": "impl<'arena, T: Ord> Drop for RebuildOnDrop<'_, 'arena, T> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_drop_502": {
      "name": "drop",
      "type": "method",
      "start_line": 502,
      "end_line": 512,
      "content_hash": "fcd54d44c83c77f4be892b05cd4ed33caa961a16",
      "content": "    fn drop(&mut self) {\n        self.heap.rebuild_tail(self.rebuild_from);\n    }\n}\n\n/// An owning iterator over the elements of a `BinaryHeap`.\n///\n/// This `struct` is created by [`BinaryHeap::into_iter()`]\n/// (provided by the [`IntoIterator`] trait). See its documentation for more.\n///\n/// [`into_iter`]: BinaryHeap::into_iter",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IntoIter_513": {
      "name": "IntoIter",
      "type": "struct",
      "start_line": 513,
      "end_line": 516,
      "content_hash": "ae3a6b15a050d29a5209c4c9787109614ef20682",
      "content": "pub struct IntoIter<'arena, T> {\n    iter: bumpalo::collections::vec::IntoIter<'arena, T>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_517": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 517,
      "end_line": 520,
      "content_hash": "b5ab37c4d7ad311cf2812fc7458c4e190f44de02",
      "content": "impl<'arena, T> Iterator for IntoIter<'arena, T> {\n    type Item = T;\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_521": {
      "name": "next",
      "type": "method",
      "start_line": 521,
      "end_line": 525,
      "content_hash": "b7b54dfe202acd00f90897eeb785e1c90182a4b1",
      "content": "    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_size_hint_526": {
      "name": "size_hint",
      "type": "method",
      "start_line": 526,
      "end_line": 530,
      "content_hash": "d2591e3af9208b9e3110a05989eb406041ff998d",
      "content": "    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_DoubleEndedIterator_531": {
      "name": "DoubleEndedIterator",
      "type": "impl",
      "start_line": 531,
      "end_line": 532,
      "content_hash": "ebf1cbe1c16ec412abd7c4495575d171ee680a05",
      "content": "impl<'arena, T> DoubleEndedIterator for IntoIter<'arena, T> {\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_next_back_533": {
      "name": "next_back",
      "type": "method",
      "start_line": 533,
      "end_line": 537,
      "content_hash": "11921cf646e14a830e6edddecc467cf693b7b02e",
      "content": "    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_FusedIterator_538": {
      "name": "FusedIterator",
      "type": "impl",
      "start_line": 538,
      "end_line": 539,
      "content_hash": "78cea3abd97aeb2d787733287c4414a925410c16",
      "content": "impl<T> FusedIterator for IntoIter<'_, T> {}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_IntoIterator_540": {
      "name": "IntoIterator",
      "type": "impl",
      "start_line": 540,
      "end_line": 561,
      "content_hash": "0a77aaa23ecc6c94c9f52c85f94f727561326a49",
      "content": "impl<'arena, T> IntoIterator for BinaryHeap<'arena, T> {\n    type Item = T;\n    type IntoIter = IntoIter<'arena, T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the binary heap in arbitrary order. The binary heap cannot be used\n    /// after calling this.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from([1, 2, 3, 4]);\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order\n    /// for x in heap.into_iter() {\n    ///     // x has type i32, not &i32\n    ///     println!(\"{x}\");\n    /// }\n    /// ```",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_into_iter_562": {
      "name": "into_iter",
      "type": "method",
      "start_line": 562,
      "end_line": 567,
      "content_hash": "c1bf7419d26897deb27eea257c7de35a474a5e41",
      "content": "    fn into_iter(self) -> IntoIter<'arena, T> {\n        IntoIter {\n            iter: self.data.into_iter(),\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}