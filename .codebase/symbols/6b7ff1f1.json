{
  "file_path": "/work/.local/tools/modelscan/sdk/router/router_test.go",
  "file_hash": "c4e6653ec272fedecc8d49566c2b8cb17458a486",
  "updated_at": "2025-12-26T17:34:24.432198",
  "symbols": {
    "function_setupRouterTest_12": {
      "name": "setupRouterTest",
      "type": "function",
      "start_line": 12,
      "end_line": 30,
      "content_hash": "d584fc7be588e06b8d4a47eb55c3762c38aa8511",
      "content": "func setupRouterTest(t *testing.T) string {\n\tdbPath := \"/tmp/test_router_\" + t.Name() + \".db\"\n\tos.Remove(dbPath)\n\n\tif err := storage.InitRateLimitDB(dbPath); err != nil {\n\t\tt.Fatalf(\"Failed to init test DB: %v\", err)\n\t}\n\n\t// Seed test data\n\tif err := scraper.SeedInitialRateLimits(); err != nil {\n\t\tt.Fatalf(\"Failed to seed rate limits: %v\", err)\n\t}\n\tif err := scraper.SeedInitialPricing(); err != nil {\n\t\tt.Fatalf(\"Failed to seed pricing: %v\", err)\n\t}\n\n\treturn dbPath\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_teardownRouterTest_31": {
      "name": "teardownRouterTest",
      "type": "function",
      "start_line": 31,
      "end_line": 35,
      "content_hash": "c1a3165044e872e12eaab6c10f1a4883468f239c",
      "content": "func teardownRouterTest(t *testing.T, dbPath string) {\n\tstorage.CloseRateLimitDB()\n\tos.Remove(dbPath)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestNewRouter_CreatesWithStrategy_36": {
      "name": "TestNewRouter_CreatesWithStrategy",
      "type": "function",
      "start_line": 36,
      "end_line": 45,
      "content_hash": "64a173cfc8757aeac98962ee396468f9bb37c12d",
      "content": "func TestNewRouter_CreatesWithStrategy(t *testing.T) {\n\trouter := NewRouter(StrategyCheapest)\n\tif router.strategy != StrategyCheapest {\n\t\tt.Errorf(\"Expected strategy cheapest, got %s\", router.strategy)\n\t}\n\tif router.healthTracker == nil {\n\t\tt.Error(\"Health tracker not initialized\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_SelectsCheapestProvider_46": {
      "name": "TestRouter_SelectsCheapestProvider",
      "type": "function",
      "start_line": 46,
      "end_line": 77,
      "content_hash": "a9511e7a4a014ed9899af0690831add3d9c592ac",
      "content": "func TestRouter_SelectsCheapestProvider(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\tctx := context.Background()\n\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err != nil {\n\t\tt.Fatalf(\"Route failed: %v\", err)\n\t}\n\n\t// DeepSeek should be cheapest at $0.14-$0.28 per 1M tokens\n\tif result.Provider.ProviderName != \"deepseek\" && result.Provider.ProviderName != \"cerebras\" {\n\t\tt.Logf(\"Selected: %s at $%.6f\", result.Provider.ProviderName, result.EstimatedCost)\n\t\t// Note: Cerebras is FREE so it might win\n\t}\n\n\tif result.EstimatedCost < 0 {\n\t\tt.Errorf(\"Invalid estimated cost: $%.6f\", result.EstimatedCost)\n\t}\n\n\tif len(result.Alternatives) == 0 {\n\t\tt.Error(\"No alternatives provided\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_SelectsFastestProvider_78": {
      "name": "TestRouter_SelectsFastestProvider",
      "type": "function",
      "start_line": 78,
      "end_line": 104,
      "content_hash": "480e4081907dabcbd73c19a99858bb5e15bbb399",
      "content": "func TestRouter_SelectsFastestProvider(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyFastest)\n\n\t// Simulate latency data\n\trouter.RecordSuccess(\"groq\", 50)      // Very fast (LPU hardware)\n\trouter.RecordSuccess(\"openai\", 200)   // Standard\n\trouter.RecordSuccess(\"deepseek\", 400) // Slower (China-hosted)\n\n\tctx := context.Background()\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err != nil {\n\t\tt.Fatalf(\"Route failed: %v\", err)\n\t}\n\n\tif result.Provider.ProviderName == \"groq\" && result.Provider.AvgLatencyMs > 100 {\n\t\tt.Errorf(\"Expected fastest provider with low latency, got %dms\", result.Provider.AvgLatencyMs)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_RespectsMaxCost_105": {
      "name": "TestRouter_RespectsMaxCost",
      "type": "function",
      "start_line": 105,
      "end_line": 131,
      "content_hash": "61aa6a538b9691d67a356fe29559167b0067cec8",
      "content": "func TestRouter_RespectsMaxCost(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\tctx := context.Background()\n\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t\tMaxCost:         0.00001, // Very tight budget - should exclude expensive providers\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err != nil {\n\t\t// May fail if no providers meet budget\n\t\tif result == nil {\n\t\t\treturn // Expected\n\t\t}\n\t\tt.Fatalf(\"Route failed: %v\", err)\n\t}\n\n\tif result.EstimatedCost > req.MaxCost {\n\t\tt.Errorf(\"Selected provider exceeds budget: $%.6f > $%.6f\", result.EstimatedCost, req.MaxCost)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_ExcludesProviders_132": {
      "name": "TestRouter_ExcludesProviders",
      "type": "function",
      "start_line": 132,
      "end_line": 154,
      "content_hash": "7d6d46dd89032db5706f063ae4709eb99520fcc5",
      "content": "func TestRouter_ExcludesProviders(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\tctx := context.Background()\n\n\treq := RouteRequest{\n\t\tCapability:       \"chat\",\n\t\tEstimatedTokens:  1000,\n\t\tExcludeProviders: []string{\"openai\", \"anthropic\"},\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err != nil {\n\t\tt.Fatalf(\"Route failed: %v\", err)\n\t}\n\n\tif result.Provider.ProviderName == \"openai\" || result.Provider.ProviderName == \"anthropic\" {\n\t\tt.Errorf(\"Selected excluded provider: %s\", result.Provider.ProviderName)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_HealthTracking_MarksUnhealthy_155": {
      "name": "TestRouter_HealthTracking_MarksUnhealthy",
      "type": "function",
      "start_line": 155,
      "end_line": 174,
      "content_hash": "753b76a18815e2c46b42ab7a3a4a2ba150b120dd",
      "content": "func TestRouter_HealthTracking_MarksUnhealthy(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\t// Record 3 consecutive failures\n\trouter.RecordFailure(\"openai\", nil)\n\trouter.RecordFailure(\"openai\", nil)\n\trouter.RecordFailure(\"openai\", nil)\n\n\thealth := router.getHealth(\"openai\")\n\tif health.IsHealthy {\n\t\tt.Error(\"Provider should be marked unhealthy after 3 failures\")\n\t}\n\tif health.ConsecutiveFails != 3 {\n\t\tt.Errorf(\"Expected 3 consecutive fails, got %d\", health.ConsecutiveFails)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_HealthTracking_RecoverAfterSuccess_175": {
      "name": "TestRouter_HealthTracking_RecoverAfterSuccess",
      "type": "function",
      "start_line": 175,
      "end_line": 197,
      "content_hash": "5b76a06906b35463bdd173cc748c1578876e520d",
      "content": "func TestRouter_HealthTracking_RecoverAfterSuccess(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\t// Record failures\n\trouter.RecordFailure(\"openai\", nil)\n\trouter.RecordFailure(\"openai\", nil)\n\trouter.RecordFailure(\"openai\", nil)\n\n\t// Then success\n\trouter.RecordSuccess(\"openai\", 150)\n\n\thealth := router.getHealth(\"openai\")\n\tif !health.IsHealthy {\n\t\tt.Error(\"Provider should recover after success\")\n\t}\n\tif health.ConsecutiveFails != 0 {\n\t\tt.Errorf(\"Consecutive fails should reset to 0, got %d\", health.ConsecutiveFails)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_LatencyTracking_ExponentialMovingAverage_198": {
      "name": "TestRouter_LatencyTracking_ExponentialMovingAverage",
      "type": "function",
      "start_line": 198,
      "end_line": 218,
      "content_hash": "d3c663b01be69ff98e0670f2a1f5072e497f7653",
      "content": "func TestRouter_LatencyTracking_ExponentialMovingAverage(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\t// Initial latency\n\trouter.RecordSuccess(\"openai\", 100)\n\thealth := router.getHealth(\"openai\")\n\tif health.AvgLatencyMs != 100 {\n\t\tt.Errorf(\"Expected initial latency 100ms, got %dms\", health.AvgLatencyMs)\n\t}\n\n\t// Record higher latency (should average out)\n\trouter.RecordSuccess(\"openai\", 200)\n\thealth = router.getHealth(\"openai\")\n\tif health.AvgLatencyMs < 100 || health.AvgLatencyMs > 200 {\n\t\tt.Errorf(\"Expected averaged latency between 100-200ms, got %dms\", health.AvgLatencyMs)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_RoundRobin_CyclesThroughProviders_219": {
      "name": "TestRouter_RoundRobin_CyclesThroughProviders",
      "type": "function",
      "start_line": 219,
      "end_line": 246,
      "content_hash": "3f89c0e3033148bb6dedd8458ee4e35686287bf4",
      "content": "func TestRouter_RoundRobin_CyclesThroughProviders(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyRoundRobin)\n\tctx := context.Background()\n\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t}\n\n\t// Make multiple routing decisions\n\tseen := make(map[string]int)\n\tfor i := 0; i < 10; i++ {\n\t\tresult, err := router.Route(ctx, req)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tseen[result.Provider.ProviderName]++\n\t}\n\n\t// Should see multiple different providers\n\tif len(seen) < 2 {\n\t\tt.Errorf(\"Round-robin should cycle through providers, only saw: %v\", seen)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_Balanced_ScoresCostAndLatency_247": {
      "name": "TestRouter_Balanced_ScoresCostAndLatency",
      "type": "function",
      "start_line": 247,
      "end_line": 274,
      "content_hash": "42bf626a69bce13c168c12f968b8485ed11c52d7",
      "content": "func TestRouter_Balanced_ScoresCostAndLatency(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyBalanced)\n\n\t// Set up contrasting scenarios\n\trouter.RecordSuccess(\"groq\", 50)      // Fast but not cheapest\n\trouter.RecordSuccess(\"deepseek\", 400) // Cheap but slower\n\n\tctx := context.Background()\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err != nil {\n\t\tt.Fatalf(\"Route failed: %v\", err)\n\t}\n\n\t// Should balance between cost and speed\n\tif result.Reason == \"\" {\n\t\tt.Error(\"No reason provided for balanced selection\")\n\t}\n\tt.Logf(\"Selected: %s - %s\", result.Provider.ProviderName, result.Reason)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_NoProvidersAvailable_ReturnsError_275": {
      "name": "TestRouter_NoProvidersAvailable_ReturnsError",
      "type": "function",
      "start_line": 275,
      "end_line": 293,
      "content_hash": "95201301554b9e06062f6bb4567074bd01fb783c",
      "content": "func TestRouter_NoProvidersAvailable_ReturnsError(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\tctx := context.Background()\n\n\treq := RouteRequest{\n\t\tCapability:      \"chat\",\n\t\tEstimatedTokens: 1000,\n\t\tMaxCost:         0.0000000001, // Impossibly low budget\n\t}\n\n\tresult, err := router.Route(ctx, req)\n\tif err == nil {\n\t\tt.Errorf(\"Should fail with impossibly low budget, got result: %+v\", result)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_Fallback_SelectsPrimaryFirst_294": {
      "name": "TestRouter_Fallback_SelectsPrimaryFirst",
      "type": "function",
      "start_line": 294,
      "end_line": 311,
      "content_hash": "971be1e9f1c9dfbf0e44ca355f7313e0e9979003",
      "content": "func TestRouter_Fallback_SelectsPrimaryFirst(t *testing.T) {\n\tproviders := []*ProviderOption{\n\t\t{ProviderName: \"primary\", Health: &ProviderHealth{IsHealthy: true}},\n\t\t{ProviderName: \"fallback1\", Health: &ProviderHealth{IsHealthy: true}},\n\t\t{ProviderName: \"fallback2\", Health: &ProviderHealth{IsHealthy: true}},\n\t}\n\n\trouter := NewRouter(StrategyFallback)\n\tselected, reason := router.selectFallback(providers)\n\n\tif selected.ProviderName != \"primary\" {\n\t\tt.Errorf(\"Should select primary when healthy, got %s\", selected.ProviderName)\n\t}\n\tif reason != \"primary\" {\n\t\tt.Errorf(\"Expected reason 'primary', got '%s'\", reason)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_Fallback_UsesBackupWhenPrimaryUnhealthy_312": {
      "name": "TestRouter_Fallback_UsesBackupWhenPrimaryUnhealthy",
      "type": "function",
      "start_line": 312,
      "end_line": 329,
      "content_hash": "cf1e4e5fa4b5785e6c0007f1fcaccaa471d291c0",
      "content": "func TestRouter_Fallback_UsesBackupWhenPrimaryUnhealthy(t *testing.T) {\n\tproviders := []*ProviderOption{\n\t\t{ProviderName: \"primary\", Health: &ProviderHealth{IsHealthy: false}},\n\t\t{ProviderName: \"fallback1\", Health: &ProviderHealth{IsHealthy: true}},\n\t\t{ProviderName: \"fallback2\", Health: &ProviderHealth{IsHealthy: true}},\n\t}\n\n\trouter := NewRouter(StrategyFallback)\n\tselected, reason := router.selectFallback(providers)\n\n\tif selected.ProviderName != \"fallback1\" {\n\t\tt.Errorf(\"Should select first healthy fallback, got %s\", selected.ProviderName)\n\t}\n\tif reason != \"fallback #1\" {\n\t\tt.Errorf(\"Expected reason 'fallback #1', got '%s'\", reason)\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestProviderHealth_ThreadSafety_330": {
      "name": "TestProviderHealth_ThreadSafety",
      "type": "function",
      "start_line": 330,
      "end_line": 360,
      "content_hash": "0f51e08c5a80304d3d55b28417fea405db58a6ba",
      "content": "func TestProviderHealth_ThreadSafety(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\t// Concurrent updates\n\tdone := make(chan bool, 20)\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\trouter.RecordSuccess(\"openai\", 100)\n\t\t\tdone <- true\n\t\t}()\n\t\tgo func() {\n\t\t\trouter.RecordFailure(\"openai\", nil)\n\t\t\tdone <- true\n\t\t}()\n\t}\n\n\t// Wait for all goroutines\n\tfor i := 0; i < 20; i++ {\n\t\t<-done\n\t}\n\n\t// Should not panic and have valid state\n\thealth := router.getHealth(\"openai\")\n\tif health == nil {\n\t\tt.Error(\"Health tracker corrupted by concurrent access\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_GetHealthStatus_ReturnsAllProviders_361": {
      "name": "TestRouter_GetHealthStatus_ReturnsAllProviders",
      "type": "function",
      "start_line": 361,
      "end_line": 380,
      "content_hash": "9070f489597330142d2e2829a46a22f164ff719a",
      "content": "func TestRouter_GetHealthStatus_ReturnsAllProviders(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\trouter.RecordSuccess(\"openai\", 100)\n\trouter.RecordSuccess(\"anthropic\", 150)\n\trouter.RecordSuccess(\"deepseek\", 400)\n\n\tstatus := router.GetHealthStatus()\n\tif len(status) != 3 {\n\t\tt.Errorf(\"Expected 3 providers in health status, got %d\", len(status))\n\t}\n\n\tif status[\"openai\"] == nil || status[\"anthropic\"] == nil || status[\"deepseek\"] == nil {\n\t\tt.Error(\"Missing providers in health status\")\n\t}\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestRouter_MatchesModel_381": {
      "name": "TestRouter_MatchesModel",
      "type": "function",
      "start_line": 381,
      "end_line": 407,
      "content_hash": "16217bb84d83fb2a799bbe1a9bfcb1fc13d7f7d6",
      "content": "func TestRouter_MatchesModel(t *testing.T) {\n\tdbPath := setupRouterTest(t)\n\tdefer teardownRouterTest(t, dbPath)\n\n\trouter := NewRouter(StrategyCheapest)\n\n\ttests := []struct {\n\t\tname           string\n\t\tmodelID        string\n\t\trequiredModels []string\n\t\texpected       bool\n\t}{\n\t\t{\"exact match\", \"gpt-4\", []string{\"gpt-4\", \"gpt-3.5\"}, true},\n\t\t{\"no match\", \"claude-2\", []string{\"gpt-4\", \"gpt-3.5\"}, false},\n\t\t{\"empty required\", \"gpt-4\", []string{}, false},\n\t\t{\"single match\", \"gpt-4\", []string{\"gpt-4\"}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := router.matchesModel(tt.modelID, tt.requiredModels)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"matchesModel(%q, %v) = %v, want %v\", tt.modelID, tt.requiredModels, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}