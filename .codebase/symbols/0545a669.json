{
  "file_path": "/work/external-deps/claude-swarm/dist/workers/manager.js",
  "file_hash": "cce3a1c5c7aedfa9edc951b6cf92d4e051d3e9f9",
  "updated_at": "2025-12-26T17:34:25.111578",
  "symbols": {
    "function_getWorkerFlags_38": {
      "name": "getWorkerFlags",
      "type": "function",
      "start_line": 38,
      "end_line": 59,
      "content_hash": "3e127bef532a29464c9c48fcb6df2bdeb6ef1195",
      "content": "function getWorkerFlags() {\n    const allowedTools = process.env.CLAUDE_SWARM_ALLOWED_TOOLS || DEFAULT_WORKER_TOOLS;\n    const permissionMode = process.env.CLAUDE_SWARM_PERMISSION_MODE || \"bypassPermissions\";\n    const mcpServersJson = process.env.CLAUDE_SWARM_MCP_SERVERS || \"{}\";\n    // Parse MCP servers (validate JSON)\n    let mcpServers = {};\n    try {\n        mcpServers = JSON.parse(mcpServersJson);\n    }\n    catch {\n        // Invalid JSON, use empty\n    }\n    const flags = [];\n    // Explicitly allow specific tools (bypasses permission prompts for these)\n    flags.push(`--allowedTools \"${allowedTools}\"`);\n    // Set permission mode (bypassPermissions for headless workers)\n    flags.push(`--permission-mode ${permissionMode}`);\n    // Use inline MCP config with specified servers (empty by default)\n    const mcpConfig = JSON.stringify({ mcpServers });\n    flags.push(`--mcp-config '${mcpConfig}'`);\n    return flags.join(\" \");\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "class_WorkerManager_60": {
      "name": "WorkerManager",
      "type": "class",
      "start_line": 60,
      "end_line": 981,
      "content_hash": "1096457a3206ee4d4af68f7791a3186111f14853",
      "content": "export class WorkerManager {\n    projectDir;\n    stateManager;\n    workerDir;\n    monitorInterval = null;\n    completionCallbacks = [];\n    lastKnownStatus = new Map();\n    constructor(projectDir, stateManager) {\n        this.projectDir = projectDir;\n        this.stateManager = stateManager;\n        // Directory for worker status files\n        this.workerDir = path.join(projectDir, \".claude\", \"orchestrator\", \"workers\");\n        if (!fs.existsSync(this.workerDir)) {\n            fs.mkdirSync(this.workerDir, { recursive: true });\n        }\n    }\n    /**\n     * Generate a unique session name for a worker\n     */\n    generateSessionName(featureId) {\n        // Validate feature ID first\n        validateFeatureId(featureId);\n        const timestamp = Date.now().toString(36);\n        return `cc-worker-${featureId}-${timestamp}`;\n    }\n    /**\n     * Extract feature ID from session name\n     */\n    extractFeatureId(sessionName) {\n        const match = sessionName.match(/^cc-worker-(.+?)-[a-z0-9]+$/);\n        return match ? match[1] : null;\n    }\n    /**\n     * Read project context files (CLAUDE.md, .clauderc, etc.)\n     * Returns combined content or empty string if none found\n     */\n    readProjectContext() {\n        const contextFiles = [\n            \"CLAUDE.md\",\n            \".claude/CLAUDE.md\",\n            \".clauderc\",\n            \".claude/settings.json\",\n        ];\n        const contents = [];\n        for (const file of contextFiles) {\n            const filePath = path.join(this.projectDir, file);\n            if (fs.existsSync(filePath)) {\n                try {\n                    const content = fs.readFileSync(filePath, \"utf-8\");\n                    // Limit each file to 4000 chars to prevent prompt bloat\n                    const truncated = content.length > 4000\n                        ? content.substring(0, 4000) + \"\\n... (truncated)\"\n                        : content;\n                    contents.push(`### From ${file}:\\n${truncated}`);\n                }\n                catch {\n                    // Skip unreadable files silently\n                }\n            }\n        }\n        return contents.length > 0\n            ? `\\n## Project Context Files\\n${contents.join(\"\\n\\n\")}\\n`\n            : \"\";\n    }\n    /**\n     * Build the prompt for a worker\n     */\n    buildWorkerPrompt(feature, customPrompt) {\n        const state = this.stateManager.load();\n        const taskContext = state?.taskDescription || \"\";\n        const projectContext = this.readProjectContext();\n        // Build structured prompt with validation criteria if enabled\n        let prompt = \"\";\n        if (feature.validation?.enabled) {\n            // Use structured prompt template with success criteria\n            const structuredPrompt = buildStructuredPrompt(feature, customPrompt);\n            prompt = `You are a worker agent focused on implementing a single feature with validation criteria.\n\n${structuredPrompt}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt && !feature.validation?.enabled ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n        }\n        else {\n            // Legacy prompt without validation\n            prompt = `You are a worker agent focused on implementing a single feature.\n\n## Your Task\n${feature.description}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n        }\n        return prompt;\n    }\n    /**\n     * Build a specialized prompt for planning mode workers\n     * These workers create implementation plans without writing code\n     */\n    buildPlannerPrompt(feature, role, customPrompt) {\n        const state = this.stateManager.load();\n        const taskContext = state?.taskDescription || \"\";\n        const projectContext = this.readProjectContext();\n        // Different perspectives based on role\n        const roleGuidance = role === \"A\"\n            ? \"Consider a straightforward, incremental approach. Focus on minimizing risk and using established patterns.\"\n            : \"Consider an alternative or more elegant approach. Look for opportunities to simplify or improve the architecture.\";\n        const prompt = `You are a planning agent focused on creating an implementation plan for a feature.\nYour role is to analyze the codebase and create a detailed plan - DO NOT implement any code.\n\n## Your Task\nCreate an implementation plan for: ${feature.description}\n\n## Planning Approach\n${roleGuidance}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Instructions\n1. Explore the codebase to understand the current architecture\n2. Identify the files that need to be created or modified\n3. Create a step-by-step implementation plan\n4. Identify potential risks and how to mitigate them\n5. Output your plan as a JSON file\n\n## Output Format\nCreate a file at: .claude/orchestrator/workers/${feature.id}.plan.json\n\nThe JSON must follow this structure:\n{\n  \"summary\": \"One paragraph overview of the approach\",\n  \"steps\": [\n    {\n      \"order\": 1,\n      \"description\": \"What to do in this step\",\n      \"files\": [\"src/file1.ts\", \"src/file2.ts\"],\n      \"validation\": \"How to verify this step is complete\"\n    }\n  ],\n  \"filesToCreate\": [\"src/newfile.ts\"],\n  \"filesToModify\": [\"src/existing.ts\"],\n  \"testStrategy\": \"How to test the implementation\",\n  \"risks\": [\"Risk 1: description and mitigation\", \"Risk 2: ...\"],\n  \"estimatedComplexity\": \"low\" | \"medium\" | \"high\"\n}\n\n## Important\n- You are in PLANNING mode - do NOT write any implementation code\n- Use Read, Glob, and Grep tools to explore the codebase\n- Focus on understanding existing patterns and conventions\n- Your plan will be evaluated against another planner's approach\n- The winning plan will be used for implementation\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin exploring and planning now.`;\n        return prompt;\n    }\n    /**\n     * Start a worker in planning mode\n     * Returns a unique session name for tracking\n     */\n    async startPlannerWorker(feature, role, customPrompt) {\n        // Validate feature ID\n        try {\n            validateFeatureId(feature.id);\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Invalid feature ID: ${error.message}`,\n            };\n        }\n        // Use role suffix in session name to distinguish planners\n        const timestamp = Date.now().toString(36);\n        const sessionName = `cc-planner-${feature.id}-${role.toLowerCase()}-${timestamp}`;\n        const prompt = this.buildPlannerPrompt(feature, role, customPrompt);\n        // Check if tmux is available\n        try {\n            await execFileAsync(\"which\", [\"tmux\"]);\n        }\n        catch {\n            return {\n                success: false,\n                error: \"tmux is not installed. Please install tmux first.\",\n            };\n        }\n        try {\n            // Write prompt to a file\n            const promptFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.prompt`);\n            fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n            const logFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.log`);\n            // Create wrapper script with read-only tools only\n            const wrapperScript = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.sh`);\n            // Get worker flags (tools, permissions, MCP config)\n            const workerFlags = getWorkerFlags();\n            const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Planner: allowed tools and MCP servers configured via env vars\nclaude ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'PLANNER_EXITED' >> ${shellQuote(logFile)}\n`;\n            fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n            // Start tmux session\n            await execFileAsync(\"tmux\", [\n                \"new-session\",\n                \"-d\",\n                \"-s\",\n                sessionName,\n                \"-c\",\n                this.projectDir,\n                \"bash\",\n                wrapperScript,\n            ]);\n            // Create status file\n            const statusFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.status`);\n            fs.writeFileSync(statusFile, JSON.stringify({\n                sessionName,\n                featureId: feature.id,\n                role,\n                startedAt: new Date().toISOString(),\n                status: \"running\",\n                mode: \"planning\",\n            }));\n            return {\n                success: true,\n                sessionName,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: sanitizeOutput(error.message),\n            };\n        }\n    }\n    /**\n     * Check if a plan file exists for a feature/role\n     */\n    planExists(featureId, role) {\n        const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n        // Also check role-specific plan file\n        const rolePlanFile = path.join(this.workerDir, `${featureId}.planner-${role.toLowerCase()}.plan.json`);\n        return fs.existsSync(planFile) || fs.existsSync(rolePlanFile);\n    }\n    /**\n     * Read a plan file for a feature\n     */\n    readPlanFile(featureId) {\n        const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n        try {\n            if (fs.existsSync(planFile)) {\n                const content = fs.readFileSync(planFile, \"utf-8\");\n                return JSON.parse(content);\n            }\n        }\n        catch {\n            // Return null if parsing fails\n        }\n        return null;\n    }\n    /**\n     * Start a worker in a tmux session\n     * Security: Uses file-based prompt passing to avoid shell injection\n     */\n    async startWorker(feature, customPrompt, model) {\n        // Validate feature ID\n        try {\n            validateFeatureId(feature.id);\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Invalid feature ID: ${error.message}`,\n            };\n        }\n        const sessionName = this.generateSessionName(feature.id);\n        const prompt = this.buildWorkerPrompt(feature, customPrompt);\n        // Check if tmux is available\n        try {\n            await execFileAsync(\"which\", [\"tmux\"]);\n        }\n        catch {\n            return {\n                success: false,\n                error: \"tmux is not installed. Please install tmux first.\",\n            };\n        }\n        try {\n            // Write prompt to a file instead of passing via shell (prevents injection)\n            const promptFile = path.join(this.workerDir, `${feature.id}.prompt`);\n            fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n            const logFile = path.join(this.workerDir, `${feature.id}.log`);\n            // Create a wrapper script that reads the prompt from file\n            // This avoids any shell escaping issues\n            const wrapperScript = path.join(this.workerDir, `${feature.id}.sh`);\n            // Get worker flags (tools, permissions, MCP config)\n            const workerFlags = getWorkerFlags();\n            const modelFlag = model ? `--model claude-${model}-4-5` : \"\";\n            const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Worker: allowed tools and MCP servers configured via env vars\nclaude ${modelFlag} ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'WORKER_EXITED' >> ${shellQuote(logFile)}\n`;\n            fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n            // Start tmux session with the wrapper script\n            // Using execFile with explicit arguments avoids shell interpretation\n            await execFileAsync(\"tmux\", [\n                \"new-session\",\n                \"-d\",\n                \"-s\",\n                sessionName,\n                \"-c\",\n                this.projectDir,\n                \"bash\",\n                wrapperScript,\n            ]);\n            // Create status file\n            const statusFile = path.join(this.workerDir, `${feature.id}.status`);\n            fs.writeFileSync(statusFile, JSON.stringify({\n                sessionName,\n                featureId: feature.id,\n                startedAt: new Date().toISOString(),\n                status: \"running\",\n            }));\n            return {\n                success: true,\n                sessionName,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: sanitizeOutput(error.message),\n            };\n        }\n    }\n    /**\n     * Check the status and output of a worker\n     */\n    async checkWorker(sessionName, lines = 50) {\n        // Validate session name format\n        if (!validateSessionName(sessionName)) {\n            return {\n                status: \"not_found\",\n                output: \"Invalid session name format\",\n            };\n        }\n        try {\n            // Check if session exists using execFile\n            let sessions = \"\";\n            try {\n                const result = await execFileAsync(\"tmux\", [\n                    \"list-sessions\",\n                    \"-F\",\n                    \"#{session_name}\",\n                ]);\n                sessions = result.stdout;\n            }\n            catch {\n                // tmux might not be running, treat as no sessions\n                sessions = \"\";\n            }\n            const sessionExists = sessions.includes(sessionName);\n            if (!sessionExists) {\n                // Session ended - check for completion file\n                const featureId = this.extractFeatureId(sessionName);\n                if (!featureId) {\n                    return {\n                        status: \"not_found\",\n                        output: \"Could not extract feature ID from session name\",\n                    };\n                }\n                const doneFile = path.join(this.workerDir, `${featureId}.done`);\n                if (fs.existsSync(doneFile)) {\n                    const summary = fs.readFileSync(doneFile, \"utf-8\");\n                    return {\n                        status: \"completed\",\n                        output: `Worker completed.\\n\\nSummary:\\n${sanitizeOutput(summary)}`,\n                    };\n                }\n                // Check log file for crash info\n                const logFile = path.join(this.workerDir, `${featureId}.log`);\n                if (fs.existsSync(logFile)) {\n                    const log = fs.readFileSync(logFile, \"utf-8\");\n                    const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n                    return {\n                        status: \"crashed\",\n                        output: `Worker session ended unexpectedly.\\n\\nLast output:\\n${sanitizeOutput(lastLines)}`,\n                    };\n                }\n                return {\n                    status: \"not_found\",\n                    output: \"Worker session not found and no logs available.\",\n                };\n            }\n            // Session is running - capture output using execFile\n            const { stdout: output } = await execFileAsync(\"tmux\", [\n                \"capture-pane\",\n                \"-t\",\n                sessionName,\n                \"-p\",\n                \"-S\",\n                `-${Math.min(lines, 500)}`, // Limit lines to prevent abuse\n            ]);\n            // If tmux capture is empty, try reading from log file as fallback\n            if (!output || output.trim() === \"\") {\n                const featureId = this.extractFeatureId(sessionName);\n                if (featureId) {\n                    const logFile = path.join(this.workerDir, `${featureId}.log`);\n                    if (fs.existsSync(logFile)) {\n                        const log = fs.readFileSync(logFile, \"utf-8\");\n                        if (log.length > 0) {\n                            const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n                            return {\n                                status: \"running\",\n                                output: `(from log file)\\n${sanitizeOutput(lastLines)}`,\n                            };\n                        }\n                    }\n                }\n                // Still empty - worker is initializing\n                return {\n                    status: \"running\",\n                    output: \"\u23f3 Worker is initializing... (output will appear in 30-60 seconds)\",\n                };\n            }\n            return {\n                status: \"running\",\n                output: sanitizeOutput(output),\n            };\n        }\n        catch (error) {\n            return {\n                status: \"not_found\",\n                output: sanitizeOutput(error.message),\n            };\n        }\n    }\n    /**\n     * Check all workers and return their statuses\n     */\n    async checkAllWorkers() {\n        const state = this.stateManager.load();\n        if (!state)\n            return [];\n        const statuses = [];\n        for (const feature of state.features) {\n            if (feature.workerId && validateSessionName(feature.workerId)) {\n                const result = await this.checkWorker(feature.workerId);\n                statuses.push({\n                    sessionName: feature.workerId,\n                    featureId: feature.id,\n                    status: result.status === \"running\"\n                        ? \"running\"\n                        : result.status === \"completed\"\n                            ? \"completed\"\n                            : result.status === \"crashed\"\n                                ? \"crashed\"\n                                : \"unknown\",\n                    startedAt: feature.startedAt || \"\",\n                    lastChecked: new Date().toISOString(),\n                });\n            }\n        }\n        return statuses;\n    }\n    /**\n     * Get lightweight heartbeat info for a worker (no full output)\n     * Parses log file to extract tool usage, file modifications, and activity\n     */\n    async getHeartbeatInfo(sessionName, startedAt) {\n        // First check the basic status\n        const basicResult = await this.checkWorker(sessionName, 10);\n        const featureId = this.extractFeatureId(sessionName);\n        if (!featureId) {\n            return {\n                status: basicResult.status,\n                linesWritten: 0,\n                filesModified: [],\n            };\n        }\n        const logFile = path.join(this.workerDir, `${featureId}.log`);\n        let linesWritten = 0;\n        let lastToolUsed;\n        let lastFile;\n        const filesModified = new Set();\n        if (fs.existsSync(logFile)) {\n            try {\n                const log = fs.readFileSync(logFile, \"utf-8\");\n                const lines = log.split(\"\\n\");\n                linesWritten = lines.length;\n                // Parse log for tool usage patterns (scan last 100 lines for efficiency)\n                const recentLines = lines.slice(-100);\n                for (const line of recentLines) {\n                    // Match tool usage patterns like \"Read tool\", \"Edit tool\", \"Bash tool\"\n                    const toolMatch = line.match(/\\b(Read|Write|Edit|Bash|Glob|Grep)\\b.*?(?:tool|file|command)/i);\n                    if (toolMatch) {\n                        lastToolUsed = toolMatch[1];\n                    }\n                    // Match file paths in tool output\n                    const fileMatch = line.match(/(?:Reading|Writing|Editing|Created|Modified|file_path['\":\\s]+)([^\\s'\"]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html))/i);\n                    if (fileMatch) {\n                        lastFile = fileMatch[1];\n                        filesModified.add(fileMatch[1]);\n                    }\n                    // Also match paths like /src/foo.ts\n                    const pathMatch = line.match(/\\/[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html)\\b/);\n                    if (pathMatch) {\n                        lastFile = pathMatch[0];\n                        filesModified.add(pathMatch[0]);\n                    }\n                }\n            }\n            catch {\n                // Ignore read errors\n            }\n        }\n        // Calculate last activity (use file mtime)\n        let lastActivity;\n        if (fs.existsSync(logFile)) {\n            try {\n                const stat = fs.statSync(logFile);\n                const mtime = stat.mtime;\n                const now = new Date();\n                const diffMs = now.getTime() - mtime.getTime();\n                const diffSec = Math.floor(diffMs / 1000);\n                if (diffSec < 60) {\n                    lastActivity = `${diffSec}s ago`;\n                }\n                else if (diffSec < 3600) {\n                    lastActivity = `${Math.floor(diffSec / 60)}m ago`;\n                }\n                else {\n                    lastActivity = `${Math.floor(diffSec / 3600)}h ago`;\n                }\n            }\n            catch {\n                // Ignore stat errors\n            }\n        }\n        // Calculate running time\n        let runningFor;\n        if (startedAt) {\n            const startTime = new Date(startedAt);\n            const now = new Date();\n            const diffMs = now.getTime() - startTime.getTime();\n            const diffSec = Math.floor(diffMs / 1000);\n            const mins = Math.floor(diffSec / 60);\n            const secs = diffSec % 60;\n            runningFor = `${mins}m ${secs}s`;\n        }\n        // Get confidence score\n        let confidence;\n        if (basicResult.status === \"running\") {\n            const confidenceResult = getWorkerConfidence(this.workerDir, featureId);\n            if (confidenceResult) {\n                confidence = confidenceResult;\n            }\n        }\n        return {\n            status: basicResult.status,\n            lastToolUsed,\n            lastFile,\n            lastActivity,\n            linesWritten,\n            filesModified: Array.from(filesModified).slice(0, 10), // Limit to 10 files\n            runningFor,\n            confidence,\n        };\n    }\n    /**\n     * Register a callback to be notified when workers complete or crash\n     */\n    onWorkerCompletion(callback) {\n        this.completionCallbacks.push(callback);\n    }\n    /**\n     * Start monitoring workers for completion\n     * Polls every 10 seconds to detect session exits\n     */\n    startCompletionMonitor() {\n        if (this.monitorInterval) {\n            return; // Already monitoring\n        }\n        this.monitorInterval = setInterval(async () => {\n            try {\n                await this.checkForCompletions();\n            }\n            catch (error) {\n                console.error(\"Error checking for completions:\", error);\n            }\n        }, 10000); // Check every 10 seconds\n    }\n    /**\n     * Stop the completion monitor\n     */\n    stopCompletionMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n            this.monitorInterval = null;\n        }\n    }\n    /**\n     * Check all tracked workers for completion and notify callbacks\n     */\n    async checkForCompletions() {\n        const state = this.stateManager.load();\n        if (!state)\n            return;\n        // Get list of in-progress features with workers\n        const activeWorkers = state.features.filter((f) => f.status === \"in_progress\" && f.workerId);\n        for (const feature of activeWorkers) {\n            if (!feature.workerId)\n                continue;\n            const currentStatus = await this.checkWorker(feature.workerId, 20);\n            const lastStatus = this.lastKnownStatus.get(feature.id);\n            // Track status changes\n            if (lastStatus !== currentStatus.status) {\n                this.lastKnownStatus.set(feature.id, currentStatus.status);\n                // Notify on completion or crash (but not initial running status)\n                if (lastStatus === \"running\" &&\n                    (currentStatus.status === \"completed\" ||\n                        currentStatus.status === \"crashed\")) {\n                    // Notify all registered callbacks\n                    for (const callback of this.completionCallbacks) {\n                        try {\n                            callback(feature.id, currentStatus.status, currentStatus.output);\n                        }\n                        catch (error) {\n                            console.error(\"Error in completion callback:\", error);\n                        }\n                    }\n                }\n            }\n            // Initialize tracking for new workers\n            if (!lastStatus && currentStatus.status === \"running\") {\n                this.lastKnownStatus.set(feature.id, \"running\");\n            }\n        }\n        // Clean up tracking for completed features\n        for (const [featureId] of this.lastKnownStatus) {\n            const feature = state.features.find((f) => f.id === featureId);\n            if (!feature || feature.status !== \"in_progress\") {\n                this.lastKnownStatus.delete(featureId);\n            }\n        }\n    }\n    /**\n     * Analyze potential conflicts between features for parallel execution\n     * Extracts file/component hints from descriptions and detects overlaps\n     */\n    analyzeFeatureConflicts(features) {\n        const conflicts = [];\n        // Extract file/component hints from each feature description\n        const featureHints = features.map((feature) => {\n            const desc = feature.description.toLowerCase();\n            // Extract potential file paths\n            const fileMatches = desc.match(/(?:[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html|vue|svelte))/gi) || [];\n            // Extract component/module names\n            const componentMatches = desc.match(/(?:component|module|service|controller|handler|model|route|api|endpoint|hook|context|store|page|layout)\\s*['\":]?\\s*(\\w+)/gi) || [];\n            // Extract folder/directory hints\n            const folderMatches = desc.match(/(?:in|under|to|from|inside)\\s+(?:the\\s+)?['\"\\/]?(src|lib|app|components|pages|routes|api|services|utils|hooks|stores|models|controllers|handlers|config)(?:\\/[\\w\\-]+)*/gi) || [];\n            // Extract action keywords that may conflict\n            const actionMatches = desc.match(/(?:refactor|rewrite|restructure|redesign|overhaul|migrate)\\s+(?:the\\s+)?(\\w+)/gi) || [];\n            return {\n                id: feature.id,\n                description: feature.description,\n                files: fileMatches.map((f) => f.toLowerCase()),\n                components: componentMatches.map((c) => c.toLowerCase()),\n                folders: folderMatches.map((f) => f.toLowerCase()),\n                actions: actionMatches.map((a) => a.toLowerCase()),\n            };\n        });\n        // Compare each pair of features for potential conflicts\n        for (let i = 0; i < featureHints.length; i++) {\n            for (let j = i + 1; j < featureHints.length; j++) {\n                const hint1 = featureHints[i];\n                const hint2 = featureHints[j];\n                // Check for overlapping files\n                const fileOverlap = hint1.files.filter((f) => hint2.files.includes(f));\n                if (fileOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify file(s): ${fileOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for overlapping components\n                const componentOverlap = hint1.components.filter((c) => hint2.components.includes(c));\n                if (componentOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify component(s): ${componentOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for overlapping folders\n                const folderOverlap = hint1.folders.filter((f) => hint2.folders.includes(f));\n                if (folderOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify folder(s): ${folderOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for dangerous action combinations\n                if (hint1.actions.length > 0 && hint2.actions.length > 0) {\n                    const actionOverlap = hint1.actions.filter((a) => hint2.actions.some((a2) => a.includes(a2) || a2.includes(a)));\n                    if (actionOverlap.length > 0) {\n                        conflicts.push({\n                            feature1: hint1.id,\n                            feature2: hint2.id,\n                            reason: `Both involve major changes: ${hint1.actions[0]}, ${hint2.actions[0]}`,\n                        });\n                    }\n                }\n            }\n        }\n        return conflicts;\n    }\n    /**\n     * Kill a specific worker session\n     */\n    async killWorker(sessionName) {\n        // Validate session name\n        if (!validateSessionName(sessionName)) {\n            return;\n        }\n        try {\n            await execFileAsync(\"tmux\", [\"kill-session\", \"-t\", sessionName]);\n        }\n        catch {\n            // Session might already be dead, that's fine\n        }\n    }\n    /**\n     * Kill all worker sessions for this project\n     */\n    async killAllWorkers() {\n        try {\n            // List all sessions\n            let sessions = \"\";\n            try {\n                const result = await execFileAsync(\"tmux\", [\n                    \"list-sessions\",\n                    \"-F\",\n                    \"#{session_name}\",\n                ]);\n                sessions = result.stdout;\n            }\n            catch {\n                sessions = \"\";\n            }\n            const workerSessions = sessions\n                .split(\"\\n\")\n                .filter((s) => s.startsWith(\"cc-worker-\") && validateSessionName(s));\n            for (const session of workerSessions) {\n                if (session) {\n                    await this.killWorker(session);\n                }\n            }\n            // Clean up worker files\n            if (fs.existsSync(this.workerDir)) {\n                const files = fs.readdirSync(this.workerDir);\n                for (const file of files) {\n                    const filePath = path.join(this.workerDir, file);\n                    try {\n                        fs.unlinkSync(filePath);\n                    }\n                    catch {\n                        // Ignore errors during cleanup\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error killing workers:\", error);\n        }\n    }\n    /**\n     * Wait for a worker to complete (blocking)\n     */\n    async waitForWorker(sessionName, timeoutMs = 3600000) {\n        if (!validateSessionName(sessionName)) {\n            return {\n                status: \"not_found\",\n                output: \"Invalid session name\",\n            };\n        }\n        const startTime = Date.now();\n        const pollInterval = 5000; // Check every 5 seconds\n        while (Date.now() - startTime < timeoutMs) {\n            const result = await this.checkWorker(sessionName);\n            if (result.status !== \"running\") {\n                return result;\n            }\n            // Wait before checking again\n            await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        }\n        return {\n            status: \"crashed\",\n            output: \"Worker timed out\",\n        };\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_67": {
      "name": "constructor",
      "type": "method",
      "start_line": 67,
      "end_line": 75,
      "content_hash": "1341088e7d01dab4be317a2757216fa2aafd48ed",
      "content": "    constructor(projectDir, stateManager) {\n        this.projectDir = projectDir;\n        this.stateManager = stateManager;\n        // Directory for worker status files\n        this.workerDir = path.join(projectDir, \".claude\", \"orchestrator\", \"workers\");\n        if (!fs.existsSync(this.workerDir)) {\n            fs.mkdirSync(this.workerDir, { recursive: true });\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generateSessionName_79": {
      "name": "generateSessionName",
      "type": "method",
      "start_line": 79,
      "end_line": 84,
      "content_hash": "5c18ebddff82b4e7dc9e998a4045e9ad078af787",
      "content": "    generateSessionName(featureId) {\n        // Validate feature ID first\n        validateFeatureId(featureId);\n        const timestamp = Date.now().toString(36);\n        return `cc-worker-${featureId}-${timestamp}`;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_extractFeatureId_88": {
      "name": "extractFeatureId",
      "type": "method",
      "start_line": 88,
      "end_line": 91,
      "content_hash": "eb8314dce0ce5f6a9b284d1ef7a29c2eb693b91f",
      "content": "    extractFeatureId(sessionName) {\n        const match = sessionName.match(/^cc-worker-(.+?)-[a-z0-9]+$/);\n        return match ? match[1] : null;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_readProjectContext_96": {
      "name": "readProjectContext",
      "type": "method",
      "start_line": 96,
      "end_line": 123,
      "content_hash": "e5f0aad87c1b38d89d377ad079329bc5e8cc3ee0",
      "content": "    readProjectContext() {\n        const contextFiles = [\n            \"CLAUDE.md\",\n            \".claude/CLAUDE.md\",\n            \".clauderc\",\n            \".claude/settings.json\",\n        ];\n        const contents = [];\n        for (const file of contextFiles) {\n            const filePath = path.join(this.projectDir, file);\n            if (fs.existsSync(filePath)) {\n                try {\n                    const content = fs.readFileSync(filePath, \"utf-8\");\n                    // Limit each file to 4000 chars to prevent prompt bloat\n                    const truncated = content.length > 4000\n                        ? content.substring(0, 4000) + \"\\n... (truncated)\"\n                        : content;\n                    contents.push(`### From ${file}:\\n${truncated}`);\n                }\n                catch {\n                    // Skip unreadable files silently\n                }\n            }\n        }\n        return contents.length > 0\n            ? `\\n## Project Context Files\\n${contents.join(\"\\n\\n\")}\\n`\n            : \"\";\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildWorkerPrompt_127": {
      "name": "buildWorkerPrompt",
      "type": "method",
      "start_line": 127,
      "end_line": 260,
      "content_hash": "7f07a3597d702bb86ca7cdb2418e32dc4d3c65d7",
      "content": "    buildWorkerPrompt(feature, customPrompt) {\n        const state = this.stateManager.load();\n        const taskContext = state?.taskDescription || \"\";\n        const projectContext = this.readProjectContext();\n        // Build structured prompt with validation criteria if enabled\n        let prompt = \"\";\n        if (feature.validation?.enabled) {\n            // Use structured prompt template with success criteria\n            const structuredPrompt = buildStructuredPrompt(feature, customPrompt);\n            prompt = `You are a worker agent focused on implementing a single feature with validation criteria.\n\n${structuredPrompt}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt && !feature.validation?.enabled ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n        }\n        else {\n            // Legacy prompt without validation\n            prompt = `You are a worker agent focused on implementing a single feature.\n\n## Your Task\n${feature.description}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Implementation Steps (REQUIRED)\n\n### Phase 1: Get Your Bearings (ALWAYS START HERE)\n1. Run 'pwd' to see your working directory\n2. Read git logs: 'git log --oneline -20' to see recent work\n3. Read claude-progress.txt (if it exists) to understand what was recently done\n4. Read the feature list to understand overall progress\n5. If init.sh exists, read it to understand how to run/test the project\n\n### Phase 2: Verify Environment Health\n1. Run basic tests or start development server (if applicable)\n2. Verify the codebase is in a working state\n3. If broken, fix critical bugs BEFORE implementing your feature\n4. Document any fixes in your .done file\n\n### Phase 3: Implement Your Feature\n1. Read the relevant source files to understand current implementation\n2. Make the necessary code changes using Edit or Write tools\n3. Test your changes thoroughly:\n   - Run automated tests (unit, integration)\n   - For web features: Use Chrome DevTools MCP to test in browser as a user would\n   - Verify syntax, check behavior end-to-end\n   - Take screenshots of working features if applicable\n4. ONLY AFTER code changes are complete AND tested: Create .claude/orchestrator/workers/${feature.id}.done\n\n   The .done file MUST contain:\n   - List of files you modified (with line numbers if applicable)\n   - Summary of changes made to each file\n   - Any tests you ran and their results\n   - If BLOCKED: explain what blocked you and what you tried\n\n### Phase 4: Leave Environment Clean\n1. Do NOT commit - the orchestrator handles commits\n2. Ensure all tests pass\n3. Ensure code is in a working state for the next worker\n\n## Critical Requirements\n- You MUST make actual code changes - reading files is not enough\n- You MUST use Edit/Write tools to modify source code\n- Do NOT create the .done file until you have modified code\n- If you encounter a blocker, document it in .done and explain what prevented completion\n- Keep changes minimal and focused on this single feature\n- NEVER commit, stage, or git add ANY of these files:\n  - .claude/ (entire directory - orchestrator state, logs, prompts, worker files)\n  - claude-progress.txt\n  - init.sh\n  - *.prompt, *.log, *.done, *.status files in .claude/\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin implementing the feature now.`;\n        }\n        return prompt;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_buildPlannerPrompt_265": {
      "name": "buildPlannerPrompt",
      "type": "method",
      "start_line": 265,
      "end_line": 325,
      "content_hash": "6aa30ff3d7387cfe444dd7bc9764532b6364fe2f",
      "content": "    buildPlannerPrompt(feature, role, customPrompt) {\n        const state = this.stateManager.load();\n        const taskContext = state?.taskDescription || \"\";\n        const projectContext = this.readProjectContext();\n        // Different perspectives based on role\n        const roleGuidance = role === \"A\"\n            ? \"Consider a straightforward, incremental approach. Focus on minimizing risk and using established patterns.\"\n            : \"Consider an alternative or more elegant approach. Look for opportunities to simplify or improve the architecture.\";\n        const prompt = `You are a planning agent focused on creating an implementation plan for a feature.\nYour role is to analyze the codebase and create a detailed plan - DO NOT implement any code.\n\n## Your Task\nCreate an implementation plan for: ${feature.description}\n\n## Planning Approach\n${roleGuidance}\n\n## Orchestration Context\n${taskContext}\n${projectContext}\n\n## Instructions\n1. Explore the codebase to understand the current architecture\n2. Identify the files that need to be created or modified\n3. Create a step-by-step implementation plan\n4. Identify potential risks and how to mitigate them\n5. Output your plan as a JSON file\n\n## Output Format\nCreate a file at: .claude/orchestrator/workers/${feature.id}.plan.json\n\nThe JSON must follow this structure:\n{\n  \"summary\": \"One paragraph overview of the approach\",\n  \"steps\": [\n    {\n      \"order\": 1,\n      \"description\": \"What to do in this step\",\n      \"files\": [\"src/file1.ts\", \"src/file2.ts\"],\n      \"validation\": \"How to verify this step is complete\"\n    }\n  ],\n  \"filesToCreate\": [\"src/newfile.ts\"],\n  \"filesToModify\": [\"src/existing.ts\"],\n  \"testStrategy\": \"How to test the implementation\",\n  \"risks\": [\"Risk 1: description and mitigation\", \"Risk 2: ...\"],\n  \"estimatedComplexity\": \"low\" | \"medium\" | \"high\"\n}\n\n## Important\n- You are in PLANNING mode - do NOT write any implementation code\n- Use Read, Glob, and Grep tools to explore the codebase\n- Focus on understanding existing patterns and conventions\n- Your plan will be evaluated against another planner's approach\n- The winning plan will be used for implementation\n\n${customPrompt ? `\\n## Additional Context\\n${customPrompt}` : \"\"}\n\nBegin exploring and planning now.`;\n        return prompt;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startPlannerWorker_330": {
      "name": "startPlannerWorker",
      "type": "method",
      "start_line": 330,
      "end_line": 405,
      "content_hash": "054114b523a7d863fadabb1970c78f6472d37ea9",
      "content": "    async startPlannerWorker(feature, role, customPrompt) {\n        // Validate feature ID\n        try {\n            validateFeatureId(feature.id);\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Invalid feature ID: ${error.message}`,\n            };\n        }\n        // Use role suffix in session name to distinguish planners\n        const timestamp = Date.now().toString(36);\n        const sessionName = `cc-planner-${feature.id}-${role.toLowerCase()}-${timestamp}`;\n        const prompt = this.buildPlannerPrompt(feature, role, customPrompt);\n        // Check if tmux is available\n        try {\n            await execFileAsync(\"which\", [\"tmux\"]);\n        }\n        catch {\n            return {\n                success: false,\n                error: \"tmux is not installed. Please install tmux first.\",\n            };\n        }\n        try {\n            // Write prompt to a file\n            const promptFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.prompt`);\n            fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n            const logFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.log`);\n            // Create wrapper script with read-only tools only\n            const wrapperScript = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.sh`);\n            // Get worker flags (tools, permissions, MCP config)\n            const workerFlags = getWorkerFlags();\n            const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Planner: allowed tools and MCP servers configured via env vars\nclaude ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'PLANNER_EXITED' >> ${shellQuote(logFile)}\n`;\n            fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n            // Start tmux session\n            await execFileAsync(\"tmux\", [\n                \"new-session\",\n                \"-d\",\n                \"-s\",\n                sessionName,\n                \"-c\",\n                this.projectDir,\n                \"bash\",\n                wrapperScript,\n            ]);\n            // Create status file\n            const statusFile = path.join(this.workerDir, `${feature.id}.planner-${role.toLowerCase()}.status`);\n            fs.writeFileSync(statusFile, JSON.stringify({\n                sessionName,\n                featureId: feature.id,\n                role,\n                startedAt: new Date().toISOString(),\n                status: \"running\",\n                mode: \"planning\",\n            }));\n            return {\n                success: true,\n                sessionName,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: sanitizeOutput(error.message),\n            };\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_planExists_409": {
      "name": "planExists",
      "type": "method",
      "start_line": 409,
      "end_line": 414,
      "content_hash": "084bfc7eff81146c54bcd443881be8cbdd5552a2",
      "content": "    planExists(featureId, role) {\n        const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n        // Also check role-specific plan file\n        const rolePlanFile = path.join(this.workerDir, `${featureId}.planner-${role.toLowerCase()}.plan.json`);\n        return fs.existsSync(planFile) || fs.existsSync(rolePlanFile);\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_readPlanFile_418": {
      "name": "readPlanFile",
      "type": "method",
      "start_line": 418,
      "end_line": 430,
      "content_hash": "9523bbb82af9a9264d2d9491c7c2916239f5a429",
      "content": "    readPlanFile(featureId) {\n        const planFile = path.join(this.workerDir, `${featureId}.plan.json`);\n        try {\n            if (fs.existsSync(planFile)) {\n                const content = fs.readFileSync(planFile, \"utf-8\");\n                return JSON.parse(content);\n            }\n        }\n        catch {\n            // Return null if parsing fails\n        }\n        return null;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startWorker_435": {
      "name": "startWorker",
      "type": "method",
      "start_line": 435,
      "end_line": 509,
      "content_hash": "4facf2163915d0c202917c74c52830df08278dc0",
      "content": "    async startWorker(feature, customPrompt, model) {\n        // Validate feature ID\n        try {\n            validateFeatureId(feature.id);\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Invalid feature ID: ${error.message}`,\n            };\n        }\n        const sessionName = this.generateSessionName(feature.id);\n        const prompt = this.buildWorkerPrompt(feature, customPrompt);\n        // Check if tmux is available\n        try {\n            await execFileAsync(\"which\", [\"tmux\"]);\n        }\n        catch {\n            return {\n                success: false,\n                error: \"tmux is not installed. Please install tmux first.\",\n            };\n        }\n        try {\n            // Write prompt to a file instead of passing via shell (prevents injection)\n            const promptFile = path.join(this.workerDir, `${feature.id}.prompt`);\n            fs.writeFileSync(promptFile, prompt, { mode: 0o600 });\n            const logFile = path.join(this.workerDir, `${feature.id}.log`);\n            // Create a wrapper script that reads the prompt from file\n            // This avoids any shell escaping issues\n            const wrapperScript = path.join(this.workerDir, `${feature.id}.sh`);\n            // Get worker flags (tools, permissions, MCP config)\n            const workerFlags = getWorkerFlags();\n            const modelFlag = model ? `--model claude-${model}-4-5` : \"\";\n            const scriptContent = `#!/bin/bash\nset -e\ncd ${shellQuote(this.projectDir)}\nPROMPT=$(cat ${shellQuote(promptFile)})\n# Worker: allowed tools and MCP servers configured via env vars\nclaude ${modelFlag} ${workerFlags} -p \"$PROMPT\" 2>&1 | tee ${shellQuote(logFile)}\necho 'WORKER_EXITED' >> ${shellQuote(logFile)}\n`;\n            fs.writeFileSync(wrapperScript, scriptContent, { mode: 0o700 });\n            // Start tmux session with the wrapper script\n            // Using execFile with explicit arguments avoids shell interpretation\n            await execFileAsync(\"tmux\", [\n                \"new-session\",\n                \"-d\",\n                \"-s\",\n                sessionName,\n                \"-c\",\n                this.projectDir,\n                \"bash\",\n                wrapperScript,\n            ]);\n            // Create status file\n            const statusFile = path.join(this.workerDir, `${feature.id}.status`);\n            fs.writeFileSync(statusFile, JSON.stringify({\n                sessionName,\n                featureId: feature.id,\n                startedAt: new Date().toISOString(),\n                status: \"running\",\n            }));\n            return {\n                success: true,\n                sessionName,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: sanitizeOutput(error.message),\n            };\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkWorker_513": {
      "name": "checkWorker",
      "type": "method",
      "start_line": 513,
      "end_line": 611,
      "content_hash": "553998d4099d38f2193cc566dff720855a05f569",
      "content": "    async checkWorker(sessionName, lines = 50) {\n        // Validate session name format\n        if (!validateSessionName(sessionName)) {\n            return {\n                status: \"not_found\",\n                output: \"Invalid session name format\",\n            };\n        }\n        try {\n            // Check if session exists using execFile\n            let sessions = \"\";\n            try {\n                const result = await execFileAsync(\"tmux\", [\n                    \"list-sessions\",\n                    \"-F\",\n                    \"#{session_name}\",\n                ]);\n                sessions = result.stdout;\n            }\n            catch {\n                // tmux might not be running, treat as no sessions\n                sessions = \"\";\n            }\n            const sessionExists = sessions.includes(sessionName);\n            if (!sessionExists) {\n                // Session ended - check for completion file\n                const featureId = this.extractFeatureId(sessionName);\n                if (!featureId) {\n                    return {\n                        status: \"not_found\",\n                        output: \"Could not extract feature ID from session name\",\n                    };\n                }\n                const doneFile = path.join(this.workerDir, `${featureId}.done`);\n                if (fs.existsSync(doneFile)) {\n                    const summary = fs.readFileSync(doneFile, \"utf-8\");\n                    return {\n                        status: \"completed\",\n                        output: `Worker completed.\\n\\nSummary:\\n${sanitizeOutput(summary)}`,\n                    };\n                }\n                // Check log file for crash info\n                const logFile = path.join(this.workerDir, `${featureId}.log`);\n                if (fs.existsSync(logFile)) {\n                    const log = fs.readFileSync(logFile, \"utf-8\");\n                    const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n                    return {\n                        status: \"crashed\",\n                        output: `Worker session ended unexpectedly.\\n\\nLast output:\\n${sanitizeOutput(lastLines)}`,\n                    };\n                }\n                return {\n                    status: \"not_found\",\n                    output: \"Worker session not found and no logs available.\",\n                };\n            }\n            // Session is running - capture output using execFile\n            const { stdout: output } = await execFileAsync(\"tmux\", [\n                \"capture-pane\",\n                \"-t\",\n                sessionName,\n                \"-p\",\n                \"-S\",\n                `-${Math.min(lines, 500)}`, // Limit lines to prevent abuse\n            ]);\n            // If tmux capture is empty, try reading from log file as fallback\n            if (!output || output.trim() === \"\") {\n                const featureId = this.extractFeatureId(sessionName);\n                if (featureId) {\n                    const logFile = path.join(this.workerDir, `${featureId}.log`);\n                    if (fs.existsSync(logFile)) {\n                        const log = fs.readFileSync(logFile, \"utf-8\");\n                        if (log.length > 0) {\n                            const lastLines = log.split(\"\\n\").slice(-lines).join(\"\\n\");\n                            return {\n                                status: \"running\",\n                                output: `(from log file)\\n${sanitizeOutput(lastLines)}`,\n                            };\n                        }\n                    }\n                }\n                // Still empty - worker is initializing\n                return {\n                    status: \"running\",\n                    output: \"\u23f3 Worker is initializing... (output will appear in 30-60 seconds)\",\n                };\n            }\n            return {\n                status: \"running\",\n                output: sanitizeOutput(output),\n            };\n        }\n        catch (error) {\n            return {\n                status: \"not_found\",\n                output: sanitizeOutput(error.message),\n            };\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkAllWorkers_615": {
      "name": "checkAllWorkers",
      "type": "method",
      "start_line": 615,
      "end_line": 639,
      "content_hash": "c24940d52e3284410bf67578d7116e6f1e51ff7c",
      "content": "    async checkAllWorkers() {\n        const state = this.stateManager.load();\n        if (!state)\n            return [];\n        const statuses = [];\n        for (const feature of state.features) {\n            if (feature.workerId && validateSessionName(feature.workerId)) {\n                const result = await this.checkWorker(feature.workerId);\n                statuses.push({\n                    sessionName: feature.workerId,\n                    featureId: feature.id,\n                    status: result.status === \"running\"\n                        ? \"running\"\n                        : result.status === \"completed\"\n                            ? \"completed\"\n                            : result.status === \"crashed\"\n                                ? \"crashed\"\n                                : \"unknown\",\n                    startedAt: feature.startedAt || \"\",\n                    lastChecked: new Date().toISOString(),\n                });\n            }\n        }\n        return statuses;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getHeartbeatInfo_644": {
      "name": "getHeartbeatInfo",
      "type": "method",
      "start_line": 644,
      "end_line": 743,
      "content_hash": "05f21d8b1d80d276e86dd5e63b9d8335a3dc71eb",
      "content": "    async getHeartbeatInfo(sessionName, startedAt) {\n        // First check the basic status\n        const basicResult = await this.checkWorker(sessionName, 10);\n        const featureId = this.extractFeatureId(sessionName);\n        if (!featureId) {\n            return {\n                status: basicResult.status,\n                linesWritten: 0,\n                filesModified: [],\n            };\n        }\n        const logFile = path.join(this.workerDir, `${featureId}.log`);\n        let linesWritten = 0;\n        let lastToolUsed;\n        let lastFile;\n        const filesModified = new Set();\n        if (fs.existsSync(logFile)) {\n            try {\n                const log = fs.readFileSync(logFile, \"utf-8\");\n                const lines = log.split(\"\\n\");\n                linesWritten = lines.length;\n                // Parse log for tool usage patterns (scan last 100 lines for efficiency)\n                const recentLines = lines.slice(-100);\n                for (const line of recentLines) {\n                    // Match tool usage patterns like \"Read tool\", \"Edit tool\", \"Bash tool\"\n                    const toolMatch = line.match(/\\b(Read|Write|Edit|Bash|Glob|Grep)\\b.*?(?:tool|file|command)/i);\n                    if (toolMatch) {\n                        lastToolUsed = toolMatch[1];\n                    }\n                    // Match file paths in tool output\n                    const fileMatch = line.match(/(?:Reading|Writing|Editing|Created|Modified|file_path['\":\\s]+)([^\\s'\"]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html))/i);\n                    if (fileMatch) {\n                        lastFile = fileMatch[1];\n                        filesModified.add(fileMatch[1]);\n                    }\n                    // Also match paths like /src/foo.ts\n                    const pathMatch = line.match(/\\/[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html)\\b/);\n                    if (pathMatch) {\n                        lastFile = pathMatch[0];\n                        filesModified.add(pathMatch[0]);\n                    }\n                }\n            }\n            catch {\n                // Ignore read errors\n            }\n        }\n        // Calculate last activity (use file mtime)\n        let lastActivity;\n        if (fs.existsSync(logFile)) {\n            try {\n                const stat = fs.statSync(logFile);\n                const mtime = stat.mtime;\n                const now = new Date();\n                const diffMs = now.getTime() - mtime.getTime();\n                const diffSec = Math.floor(diffMs / 1000);\n                if (diffSec < 60) {\n                    lastActivity = `${diffSec}s ago`;\n                }\n                else if (diffSec < 3600) {\n                    lastActivity = `${Math.floor(diffSec / 60)}m ago`;\n                }\n                else {\n                    lastActivity = `${Math.floor(diffSec / 3600)}h ago`;\n                }\n            }\n            catch {\n                // Ignore stat errors\n            }\n        }\n        // Calculate running time\n        let runningFor;\n        if (startedAt) {\n            const startTime = new Date(startedAt);\n            const now = new Date();\n            const diffMs = now.getTime() - startTime.getTime();\n            const diffSec = Math.floor(diffMs / 1000);\n            const mins = Math.floor(diffSec / 60);\n            const secs = diffSec % 60;\n            runningFor = `${mins}m ${secs}s`;\n        }\n        // Get confidence score\n        let confidence;\n        if (basicResult.status === \"running\") {\n            const confidenceResult = getWorkerConfidence(this.workerDir, featureId);\n            if (confidenceResult) {\n                confidence = confidenceResult;\n            }\n        }\n        return {\n            status: basicResult.status,\n            lastToolUsed,\n            lastFile,\n            lastActivity,\n            linesWritten,\n            filesModified: Array.from(filesModified).slice(0, 10), // Limit to 10 files\n            runningFor,\n            confidence,\n        };\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_onWorkerCompletion_747": {
      "name": "onWorkerCompletion",
      "type": "method",
      "start_line": 747,
      "end_line": 749,
      "content_hash": "cc426d9edbd25f577bb1220ca31ff2bc86270172",
      "content": "    onWorkerCompletion(callback) {\n        this.completionCallbacks.push(callback);\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startCompletionMonitor_754": {
      "name": "startCompletionMonitor",
      "type": "method",
      "start_line": 754,
      "end_line": 766,
      "content_hash": "15e62018aec4b2920b169d10b54a4f1e03e5ffa7",
      "content": "    startCompletionMonitor() {\n        if (this.monitorInterval) {\n            return; // Already monitoring\n        }\n        this.monitorInterval = setInterval(async () => {\n            try {\n                await this.checkForCompletions();\n            }\n            catch (error) {\n                console.error(\"Error checking for completions:\", error);\n            }\n        }, 10000); // Check every 10 seconds\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stopCompletionMonitor_770": {
      "name": "stopCompletionMonitor",
      "type": "method",
      "start_line": 770,
      "end_line": 775,
      "content_hash": "46b51d304820af3d2a47a0eb6bbde9d1ee26ef5d",
      "content": "    stopCompletionMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n            this.monitorInterval = null;\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_checkForCompletions_779": {
      "name": "checkForCompletions",
      "type": "method",
      "start_line": 779,
      "end_line": 820,
      "content_hash": "7be969c21e0c27a013da5c201c3c5e62ec288a95",
      "content": "    async checkForCompletions() {\n        const state = this.stateManager.load();\n        if (!state)\n            return;\n        // Get list of in-progress features with workers\n        const activeWorkers = state.features.filter((f) => f.status === \"in_progress\" && f.workerId);\n        for (const feature of activeWorkers) {\n            if (!feature.workerId)\n                continue;\n            const currentStatus = await this.checkWorker(feature.workerId, 20);\n            const lastStatus = this.lastKnownStatus.get(feature.id);\n            // Track status changes\n            if (lastStatus !== currentStatus.status) {\n                this.lastKnownStatus.set(feature.id, currentStatus.status);\n                // Notify on completion or crash (but not initial running status)\n                if (lastStatus === \"running\" &&\n                    (currentStatus.status === \"completed\" ||\n                        currentStatus.status === \"crashed\")) {\n                    // Notify all registered callbacks\n                    for (const callback of this.completionCallbacks) {\n                        try {\n                            callback(feature.id, currentStatus.status, currentStatus.output);\n                        }\n                        catch (error) {\n                            console.error(\"Error in completion callback:\", error);\n                        }\n                    }\n                }\n            }\n            // Initialize tracking for new workers\n            if (!lastStatus && currentStatus.status === \"running\") {\n                this.lastKnownStatus.set(feature.id, \"running\");\n            }\n        }\n        // Clean up tracking for completed features\n        for (const [featureId] of this.lastKnownStatus) {\n            const feature = state.features.find((f) => f.id === featureId);\n            if (!feature || feature.status !== \"in_progress\") {\n                this.lastKnownStatus.delete(featureId);\n            }\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_analyzeFeatureConflicts_825": {
      "name": "analyzeFeatureConflicts",
      "type": "method",
      "start_line": 825,
      "end_line": 896,
      "content_hash": "12d39dec0dc87437b3b5ce16ea8c939ec24c28f8",
      "content": "    analyzeFeatureConflicts(features) {\n        const conflicts = [];\n        // Extract file/component hints from each feature description\n        const featureHints = features.map((feature) => {\n            const desc = feature.description.toLowerCase();\n            // Extract potential file paths\n            const fileMatches = desc.match(/(?:[\\w\\-\\/]+\\.(ts|js|tsx|jsx|json|md|py|rs|go|css|scss|html|vue|svelte))/gi) || [];\n            // Extract component/module names\n            const componentMatches = desc.match(/(?:component|module|service|controller|handler|model|route|api|endpoint|hook|context|store|page|layout)\\s*['\":]?\\s*(\\w+)/gi) || [];\n            // Extract folder/directory hints\n            const folderMatches = desc.match(/(?:in|under|to|from|inside)\\s+(?:the\\s+)?['\"\\/]?(src|lib|app|components|pages|routes|api|services|utils|hooks|stores|models|controllers|handlers|config)(?:\\/[\\w\\-]+)*/gi) || [];\n            // Extract action keywords that may conflict\n            const actionMatches = desc.match(/(?:refactor|rewrite|restructure|redesign|overhaul|migrate)\\s+(?:the\\s+)?(\\w+)/gi) || [];\n            return {\n                id: feature.id,\n                description: feature.description,\n                files: fileMatches.map((f) => f.toLowerCase()),\n                components: componentMatches.map((c) => c.toLowerCase()),\n                folders: folderMatches.map((f) => f.toLowerCase()),\n                actions: actionMatches.map((a) => a.toLowerCase()),\n            };\n        });\n        // Compare each pair of features for potential conflicts\n        for (let i = 0; i < featureHints.length; i++) {\n            for (let j = i + 1; j < featureHints.length; j++) {\n                const hint1 = featureHints[i];\n                const hint2 = featureHints[j];\n                // Check for overlapping files\n                const fileOverlap = hint1.files.filter((f) => hint2.files.includes(f));\n                if (fileOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify file(s): ${fileOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for overlapping components\n                const componentOverlap = hint1.components.filter((c) => hint2.components.includes(c));\n                if (componentOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify component(s): ${componentOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for overlapping folders\n                const folderOverlap = hint1.folders.filter((f) => hint2.folders.includes(f));\n                if (folderOverlap.length > 0) {\n                    conflicts.push({\n                        feature1: hint1.id,\n                        feature2: hint2.id,\n                        reason: `Both may modify folder(s): ${folderOverlap.join(\", \")}`,\n                    });\n                    continue;\n                }\n                // Check for dangerous action combinations\n                if (hint1.actions.length > 0 && hint2.actions.length > 0) {\n                    const actionOverlap = hint1.actions.filter((a) => hint2.actions.some((a2) => a.includes(a2) || a2.includes(a)));\n                    if (actionOverlap.length > 0) {\n                        conflicts.push({\n                            feature1: hint1.id,\n                            feature2: hint2.id,\n                            reason: `Both involve major changes: ${hint1.actions[0]}, ${hint2.actions[0]}`,\n                        });\n                    }\n                }\n            }\n        }\n        return conflicts;\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_killWorker_900": {
      "name": "killWorker",
      "type": "method",
      "start_line": 900,
      "end_line": 911,
      "content_hash": "77d7a364b31045592109689136fdfd96c383e101",
      "content": "    async killWorker(sessionName) {\n        // Validate session name\n        if (!validateSessionName(sessionName)) {\n            return;\n        }\n        try {\n            await execFileAsync(\"tmux\", [\"kill-session\", \"-t\", sessionName]);\n        }\n        catch {\n            // Session might already be dead, that's fine\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_killAllWorkers_915": {
      "name": "killAllWorkers",
      "type": "method",
      "start_line": 915,
      "end_line": 955,
      "content_hash": "16f68d8cfdff69725c8cd0e37a288f9d80684936",
      "content": "    async killAllWorkers() {\n        try {\n            // List all sessions\n            let sessions = \"\";\n            try {\n                const result = await execFileAsync(\"tmux\", [\n                    \"list-sessions\",\n                    \"-F\",\n                    \"#{session_name}\",\n                ]);\n                sessions = result.stdout;\n            }\n            catch {\n                sessions = \"\";\n            }\n            const workerSessions = sessions\n                .split(\"\\n\")\n                .filter((s) => s.startsWith(\"cc-worker-\") && validateSessionName(s));\n            for (const session of workerSessions) {\n                if (session) {\n                    await this.killWorker(session);\n                }\n            }\n            // Clean up worker files\n            if (fs.existsSync(this.workerDir)) {\n                const files = fs.readdirSync(this.workerDir);\n                for (const file of files) {\n                    const filePath = path.join(this.workerDir, file);\n                    try {\n                        fs.unlinkSync(filePath);\n                    }\n                    catch {\n                        // Ignore errors during cleanup\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error killing workers:\", error);\n        }\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_waitForWorker_959": {
      "name": "waitForWorker",
      "type": "method",
      "start_line": 959,
      "end_line": 980,
      "content_hash": "fe8fa225e64afeacd1836ec30c4b27d8394f1669",
      "content": "    async waitForWorker(sessionName, timeoutMs = 3600000) {\n        if (!validateSessionName(sessionName)) {\n            return {\n                status: \"not_found\",\n                output: \"Invalid session name\",\n            };\n        }\n        const startTime = Date.now();\n        const pollInterval = 5000; // Check every 5 seconds\n        while (Date.now() - startTime < timeoutMs) {\n            const result = await this.checkWorker(sessionName);\n            if (result.status !== \"running\") {\n                return result;\n            }\n            // Wait before checking again\n            await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        }\n        return {\n            status: \"crashed\",\n            output: \"Worker timed out\",\n        };\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}