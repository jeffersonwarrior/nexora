{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/parser/object_parse_methods.rs",
  "file_hash": "2e11b7315b32f92a3c081d32c005486334080611",
  "updated_at": "2025-12-26T17:34:22.452396",
  "symbols": {
    "impl_HelixParser_14": {
      "name": "HelixParser",
      "type": "impl",
      "start_line": 14,
      "end_line": 226,
      "content_hash": "aa5be3df971a8f8d4daff3708990ccc8b1189fb8",
      "content": "impl HelixParser {\n    pub(super) fn parse_property_assignments(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<HashMap<String, ValueType>, ParserError> {\n        pair.into_inner()\n            .map(|p| {\n                let mut pairs = p.into_inner();\n                let prop_key = pairs.try_next()?.as_str().to_string();\n\n                let value_pair = pairs.try_next().try_inner_next()?;\n\n                let prop_val = match value_pair.as_rule() {\n                    Rule::string_literal => Ok(ValueType::new(\n                        Value::from(value_pair.as_str().to_string()),\n                        value_pair.loc(),\n                    )),\n                    Rule::integer => value_pair\n                        .as_str()\n                        .parse()\n                        .map(|i| ValueType::new(Value::I32(i), value_pair.loc()))\n                        .map_err(|_| ParserError::from(\"Invalid integer value\")),\n                    Rule::float => value_pair\n                        .as_str()\n                        .parse()\n                        .map(|f| ValueType::new(Value::F64(f), value_pair.loc()))\n                        .map_err(|_| ParserError::from(\"Invalid float value\")),\n                    Rule::boolean => Ok(ValueType::new(\n                        Value::Boolean(value_pair.as_str() == \"true\"),\n                        value_pair.loc(),\n                    )),\n                    Rule::identifier => Ok(ValueType::Identifier {\n                        value: value_pair.as_str().to_string(),\n                        loc: value_pair.loc(),\n                    }),\n                    _ => Err(ParserError::from(\"Invalid property value type\")),\n                }?;\n\n                Ok((prop_key, prop_val))\n            })\n            .collect()\n    }\n\n    pub(super) fn parse_object_fields(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<Vec<FieldAddition>, ParserError> {\n        pair.into_inner()\n            .map(|p| self.parse_new_field_pair(p))\n            .collect()\n    }\n\n    pub(super) fn parse_field_value(\n        &self,\n        value_pair: Pair<Rule>,\n    ) -> Result<FieldValue, ParserError> {\n        Ok(match value_pair.as_rule() {\n            Rule::evaluates_to_anything => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Expression(self.parse_expression(value_pair)?),\n            },\n            Rule::anonymous_traversal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Traversal(Box::new(self.parse_traversal(value_pair)?)),\n            },\n            Rule::id_traversal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Traversal(Box::new(self.parse_traversal(value_pair)?)),\n            },\n            Rule::object_step => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Fields(self.parse_object_fields(value_pair)?),\n            },\n            Rule::string_literal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::String(\n                    self.parse_string_literal(value_pair)?,\n                )),\n            },\n            Rule::integer => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::I32(\n                    value_pair\n                        .as_str()\n                        .parse()\n                        .map_err(|_| ParserError::from(\"Invalid integer literal\"))?,\n                )),\n            },\n            Rule::float => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::F64(\n                    value_pair\n                        .as_str()\n                        .parse()\n                        .map_err(|_| ParserError::from(\"Invalid float literal\"))?,\n                )),\n            },\n            Rule::boolean => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::Boolean(value_pair.as_str() == \"true\")),\n            },\n            Rule::none => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Empty,\n            },\n            Rule::mapping_field => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Fields(self.parse_object_fields(value_pair)?),\n            },\n            Rule::identifier => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Identifier(value_pair.as_str().to_string()),\n            },\n            _ => {\n                return Err(ParserError::from(format!(\n                    \"Unexpected field pair type: {:?} \\n {:?}\",\n                    value_pair.as_rule(),\n                    value_pair\n                )));\n            }\n        })\n    }\n\n    pub(super) fn parse_new_field_pair(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<FieldAddition, ParserError> {\n        let mut pairs = pair.clone().into_inner();\n        let key = pairs.try_next()?.as_str().to_string();\n        let value_pair = pairs.try_next()?;\n        let value = self.parse_field_value(value_pair)?;\n\n        Ok(FieldAddition {\n            loc: pair.loc(),\n            key,\n            value,\n        })\n    }\n\n    pub(super) fn parse_new_field_value(\n        &self,\n        pair: Pair<Rule>,\n    ) -> Result<FieldValue, ParserError> {\n        let value_pair = pair.try_inner_next()?;\n        let value: FieldValue = match value_pair.as_rule() {\n            Rule::evaluates_to_anything => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Expression(self.parse_expression(value_pair)?),\n            },\n            Rule::anonymous_traversal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Traversal(Box::new(self.parse_traversal(value_pair)?)),\n            },\n            Rule::id_traversal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Traversal(Box::new(self.parse_traversal(value_pair)?)),\n            },\n            Rule::identifier => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Identifier(value_pair.as_str().to_string()),\n            },\n            Rule::object_step => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Fields(self.parse_object_fields(value_pair)?),\n            },\n            Rule::string_literal => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::String(\n                    self.parse_string_literal(value_pair)?,\n                )),\n            },\n            Rule::integer => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::I32(\n                    value_pair\n                        .as_str()\n                        .parse()\n                        .map_err(|_| ParserError::from(\"Invalid integer literal\"))?,\n                )),\n            },\n            Rule::float => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::F64(\n                    value_pair\n                        .as_str()\n                        .parse()\n                        .map_err(|_| ParserError::from(\"Invalid float literal\"))?,\n                )),\n            },\n            Rule::boolean => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Literal(Value::Boolean(value_pair.as_str() == \"true\")),\n            },\n            Rule::none => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Empty,\n            },\n            Rule::mapping_field => FieldValue {\n                loc: value_pair.loc(),\n                value: FieldValueType::Fields(self.parse_object_fields(value_pair)?),\n            },\n            _ => {\n                return Err(ParserError::from(format!(\n                    \"Unexpected field value type: {:?} \\n {:?}\",\n                    value_pair.as_rule(),\n                    value_pair,\n                )));\n            }\n        };\n\n        Ok(value)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}