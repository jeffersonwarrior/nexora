{
  "file_path": "/work/internal/indexer/watcher.go",
  "file_hash": "25960a0c1fa9283be6c717965c7b210879cb26ac",
  "updated_at": "2025-12-26T17:34:21.165749",
  "symbols": {
    "struct_FileWatcher_16": {
      "name": "FileWatcher",
      "type": "struct",
      "start_line": 16,
      "end_line": 41,
      "content_hash": "d56af8116b0908902294d9031b4d6f893690405a",
      "content": "type FileWatcher struct {\n\twatcher     *fsnotify.Watcher\n\tindexer     *Indexer\n\tparser      *ASTParser\n\tembedEngine *EmbeddingEngine\n\tctx         context.Context\n\tcancel      context.CancelFunc\n\n\t// Configuration\n\tpaths         []string\n\tignoredDirs   []string\n\tignoredExts   []string\n\tdebounceDelay time.Duration\n\n\t// State\n\tpendingFiles map[string]time.Time\n\tmu           sync.RWMutex\n\tbatchSize    int\n\n\t// Events\n\tOnFileAdded   func(string)\n\tOnFileChanged func(string)\n\tOnFileRemoved func(string)\n}\n\n// NewFileWatcher creates a new file system watcher",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewFileWatcher_42": {
      "name": "NewFileWatcher",
      "type": "function",
      "start_line": 42,
      "end_line": 65,
      "content_hash": "1128e82ab62614f902e285e19fe6542ffab98206",
      "content": "func NewFileWatcher(indexer *Indexer, parser *ASTParser, embedEngine *EmbeddingEngine) (*FileWatcher, error) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\treturn &FileWatcher{\n\t\twatcher:       watcher,\n\t\tindexer:       indexer,\n\t\tparser:        parser,\n\t\tembedEngine:   embedEngine,\n\t\tctx:           ctx,\n\t\tcancel:        cancel,\n\t\tignoredDirs:   []string{\".git\", \"node_modules\", \"vendor\", \".vscode\", \".idea\"},\n\t\tignoredExts:   []string{\".tmp\", \".log\", \".build\", \".test\"},\n\t\tdebounceDelay: 2 * time.Second,\n\t\tpendingFiles:  make(map[string]time.Time),\n\t\tbatchSize:     10,\n\t}, nil\n}\n\n// AddPath adds a directory to watch for changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_AddPath_66": {
      "name": "AddPath",
      "type": "method",
      "start_line": 66,
      "end_line": 96,
      "content_hash": "08e694ba8d894418e6f58bf9e0313892765e8036",
      "content": "func (fw *FileWatcher) AddPath(path string) error {\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the directory itself\n\terr = fw.watcher.Add(absPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfw.paths = append(fw.paths, absPath)\n\n\t// Watch subdirectories recursively\n\treturn filepath.Walk(absPath, func(walkPath string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif info.IsDir() && fw.shouldWatchDir(walkPath) {\n\t\t\tif walkErr := fw.watcher.Add(walkPath); walkErr != nil {\n\t\t\t\tslog.Warn(\"Failed to watch directory\", \"path\", walkPath, \"error\", walkErr)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// shouldWatchDir checks if a directory should be watched",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldWatchDir_97": {
      "name": "shouldWatchDir",
      "type": "method",
      "start_line": 97,
      "end_line": 107,
      "content_hash": "f78da8c4f28493f31786700ce1acf16d40dcee40",
      "content": "func (fw *FileWatcher) shouldWatchDir(path string) bool {\n\tdirName := filepath.Base(path)\n\tfor _, ignored := range fw.ignoredDirs {\n\t\tif strings.HasPrefix(dirName, ignored) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// shouldProcessFile checks if a file should be processed for indexing",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_shouldProcessFile_108": {
      "name": "shouldProcessFile",
      "type": "method",
      "start_line": 108,
      "end_line": 129,
      "content_hash": "b2346dd0541beaf9cf075a03c70ac92825d6c49b",
      "content": "func (fw *FileWatcher) shouldProcessFile(path string) bool {\n\t// Only process Go files\n\tif !strings.HasSuffix(path, \".go\") {\n\t\treturn false\n\t}\n\n\t// Skip test files if desired\n\tif strings.HasSuffix(path, \"_test.go\") {\n\t\treturn false // Could make this configurable\n\t}\n\n\t// Check ignored extensions\n\tfor _, ext := range fw.ignoredExts {\n\t\tif strings.HasSuffix(path, ext) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Start begins watching for file system changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Start_130": {
      "name": "Start",
      "type": "method",
      "start_line": 130,
      "end_line": 135,
      "content_hash": "50f485ad19de2d60615f990369e0166fd07bc175",
      "content": "func (fw *FileWatcher) Start() {\n\tgo fw.watchLoop()\n\tgo fw.debounceLoop()\n}\n\n// Stop stops the file watcher",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Stop_136": {
      "name": "Stop",
      "type": "method",
      "start_line": 136,
      "end_line": 141,
      "content_hash": "6a72f289fda99ab34958aa1ccd842ef24f54323d",
      "content": "func (fw *FileWatcher) Stop() {\n\tfw.cancel()\n\tfw.watcher.Close()\n}\n\n// watchLoop is the main event loop for file system changes",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_watchLoop_142": {
      "name": "watchLoop",
      "type": "method",
      "start_line": 142,
      "end_line": 165,
      "content_hash": "bd983081a07a07041797d3855b9da6f115465fc2",
      "content": "func (fw *FileWatcher) watchLoop() {\n\tfor {\n\t\tselect {\n\t\tcase <-fw.ctx.Done():\n\t\t\treturn\n\n\t\tcase event, ok := <-fw.watcher.Events:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfw.handleEvent(event)\n\n\t\tcase err, ok := <-fw.watcher.Errors:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tslog.Error(\"File watcher error\", \"error\", err)\n\t\t}\n\t}\n}\n\n// handleEvent processes a file system event",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_handleEvent_166": {
      "name": "handleEvent",
      "type": "method",
      "start_line": 166,
      "end_line": 196,
      "content_hash": "c536300947e9ee6a6fc33d8e7d82f65721a3a6fa",
      "content": "func (fw *FileWatcher) handleEvent(event fsnotify.Event) {\n\tif !fw.shouldProcessFile(event.Name) {\n\t\treturn\n\t}\n\n\tfw.mu.Lock()\n\tdefer fw.mu.Unlock()\n\n\t// Add to pending files with timestamp\n\tfw.pendingFiles[event.Name] = time.Now()\n\n\tswitch {\n\tcase event.Op&fsnotify.Create == fsnotify.Create:\n\t\tif fw.OnFileAdded != nil {\n\t\t\tfw.OnFileAdded(event.Name)\n\t\t}\n\n\tcase event.Op&fsnotify.Write == fsnotify.Write:\n\t\tif fw.OnFileChanged != nil {\n\t\t\tfw.OnFileChanged(event.Name)\n\t\t}\n\n\tcase event.Op&fsnotify.Remove == fsnotify.Remove:\n\t\tif fw.OnFileRemoved != nil {\n\t\t\tfw.OnFileRemoved(event.Name)\n\t\t}\n\t\tdelete(fw.pendingFiles, event.Name)\n\t}\n}\n\n// debounceLoop processes pending files after debounce delay",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_debounceLoop_197": {
      "name": "debounceLoop",
      "type": "method",
      "start_line": 197,
      "end_line": 212,
      "content_hash": "74474a7dff2b362df46c1adedcc8a485a17c149d",
      "content": "func (fw *FileWatcher) debounceLoop() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-fw.ctx.Done():\n\t\t\treturn\n\n\t\tcase now := <-ticker.C:\n\t\t\tfw.processPendingFiles(now)\n\t\t}\n\t}\n}\n\n// processPendingFiles processes files that have been stable for debounce period",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_processPendingFiles_213": {
      "name": "processPendingFiles",
      "type": "method",
      "start_line": 213,
      "end_line": 239,
      "content_hash": "3310d5be050839e9fc9c1479556ad10e6f2bfd3d",
      "content": "func (fw *FileWatcher) processPendingFiles(now time.Time) {\n\tfw.mu.Lock()\n\tdefer fw.mu.Unlock()\n\n\tready := make([]string, 0)\n\n\t// Find files that have been stable for debounce period\n\tfor file, timestamp := range fw.pendingFiles {\n\t\tif now.Sub(timestamp) >= fw.debounceDelay {\n\t\t\tready = append(ready, file)\n\t\t\tdelete(fw.pendingFiles, file)\n\t\t}\n\t}\n\n\t// Process in batches to avoid overwhelming the system\n\tfor i := 0; i < len(ready); i += fw.batchSize {\n\t\tend := i + fw.batchSize\n\t\tif end > len(ready) {\n\t\t\tend = len(ready)\n\t\t}\n\n\t\tbatch := ready[i:end]\n\t\tgo fw.processBatch(batch)\n\t}\n}\n\n// processBatch processes a batch of files",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_processBatch_240": {
      "name": "processBatch",
      "type": "method",
      "start_line": 240,
      "end_line": 248,
      "content_hash": "184204a8ce993f559de80ed3ba9ee37688e12f21",
      "content": "func (fw *FileWatcher) processBatch(files []string) {\n\tfor _, file := range files {\n\t\tif err := fw.processFile(file); err != nil {\n\t\t\tslog.Error(\"Failed to process file\", \"file\", file, \"error\", err)\n\t\t}\n\t}\n}\n\n// processFile updates the index for a single file",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_processFile_249": {
      "name": "processFile",
      "type": "method",
      "start_line": 249,
      "end_line": 280,
      "content_hash": "9f064d6d95269970dd566e7233de638cafa8f978",
      "content": "func (fw *FileWatcher) processFile(path string) error {\n\t// Remove old symbols for this file\n\tif err := fw.indexer.DeleteSymbolsByFile(fw.ctx, path); err != nil {\n\t\tslog.Warn(\"Failed to remove old symbols\", \"file\", path, \"error\", err)\n\t}\n\n\t// Parse the file for new symbols\n\tsymbols, err := fw.parser.ParseFile(fw.ctx, path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(symbols) == 0 {\n\t\treturn nil\n\t}\n\n\t// Store new symbols\n\tif err := fw.indexer.StoreSymbols(fw.ctx, symbols); err != nil {\n\t\treturn err\n\t}\n\n\t// Generate embeddings for the symbols\n\tembeddings, err := fw.embedEngine.GenerateSymbolEmbeddings(fw.ctx, symbols)\n\tif err != nil {\n\t\tslog.Warn(\"Failed to generate embeddings\", \"file\", path, \"error\", err)\n\t\treturn nil // Don't fail the whole process for embedding issues\n\t}\n\n\treturn fw.indexer.StoreEmbeddings(fw.ctx, embeddings)\n}\n\n// SetIgnoredDirs sets the list of directories to ignore",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetIgnoredDirs_281": {
      "name": "SetIgnoredDirs",
      "type": "method",
      "start_line": 281,
      "end_line": 285,
      "content_hash": "6401797018aacc8f5adb95e6cccbdf40160c5059",
      "content": "func (fw *FileWatcher) SetIgnoredDirs(dirs []string) {\n\tfw.ignoredDirs = dirs\n}\n\n// SetIgnoredExts sets the list of file extensions to ignore",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetIgnoredExts_286": {
      "name": "SetIgnoredExts",
      "type": "method",
      "start_line": 286,
      "end_line": 290,
      "content_hash": "46bc260e286e4fa964c58b4c8237061b5f66625b",
      "content": "func (fw *FileWatcher) SetIgnoredExts(exts []string) {\n\tfw.ignoredExts = exts\n}\n\n// SetDebounceDelay sets the debounce delay for processing files",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_SetDebounceDelay_291": {
      "name": "SetDebounceDelay",
      "type": "method",
      "start_line": 291,
      "end_line": 295,
      "content_hash": "14de7c32db0df985eb96831c57f8d2d605ad0afc",
      "content": "func (fw *FileWatcher) SetDebounceDelay(delay time.Duration) {\n\tfw.debounceDelay = delay\n}\n\n// IsWatching returns true if currently watching any paths",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_IsWatching_296": {
      "name": "IsWatching",
      "type": "method",
      "start_line": 296,
      "end_line": 300,
      "content_hash": "97ecd476b1c639dd6fe1013983ec471326643645",
      "content": "func (fw *FileWatcher) IsWatching() bool {\n\treturn len(fw.paths) > 0\n}\n\n// GetWatchedPaths returns the list of currently watched paths",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_GetWatchedPaths_301": {
      "name": "GetWatchedPaths",
      "type": "method",
      "start_line": 301,
      "end_line": 303,
      "content_hash": "18e82b79bbea7d89d0dd4510c4fba0a2f0455ddf",
      "content": "func (fw *FileWatcher) GetWatchedPaths() []string {\n\treturn append([]string{}, fw.paths...)\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}