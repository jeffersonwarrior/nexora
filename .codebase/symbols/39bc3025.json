{
  "file_path": "/work/internal/agent/tools/glob.go",
  "file_hash": "11f0efe112d2658a88d96bc1f2179281dfabead0",
  "updated_at": "2025-12-26T17:34:22.056689",
  "symbols": {
    "struct_GlobParams_23": {
      "name": "GlobParams",
      "type": "struct",
      "start_line": 23,
      "end_line": 27,
      "content_hash": "93bbcade7652420eca4032fd7f05eb63c172c19e",
      "content": "type GlobParams struct {\n\tPattern string `json:\"pattern\" description:\"The glob pattern to match files against\"`\n\tPath    string `json:\"path,omitempty\" description:\"The directory to search in. Defaults to the current working directory.\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_GlobResponseMetadata_28": {
      "name": "GlobResponseMetadata",
      "type": "struct",
      "start_line": 28,
      "end_line": 32,
      "content_hash": "1b98fb1d4e2ef1416e88a5293448348b866c7e29",
      "content": "type GlobResponseMetadata struct {\n\tNumberOfFiles int  `json:\"number_of_files\"`\n\tTruncated     bool `json:\"truncated\"`\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewGlobTool_33": {
      "name": "NewGlobTool",
      "type": "function",
      "start_line": 33,
      "end_line": 72,
      "content_hash": "3e2979b9458229a328ee307e34320eda9f2fd1fa",
      "content": "func NewGlobTool(workingDir string) fantasy.AgentTool {\n\treturn fantasy.NewAgentTool(\n\t\tGlobToolName,\n\t\tstring(globDescription),\n\t\tfunc(ctx context.Context, params GlobParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) {\n\t\t\tif params.Pattern == \"\" {\n\t\t\t\treturn fantasy.NewTextErrorResponse(\"pattern is required\"), nil\n\t\t\t}\n\n\t\t\tsearchPath := params.Path\n\t\t\tif searchPath == \"\" {\n\t\t\t\tsearchPath = workingDir\n\t\t\t}\n\n\t\t\tfiles, truncated, err := globFiles(ctx, params.Pattern, searchPath, 100)\n\t\t\tif err != nil {\n\t\t\t\treturn fantasy.ToolResponse{}, fmt.Errorf(\"error finding files: %w\", err)\n\t\t\t}\n\n\t\t\tvar output string\n\t\t\tif len(files) == 0 {\n\t\t\t\toutput = \"No files found\"\n\t\t\t} else {\n\t\t\t\tnormalizeFilePaths(files)\n\t\t\t\toutput = strings.Join(files, \"\\n\")\n\t\t\t\tif truncated {\n\t\t\t\t\toutput += \"\\n\\n(Results are truncated. Consider using a more specific path or pattern.)\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fantasy.WithResponseMetadata(\n\t\t\t\tfantasy.NewTextResponse(output),\n\t\t\t\tGlobResponseMetadata{\n\t\t\t\t\tNumberOfFiles: len(files),\n\t\t\t\t\tTruncated:     truncated,\n\t\t\t\t},\n\t\t\t), nil\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_globFiles_73": {
      "name": "globFiles",
      "type": "function",
      "start_line": 73,
      "end_line": 86,
      "content_hash": "7141c86bc80458831b00124de3a9bc601f73db0b",
      "content": "func globFiles(ctx context.Context, pattern, searchPath string, limit int) ([]string, bool, error) {\n\tcmdRg := getRgCmd(ctx, pattern)\n\tif cmdRg != nil {\n\t\tcmdRg.Dir = searchPath\n\t\tmatches, err := runRipgrep(cmdRg, searchPath, limit)\n\t\tif err == nil {\n\t\t\treturn matches, len(matches) >= limit && limit > 0, nil\n\t\t}\n\t\tslog.Warn(\"Ripgrep execution failed, falling back to doublestar\", \"error\", err)\n\t}\n\n\treturn fsext.GlobWithDoubleStar(pattern, searchPath, limit)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_runRipgrep_87": {
      "name": "runRipgrep",
      "type": "function",
      "start_line": 87,
      "end_line": 120,
      "content_hash": "833a9dec60b836ac6288b9894356ee3baae1b9b6",
      "content": "func runRipgrep(cmd *exec.Cmd, searchRoot string, limit int) ([]string, error) {\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tif ee, ok := err.(*exec.ExitError); ok && ee.ExitCode() == 1 {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"ripgrep: %w\\n%s\", err, out)\n\t}\n\n\tvar matches []string\n\tfor p := range bytes.SplitSeq(out, []byte{0}) {\n\t\tif len(p) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tabsPath := string(p)\n\t\tif !filepath.IsAbs(absPath) {\n\t\t\tabsPath = filepath.Join(searchRoot, absPath)\n\t\t}\n\t\tif fsext.SkipHidden(absPath) {\n\t\t\tcontinue\n\t\t}\n\t\tmatches = append(matches, absPath)\n\t}\n\n\tsort.SliceStable(matches, func(i, j int) bool {\n\t\treturn len(matches[i]) < len(matches[j])\n\t})\n\n\tif limit > 0 && len(matches) > limit {\n\t\tmatches = matches[:limit]\n\t}\n\treturn matches, nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeFilePaths_121": {
      "name": "normalizeFilePaths",
      "type": "function",
      "start_line": 121,
      "end_line": 125,
      "content_hash": "4d05349742cdda5c16631ec9f188eb133db33a2a",
      "content": "func normalizeFilePaths(paths []string) {\n\tfor i, p := range paths {\n\t\tpaths[i] = filepath.ToSlash(p)\n\t}\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}