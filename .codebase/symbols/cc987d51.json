{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/tests/traversal_tests/edge_traversal_tests.rs",
  "file_hash": "d0dec56298678ae82831500d03eeb65a44d502bf",
  "updated_at": "2025-12-26T17:34:23.925943",
  "symbols": {
    "function_setup_test_db_34": {
      "name": "setup_test_db",
      "type": "function",
      "start_line": 34,
      "end_line": 45,
      "content_hash": "34cee3a1054f593771d88e8310cf09da65e1bcaa",
      "content": "fn setup_test_db() -> (TempDir, Arc<HelixGraphStorage>) {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let storage = HelixGraphStorage::new(\n        db_path,\n        crate::helix_engine::traversal_core::config::Config::default(),\n        Default::default(),\n    )\n    .unwrap();\n    (temp_dir, Arc::new(storage))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_edge_id_46": {
      "name": "edge_id",
      "type": "function",
      "start_line": 46,
      "end_line": 53,
      "content_hash": "e0fbebecc0bc25edf589b6afe09f434ba23be9e4",
      "content": "fn edge_id(value: &TraversalValue) -> u128 {\n    match value {\n        TraversalValue::Edge(edge) => edge.id,\n        _ => panic!(\"expected edge\"),\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_add_edge_creates_relationship_54": {
      "name": "test_add_edge_creates_relationship",
      "type": "function",
      "start_line": 54,
      "end_line": 82,
      "content_hash": "c888bb46c6e0cf25a0fe1664aefb2ca18e861529",
      "content": "fn test_add_edge_creates_relationship() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let target_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n\n    let edge = G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, source_id, target_id, false)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let fetched = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge.id())\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(fetched.len(), 1);\n    assert_eq!(edge_id(&fetched[0]), edge.id());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_e_returns_edge_83": {
      "name": "test_out_e_returns_edge",
      "type": "function",
      "start_line": 83,
      "end_line": 111,
      "content_hash": "efe8e3116520fb75c45fd54e116437ebdf8d115d",
      "content": "fn test_out_e_returns_edge() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let target_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, source_id, target_id, false)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&source_id)\n        .out_e(\"knows\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(edges.len(), 1);\n    assert_eq!(edges[0].id(), edge_id(&edges[0]));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_in_e_returns_edge_112": {
      "name": "test_in_e_returns_edge",
      "type": "function",
      "start_line": 112,
      "end_line": 140,
      "content_hash": "bfa42a662f44e23962e9ffbb405a81ffaa16fbdf",
      "content": "fn test_in_e_returns_edge() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let target_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, source_id, target_id, false)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edges = G::new(&storage, &txn, &arena)\n        .n_from_id(&target_id)\n        .in_e(\"knows\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(edges.len(), 1);\n    assert_eq!(edge_id(&edges[0]), edges[0].id());\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_out_node_returns_neighbor_141": {
      "name": "test_out_node_returns_neighbor",
      "type": "function",
      "start_line": 141,
      "end_line": 169,
      "content_hash": "3ff7207c7c75ab1bde7d280ff5b54140cb9931b4",
      "content": "fn test_out_node_returns_neighbor() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let neighbor_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, source_id, neighbor_id, false)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let neighbors = G::new(&storage, &txn, &arena)\n        .n_from_id(&source_id)\n        .out_node(\"knows\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(neighbors.len(), 1);\n    assert_eq!(neighbors[0].id(), neighbor_id);\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_properties_can_be_read_170": {
      "name": "test_edge_properties_can_be_read",
      "type": "function",
      "start_line": 170,
      "end_line": 211,
      "content_hash": "9e1bf80996373aa2fa2c73d7bac7d1db4448716c",
      "content": "fn test_edge_properties_can_be_read() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let target_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\n            \"knows\",\n            props_option(&arena, props! { \"since\" => 2024 }),\n            source_id,\n            target_id,\n            false,\n        )\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edge = G::new(&storage, &txn, &arena)\n        .e_from_type(\"knows\")\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(edge.len(), 1);\n    if let TraversalValue::Edge(edge) = &edge[0] {\n        match edge.properties.as_ref().unwrap().get(\"since\").unwrap() {\n            Value::I64(year) => assert_eq!(*year, 2024),\n            Value::I32(year) => assert_eq!(*year, 2024),\n            other => panic!(\"unexpected value {other:?}\"),\n        }\n    } else {\n        panic!(\"expected edge\");\n    }\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_vector_edges_roundtrip_212": {
      "name": "test_vector_edges_roundtrip",
      "type": "function",
      "start_line": 212,
      "end_line": 252,
      "content_hash": "ca913d0d6089d143debcd5a6e36f34bb23c18742",
      "content": "fn test_vector_edges_roundtrip() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    let node_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"doc\", None, None)\n        .collect::<Result<Vec<_>,_>>().unwrap()[0]\n        .id();\n    let vector_id = match G::new_mut(&storage, &arena, &mut txn)\n        .insert_v::<Filter>(&[1.0, 0.0, 0.0], \"embedding\", None)\n        .collect_to_obj().unwrap()\n    {\n        TraversalValue::Vector(vector) => vector.id,\n        TraversalValue::VectorNodeWithoutVectorData(vector) => *vector.id(),\n        other => panic!(\"unexpected traversal value: {other:?}\"),\n    };\n    G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"has_vector\", None, node_id, vector_id, false)\n        .collect_to_obj().unwrap();\n    txn.commit().unwrap();\n\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let vectors = G::new(&storage, &txn, &arena)\n        .n_from_id(&node_id)\n        .out_vec(\"has_vector\", true)\n        .collect::<Result<Vec<_>,_>>().unwrap();\n    assert_eq!(vectors.len(), 1);\n    match &vectors[0] {\n        TraversalValue::Vector(vec) => assert_eq!(*vec.id(), vector_id),\n        TraversalValue::VectorNodeWithoutVectorData(vec) => assert_eq!(*vec.id(), vector_id),\n        other => panic!(\"unexpected traversal value: {other:?}\"),\n    }\n}\n\n// ============================================================================\n// Error Tests for e_from_id\n// ============================================================================\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_id_with_nonexistent_id_253": {
      "name": "test_e_from_id_with_nonexistent_id",
      "type": "function",
      "start_line": 253,
      "end_line": 270,
      "content_hash": "15b34e8c64bc962623293898cfd2a821d9e630bb",
      "content": "fn test_e_from_id_with_nonexistent_id() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    // Generate a random ID that doesn't exist\n    let fake_id = uuid::Uuid::new_v4().as_u128();\n\n    // Attempt to query\n    let result = G::new(&storage, &txn, &arena)\n        .e_from_id(&fake_id)\n        .collect_to_obj();\n\n    // Assert it returns EdgeNotFound error\n    assert!(matches!(result, Err(GraphError::EdgeNotFound)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_id_with_deleted_edge_271": {
      "name": "test_e_from_id_with_deleted_edge",
      "type": "function",
      "start_line": 271,
      "end_line": 325,
      "content_hash": "6c93c31f281160f4d5e3ab7c226320b155c72245",
      "content": "fn test_e_from_id_with_deleted_edge() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let mut txn = storage.graph_env.write_txn().unwrap();\n\n    // Create two nodes and an edge between them\n    let source_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n    let target_id = G::new_mut(&storage, &arena, &mut txn)\n        .add_n(\"person\", None, None)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap()[0]\n        .id();\n\n    let edge = G::new_mut(&storage, &arena, &mut txn)\n        .add_edge(\"knows\", None, source_id, target_id, false)\n        .collect_to_obj()\n        .unwrap();\n    let edge_id = edge.id();\n\n    txn.commit().unwrap();\n\n    // Delete the edge\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let edge_to_delete = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge_id)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n    drop(txn);\n\n    let mut txn = storage.graph_env.write_txn().unwrap();\n    Drop::drop_traversal(\n        edge_to_delete.into_iter().map(Ok::<_, GraphError>),\n        storage.as_ref(),\n        &mut txn,\n    )\n    .unwrap();\n    txn.commit().unwrap();\n\n    // Try to query the deleted edge\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n    let result = G::new(&storage, &txn, &arena)\n        .e_from_id(&edge_id)\n        .collect_to_obj();\n\n    // Assert it returns EdgeNotFound error\n    assert!(matches!(result, Err(GraphError::EdgeNotFound)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_id_with_zero_id_326": {
      "name": "test_e_from_id_with_zero_id",
      "type": "function",
      "start_line": 326,
      "end_line": 340,
      "content_hash": "bcc4135d4133019c70896fc54cfa6ce7aedac8be",
      "content": "fn test_e_from_id_with_zero_id() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    // Query with ID = 0\n    let result = G::new(&storage, &txn, &arena)\n        .e_from_id(&0)\n        .collect_to_obj();\n\n    // Assert it returns EdgeNotFound error\n    assert!(matches!(result, Err(GraphError::EdgeNotFound)));\n}\n\n#[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_e_from_id_with_max_id_341": {
      "name": "test_e_from_id_with_max_id",
      "type": "function",
      "start_line": 341,
      "end_line": 353,
      "content_hash": "a414d7c7172f3b75a4e0787d800b35738ed8ac6a",
      "content": "fn test_e_from_id_with_max_id() {\n    let (_temp_dir, storage) = setup_test_db();\n    let arena = Bump::new();\n    let txn = storage.graph_env.read_txn().unwrap();\n\n    // Query with ID = u128::MAX\n    let result = G::new(&storage, &txn, &arena)\n        .e_from_id(&u128::MAX)\n        .collect_to_obj();\n\n    // Assert it returns EdgeNotFound error\n    assert!(matches!(result, Err(GraphError::EdgeNotFound)));\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}