{
  "file_path": "/work/internal/agent/recovery/file_outdated.go",
  "file_hash": "c54b44bbc87aa68d73e51e81cf07e10243b0c807",
  "updated_at": "2025-12-26T17:34:20.730990",
  "symbols": {
    "struct_FileOutdatedStrategy_14": {
      "name": "FileOutdatedStrategy",
      "type": "struct",
      "start_line": 14,
      "end_line": 15,
      "content_hash": "710599ee03943834bb0118ef5e0606193f320e03",
      "content": "type FileOutdatedStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_16": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 16,
      "end_line": 24,
      "content_hash": "431e6aaf42e524dc56920ea07925a0e3f0ec035a",
      "content": "func (s *FileOutdatedStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypeFileOutdated\n\t}\n\treturn strings.Contains(err.Error(), \"file has been modified\") ||\n\t\tstrings.Contains(err.Error(), \"file outdated\") ||\n\t\tstrings.Contains(err.Error(), \"stale data\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_25": {
      "name": "Recover",
      "type": "method",
      "start_line": 25,
      "end_line": 53,
      "content_hash": "b0288fecccecd08fab39230d743f57dfaed38b6c",
      "content": "func (s *FileOutdatedStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\t// Extract file path from error context\n\tvar filePath string\n\tif re, ok := err.(*RecoverableError); ok && re.Context != nil {\n\t\tif path, exists := re.Context[\"file_path\"]; exists {\n\t\t\tfilePath = path.(string)\n\t\t}\n\t}\n\n\tif filePath == \"\" {\n\t\treturn fmt.Errorf(\"cannot recover from file outdated error: no file path provided\")\n\t}\n\n\t// Validate file exists\n\tif _, statErr := os.Stat(filePath); os.IsNotExist(statErr) {\n\t\treturn fmt.Errorf(\"file %s no longer exists: %w\", filePath, statErr)\n\t}\n\n\t// Record recovery attempt\n\texecCtx.LastError = fmt.Errorf(\"file %s was outdated, re-reading file\", filePath)\n\n\t// In a real implementation, we would:\n\t// 1. Re-read the file content\n\t// 2. Update any cached content\n\t// 3. Signal to retry the operation with fresh data\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_54": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 54,
      "end_line": 57,
      "content_hash": "7e444b791c1dc4b33720c8fe17ed1432482e287d",
      "content": "func (s *FileOutdatedStrategy) MaxRetries() int {\n\treturn 2 // Re-reading files should work quickly\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_58": {
      "name": "Name",
      "type": "method",
      "start_line": 58,
      "end_line": 62,
      "content_hash": "c2324455add1bece22f4a06c9dfc9ff4ed604c96",
      "content": "func (s *FileOutdatedStrategy) Name() string {\n\treturn \"File Outdated Recovery\"\n}\n\n// EditFailedStrategy handles edit operation failures",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EditFailedStrategy_63": {
      "name": "EditFailedStrategy",
      "type": "struct",
      "start_line": 63,
      "end_line": 64,
      "content_hash": "fb1cf7834f6aab729cf1a096a855c2f37ed63a78",
      "content": "type EditFailedStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_65": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 65,
      "end_line": 74,
      "content_hash": "87ddd36556bf0f8a8238d9b5422f301cf1ad73af",
      "content": "func (s *EditFailedStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypeEditFailed\n\t}\n\treturn strings.Contains(err.Error(), \"edit failed\") ||\n\t\tstrings.Contains(err.Error(), \"whitespace mismatch\") ||\n\t\tstrings.Contains(err.Error(), \"text not found\") ||\n\t\tstrings.Contains(err.Error(), \"edit tool failed\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_75": {
      "name": "Recover",
      "type": "method",
      "start_line": 75,
      "end_line": 116,
      "content_hash": "d1a5dc85735ad8b106a57ef54905ebb371700b99",
      "content": "func (s *EditFailedStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\t// Extract edit context\n\tvar filePath, oldText string\n\tif re, ok := err.(*RecoverableError); ok && re.Context != nil {\n\t\tfilePath, _ = re.Context[\"file_path\"].(string)\n\t\toldText, _ = re.Context[\"old_text\"].(string)\n\t}\n\n\tif filePath == \"\" {\n\t\treturn fmt.Errorf(\"cannot recover from edit failure: no file path provided\")\n\t}\n\n\t// Record recovery attempt\n\texecCtx.LastError = fmt.Errorf(\"edit failed on %s, attempting recovery\", filePath)\n\n\t// Recovery strategies:\n\t// 1. Try to read the current file content\n\t// 2. If we have oldText and newText, attempt a more robust edit\n\t// 3. Fall back to AIOPS-powered fix if available\n\n\tcontent, readErr := os.ReadFile(filePath)\n\tif readErr != nil {\n\t\treturn fmt.Errorf(\"cannot read file for recovery: %w\", readErr)\n\t}\n\n\tcurrentContent := string(content)\n\n\t// Try to find exact match with normalized whitespace\n\tif oldText != \"\" {\n\t\tnormalizedCurrent := normalizeWhitespace(currentContent)\n\t\tnormalizedOld := normalizeWhitespace(oldText)\n\n\t\tif strings.Contains(normalizedCurrent, normalizedOld) {\n\t\t\t// We can potentially recover, signal to retry\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Fall back: suggest using write tool to replace entire file\n\treturn fmt.Errorf(\"edit recovery failed - suggest using write tool to replace entire file\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_117": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 117,
      "end_line": 120,
      "content_hash": "6d4c7b173b11f1274b73291d65050628854373c3",
      "content": "func (s *EditFailedStrategy) MaxRetries() int {\n\treturn 3 // Edits can fail due to whitespace issues\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_121": {
      "name": "Name",
      "type": "method",
      "start_line": 121,
      "end_line": 125,
      "content_hash": "24255b20d6a1c9e63b133e9204063fabb044cedc",
      "content": "func (s *EditFailedStrategy) Name() string {\n\treturn \"Edit Failed Recovery\"\n}\n\n// LoopDetectedStrategy handles infinite loop detection",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_LoopDetectedStrategy_126": {
      "name": "LoopDetectedStrategy",
      "type": "struct",
      "start_line": 126,
      "end_line": 127,
      "content_hash": "ade4ff3f6daee44fd18c7996f8cd34683495e820",
      "content": "type LoopDetectedStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_128": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 128,
      "end_line": 136,
      "content_hash": "36a8a5b8e0df962cfc1d1f474e503552592fab40",
      "content": "func (s *LoopDetectedStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypeLoopDetected\n\t}\n\treturn strings.Contains(err.Error(), \"loop detected\") ||\n\t\tstrings.Contains(err.Error(), \"infinite loop\") ||\n\t\tstrings.Contains(err.Error(), \"stuck in loop\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_137": {
      "name": "Recover",
      "type": "method",
      "start_line": 137,
      "end_line": 148,
      "content_hash": "4bb525b18ac680ae9466da0af5b3de1765477696",
      "content": "func (s *LoopDetectedStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\t// For loop detection, recovery means stopping the loop and returning control\n\texecCtx.LastError = fmt.Errorf(\"loop detected, halting execution and returning to user\")\n\n\t// In a complete implementation, this would:\n\t// 1. Transition state machine to StateHalted\n\t// 2. Provide a summary of what was being done\n\t// 3. Suggest next steps to the user\n\n\treturn fmt.Errorf(\"loop detected - execution halted to prevent infinite loop\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_149": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 149,
      "end_line": 152,
      "content_hash": "1ecb4d76714c794762cf3a3fcc31baebf4aeec1f",
      "content": "func (s *LoopDetectedStrategy) MaxRetries() int {\n\treturn 0 // No retries for loops - always halt\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_153": {
      "name": "Name",
      "type": "method",
      "start_line": 153,
      "end_line": 157,
      "content_hash": "2507fa65de04d5fda1457d4d66b8ce467d9a9909",
      "content": "func (s *LoopDetectedStrategy) Name() string {\n\treturn \"Loop Detected Recovery\"\n}\n\n// TimeoutStrategy handles operation timeouts",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_TimeoutStrategy_158": {
      "name": "TimeoutStrategy",
      "type": "struct",
      "start_line": 158,
      "end_line": 159,
      "content_hash": "debd28ed85becbb12dea0ba6660c011511e8229e",
      "content": "type TimeoutStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_160": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 160,
      "end_line": 168,
      "content_hash": "2b79eb208a79af54b03701533c77fc98fe172f7f",
      "content": "func (s *TimeoutStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypeTimeout\n\t}\n\treturn strings.Contains(err.Error(), \"timeout\") ||\n\t\tstrings.Contains(err.Error(), \"deadline exceeded\") ||\n\t\tstrings.Contains(err.Error(), \"context deadline exceeded\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_169": {
      "name": "Recover",
      "type": "method",
      "start_line": 169,
      "end_line": 189,
      "content_hash": "4f9ae8442ced68f629dd4b5d31e322f919c75d90",
      "content": "func (s *TimeoutStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\t// Extract operation context\n\tvar operation string\n\tif re, ok := err.(*RecoverableError); ok && re.Context != nil {\n\t\toperation, _ = re.Context[\"operation\"].(string)\n\t}\n\n\tif operation == \"\" {\n\t\toperation = \"operation\"\n\t}\n\n\texecCtx.LastError = fmt.Errorf(\"%s timed out\", operation)\n\n\t// For timeout recovery:\n\t// 1. Check if operation can be retried with longer timeout\n\t// 2. Suggest breaking down into smaller operations\n\t// 3. For long-running operations, suggest background execution\n\n\treturn fmt.Errorf(\"%s timed out - try with longer timeout or break into smaller steps\", operation)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_190": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 190,
      "end_line": 193,
      "content_hash": "7818d3812249a69723791cc62fe42ae69d76e981",
      "content": "func (s *TimeoutStrategy) MaxRetries() int {\n\treturn 1 // One retry with potentially longer timeout\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_194": {
      "name": "Name",
      "type": "method",
      "start_line": 194,
      "end_line": 198,
      "content_hash": "15ed87684e63f3bd574e658280fa46e97e29b927",
      "content": "func (s *TimeoutStrategy) Name() string {\n\treturn \"Timeout Recovery\"\n}\n\n// ResourceLimitStrategy handles resource exhaustion",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ResourceLimitStrategy_199": {
      "name": "ResourceLimitStrategy",
      "type": "struct",
      "start_line": 199,
      "end_line": 200,
      "content_hash": "1000eef00517293a3c8fb8ee56127cb8d19f7c3c",
      "content": "type ResourceLimitStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_201": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 201,
      "end_line": 210,
      "content_hash": "e3abaa64608de06c81d13670a300b33a818dc729",
      "content": "func (s *ResourceLimitStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypeResourceLimit\n\t}\n\treturn strings.Contains(err.Error(), \"resource limit\") ||\n\t\tstrings.Contains(err.Error(), \"memory\") && strings.Contains(err.Error(), \"insufficient\") ||\n\t\tstrings.Contains(err.Error(), \"disk space\") ||\n\t\tstrings.Contains(err.Error(), \"cpu usage\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_211": {
      "name": "Recover",
      "type": "method",
      "start_line": 211,
      "end_line": 231,
      "content_hash": "cc029677ad63d3721e3b23648e6c2901eea570a8",
      "content": "func (s *ResourceLimitStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\t// Extract resource type\n\tvar resourceType string\n\tif re, ok := err.(*RecoverableError); ok && re.Context != nil {\n\t\tresourceType, _ = re.Context[\"resource_type\"].(string)\n\t}\n\n\tif resourceType == \"\" {\n\t\tresourceType = \"system resource\"\n\t}\n\n\texecCtx.LastError = fmt.Errorf(\"%s limit reached\", resourceType)\n\n\t// Resource recovery strategies:\n\t// 1. Transition to paused state if not already\n\t// 2. Wait for resources to become available\n\t// 3. Suggest freeing up resources\n\n\treturn fmt.Errorf(\"%s limit reached - system will pause and retry when resources are available\", resourceType)\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_232": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 232,
      "end_line": 235,
      "content_hash": "526b963616c0395a7e725b141e12ba7887492874",
      "content": "func (s *ResourceLimitStrategy) MaxRetries() int {\n\treturn 5 // Resources may become available\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_236": {
      "name": "Name",
      "type": "method",
      "start_line": 236,
      "end_line": 240,
      "content_hash": "38f69e71e4fb3b4826ea69ab6121f0307126417f",
      "content": "func (s *ResourceLimitStrategy) Name() string {\n\treturn \"Resource Limit Recovery\"\n}\n\n// PanicStrategy handles panic recovery",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_PanicStrategy_241": {
      "name": "PanicStrategy",
      "type": "struct",
      "start_line": 241,
      "end_line": 242,
      "content_hash": "92ecdf270d77f4f5f485c473de684aa0cc276c13",
      "content": "type PanicStrategy struct{}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_CanRecover_243": {
      "name": "CanRecover",
      "type": "method",
      "start_line": 243,
      "end_line": 250,
      "content_hash": "54ca1aaa20afd5f9d0fa2e2496861b06002f39f3",
      "content": "func (s *PanicStrategy) CanRecover(err error) bool {\n\tif re, ok := err.(*RecoverableError); ok {\n\t\treturn re.ErrorType == ErrorTypePanic\n\t}\n\treturn strings.Contains(err.Error(), \"panic\") ||\n\t\tstrings.Contains(err.Error(), \"runtime panic\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Recover_251": {
      "name": "Recover",
      "type": "method",
      "start_line": 251,
      "end_line": 264,
      "content_hash": "ad2343a3d7f1c54619a43a7f1cbdcadf6715f2ad",
      "content": "func (s *PanicStrategy) Recover(ctx context.Context, err error, execCtx *state.AgentExecutionContext) error {\n\texecCtx.LastError = fmt.Errorf(\"panic recovered: %v\", err)\n\n\t// Panic recovery:\n\t// 1. Log the panic and stack trace\n\t// 2. Transition to recovery state\n\t// 3. Attempt graceful shutdown or restart\n\n\t// In a complete implementation, this would capture the stack trace\n\t// and perform more sophisticated recovery\n\n\treturn fmt.Errorf(\"panic occurred - system recovered and continuing safely\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_MaxRetries_265": {
      "name": "MaxRetries",
      "type": "method",
      "start_line": 265,
      "end_line": 268,
      "content_hash": "7b11162e7dce6d482ab32e2bb1d90bc643983002",
      "content": "func (s *PanicStrategy) MaxRetries() int {\n\treturn 1 // Limited retries for panics\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_Name_269": {
      "name": "Name",
      "type": "method",
      "start_line": 269,
      "end_line": 273,
      "content_hash": "2ce2d77ff208afe823a7a2e93b9004fffbbf7709",
      "content": "func (s *PanicStrategy) Name() string {\n\treturn \"Panic Recovery\"\n}\n\n// Helper function to normalize whitespace for comparison",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_normalizeWhitespace_274": {
      "name": "normalizeWhitespace",
      "type": "function",
      "start_line": 274,
      "end_line": 282,
      "content_hash": "2497821d9605ef1f4af1ad7a88638366733af135",
      "content": "func normalizeWhitespace(text string) string {\n\t// Convert tabs to spaces\n\ttext = strings.ReplaceAll(text, \"\\t\", \"    \")\n\t// Normalize multiple spaces to single space\n\ttext = strings.Join(strings.Fields(text), \" \")\n\treturn text\n}\n\n// Create convenience functions for creating common recoverable errors",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewFileOutdatedError_283": {
      "name": "NewFileOutdatedError",
      "type": "function",
      "start_line": 283,
      "end_line": 289,
      "content_hash": "3f41eb2f7f7948c970218e7b6eff16bde6fcb470",
      "content": "func NewFileOutdatedError(err error, filePath string) error {\n\treturn NewRecoverableError(err, ErrorTypeFileOutdated, map[string]interface{}{\n\t\t\"file_path\": filePath,\n\t\t\"timestamp\": time.Now(),\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewEditFailedError_290": {
      "name": "NewEditFailedError",
      "type": "function",
      "start_line": 290,
      "end_line": 298,
      "content_hash": "94921cf6dd0933cbbf43be005defb23d752e1064",
      "content": "func NewEditFailedError(err error, filePath, oldText, newText string) error {\n\treturn NewRecoverableError(err, ErrorTypeEditFailed, map[string]interface{}{\n\t\t\"file_path\": filePath,\n\t\t\"old_text\":  oldText,\n\t\t\"new_text\":  newText,\n\t\t\"timestamp\": time.Now(),\n\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewLoopDetectedError_299": {
      "name": "NewLoopDetectedError",
      "type": "function",
      "start_line": 299,
      "end_line": 307,
      "content_hash": "8641968888a409fcc62a2ab963609c4affce2c02",
      "content": "func NewLoopDetectedError(operation string, iterations int) error {\n\treturn NewRecoverableError(fmt.Errorf(\"loop detected after %d iterations in %s\", iterations, operation),\n\t\tErrorTypeLoopDetected, map[string]interface{}{\n\t\t\t\"operation\":  operation,\n\t\t\t\"iterations\": iterations,\n\t\t\t\"timestamp\":  time.Now(),\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewTimeoutError_308": {
      "name": "NewTimeoutError",
      "type": "function",
      "start_line": 308,
      "end_line": 316,
      "content_hash": "a32ed5f1bd80dd64f05e0306956d390c291a02a6",
      "content": "func NewTimeoutError(operation string, timeout time.Duration) error {\n\treturn NewRecoverableError(fmt.Errorf(\"%s timed out after %v\", operation, timeout),\n\t\tErrorTypeTimeout, map[string]interface{}{\n\t\t\t\"operation\": operation,\n\t\t\t\"timeout\":   timeout,\n\t\t\t\"timestamp\": time.Now(),\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewResourceLimitError_317": {
      "name": "NewResourceLimitError",
      "type": "function",
      "start_line": 317,
      "end_line": 326,
      "content_hash": "b88a4ddd0ef85696e6b2248537195c33590c4ba7",
      "content": "func NewResourceLimitError(resourceType string, current, limit interface{}) error {\n\treturn NewRecoverableError(fmt.Errorf(\"%s limit reached (current: %v, limit: %v)\", resourceType, current, limit),\n\t\tErrorTypeResourceLimit, map[string]interface{}{\n\t\t\t\"resource_type\": resourceType,\n\t\t\t\"current\":       current,\n\t\t\t\"limit\":         limit,\n\t\t\t\"timestamp\":     time.Now(),\n\t\t})\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_NewPanicError_327": {
      "name": "NewPanicError",
      "type": "function",
      "start_line": 327,
      "end_line": 332,
      "content_hash": "cf52a4b583f8a46fc71899d4725b2feaf3ea4769",
      "content": "func NewPanicError(err error, stackTrace string) error {\n\treturn NewRecoverableError(err, ErrorTypePanic, map[string]interface{}{\n\t\t\"stack_trace\": stackTrace,\n\t\t\"timestamp\":   time.Now(),\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}