{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/vector_core/vector_without_data.rs",
  "file_hash": "362b14655f874cf2e3a2e9f5b557dda39ca64897",
  "updated_at": "2025-12-26T17:34:20.843942",
  "symbols": {
    "struct_VectorWithoutData_16": {
      "name": "VectorWithoutData",
      "type": "struct",
      "start_line": 16,
      "end_line": 33,
      "content_hash": "82349f271b74a4d844cbda811ce01fd01d94e9a7",
      "content": "pub struct VectorWithoutData<'arena> {\n    /// The id of the HVector\n    pub id: u128,\n    /// The label of the HVector\n    pub label: &'arena str,\n    /// the version of the vector\n    pub version: u8,\n    /// whether the vector is deleted\n    pub deleted: bool,\n    /// The level of the HVector\n    pub level: usize,\n\n    /// The properties of the HVector\n    pub properties: Option<ImmutablePropertiesMap<'arena>>,\n}\n\n// Custom Serialize implementation to conditionally include id field\n// For JSON serialization, the id field is included, but for bincode it is skipped",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_34": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 34,
      "end_line": 71,
      "content_hash": "58951ff3f0a544cfe6b1af91c8621956f40acbbe",
      "content": "impl<'arena> Serialize for VectorWithoutData<'arena> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        // Check if this is a human-readable format (like JSON)\n        if serializer.is_human_readable() {\n            // Include id for JSON serialization\n            let mut buffer = [0u8; 36];\n            let mut state = serializer.serialize_map(Some(\n                6 + self.properties.as_ref().map(|p| p.len()).unwrap_or(0),\n            ))?;\n            state.serialize_entry(\"id\", uuid_str_from_buf(self.id, &mut buffer))?;\n            state.serialize_entry(\"label\", self.label)?;\n            state.serialize_entry(\"version\", &self.version)?;\n            state.serialize_entry(\"deleted\", &self.deleted)?;\n            state.serialize_entry(\"level\", &self.level)?;\n            if let Some(properties) = &self.properties {\n                for (key, value) in properties.iter() {\n                    state.serialize_entry(key, value)?;\n                }\n            }\n            state.end()\n        } else {\n            // Skip id for bincode serialization\n            let mut state = serializer.serialize_struct(\"VectorWithoutData\", 5)?;\n            state.serialize_field(\"label\", self.label)?;\n            state.serialize_field(\"version\", &self.version)?;\n            state.serialize_field(\"deleted\", &self.deleted)?;\n            state.serialize_field(\"level\", &self.level)?;\n            state.serialize_field(\"properties\", &self.properties)?;\n            state.end()\n        }\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Debug_72": {
      "name": "Debug",
      "type": "impl",
      "start_line": 72,
      "end_line": 72,
      "content_hash": "f032ebd8022fa29647fc22ee4c745388d3b5b514",
      "content": "impl Debug for VectorWithoutData<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_73": {
      "name": "fmt",
      "type": "method",
      "start_line": 73,
      "end_line": 82,
      "content_hash": "8009be7a682ab22bb98b6f82e0e3b7f1e63b2fda",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{{ \\nid: {},\\nlevel: {} }}\",\n            uuid::Uuid::from_u128(self.id),\n            self.level,\n        )\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_VectorWithoutData_83": {
      "name": "VectorWithoutData",
      "type": "impl",
      "start_line": 83,
      "end_line": 84,
      "content_hash": "6df7cb42a1ad2f92a7169ae2dad41b656a3eda77",
      "content": "impl<'arena> VectorWithoutData<'arena> {\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_properties_85": {
      "name": "from_properties",
      "type": "method",
      "start_line": 85,
      "end_line": 113,
      "content_hash": "8f0bb1bd7138d8f3b1901e7202a5bf365d7f9e9a",
      "content": "    pub fn from_properties(\n        id: u128,\n        label: &'arena str,\n        level: usize,\n        properties: ImmutablePropertiesMap<'arena>,\n    ) -> Self {\n        VectorWithoutData {\n            id,\n            label,\n            version: 1,\n            level,\n            properties: Some(properties),\n            deleted: false,\n        }\n    }\n\n    pub fn from_bincode_bytes<'txn>(\n        arena: &'arena bumpalo::Bump,\n        properties: &'txn [u8],\n        id: u128,\n    ) -> Result<Self, VectorError> {\n        bincode::options()\n            .with_fixint_encoding()\n            .allow_trailing_bytes()\n            .deserialize_seed(VectoWithoutDataDeSeed { arena, id }, properties)\n            .map_err(|e| VectorError::ConversionError(format!(\"Error deserializing vector: {e}\")))\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_to_bincode_bytes_114": {
      "name": "to_bincode_bytes",
      "type": "method",
      "start_line": 114,
      "end_line": 118,
      "content_hash": "81e276d513e595b15d14cd6017e35f9fb348fd78",
      "content": "    pub fn to_bincode_bytes(&self) -> Result<Vec<u8>, bincode::Error> {\n        bincode::serialize(self)\n    }\n    /// Returns the id of the HVector\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_id_119": {
      "name": "get_id",
      "type": "method",
      "start_line": 119,
      "end_line": 124,
      "content_hash": "ea36e5151ca8c519ad8f5bfe66020d7eb277512b",
      "content": "    pub fn get_id(&self) -> u128 {\n        self.id\n    }\n\n    /// Returns the level of the HVector\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_level_125": {
      "name": "get_level",
      "type": "method",
      "start_line": 125,
      "end_line": 129,
      "content_hash": "7c26289f53b1650b53729478da602762d5e8d859",
      "content": "    pub fn get_level(&self) -> usize {\n        self.level\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_label_130": {
      "name": "get_label",
      "type": "method",
      "start_line": 130,
      "end_line": 134,
      "content_hash": "8c6b44a5714ca88b967de73879718c300cbf6f3e",
      "content": "    pub fn get_label(&self) -> &'arena str {\n        self.label\n    }\n\n    #[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_property_135": {
      "name": "get_property",
      "type": "method",
      "start_line": 135,
      "end_line": 138,
      "content_hash": "3a8265ece109f95318a2ef540c55776ef93aeaa3",
      "content": "    pub fn get_property(&self, key: &str) -> Option<&'arena Value> {\n        self.properties.as_ref().and_then(|value| value.get(key))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_id_139": {
      "name": "id",
      "type": "method",
      "start_line": 139,
      "end_line": 142,
      "content_hash": "91cbe510e3ff9eb683227e2fd287978f372c9a7e",
      "content": "    pub fn id(&self) -> &u128 {\n        &self.id\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_label_143": {
      "name": "label",
      "type": "method",
      "start_line": 143,
      "end_line": 147,
      "content_hash": "95a03a77b9dc0751963641c945a3f1e58bdb84d0",
      "content": "    pub fn label(&self) -> &'arena str {\n        self.label\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_148": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 148,
      "end_line": 148,
      "content_hash": "3c931d8f7d5235046b60002a679151c7827f892f",
      "content": "impl PartialEq for VectorWithoutData<'_> {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_149": {
      "name": "eq",
      "type": "method",
      "start_line": 149,
      "end_line": 152,
      "content_hash": "e42e74568e66462fe2136c6e1059be269af7bdfd",
      "content": "    fn eq(&self, other: &Self) -> bool {\n        self.id == other.id\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_153": {
      "name": "Eq",
      "type": "impl",
      "start_line": 153,
      "end_line": 153,
      "content_hash": "45b1cd034607bfbef5c056836a3c183bd55f8b3b",
      "content": "impl Eq for VectorWithoutData<'_> {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}