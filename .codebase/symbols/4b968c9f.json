{
  "file_path": "/work/internal/tui/components/dialogs/models/list_recent_test.go",
  "file_hash": "caad877164d58b562b5ac663f67909d40274536a",
  "updated_at": "2025-12-26T17:34:21.177455",
  "symbols": {
    "function_execCmdML_20": {
      "name": "execCmdML",
      "type": "function",
      "start_line": 20,
      "end_line": 30,
      "content_hash": "f07095abd57f2fa9478c55219250f9815a02c35a",
      "content": "func execCmdML(t *testing.T, m *ModelListComponent, cmd tea.Cmd) {\n\tt.Helper()\n\tfor cmd != nil {\n\t\tmsg := cmd()\n\t\tvar next tea.Cmd\n\t\t_, next = m.Update(msg)\n\t\tcmd = next\n\t}\n}\n\n// readConfigJSON reads and unmarshals the JSON config file at path.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_readConfigJSON_31": {
      "name": "readConfigJSON",
      "type": "function",
      "start_line": 31,
      "end_line": 42,
      "content_hash": "a75c54c50b9d142b889305660907c5a46ed5a420",
      "content": "func readConfigJSON(t *testing.T, path string) map[string]any {\n\tt.Helper()\n\tbaseDir := filepath.Dir(path)\n\tfileName := filepath.Base(path)\n\tb, err := fs.ReadFile(os.DirFS(baseDir), fileName)\n\trequire.NoError(t, err)\n\tvar out map[string]any\n\trequire.NoError(t, json.Unmarshal(b, &out))\n\treturn out\n}\n\n// readRecentModels reads the recent_models section from the config file.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_readRecentModels_43": {
      "name": "readRecentModels",
      "type": "function",
      "start_line": 43,
      "end_line": 50,
      "content_hash": "0bd6ef12c372318695edaab07330f32d33351313",
      "content": "func readRecentModels(t *testing.T, path string) map[string]any {\n\tt.Helper()\n\tout := readConfigJSON(t, path)\n\trm, ok := out[\"recent_models\"].(map[string]any)\n\trequire.True(t, ok)\n\treturn rm\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelList_RecentlyUsedSectionAndPrunesInvalid_51": {
      "name": "TestModelList_RecentlyUsedSectionAndPrunesInvalid",
      "type": "function",
      "start_line": 51,
      "end_line": 159,
      "content_hash": "d2600646ec6cc465d83f9aece88817b2d8ca4730",
      "content": "func TestModelList_RecentlyUsedSectionAndPrunesInvalid(t *testing.T) {\n\t// Pre-initialize logger to os.DevNull to prevent file lock on Windows.\n\tlog.Setup(os.DevNull, false)\n\n\t// Isolate config/data paths\n\tcfgDir := t.TempDir()\n\tdataDir := t.TempDir()\n\tt.Setenv(\"XDG_CONFIG_HOME\", cfgDir)\n\tt.Setenv(\"XDG_DATA_HOME\", dataDir)\n\n\t// Pre-seed config so provider auto-update is disabled and we have recents\n\tconfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\trequire.NoError(t, os.MkdirAll(filepath.Dir(confPath), 0o755))\n\tinitial := map[string]any{\n\t\t\"options\": map[string]any{\n\t\t\t\"disable_provider_auto_update\": true,\n\t\t},\n\t\t\"models\": map[string]any{\n\t\t\t\"large\": map[string]any{\n\t\t\t\t\"model\":    \"m1\",\n\t\t\t\t\"provider\": \"p1\",\n\t\t\t},\n\t\t},\n\t\t\"recent_models\": map[string]any{\n\t\t\t\"large\": []any{\n\t\t\t\tmap[string]any{\"model\": \"m2\", \"provider\": \"p1\"},              // valid\n\t\t\t\tmap[string]any{\"model\": \"x\", \"provider\": \"unknown-provider\"}, // invalid -> pruned\n\t\t\t},\n\t\t},\n\t}\n\tbts, err := json.Marshal(initial)\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.WriteFile(confPath, bts, 0o644))\n\n\t// Also create empty providers.json to prevent loading real providers\n\tdataConfDir := filepath.Join(dataDir, \"nexora\")\n\trequire.NoError(t, os.MkdirAll(dataConfDir, 0o755))\n\temptyProviders := []byte(\"[]\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(dataConfDir, \"providers.json\"), emptyProviders, 0o644))\n\n\t// Initialize global config instance (no network due to auto-update disabled)\n\t_, err = config.Init(cfgDir, dataDir, false)\n\trequire.NoError(t, err)\n\n\t// Build a small provider set for the list component\n\tprovider := catwalk.Provider{\n\t\tID:   catwalk.InferenceProvider(\"p1\"),\n\t\tName: \"Provider One\",\n\t\tModels: []catwalk.Model{\n\t\t\t{ID: \"m1\", Name: \"Model One\", DefaultMaxTokens: 100},\n\t\t\t{ID: \"m2\", Name: \"Model Two\", DefaultMaxTokens: 100}, // recent\n\t\t},\n\t}\n\n\t// Create and initialize the component with our provider set\n\tlistKeyMap := list.DefaultKeyMap()\n\tcmp := NewModelListComponent(listKeyMap, \"Find your fave\", false)\n\tcmp.providers = []catwalk.Provider{provider}\n\texecCmdML(t, cmp, cmp.Init())\n\n\t// Find all recent items (IDs prefixed with \"recent::\") and verify pruning\n\tgroups := cmp.list.Groups()\n\trequire.NotEmpty(t, groups)\n\tvar recentItems []list.CompletionItem[ModelOption]\n\tfor _, g := range groups {\n\t\tfor _, it := range g.Items {\n\t\t\tif strings.HasPrefix(it.ID(), \"recent::\") {\n\t\t\t\trecentItems = append(recentItems, it)\n\t\t\t}\n\t\t}\n\t}\n\trequire.NotEmpty(t, recentItems, \"no recent items found\")\n\t// Ensure the valid recent (p1:m2) is present and the invalid one is not\n\tfoundValid := false\n\tfor _, it := range recentItems {\n\t\tif it.ID() == \"recent::p1:m2\" {\n\t\t\tfoundValid = true\n\t\t}\n\t\trequire.NotEqual(t, \"recent::unknown-provider:x\", it.ID(), \"invalid recent should be pruned\")\n\t}\n\trequire.True(t, foundValid, \"expected valid recent not found\")\n\n\t// Verify original config in cfgDir remains unchanged\n\torigConfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\tafterOrig, err := fs.ReadFile(os.DirFS(filepath.Dir(origConfPath)), filepath.Base(origConfPath))\n\trequire.NoError(t, err)\n\tvar origParsed map[string]any\n\trequire.NoError(t, json.Unmarshal(afterOrig, &origParsed))\n\torigRM := origParsed[\"recent_models\"].(map[string]any)\n\torigLarge := origRM[\"large\"].([]any)\n\trequire.Len(t, origLarge, 2, \"original config should be unchanged\")\n\n\t// Config should be rewritten with pruned recents in dataDir\n\tdataConf := filepath.Join(dataDir, \"nexora\", \"nexora.json\")\n\trm := readRecentModels(t, dataConf)\n\tlargeAny, ok := rm[\"large\"].([]any)\n\trequire.True(t, ok)\n\t// Ensure that only valid recent(s) remain and the invalid one is removed\n\tfound := false\n\tfor _, v := range largeAny {\n\t\tm := v.(map[string]any)\n\t\trequire.NotEqual(t, \"unknown-provider\", m[\"provider\"], \"invalid provider should be pruned\")\n\t\tif m[\"provider\"] == \"p1\" && m[\"model\"] == \"m2\" {\n\t\t\tfound = true\n\t\t}\n\t}\n\trequire.True(t, found, \"persisted recents should include p1:m2\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelList_PrunesInvalidModelWithinValidProvider_160": {
      "name": "TestModelList_PrunesInvalidModelWithinValidProvider",
      "type": "function",
      "start_line": 160,
      "end_line": 263,
      "content_hash": "5be4a1e4ab49edb25ecf7348c0e79855a9a4a6b3",
      "content": "func TestModelList_PrunesInvalidModelWithinValidProvider(t *testing.T) {\n\t// Pre-initialize logger to os.DevNull to prevent file lock on Windows.\n\tlog.Setup(os.DevNull, false)\n\n\t// Isolate config/data paths\n\tcfgDir := t.TempDir()\n\tdataDir := t.TempDir()\n\tt.Setenv(\"XDG_CONFIG_HOME\", cfgDir)\n\tt.Setenv(\"XDG_DATA_HOME\", dataDir)\n\n\t// Pre-seed config with valid provider but one invalid model\n\tconfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\trequire.NoError(t, os.MkdirAll(filepath.Dir(confPath), 0o755))\n\tinitial := map[string]any{\n\t\t\"options\": map[string]any{\n\t\t\t\"disable_provider_auto_update\": true,\n\t\t},\n\t\t\"models\": map[string]any{\n\t\t\t\"large\": map[string]any{\n\t\t\t\t\"model\":    \"m1\",\n\t\t\t\t\"provider\": \"p1\",\n\t\t\t},\n\t\t},\n\t\t\"recent_models\": map[string]any{\n\t\t\t\"large\": []any{\n\t\t\t\tmap[string]any{\"model\": \"m1\", \"provider\": \"p1\"},      // valid\n\t\t\t\tmap[string]any{\"model\": \"missing\", \"provider\": \"p1\"}, // invalid model\n\t\t\t},\n\t\t},\n\t}\n\tbts, err := json.Marshal(initial)\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.WriteFile(confPath, bts, 0o644))\n\n\t// Create empty providers.json\n\tdataConfDir := filepath.Join(dataDir, \"nexora\")\n\trequire.NoError(t, os.MkdirAll(dataConfDir, 0o755))\n\temptyProviders := []byte(\"[]\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(dataConfDir, \"providers.json\"), emptyProviders, 0o644))\n\n\t// Initialize global config instance\n\t_, err = config.Init(cfgDir, dataDir, false)\n\trequire.NoError(t, err)\n\n\t// Build provider set that only includes m1, not \"missing\"\n\tprovider := catwalk.Provider{\n\t\tID:   catwalk.InferenceProvider(\"p1\"),\n\t\tName: \"Provider One\",\n\t\tModels: []catwalk.Model{\n\t\t\t{ID: \"m1\", Name: \"Model One\", DefaultMaxTokens: 100},\n\t\t},\n\t}\n\n\t// Create and initialize component\n\tlistKeyMap := list.DefaultKeyMap()\n\tcmp := NewModelListComponent(listKeyMap, \"Find your fave\", false)\n\tcmp.providers = []catwalk.Provider{provider}\n\texecCmdML(t, cmp, cmp.Init())\n\n\t// Find all recent items\n\tgroups := cmp.list.Groups()\n\trequire.NotEmpty(t, groups)\n\tvar recentItems []list.CompletionItem[ModelOption]\n\tfor _, g := range groups {\n\t\tfor _, it := range g.Items {\n\t\t\tif strings.HasPrefix(it.ID(), \"recent::\") {\n\t\t\t\trecentItems = append(recentItems, it)\n\t\t\t}\n\t\t}\n\t}\n\trequire.NotEmpty(t, recentItems, \"valid recent should exist\")\n\n\t// Verify the valid recent is present and invalid model is not\n\tfoundValid := false\n\tfor _, it := range recentItems {\n\t\tif it.ID() == \"recent::p1:m1\" {\n\t\t\tfoundValid = true\n\t\t}\n\t\trequire.NotEqual(t, \"recent::p1:missing\", it.ID(), \"invalid model should be pruned\")\n\t}\n\trequire.True(t, foundValid, \"valid recent p1:m1 should be present\")\n\n\t// Verify original config in cfgDir remains unchanged\n\torigConfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\tafterOrig, err := fs.ReadFile(os.DirFS(filepath.Dir(origConfPath)), filepath.Base(origConfPath))\n\trequire.NoError(t, err)\n\tvar origParsed map[string]any\n\trequire.NoError(t, json.Unmarshal(afterOrig, &origParsed))\n\torigRM := origParsed[\"recent_models\"].(map[string]any)\n\torigLarge := origRM[\"large\"].([]any)\n\trequire.Len(t, origLarge, 2, \"original config should be unchanged\")\n\n\t// Config should be rewritten with pruned recents in dataDir\n\tdataConf := filepath.Join(dataDir, \"nexora\", \"nexora.json\")\n\trm := readRecentModels(t, dataConf)\n\tlargeAny, ok := rm[\"large\"].([]any)\n\trequire.True(t, ok)\n\trequire.Len(t, largeAny, 1, \"should only have one valid model\")\n\t// Verify only p1:m1 remains\n\tm := largeAny[0].(map[string]any)\n\trequire.Equal(t, \"p1\", m[\"provider\"])\n\trequire.Equal(t, \"m1\", m[\"model\"])\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelKey_EmptyInputs_264": {
      "name": "TestModelKey_EmptyInputs",
      "type": "function",
      "start_line": 264,
      "end_line": 274,
      "content_hash": "e471e09e6a5b0b78197241cae0644fcf2582dcd0",
      "content": "func TestModelKey_EmptyInputs(t *testing.T) {\n\t// Empty provider\n\trequire.Equal(t, \"\", modelKey(\"\", \"model\"))\n\t// Empty model\n\trequire.Equal(t, \"\", modelKey(\"provider\", \"\"))\n\t// Both empty\n\trequire.Equal(t, \"\", modelKey(\"\", \"\"))\n\t// Valid inputs\n\trequire.Equal(t, \"p:m\", modelKey(\"p\", \"m\"))\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelList_AllRecentsInvalid_275": {
      "name": "TestModelList_AllRecentsInvalid",
      "type": "function",
      "start_line": 275,
      "end_line": 370,
      "content_hash": "bfae497482af6e46a7e5102a5e891a4a58846307",
      "content": "func TestModelList_AllRecentsInvalid(t *testing.T) {\n\t// Pre-initialize logger to os.DevNull to prevent file lock on Windows.\n\tlog.Setup(os.DevNull, false)\n\n\t// Isolate config/data paths\n\tcfgDir := t.TempDir()\n\tdataDir := t.TempDir()\n\tt.Setenv(\"XDG_CONFIG_HOME\", cfgDir)\n\tt.Setenv(\"XDG_DATA_HOME\", dataDir)\n\n\t// Pre-seed config with only invalid recents\n\tconfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\trequire.NoError(t, os.MkdirAll(filepath.Dir(confPath), 0o755))\n\tinitial := map[string]any{\n\t\t\"options\": map[string]any{\n\t\t\t\"disable_provider_auto_update\": true,\n\t\t},\n\t\t\"models\": map[string]any{\n\t\t\t\"large\": map[string]any{\n\t\t\t\t\"model\":    \"m1\",\n\t\t\t\t\"provider\": \"p1\",\n\t\t\t},\n\t\t},\n\t\t\"recent_models\": map[string]any{\n\t\t\t\"large\": []any{\n\t\t\t\tmap[string]any{\"model\": \"x\", \"provider\": \"unknown1\"},\n\t\t\t\tmap[string]any{\"model\": \"y\", \"provider\": \"unknown2\"},\n\t\t\t},\n\t\t},\n\t}\n\tbts, err := json.Marshal(initial)\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.WriteFile(confPath, bts, 0o644))\n\n\t// Also create empty providers.json and data config\n\tdataConfDir := filepath.Join(dataDir, \"nexora\")\n\trequire.NoError(t, os.MkdirAll(dataConfDir, 0o755))\n\temptyProviders := []byte(\"[]\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(dataConfDir, \"providers.json\"), emptyProviders, 0o644))\n\n\t// Initialize global config instance with isolated dataDir\n\t_, err = config.Init(cfgDir, dataDir, false)\n\trequire.NoError(t, err)\n\n\t// Build provider set (doesn't include unknown1 or unknown2)\n\tprovider := catwalk.Provider{\n\t\tID:   catwalk.InferenceProvider(\"p1\"),\n\t\tName: \"Provider One\",\n\t\tModels: []catwalk.Model{\n\t\t\t{ID: \"m1\", Name: \"Model One\", DefaultMaxTokens: 100},\n\t\t},\n\t}\n\n\t// Create and initialize component\n\tlistKeyMap := list.DefaultKeyMap()\n\tcmp := NewModelListComponent(listKeyMap, \"Find your fave\", false)\n\tcmp.providers = []catwalk.Provider{provider}\n\texecCmdML(t, cmp, cmp.Init())\n\n\t// Verify no recent items exist in UI\n\tgroups := cmp.list.Groups()\n\trequire.NotEmpty(t, groups)\n\tvar recentItems []list.CompletionItem[ModelOption]\n\tfor _, g := range groups {\n\t\tfor _, it := range g.Items {\n\t\t\tif strings.HasPrefix(it.ID(), \"recent::\") {\n\t\t\t\trecentItems = append(recentItems, it)\n\t\t\t}\n\t\t}\n\t}\n\trequire.Empty(t, recentItems, \"all invalid recents should be pruned, resulting in no recent section\")\n\n\t// Verify original config in cfgDir remains unchanged\n\torigConfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\tafterOrig, err := fs.ReadFile(os.DirFS(filepath.Dir(origConfPath)), filepath.Base(origConfPath))\n\trequire.NoError(t, err)\n\tvar origParsed map[string]any\n\trequire.NoError(t, json.Unmarshal(afterOrig, &origParsed))\n\torigRM := origParsed[\"recent_models\"].(map[string]any)\n\torigLarge := origRM[\"large\"].([]any)\n\trequire.Len(t, origLarge, 2, \"original config should be unchanged\")\n\n\t// Config should be rewritten with empty recents in dataDir\n\tdataConf := filepath.Join(dataDir, \"nexora\", \"nexora.json\")\n\trm := readRecentModels(t, dataConf)\n\t// When all recents are pruned, the value may be nil or an empty array\n\tlargeVal := rm[\"large\"]\n\tif largeVal == nil {\n\t\t// nil is acceptable - means empty\n\t\treturn\n\t}\n\tlargeAny, ok := largeVal.([]any)\n\trequire.True(t, ok, \"large key should be nil or array\")\n\trequire.Empty(t, largeAny, \"persisted recents should be empty after pruning all invalid entries\")\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_TestModelList_LocalProviderInRecents_371": {
      "name": "TestModelList_LocalProviderInRecents",
      "type": "function",
      "start_line": 371,
      "end_line": 462,
      "content_hash": "1a08421e174d0904fe11419f639cd9636122450d",
      "content": "func TestModelList_LocalProviderInRecents(t *testing.T) {\n\t// Pre-initialize logger to os.DevNull to prevent file lock on Windows.\n\tlog.Setup(os.DevNull, false)\n\n\t// Isolate config/data paths\n\tcfgDir := t.TempDir()\n\tdataDir := t.TempDir()\n\tt.Setenv(\"XDG_CONFIG_HOME\", cfgDir)\n\tt.Setenv(\"XDG_DATA_HOME\", dataDir)\n\n\t// Pre-seed config with a local provider and a recent local model\n\tconfPath := filepath.Join(cfgDir, \"nexora\", \"nexora.json\")\n\trequire.NoError(t, os.MkdirAll(filepath.Dir(confPath), 0o755))\n\tinitial := map[string]any{\n\t\t\"options\": map[string]any{\n\t\t\t\"disable_provider_auto_update\": true,\n\t\t},\n\t\t\"models\": map[string]any{\n\t\t\t\"large\": map[string]any{\n\t\t\t\t\"model\":    \"llama3.2:latest\",\n\t\t\t\t\"provider\": \"local\",\n\t\t\t},\n\t\t},\n\t\t\"providers\": map[string]any{\n\t\t\t\"local\": map[string]any{\n\t\t\t\t\"id\":       \"local\",\n\t\t\t\t\"name\":     \"Local Models\",\n\t\t\t\t\"type\":     \"openai-compat\",\n\t\t\t\t\"base_url\": \"https://example.ngrok.dev\",\n\t\t\t\t\"api_key\":  \"sk-123\",\n\t\t\t\t\"models\": []any{\n\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\"id\":   \"llama3.2:latest\",\n\t\t\t\t\t\t\"name\": \"Llama 3.2 Latest\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"recent_models\": map[string]any{\n\t\t\t\"large\": []any{\n\t\t\t\tmap[string]any{\"model\": \"llama3.2:latest\", \"provider\": \"local\"},\n\t\t\t},\n\t\t},\n\t}\n\tbts, err := json.Marshal(initial)\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.WriteFile(confPath, bts, 0o644))\n\n\t// Create empty providers.json to prevent loading real providers\n\tdataConfDir := filepath.Join(dataDir, \"nexora\")\n\trequire.NoError(t, os.MkdirAll(dataConfDir, 0o755))\n\temptyProviders := []byte(\"[]\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(dataConfDir, \"providers.json\"), emptyProviders, 0o644))\n\n\t// Initialize global config instance\n\tcfg, err := config.Init(cfgDir, dataDir, false)\n\trequire.NoError(t, err)\n\n\t// Verify local provider is in config\n\tlocalProvider, exists := cfg.Providers.Get(\"local\")\n\trequire.True(t, exists, \"local provider should exist in config\")\n\trequire.NotEmpty(t, localProvider.Models, \"local provider should have models\")\n\n\t// Create and initialize the component with empty provider set (no known providers)\n\tlistKeyMap := list.DefaultKeyMap()\n\tcmp := NewModelListComponent(listKeyMap, \"Find your fave\", false)\n\tcmp.providers = []catwalk.Provider{} // No known providers\n\texecCmdML(t, cmp, cmp.Init())\n\n\t// Find all groups and items\n\tgroups := cmp.list.Groups()\n\n\t// Find all recent items (IDs prefixed with \"recent::\")\n\tvar recentItems []list.CompletionItem[ModelOption]\n\tfor _, g := range groups {\n\t\tfor _, it := range g.Items {\n\t\t\tif strings.HasPrefix(it.ID(), \"recent::\") {\n\t\t\t\trecentItems = append(recentItems, it)\n\t\t\t}\n\t\t}\n\t}\n\n\t// The recent local model should be present\n\trequire.NotEmpty(t, recentItems, \"recent items should include the local model\")\n\tfoundLocalRecent := false\n\tfor _, it := range recentItems {\n\t\tif it.ID() == \"recent::local:llama3.2:latest\" {\n\t\t\tfoundLocalRecent = true\n\t\t}\n\t}\n\trequire.True(t, foundLocalRecent, \"recent local model should be found (expected recent::local:llama3.2:latest)\")\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}