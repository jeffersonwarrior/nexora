{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/storage_core/graph_visualization.rs",
  "file_hash": "b76e8c5e537969b8557b3dfc532f3560f222254a",
  "updated_at": "2025-12-26T17:34:21.566109",
  "symbols": {
    "trait_GraphVisualization_15": {
      "name": "GraphVisualization",
      "type": "trait",
      "start_line": 15,
      "end_line": 16,
      "content_hash": "b564981a51bfde679df69061e3ad89cc536f36a8",
      "content": "pub trait GraphVisualization {\n    /// Serializes nodes and edges to JSON for graph visualization.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_nodes_edges_to_json_17": {
      "name": "nodes_edges_to_json",
      "type": "function",
      "start_line": 17,
      "end_line": 24,
      "content_hash": "771a6e8afa97a602a83752fbe986ae7857e71efb",
      "content": "    fn nodes_edges_to_json(\n        &self,\n        txn: &RoTxn,\n        k: Option<usize>,\n        node_prop: Option<String>,\n    ) -> Result<String, GraphError>;\n\n    /// Retrieves database statistics in JSON format.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_get_db_stats_json_25": {
      "name": "get_db_stats_json",
      "type": "function",
      "start_line": 25,
      "end_line": 27,
      "content_hash": "7c23bb4c071e9855be4364e1392ac6aa56824454",
      "content": "    fn get_db_stats_json(&self, txn: &RoTxn) -> Result<String, GraphError>;\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_GraphVisualization_28": {
      "name": "GraphVisualization",
      "type": "impl",
      "start_line": 28,
      "end_line": 28,
      "content_hash": "1ddd084dc37cbe6667ffd7d71579a967b891d8bc",
      "content": "impl GraphVisualization for HelixGraphStorage {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_nodes_edges_to_json_29": {
      "name": "nodes_edges_to_json",
      "type": "method",
      "start_line": 29,
      "end_line": 53,
      "content_hash": "771c3c80f54f9bc491b3ac2eb45810357930c2fe",
      "content": "    fn nodes_edges_to_json(\n        &self,\n        txn: &RoTxn,\n        k: Option<usize>,\n        node_prop: Option<String>,\n    ) -> Result<String, GraphError> {\n        let k = k.unwrap_or(200);\n        if k > 300 {\n            return Err(GraphError::New(\n                \"cannot not visualize more than 300 nodes!\".to_string(),\n            ));\n        }\n\n        if self.nodes_db.is_empty(txn)? || self.edges_db.is_empty(txn)? {\n            return Err(GraphError::New(\n                \"edges or nodes db is empty!\".to_string(),\n            ));\n        }\n\n        let top_nodes = self.get_nodes_by_cardinality(txn, k)?;\n\n        let ret_json = self.cards_to_json(txn, k, top_nodes, node_prop)?;\n        sonic_rs::to_string(&ret_json).map_err(|e| GraphError::New(e.to_string()))\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_db_stats_json_54": {
      "name": "get_db_stats_json",
      "type": "method",
      "start_line": 54,
      "end_line": 66,
      "content_hash": "50ed92f402bb2c04292741c821573ec4813ce1ce",
      "content": "    fn get_db_stats_json(&self, txn: &RoTxn) -> Result<String, GraphError> {\n        let result = json!({\n            \"num_nodes\":   self.nodes_db.len(txn).unwrap_or(0),\n            \"num_edges\":   self.edges_db.len(txn).unwrap_or(0),\n            \"num_vectors\": self.vectors.vectors_db.len(txn).unwrap_or(0),\n        });\n        debug_println!(\"db stats json: {:?}\", result);\n\n        sonic_rs::to_string(&result).map_err(|e| GraphError::New(e.to_string()))\n    }\n}\n\n/// Implementing the helper functions needed to get the data for graph visualization",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_HelixGraphStorage_67": {
      "name": "HelixGraphStorage",
      "type": "impl",
      "start_line": 67,
      "end_line": 70,
      "content_hash": "604f7536f12d09259491b32db56ca00e5ee64694",
      "content": "impl HelixGraphStorage {\n    /// Get the top k nodes and all of the edges associated with them by checking their\n    /// cardinalities (total number of in and out edges)\n    #[allow(clippy::type_complexity)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_get_nodes_by_cardinality_71": {
      "name": "get_nodes_by_cardinality",
      "type": "method",
      "start_line": 71,
      "end_line": 81,
      "content_hash": "72eadef126409fbecdcff85a3b6f1ffe89e97b33",
      "content": "    fn get_nodes_by_cardinality(\n        &self,\n        txn: &RoTxn,\n        k: usize,\n    ) -> Result<Vec<(u128, Vec<(u128, u128, u128)>, Vec<(u128, u128, u128)>)>, GraphError> {\n        let node_count = self.nodes_db.len(txn)?;\n\n        type EdgeID = u128;\n        type ToNodeId = u128;\n        type FromNodeId = u128;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_EdgeCount_82": {
      "name": "EdgeCount",
      "type": "struct",
      "start_line": 82,
      "end_line": 88,
      "content_hash": "ae98ac4ffed293fc6ded3027e145d0be47294353",
      "content": "        struct EdgeCount {\n            node_id: u128,\n            edges_count: usize,\n            out_edges: Vec<(EdgeID, FromNodeId, ToNodeId)>,\n            in_edges: Vec<(EdgeID, FromNodeId, ToNodeId)>,\n        }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialEq_89": {
      "name": "PartialEq",
      "type": "impl",
      "start_line": 89,
      "end_line": 89,
      "content_hash": "d5a9e3ef2e8ae39162ef440a765ba628cef461df",
      "content": "        impl PartialEq for EdgeCount {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_eq_90": {
      "name": "eq",
      "type": "method",
      "start_line": 90,
      "end_line": 93,
      "content_hash": "c11d7bd2835f20895799a1f31e03fb95c6af0dbf",
      "content": "            fn eq(&self, other: &Self) -> bool {\n                self.edges_count == other.edges_count\n            }\n        }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Eq_94": {
      "name": "Eq",
      "type": "impl",
      "start_line": 94,
      "end_line": 94,
      "content_hash": "5a5e210efc355173d08f948dd57090ef19901f32",
      "content": "        impl Eq for EdgeCount {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_PartialOrd_95": {
      "name": "PartialOrd",
      "type": "impl",
      "start_line": 95,
      "end_line": 95,
      "content_hash": "e48da3cea1abae65f468cc509e043a801887c270",
      "content": "        impl PartialOrd for EdgeCount {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_partial_cmp_96": {
      "name": "partial_cmp",
      "type": "method",
      "start_line": 96,
      "end_line": 99,
      "content_hash": "89e4500dd2875e99f5a02d499f719a9b6cb17bbb",
      "content": "            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                Some(self.cmp(other))\n            }\n        }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Ord_100": {
      "name": "Ord",
      "type": "impl",
      "start_line": 100,
      "end_line": 100,
      "content_hash": "9d09f77709a1e27cc3eb0764d2bafd820175ce12",
      "content": "        impl Ord for EdgeCount {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cmp_101": {
      "name": "cmp",
      "type": "method",
      "start_line": 101,
      "end_line": 110,
      "content_hash": "ff9a8b7971ca1ff5c82821a276f75fbcef67112b",
      "content": "            fn cmp(&self, other: &Self) -> Ordering {\n                self.edges_count.cmp(&other.edges_count)\n            }\n        }\n\n        let db = Arc::new(self);\n        let out_db = Arc::clone(&db);\n        let in_db = Arc::clone(&db);\n\n        #[derive(Default)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_Edges_111": {
      "name": "Edges",
      "type": "struct",
      "start_line": 111,
      "end_line": 240,
      "content_hash": "58420a3ca0ce5772e57465c712855e7acd62a9b2",
      "content": "        struct Edges<'a> {\n            edge_count: usize,\n            out_edges: Option<\n                RoIter<\n                    'a,\n                    Bytes,\n                    LazyDecode<Bytes>,\n                    heed3::iteration_method::MoveOnCurrentKeyDuplicates,\n                >,\n            >,\n            in_edges: Option<\n                RoIter<\n                    'a,\n                    Bytes,\n                    LazyDecode<Bytes>,\n                    heed3::iteration_method::MoveOnCurrentKeyDuplicates,\n                >,\n            >,\n        }\n\n        let mut edge_counts: HashMap<u128, Edges> = HashMap::with_capacity(node_count as usize);\n        let mut ordered_edge_counts: BinaryHeap<EdgeCount> =\n            BinaryHeap::with_capacity(node_count as usize);\n\n        // out edges - iterate through nodes by getting each unique node ID from out_edges_db\n        let out_node_key_iter = out_db\n            .out_edges_db\n            .lazily_decode_data()\n            .iter(txn)\n            .unwrap();\n        for data in out_node_key_iter {\n            match data {\n                Ok((key, _)) => {\n                    let node_id = &key[0..16];\n                    let edges = out_db\n                        .out_edges_db\n                        .lazily_decode_data()\n                        .get_duplicates(txn, key)\n                        .unwrap();\n\n                    let edges_count = edges.iter().count();\n\n                    let edge_count = edge_counts\n                        .entry(u128::from_be_bytes(node_id.try_into().unwrap()))\n                        .or_default();\n                    edge_count.edge_count += edges_count;\n                    edge_count.out_edges = edges;\n                }\n                Err(_e) => {\n                    debug_println!(\"Error in out_node_key_iter: {:?}\", _e);\n                }\n            }\n        }\n\n        // in edges\n        let in_node_key_iter = in_db.in_edges_db.lazily_decode_data().iter(txn).unwrap();\n        for data in in_node_key_iter {\n            match data {\n                Ok((key, _)) => {\n                    let node_id = &key[0..16];\n                    let edges = in_db\n                        .in_edges_db\n                        .lazily_decode_data()\n                        .get_duplicates(txn, key)\n                        .unwrap();\n                    let edges_count = edges.iter().count();\n\n                    let edge_count = edge_counts\n                        .entry(u128::from_be_bytes(node_id.try_into().unwrap()))\n                        .or_default();\n                    edge_count.edge_count += edges_count;\n                    edge_count.in_edges = edges;\n                }\n                Err(_e) => {\n                    debug_println!(\"Error in in_node_key_iter: {:?}\", _e);\n                }\n            }\n        }\n\n        // Decode edges and extract edge id and other node id\n        for (node_id, edges_count) in edge_counts.into_iter() {\n            let out_edges = match edges_count.out_edges {\n                Some(out_edges_iter) => out_edges_iter\n                    .map(|result| {\n                        let (key, value) = result.unwrap();\n                        let from_node = u128::from_be_bytes(key[0..16].try_into().unwrap());\n                        let (edge_id, to_node) =\n                            Self::unpack_adj_edge_data(value.decode().unwrap()).unwrap();\n                        (edge_id, from_node, to_node)\n                    })\n                    .collect::<Vec<(EdgeID, FromNodeId, ToNodeId)>>(),\n                None => vec![],\n            };\n            let in_edges = match edges_count.in_edges {\n                Some(in_edges_iter) => in_edges_iter\n                    .map(|result| {\n                        let (key, value) = result.unwrap();\n                        let to_node = u128::from_be_bytes(key[0..16].try_into().unwrap());\n                        let (edge_id, from_node) =\n                            Self::unpack_adj_edge_data(value.decode().unwrap()).unwrap();\n                        (edge_id, from_node, to_node)\n                    })\n                    .collect::<Vec<(EdgeID, FromNodeId, ToNodeId)>>(),\n                None => vec![],\n            };\n\n            ordered_edge_counts.push(EdgeCount {\n                node_id,\n                edges_count: edges_count.edge_count,\n                out_edges,\n                in_edges,\n            });\n        }\n\n        let mut top_nodes = Vec::with_capacity(k);\n        while let Some(edges_count) = ordered_edge_counts.pop() {\n            top_nodes.push((\n                edges_count.node_id,\n                edges_count.out_edges,\n                edges_count.in_edges,\n            ));\n            if top_nodes.len() >= k {\n                break;\n            }\n        }\n\n        Ok(top_nodes)\n    }\n\n    #[allow(clippy::type_complexity)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_cards_to_json_241": {
      "name": "cards_to_json",
      "type": "method",
      "start_line": 241,
      "end_line": 299,
      "content_hash": "c7147adb8f1ff007237dd74212b1ad393847c301",
      "content": "    fn cards_to_json(\n        &self,\n        txn: &RoTxn,\n        k: usize,\n        top_nodes: Vec<(u128, Vec<(u128, u128, u128)>, Vec<(u128, u128, u128)>)>,\n        node_prop: Option<String>,\n    ) -> Result<JsonValue, GraphError> {\n        let mut nodes = Vec::with_capacity(k);\n        let mut edges = Vec::new();\n\n        // Create temporary arena for node deserialization\n        let arena = bumpalo::Bump::new();\n\n        top_nodes\n            .iter()\n            .try_for_each(|(id, out_edges, _in_edges)| {\n                let mut json_node = json!({ \"id\": id.to_string(), \"title\": id.to_string() });\n                if let Some(prop) = &node_prop {\n                    // Get node data\n                    if let Some(node_data) = self.nodes_db.get(txn, id)? {\n                        let node = Node::from_bincode_bytes(*id, node_data, &arena)?;\n                        if let Some(props) = node.properties\n                            && let Some(prop_value) = props.get(prop) {\n                                json_node\n                                    .as_object_mut()\n                                    .ok_or_else(|| {\n                                        GraphError::New(\"invalid JSON object\".to_string())\n                                    })?\n                                    .insert(\n                                        \"label\",\n                                        sonic_rs::to_value(&prop_value.inner_stringify())\n                                            .unwrap_or_else(|_| sonic_rs::Value::from(\"\")),\n                                    );\n                            }\n                    }\n                }\n\n                nodes.push(json_node);\n                out_edges\n                    .iter()\n                    .for_each(|(edge_id, from_node_id, to_node_id)| {\n                        edges.push(json!({\n                            \"from\": from_node_id.to_string(),\n                            \"to\": to_node_id.to_string(),\n                            \"title\": edge_id.to_string(),\n                        }));\n                    });\n\n                Ok::<(), GraphError>(())\n            })?;\n\n        let result = json!({\n            \"nodes\": nodes,\n            \"edges\": edges,\n        });\n\n        Ok(result)\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}