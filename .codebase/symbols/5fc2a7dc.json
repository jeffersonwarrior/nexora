{
  "file_path": "/work/.local/tools/modelscan/storage/markdown.go",
  "file_hash": "4d4730832290b91b2208aab37cc23402dc9e071b",
  "updated_at": "2025-12-26T17:34:22.792282",
  "symbols": {
    "function_ExportToMarkdown_14": {
      "name": "ExportToMarkdown",
      "type": "function",
      "start_line": 14,
      "end_line": 68,
      "content_hash": "1bf2a4149860d17b69d6a534aca0c0d801383759",
      "content": "func ExportToMarkdown(outputPath string) error {\n\tif db == nil {\n\t\treturn fmt.Errorf(\"database not initialized\")\n\t}\n\n\t// Note: The parent directory should be created by the caller\n\t// Don't try to mkdir the outputPath which could be a file path\n\n\t// Get all provider names\n\trows, err := db.Query(\"SELECT DISTINCT name FROM providers ORDER BY name\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to query providers: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar providerNames []string\n\tfor rows.Next() {\n\t\tvar name string\n\t\tif err := rows.Scan(&name); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to scan provider name: %w\", err)\n\t\t}\n\t\tproviderNames = append(providerNames, name)\n\t}\n\n\t// Create markdown file\n\tfile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create markdown file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Execute markdown template\n\ttmpl := template.Must(template.New(\"report\").Parse(markdownTemplate))\n\tdata := struct {\n\t\tProviders   []string\n\t\tGeneratedAt time.Time\n\t}{\n\t\tProviders:   providerNames,\n\t\tGeneratedAt: time.Now(),\n\t}\n\n\tif err := tmpl.Execute(file, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template: %w\", err)\n\t}\n\n\t// Append provider details\n\tfor _, providerName := range providerNames {\n\t\tif err := appendProviderDetails(file, providerName); err != nil {\n\t\t\tlog.Printf(\"Error appending details for %s: %v\", providerName, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_appendProviderDetails_69": {
      "name": "appendProviderDetails",
      "type": "function",
      "start_line": 69,
      "end_line": 174,
      "content_hash": "173ef6e5172c144bb185d117037c24353cce41bb",
      "content": "func appendProviderDetails(file *os.File, providerName string) error {\n\tfmt.Fprintf(file, \"\\n## %s\\n\\n\", providerName)\n\n\t// Get models\n\tmodels, err := GetProviderModels(providerName)\n\tif err != nil {\n\t\tfmt.Fprintf(file, \"Error fetching models: %v\\n\\n\", err)\n\t\treturn err\n\t}\n\n\t// Group models by category\n\tmodelByCategory := make(map[string][]providers.Model)\n\tfor _, model := range models {\n\t\tif len(model.Categories) == 0 {\n\t\t\tmodel.Categories = []string{\"general\"}\n\t\t}\n\t\tfor _, cat := range model.Categories {\n\t\t\tmodelByCategory[cat] = append(modelByCategory[cat], model)\n\t\t}\n\t}\n\n\t// Print models by category\n\tfor category, categoryModels := range modelByCategory {\n\t\tfmt.Fprintf(file, \"### %s Models\\n\\n\", category)\n\t\tfmt.Fprintf(file, \"| Name | ID | Context | Input/Output Cost | Features |\\n\")\n\t\tfmt.Fprintf(file, \"|------|----|---------|-------------------|----------|\\n\")\n\n\t\tfor _, model := range categoryModels {\n\t\t\tfeatures := \"\"\n\t\t\tif model.SupportsImages {\n\t\t\t\tfeatures += \"\ud83d\uddbc\ufe0f \"\n\t\t\t}\n\t\t\tif model.SupportsTools {\n\t\t\t\tfeatures += \"\ud83d\udd27 \"\n\t\t\t}\n\t\t\tif model.CanReason {\n\t\t\t\tfeatures += \"\ud83e\udde0 \"\n\t\t\t}\n\t\t\tif model.CanStream {\n\t\t\t\tfeatures += \"\ud83d\udce1 \"\n\t\t\t}\n\t\t\tif features == \"\" {\n\t\t\t\tfeatures = \"N/A\"\n\t\t\t}\n\n\t\t\tfmt.Fprintf(file, \"| %s | %s | %d | $%.3f/$%.3f | %s |\\n\",\n\t\t\t\tmodel.Name,\n\t\t\t\tmodel.ID,\n\t\t\t\tmodel.ContextWindow,\n\t\t\t\tmodel.CostPer1MIn,\n\t\t\t\tmodel.CostPer1MOut,\n\t\t\t\tfeatures,\n\t\t\t)\n\t\t}\n\t\tfmt.Fprintf(file, \"\\n\")\n\t}\n\n\t// Get endpoint status\n\tendpoints, err := GetProviderEndpoints(providerName)\n\tif err != nil {\n\t\tfmt.Fprintf(file, \"Error fetching endpoints: %v\\n\\n\", err)\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(file, \"### Endpoint Status\\n\\n\")\n\tfmt.Fprintf(file, \"| Endpoint | Method | Status | Latency |\\n\")\n\tfmt.Fprintf(file, \"|----------|--------|--------|----------|\\n\")\n\n\tfor _, endpoint := range endpoints {\n\t\tlatency := \"N/A\"\n\t\tif endpoint.Latency > 0 {\n\t\t\tlatency = fmt.Sprintf(\"%v\", endpoint.Latency.Round(time.Millisecond))\n\t\t}\n\n\t\tstatus := \"\u274c \" + endpoint.Error\n\t\tif endpoint.Status == providers.StatusWorking {\n\t\t\tstatus = \"\u2705 Working\"\n\t\t}\n\n\t\tfmt.Fprintf(file, \"| %s | %s | %s | %s |\\n\",\n\t\t\tendpoint.Path,\n\t\t\tendpoint.Method,\n\t\t\tstatus,\n\t\t\tlatency,\n\t\t)\n\t}\n\tfmt.Fprintf(file, \"\\n---\\n\\n\")\n\n\treturn nil\n}\n\nconst markdownTemplate = `# AI Provider Validation Report\n\nGenerated on: {{.GeneratedAt.Format \"2006-01-02 15:04:05\"}}\n\nThis document contains a comprehensive overview of all validated AI providers and their available models.\n\n## Summary\n\n- Total Providers: {{len .Providers}}\n- Report generated automatically by modelscan\n\n## Table of Contents\n`\n\n// Append storeEndpointResults from markdown.go since it's duplicated",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}