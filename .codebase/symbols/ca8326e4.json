{
  "file_path": "/work/external-deps/Context-Engine/scripts/mcp_impl/info_request.py",
  "file_hash": "29e98a38a630d703278c27321078b1b6c2692847",
  "updated_at": "2025-12-26T17:34:21.552335",
  "symbols": {
    "function__extract_symbols_from_query_30": {
      "name": "_extract_symbols_from_query",
      "type": "function",
      "start_line": 30,
      "end_line": 44,
      "content_hash": "a65e83f05e7c0f202da6d19578299b671aa49879",
      "content": "def _extract_symbols_from_query(query: str) -> list[str]:\n    \"\"\"Extract potential symbol names from a query string.\"\"\"\n    # Match CamelCase, snake_case, or standalone words that look like identifiers\n    patterns = [\n        r'\\b[A-Z][a-z]+(?:[A-Z][a-z]+)+\\b',  # CamelCase\n        r'\\b[a-z_][a-z0-9_]*(?:_[a-z0-9]+)+\\b',  # snake_case\n        r'\\b(?:def|class|function|method|async)\\s+(\\w+)',  # explicit mentions\n    ]\n    symbols = set()\n    for pat in patterns:\n        for m in re.finditer(pat, query):\n            sym = m.group(1) if m.lastindex else m.group(0)\n            if len(sym) > 2:\n                symbols.add(sym)\n    return list(symbols)[:5]  # Limit to top 5",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_related_concepts_47": {
      "name": "_extract_related_concepts",
      "type": "function",
      "start_line": 47,
      "end_line": 83,
      "content_hash": "4e5ed024d32671e78702b5415bc86b927e416af5",
      "content": "def _extract_related_concepts(query: str, results: list) -> list[str]:\n    \"\"\"Extract related technical concepts dynamically from results (codebase-agnostic).\"\"\"\n    concepts = set()\n\n    # Extract from results - this works on any codebase\n    for r in results[:10]:\n        # From symbols: split CamelCase/snake_case into meaningful parts\n        sym = r.get(\"symbol\", \"\") or \"\"\n        if sym and len(sym) > 2:\n            parts = [p for p in re.split(r'(?=[A-Z])|_|-', sym) if p and len(p) > 2]\n            for part in parts[:3]:\n                concepts.add(part.lower())\n\n        # From file paths: extract directory/module names\n        path = r.get(\"path\", \"\") or \"\"\n        if path:\n            path_parts = path.replace(\"\\\\\", \"/\").split(\"/\")\n            for pp in path_parts[-3:]:  # Last 3 path segments\n                # Remove extension and split\n                name = pp.rsplit(\".\", 1)[0] if \".\" in pp else pp\n                if name and len(name) > 2 and not name.startswith(\"_\"):\n                    concepts.add(name.lower())\n\n        # From kind: function, class, method, etc.\n        kind = r.get(\"kind\", \"\") or \"\"\n        if kind and len(kind) > 2:\n            concepts.add(kind.lower())\n\n    # From query: extract significant words (skip common words)\n    skip_words = {\"the\", \"is\", \"are\", \"how\", \"does\", \"what\", \"where\", \"find\", \"get\", \"set\", \"for\", \"and\", \"with\"}\n    query_parts = re.split(r'\\W+', query.lower())\n    for qp in query_parts:\n        if qp and len(qp) > 2 and qp not in skip_words:\n            concepts.add(qp)\n\n    # Sort by frequency in results for relevance\n    return list(concepts)[:10]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__format_information_field_86": {
      "name": "_format_information_field",
      "type": "function",
      "start_line": 86,
      "end_line": 102,
      "content_hash": "99b3d0dd42f84dfce90945b361f2d5ce4c06d002",
      "content": "def _format_information_field(result: dict) -> str:\n    \"\"\"Generate human-readable information field for a result.\"\"\"\n    path = result.get(\"path\", \"\")\n    symbol = result.get(\"symbol\", \"\")\n    start = result.get(\"start_line\", 0)\n    end = result.get(\"end_line\", 0)\n    kind = result.get(\"kind\", \"\")\n\n    # Get just the filename\n    filename = path.split(\"/\")[-1] if \"/\" in path else path\n\n    if symbol and kind:\n        return f\"Found {kind} '{symbol}' in {filename} (lines {start}-{end})\"\n    elif symbol:\n        return f\"Found '{symbol}' in {filename} (lines {start}-{end})\"\n    else:\n        return f\"Found match in {filename} (lines {start}-{end})\"",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__extract_relationships_105": {
      "name": "_extract_relationships",
      "type": "function",
      "start_line": 105,
      "end_line": 125,
      "content_hash": "f70e5835f90b41ede95b78564b618acf442275db",
      "content": "def _extract_relationships(result: dict) -> dict:\n    \"\"\"Extract relationship metadata (imports, calls) from a result.\"\"\"\n    relations = result.get(\"relations\") or {}\n    # Get from relations object if present\n    imports = relations.get(\"imports\") or []\n    calls = relations.get(\"calls\") or []\n    symbol_path = relations.get(\"symbol_path\") or \"\"\n    # Also check top-level metadata (fallback)\n    if not imports:\n        imports = result.get(\"imports\") or []\n    if not calls:\n        calls = result.get(\"calls\") or []\n    # Get related paths if available\n    related_paths = result.get(\"related_paths\") or []\n\n    return {\n        \"imports_from\": imports[:10] if imports else [],  # Limit to 10\n        \"calls\": calls[:10] if calls else [],\n        \"symbol_path\": symbol_path,\n        \"related_paths\": related_paths[:5] if related_paths else [],\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function__calculate_confidence_128": {
      "name": "_calculate_confidence",
      "type": "function",
      "start_line": 128,
      "end_line": 158,
      "content_hash": "d4bd9b2294896684f268b6cbcffb5e7274e554f3",
      "content": "def _calculate_confidence(query: str, results: list) -> dict:\n    \"\"\"Calculate confidence metrics for the search.\"\"\"\n    if not results:\n        return {\"level\": \"none\", \"score\": 0.0, \"reason\": \"no_results\"}\n\n    avg_score = sum(r.get(\"score\", 0) for r in results) / len(results)\n    top_score = results[0].get(\"score\", 0) if results else 0\n\n    # Check if query terms match symbols\n    query_tokens = set(_split_ident(query.lower()))\n    symbol_matches = sum(\n        1 for r in results[:5]\n        if any(tok in _split_ident((r.get(\"symbol\", \"\") or \"\").lower())\n               for tok in query_tokens)\n    )\n\n    if top_score > 0.8 and symbol_matches > 0:\n        level = \"high\"\n    elif avg_score > 0.6:\n        level = \"medium\"\n    elif results:\n        level = \"low\"\n    else:\n        level = \"none\"\n\n    return {\n        \"level\": level,\n        \"score\": round(avg_score, 3),\n        \"top_score\": round(top_score, 3),\n        \"symbol_matches\": symbol_matches,\n    }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}