{
  "file_path": "/work/external-deps/helix-db/helix-db/src/utils/id.rs",
  "file_hash": "84b0ec20b8b40902de11cbf7994ef195118ecc06",
  "updated_at": "2025-12-26T17:34:20.884847",
  "symbols": {
    "struct_ID_22": {
      "name": "ID",
      "type": "struct",
      "start_line": 22,
      "end_line": 22,
      "content_hash": "f510c0bc2a1088a9ed659bbf16aa037ee2bac0ec",
      "content": "pub struct ID(u128);",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ID_23": {
      "name": "ID",
      "type": "impl",
      "start_line": 23,
      "end_line": 23,
      "content_hash": "1f5d26a48bdccb7ee0f436f5d0b593b1bd787ee2",
      "content": "impl ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_inner_24": {
      "name": "inner",
      "type": "method",
      "start_line": 24,
      "end_line": 27,
      "content_hash": "ec88cab49e4f01821535176c373d4ff8485b980a",
      "content": "    pub fn inner(&self) -> u128 {\n        self.0\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_id_28": {
      "name": "id",
      "type": "method",
      "start_line": 28,
      "end_line": 31,
      "content_hash": "835b3b27e5f198e82a8a6012c9bb19d140cce9ab",
      "content": "    pub fn id(&self) -> u128 {\n        self.0\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_stringify_32": {
      "name": "stringify",
      "type": "method",
      "start_line": 32,
      "end_line": 36,
      "content_hash": "9198f6b69b528b8009bb8131dab4a01abaaddd71",
      "content": "    pub fn stringify(&self) -> String {\n        uuid::Uuid::from_u128(self.0).to_string()\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Serialize_37": {
      "name": "Serialize",
      "type": "impl",
      "start_line": 37,
      "end_line": 45,
      "content_hash": "ea4d4583ff4d6af9407d87d3b53f9b55d70c8b12",
      "content": "impl Serialize for ID {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_u128(self.0)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IDVisitor_46": {
      "name": "IDVisitor",
      "type": "struct",
      "start_line": 46,
      "end_line": 47,
      "content_hash": "e50ac4248d27fc07a20e43b66a3327454d3b7489",
      "content": "struct IDVisitor;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Visitor_48": {
      "name": "Visitor",
      "type": "impl",
      "start_line": 48,
      "end_line": 50,
      "content_hash": "a8562de21d56af3b7187e08dbec61eb6a96f2ca1",
      "content": "impl<'de> Visitor<'de> for IDVisitor {\n    type Value = ID;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_expecting_51": {
      "name": "expecting",
      "type": "method",
      "start_line": 51,
      "end_line": 67,
      "content_hash": "3667ad246895e9580de88bab5ffe67b4185d592b",
      "content": "    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a valid UUID\")\n    }\n\n    /// Visits a string UUID and parses it into a 128-bit integer.\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: serde::de::Error,\n    {\n        match uuid::Uuid::parse_str(v) {\n            Ok(uuid) => Ok(ID(uuid.as_u128())),\n            Err(e) => Err(E::custom(e.to_string())),\n        }\n    }\n}\n\n/// Deserializes a string UUID into a 128-bit integer.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deserialize_68": {
      "name": "Deserialize",
      "type": "impl",
      "start_line": 68,
      "end_line": 77,
      "content_hash": "335f32772e4443e23421a23fc6143a80f408d401",
      "content": "impl<'de> Deserialize<'de> for ID {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_str(IDVisitor)\n    }\n}\n\n/// Dereferences the ID to a 128-bit integer.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Deref_78": {
      "name": "Deref",
      "type": "impl",
      "start_line": 78,
      "end_line": 80,
      "content_hash": "4c3f8638fb420b7ed937d9a9628e5aa4d17a55c5",
      "content": "impl Deref for ID {\n    type Target = u128;\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_deref_81": {
      "name": "deref",
      "type": "method",
      "start_line": 81,
      "end_line": 85,
      "content_hash": "e0758894e7afb992a203d37c9cdd405dbcb88cbf",
      "content": "    fn deref(&self) -> &u128 {\n        &self.0\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_86": {
      "name": "From",
      "type": "impl",
      "start_line": 86,
      "end_line": 86,
      "content_hash": "94502937ee393dcb6f8bf56bf0f908d255025253",
      "content": "impl From<u128> for ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_87": {
      "name": "from",
      "type": "method",
      "start_line": 87,
      "end_line": 91,
      "content_hash": "6080966929395a46213d6d0d5b52aebb8d286760",
      "content": "    fn from(id: u128) -> Self {\n        ID(id)\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_92": {
      "name": "From",
      "type": "impl",
      "start_line": 92,
      "end_line": 92,
      "content_hash": "8dcd3c5b602bdb29c4166e3d3598f2e821d418b1",
      "content": "impl From<String> for ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_93": {
      "name": "from",
      "type": "method",
      "start_line": 93,
      "end_line": 96,
      "content_hash": "5895a10a043158d00e88749265859b3f3b17241c",
      "content": "    fn from(id: String) -> Self {\n        ID(uuid::Uuid::parse_str(&id).unwrap().as_u128())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_97": {
      "name": "From",
      "type": "impl",
      "start_line": 97,
      "end_line": 97,
      "content_hash": "ff720fdd8432a44d67eea73d2e2b7f057f529510",
      "content": "impl From<&String> for ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_98": {
      "name": "from",
      "type": "method",
      "start_line": 98,
      "end_line": 102,
      "content_hash": "9f63f003556b6e090bc59e3f724ad2fd15aa8503",
      "content": "    fn from(id: &String) -> Self {\n        ID(uuid::Uuid::parse_str(id).unwrap().as_u128())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_103": {
      "name": "From",
      "type": "impl",
      "start_line": 103,
      "end_line": 103,
      "content_hash": "9dcca0a69495a438a7ae8cd095749994e91fcc0c",
      "content": "impl From<&str> for ID {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_104": {
      "name": "from",
      "type": "method",
      "start_line": 104,
      "end_line": 108,
      "content_hash": "accfaa16cc814f615ed0fbe1e91609250885cdfd",
      "content": "    fn from(id: &str) -> Self {\n        ID(uuid::Uuid::parse_str(id).unwrap().as_u128())\n    }\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_From_109": {
      "name": "From",
      "type": "impl",
      "start_line": 109,
      "end_line": 109,
      "content_hash": "80a0247436737282306f1472bdca076fe6fcf0d2",
      "content": "impl From<ID> for u128 {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_110": {
      "name": "from",
      "type": "method",
      "start_line": 110,
      "end_line": 119,
      "content_hash": "42627191dd775b41adf5b0ec71691ac3fd377661",
      "content": "    fn from(id: ID) -> Self {\n        id.0\n    }\n}\n\n/// Generates a new v6 UUID.\n///\n/// This is used to generate a new UUID for a node or edge.\n/// The UUID is generated using the current time and a random number.\n#[inline(always)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_v6_uuid_120": {
      "name": "v6_uuid",
      "type": "method",
      "start_line": 120,
      "end_line": 130,
      "content_hash": "42a1bdded689f072a36fe60a33f8932ae0123967",
      "content": "pub fn v6_uuid() -> u128 {\n    uuid::Uuid::now_v6(&[1, 2, 3, 4, 5, 6]).as_u128()\n}\n\n/// Converts a uuid to a string slice using a buffer created in the arena \n/// \n/// This is more efficient that using the `to_string` on the created uuid\n/// as it avoids formatting and potential double buffering\n/// \n/// NOTE: This could be optimized further by reusing a slice at a set index within the arena \n#[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_uuid_str_131": {
      "name": "uuid_str",
      "type": "method",
      "start_line": 131,
      "end_line": 141,
      "content_hash": "55020f4545fb4d9cc06ac75087e39ac6a66af4a7",
      "content": "pub fn uuid_str(id: u128, arena: &bumpalo::Bump) -> &str {\n    let uuid = uuid::Uuid::from_u128(id);\n    let buffer = arena.alloc_slice_fill_default(36);\n    uuid.as_hyphenated().encode_lower(buffer)\n}\n\n/// Converts a uuid to a string slice using a buffer \n/// \n/// This is more efficient that using the `to_string` on the created uuid\n/// as it avoids formatting and potential double buffering\n#[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_uuid_str_from_buf_142": {
      "name": "uuid_str_from_buf",
      "type": "method",
      "start_line": 142,
      "end_line": 154,
      "content_hash": "07d21d11684d1ae029ce12ec75f5c28d1a20cef2",
      "content": "pub fn uuid_str_from_buf(id: u128, buffer: &mut [u8]) -> &str {\n    assert_eq!(buffer.len(), 36, \"length of hyphenated buffer should be 36 characters long\");\n    let uuid = uuid::Uuid::from_u128(id);\n    uuid.as_hyphenated().encode_lower(buffer)\n}\n\n#[cfg(test)]\nmod tests {\n    use sonic_rs::json;\n\n    use super::*;\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_deserialization_155": {
      "name": "test_uuid_deserialization",
      "type": "method",
      "start_line": 155,
      "end_line": 158,
      "content_hash": "b0ec64df76ff68c861dc7ceb53e8800c2cd2120c",
      "content": "    fn test_uuid_deserialization() {\n        let uuid = json!({ \"id\": \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\" });\n\n        #[derive(Deserialize)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_IDWrapper_159": {
      "name": "IDWrapper",
      "type": "struct",
      "start_line": 159,
      "end_line": 170,
      "content_hash": "a71724e736523b0008514be6a5b23d9a167b5fc2",
      "content": "        struct IDWrapper {\n            id: ID,\n        }\n\n        let deserialized: IDWrapper = sonic_rs::from_value(&uuid).unwrap();\n        assert_eq!(\n            deserialized.id.stringify(),\n            \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_serialization_171": {
      "name": "test_uuid_serialization",
      "type": "method",
      "start_line": 171,
      "end_line": 185,
      "content_hash": "a5f188f5e69d52b15debd8f83a322385e17df1fb",
      "content": "    fn test_uuid_serialization() {\n        let uuid = \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\";\n        let id = ID::from(uuid);\n\n        let serialized = sonic_rs::to_string(&id).unwrap();\n\n        let uuid_u128 = str::parse::<u128>(&serialized).unwrap();\n        let uuid = uuid::Uuid::from_u128(uuid_u128);\n\n        assert_eq!(uuid.to_string(), \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\");\n    }\n\n    // New comprehensive tests for v6_uuid() and ID type\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_v6_uuid_generation_uniqueness_186": {
      "name": "test_v6_uuid_generation_uniqueness",
      "type": "method",
      "start_line": 186,
      "end_line": 198,
      "content_hash": "3956b15d490b59a7938680e40c35c890d0dac950",
      "content": "    fn test_v6_uuid_generation_uniqueness() {\n        let id1 = v6_uuid();\n        let id2 = v6_uuid();\n\n        // UUIDs must be unique\n        assert_ne!(id1, id2, \"Generated UUIDs should be unique\");\n\n        // Must be valid u128 (non-zero)\n        assert!(id1 > 0, \"UUID should be non-zero\");\n        assert!(id2 > 0, \"UUID should be non-zero\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_v6_uuid_monotonicity_199": {
      "name": "test_v6_uuid_monotonicity",
      "type": "method",
      "start_line": 199,
      "end_line": 224,
      "content_hash": "52af79cd0297a02bc8db5bff21319b829c021007",
      "content": "    fn test_v6_uuid_monotonicity() {\n        // UUID v6 should be time-ordered (monotonically increasing)\n        let mut ids = Vec::new();\n        for _ in 0..100 {\n            ids.push(v6_uuid());\n            // Small delay to ensure time difference\n            std::thread::sleep(std::time::Duration::from_micros(1));\n        }\n\n        // Check that most IDs are monotonically increasing\n        let mut increasing_count = 0;\n        for window in ids.windows(2) {\n            if window[0] < window[1] {\n                increasing_count += 1;\n            }\n        }\n\n        // At least 95% should be increasing (allowing for some edge cases)\n        assert!(\n            increasing_count >= 95,\n            \"UUID v6 should be mostly monotonically increasing. Got {}/99 increasing\",\n            increasing_count\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_roundtrip_string_225": {
      "name": "test_uuid_roundtrip_string",
      "type": "method",
      "start_line": 225,
      "end_line": 238,
      "content_hash": "dc9bd1154a6737c9fbe32994df25014b502d51d9",
      "content": "    fn test_uuid_roundtrip_string() {\n        let original_id = v6_uuid();\n        let id = ID::from(original_id);\n        let string = id.stringify();\n        let parsed = ID::from(string.as_str());\n\n        assert_eq!(\n            *id, *parsed,\n            \"UUID roundtrip through string should preserve value\"\n        );\n        assert_eq!(id.inner(), parsed.inner());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_from_u128_239": {
      "name": "test_id_from_u128",
      "type": "method",
      "start_line": 239,
      "end_line": 247,
      "content_hash": "cadfe2f20ac56e4784150aad3618079ca6ec2963",
      "content": "    fn test_id_from_u128() {\n        let value: u128 = 12345678901234567890;\n        let id = ID::from(value);\n\n        assert_eq!(*id, value);\n        assert_eq!(id.inner(), value);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_from_string_248": {
      "name": "test_id_from_string",
      "type": "method",
      "start_line": 248,
      "end_line": 255,
      "content_hash": "e6202a54647fd696ca4e88c5639083b841a5908e",
      "content": "    fn test_id_from_string() {\n        let uuid_str = \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\";\n        let id = ID::from(uuid_str);\n\n        assert_eq!(id.stringify(), uuid_str);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_from_string_owned_256": {
      "name": "test_id_from_string_owned",
      "type": "method",
      "start_line": 256,
      "end_line": 263,
      "content_hash": "10011ed639581149f8e2acd3d42d5a543bdf54b6",
      "content": "    fn test_id_from_string_owned() {\n        let uuid_str = String::from(\"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\");\n        let id = ID::from(uuid_str.clone());\n\n        assert_eq!(id.stringify(), uuid_str);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_from_string_ref_264": {
      "name": "test_id_from_string_ref",
      "type": "method",
      "start_line": 264,
      "end_line": 271,
      "content_hash": "6887b9694bc2d6f7de5639c4c6b3feba9a604030",
      "content": "    fn test_id_from_string_ref() {\n        let uuid_str = String::from(\"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\");\n        let id = ID::from(&uuid_str);\n\n        assert_eq!(id.stringify(), uuid_str);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_deref_272": {
      "name": "test_id_deref",
      "type": "method",
      "start_line": 272,
      "end_line": 281,
      "content_hash": "af50c892cb5b4f26c9c958f8a8f0bb8f6e5bfb38",
      "content": "    fn test_id_deref() {\n        let value: u128 = 12345678901234567890;\n        let id = ID::from(value);\n\n        // Test Deref trait\n        let deref_value: &u128 = &*id;\n        assert_eq!(*deref_value, value);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_into_u128_282": {
      "name": "test_id_into_u128",
      "type": "method",
      "start_line": 282,
      "end_line": 290,
      "content_hash": "e67ef37fdd92ea746254029fe387a2149d46ce63",
      "content": "    fn test_id_into_u128() {\n        let value: u128 = 12345678901234567890;\n        let id = ID::from(value);\n        let back: u128 = id.into();\n\n        assert_eq!(back, value);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_comparison_291": {
      "name": "test_id_comparison",
      "type": "method",
      "start_line": 291,
      "end_line": 302,
      "content_hash": "271e3496cd0205ce0807353ae85e56a0475cf477",
      "content": "    fn test_id_comparison() {\n        let id1 = ID::from(100u128);\n        let id2 = ID::from(200u128);\n        let id3 = ID::from(100u128);\n\n        assert!(id1 < id2);\n        assert!(id2 > id1);\n        assert_eq!(id1, id3);\n        assert_ne!(id1, id2);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_ordering_303": {
      "name": "test_id_ordering",
      "type": "method",
      "start_line": 303,
      "end_line": 314,
      "content_hash": "f81087beab48cee9685b4d7bf5bb59d070e48587",
      "content": "    fn test_id_ordering() {\n        let mut ids = vec![ID::from(300u128), ID::from(100u128), ID::from(200u128)];\n\n        ids.sort();\n\n        assert_eq!(*ids[0], 100u128);\n        assert_eq!(*ids[1], 200u128);\n        assert_eq!(*ids[2], 300u128);\n    }\n\n    #[test]\n    #[should_panic]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_id_from_invalid_uuid_string_315": {
      "name": "test_id_from_invalid_uuid_string",
      "type": "method",
      "start_line": 315,
      "end_line": 320,
      "content_hash": "078dd3d0e0d6af90dd919b11a521a220d8928713",
      "content": "    fn test_id_from_invalid_uuid_string() {\n        // This should panic because the UUID string is invalid\n        let _ = ID::from(\"not-a-valid-uuid\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_v6_uuid_performance_321": {
      "name": "test_v6_uuid_performance",
      "type": "method",
      "start_line": 321,
      "end_line": 346,
      "content_hash": "ea835141e2cfd8993e19d4e427d32dc77bd0297c",
      "content": "    fn test_v6_uuid_performance() {\n        // Generate 10k UUIDs and ensure it completes in reasonable time\n        let start = std::time::Instant::now();\n        let mut ids = Vec::with_capacity(10_000);\n\n        for _ in 0..10_000 {\n            ids.push(v6_uuid());\n        }\n\n        let elapsed = start.elapsed();\n\n        // Should complete in less than 1 second\n        assert!(\n            elapsed.as_secs() < 1,\n            \"UUID generation too slow: {:?}\",\n            elapsed\n        );\n\n        // Verify all are unique\n        let unique_count = ids.iter().collect::<std::collections::HashSet<_>>().len();\n        assert_eq!(unique_count, 10_000, \"All generated UUIDs should be unique\");\n    }\n\n    // Tests for the new uuid_str arena-based approach\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_basic_347": {
      "name": "test_uuid_str_basic",
      "type": "method",
      "start_line": 347,
      "end_line": 361,
      "content_hash": "1e4fde4815d047b1f687728b2aba49c65da65256",
      "content": "    fn test_uuid_str_basic() {\n        let arena = bumpalo::Bump::new();\n\n        let expected_uuid = \"1f07ae4b-e354-6660-b5f0-fd3ce8bc4b49\";\n        let id: u128 = uuid::Uuid::parse_str(expected_uuid).unwrap().as_u128();\n\n        let uuid_string = uuid_str(id, &arena);\n\n        // Verify it returns the correct UUID string\n        assert_eq!(uuid_string, expected_uuid);\n        // Verify it's exactly 36 characters (standard UUID format)\n        assert_eq!(uuid_string.len(), 36);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_matches_stringify_362": {
      "name": "test_uuid_str_matches_stringify",
      "type": "method",
      "start_line": 362,
      "end_line": 373,
      "content_hash": "65fa346e62adf8bebca45ec548fcd74100dcad26",
      "content": "    fn test_uuid_str_matches_stringify() {\n        let arena = bumpalo::Bump::new();\n        let id = v6_uuid();\n\n        let arena_str = uuid_str(id, &arena);\n        let heap_str = ID::from(id).stringify();\n\n        // Both methods should produce the same result\n        assert_eq!(arena_str, heap_str);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_multiple_allocations_374": {
      "name": "test_uuid_str_multiple_allocations",
      "type": "method",
      "start_line": 374,
      "end_line": 405,
      "content_hash": "607590f93978d764ae31f4182464d011077c9952",
      "content": "    fn test_uuid_str_multiple_allocations() {\n        let arena = bumpalo::Bump::new();\n\n        let id1 = v6_uuid();\n        let id2 = v6_uuid();\n        let id3 = v6_uuid();\n\n        let str1 = uuid_str(id1, &arena);\n        let str2 = uuid_str(id2, &arena);\n        let str3 = uuid_str(id3, &arena);\n\n        // All strings should be different\n        assert_ne!(str1, str2);\n        assert_ne!(str2, str3);\n        assert_ne!(str1, str3);\n\n        // All should be valid UUIDs (36 chars)\n        assert_eq!(str1.len(), 36);\n        assert_eq!(str2.len(), 36);\n        assert_eq!(str3.len(), 36);\n\n        // Verify they can be parsed back\n        let parsed1 = ID::from(str1);\n        let parsed2 = ID::from(str2);\n        let parsed3 = ID::from(str3);\n\n        assert_eq!(*parsed1, id1);\n        assert_eq!(*parsed2, id2);\n        assert_eq!(*parsed3, id3);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_zero_id_406": {
      "name": "test_uuid_str_zero_id",
      "type": "method",
      "start_line": 406,
      "end_line": 416,
      "content_hash": "10ca0624a9248c0bd7a7bb19c6b3b6d47ca80456",
      "content": "    fn test_uuid_str_zero_id() {\n        let arena = bumpalo::Bump::new();\n        let id: u128 = 0;\n\n        let uuid_string = uuid_str(id, &arena);\n\n        assert_eq!(uuid_string, \"00000000-0000-0000-0000-000000000000\");\n        assert_eq!(uuid_string.len(), 36);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_max_id_417": {
      "name": "test_uuid_str_max_id",
      "type": "method",
      "start_line": 417,
      "end_line": 427,
      "content_hash": "70fc349a245f55403935d28108a408a628d9b081",
      "content": "    fn test_uuid_str_max_id() {\n        let arena = bumpalo::Bump::new();\n        let id: u128 = u128::MAX;\n\n        let uuid_string = uuid_str(id, &arena);\n\n        assert_eq!(uuid_string, \"ffffffff-ffff-ffff-ffff-ffffffffffff\");\n        assert_eq!(uuid_string.len(), 36);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_format_validation_428": {
      "name": "test_uuid_str_format_validation",
      "type": "method",
      "start_line": 428,
      "end_line": 452,
      "content_hash": "64e21ee80aaba3579ca0697a9b00bca4411b386c",
      "content": "    fn test_uuid_str_format_validation() {\n        let arena = bumpalo::Bump::new();\n        let id = v6_uuid();\n\n        let uuid_string = uuid_str(id, &arena);\n\n        // Verify the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n        let parts: Vec<&str> = uuid_string.split('-').collect();\n        assert_eq!(parts.len(), 5, \"UUID should have 5 hyphen-separated parts\");\n        assert_eq!(parts[0].len(), 8, \"First part should be 8 chars\");\n        assert_eq!(parts[1].len(), 4, \"Second part should be 4 chars\");\n        assert_eq!(parts[2].len(), 4, \"Third part should be 4 chars\");\n        assert_eq!(parts[3].len(), 4, \"Fourth part should be 4 chars\");\n        assert_eq!(parts[4].len(), 12, \"Fifth part should be 12 chars\");\n\n        // Verify all characters are valid hex (lowercase)\n        for c in uuid_string.chars() {\n            assert!(\n                c.is_ascii_hexdigit() || c == '-',\n                \"UUID should only contain hex digits and hyphens\"\n            );\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_roundtrip_453": {
      "name": "test_uuid_str_roundtrip",
      "type": "method",
      "start_line": 453,
      "end_line": 463,
      "content_hash": "78f26cd80b06b1a05bae6faf15de04f6804050df",
      "content": "    fn test_uuid_str_roundtrip() {\n        let arena = bumpalo::Bump::new();\n        let original_id = v6_uuid();\n\n        let uuid_string = uuid_str(original_id, &arena);\n        let parsed_id = ID::from(uuid_string);\n\n        assert_eq!(*parsed_id, original_id, \"UUID should survive roundtrip\");\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_arena_lifetime_464": {
      "name": "test_uuid_str_arena_lifetime",
      "type": "method",
      "start_line": 464,
      "end_line": 482,
      "content_hash": "ac8874d0a78aa66c2669a5281691a9560054f0d4",
      "content": "    fn test_uuid_str_arena_lifetime() {\n        // Test that the string lives as long as the arena\n        let arena = bumpalo::Bump::new();\n        let id = v6_uuid();\n\n        let uuid_string = uuid_str(id, &arena);\n\n        // Create multiple references to verify lifetime\n        let ref1 = uuid_string;\n        let ref2 = uuid_string;\n\n        assert_eq!(ref1, ref2);\n        assert_eq!(ref1.len(), 36);\n\n        // The string should still be valid here since arena is alive\n        assert!(ref1.chars().all(|c| c.is_ascii_hexdigit() || c == '-'));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_lowercase_483": {
      "name": "test_uuid_str_lowercase",
      "type": "method",
      "start_line": 483,
      "end_line": 495,
      "content_hash": "0d3470de34479411a4a08a321097761381fa26c1",
      "content": "    fn test_uuid_str_lowercase() {\n        let arena = bumpalo::Bump::new();\n        let id = v6_uuid();\n\n        let uuid_string = uuid_str(id, &arena);\n\n        // Verify the hex digits are lowercase\n        for c in uuid_string.chars().filter(|&c| c != '-') {\n            assert!(!c.is_uppercase(), \"UUID should use lowercase hex digits\");\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_matches_str_buf_496": {
      "name": "test_uuid_str_matches_str_buf",
      "type": "method",
      "start_line": 496,
      "end_line": 508,
      "content_hash": "b468d2a718db7ed870bb92ff809ce6d71c60ae9a",
      "content": "    fn test_uuid_str_matches_str_buf() {\n        let arena = bumpalo::Bump::new();\n        let id = v6_uuid();\n\n        let arena_str = uuid_str(id, &arena);\n\n        let mut buffer = [0u8; 36];\n        let temp_str = uuid_str_from_buf(id, &mut buffer);\n\n        assert_eq!(arena_str, temp_str);\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_performance_509": {
      "name": "test_uuid_str_performance",
      "type": "method",
      "start_line": 509,
      "end_line": 529,
      "content_hash": "b5cc9a6dc971b6d46cdf4e7f710246670d2ed454",
      "content": "    fn test_uuid_str_performance() {\n        // Test that uuid_str is efficient when using arena allocation\n        let arena = bumpalo::Bump::new();\n        let start = std::time::Instant::now();\n\n        for _ in 0..10_000 {\n            let id = v6_uuid();\n            let _ = uuid_str(id, &arena);\n        }\n\n        let elapsed = start.elapsed();\n\n        // Should be fast (under 100ms for 10k conversions)\n        assert!(\n            elapsed.as_millis() < 100,\n            \"uuid_str should be fast with arena allocation: {:?}\",\n            elapsed\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_test_uuid_str_memory_efficiency_530": {
      "name": "test_uuid_str_memory_efficiency",
      "type": "method",
      "start_line": 530,
      "end_line": 551,
      "content_hash": "cff73495485b097d2981e885b1f6bc531aa3c89e",
      "content": "    fn test_uuid_str_memory_efficiency() {\n        // Test that multiple uuid_str calls in the same arena are memory efficient\n        let arena = bumpalo::Bump::new();\n\n        let mut strings = Vec::new();\n        for _ in 0..1000 {\n            let id = v6_uuid();\n            strings.push(uuid_str(id, &arena));\n        }\n\n        // Verify all strings are valid\n        assert_eq!(strings.len(), 1000);\n        for s in &strings {\n            assert_eq!(s.len(), 36);\n        }\n\n        // All strings should be parseable back to IDs\n        for s in &strings {\n            let _ = ID::from(*s);\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}