{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/analyzer/pretty.rs",
  "file_hash": "f0b5811ee59ba2612da70b45e0e0e0e26a8ba549",
  "updated_at": "2025-12-26T17:34:20.892386",
  "symbols": {
    "function_render_18": {
      "name": "render",
      "type": "function",
      "start_line": 18,
      "end_line": 166,
      "content_hash": "a29852fce9a5abb391126a7fa304a7e3de516e12",
      "content": "pub fn render(diag: &Diagnostic, src: &str, filepath: &str) -> String {\n    // 1-based \u2192 0-based index\n    let line_idx = diag.location.start.line.saturating_sub(1);\n    let code_line = src.lines().nth(line_idx).unwrap_or(\"\");\n    let caret_pad = \" \".repeat(diag.location.start.column.saturating_sub(2));\n    // Calculate the span length for the error underline\n    let span_length = diag\n        .location\n        .end\n        .column\n        .saturating_sub(diag.location.start.column)\n        .max(1);\n    let caret_underline = \"^\".repeat(span_length).red().bold();\n\n    let mut out = String::new();\n\n    // Color the error/warning label based on severity\n    let severity_str = match diag.severity {\n        DiagnosticSeverity::Error => format!(\"error[{}]\", diag.error_code).red().bold(),\n        DiagnosticSeverity::Warning => format!(\"warning[{}]\", diag.error_code).yellow().bold(),\n        DiagnosticSeverity::Info => \"info\".blue().bold(),\n        DiagnosticSeverity::Hint => \"hint\".green().bold(),\n        DiagnosticSeverity::Empty => \"note\".normal(),\n    };\n\n    out.push_str(&format!(\"\\n{}: {}\\n\", severity_str, diag.message));\n\n    // Color the location line in red for errors, yellow for warnings\n    let location_color = match diag.severity {\n        DiagnosticSeverity::Error => format!(\n            \"{:>2} {} {}\",\n            \"\",\n            \"\u250c\u2500\".red(),\n            format!(\n                \"{filepath}:{line}:{col}\",\n                filepath = filepath,\n                line = diag.location.start.line,\n                col = diag.location.start.column\n            )\n            .bold(),\n        ),\n        DiagnosticSeverity::Warning => format!(\n            \"{:>2} {} {}\",\n            \"\",\n            \"\u250c\u2500\".yellow(),\n            format!(\n                \"{filepath}:{line}:{col}\",\n                filepath = filepath,\n                line = diag.location.start.line,\n                col = diag.location.start.column\n            )\n            .bold(),\n        ),\n        _ => format!(\n            \"{:>2} {} {}\",\n            \"\",\n            \"\u250c\u2500\".normal(),\n            format!(\n                \"{filepath}:{line}:{col}\",\n                filepath = filepath,\n                line = diag.location.start.line,\n                col = diag.location.start.column\n            )\n            .bold(),\n        ),\n    };\n\n    out.push_str(&format!(\"{location_color}\\n\"));\n\n    // Color the vertical bars and line numbers based on severity\n    let (line_num_color, vertical_bar) = match diag.severity {\n        DiagnosticSeverity::Error => (\n            format!(\"{:>2}\", diag.location.start.line).red().bold(),\n            \"\u2502\".red(),\n        ),\n        DiagnosticSeverity::Warning => (\n            format!(\"{:>2}\", diag.location.start.line).yellow().bold(),\n            \"\u2502\".yellow(),\n        ),\n        _ => (\n            format!(\"{:>2}\", diag.location.start.line).normal().bold(),\n            \"\u2502\".normal(),\n        ),\n    };\n\n    out.push_str(&format!(\"{:>2} {} \\n\", \"\", vertical_bar));\n    out.push_str(&format!(\"{line_num_color} {vertical_bar} {code_line}\\n\"));\n    out.push_str(&format!(\n        \"{:>2} {} {}{}\\n\",\n        \"\", vertical_bar, caret_pad, caret_underline\n    ));\n\n    if let Some(ref hint) = diag.hint {\n        out.push_str(&format!(\n            \"{} {}: {}\\n\",\n            \"--->\".blue().bold(),\n            \"help\".blue().bold(),\n            hint.blue().bold()\n        ));\n    }\n\n    if let Some(ref fix) = diag.fix {\n        let bar = &vertical_bar.clone().blue().bold();\n        let location = &format!(\"{:>2}\", diag.location.start.line).blue().bold();\n\n        let (start_chunk, end_chunk) = match &fix.span {\n            Some(span) => {\n                if let Some(to_remove) = &fix.to_remove {\n                    let start = to_remove.start.column - span.start.column;\n                    let end = to_remove.end.column - span.start.column;\n                    let start_chunk = span.span.split_at(start).0.to_string();\n                    let end_chunk = span.span.split_at(end).1.to_string();\n                    (\n                        start_chunk.trim_start_matches(\"\\t\").to_string(),\n                        end_chunk\n                            .trim_end_matches(|c: char| c.is_whitespace() || c == '\\n' || c == '\\r')\n                            .to_string(),\n                    )\n                } else {\n                    (\"\".to_string(), \"\".to_string())\n                }\n            }\n            None => (\"\".to_string(), \"\".to_string()),\n        };\n        out.push_str(&format!(\"{:>2} {}\\n\", \"\", bar));\n        if let Some(to_remove) = &fix.to_remove {\n            out.push_str(&format!(\n                \"{location} {} {start_chunk}{}{end_chunk}\\n\",\n                \"-\".bright_red().bold(),\n                to_remove\n                    .span\n                    .trim_end_matches('\\n')\n                    .to_string()\n                    .red()\n                    .bold(),\n            ));\n        }\n        if let Some(to_add) = &fix.to_add {\n            out.push_str(&format!(\n                \"{location} {} {start_chunk}{}{end_chunk}\\n\",\n                \"+\".green().bold(),\n                to_add.trim_end_matches('\\n').to_string().green().bold(),\n            ));\n        }\n        out.push_str(&format!(\"{:>2} {}\\n\", \"\", bar));\n    }\n\n    out\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}