{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helixc/generator/return_values.rs",
  "file_hash": "f8e6b13e69902e39e910684e9b14b508b47ea766",
  "updated_at": "2025-12-26T17:34:20.888611",
  "symbols": {
    "struct_ReturnValueField_8": {
      "name": "ReturnValueField",
      "type": "struct",
      "start_line": 8,
      "end_line": 15,
      "content_hash": "8230910b9800ea91d1fe9d15a221053766ecee20",
      "content": "pub struct ReturnValueField {\n    pub name: String,\n    pub field_type: String,\n    pub is_implicit: bool,         // id, label, from_node, to_node, data, score\n    pub is_nested_traversal: bool, // Whether this field contains a nested traversal\n    pub nested_struct_name: Option<String>, // Name of nested struct type if applicable\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ReturnValueField_16": {
      "name": "ReturnValueField",
      "type": "impl",
      "start_line": 16,
      "end_line": 16,
      "content_hash": "48be392e1b0411f48540c453e9cdc92c572f6ab0",
      "content": "impl ReturnValueField {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_17": {
      "name": "new",
      "type": "method",
      "start_line": 17,
      "end_line": 26,
      "content_hash": "db0c816e9aea19cea5126fb1958a353fee5f6d77",
      "content": "    pub fn new(name: String, field_type: String) -> Self {\n        Self {\n            name,\n            field_type,\n            is_implicit: false,\n            is_nested_traversal: false,\n            nested_struct_name: None,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_implicit_27": {
      "name": "with_implicit",
      "type": "method",
      "start_line": 27,
      "end_line": 31,
      "content_hash": "17c656ef7260fda5a5a597d522beaa951f824f05",
      "content": "    pub fn with_implicit(mut self, is_implicit: bool) -> Self {\n        self.is_implicit = is_implicit;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_nested_traversal_32": {
      "name": "with_nested_traversal",
      "type": "method",
      "start_line": 32,
      "end_line": 40,
      "content_hash": "4d0100de0ba253b3bbce642a5d6fb18a1aa94488",
      "content": "    pub fn with_nested_traversal(mut self, nested_struct_name: String) -> Self {\n        self.is_nested_traversal = true;\n        self.nested_struct_name = Some(nested_struct_name);\n        self\n    }\n}\n\n/// Represents a generated struct for return types\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ReturnValueStruct_41": {
      "name": "ReturnValueStruct",
      "type": "struct",
      "start_line": 41,
      "end_line": 55,
      "content_hash": "54c81b6db6845b485ee2916ec2f3974abe96bcb5",
      "content": "pub struct ReturnValueStruct {\n    pub name: String,\n    pub fields: Vec<ReturnValueField>,\n    pub has_lifetime: bool,         // Whether to add 'a lifetime parameter\n    pub is_query_return_type: bool, // True for the main QueryReturnType\n    pub is_collection: bool,        // True if this returns Vec<T>, false for single T\n    pub is_aggregate: bool,         // True for aggregate/group_by returns\n    pub is_group_by: bool,          // True for GROUP_BY, false for AGGREGATE_BY\n    pub source_variable: String,    // Variable name this struct is built from\n    pub is_reused_variable: bool,   // True if source variable is referenced multiple times\n    pub field_infos: Vec<ReturnFieldInfo>, // Original field info for nested struct generation\n    pub aggregate_properties: Vec<String>, // Properties to group by (for closure-style aggregates)\n    pub is_count_aggregate: bool,   // True for COUNT mode aggregates\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ReturnValueStruct_56": {
      "name": "ReturnValueStruct",
      "type": "impl",
      "start_line": 56,
      "end_line": 56,
      "content_hash": "ca956824be4fb1b9ff8093a5656f8606c3f72114",
      "content": "impl ReturnValueStruct {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_57": {
      "name": "new",
      "type": "method",
      "start_line": 57,
      "end_line": 73,
      "content_hash": "f8d2c9629dead9131d3c2c0b47a00b8af869e433",
      "content": "    pub fn new(name: String) -> Self {\n        Self {\n            name,\n            fields: Vec::new(),\n            has_lifetime: true,\n            is_query_return_type: false,\n            is_collection: false,\n            is_aggregate: false,\n            is_group_by: false,\n            source_variable: String::new(),\n            is_reused_variable: false,\n            field_infos: Vec::new(),\n            aggregate_properties: Vec::new(),\n            is_count_aggregate: false,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_fields_74": {
      "name": "with_fields",
      "type": "method",
      "start_line": 74,
      "end_line": 78,
      "content_hash": "58b2e1de247d47fee0a82b985e0e379208418c97",
      "content": "    pub fn with_fields(mut self, fields: Vec<ReturnValueField>) -> Self {\n        self.fields = fields;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_lifetime_79": {
      "name": "with_lifetime",
      "type": "method",
      "start_line": 79,
      "end_line": 83,
      "content_hash": "daab8b0f6598888c2720805819705b85634ce533",
      "content": "    pub fn with_lifetime(mut self, has_lifetime: bool) -> Self {\n        self.has_lifetime = has_lifetime;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_as_query_return_type_84": {
      "name": "as_query_return_type",
      "type": "method",
      "start_line": 84,
      "end_line": 88,
      "content_hash": "558fe584f041979fa75dfcc172a787e5d260785c",
      "content": "    pub fn as_query_return_type(mut self) -> Self {\n        self.is_query_return_type = true;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_collection_89": {
      "name": "with_collection",
      "type": "method",
      "start_line": 89,
      "end_line": 93,
      "content_hash": "fc7592e6822462f3c772b9af5615c7721ce96a85",
      "content": "    pub fn with_collection(mut self, is_collection: bool) -> Self {\n        self.is_collection = is_collection;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_source_variable_94": {
      "name": "with_source_variable",
      "type": "method",
      "start_line": 94,
      "end_line": 98,
      "content_hash": "6b42a884da0ae596113d73c51222c15381fbb11c",
      "content": "    pub fn with_source_variable(mut self, source_variable: String) -> Self {\n        self.source_variable = source_variable;\n        self\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_with_reused_variable_99": {
      "name": "with_reused_variable",
      "type": "method",
      "start_line": 99,
      "end_line": 104,
      "content_hash": "bc523969d382e99af33be203f5e0871a4961b250",
      "content": "    pub fn with_reused_variable(mut self, is_reused: bool) -> Self {\n        self.is_reused_variable = is_reused;\n        self\n    }\n\n    /// Generate the struct definition as a string",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_struct_def_105": {
      "name": "generate_struct_def",
      "type": "method",
      "start_line": 105,
      "end_line": 133,
      "content_hash": "3c10c86043b8f29bf2366e87087a21fd4a9c62b7",
      "content": "    pub fn generate_struct_def(&self) -> String {\n        let mut output = String::new();\n\n        // Generate derive attributes\n        output.push_str(\"#[derive(Serialize)]\\n\");\n\n        // Generate struct declaration\n        if self.has_lifetime {\n            output.push_str(&format!(\"pub struct {}<'a> {{\\n\", self.name));\n        } else {\n            output.push_str(&format!(\"pub struct {} {{\\n\", self.name));\n        }\n\n        // Generate fields\n        for field in &self.fields {\n            if self.has_lifetime {\n                output.push_str(&format!(\"    pub {}: {},\\n\", field.name, field.field_type));\n            } else {\n                // Remove lifetime parameters if not needed\n                let field_type = field.field_type.replace(\"<'a>\", \"\");\n                output.push_str(&format!(\"    pub {}: {},\\n\", field.name, field_type));\n            }\n        }\n\n        output.push_str(\"}\\n\");\n        output\n    }\n\n    /// Generate code to construct an instance of this struct from the source variable",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_struct_construction_134": {
      "name": "generate_struct_construction",
      "type": "method",
      "start_line": 134,
      "end_line": 184,
      "content_hash": "f0fceba37566036a2ddd118962a841138318f5be",
      "content": "    pub fn generate_struct_construction(&self) -> String {\n        let singular_var = self.source_variable.trim_end_matches('s');\n\n        // Generate the struct construction body\n        let mut body = format!(\"{} {{\\n\", self.name);\n\n        for field in &self.fields {\n            let field_value = if field.name == \"id\" {\n                format!(\"uuid_str({}.id(), &arena)\", singular_var)\n            } else if field.name == \"label\" {\n                format!(\"{}.label()\", singular_var)\n            } else if field.name == \"from_node\" {\n                format!(\"uuid_str({}.from_node(), &arena)\", singular_var)\n            } else if field.name == \"to_node\" {\n                format!(\"uuid_str({}.to_node(), &arena)\", singular_var)\n            } else if field.name == \"data\" {\n                format!(\"{}.data()\", singular_var)\n            } else if field.name == \"score\" {\n                format!(\"{}.score()\", singular_var)\n            } else if field.is_nested_traversal {\n                // Nested traversal - will be populated by nested G::new() call\n                \"/* nested traversal */\".to_string()\n            } else {\n                // Regular schema field\n                format!(\"{}.get_property(\\\"{}\\\").unwrap()\", singular_var, field.name)\n            };\n\n            body.push_str(&format!(\"        {}: {},\\n\", field.name, field_value));\n        }\n\n        body.push_str(\"    }\");\n\n        // Wrap in .map() for collections\n        if self.is_collection {\n            let iter_method = if self.is_reused_variable {\n                \"iter().cloned()\"\n            } else {\n                \"into_iter()\"\n            };\n\n            format!(\n                \"{}.{}.map(|{}| {}).collect::<Vec<_>>()\",\n                self.source_variable, iter_method, singular_var, body\n            )\n        } else {\n            // Single item - just construct the struct directly\n            body.replace(singular_var, &self.source_variable)\n        }\n    }\n\n    /// Create a ReturnValueStruct from unified field information",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_from_return_fields_185": {
      "name": "from_return_fields",
      "type": "method",
      "start_line": 185,
      "end_line": 285,
      "content_hash": "dfb7de3e605923e692deb8c9c45c36b5b6340674",
      "content": "    pub fn from_return_fields(\n        name: String,\n        field_infos: Vec<ReturnFieldInfo>,\n        source_variable: String,\n        is_collection: bool,\n        is_reused: bool,\n        is_aggregate: bool,\n        is_group_by: bool,\n        aggregate_properties: Vec<String>,\n        is_count_aggregate: bool,\n    ) -> Self {\n        // First, recursively build nested structs to determine if they have lifetimes\n        let mut nested_has_lifetime = std::collections::HashMap::new();\n        for field_info in &field_infos {\n            if let ReturnFieldType::Nested(nested_fields) = &field_info.field_type {\n                // Use the nested_struct_name from the source if available, otherwise fall back to field name\n                let nested_name = if let ReturnFieldSource::NestedTraversal {\n                    nested_struct_name: Some(name),\n                    ..\n                } = &field_info.source\n                {\n                    name.clone()\n                } else {\n                    format!(\"{}ReturnType\", capitalize_first(&field_info.name))\n                };\n                let nested_struct = Self::from_return_fields(\n                    nested_name.clone(),\n                    nested_fields.clone(),\n                    \"item\".to_string(),\n                    false,\n                    false,\n                    false,      // Nested structs are not aggregates\n                    false,      // Not group_by\n                    Vec::new(), // No aggregate properties for nested structs\n                    false,      // Not count aggregate\n                );\n                nested_has_lifetime.insert(nested_name, nested_struct.has_lifetime);\n            }\n        }\n\n        let fields = field_infos\n            .iter()\n            .map(|field_info| {\n                let (field_type, _is_nested, nested_name) = match &field_info.field_type {\n                    ReturnFieldType::Simple(ty) => (ty.clone(), false, None),\n                    ReturnFieldType::Nested(_) => {\n                        // Nested fields become Vec<NestedTypeName> or Vec<NestedTypeName<'a>>\n                        // Use the nested_struct_name from the source if available, otherwise fall back to field name\n                        let nested_type_name = if let ReturnFieldSource::NestedTraversal {\n                            nested_struct_name: Some(name),\n                            ..\n                        } = &field_info.source\n                        {\n                            name.clone()\n                        } else {\n                            format!(\"{}ReturnType\", capitalize_first(&field_info.name))\n                        };\n                        let has_lt = nested_has_lifetime\n                            .get(&nested_type_name)\n                            .copied()\n                            .unwrap_or(false);\n                        let type_ref = if has_lt {\n                            format!(\"Vec<{}<'a>>\", nested_type_name)\n                        } else {\n                            format!(\"Vec<{}>\", nested_type_name)\n                        };\n                        (type_ref, true, Some(nested_type_name))\n                    }\n                };\n\n                ReturnValueField {\n                    name: field_info.name.clone(),\n                    field_type,\n                    is_implicit: matches!(field_info.source, ReturnFieldSource::ImplicitField),\n                    is_nested_traversal: matches!(\n                        field_info.source,\n                        ReturnFieldSource::NestedTraversal { .. }\n                    ),\n                    nested_struct_name: nested_name,\n                }\n            })\n            .collect::<Vec<_>>();\n\n        // Check if any field contains a lifetime parameter\n        let has_lifetime = fields.iter().any(|f| f.field_type.contains(\"'a\"));\n\n        let mut struct_def = ReturnValueStruct::new(name);\n        struct_def.has_lifetime = has_lifetime;\n        struct_def.fields = fields;\n        struct_def.source_variable = source_variable;\n        struct_def.is_collection = is_collection;\n        struct_def.is_aggregate = is_aggregate;\n        struct_def.is_group_by = is_group_by;\n        struct_def.is_reused_variable = is_reused;\n        struct_def.field_infos = field_infos; // Store for nested generation\n        struct_def.aggregate_properties = aggregate_properties;\n        struct_def.is_count_aggregate = is_count_aggregate;\n        struct_def\n    }\n\n    /// Recursively generate all struct definitions (including nested ones)",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_all_struct_defs_286": {
      "name": "generate_all_struct_defs",
      "type": "method",
      "start_line": 286,
      "end_line": 325,
      "content_hash": "642b95e1574eec924b754bac3233f7e072b32375",
      "content": "    pub fn generate_all_struct_defs(&self) -> String {\n        let mut output = String::new();\n\n        // First, generate nested struct definitions\n        for field_info in &self.field_infos {\n            if let ReturnFieldType::Nested(nested_fields) = &field_info.field_type {\n                // Use the nested_struct_name from the source if available, otherwise fall back to field name\n                let nested_name = if let ReturnFieldSource::NestedTraversal {\n                    nested_struct_name: Some(name),\n                    ..\n                } = &field_info.source\n                {\n                    name.clone()\n                } else {\n                    format!(\"{}ReturnType\", capitalize_first(&field_info.name))\n                };\n                let nested_struct = ReturnValueStruct::from_return_fields(\n                    nested_name,\n                    nested_fields.clone(),\n                    \"item\".to_string(), // Placeholder - actual value comes from traversal\n                    false,              // Nested items are not collections themselves\n                    false,              // Not reused\n                    false,              // Nested structs are not aggregates\n                    false,              // Not group_by\n                    Vec::new(),         // No aggregate properties for nested structs\n                    false,              // Not count aggregate\n                );\n                // Recursively generate nested struct defs\n                output.push_str(&nested_struct.generate_all_struct_defs());\n                output.push_str(\"\\n\\n\");\n            }\n        }\n\n        // Then generate this struct's definition\n        output.push_str(&self.generate_struct_def());\n        output\n    }\n}\n\n/// Helper function to capitalize the first letter of a string",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_capitalize_first_326": {
      "name": "capitalize_first",
      "type": "method",
      "start_line": 326,
      "end_line": 336,
      "content_hash": "54743c97ece3d3275f8375a2f87d9b70cb0af535",
      "content": "fn capitalize_first(s: &str) -> String {\n    let mut chars = s.chars();\n    match chars.next() {\n        None => String::new(),\n        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),\n    }\n}\n\n/// Generate the body of a map closure for struct construction\n/// Returns: \"StructName { id: uuid_str(val.id(), &arena), ... }\"\n/// Note: Always uses \"val\" as the variable name to match closure parameter",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_generate_map_closure_body_337": {
      "name": "generate_map_closure_body",
      "type": "method",
      "start_line": 337,
      "end_line": 373,
      "content_hash": "2849e0e64be907acd8c4a4fb5288ae45e77b1ffc",
      "content": "pub fn generate_map_closure_body(\n    struct_name: &str,\n    fields: &[ReturnValueField],\n    _singular_var: &str,\n) -> String {\n    let mut body = format!(\"{} {{\\n\", struct_name);\n\n    for field in fields {\n        let field_value = if field.name == \"id\" {\n            \"uuid_str(val.id(), &arena)\".to_string()\n        } else if field.name == \"label\" {\n            \"val.label()\".to_string()\n        } else if field.name == \"from_node\" {\n            \"uuid_str(val.from_node(), &arena)\".to_string()\n        } else if field.name == \"to_node\" {\n            \"uuid_str(val.to_node(), &arena)\".to_string()\n        } else if field.name == \"data\" {\n            \"val.data()\".to_string()\n        } else if field.name == \"score\" {\n            \"val.score()\".to_string()\n        } else if field.is_nested_traversal {\n            // Nested traversal - will be populated by nested G::new() call\n            \"/* TODO: nested traversal */\".to_string()\n        } else {\n            // Regular schema field - return Option directly, no unwrap\n            format!(\"val.get_property(\\\"{}\\\")\", field.name)\n        };\n\n        body.push_str(&format!(\"            {}: {},\\n\", field.name, field_value));\n    }\n\n    body.push_str(\"        }\");\n    body\n}\n\n/// Represents how a return value should be constructed\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ReturnValueConstruction_374": {
      "name": "ReturnValueConstruction",
      "type": "enum",
      "start_line": 374,
      "end_line": 390,
      "content_hash": "083e1e8680f66aff626a3aeacf128896363eeb0b",
      "content": "pub enum ReturnValueConstruction {\n    /// Map a traversal result to a struct\n    MapTraversal {\n        variable_name: String,\n        struct_name: String,\n        field_mappings: Vec<FieldMapping>,\n    },\n    /// Construct a struct from existing variables\n    DirectConstruction {\n        struct_name: String,\n        field_assignments: Vec<(String, String)>, // field_name -> expression\n    },\n    /// A literal value (for backwards compatibility)\n    Literal { value: GenRef<String> },\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_FieldMapping_391": {
      "name": "FieldMapping",
      "type": "struct",
      "start_line": 391,
      "end_line": 396,
      "content_hash": "5e5064574746a990720510b66eea3c84b8c0c540",
      "content": "pub struct FieldMapping {\n    pub field_name: String,\n    pub source: FieldSource,\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_FieldSource_397": {
      "name": "FieldSource",
      "type": "enum",
      "start_line": 397,
      "end_line": 416,
      "content_hash": "f9b2db1e00ffa289fc81f40386c3af7a0ab086c2",
      "content": "pub enum FieldSource {\n    /// Call .id() on the value\n    Id,\n    /// Call .label() on the value\n    Label,\n    /// Call .get_property(name) on the value\n    Property(String),\n    /// Nested traversal that needs to be executed\n    NestedTraversal {\n        traversal_expr: String,\n        inner_mapping: Box<ReturnValueConstruction>,\n    },\n    /// Reference to another variable\n    Variable(String),\n    /// A literal value\n    Literal(String),\n}\n\n/// Unified field information for return types\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ReturnFieldInfo_417": {
      "name": "ReturnFieldInfo",
      "type": "struct",
      "start_line": 417,
      "end_line": 423,
      "content_hash": "d152fb35952d5f2e44c7f91432db0fa920a0c823",
      "content": "pub struct ReturnFieldInfo {\n    pub name: String,\n    pub field_type: ReturnFieldType,\n    pub source: ReturnFieldSource,\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ReturnFieldType_424": {
      "name": "ReturnFieldType",
      "type": "enum",
      "start_line": 424,
      "end_line": 431,
      "content_hash": "ffb08bd84d27966e2912e408755bbb7b9959812c",
      "content": "pub enum ReturnFieldType {\n    /// Simple type like \"&'a str\", \"Option<&'a Value>\", etc.\n    Simple(String),\n    /// Nested object with its own fields (for nested traversals)\n    Nested(Vec<ReturnFieldInfo>),\n}\n\n#[derive(Clone, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "enum_ReturnFieldSource_432": {
      "name": "ReturnFieldSource",
      "type": "enum",
      "start_line": 432,
      "end_line": 451,
      "content_hash": "d7aef035f03481bc91466e0a541427e353943049",
      "content": "pub enum ReturnFieldSource {\n    /// Field from the schema (node/edge/vector properties)\n    SchemaField,\n    /// Implicit field (id, label, from_node, to_node, data, score)\n    ImplicitField,\n    /// User-defined field in custom object\n    UserDefined,\n    /// Result of a nested traversal expression\n    NestedTraversal {\n        traversal_expr: String,\n        traversal_code: Option<String>, // Generated traversal code for response\n        nested_struct_name: Option<String>, // Name of the nested struct type\n        traversal_type: Option<super::traversal_steps::TraversalType>, // The actual traversal type for source extraction\n        closure_param_name: Option<String>, // Closure parameter if in closure context\n        closure_source_var: Option<String>, // Actual variable for the closure parameter\n        accessed_field_name: Option<String>, // For simple property access, the field being accessed (e.g., \"name\" for usr::{name})\n        own_closure_param: Option<String>, // This traversal's own closure parameter if it ends with a Closure step\n    },\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_ReturnFieldInfo_452": {
      "name": "ReturnFieldInfo",
      "type": "impl",
      "start_line": 452,
      "end_line": 452,
      "content_hash": "4e88120f101846f5ea1e7e029651c2dbba57f2ee",
      "content": "impl ReturnFieldInfo {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_implicit_453": {
      "name": "new_implicit",
      "type": "method",
      "start_line": 453,
      "end_line": 460,
      "content_hash": "b8b46c1f4ee1b7a127100a853cbc3559dbb1e507",
      "content": "    pub fn new_implicit(name: String, field_type: String) -> Self {\n        Self {\n            name,\n            field_type: ReturnFieldType::Simple(field_type),\n            source: ReturnFieldSource::ImplicitField,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_schema_461": {
      "name": "new_schema",
      "type": "method",
      "start_line": 461,
      "end_line": 468,
      "content_hash": "dd4ea19e2020ebe5851e5b59324a5a1e7b6aea29",
      "content": "    pub fn new_schema(name: String, field_type: String) -> Self {\n        Self {\n            name,\n            field_type: ReturnFieldType::Simple(field_type),\n            source: ReturnFieldSource::SchemaField,\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_nested_469": {
      "name": "new_nested",
      "type": "method",
      "start_line": 469,
      "end_line": 485,
      "content_hash": "19f4c503a4e24f2a8bb2e66307148c0f2926b547",
      "content": "    pub fn new_nested(name: String, fields: Vec<ReturnFieldInfo>, traversal_expr: String) -> Self {\n        Self {\n            name,\n            field_type: ReturnFieldType::Nested(fields),\n            source: ReturnFieldSource::NestedTraversal {\n                traversal_expr,\n                traversal_code: None,\n                nested_struct_name: None,\n                traversal_type: None,\n                closure_param_name: None,\n                closure_source_var: None,\n                accessed_field_name: None,\n                own_closure_param: None,\n            },\n        }\n    }\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_new_user_defined_486": {
      "name": "new_user_defined",
      "type": "method",
      "start_line": 486,
      "end_line": 495,
      "content_hash": "c691dbd3a272696363d3a91d6fc15453c2348870",
      "content": "    pub fn new_user_defined(name: String, field_type: String) -> Self {\n        Self {\n            name,\n            field_type: ReturnFieldType::Simple(field_type),\n            source: ReturnFieldSource::UserDefined,\n        }\n    }\n}\n\n/// Legacy ReturnValue structure for backwards compatibility",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_ReturnValue_496": {
      "name": "ReturnValue",
      "type": "struct",
      "start_line": 496,
      "end_line": 501,
      "content_hash": "fd5c39218a1862b60f2ce8c3d33503dda0018638",
      "content": "pub struct ReturnValue {\n    pub name: String,\n    pub fields: Vec<ReturnValueField>,\n    pub literal_value: Option<GenRef<String>>,\n}\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Display_502": {
      "name": "Display",
      "type": "impl",
      "start_line": 502,
      "end_line": 502,
      "content_hash": "ef0b63817acb47a895772fbc06e0a8f1fa128b62",
      "content": "impl Display for ReturnValue {",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_fmt_503": {
      "name": "fmt",
      "type": "method",
      "start_line": 503,
      "end_line": 512,
      "content_hash": "66f271d82dc63e6347ff7c72f59a36877fe9acb4",
      "content": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        writeln!(f, \"#[derive(Serialize)]\")?;\n        writeln!(f, \"pub struct {} {{\", self.name)?;\n        for field in &self.fields {\n            writeln!(f, \"    pub {}: {},\", field.name, field.field_type)?;\n        }\n        writeln!(f, \"}}\")?;\n        Ok(())\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}