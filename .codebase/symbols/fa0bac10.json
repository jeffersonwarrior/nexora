{
  "file_path": "/work/external-deps/helix-db/helix-db/src/protocol/custom_serde/tests.rs",
  "file_hash": "bf766d6b46072fd94300c31c6421eefcfe85e416",
  "updated_at": "2025-12-26T17:34:23.253845",
  "symbols": {
    "struct_OldNode_19": {
      "name": "OldNode",
      "type": "struct",
      "start_line": 19,
      "end_line": 62,
      "content_hash": "bb4220dabb41ce9ca3c61fa07b250d656c079af2",
      "content": "    struct OldNode {\n        #[serde(skip)]\n        pub id: u128,\n        pub label: String,\n        #[serde(default)]\n        pub version: u8,\n        #[serde(default)]\n        pub properties: Option<HashMap<String, Value>>,\n    }\n\n    /// Helper to create a test arena node with properties\n    fn create_arena_node_with_props<'arena>(\n        arena: &'arena Bump,\n        id: u128,\n        label: &str,\n        props: Vec<(&str, Value)>,\n    ) -> Node<'arena> {\n        let label_ref = arena.alloc_str(label);\n\n        if props.is_empty() {\n            Node {\n                id,\n                label: label_ref,\n                version: 0,\n                properties: None,\n            }\n        } else {\n            let len = props.len();\n            let props_iter = props.into_iter().map(|(k, v)| {\n                let key: &'arena str = arena.alloc_str(k);\n                (key, v)\n            });\n            let props_map = ImmutablePropertiesMap::new(len, props_iter, arena);\n\n            Node {\n                id,\n                label: label_ref,\n                version: 0,\n                properties: Some(props_map),\n            }\n        }\n    }\n\n    /// Helper to create an old node with properties",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_old_node_with_props_63": {
      "name": "create_old_node_with_props",
      "type": "function",
      "start_line": 63,
      "end_line": 90,
      "content_hash": "4e876f41ee0c5bf3df4e842f5d8aba5122fd8484",
      "content": "    fn create_old_node_with_props(\n        id: u128,\n        label: &str,\n        props: Vec<(&str, Value)>,\n    ) -> OldNode {\n        if props.is_empty() {\n            OldNode {\n                id,\n                label: label.to_string(),\n                version: 0,\n                properties: None,\n            }\n        } else {\n            let mut props_map = HashMap::new();\n            for (k, v) in props {\n                props_map.insert(k.to_string(), v);\n            }\n\n            OldNode {\n                id,\n                label: label.to_string(),\n                version: 0,\n                properties: Some(props_map),\n            }\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_detailed_byte_analysis_empty_properties_91": {
      "name": "test_detailed_byte_analysis_empty_properties",
      "type": "function",
      "start_line": 91,
      "end_line": 152,
      "content_hash": "965b332d54cc5dea1c61bae824eb57296b3828e9",
      "content": "    fn test_detailed_byte_analysis_empty_properties() {\n        let arena = Bump::new();\n        let id = 12345u128;\n\n        // Create both old and new nodes\n        let old_node = OldNode {\n            id,\n            label: \"Person\".to_string(),\n            version: 0,\n            properties: None,\n        };\n\n        let new_node = Node {\n            id,\n            label: arena.alloc_str(\"Person\"),\n            version: 0,\n            properties: None,\n        };\n\n        // Serialize both\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        println!(\"\\n=== EMPTY PROPERTIES COMPARISON ===\");\n        println!(\"Old bytes ({} total): {:02x?}\", old_bytes.len(), old_bytes);\n        println!(\"New bytes ({} total): {:02x?}\", new_bytes.len(), new_bytes);\n\n        // Detailed analysis\n        println!(\"\\nByte-by-byte comparison:\");\n        for (i, (old_byte, new_byte)) in old_bytes.iter().zip(new_bytes.iter()).enumerate() {\n            if old_byte != new_byte {\n                println!(\"  Index {}: old={:02x} ({}), new={:02x} ({})\",\n                    i, old_byte, old_byte, new_byte, new_byte);\n            }\n        }\n\n        // Bytes should be IDENTICAL\n        assert_eq!(\n            old_bytes, new_bytes,\n            \"Serialized bytes differ for empty properties!\"\n        );\n\n        // Test that new format can deserialize its own output\n        println!(\"\\nAttempting to deserialize new_bytes...\");\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2);\n        if let Err(e) = &deserialized {\n            println!(\"Deserialization error: {:?}\", e);\n        }\n        assert!(deserialized.is_ok(), \"Failed to deserialize new format: {:?}\", deserialized.err());\n\n        // Test that new format can deserialize old format\n        println!(\"Attempting to deserialize old_bytes...\");\n        let arena3 = Bump::new();\n        let old_deserialized = Node::from_bincode_bytes(id, &old_bytes, &arena3);\n        if let Err(e) = &old_deserialized {\n            println!(\"Deserialization error from old format: {:?}\", e);\n        }\n        assert!(old_deserialized.is_ok(), \"Failed to deserialize old format: {:?}\", old_deserialized.err());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_detailed_byte_analysis_with_properties_153": {
      "name": "test_detailed_byte_analysis_with_properties",
      "type": "function",
      "start_line": 153,
      "end_line": 249,
      "content_hash": "ac90f345d79f4636863f8c4cd261e120d888c6ee",
      "content": "    fn test_detailed_byte_analysis_with_properties() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        // Create old node with properties\n        let mut old_props_map = HashMap::new();\n        old_props_map.insert(\"name\".to_string(), Value::String(\"Alice\".to_string()));\n        old_props_map.insert(\"age\".to_string(), Value::I32(30));\n\n        let old_node = OldNode {\n            id,\n            label: \"User\".to_string(),\n            version: 0,\n            properties: Some(old_props_map),\n        };\n\n        // Create new node with same properties\n        let new_props = vec![\n            (\"name\", Value::String(\"Alice\".to_string())),\n            (\"age\", Value::I32(30)),\n        ];\n        let new_node = create_arena_node_with_props(&arena, id, \"User\", new_props);\n\n        // Serialize both\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        println!(\"\\n=== WITH PROPERTIES COMPARISON ===\");\n        println!(\"Old bytes ({} total): {:02x?}\", old_bytes.len(), old_bytes);\n        println!(\"New bytes ({} total): {:02x?}\", new_bytes.len(), new_bytes);\n\n        println!(\"\\nOld as string interpretation:\");\n        for (i, byte) in old_bytes.iter().enumerate() {\n            if *byte >= 32 && *byte < 127 {\n                print!(\"{}\", *byte as char);\n            } else {\n                print!(\"[{:02x}]\", byte);\n            }\n            if (i + 1) % 40 == 0 {\n                println!();\n            }\n        }\n        println!();\n\n        println!(\"\\nNew as string interpretation:\");\n        for (i, byte) in new_bytes.iter().enumerate() {\n            if *byte >= 32 && *byte < 127 {\n                print!(\"{}\", *byte as char);\n            } else {\n                print!(\"[{:02x}]\", byte);\n            }\n            if (i + 1) % 40 == 0 {\n                println!();\n            }\n        }\n        println!();\n\n        // Test deserialization of new format\n        println!(\"\\nAttempting to deserialize new_bytes...\");\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2);\n        if let Err(e) = &deserialized {\n            println!(\"Deserialization error: {:?}\", e);\n        } else {\n            println!(\"Successfully deserialized!\");\n            let node = deserialized.unwrap();\n            println!(\"  Label: {}\", node.label);\n            println!(\"  Version: {}\", node.version);\n            if let Some(props) = &node.properties {\n                println!(\"  Properties: {} entries\", props.len());\n                for (k, v) in props.iter() {\n                    println!(\"    {}: {:?}\", k, v);\n                }\n            }\n        }\n\n        // Test deserialization of old format\n        println!(\"\\nAttempting to deserialize old_bytes...\");\n        let arena3 = Bump::new();\n        let old_deserialized = Node::from_bincode_bytes(id, &old_bytes, &arena3);\n        if let Err(e) = &old_deserialized {\n            println!(\"Deserialization error from old format: {:?}\", e);\n        } else {\n            println!(\"Successfully deserialized old format!\");\n            let node = old_deserialized.unwrap();\n            println!(\"  Label: {}\", node.label);\n            println!(\"  Version: {}\", node.version);\n            if let Some(props) = &node.properties {\n                println!(\"  Properties: {} entries\", props.len());\n                for (k, v) in props.iter() {\n                    println!(\"    {}: {:?}\", k, v);\n                }\n            }\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_single_property_250": {
      "name": "test_node_serialization_single_property",
      "type": "function",
      "start_line": 250,
      "end_line": 269,
      "content_hash": "b2748cd3e3107e0fb73b4480d0265d7f9a66aa32",
      "content": "    fn test_node_serialization_single_property() {\n        let arena = Bump::new();\n        let id = 67890u128;\n\n        let props = vec![(\"name\", Value::String(\"Alice\".to_string()))];\n\n        let old_node = create_old_node_with_props(id, \"User\", props.clone());\n        let new_node = create_arena_node_with_props(&arena, id, \"User\", props);\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        assert_eq!(\n            old_bytes, new_bytes,\n            \"Serialized bytes differ for single property!\\nOld: {:?}\\nNew: {:?}\",\n            old_bytes, new_bytes\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_multiple_properties_semantic_equality_270": {
      "name": "test_node_serialization_multiple_properties_semantic_equality",
      "type": "function",
      "start_line": 270,
      "end_line": 301,
      "content_hash": "cb9a82caa95beaf3a3da9fe5ccffba59adad68c8",
      "content": "    fn test_node_serialization_multiple_properties_semantic_equality() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        let props = vec![\n            (\"name\", Value::String(\"Bob\".to_string())),\n            (\"age\", Value::I64(30)),\n            (\"score\", Value::F64(95.5)),\n        ];\n\n        let new_node = create_arena_node_with_props(&arena, id, \"Player\", props);\n\n        // Serialize the new node\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize it back\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        // Verify all fields match\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"Player\");\n        assert_eq!(deserialized.version, 0);\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 3);\n        assert_eq!(props.get(\"name\"), Some(&Value::String(\"Bob\".to_string())));\n        assert_eq!(props.get(\"age\"), Some(&Value::I64(30)));\n        assert_eq!(props.get(\"score\"), Some(&Value::F64(95.5)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_various_value_types_roundtrip_302": {
      "name": "test_node_serialization_various_value_types_roundtrip",
      "type": "function",
      "start_line": 302,
      "end_line": 346,
      "content_hash": "250005fa46dc3b878f6c216fc72807e1120cf084",
      "content": "    fn test_node_serialization_various_value_types_roundtrip() {\n        let arena = Bump::new();\n        let id = 11111u128;\n\n        let props = vec![\n            (\"string_val\", Value::String(\"test\".to_string())),\n            (\"i8_val\", Value::I8(-42)),\n            (\"i16_val\", Value::I16(1000)),\n            (\"i32_val\", Value::I32(100000)),\n            (\"i64_val\", Value::I64(9999999)),\n            (\"u8_val\", Value::U8(255)),\n            (\"u16_val\", Value::U16(65535)),\n            (\"u32_val\", Value::U32(4294967295)),\n            (\"u64_val\", Value::U64(18446744073709551615)),\n            (\"u128_val\", Value::U128(340282366920938463463374607431768211455)),\n            (\"f32_val\", Value::F32(3.14159)),\n            (\"f64_val\", Value::F64(2.71828)),\n            (\"bool_val\", Value::Boolean(true)),\n        ];\n\n        let new_node = create_arena_node_with_props(&arena, id, \"AllTypes\", props);\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize and verify all values\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 13);\n        assert_eq!(props.get(\"string_val\"), Some(&Value::String(\"test\".to_string())));\n        assert_eq!(props.get(\"i8_val\"), Some(&Value::I8(-42)));\n        assert_eq!(props.get(\"i16_val\"), Some(&Value::I16(1000)));\n        assert_eq!(props.get(\"i32_val\"), Some(&Value::I32(100000)));\n        assert_eq!(props.get(\"i64_val\"), Some(&Value::I64(9999999)));\n        assert_eq!(props.get(\"u8_val\"), Some(&Value::U8(255)));\n        assert_eq!(props.get(\"u16_val\"), Some(&Value::U16(65535)));\n        assert_eq!(props.get(\"u32_val\"), Some(&Value::U32(4294967295)));\n        assert_eq!(props.get(\"u64_val\"), Some(&Value::U64(18446744073709551615)));\n        assert_eq!(props.get(\"u128_val\"), Some(&Value::U128(340282366920938463463374607431768211455)));\n        assert_eq!(props.get(\"f32_val\"), Some(&Value::F32(3.14159)));\n        assert_eq!(props.get(\"f64_val\"), Some(&Value::F64(2.71828)));\n        assert_eq!(props.get(\"bool_val\"), Some(&Value::Boolean(true)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_nested_values_347": {
      "name": "test_node_serialization_nested_values",
      "type": "function",
      "start_line": 347,
      "end_line": 395,
      "content_hash": "6d66a7e0869caa87c71eec8a5c1f825c146b320a",
      "content": "    fn test_node_serialization_nested_values() {\n        let arena = Bump::new();\n        let id = 22222u128;\n\n        let props = vec![\n            (\"array\", Value::Array(vec![\n                Value::I32(1),\n                Value::I32(2),\n                Value::I32(3),\n            ])),\n            (\"nested_obj\", {\n                let mut map = HashMap::new();\n                map.insert(\"inner_key\".to_string(), Value::String(\"inner_value\".to_string()));\n                Value::Object(map)\n            }),\n        ];\n\n        let old_node = create_old_node_with_props(id, \"Complex\", props.clone());\n        let new_node = create_arena_node_with_props(&arena, id, \"Complex\", props);\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Note: Property order may differ between HashMap (old) and ImmutablePropertiesMap (new)\n        // So we check semantic equality by deserializing both and comparing the values\n        let arena2 = Bump::new();\n        let arena3 = Bump::new();\n\n        let deserialized_old = Node::from_bincode_bytes(id, &old_bytes, &arena2).unwrap();\n        let deserialized_new = Node::from_bincode_bytes(id, &new_bytes, &arena3).unwrap();\n\n        assert_eq!(deserialized_old.id, id);\n        assert_eq!(deserialized_old.label, \"Complex\");\n        assert_eq!(deserialized_new.id, id);\n        assert_eq!(deserialized_new.label, \"Complex\");\n\n        let old_props = deserialized_old.properties.unwrap();\n        let new_props = deserialized_new.properties.unwrap();\n        assert_eq!(old_props.len(), new_props.len());\n\n        // Check that both have the same keys and values (regardless of order)\n        for (key, old_value) in old_props.iter() {\n            let new_value = new_props.get(key).expect(&format!(\"Missing key: {}\", key));\n            // For nested objects, we need to compare recursively since HashMap order may differ\n            assert!(values_equal(old_value, new_value), \"Value mismatch for key {}: {:?} != {:?}\", key, old_value, new_value);\n        }\n    }\n\n    // Helper function to compare Values recursively, ignoring HashMap order",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_values_equal_396": {
      "name": "values_equal",
      "type": "function",
      "start_line": 396,
      "end_line": 424,
      "content_hash": "33ea11d1c37b89c80b2971ad1400380743bd2f5f",
      "content": "    fn values_equal(a: &Value, b: &Value) -> bool {\n        match (a, b) {\n            (Value::Empty, Value::Empty) => true,\n            (Value::Boolean(a), Value::Boolean(b)) => a == b,\n            (Value::I8(a), Value::I8(b)) => a == b,\n            (Value::I16(a), Value::I16(b)) => a == b,\n            (Value::I32(a), Value::I32(b)) => a == b,\n            (Value::I64(a), Value::I64(b)) => a == b,\n            (Value::U8(a), Value::U8(b)) => a == b,\n            (Value::U16(a), Value::U16(b)) => a == b,\n            (Value::U32(a), Value::U32(b)) => a == b,\n            (Value::U64(a), Value::U64(b)) => a == b,\n            (Value::U128(a), Value::U128(b)) => a == b,\n            (Value::F32(a), Value::F32(b)) => (a.is_nan() && b.is_nan()) || a == b,\n            (Value::F64(a), Value::F64(b)) => (a.is_nan() && b.is_nan()) || a == b,\n            (Value::String(a), Value::String(b)) => a == b,\n            (Value::Array(a), Value::Array(b)) => {\n                a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| values_equal(x, y))\n            }\n            (Value::Object(a), Value::Object(b)) => {\n                a.len() == b.len() && a.iter().all(|(k, v)| b.get(k).map_or(false, |bv| values_equal(v, bv)))\n            }\n            (Value::Date(a), Value::Date(b)) => a == b,\n            (Value::Id(a), Value::Id(b)) => a == b,\n            _ => false,\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_with_version_425": {
      "name": "test_node_serialization_with_version",
      "type": "function",
      "start_line": 425,
      "end_line": 454,
      "content_hash": "ba47ba4666f253801c389353c8b3c193f34b3667",
      "content": "    fn test_node_serialization_with_version() {\n        let arena = Bump::new();\n        let id = 33333u128;\n        let label = \"VersionedNode\";\n\n        // Create nodes with explicit version\n        let old_node = OldNode {\n            id,\n            label: label.to_string(),\n            version: 5,\n            properties: None,\n        };\n\n        let new_node = Node {\n            id,\n            label: arena.alloc_str(label),\n            version: 5,\n            properties: None,\n        };\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        assert_eq!(\n            old_bytes, new_bytes,\n            \"Serialized bytes differ for versioned nodes!\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_deserialization_from_old_format_455": {
      "name": "test_node_deserialization_from_old_format",
      "type": "function",
      "start_line": 455,
      "end_line": 483,
      "content_hash": "f9019d0f4018d1e07f1f6f78973b6af90d494340",
      "content": "    fn test_node_deserialization_from_old_format() {\n        let arena = Bump::new();\n        let id = 44444u128;\n\n        let props = vec![\n            (\"name\", Value::String(\"Charlie\".to_string())),\n            (\"count\", Value::U64(42)),\n        ];\n\n        // Create and serialize old node\n        let old_node = create_old_node_with_props(id, \"OldFormat\", props);\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        // Deserialize into new node format\n        let deserialized_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        // Verify fields\n        assert_eq!(deserialized_node.id, id);\n        assert_eq!(deserialized_node.label, \"OldFormat\");\n        assert_eq!(deserialized_node.version, 0);\n        assert!(deserialized_node.properties.is_some());\n\n        let props = deserialized_node.properties.unwrap();\n        assert_eq!(props.len(), 2);\n        assert_eq!(props.get(\"name\"), Some(&Value::String(\"Charlie\".to_string())));\n        assert_eq!(props.get(\"count\"), Some(&Value::U64(42)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_roundtrip_serialization_484": {
      "name": "test_node_roundtrip_serialization",
      "type": "function",
      "start_line": 484,
      "end_line": 522,
      "content_hash": "36feb9e017770db550de9f707d6e62a7d36f158f",
      "content": "    fn test_node_roundtrip_serialization() {\n        let arena = Bump::new();\n        let id = 55555u128;\n\n        let props = vec![\n            (\"key1\", Value::String(\"value1\".to_string())),\n            (\"key2\", Value::I32(100)),\n            (\"key3\", Value::Boolean(false)),\n        ];\n\n        // Create new node\n        let original_node = create_arena_node_with_props(&arena, id, \"Roundtrip\", props);\n\n        // Serialize\n        let serialized = bincode::serialize(&original_node).unwrap();\n\n        // Deserialize\n        let arena2 = Bump::new();\n        let deserialized_node = Node::from_bincode_bytes(id, &serialized, &arena2).unwrap();\n\n        // Verify all fields match\n        assert_eq!(deserialized_node.id, original_node.id);\n        assert_eq!(deserialized_node.label, original_node.label);\n        assert_eq!(deserialized_node.version, original_node.version);\n\n        // Verify properties\n        match (original_node.properties, deserialized_node.properties) {\n            (Some(orig_props), Some(deser_props)) => {\n                assert_eq!(orig_props.len(), deser_props.len());\n                for (k, v) in orig_props.iter() {\n                    assert_eq!(deser_props.get(k), Some(v));\n                }\n            }\n            (None, None) => {}\n            _ => panic!(\"Properties mismatch: one is Some, other is None\"),\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_byte_level_comparison_empty_523": {
      "name": "test_node_byte_level_comparison_empty",
      "type": "function",
      "start_line": 523,
      "end_line": 545,
      "content_hash": "1b60a3ffcba32df3938fd77d90177478c9f0358f",
      "content": "    fn test_node_byte_level_comparison_empty() {\n        let arena = Bump::new();\n        let id = 66666u128;\n\n        let old_node = create_old_node_with_props(id, \"Empty\", vec![]);\n        let new_node = create_arena_node_with_props(&arena, id, \"Empty\", vec![]);\n\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Detailed byte comparison\n        assert_eq!(old_bytes.len(), new_bytes.len(), \"Byte lengths differ\");\n\n        for (i, (old_byte, new_byte)) in old_bytes.iter().zip(new_bytes.iter()).enumerate() {\n            assert_eq!(\n                old_byte, new_byte,\n                \"Byte mismatch at index {}: old={:02x}, new={:02x}\",\n                i, old_byte, new_byte\n            );\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_deserialization_semantic_equivalence_546": {
      "name": "test_node_deserialization_semantic_equivalence",
      "type": "function",
      "start_line": 546,
      "end_line": 571,
      "content_hash": "ccaf5b9bd9a3ea3eaaabbe04384a9c4a251c4e22",
      "content": "    fn test_node_deserialization_semantic_equivalence() {\n        let arena = Bump::new();\n        let id = 77777u128;\n\n        let props = vec![\n            (\"alpha\", Value::String(\"beta\".to_string())),\n            (\"gamma\", Value::I64(999)),\n        ];\n\n        let new_node = create_arena_node_with_props(&arena, id, \"ByteTest\", props);\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize and verify\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"ByteTest\");\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 2);\n        assert_eq!(props.get(\"alpha\"), Some(&Value::String(\"beta\".to_string())));\n        assert_eq!(props.get(\"gamma\"), Some(&Value::I64(999)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_edge_cases_572": {
      "name": "test_node_serialization_edge_cases",
      "type": "function",
      "start_line": 572,
      "end_line": 601,
      "content_hash": "9b755df4b6ec91e4475cddf943e98a44c1baf4c7",
      "content": "    fn test_node_serialization_edge_cases() {\n        let arena = Bump::new();\n\n        // Empty label\n        let node1_old = create_old_node_with_props(1, \"\", vec![]);\n        let node1_new = create_arena_node_with_props(&arena, 1, \"\", vec![]);\n        assert_eq!(\n            bincode::serialize(&node1_old).unwrap(),\n            bincode::serialize(&node1_new).unwrap()\n        );\n\n        // Very long label\n        let long_label = \"a\".repeat(1000);\n        let node2_old = create_old_node_with_props(2, &long_label, vec![]);\n        let node2_new = create_arena_node_with_props(&arena, 2, &long_label, vec![]);\n        assert_eq!(\n            bincode::serialize(&node2_old).unwrap(),\n            bincode::serialize(&node2_new).unwrap()\n        );\n\n        // Max u128 ID\n        let node3_old = create_old_node_with_props(u128::MAX, \"MaxID\", vec![]);\n        let node3_new = create_arena_node_with_props(&arena, u128::MAX, \"MaxID\", vec![]);\n        assert_eq!(\n            bincode::serialize(&node3_old).unwrap(),\n            bincode::serialize(&node3_new).unwrap()\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_utf8_labels_602": {
      "name": "test_node_serialization_utf8_labels",
      "type": "function",
      "start_line": 602,
      "end_line": 629,
      "content_hash": "a364893d98ee7a3c316aeb02fa43251f92cc27a5",
      "content": "    fn test_node_serialization_utf8_labels() {\n        let arena = Bump::new();\n\n        let utf8_labels = vec![\n            \"Hello\",\n            \"\u4e16\u754c\",\n            \"\ud83d\ude80\ud83c\udf1f\",\n            \"\u041f\u0440\u0438\u0432\u0435\u0442\",\n            \"\u0645\u0631\u062d\u0628\u0627\",\n            \"\u00d1o\u00f1o\",\n        ];\n\n        for (idx, label) in utf8_labels.iter().enumerate() {\n            let id = idx as u128;\n            let old_node = create_old_node_with_props(id, label, vec![]);\n            let new_node = create_arena_node_with_props(&arena, id, label, vec![]);\n\n            let old_bytes = bincode::serialize(&old_node).unwrap();\n            let new_bytes = bincode::serialize(&new_node).unwrap();\n\n            assert_eq!(\n                old_bytes, new_bytes,\n                \"UTF-8 label '{}' serialization differs\", label\n            );\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_utf8_property_keys_and_values_roundtrip_630": {
      "name": "test_node_serialization_utf8_property_keys_and_values_roundtrip",
      "type": "function",
      "start_line": 630,
      "end_line": 654,
      "content_hash": "098d79dd58d058d9237ab3bc9a041d0d49fdc186",
      "content": "    fn test_node_serialization_utf8_property_keys_and_values_roundtrip() {\n        let arena = Bump::new();\n        let id = 88888u128;\n\n        let props = vec![\n            (\"\u540d\u524d\", Value::String(\"\u592a\u90ce\".to_string())),\n            (\"\u0432\u043e\u0437\u0440\u0430\u0441\u0442\", Value::I32(25)),\n            (\"emoji_key_\ud83c\udf89\", Value::String(\"party_\ud83c\udf8a\".to_string())),\n        ];\n\n        let new_node = create_arena_node_with_props(&arena, id, \"UTF8Props\", props);\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize and verify UTF-8 handling\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 3);\n        assert_eq!(props.get(\"\u540d\u524d\"), Some(&Value::String(\"\u592a\u90ce\".to_string())));\n        assert_eq!(props.get(\"\u0432\u043e\u0437\u0440\u0430\u0441\u0442\"), Some(&Value::I32(25)));\n        assert_eq!(props.get(\"emoji_key_\ud83c\udf89\"), Some(&Value::String(\"party_\ud83c\udf8a\".to_string())));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_serialization_many_properties_roundtrip_655": {
      "name": "test_node_serialization_many_properties_roundtrip",
      "type": "function",
      "start_line": 655,
      "end_line": 684,
      "content_hash": "53b6d679408f0ceeba96bfdfdf2eecd673932fab",
      "content": "    fn test_node_serialization_many_properties_roundtrip() {\n        let arena = Bump::new();\n        let id = 99999u128;\n\n        // Create 50 properties\n        let props: Vec<(&str, Value)> = (0..50)\n            .map(|i| {\n                let key = Box::leak(format!(\"key_{}\", i).into_boxed_str());\n                (key as &str, Value::I32(i))\n            })\n            .collect();\n\n        let new_node = create_arena_node_with_props(&arena, id, \"ManyProps\", props);\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize and verify all 50 properties\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 50);\n\n        // Verify all properties are present with correct values\n        for i in 0..50 {\n            let key = format!(\"key_{}\", i);\n            assert_eq!(props.get(&key), Some(&Value::I32(i)), \"Missing or incorrect value for {}\", key);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_deserialization_from_old_preserves_all_properties_685": {
      "name": "test_node_deserialization_from_old_preserves_all_properties",
      "type": "function",
      "start_line": 685,
      "end_line": 710,
      "content_hash": "5362fd0e3aee60d2ae12266be582b02f8d027756",
      "content": "    fn test_node_deserialization_from_old_preserves_all_properties() {\n        let id = 12121u128;\n\n        // Create old node and serialize it\n        let props = vec![\n            (\"aaa\", Value::I32(1)),\n            (\"bbb\", Value::I32(2)),\n            (\"ccc\", Value::I32(3)),\n        ];\n\n        let old_node = create_old_node_with_props(id, \"Ordered\", props);\n        let old_bytes = bincode::serialize(&old_node).unwrap();\n\n        // Deserialize using new format\n        let arena = Bump::new();\n        let new_node = Node::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        // Verify all properties are present (order may differ)\n        let new_props = new_node.properties.unwrap();\n        assert_eq!(new_props.len(), 3);\n        assert_eq!(new_props.get(\"aaa\"), Some(&Value::I32(1)));\n        assert_eq!(new_props.get(\"bbb\"), Some(&Value::I32(2)));\n        assert_eq!(new_props.get(\"ccc\"), Some(&Value::I32(3)));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_node_empty_value_serialization_roundtrip_711": {
      "name": "test_node_empty_value_serialization_roundtrip",
      "type": "function",
      "start_line": 711,
      "end_line": 744,
      "content_hash": "b7821b99ebe889635022c0db76f168df0113e0ec",
      "content": "    fn test_node_empty_value_serialization_roundtrip() {\n        let arena = Bump::new();\n        let id = 13131u128;\n\n        let props = vec![\n            (\"empty_val\", Value::Empty),\n            (\"normal_val\", Value::I32(42)),\n        ];\n\n        let new_node = create_arena_node_with_props(&arena, id, \"EmptyValue\", props);\n        let new_bytes = bincode::serialize(&new_node).unwrap();\n\n        // Deserialize and verify Empty value is preserved\n        let arena2 = Bump::new();\n        let deserialized = Node::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 2);\n        assert_eq!(props.get(\"empty_val\"), Some(&Value::Empty));\n        assert_eq!(props.get(\"normal_val\"), Some(&Value::I32(42)));\n    }\n}\n\n#[cfg(test)]\nmod edge_serialization_tests {\n    use crate::protocol::value::Value;\n    use crate::utils::items::Edge;\n    use crate::utils::properties::ImmutablePropertiesMap;\n    use bumpalo::Bump;\n    use serde::{Deserialize, Serialize};\n    use std::collections::HashMap;\n\n    /// Old Edge implementation for comparison testing\n    #[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "struct_OldEdge_745": {
      "name": "OldEdge",
      "type": "struct",
      "start_line": 745,
      "end_line": 797,
      "content_hash": "a884c3c7b082805b1299625c3c68493a786fb196",
      "content": "    struct OldEdge {\n        #[serde(skip)]\n        pub id: u128,\n        pub label: String,\n        #[serde(default)]\n        pub version: u8,\n        pub from_node: u128,\n        pub to_node: u128,\n        #[serde(default)]\n        pub properties: Option<HashMap<String, Value>>,\n    }\n\n    /// Helper to create a test arena edge with properties\n    fn create_arena_edge_with_props<'arena>(\n        arena: &'arena Bump,\n        id: u128,\n        label: &str,\n        from_node: u128,\n        to_node: u128,\n        props: Vec<(&str, Value)>,\n    ) -> Edge<'arena> {\n        let label_ref = arena.alloc_str(label);\n\n        if props.is_empty() {\n            Edge {\n                id,\n                label: label_ref,\n                version: 0,\n                from_node,\n                to_node,\n                properties: None,\n            }\n        } else {\n            let len = props.len();\n            let props_iter = props.into_iter().map(|(k, v)| {\n                let key: &'arena str = arena.alloc_str(k);\n                (key, v)\n            });\n\n            let props_map = ImmutablePropertiesMap::new(len, props_iter, arena);\n\n            Edge {\n                id,\n                label: label_ref,\n                version: 0,\n                from_node,\n                to_node,\n                properties: Some(props_map),\n            }\n        }\n    }\n\n    /// Helper to create old edge with properties",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_create_old_edge_with_props_798": {
      "name": "create_old_edge_with_props",
      "type": "function",
      "start_line": 798,
      "end_line": 825,
      "content_hash": "c1af660abc12214eb415b74517fbad69e6698a8d",
      "content": "    fn create_old_edge_with_props(\n        id: u128,\n        label: &str,\n        from_node: u128,\n        to_node: u128,\n        props: Vec<(&str, Value)>,\n    ) -> OldEdge {\n        let properties = if props.is_empty() {\n            None\n        } else {\n            let mut map = HashMap::new();\n            for (k, v) in props {\n                map.insert(k.to_string(), v);\n            }\n            Some(map)\n        };\n\n        OldEdge {\n            id,\n            label: label.to_string(),\n            version: 0,\n            from_node,\n            to_node,\n            properties,\n        }\n    }\n\n    // Helper function to compare Values recursively, ignoring HashMap order",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_values_equal_826": {
      "name": "values_equal",
      "type": "function",
      "start_line": 826,
      "end_line": 854,
      "content_hash": "33ea11d1c37b89c80b2971ad1400380743bd2f5f",
      "content": "    fn values_equal(a: &Value, b: &Value) -> bool {\n        match (a, b) {\n            (Value::Empty, Value::Empty) => true,\n            (Value::Boolean(a), Value::Boolean(b)) => a == b,\n            (Value::I8(a), Value::I8(b)) => a == b,\n            (Value::I16(a), Value::I16(b)) => a == b,\n            (Value::I32(a), Value::I32(b)) => a == b,\n            (Value::I64(a), Value::I64(b)) => a == b,\n            (Value::U8(a), Value::U8(b)) => a == b,\n            (Value::U16(a), Value::U16(b)) => a == b,\n            (Value::U32(a), Value::U32(b)) => a == b,\n            (Value::U64(a), Value::U64(b)) => a == b,\n            (Value::U128(a), Value::U128(b)) => a == b,\n            (Value::F32(a), Value::F32(b)) => (a.is_nan() && b.is_nan()) || a == b,\n            (Value::F64(a), Value::F64(b)) => (a.is_nan() && b.is_nan()) || a == b,\n            (Value::String(a), Value::String(b)) => a == b,\n            (Value::Array(a), Value::Array(b)) => {\n                a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| values_equal(x, y))\n            }\n            (Value::Object(a), Value::Object(b)) => {\n                a.len() == b.len() && a.iter().all(|(k, v)| b.get(k).map_or(false, |bv| values_equal(v, bv)))\n            }\n            (Value::Date(a), Value::Date(b)) => a == b,\n            (Value::Id(a), Value::Id(b)) => a == b,\n            _ => false,\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_serialization_empty_properties_855": {
      "name": "test_edge_serialization_empty_properties",
      "type": "function",
      "start_line": 855,
      "end_line": 900,
      "content_hash": "60fe23a7c188e3f732647290cc663da8645b76a8",
      "content": "    fn test_edge_serialization_empty_properties() {\n        let arena = Bump::new();\n        let id = 1000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let old_edge = OldEdge {\n            id,\n            label: \"KNOWS\".to_string(),\n            version: 0,\n            from_node,\n            to_node,\n            properties: None,\n        };\n\n        let new_edge = Edge {\n            id,\n            label: arena.alloc_str(\"KNOWS\"),\n            version: 0,\n            from_node,\n            to_node,\n            properties: None,\n        };\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n        let new_bytes = bincode::serialize(&new_edge).unwrap();\n\n        // Bytes should be IDENTICAL\n        assert_eq!(\n            old_bytes, new_bytes,\n            \"Serialized bytes differ for empty properties!\"\n        );\n\n        // Test that new format can deserialize its own output\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &new_bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"KNOWS\");\n        assert_eq!(deserialized.version, 0);\n        assert_eq!(deserialized.from_node, from_node);\n        assert_eq!(deserialized.to_node, to_node);\n        assert!(deserialized.properties.is_none());\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_serialization_with_properties_901": {
      "name": "test_edge_serialization_with_properties",
      "type": "function",
      "start_line": 901,
      "end_line": 946,
      "content_hash": "e188742230e6bae64fd957beb476b18e23f0425b",
      "content": "    fn test_edge_serialization_with_properties() {\n        let arena = Bump::new();\n        let id = 2000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let props = vec![\n            (\"weight\", Value::F64(0.8)),\n            (\"type\", Value::String(\"friend\".to_string())),\n            (\"since\", Value::I32(2020)),\n        ];\n\n        let old_edge = create_old_edge_with_props(id, \"KNOWS\", from_node, to_node, props.clone());\n        let new_edge = create_arena_edge_with_props(&arena, id, \"KNOWS\", from_node, to_node, props);\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n        let new_bytes = bincode::serialize(&new_edge).unwrap();\n\n        // Deserialize both and compare semantically\n        let arena2 = Bump::new();\n        let arena3 = Bump::new();\n\n        let deserialized_old = Edge::from_bincode_bytes(id, &old_bytes, &arena2).unwrap();\n        let deserialized_new = Edge::from_bincode_bytes(id, &new_bytes, &arena3).unwrap();\n\n        assert_eq!(deserialized_old.id, id);\n        assert_eq!(deserialized_new.id, id);\n        assert_eq!(deserialized_old.label, \"KNOWS\");\n        assert_eq!(deserialized_new.label, \"KNOWS\");\n        assert_eq!(deserialized_old.from_node, from_node);\n        assert_eq!(deserialized_new.from_node, from_node);\n        assert_eq!(deserialized_old.to_node, to_node);\n        assert_eq!(deserialized_new.to_node, to_node);\n\n        let old_props = deserialized_old.properties.unwrap();\n        let new_props = deserialized_new.properties.unwrap();\n        assert_eq!(old_props.len(), new_props.len());\n\n        // Check semantic equality (order may differ)\n        for (key, old_value) in old_props.iter() {\n            let new_value = new_props.get(key).expect(&format!(\"Missing key: {}\", key));\n            assert!(values_equal(old_value, new_value), \"Value mismatch for key {}\", key);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_roundtrip_serialization_947": {
      "name": "test_edge_roundtrip_serialization",
      "type": "function",
      "start_line": 947,
      "end_line": 979,
      "content_hash": "bcab79815b7448b8f1af0be3f19270812a3d5d04",
      "content": "    fn test_edge_roundtrip_serialization() {\n        let arena = Bump::new();\n        let id = 3000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let props = vec![\n            (\"confidence\", Value::F64(0.95)),\n            (\"verified\", Value::Boolean(true)),\n        ];\n\n        let original = create_arena_edge_with_props(&arena, id, \"RELATED_TO\", from_node, to_node, props);\n        let bytes = bincode::serialize(&original).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.id, original.id);\n        assert_eq!(deserialized.label, original.label);\n        assert_eq!(deserialized.version, original.version);\n        assert_eq!(deserialized.from_node, original.from_node);\n        assert_eq!(deserialized.to_node, original.to_node);\n\n        let original_props = original.properties.unwrap();\n        let deserialized_props = deserialized.properties.unwrap();\n\n        assert_eq!(original_props.len(), deserialized_props.len());\n        for (key, value) in original_props.iter() {\n            assert_eq!(deserialized_props.get(key), Some(value));\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_deserialization_from_old_format_980": {
      "name": "test_edge_deserialization_from_old_format",
      "type": "function",
      "start_line": 980,
      "end_line": 1009,
      "content_hash": "9a6dbce568fe137acb182c1956afb1824c4c677e",
      "content": "    fn test_edge_deserialization_from_old_format() {\n        let id = 4000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let props = vec![\n            (\"strength\", Value::I32(5)),\n            (\"label_text\", Value::String(\"connection\".to_string())),\n        ];\n\n        let old_edge = create_old_edge_with_props(id, \"CONNECTS\", from_node, to_node, props);\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n\n        // New format should deserialize old format\n        let arena = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &old_bytes, &arena).unwrap();\n\n        assert_eq!(deserialized.id, id);\n        assert_eq!(deserialized.label, \"CONNECTS\");\n        assert_eq!(deserialized.version, 0);\n        assert_eq!(deserialized.from_node, from_node);\n        assert_eq!(deserialized.to_node, to_node);\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 2);\n        assert_eq!(props.get(\"strength\"), Some(&Value::I32(5)));\n        assert_eq!(props.get(\"label_text\"), Some(&Value::String(\"connection\".to_string())));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_nested_values_1010": {
      "name": "test_edge_with_nested_values",
      "type": "function",
      "start_line": 1010,
      "end_line": 1053,
      "content_hash": "9ec55579004ba191e70e61f4084acc7456b18b7e",
      "content": "    fn test_edge_with_nested_values() {\n        let arena = Bump::new();\n        let id = 5000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let props = vec![\n            (\"metadata\", {\n                let mut map = HashMap::new();\n                map.insert(\"created_by\".to_string(), Value::String(\"system\".to_string()));\n                map.insert(\"timestamp\".to_string(), Value::I64(1234567890));\n                Value::Object(map)\n            }),\n            (\"tags\", Value::Array(vec![\n                Value::String(\"important\".to_string()),\n                Value::String(\"verified\".to_string()),\n            ])),\n        ];\n\n        let old_edge = create_old_edge_with_props(id, \"HAS_TAG\", from_node, to_node, props.clone());\n        let new_edge = create_arena_edge_with_props(&arena, id, \"HAS_TAG\", from_node, to_node, props);\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n        let new_bytes = bincode::serialize(&new_edge).unwrap();\n\n        // Deserialize and compare semantically\n        let arena2 = Bump::new();\n        let arena3 = Bump::new();\n\n        let deserialized_old = Edge::from_bincode_bytes(id, &old_bytes, &arena2).unwrap();\n        let deserialized_new = Edge::from_bincode_bytes(id, &new_bytes, &arena3).unwrap();\n\n        let old_props = deserialized_old.properties.unwrap();\n        let new_props = deserialized_new.properties.unwrap();\n        assert_eq!(old_props.len(), new_props.len());\n\n        // Compare nested values\n        for (key, old_value) in old_props.iter() {\n            let new_value = new_props.get(key).expect(&format!(\"Missing key: {}\", key));\n            assert!(values_equal(old_value, new_value), \"Value mismatch for key {}: {:?} != {:?}\", key, old_value, new_value);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_many_properties_1054": {
      "name": "test_edge_with_many_properties",
      "type": "function",
      "start_line": 1054,
      "end_line": 1086,
      "content_hash": "c17b4e035377581cdb01e8e9eb65834597e0ca73",
      "content": "    fn test_edge_with_many_properties() {\n        let arena = Bump::new();\n        let id = 6000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        // Create edge with 20 properties\n        let props: Vec<(&str, Value)> = (0..20)\n            .map(|i| {\n                (\n                    Box::leak(format!(\"prop_{}\", i).into_boxed_str()) as &str,\n                    Value::I32(i),\n                )\n            })\n            .collect();\n\n        let new_edge = create_arena_edge_with_props(&arena, id, \"BULK\", from_node, to_node, props);\n        let bytes = bincode::serialize(&new_edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.len(), 20);\n\n        // Verify all properties are present\n        for i in 0..20 {\n            let key = format!(\"prop_{}\", i);\n            assert_eq!(props.get(&key), Some(&Value::I32(i)), \"Property {} mismatch\", key);\n        }\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_byte_level_comparison_empty_1087": {
      "name": "test_edge_byte_level_comparison_empty",
      "type": "function",
      "start_line": 1087,
      "end_line": 1134,
      "content_hash": "10eb6aa3b2e2119dbd9c7377877600c7c7dc2740",
      "content": "    fn test_edge_byte_level_comparison_empty() {\n        let arena = Bump::new();\n        let id = 7000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let old_edge = OldEdge {\n            id,\n            label: \"LINKS\".to_string(),\n            version: 0,\n            from_node,\n            to_node,\n            properties: None,\n        };\n\n        let new_edge = Edge {\n            id,\n            label: arena.alloc_str(\"LINKS\"),\n            version: 0,\n            from_node,\n            to_node,\n            properties: None,\n        };\n\n        let old_bytes = bincode::serialize(&old_edge).unwrap();\n        let new_bytes = bincode::serialize(&new_edge).unwrap();\n\n        println!(\"\\n=== EDGE EMPTY PROPERTIES COMPARISON ===\");\n        println!(\"Old bytes ({} total): {:02x?}\", old_bytes.len(), old_bytes);\n        println!(\"New bytes ({} total): {:02x?}\", new_bytes.len(), new_bytes);\n\n        // Detailed analysis\n        println!(\"\\nByte-by-byte comparison:\");\n        for (i, (old_byte, new_byte)) in old_bytes.iter().zip(new_bytes.iter()).enumerate() {\n            if old_byte != new_byte {\n                println!(\"  Index {}: old={:02x} ({}), new={:02x} ({})\",\n                    i, old_byte, old_byte, new_byte, new_byte);\n            }\n        }\n\n        // Bytes should be IDENTICAL\n        assert_eq!(\n            old_bytes, new_bytes,\n            \"Serialized bytes differ for empty properties!\"\n        );\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_utf8_labels_and_properties_1135": {
      "name": "test_edge_with_utf8_labels_and_properties",
      "type": "function",
      "start_line": 1135,
      "end_line": 1158,
      "content_hash": "23e196b42607cff71317602ca8aec5be2fa7e3e3",
      "content": "    fn test_edge_with_utf8_labels_and_properties() {\n        let arena = Bump::new();\n        let id = 8000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let props = vec![\n            (\"\u540d\u524d\", Value::String(\"\u592a\u90ce\".to_string())),\n            (\"emoji\", Value::String(\"\ud83d\udd17\".to_string())),\n        ];\n\n        let new_edge = create_arena_edge_with_props(&arena, id, \"\u7e4b\u304c\u308a\", from_node, to_node, props);\n        let bytes = bincode::serialize(&new_edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.label, \"\u7e4b\u304c\u308a\");\n        let props = deserialized.properties.unwrap();\n        assert_eq!(props.get(\"\u540d\u524d\"), Some(&Value::String(\"\u592a\u90ce\".to_string())));\n        assert_eq!(props.get(\"emoji\"), Some(&Value::String(\"\ud83d\udd17\".to_string())));\n    }\n\n    #[test]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_test_edge_with_version_1159": {
      "name": "test_edge_with_version",
      "type": "function",
      "start_line": 1159,
      "end_line": 1181,
      "content_hash": "a8c4d69119ba7320d3963e3593e3c1d314879247",
      "content": "    fn test_edge_with_version() {\n        let arena = Bump::new();\n        let id = 9000u128;\n        let from_node = 100u128;\n        let to_node = 200u128;\n\n        let edge = Edge {\n            id,\n            label: arena.alloc_str(\"VERSIONED\"),\n            version: 42,\n            from_node,\n            to_node,\n            properties: None,\n        };\n\n        let bytes = bincode::serialize(&edge).unwrap();\n\n        let arena2 = Bump::new();\n        let deserialized = Edge::from_bincode_bytes(id, &bytes, &arena2).unwrap();\n\n        assert_eq!(deserialized.version, 42);\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}