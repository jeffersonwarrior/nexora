{
  "file_path": "/work/internal/agent/prompt/cache_test.go",
  "file_hash": "6b7f1619ea504f8c621185d3262cdf174796a3a9",
  "updated_at": "2025-12-26T17:34:20.678817",
  "symbols": {
    "function_TestEnvironmentCache_9": {
      "name": "TestEnvironmentCache",
      "type": "function",
      "start_line": 9,
      "end_line": 144,
      "content_hash": "f11657f9164f628fc07e09f339faf75fa72e97d1",
      "content": "func TestEnvironmentCache(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"cache initialization\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(1 * time.Minute)\n\t\tif cache == nil {\n\t\t\tt.Fatal(\"NewEnvironmentCache returned nil\")\n\t\t}\n\t\tif cache.ttl != 1*time.Minute {\n\t\t\tt.Errorf(\"Expected TTL of 1 minute, got %v\", cache.ttl)\n\t\t}\n\t})\n\n\tt.Run(\"cache refresh and retrieval\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(1 * time.Minute)\n\n\t\t// First call should populate cache\n\t\tdata1, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Verify some data was populated\n\t\tif data1.Architecture == \"\" {\n\t\t\tt.Error(\"Expected Architecture to be populated\")\n\t\t}\n\n\t\t// Second call should use cache (same data)\n\t\tdata2, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Should be same data (from cache)\n\t\tif data1.Architecture != data2.Architecture {\n\t\t\tt.Error(\"Expected cached data to match\")\n\t\t}\n\t})\n\n\tt.Run(\"cache expiration\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(100 * time.Millisecond)\n\n\t\t// First call\n\t\t_, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Wait for cache to expire\n\t\ttime.Sleep(150 * time.Millisecond)\n\n\t\t// Should refresh cache\n\t\tdata2, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Data might be same or different, but should have valid values\n\t\tif data2.Architecture == \"\" {\n\t\t\tt.Error(\"Expected Architecture to be populated after refresh\")\n\t\t}\n\t})\n\n\tt.Run(\"cache invalidation\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(1 * time.Minute)\n\n\t\t// Populate cache\n\t\t_, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Invalidate\n\t\tcache.Invalidate()\n\n\t\t// Next call should refresh (we can't easily verify this without\n\t\t// inspecting internals, but at least test it doesn't error)\n\t\t_, err = cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get after invalidation failed: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"full env vs normal mode\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(1 * time.Minute)\n\n\t\t// Normal mode (fullEnv=false)\n\t\tdata1, err := cache.Get(ctx, \"/tmp\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get failed: %v\", err)\n\t\t}\n\n\t\t// Should use defaults\n\t\tif data1.NetworkStatus != \"online\" {\n\t\t\tt.Errorf(\"Expected default network status 'online', got '%s'\", data1.NetworkStatus)\n\t\t}\n\t\tif data1.ActiveServices != \"\" {\n\t\t\tt.Errorf(\"Expected empty active services in normal mode, got '%s'\", data1.ActiveServices)\n\t\t}\n\n\t\t// Invalidate to force refresh with fullEnv\n\t\tcache.Invalidate()\n\n\t\t// Full env mode (fullEnv=true) - may take longer but should work\n\t\tdata2, err := cache.Get(ctx, \"/tmp\", true)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Get with fullEnv failed: %v\", err)\n\t\t}\n\n\t\t// Network status should still be populated (may be \"online\" or actual check result)\n\t\tif data2.NetworkStatus == \"\" {\n\t\t\tt.Error(\"Expected NetworkStatus to be populated in full env mode\")\n\t\t}\n\t})\n\n\tt.Run(\"parallel access\", func(t *testing.T) {\n\t\tcache := NewEnvironmentCache(1 * time.Minute)\n\n\t\t// Simulate multiple concurrent accesses\n\t\tdone := make(chan bool, 10)\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tgo func() {\n\t\t\t\t_, err := cache.Get(ctx, \"/tmp\", false)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Concurrent Get failed: %v\", err)\n\t\t\t\t}\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t}\n\n\t\t// Wait for all goroutines\n\t\tfor i := 0; i < 10; i++ {\n\t\t\t<-done\n\t\t}\n\t})\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}