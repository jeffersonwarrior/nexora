{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/SDKAgent.ts",
  "file_hash": "336b06ec6d0fe80476001a1ad9dd5928871d176a",
  "updated_at": "2025-12-26T17:34:23.236370",
  "symbols": {
    "class_SDKAgent_28": {
      "name": "SDKAgent",
      "type": "class",
      "start_line": 28,
      "end_line": 483,
      "content_hash": "23f9cc4ead73929ec253c8233e8861b39bfdb464",
      "content": "export class SDKAgent {\n  private dbManager: DatabaseManager;\n  private sessionManager: SessionManager;\n\n  constructor(dbManager: DatabaseManager, sessionManager: SessionManager) {\n    this.dbManager = dbManager;\n    this.sessionManager = sessionManager;\n  }\n\n  /**\n   * Start SDK agent for a session (event-driven, no polling)\n   * @param worker WorkerService reference for spinner control (optional)\n   */\n  async startSession(session: ActiveSession, worker?: any): Promise<void> {\n    try {\n      // Find Claude executable\n      const claudePath = this.findClaudeExecutable();\n\n      // Get model ID and disallowed tools\n      const modelId = this.getModelId();\n      // Memory agent is OBSERVER ONLY - no tools allowed\n      const disallowedTools = [\n        'Bash',           // Prevent infinite loops\n        'Read',           // No file reading\n        'Write',          // No file writing\n        'Edit',           // No file editing\n        'Grep',           // No code searching\n        'Glob',           // No file pattern matching\n        'WebFetch',       // No web fetching\n        'WebSearch',      // No web searching\n        'Task',           // No spawning sub-agents\n        'NotebookEdit',   // No notebook editing\n        'AskUserQuestion',// No asking questions\n        'TodoWrite'       // No todo management\n      ];\n\n      // Create message generator (event-driven)\n      const messageGenerator = this.createMessageGenerator(session);\n\n      // Run Agent SDK query loop\n      const queryResult = query({\n        prompt: messageGenerator,\n        options: {\n          model: modelId,\n          disallowedTools,\n          abortController: session.abortController,\n          pathToClaudeCodeExecutable: claudePath\n        }\n      });\n\n      // Process SDK messages\n      for await (const message of queryResult) {\n        // Handle assistant messages\n        if (message.type === 'assistant') {\n          const content = message.message.content;\n          const textContent = Array.isArray(content)\n            ? content.filter((c: any) => c.type === 'text').map((c: any) => c.text).join('\\n')\n            : typeof content === 'string' ? content : '';\n\n          const responseSize = textContent.length;\n\n          // Capture token state BEFORE updating (for delta calculation)\n          const tokensBeforeResponse = session.cumulativeInputTokens + session.cumulativeOutputTokens;\n\n          // Extract and track token usage\n          const usage = message.message.usage;\n          if (usage) {\n            session.cumulativeInputTokens += usage.input_tokens || 0;\n            session.cumulativeOutputTokens += usage.output_tokens || 0;\n\n            // Cache creation counts as discovery, cache read doesn't\n            if (usage.cache_creation_input_tokens) {\n              session.cumulativeInputTokens += usage.cache_creation_input_tokens;\n            }\n\n            logger.debug('SDK', 'Token usage captured', {\n              sessionId: session.sessionDbId,\n              inputTokens: usage.input_tokens,\n              outputTokens: usage.output_tokens,\n              cacheCreation: usage.cache_creation_input_tokens || 0,\n              cacheRead: usage.cache_read_input_tokens || 0,\n              cumulativeInput: session.cumulativeInputTokens,\n              cumulativeOutput: session.cumulativeOutputTokens\n            });\n          }\n\n          // Calculate discovery tokens (delta for this response only)\n          const discoveryTokens = (session.cumulativeInputTokens + session.cumulativeOutputTokens) - tokensBeforeResponse;\n\n          // Process response (empty or not) and mark messages as processed\n          if (responseSize > 0) {\n            const truncatedResponse = responseSize > 100\n              ? textContent.substring(0, 100) + '...'\n              : textContent;\n            logger.dataOut('SDK', `Response received (${responseSize} chars)`, {\n              sessionId: session.sessionDbId,\n              promptNumber: session.lastPromptNumber\n            }, truncatedResponse);\n\n            // Parse and process response with discovery token delta\n            await this.processSDKResponse(session, textContent, worker, discoveryTokens);\n          } else {\n            // Empty response - still need to mark pending messages as processed\n            await this.markMessagesProcessed(session, worker);\n          }\n        }\n\n        // Log result messages\n        if (message.type === 'result' && message.subtype === 'success') {\n          // Usage telemetry is captured at SDK level\n        }\n      }\n\n      // Mark session complete\n      const sessionDuration = Date.now() - session.startTime;\n      logger.success('SDK', 'Agent completed', {\n        sessionId: session.sessionDbId,\n        duration: `${(sessionDuration / 1000).toFixed(1)}s`\n      });\n\n      this.dbManager.getSessionStore().markSessionCompleted(session.sessionDbId);\n\n    } catch (error: any) {\n      if (error.name === 'AbortError') {\n        logger.warn('SDK', 'Agent aborted', { sessionId: session.sessionDbId });\n      } else {\n        logger.failure('SDK', 'Agent error', { sessionDbId: session.sessionDbId }, error);\n      }\n      throw error;\n    } finally {\n      // Cleanup\n      this.sessionManager.deleteSession(session.sessionDbId).catch(() => {});\n    }\n  }\n\n  /**\n   * Create event-driven message generator (yields messages from SessionManager)\n   *\n   * CRITICAL: CONTINUATION PROMPT LOGIC\n   * ====================================\n   * This is where NEW hook's dual-purpose nature comes together:\n   *\n   * - Prompt #1 (lastPromptNumber === 1): buildInitPrompt\n   *   - Full initialization prompt with instructions\n   *   - Sets up the SDK agent's context\n   *\n   * - Prompt #2+ (lastPromptNumber > 1): buildContinuationPrompt\n   *   - Continuation prompt for same session\n   *   - Includes session context and prompt number\n   *\n   * BOTH prompts receive session.claudeSessionId:\n   * - This comes from the hook's session_id (see new-hook.ts)\n   * - Same session_id used by SAVE hook to store observations\n   * - This is how everything stays connected in one unified session\n   *\n   * NO SESSION EXISTENCE CHECKS NEEDED:\n   * - SessionManager.initializeSession already fetched this from database\n   * - Database row was created by new-hook's createSDKSession call\n   * - We just use the session_id we're given - simple and reliable\n   */\n  private async *createMessageGenerator(session: ActiveSession): AsyncIterableIterator<SDKUserMessage> {\n    // Load active mode\n    const mode = ModeManager.getInstance().getActiveMode();\n\n    // Yield initial user prompt with context (or continuation if prompt #2+)\n    // CRITICAL: Both paths use session.claudeSessionId from the hook\n    yield {\n      type: 'user',\n      message: {\n        role: 'user',\n        content: session.lastPromptNumber === 1\n          ? buildInitPrompt(session.project, session.claudeSessionId, session.userPrompt, mode)\n          : buildContinuationPrompt(session.userPrompt, session.lastPromptNumber, session.claudeSessionId, mode)\n      },\n      session_id: session.claudeSessionId,\n      parent_tool_use_id: null,\n      isSynthetic: true\n    };\n\n    // Consume pending messages from SessionManager (event-driven, no polling)\n    for await (const message of this.sessionManager.getMessageIterator(session.sessionDbId)) {\n      if (message.type === 'observation') {\n        // Update last prompt number\n        if (message.prompt_number !== undefined) {\n          session.lastPromptNumber = message.prompt_number;\n        }\n\n        yield {\n          type: 'user',\n          message: {\n            role: 'user',\n            content: buildObservationPrompt({\n              id: 0, // Not used in prompt\n              tool_name: message.tool_name!,\n              tool_input: JSON.stringify(message.tool_input),\n              tool_output: JSON.stringify(message.tool_response),\n              created_at_epoch: Date.now(),\n              cwd: message.cwd\n            })\n          },\n          session_id: session.claudeSessionId,\n          parent_tool_use_id: null,\n          isSynthetic: true\n        };\n      } else if (message.type === 'summarize') {\n        yield {\n          type: 'user',\n          message: {\n            role: 'user',\n            content: buildSummaryPrompt({\n              id: session.sessionDbId,\n              sdk_session_id: session.sdkSessionId,\n              project: session.project,\n              user_prompt: session.userPrompt,\n              last_user_message: message.last_user_message || '',\n              last_assistant_message: message.last_assistant_message || ''\n            }, mode)\n          },\n          session_id: session.claudeSessionId,\n          parent_tool_use_id: null,\n          isSynthetic: true\n        };\n      }\n    }\n  }\n\n  /**\n   * Process SDK response text (parse XML, save to database, sync to Chroma)\n   * @param discoveryTokens - Token cost for discovering this response (delta, not cumulative)\n   */\n  private async processSDKResponse(session: ActiveSession, text: string, worker: any | undefined, discoveryTokens: number): Promise<void> {\n    // Parse observations\n    const observations = parseObservations(text, session.claudeSessionId);\n\n    // Store observations\n    for (const obs of observations) {\n      const { id: obsId, createdAtEpoch } = this.dbManager.getSessionStore().storeObservation(\n        session.claudeSessionId,\n        session.project,\n        obs,\n        session.lastPromptNumber,\n        discoveryTokens\n      );\n\n      // Log observation details\n      logger.info('SDK', 'Observation saved', {\n        sessionId: session.sessionDbId,\n        obsId,\n        type: obs.type,\n        title: obs.title || '(untitled)',\n        filesRead: obs.files_read?.length ?? 0,\n        filesModified: obs.files_modified?.length ?? 0,\n        concepts: obs.concepts?.length ?? 0\n      });\n\n      // Sync to Chroma\n      const chromaStart = Date.now();\n      const obsType = obs.type;\n      const obsTitle = obs.title || '(untitled)';\n      this.dbManager.getChromaSync().syncObservation(\n        obsId,\n        session.claudeSessionId,\n        session.project,\n        obs,\n        session.lastPromptNumber,\n        createdAtEpoch,\n        discoveryTokens\n      ).then(() => {\n        const chromaDuration = Date.now() - chromaStart;\n        logger.debug('CHROMA', 'Observation synced', {\n          obsId,\n          duration: `${chromaDuration}ms`,\n          type: obsType,\n          title: obsTitle\n        });\n      }).catch((error) => {\n        logger.warn('CHROMA', 'Observation sync failed, continuing without vector search', {\n          obsId,\n          type: obsType,\n          title: obsTitle\n        }, error);\n      });\n\n      // Broadcast to SSE clients (for web UI)\n      if (worker && worker.sseBroadcaster) {\n        worker.sseBroadcaster.broadcast({\n          type: 'new_observation',\n          observation: {\n            id: obsId,\n            sdk_session_id: session.sdkSessionId,\n            session_id: session.claudeSessionId,\n            type: obs.type,\n            title: obs.title,\n            subtitle: obs.subtitle,\n            text: obs.text || null,\n            narrative: obs.narrative || null,\n            facts: JSON.stringify(obs.facts || []),\n            concepts: JSON.stringify(obs.concepts || []),\n            files_read: JSON.stringify(obs.files || []),\n            files_modified: JSON.stringify([]),\n            project: session.project,\n            prompt_number: session.lastPromptNumber,\n            created_at_epoch: createdAtEpoch\n          }\n        });\n      }\n    }\n\n    // Parse summary\n    const summary = parseSummary(text, session.sessionDbId);\n\n    // Store summary\n    if (summary) {\n      const { id: summaryId, createdAtEpoch } = this.dbManager.getSessionStore().storeSummary(\n        session.claudeSessionId,\n        session.project,\n        summary,\n        session.lastPromptNumber,\n        discoveryTokens\n      );\n\n      // Log summary details\n      logger.info('SDK', 'Summary saved', {\n        sessionId: session.sessionDbId,\n        summaryId,\n        request: summary.request || '(no request)',\n        hasCompleted: !!summary.completed,\n        hasNextSteps: !!summary.next_steps\n      });\n\n      // Sync to Chroma\n      const chromaStart = Date.now();\n      const summaryRequest = summary.request || '(no request)';\n      this.dbManager.getChromaSync().syncSummary(\n        summaryId,\n        session.claudeSessionId,\n        session.project,\n        summary,\n        session.lastPromptNumber,\n        createdAtEpoch,\n        discoveryTokens\n      ).then(() => {\n        const chromaDuration = Date.now() - chromaStart;\n        logger.debug('CHROMA', 'Summary synced', {\n          summaryId,\n          duration: `${chromaDuration}ms`,\n          request: summaryRequest\n        });\n      }).catch((error) => {\n        logger.warn('CHROMA', 'Summary sync failed, continuing without vector search', {\n          summaryId,\n          request: summaryRequest\n        }, error);\n      });\n\n      // Broadcast to SSE clients (for web UI)\n      if (worker && worker.sseBroadcaster) {\n        worker.sseBroadcaster.broadcast({\n          type: 'new_summary',\n          summary: {\n            id: summaryId,\n            session_id: session.claudeSessionId,\n            request: summary.request,\n            investigated: summary.investigated,\n            learned: summary.learned,\n            completed: summary.completed,\n            next_steps: summary.next_steps,\n            notes: summary.notes,\n            project: session.project,\n            prompt_number: session.lastPromptNumber,\n            created_at_epoch: createdAtEpoch\n          }\n        });\n      }\n    }\n\n    // Mark messages as processed after successful observation/summary storage\n    await this.markMessagesProcessed(session, worker);\n  }\n\n  /**\n   * Mark all pending messages as successfully processed\n   * CRITICAL: Prevents message loss and duplicate processing\n   */\n  private async markMessagesProcessed(session: ActiveSession, worker: any | undefined): Promise<void> {\n    const pendingMessageStore = this.sessionManager.getPendingMessageStore();\n    if (session.pendingProcessingIds.size > 0) {\n      for (const messageId of session.pendingProcessingIds) {\n        pendingMessageStore.markProcessed(messageId);\n      }\n      logger.debug('SDK', 'Messages marked as processed', {\n        sessionId: session.sessionDbId,\n        messageIds: Array.from(session.pendingProcessingIds),\n        count: session.pendingProcessingIds.size\n      });\n      session.pendingProcessingIds.clear();\n\n      // Clean up old processed messages (keep last 100 for UI display)\n      const deletedCount = pendingMessageStore.cleanupProcessed(100);\n      if (deletedCount > 0) {\n        logger.debug('SDK', 'Cleaned up old processed messages', {\n          deletedCount\n        });\n      }\n    }\n\n    // Broadcast activity status after processing (queue may have changed)\n    if (worker && typeof worker.broadcastProcessingStatus === 'function') {\n      worker.broadcastProcessingStatus();\n    }\n  }\n\n  // ============================================================================\n  // Configuration Helpers\n  // ============================================================================\n\n  /**\n   * Find Claude executable (inline, called once per session)\n   */\n  private findClaudeExecutable(): string {\n    const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n    \n    // 1. Check configured path\n    if (settings.CLAUDE_CODE_PATH) {\n      // Lazy load fs to keep startup fast\n      const { existsSync } = require('fs');\n      if (!existsSync(settings.CLAUDE_CODE_PATH)) {\n        throw new Error(`CLAUDE_CODE_PATH is set to \"${settings.CLAUDE_CODE_PATH}\" but the file does not exist.`);\n      }\n      return settings.CLAUDE_CODE_PATH;\n    }\n\n    // 2. Try auto-detection\n    try {\n      const claudePath = execSync(\n        process.platform === 'win32' ? 'where claude' : 'which claude', \n        { encoding: 'utf8', windowsHide: true, stdio: ['ignore', 'pipe', 'ignore'] }\n      ).trim().split('\\n')[0].trim();\n      \n      if (claudePath) return claudePath;\n    } catch (error) {\n      logger.debug('SDK', 'Claude executable auto-detection failed', error);\n    }\n\n    throw new Error('Claude executable not found. Please either:\\n1. Add \"claude\" to your system PATH, or\\n2. Set CLAUDE_CODE_PATH in ~/.claude-mem/settings.json');\n  }\n\n  /**\n   * Get model ID from settings or environment\n   */\n  private getModelId(): string {\n    const settingsPath = path.join(homedir(), '.claude-mem', 'settings.json');\n    const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n    return settings.CLAUDE_MEM_MODEL;\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_32": {
      "name": "constructor",
      "type": "method",
      "start_line": 32,
      "end_line": 35,
      "content_hash": "7d021e4d589994fadcce507eeb02de87806c610a",
      "content": "  constructor(dbManager: DatabaseManager, sessionManager: SessionManager) {\n    this.dbManager = dbManager;\n    this.sessionManager = sessionManager;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_startSession_41": {
      "name": "startSession",
      "type": "method",
      "start_line": 41,
      "end_line": 161,
      "content_hash": "f181fbf2d0e0a65aea278d936c6ef1b2a961d573",
      "content": "  async startSession(session: ActiveSession, worker?: any): Promise<void> {\n    try {\n      // Find Claude executable\n      const claudePath = this.findClaudeExecutable();\n\n      // Get model ID and disallowed tools\n      const modelId = this.getModelId();\n      // Memory agent is OBSERVER ONLY - no tools allowed\n      const disallowedTools = [\n        'Bash',           // Prevent infinite loops\n        'Read',           // No file reading\n        'Write',          // No file writing\n        'Edit',           // No file editing\n        'Grep',           // No code searching\n        'Glob',           // No file pattern matching\n        'WebFetch',       // No web fetching\n        'WebSearch',      // No web searching\n        'Task',           // No spawning sub-agents\n        'NotebookEdit',   // No notebook editing\n        'AskUserQuestion',// No asking questions\n        'TodoWrite'       // No todo management\n      ];\n\n      // Create message generator (event-driven)\n      const messageGenerator = this.createMessageGenerator(session);\n\n      // Run Agent SDK query loop\n      const queryResult = query({\n        prompt: messageGenerator,\n        options: {\n          model: modelId,\n          disallowedTools,\n          abortController: session.abortController,\n          pathToClaudeCodeExecutable: claudePath\n        }\n      });\n\n      // Process SDK messages\n      for await (const message of queryResult) {\n        // Handle assistant messages\n        if (message.type === 'assistant') {\n          const content = message.message.content;\n          const textContent = Array.isArray(content)\n            ? content.filter((c: any) => c.type === 'text').map((c: any) => c.text).join('\\n')\n            : typeof content === 'string' ? content : '';\n\n          const responseSize = textContent.length;\n\n          // Capture token state BEFORE updating (for delta calculation)\n          const tokensBeforeResponse = session.cumulativeInputTokens + session.cumulativeOutputTokens;\n\n          // Extract and track token usage\n          const usage = message.message.usage;\n          if (usage) {\n            session.cumulativeInputTokens += usage.input_tokens || 0;\n            session.cumulativeOutputTokens += usage.output_tokens || 0;\n\n            // Cache creation counts as discovery, cache read doesn't\n            if (usage.cache_creation_input_tokens) {\n              session.cumulativeInputTokens += usage.cache_creation_input_tokens;\n            }\n\n            logger.debug('SDK', 'Token usage captured', {\n              sessionId: session.sessionDbId,\n              inputTokens: usage.input_tokens,\n              outputTokens: usage.output_tokens,\n              cacheCreation: usage.cache_creation_input_tokens || 0,\n              cacheRead: usage.cache_read_input_tokens || 0,\n              cumulativeInput: session.cumulativeInputTokens,\n              cumulativeOutput: session.cumulativeOutputTokens\n            });\n          }\n\n          // Calculate discovery tokens (delta for this response only)\n          const discoveryTokens = (session.cumulativeInputTokens + session.cumulativeOutputTokens) - tokensBeforeResponse;\n\n          // Process response (empty or not) and mark messages as processed\n          if (responseSize > 0) {\n            const truncatedResponse = responseSize > 100\n              ? textContent.substring(0, 100) + '...'\n              : textContent;\n            logger.dataOut('SDK', `Response received (${responseSize} chars)`, {\n              sessionId: session.sessionDbId,\n              promptNumber: session.lastPromptNumber\n            }, truncatedResponse);\n\n            // Parse and process response with discovery token delta\n            await this.processSDKResponse(session, textContent, worker, discoveryTokens);\n          } else {\n            // Empty response - still need to mark pending messages as processed\n            await this.markMessagesProcessed(session, worker);\n          }\n        }\n\n        // Log result messages\n        if (message.type === 'result' && message.subtype === 'success') {\n          // Usage telemetry is captured at SDK level\n        }\n      }\n\n      // Mark session complete\n      const sessionDuration = Date.now() - session.startTime;\n      logger.success('SDK', 'Agent completed', {\n        sessionId: session.sessionDbId,\n        duration: `${(sessionDuration / 1000).toFixed(1)}s`\n      });\n\n      this.dbManager.getSessionStore().markSessionCompleted(session.sessionDbId);\n\n    } catch (error: any) {\n      if (error.name === 'AbortError') {\n        logger.warn('SDK', 'Agent aborted', { sessionId: session.sessionDbId });\n      } else {\n        logger.failure('SDK', 'Agent error', { sessionDbId: session.sessionDbId }, error);\n      }\n      throw error;\n    } finally {\n      // Cleanup\n      this.sessionManager.deleteSession(session.sessionDbId).catch(() => {});\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_createMessageGenerator_188": {
      "name": "createMessageGenerator",
      "type": "method",
      "start_line": 188,
      "end_line": 252,
      "content_hash": "5ef63adff051e9416bd376e1a77cd63b57529212",
      "content": "  private async *createMessageGenerator(session: ActiveSession): AsyncIterableIterator<SDKUserMessage> {\n    // Load active mode\n    const mode = ModeManager.getInstance().getActiveMode();\n\n    // Yield initial user prompt with context (or continuation if prompt #2+)\n    // CRITICAL: Both paths use session.claudeSessionId from the hook\n    yield {\n      type: 'user',\n      message: {\n        role: 'user',\n        content: session.lastPromptNumber === 1\n          ? buildInitPrompt(session.project, session.claudeSessionId, session.userPrompt, mode)\n          : buildContinuationPrompt(session.userPrompt, session.lastPromptNumber, session.claudeSessionId, mode)\n      },\n      session_id: session.claudeSessionId,\n      parent_tool_use_id: null,\n      isSynthetic: true\n    };\n\n    // Consume pending messages from SessionManager (event-driven, no polling)\n    for await (const message of this.sessionManager.getMessageIterator(session.sessionDbId)) {\n      if (message.type === 'observation') {\n        // Update last prompt number\n        if (message.prompt_number !== undefined) {\n          session.lastPromptNumber = message.prompt_number;\n        }\n\n        yield {\n          type: 'user',\n          message: {\n            role: 'user',\n            content: buildObservationPrompt({\n              id: 0, // Not used in prompt\n              tool_name: message.tool_name!,\n              tool_input: JSON.stringify(message.tool_input),\n              tool_output: JSON.stringify(message.tool_response),\n              created_at_epoch: Date.now(),\n              cwd: message.cwd\n            })\n          },\n          session_id: session.claudeSessionId,\n          parent_tool_use_id: null,\n          isSynthetic: true\n        };\n      } else if (message.type === 'summarize') {\n        yield {\n          type: 'user',\n          message: {\n            role: 'user',\n            content: buildSummaryPrompt({\n              id: session.sessionDbId,\n              sdk_session_id: session.sdkSessionId,\n              project: session.project,\n              user_prompt: session.userPrompt,\n              last_user_message: message.last_user_message || '',\n              last_assistant_message: message.last_assistant_message || ''\n            }, mode)\n          },\n          session_id: session.claudeSessionId,\n          parent_tool_use_id: null,\n          isSynthetic: true\n        };\n      }\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_processSDKResponse_258": {
      "name": "processSDKResponse",
      "type": "method",
      "start_line": 258,
      "end_line": 406,
      "content_hash": "886ff8858e28b50a38d04f73229687a73c011d3b",
      "content": "  private async processSDKResponse(session: ActiveSession, text: string, worker: any | undefined, discoveryTokens: number): Promise<void> {\n    // Parse observations\n    const observations = parseObservations(text, session.claudeSessionId);\n\n    // Store observations\n    for (const obs of observations) {\n      const { id: obsId, createdAtEpoch } = this.dbManager.getSessionStore().storeObservation(\n        session.claudeSessionId,\n        session.project,\n        obs,\n        session.lastPromptNumber,\n        discoveryTokens\n      );\n\n      // Log observation details\n      logger.info('SDK', 'Observation saved', {\n        sessionId: session.sessionDbId,\n        obsId,\n        type: obs.type,\n        title: obs.title || '(untitled)',\n        filesRead: obs.files_read?.length ?? 0,\n        filesModified: obs.files_modified?.length ?? 0,\n        concepts: obs.concepts?.length ?? 0\n      });\n\n      // Sync to Chroma\n      const chromaStart = Date.now();\n      const obsType = obs.type;\n      const obsTitle = obs.title || '(untitled)';\n      this.dbManager.getChromaSync().syncObservation(\n        obsId,\n        session.claudeSessionId,\n        session.project,\n        obs,\n        session.lastPromptNumber,\n        createdAtEpoch,\n        discoveryTokens\n      ).then(() => {\n        const chromaDuration = Date.now() - chromaStart;\n        logger.debug('CHROMA', 'Observation synced', {\n          obsId,\n          duration: `${chromaDuration}ms`,\n          type: obsType,\n          title: obsTitle\n        });\n      }).catch((error) => {\n        logger.warn('CHROMA', 'Observation sync failed, continuing without vector search', {\n          obsId,\n          type: obsType,\n          title: obsTitle\n        }, error);\n      });\n\n      // Broadcast to SSE clients (for web UI)\n      if (worker && worker.sseBroadcaster) {\n        worker.sseBroadcaster.broadcast({\n          type: 'new_observation',\n          observation: {\n            id: obsId,\n            sdk_session_id: session.sdkSessionId,\n            session_id: session.claudeSessionId,\n            type: obs.type,\n            title: obs.title,\n            subtitle: obs.subtitle,\n            text: obs.text || null,\n            narrative: obs.narrative || null,\n            facts: JSON.stringify(obs.facts || []),\n            concepts: JSON.stringify(obs.concepts || []),\n            files_read: JSON.stringify(obs.files || []),\n            files_modified: JSON.stringify([]),\n            project: session.project,\n            prompt_number: session.lastPromptNumber,\n            created_at_epoch: createdAtEpoch\n          }\n        });\n      }\n    }\n\n    // Parse summary\n    const summary = parseSummary(text, session.sessionDbId);\n\n    // Store summary\n    if (summary) {\n      const { id: summaryId, createdAtEpoch } = this.dbManager.getSessionStore().storeSummary(\n        session.claudeSessionId,\n        session.project,\n        summary,\n        session.lastPromptNumber,\n        discoveryTokens\n      );\n\n      // Log summary details\n      logger.info('SDK', 'Summary saved', {\n        sessionId: session.sessionDbId,\n        summaryId,\n        request: summary.request || '(no request)',\n        hasCompleted: !!summary.completed,\n        hasNextSteps: !!summary.next_steps\n      });\n\n      // Sync to Chroma\n      const chromaStart = Date.now();\n      const summaryRequest = summary.request || '(no request)';\n      this.dbManager.getChromaSync().syncSummary(\n        summaryId,\n        session.claudeSessionId,\n        session.project,\n        summary,\n        session.lastPromptNumber,\n        createdAtEpoch,\n        discoveryTokens\n      ).then(() => {\n        const chromaDuration = Date.now() - chromaStart;\n        logger.debug('CHROMA', 'Summary synced', {\n          summaryId,\n          duration: `${chromaDuration}ms`,\n          request: summaryRequest\n        });\n      }).catch((error) => {\n        logger.warn('CHROMA', 'Summary sync failed, continuing without vector search', {\n          summaryId,\n          request: summaryRequest\n        }, error);\n      });\n\n      // Broadcast to SSE clients (for web UI)\n      if (worker && worker.sseBroadcaster) {\n        worker.sseBroadcaster.broadcast({\n          type: 'new_summary',\n          summary: {\n            id: summaryId,\n            session_id: session.claudeSessionId,\n            request: summary.request,\n            investigated: summary.investigated,\n            learned: summary.learned,\n            completed: summary.completed,\n            next_steps: summary.next_steps,\n            notes: summary.notes,\n            project: session.project,\n            prompt_number: session.lastPromptNumber,\n            created_at_epoch: createdAtEpoch\n          }\n        });\n      }\n    }\n\n    // Mark messages as processed after successful observation/summary storage\n    await this.markMessagesProcessed(session, worker);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_markMessagesProcessed_412": {
      "name": "markMessagesProcessed",
      "type": "method",
      "start_line": 412,
      "end_line": 438,
      "content_hash": "ca2b1d1f70f19b459e67396b25fead05474a32c0",
      "content": "  private async markMessagesProcessed(session: ActiveSession, worker: any | undefined): Promise<void> {\n    const pendingMessageStore = this.sessionManager.getPendingMessageStore();\n    if (session.pendingProcessingIds.size > 0) {\n      for (const messageId of session.pendingProcessingIds) {\n        pendingMessageStore.markProcessed(messageId);\n      }\n      logger.debug('SDK', 'Messages marked as processed', {\n        sessionId: session.sessionDbId,\n        messageIds: Array.from(session.pendingProcessingIds),\n        count: session.pendingProcessingIds.size\n      });\n      session.pendingProcessingIds.clear();\n\n      // Clean up old processed messages (keep last 100 for UI display)\n      const deletedCount = pendingMessageStore.cleanupProcessed(100);\n      if (deletedCount > 0) {\n        logger.debug('SDK', 'Cleaned up old processed messages', {\n          deletedCount\n        });\n      }\n    }\n\n    // Broadcast activity status after processing (queue may have changed)\n    if (worker && typeof worker.broadcastProcessingStatus === 'function') {\n      worker.broadcastProcessingStatus();\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findClaudeExecutable_447": {
      "name": "findClaudeExecutable",
      "type": "method",
      "start_line": 447,
      "end_line": 473,
      "content_hash": "cb34ebb6facf3fc7967e506e74adbe09d4f716f8",
      "content": "  private findClaudeExecutable(): string {\n    const settings = SettingsDefaultsManager.loadFromFile(USER_SETTINGS_PATH);\n    \n    // 1. Check configured path\n    if (settings.CLAUDE_CODE_PATH) {\n      // Lazy load fs to keep startup fast\n      const { existsSync } = require('fs');\n      if (!existsSync(settings.CLAUDE_CODE_PATH)) {\n        throw new Error(`CLAUDE_CODE_PATH is set to \"${settings.CLAUDE_CODE_PATH}\" but the file does not exist.`);\n      }\n      return settings.CLAUDE_CODE_PATH;\n    }\n\n    // 2. Try auto-detection\n    try {\n      const claudePath = execSync(\n        process.platform === 'win32' ? 'where claude' : 'which claude', \n        { encoding: 'utf8', windowsHide: true, stdio: ['ignore', 'pipe', 'ignore'] }\n      ).trim().split('\\n')[0].trim();\n      \n      if (claudePath) return claudePath;\n    } catch (error) {\n      logger.debug('SDK', 'Claude executable auto-detection failed', error);\n    }\n\n    throw new Error('Claude executable not found. Please either:\\n1. Add \"claude\" to your system PATH, or\\n2. Set CLAUDE_CODE_PATH in ~/.claude-mem/settings.json');\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getModelId_478": {
      "name": "getModelId",
      "type": "method",
      "start_line": 478,
      "end_line": 482,
      "content_hash": "a6da74e1f903311bcf4da0720c504f846c555839",
      "content": "  private getModelId(): string {\n    const settingsPath = path.join(homedir(), '.claude-mem', 'settings.json');\n    const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n    return settings.CLAUDE_MEM_MODEL;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}