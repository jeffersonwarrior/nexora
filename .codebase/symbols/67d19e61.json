{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_gateway/tests/introspect_schema_tests.rs",
  "file_hash": "25c7bf5b341fa3712629060c28a3f287224717c6",
  "updated_at": "2025-12-26T17:34:22.262967",
  "symbols": {
    "function_create_test_app_state_17": {
      "name": "create_test_app_state",
      "type": "function",
      "start_line": 17,
      "end_line": 130,
      "content_hash": "0d9f158925c614106a096d72a401a013756d6a03",
      "content": "fn create_test_app_state(schema_json: Option<String>) -> Arc<AppState> {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().to_str().unwrap();\n    let opts = HelixGraphEngineOpts {\n        path: db_path.to_string(),\n        config: Config::default(),\n        version_info: VersionInfo::default(),\n    };\n    let graph = Arc::new(HelixGraphEngine::new(opts).unwrap());\n    let router = Arc::new(HelixRouter::new(None, None, None));\n    let rt = Arc::new(\n        tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(1)\n            .enable_all()\n            .build()\n            .unwrap(),\n    );\n\n    let cores = core_affinity::get_core_ids().unwrap_or_default();\n    let core_setter = Arc::new(CoreSetter::new(cores, 2));\n    let worker_pool = WorkerPool::new(core_setter, graph, router, rt);\n\n    Arc::new(AppState {\n        worker_pool,\n        schema_json,\n        cluster_id: None,\n    })\n}\n\n#[tokio::test]\nasync fn test_introspect_schema_with_valid_schema() {\n    let schema_json = r#\"{\"version\":\"1.0\",\"tables\":[]}\"#.to_string();\n    let state = create_test_app_state(Some(schema_json.clone()));\n\n    let response = introspect_schema_handler(State(state)).await;\n\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let content_type = response.headers().get(\"Content-Type\");\n    assert!(content_type.is_some());\n    assert_eq!(content_type.unwrap(), \"application/json\");\n\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    let body_str = String::from_utf8(body_bytes.to_vec()).unwrap();\n    assert_eq!(body_str, schema_json);\n}\n\n#[tokio::test]\nasync fn test_introspect_schema_without_schema() {\n    let state = create_test_app_state(None);\n\n    let response = introspect_schema_handler(State(state)).await;\n\n    assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    let body_str = String::from_utf8(body_bytes.to_vec()).unwrap();\n    assert_eq!(body_str, \"Could not find schema\");\n}\n\n#[tokio::test]\nasync fn test_introspect_schema_with_empty_schema() {\n    let schema_json = \"\".to_string();\n    let state = create_test_app_state(Some(schema_json.clone()));\n\n    let response = introspect_schema_handler(State(state)).await;\n\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    let body_str = String::from_utf8(body_bytes.to_vec()).unwrap();\n    assert_eq!(body_str, \"\");\n}\n\n#[tokio::test]\nasync fn test_introspect_schema_with_complex_schema() {\n    let schema_json = r#\"{\"version\":\"2.0\",\"tables\":[{\"name\":\"users\",\"fields\":[\"id\",\"name\",\"email\"]},{\"name\":\"posts\",\"fields\":[\"id\",\"title\",\"content\"]}]}\"#.to_string();\n    let state = create_test_app_state(Some(schema_json.clone()));\n\n    let response = introspect_schema_handler(State(state)).await;\n\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    let body_str = String::from_utf8(body_bytes.to_vec()).unwrap();\n    assert_eq!(body_str, schema_json);\n}\n\n#[tokio::test]\nasync fn test_introspect_schema_response_format() {\n    let schema_json = r#\"{\"test\":\"data\"}\"#.to_string();\n    let state = create_test_app_state(Some(schema_json));\n\n    let response = introspect_schema_handler(State(state)).await;\n\n    assert_eq!(response.status(), StatusCode::OK);\n    assert_eq!(\n        response.headers().get(\"Content-Type\").unwrap(),\n        \"application/json\"\n    );\n\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    assert!(!body_bytes.is_empty());\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}