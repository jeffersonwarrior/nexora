{
  "file_path": "/work/external-deps/helix-db/helix-db/src/helix_engine/traversal_core/ops/in_/in_.rs",
  "file_hash": "a9a3f0553d932e12dd7c900798fc4a976a62976c",
  "updated_at": "2025-12-26T17:34:21.198002",
  "symbols": {
    "trait_InAdapter_10": {
      "name": "InAdapter",
      "type": "trait",
      "start_line": 10,
      "end_line": 18,
      "content_hash": "c12b935bfd76690422cd965dced3ead2419edd45",
      "content": "pub trait InAdapter<'db, 'arena, 'txn, 's>:\n    Iterator<Item = Result<TraversalValue<'arena>, GraphError>>\n{\n    /// Returns an iterator containing the nodes that have an incoming edge with the given label.\n    ///\n    /// Note that the `edge_label` cannot be empty and must be a valid, existing edge label.\n    ///\n    /// To provide safety, you cannot get all outgoing nodes as it would be ambiguous as to what\n    /// type that resulting node would be.",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "function_in_vec_19": {
      "name": "in_vec",
      "type": "function",
      "start_line": 19,
      "end_line": 26,
      "content_hash": "66bb2ed02eed2ec2344049a3e4297303c4f30d56",
      "content": "    fn in_vec(\n        self,\n        edge_label: &'s str,\n        get_vector_data: bool,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_27": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 27,
      "end_line": 29,
      "content_hash": "8773007e76fbde46c81641c22c1a5fbbac716149",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_node_30": {
      "name": "in_node",
      "type": "method",
      "start_line": 30,
      "end_line": 36,
      "content_hash": "34647ffbd0aac702939534df98060b04dfed81c9",
      "content": "    fn in_node(\n        self,\n        edge_label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_37": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 37,
      "end_line": 44,
      "content_hash": "e218f1e1f7d9bac1ea1ae0fa56f2828b13ea5c58",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    >;\n}\n\nimpl<'db, 'arena, 'txn, 's, I: Iterator<Item = Result<TraversalValue<'arena>, GraphError>>>\n    InAdapter<'db, 'arena, 'txn, 's> for RoTraversalIterator<'db, 'arena, 'txn, I>\n{\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_vec_45": {
      "name": "in_vec",
      "type": "method",
      "start_line": 45,
      "end_line": 52,
      "content_hash": "66bb2ed02eed2ec2344049a3e4297303c4f30d56",
      "content": "    fn in_vec(\n        self,\n        edge_label: &'s str,\n        get_vector_data: bool,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_53": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 53,
      "end_line": 116,
      "content_hash": "d9611c5e144047ddae2eb1bd10afafa1b426d0b3",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let iter = self\n            .inner\n            .filter_map(move |item| {\n                let edge_label_hash = hash_label(edge_label, None);\n                let prefix = HelixGraphStorage::in_edge_key(\n                    &match item {\n                        Ok(item) => item.id(),\n                        Err(_) => return None,\n                    },\n                    &edge_label_hash,\n                );\n\n                match self.storage.in_edges_db.get_duplicates(self.txn, &prefix) {\n                    Ok(Some(iter)) => Some(iter.filter_map(move |item| {\n                        if let Ok((_, value)) = item {\n                            let (_, item_id) = match HelixGraphStorage::unpack_adj_edge_data(value)\n                            {\n                                Ok(data) => data,\n                                Err(e) => {\n                                    println!(\"Error unpacking edge data: {e:?}\");\n                                    return Some(Err(e));\n                                }\n                            };\n                            if get_vector_data {\n                                if let Ok(vec) = self\n                                    .storage\n                                    .vectors\n                                    .get_full_vector(self.txn, item_id, self.arena)\n                                {\n                                    return Some(Ok(TraversalValue::Vector(vec)));\n                                }\n                            } else if let Ok(Some(vec)) = self\n                                .storage\n                                .vectors\n                                .get_vector_properties(self.txn, item_id, self.arena)\n                            {\n                                return Some(Ok(TraversalValue::VectorNodeWithoutVectorData(vec)));\n                            }\n                            None\n                        } else {\n                            None\n                        }\n                    })),\n                    Ok(None) => None,\n                    Err(e) => {\n                        println!(\"{} Error getting out edges: {:?}\", line!(), e);\n                        // return Err(e);\n                        None\n                    }\n                }\n            })\n            .flatten();\n\n        RoTraversalIterator {\n            inner: iter,\n            storage: self.storage,\n            arena: self.arena,\n            txn: self.txn,\n        }\n    }\n\n    #[inline]",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_in_node_117": {
      "name": "in_node",
      "type": "method",
      "start_line": 117,
      "end_line": 123,
      "content_hash": "34647ffbd0aac702939534df98060b04dfed81c9",
      "content": "    fn in_node(\n        self,\n        edge_label: &'s str,\n    ) -> RoTraversalIterator<\n        'db,\n        'arena,\n        'txn,",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "impl_Iterator_124": {
      "name": "Iterator",
      "type": "impl",
      "start_line": 124,
      "end_line": 171,
      "content_hash": "6f3e5ac70d9907034e8d67531524de9ab9f7ecd5",
      "content": "        impl Iterator<Item = Result<TraversalValue<'arena>, GraphError>>,\n    > {\n        let iter = self\n            .inner\n            .filter_map(move |item| {\n                let edge_label_hash = hash_label(edge_label, None);\n                let prefix = HelixGraphStorage::in_edge_key(\n                    &match item {\n                        Ok(item) => item.id(),\n                        Err(_) => return None,\n                    },\n                    &edge_label_hash,\n                );\n                match self.storage.in_edges_db.get_duplicates(self.txn, &prefix) {\n                    Ok(Some(iter)) => Some(iter.filter_map(move |item| {\n                        if let Ok((_, data)) = item {\n                            let (_, item_id) = match HelixGraphStorage::unpack_adj_edge_data(data) {\n                                Ok(data) => data,\n                                Err(e) => {\n                                    println!(\"Error unpacking edge data: {e:?}\");\n                                    return Some(Err(e));\n                                }\n                            };\n                            if let Ok(node) = self.storage.get_node(self.txn, &item_id, self.arena)\n                            {\n                                return Some(Ok(TraversalValue::Node(node)));\n                            }\n                        }\n                        None\n                    })),\n                    Ok(None) => None,\n                    Err(e) => {\n                        println!(\"{} Error getting out nodes: {:?}\", line!(), e);\n                        // return Err(e);\n                        None\n                    }\n                }\n            })\n            .flatten();\n\n        RoTraversalIterator {\n            inner: iter,\n            storage: self.storage,\n            arena: self.arena,\n            txn: self.txn,\n        }\n    }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}