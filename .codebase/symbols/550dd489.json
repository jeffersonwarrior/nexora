{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/http/routes/SettingsRoutes.ts",
  "file_hash": "37f5a76142a172f262d7c876dea5259512e67e79",
  "updated_at": "2025-12-26T17:34:23.596955",
  "symbols": {
    "class_SettingsRoutes_21": {
      "name": "SettingsRoutes",
      "type": "class",
      "start_line": 21,
      "end_line": 350,
      "content_hash": "9d169579356ccdab87ee46df080a9fd221b5b7d9",
      "content": "export class SettingsRoutes extends BaseRouteHandler {\n  constructor(\n    private settingsManager: SettingsManager\n  ) {\n    super();\n  }\n\n  setupRoutes(app: express.Application): void {\n    // Settings endpoints\n    app.get('/api/settings', this.handleGetSettings.bind(this));\n    app.post('/api/settings', this.handleUpdateSettings.bind(this));\n\n    // MCP toggle endpoints\n    app.get('/api/mcp/status', this.handleGetMcpStatus.bind(this));\n    app.post('/api/mcp/toggle', this.handleToggleMcp.bind(this));\n\n    // Branch switching endpoints\n    app.get('/api/branch/status', this.handleGetBranchStatus.bind(this));\n    app.post('/api/branch/switch', this.handleSwitchBranch.bind(this));\n    app.post('/api/branch/update', this.handleUpdateBranch.bind(this));\n  }\n\n  /**\n   * Get environment settings (from ~/.claude-mem/settings.json)\n   */\n  private handleGetSettings = this.wrapHandler((req: Request, res: Response): void => {\n    const settingsPath = path.join(homedir(), '.claude-mem', 'settings.json');\n    this.ensureSettingsFile(settingsPath);\n    const settings = SettingsDefaultsManager.loadFromFile(settingsPath);\n    res.json(settings);\n  });\n\n  /**\n   * Update environment settings (in ~/.claude-mem/settings.json) with validation\n   */\n  private handleUpdateSettings = this.wrapHandler((req: Request, res: Response): void => {\n    // Validate all settings\n    const validation = this.validateSettings(req.body);\n    if (!validation.valid) {\n      res.status(400).json({\n        success: false,\n        error: validation.error\n      });\n      return;\n    }\n\n    // Read existing settings\n    const settingsPath = path.join(homedir(), '.claude-mem', 'settings.json');\n    this.ensureSettingsFile(settingsPath);\n    let settings: any = {};\n\n    if (existsSync(settingsPath)) {\n      const settingsData = readFileSync(settingsPath, 'utf-8');\n      settings = JSON.parse(settingsData);\n    }\n\n    // Update all settings from request body\n    const settingKeys = [\n      'CLAUDE_MEM_MODEL',\n      'CLAUDE_MEM_CONTEXT_OBSERVATIONS',\n      'CLAUDE_MEM_WORKER_PORT',\n      'CLAUDE_MEM_WORKER_HOST',\n      // System Configuration\n      'CLAUDE_MEM_DATA_DIR',\n      'CLAUDE_MEM_LOG_LEVEL',\n      'CLAUDE_MEM_PYTHON_VERSION',\n      'CLAUDE_CODE_PATH',\n      // Token Economics\n      'CLAUDE_MEM_CONTEXT_SHOW_READ_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_WORK_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_AMOUNT',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_PERCENT',\n      // Observation Filtering\n      'CLAUDE_MEM_CONTEXT_OBSERVATION_TYPES',\n      'CLAUDE_MEM_CONTEXT_OBSERVATION_CONCEPTS',\n      // Display Configuration\n      'CLAUDE_MEM_CONTEXT_FULL_COUNT',\n      'CLAUDE_MEM_CONTEXT_FULL_FIELD',\n      'CLAUDE_MEM_CONTEXT_SESSION_COUNT',\n      // Feature Toggles\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_SUMMARY',\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_MESSAGE',\n    ];\n\n    for (const key of settingKeys) {\n      if (req.body[key] !== undefined) {\n        settings[key] = req.body[key];\n      }\n    }\n\n    // Write back\n    writeFileSync(settingsPath, JSON.stringify(settings, null, 2), 'utf-8');\n\n    // Clear port cache to force re-reading from updated settings\n    clearPortCache();\n\n    logger.info('WORKER', 'Settings updated');\n    res.json({ success: true, message: 'Settings updated successfully' });\n  });\n\n  /**\n   * GET /api/mcp/status - Check if MCP search server is enabled\n   */\n  private handleGetMcpStatus = this.wrapHandler((req: Request, res: Response): void => {\n    const enabled = this.isMcpEnabled();\n    res.json({ enabled });\n  });\n\n  /**\n   * POST /api/mcp/toggle - Toggle MCP search server on/off\n   * Body: { enabled: boolean }\n   */\n  private handleToggleMcp = this.wrapHandler((req: Request, res: Response): void => {\n    const { enabled } = req.body;\n\n    if (typeof enabled !== 'boolean') {\n      this.badRequest(res, 'enabled must be a boolean');\n      return;\n    }\n\n    this.toggleMcp(enabled);\n    res.json({ success: true, enabled: this.isMcpEnabled() });\n  });\n\n  /**\n   * GET /api/branch/status - Get current branch information\n   */\n  private handleGetBranchStatus = this.wrapHandler((req: Request, res: Response): void => {\n    const info = getBranchInfo();\n    res.json(info);\n  });\n\n  /**\n   * POST /api/branch/switch - Switch to a different branch\n   * Body: { branch: \"main\" | \"beta/7.0\" }\n   */\n  private handleSwitchBranch = this.wrapHandler(async (req: Request, res: Response): Promise<void> => {\n    const { branch } = req.body;\n\n    if (!branch) {\n      res.status(400).json({ success: false, error: 'Missing branch parameter' });\n      return;\n    }\n\n    // Validate branch name\n    const allowedBranches = ['main', 'beta/7.0', 'feature/bun-executable'];\n    if (!allowedBranches.includes(branch)) {\n      res.status(400).json({\n        success: false,\n        error: `Invalid branch. Allowed: ${allowedBranches.join(', ')}`\n      });\n      return;\n    }\n\n    logger.info('WORKER', 'Branch switch requested', { branch });\n\n    const result = await switchBranch(branch);\n\n    if (result.success) {\n      // Schedule worker restart after response is sent\n      setTimeout(() => {\n        logger.info('WORKER', 'Restarting worker after branch switch');\n        process.exit(0); // PM2 will restart the worker\n      }, 1000);\n    }\n\n    res.json(result);\n  });\n\n  /**\n   * POST /api/branch/update - Pull latest updates for current branch\n   */\n  private handleUpdateBranch = this.wrapHandler(async (req: Request, res: Response): Promise<void> => {\n    logger.info('WORKER', 'Branch update requested');\n\n    const result = await pullUpdates();\n\n    if (result.success) {\n      // Schedule worker restart after response is sent\n      setTimeout(() => {\n        logger.info('WORKER', 'Restarting worker after branch update');\n        process.exit(0); // PM2 will restart the worker\n      }, 1000);\n    }\n\n    res.json(result);\n  });\n\n  /**\n   * Validate all settings from request body (single source of truth)\n   */\n  private validateSettings(settings: any): { valid: boolean; error?: string } {\n    // Validate CLAUDE_MEM_CONTEXT_OBSERVATIONS\n    if (settings.CLAUDE_MEM_CONTEXT_OBSERVATIONS) {\n      const obsCount = parseInt(settings.CLAUDE_MEM_CONTEXT_OBSERVATIONS, 10);\n      if (isNaN(obsCount) || obsCount < 1 || obsCount > 200) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_OBSERVATIONS must be between 1 and 200' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_WORKER_PORT\n    if (settings.CLAUDE_MEM_WORKER_PORT) {\n      const port = parseInt(settings.CLAUDE_MEM_WORKER_PORT, 10);\n      if (isNaN(port) || port < 1024 || port > 65535) {\n        return { valid: false, error: 'CLAUDE_MEM_WORKER_PORT must be between 1024 and 65535' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_WORKER_HOST (IP address or 0.0.0.0)\n    if (settings.CLAUDE_MEM_WORKER_HOST) {\n      const host = settings.CLAUDE_MEM_WORKER_HOST;\n      // Allow localhost variants and valid IP patterns\n      const validHostPattern = /^(127\\.0\\.0\\.1|0\\.0\\.0\\.0|localhost|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})$/;\n      if (!validHostPattern.test(host)) {\n        return { valid: false, error: 'CLAUDE_MEM_WORKER_HOST must be a valid IP address (e.g., 127.0.0.1, 0.0.0.0)' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_LOG_LEVEL\n    if (settings.CLAUDE_MEM_LOG_LEVEL) {\n      const validLevels = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'SILENT'];\n      if (!validLevels.includes(settings.CLAUDE_MEM_LOG_LEVEL.toUpperCase())) {\n        return { valid: false, error: 'CLAUDE_MEM_LOG_LEVEL must be one of: DEBUG, INFO, WARN, ERROR, SILENT' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_PYTHON_VERSION (must be valid Python version format)\n    if (settings.CLAUDE_MEM_PYTHON_VERSION) {\n      const pythonVersionRegex = /^3\\.\\d{1,2}$/;\n      if (!pythonVersionRegex.test(settings.CLAUDE_MEM_PYTHON_VERSION)) {\n        return { valid: false, error: 'CLAUDE_MEM_PYTHON_VERSION must be in format \"3.X\" or \"3.XX\" (e.g., \"3.13\")' };\n      }\n    }\n\n    // Validate boolean string values\n    const booleanSettings = [\n      'CLAUDE_MEM_CONTEXT_SHOW_READ_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_WORK_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_AMOUNT',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_PERCENT',\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_SUMMARY',\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_MESSAGE',\n    ];\n\n    for (const key of booleanSettings) {\n      if (settings[key] && !['true', 'false'].includes(settings[key])) {\n        return { valid: false, error: `${key} must be \"true\" or \"false\"` };\n      }\n    }\n\n    // Validate FULL_COUNT (0-20)\n    if (settings.CLAUDE_MEM_CONTEXT_FULL_COUNT) {\n      const count = parseInt(settings.CLAUDE_MEM_CONTEXT_FULL_COUNT, 10);\n      if (isNaN(count) || count < 0 || count > 20) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_FULL_COUNT must be between 0 and 20' };\n      }\n    }\n\n    // Validate SESSION_COUNT (1-50)\n    if (settings.CLAUDE_MEM_CONTEXT_SESSION_COUNT) {\n      const count = parseInt(settings.CLAUDE_MEM_CONTEXT_SESSION_COUNT, 10);\n      if (isNaN(count) || count < 1 || count > 50) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_SESSION_COUNT must be between 1 and 50' };\n      }\n    }\n\n    // Validate FULL_FIELD\n    if (settings.CLAUDE_MEM_CONTEXT_FULL_FIELD) {\n      if (!['narrative', 'facts'].includes(settings.CLAUDE_MEM_CONTEXT_FULL_FIELD)) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_FULL_FIELD must be \"narrative\" or \"facts\"' };\n      }\n    }\n\n    // Skip observation types validation - any type string is valid since modes define their own types\n    // The database accepts any TEXT value, and mode-specific validation happens at parse time\n\n    // Skip observation concepts validation - any concept string is valid since modes define their own concepts\n    // The database accepts any TEXT value, and mode-specific validation happens at parse time\n\n    return { valid: true };\n  }\n\n  /**\n   * Check if MCP search server is enabled\n   */\n  private isMcpEnabled(): boolean {\n    const packageRoot = getPackageRoot();\n    const mcpPath = path.join(packageRoot, 'plugin', '.mcp.json');\n    return existsSync(mcpPath);\n  }\n\n  /**\n   * Toggle MCP search server (rename .mcp.json <-> .mcp.json.disabled)\n   */\n  private toggleMcp(enabled: boolean): void {\n    const packageRoot = getPackageRoot();\n    const mcpPath = path.join(packageRoot, 'plugin', '.mcp.json');\n    const mcpDisabledPath = path.join(packageRoot, 'plugin', '.mcp.json.disabled');\n\n    if (enabled && existsSync(mcpDisabledPath)) {\n      // Enable: rename .mcp.json.disabled -> .mcp.json\n      renameSync(mcpDisabledPath, mcpPath);\n      logger.info('WORKER', 'MCP search server enabled');\n    } else if (!enabled && existsSync(mcpPath)) {\n      // Disable: rename .mcp.json -> .mcp.json.disabled\n      renameSync(mcpPath, mcpDisabledPath);\n      logger.info('WORKER', 'MCP search server disabled');\n    } else {\n      logger.debug('WORKER', 'MCP toggle no-op (already in desired state)', { enabled });\n    }\n  }\n\n  /**\n   * Ensure settings file exists, creating with defaults if missing\n   */\n  private ensureSettingsFile(settingsPath: string): void {\n    if (!existsSync(settingsPath)) {\n      const defaults = SettingsDefaultsManager.getAllDefaults();\n\n      // Ensure directory exists\n      const dir = path.dirname(settingsPath);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n      }\n\n      writeFileSync(settingsPath, JSON.stringify(defaults, null, 2), 'utf-8');\n      logger.info('SETTINGS', 'Created settings file with defaults', { settingsPath });\n    }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_22": {
      "name": "constructor",
      "type": "method",
      "start_line": 22,
      "end_line": 26,
      "content_hash": "f90009199cd3ae6fbca80210591d525d5e2d73ca",
      "content": "  constructor(\n    private settingsManager: SettingsManager\n  ) {\n    super();\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_setupRoutes_28": {
      "name": "setupRoutes",
      "type": "method",
      "start_line": 28,
      "end_line": 41,
      "content_hash": "13737757fd5fc124a58bf1c2a1eca4524ccd72f1",
      "content": "  setupRoutes(app: express.Application): void {\n    // Settings endpoints\n    app.get('/api/settings', this.handleGetSettings.bind(this));\n    app.post('/api/settings', this.handleUpdateSettings.bind(this));\n\n    // MCP toggle endpoints\n    app.get('/api/mcp/status', this.handleGetMcpStatus.bind(this));\n    app.post('/api/mcp/toggle', this.handleToggleMcp.bind(this));\n\n    // Branch switching endpoints\n    app.get('/api/branch/status', this.handleGetBranchStatus.bind(this));\n    app.post('/api/branch/switch', this.handleSwitchBranch.bind(this));\n    app.post('/api/branch/update', this.handleUpdateBranch.bind(this));\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_validateSettings_212": {
      "name": "validateSettings",
      "type": "method",
      "start_line": 212,
      "end_line": 301,
      "content_hash": "3b1715151a2d07dddb16da27723ddcd9ce314f19",
      "content": "  private validateSettings(settings: any): { valid: boolean; error?: string } {\n    // Validate CLAUDE_MEM_CONTEXT_OBSERVATIONS\n    if (settings.CLAUDE_MEM_CONTEXT_OBSERVATIONS) {\n      const obsCount = parseInt(settings.CLAUDE_MEM_CONTEXT_OBSERVATIONS, 10);\n      if (isNaN(obsCount) || obsCount < 1 || obsCount > 200) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_OBSERVATIONS must be between 1 and 200' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_WORKER_PORT\n    if (settings.CLAUDE_MEM_WORKER_PORT) {\n      const port = parseInt(settings.CLAUDE_MEM_WORKER_PORT, 10);\n      if (isNaN(port) || port < 1024 || port > 65535) {\n        return { valid: false, error: 'CLAUDE_MEM_WORKER_PORT must be between 1024 and 65535' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_WORKER_HOST (IP address or 0.0.0.0)\n    if (settings.CLAUDE_MEM_WORKER_HOST) {\n      const host = settings.CLAUDE_MEM_WORKER_HOST;\n      // Allow localhost variants and valid IP patterns\n      const validHostPattern = /^(127\\.0\\.0\\.1|0\\.0\\.0\\.0|localhost|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})$/;\n      if (!validHostPattern.test(host)) {\n        return { valid: false, error: 'CLAUDE_MEM_WORKER_HOST must be a valid IP address (e.g., 127.0.0.1, 0.0.0.0)' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_LOG_LEVEL\n    if (settings.CLAUDE_MEM_LOG_LEVEL) {\n      const validLevels = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'SILENT'];\n      if (!validLevels.includes(settings.CLAUDE_MEM_LOG_LEVEL.toUpperCase())) {\n        return { valid: false, error: 'CLAUDE_MEM_LOG_LEVEL must be one of: DEBUG, INFO, WARN, ERROR, SILENT' };\n      }\n    }\n\n    // Validate CLAUDE_MEM_PYTHON_VERSION (must be valid Python version format)\n    if (settings.CLAUDE_MEM_PYTHON_VERSION) {\n      const pythonVersionRegex = /^3\\.\\d{1,2}$/;\n      if (!pythonVersionRegex.test(settings.CLAUDE_MEM_PYTHON_VERSION)) {\n        return { valid: false, error: 'CLAUDE_MEM_PYTHON_VERSION must be in format \"3.X\" or \"3.XX\" (e.g., \"3.13\")' };\n      }\n    }\n\n    // Validate boolean string values\n    const booleanSettings = [\n      'CLAUDE_MEM_CONTEXT_SHOW_READ_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_WORK_TOKENS',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_AMOUNT',\n      'CLAUDE_MEM_CONTEXT_SHOW_SAVINGS_PERCENT',\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_SUMMARY',\n      'CLAUDE_MEM_CONTEXT_SHOW_LAST_MESSAGE',\n    ];\n\n    for (const key of booleanSettings) {\n      if (settings[key] && !['true', 'false'].includes(settings[key])) {\n        return { valid: false, error: `${key} must be \"true\" or \"false\"` };\n      }\n    }\n\n    // Validate FULL_COUNT (0-20)\n    if (settings.CLAUDE_MEM_CONTEXT_FULL_COUNT) {\n      const count = parseInt(settings.CLAUDE_MEM_CONTEXT_FULL_COUNT, 10);\n      if (isNaN(count) || count < 0 || count > 20) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_FULL_COUNT must be between 0 and 20' };\n      }\n    }\n\n    // Validate SESSION_COUNT (1-50)\n    if (settings.CLAUDE_MEM_CONTEXT_SESSION_COUNT) {\n      const count = parseInt(settings.CLAUDE_MEM_CONTEXT_SESSION_COUNT, 10);\n      if (isNaN(count) || count < 1 || count > 50) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_SESSION_COUNT must be between 1 and 50' };\n      }\n    }\n\n    // Validate FULL_FIELD\n    if (settings.CLAUDE_MEM_CONTEXT_FULL_FIELD) {\n      if (!['narrative', 'facts'].includes(settings.CLAUDE_MEM_CONTEXT_FULL_FIELD)) {\n        return { valid: false, error: 'CLAUDE_MEM_CONTEXT_FULL_FIELD must be \"narrative\" or \"facts\"' };\n      }\n    }\n\n    // Skip observation types validation - any type string is valid since modes define their own types\n    // The database accepts any TEXT value, and mode-specific validation happens at parse time\n\n    // Skip observation concepts validation - any concept string is valid since modes define their own concepts\n    // The database accepts any TEXT value, and mode-specific validation happens at parse time\n\n    return { valid: true };\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_isMcpEnabled_306": {
      "name": "isMcpEnabled",
      "type": "method",
      "start_line": 306,
      "end_line": 310,
      "content_hash": "822754e44252c3a8aa19e75c20571a5cf1c5267a",
      "content": "  private isMcpEnabled(): boolean {\n    const packageRoot = getPackageRoot();\n    const mcpPath = path.join(packageRoot, 'plugin', '.mcp.json');\n    return existsSync(mcpPath);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_toggleMcp_315": {
      "name": "toggleMcp",
      "type": "method",
      "start_line": 315,
      "end_line": 331,
      "content_hash": "3c8d213312843888bac6d360bd5ff56506e13194",
      "content": "  private toggleMcp(enabled: boolean): void {\n    const packageRoot = getPackageRoot();\n    const mcpPath = path.join(packageRoot, 'plugin', '.mcp.json');\n    const mcpDisabledPath = path.join(packageRoot, 'plugin', '.mcp.json.disabled');\n\n    if (enabled && existsSync(mcpDisabledPath)) {\n      // Enable: rename .mcp.json.disabled -> .mcp.json\n      renameSync(mcpDisabledPath, mcpPath);\n      logger.info('WORKER', 'MCP search server enabled');\n    } else if (!enabled && existsSync(mcpPath)) {\n      // Disable: rename .mcp.json -> .mcp.json.disabled\n      renameSync(mcpPath, mcpDisabledPath);\n      logger.info('WORKER', 'MCP search server disabled');\n    } else {\n      logger.debug('WORKER', 'MCP toggle no-op (already in desired state)', { enabled });\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_ensureSettingsFile_336": {
      "name": "ensureSettingsFile",
      "type": "method",
      "start_line": 336,
      "end_line": 349,
      "content_hash": "21e90d36d9e2e28dd60ad789c66c2137ffe887b7",
      "content": "  private ensureSettingsFile(settingsPath: string): void {\n    if (!existsSync(settingsPath)) {\n      const defaults = SettingsDefaultsManager.getAllDefaults();\n\n      // Ensure directory exists\n      const dir = path.dirname(settingsPath);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n      }\n\n      writeFileSync(settingsPath, JSON.stringify(defaults, null, 2), 'utf-8');\n      logger.info('SETTINGS', 'Created settings file with defaults', { settingsPath });\n    }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}