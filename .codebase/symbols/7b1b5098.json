{
  "file_path": "/work/external-deps/claude-mem/src/services/worker/SearchManager.ts",
  "file_hash": "d53ab8278f900e1359a9118687be40870c2e1955",
  "updated_at": "2025-12-26T17:34:19.990025",
  "symbols": {
    "class_SearchManager_24": {
      "name": "SearchManager",
      "type": "class",
      "start_line": 24,
      "end_line": 1953,
      "content_hash": "542ad7a90d9cd798a0bcd6844bf0fd7aa3768293",
      "content": "export class SearchManager {\n  constructor(\n    private sessionSearch: SessionSearch,\n    private sessionStore: SessionStore,\n    private chromaSync: ChromaSync,\n    private formatter: FormattingService,\n    private timelineService: TimelineService\n  ) {}\n\n  /**\n   * Query Chroma vector database via ChromaSync\n   */\n  private async queryChroma(\n    query: string,\n    limit: number,\n    whereFilter?: Record<string, any>\n  ): Promise<{ ids: number[]; distances: number[]; metadatas: any[] }> {\n    return await this.chromaSync.queryChroma(query, limit, whereFilter);\n  }\n\n  /**\n   * Helper to normalize query parameters from URL-friendly format\n   * Converts comma-separated strings to arrays and flattens date params\n   */\n  private normalizeParams(args: any): any {\n    const normalized: any = { ...args };\n\n    // Parse comma-separated concepts into array\n    if (normalized.concepts && typeof normalized.concepts === 'string') {\n      normalized.concepts = normalized.concepts.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated files into array\n    if (normalized.files && typeof normalized.files === 'string') {\n      normalized.files = normalized.files.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated obs_type into array\n    if (normalized.obs_type && typeof normalized.obs_type === 'string') {\n      normalized.obs_type = normalized.obs_type.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated type (for filterSchema) into array\n    if (normalized.type && typeof normalized.type === 'string' && normalized.type.includes(',')) {\n      normalized.type = normalized.type.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Flatten dateStart/dateEnd into dateRange object\n    if (normalized.dateStart || normalized.dateEnd) {\n      normalized.dateRange = {\n        start: normalized.dateStart,\n        end: normalized.dateEnd\n      };\n      delete normalized.dateStart;\n      delete normalized.dateEnd;\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Tool handler: search\n   */\n  async search(args: any): Promise<any> {\n      try {\n        // Normalize URL-friendly params to internal format\n        const normalized = this.normalizeParams(args);\n        const { query, type, obs_type, concepts, files, format, ...options } = normalized;\n        let observations: ObservationSearchResult[] = [];\n        let sessions: SessionSummarySearchResult[] = [];\n        let prompts: UserPromptSearchResult[] = [];\n        let chromaFailed = false;\n\n        // Determine which types to query based on type filter\n        const searchObservations = !type || type === 'observations';\n        const searchSessions = !type || type === 'sessions';\n        const searchPrompts = !type || type === 'prompts';\n\n        // PATH 1: FILTER-ONLY (no query text) - Skip Chroma/FTS5, use direct SQLite filtering\n        // This path enables date filtering which Chroma cannot do (requires direct SQLite access)\n        if (!query) {\n          logger.debug('SEARCH', 'Filter-only query (no query text), using direct SQLite filtering', { enablesDateFilters: true });\n          const obsOptions = { ...options, type: obs_type, concepts, files };\n          if (searchObservations) {\n            observations = this.sessionSearch.searchObservations(undefined, obsOptions);\n          }\n          if (searchSessions) {\n            sessions = this.sessionSearch.searchSessions(undefined, options);\n          }\n          if (searchPrompts) {\n            prompts = this.sessionSearch.searchUserPrompts(undefined, options);\n          }\n        }\n        // PATH 2: CHROMA SEMANTIC SEARCH (query text + Chroma available)\n        else if (this.chromaSync) {\n          let chromaSucceeded = false;\n          try {\n            logger.debug('SEARCH', 'Using ChromaDB semantic search', { typeFilter: type || 'all' });\n\n            // Build Chroma where filter for doc_type\n            let whereFilter: Record<string, any> | undefined;\n            if (type === 'observations') {\n              whereFilter = { doc_type: 'observation' };\n            } else if (type === 'sessions') {\n              whereFilter = { doc_type: 'session_summary' };\n            } else if (type === 'prompts') {\n              whereFilter = { doc_type: 'user_prompt' };\n            }\n\n            // Step 1: Chroma semantic search with optional type filter\n            const chromaResults = await this.queryChroma(query, 100, whereFilter);\n            chromaSucceeded = true; // Chroma didn't throw error\n            logger.debug('SEARCH', 'ChromaDB returned semantic matches', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentMetadata = chromaResults.metadatas.map((meta, idx) => ({\n                id: chromaResults.ids[idx],\n                meta,\n                isRecent: meta && meta.created_at_epoch > ninetyDaysAgo\n              })).filter(item => item.isRecent);\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentMetadata.length });\n\n              // Step 3: Categorize IDs by document type\n              const obsIds: number[] = [];\n              const sessionIds: number[] = [];\n              const promptIds: number[] = [];\n\n              for (const item of recentMetadata) {\n                const docType = item.meta?.doc_type;\n                if (docType === 'observation' && searchObservations) {\n                  obsIds.push(item.id);\n                } else if (docType === 'session_summary' && searchSessions) {\n                  sessionIds.push(item.id);\n                } else if (docType === 'user_prompt' && searchPrompts) {\n                  promptIds.push(item.id);\n                }\n              }\n\n              logger.debug('SEARCH', 'Categorized results by type', { observations: obsIds.length, sessions: sessionIds.length, prompts: promptIds.length });\n\n              // Step 4: Hydrate from SQLite with additional filters\n              if (obsIds.length > 0) {\n                // Apply obs_type, concepts, files filters if provided\n                const obsOptions = { ...options, type: obs_type, concepts, files };\n                observations = this.sessionStore.getObservationsByIds(obsIds, obsOptions);\n              }\n              if (sessionIds.length > 0) {\n                sessions = this.sessionStore.getSessionSummariesByIds(sessionIds, { orderBy: 'date_desc', limit: options.limit, project: options.project });\n              }\n              if (promptIds.length > 0) {\n                prompts = this.sessionStore.getUserPromptsByIds(promptIds, { orderBy: 'date_desc', limit: options.limit, project: options.project });\n              }\n\n              logger.debug('SEARCH', 'Hydrated results from SQLite', { observations: observations.length, sessions: sessions.length, prompts: prompts.length });\n            } else {\n              // Chroma returned 0 results - this is the correct answer, don't fall back to FTS5\n              logger.debug('SEARCH', 'ChromaDB found no matches (final result, no FTS5 fallback)', {});\n            }\n          } catch (chromaError: any) {\n            chromaFailed = true;\n            logger.debug('SEARCH', 'ChromaDB failed - semantic search unavailable', { error: chromaError.message });\n            logger.debug('SEARCH', 'Install UVX/Python to enable vector search', { url: 'https://docs.astral.sh/uv/getting-started/installation/' });\n            // Set empty results - will show error message to user\n            observations = [];\n            sessions = [];\n            prompts = [];\n          }\n        }\n        // ChromaDB not initialized - mark as failed to show proper error message\n        else if (query) {\n          chromaFailed = true;\n          logger.debug('SEARCH', 'ChromaDB not initialized - semantic search unavailable', {});\n          logger.debug('SEARCH', 'Install UVX/Python to enable vector search', { url: 'https://docs.astral.sh/uv/getting-started/installation/' });\n          observations = [];\n          sessions = [];\n          prompts = [];\n        }\n\n        const totalResults = observations.length + sessions.length + prompts.length;\n\n        // JSON format: return raw data for programmatic access (e.g., export scripts)\n        if (format === 'json') {\n          return {\n            observations,\n            sessions,\n            prompts,\n            totalResults,\n            query: query || ''\n          };\n        }\n\n        if (totalResults === 0) {\n          if (chromaFailed) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `\u26a0\ufe0f  Vector search failed - semantic search unavailable.\\n\\nTo enable semantic search:\\n1. Install uv: https://docs.astral.sh/uv/getting-started/installation/\\n2. Restart the worker: npm run worker:restart\\n\\nNote: You can still use filter-only searches (date ranges, types, files) without a query term.`\n              }]\n            };\n          }\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No results found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Combine all results with timestamps for unified sorting\n        interface CombinedResult {\n          type: 'observation' | 'session' | 'prompt';\n          data: any;\n          epoch: number;\n          created_at: string;\n        }\n\n        const allResults: CombinedResult[] = [\n          ...observations.map(obs => ({\n            type: 'observation' as const,\n            data: obs,\n            epoch: obs.created_at_epoch,\n            created_at: obs.created_at\n          })),\n          ...sessions.map(sess => ({\n            type: 'session' as const,\n            data: sess,\n            epoch: sess.created_at_epoch,\n            created_at: sess.created_at\n          })),\n          ...prompts.map(prompt => ({\n            type: 'prompt' as const,\n            data: prompt,\n            epoch: prompt.created_at_epoch,\n            created_at: prompt.created_at\n          }))\n        ];\n\n        // Sort by date\n        if (options.orderBy === 'date_desc') {\n          allResults.sort((a, b) => b.epoch - a.epoch);\n        } else if (options.orderBy === 'date_asc') {\n          allResults.sort((a, b) => a.epoch - b.epoch);\n        }\n\n        // Apply limit across all types\n        const limitedResults = allResults.slice(0, options.limit || 20);\n\n        // Group by date, then by file within each day\n        const cwd = process.cwd();\n        const resultsByDate = groupByDate(limitedResults, item => item.created_at);\n\n        // Build output with date/file grouping\n        const lines: string[] = [];\n        lines.push(`Found ${totalResults} result(s) matching \"${query}\" (${observations.length} obs, ${sessions.length} sessions, ${prompts.length} prompts)`);\n        lines.push('');\n\n        for (const [day, dayResults] of resultsByDate) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          // Group by file within this day\n          const resultsByFile = new Map<string, CombinedResult[]>();\n          for (const result of dayResults) {\n            let file = 'General';\n            if (result.type === 'observation') {\n              file = extractFirstFile(result.data.files_modified, cwd);\n            }\n            if (!resultsByFile.has(file)) {\n              resultsByFile.set(file, []);\n            }\n            resultsByFile.get(file)!.push(result);\n          }\n\n          // Render each file section\n          for (const [file, fileResults] of resultsByFile) {\n            lines.push(`**${file}**`);\n            lines.push(this.formatter.formatSearchTableHeader());\n\n            let lastTime = '';\n            for (const result of fileResults) {\n              if (result.type === 'observation') {\n                const formatted = this.formatter.formatObservationSearchRow(result.data as ObservationSearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              } else if (result.type === 'session') {\n                const formatted = this.formatter.formatSessionSearchRow(result.data as SessionSummarySearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              } else {\n                const formatted = this.formatter.formatUserPromptSearchRow(result.data as UserPromptSearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              }\n            }\n\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: timeline\n   */\n  async timeline(args: any): Promise<any> {\n      try {\n        const { anchor, query, depth_before = 10, depth_after = 10, project } = args;\n        const cwd = process.cwd();\n\n        // Validate: must provide either anchor or query, not both\n        if (!anchor && !query) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Error: Must provide either \"anchor\" or \"query\" parameter'\n            }],\n            isError: true\n          };\n        }\n\n        if (anchor && query) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Error: Cannot provide both \"anchor\" and \"query\" parameters. Use one or the other.'\n            }],\n            isError: true\n          };\n        }\n\n        let anchorId: string | number;\n        let anchorEpoch: number;\n        let timelineData: any;\n\n        // MODE 1: Query-based timeline\n        if (query) {\n          // Step 1: Search for observations\n          let results: ObservationSearchResult[] = [];\n\n          if (this.chromaSync) {\n            try {\n              logger.debug('SEARCH', 'Using hybrid semantic search for timeline query', {});\n              const chromaResults = await this.queryChroma(query, 100);\n              logger.debug('SEARCH', 'Chroma returned semantic matches for timeline', { matchCount: chromaResults?.ids?.length ?? 0 });\n\n              if (chromaResults?.ids && chromaResults.ids.length > 0) {\n                const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n                const recentIds = chromaResults.ids.filter((_id, idx) => {\n                  const meta = chromaResults.metadatas[idx];\n                  return meta && meta.created_at_epoch > ninetyDaysAgo;\n                });\n\n                if (recentIds.length > 0) {\n                  results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit: 1 });\n                }\n              }\n            } catch (chromaError: any) {\n              logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n            }\n          }\n\n          if (results.length === 0) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `No observations found matching \"${query}\". Try a different search query.`\n              }]\n            };\n          }\n\n          // Use top result as anchor\n          const topResult = results[0];\n          anchorId = topResult.id;\n          anchorEpoch = topResult.created_at_epoch;\n          logger.debug('SEARCH', 'Query mode: Using observation as timeline anchor', { observationId: topResult.id });\n          timelineData = this.sessionStore.getTimelineAroundObservation(topResult.id, topResult.created_at_epoch, depth_before, depth_after, project);\n        }\n        // MODE 2: Anchor-based timeline\n        else if (typeof anchor === 'number') {\n          // Observation ID\n          const obs = this.sessionStore.getObservationById(anchor);\n          if (!obs) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Observation #${anchor} not found`\n              }],\n              isError: true\n            };\n          }\n          anchorId = anchor;\n          anchorEpoch = obs.created_at_epoch;\n          timelineData = this.sessionStore.getTimelineAroundObservation(anchor, anchorEpoch, depth_before, depth_after, project);\n        } else if (typeof anchor === 'string') {\n          // Session ID or ISO timestamp\n          if (anchor.startsWith('S') || anchor.startsWith('#S')) {\n            const sessionId = anchor.replace(/^#?S/, '');\n            const sessionNum = parseInt(sessionId, 10);\n            const sessions = this.sessionStore.getSessionSummariesByIds([sessionNum]);\n            if (sessions.length === 0) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Session #${sessionNum} not found`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = sessions[0].created_at_epoch;\n            anchorId = `S${sessionNum}`;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          } else {\n            // ISO timestamp\n            const date = new Date(anchor);\n            if (isNaN(date.getTime())) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Invalid timestamp: ${anchor}`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = date.getTime();\n            anchorId = anchor;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          }\n        } else {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Invalid anchor: must be observation ID (number), session ID (e.g., \"S123\"), or ISO timestamp'\n            }],\n            isError: true\n          };\n        }\n\n        // Combine, sort, and filter timeline items\n        const items: TimelineItem[] = [\n          ...(timelineData.observations || []).map((obs: any) => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n          ...(timelineData.sessions || []).map((sess: any) => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n          ...(timelineData.prompts || []).map((prompt: any) => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n        ];\n        items.sort((a, b) => a.epoch - b.epoch);\n        const filteredItems = this.timelineService.filterByDepth(items, anchorId, anchorEpoch, depth_before, depth_after);\n\n        if (!filteredItems || filteredItems.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: query\n                ? `Found observation matching \"${query}\", but no timeline context available (${depth_before} records before, ${depth_after} records after).`\n                : `No context found around anchor (${depth_before} records before, ${depth_after} records after)`\n            }]\n          };\n        }\n\n        // Format results\n        const lines: string[] = [];\n\n        // Header\n        if (query) {\n          const anchorObs = filteredItems.find(item => item.type === 'observation' && item.data.id === anchorId);\n          const anchorTitle = anchorObs && anchorObs.type === 'observation' ? ((anchorObs.data as ObservationSearchResult).title || 'Untitled') : 'Unknown';\n          lines.push(`# Timeline for query: \"${query}\"`);\n          lines.push(`**Anchor:** Observation #${anchorId} - ${anchorTitle}`);\n        } else {\n          lines.push(`# Timeline around anchor: ${anchorId}`);\n        }\n\n        lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n        lines.push('');\n\n\n        // Group by day\n        const dayMap = new Map<string, TimelineItem[]>();\n        for (const item of filteredItems) {\n          const day = formatDate(item.epoch);\n          if (!dayMap.has(day)) {\n            dayMap.set(day, []);\n          }\n          dayMap.get(day)!.push(item);\n        }\n\n        // Sort days chronologically\n        const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n          const aDate = new Date(a[0]).getTime();\n          const bDate = new Date(b[0]).getTime();\n          return aDate - bDate;\n        });\n\n        // Render each day\n        for (const [day, dayItems] of sortedDays) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          let currentFile: string | null = null;\n          let lastTime = '';\n          let tableOpen = false;\n\n          for (const item of dayItems) {\n            const isAnchor = (\n              (typeof anchorId === 'number' && item.type === 'observation' && item.data.id === anchorId) ||\n              (typeof anchorId === 'string' && anchorId.startsWith('S') && item.type === 'session' && `S${item.data.id}` === anchorId)\n            );\n\n            if (item.type === 'session') {\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              const sess = item.data as SessionSummarySearchResult;\n              const title = sess.request || 'Session summary';\n              const marker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n\n              lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})${marker}`);\n              lines.push('');\n            } else if (item.type === 'prompt') {\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              const prompt = item.data as UserPromptSearchResult;\n              const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n              lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n              lines.push(`> ${truncated}`);\n              lines.push('');\n            } else if (item.type === 'observation') {\n              const obs = item.data as ObservationSearchResult;\n              const file = extractFirstFile(obs.files_modified, cwd);\n\n              if (file !== currentFile) {\n                if (tableOpen) {\n                  lines.push('');\n                }\n\n                lines.push(`**${file}**`);\n                lines.push(`| ID | Time | T | Title | Tokens |`);\n                lines.push(`|----|------|---|-------|--------|`);\n\n                currentFile = file;\n                tableOpen = true;\n                lastTime = '';\n              }\n\n              const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n              const time = formatTime(item.epoch);\n              const title = obs.title || 'Untitled';\n              const tokens = estimateTokens(obs.narrative);\n\n              const showTime = time !== lastTime;\n              const timeDisplay = showTime ? time : '\u2033';\n              lastTime = time;\n\n              const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n              lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n            }\n          }\n\n          if (tableOpen) {\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: decisions\n   */\n  async decisions(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for decision-type observations\n        if (this.chromaSync) {\n          try {\n            if (query) {\n              // Semantic search filtered to decision type\n              logger.debug('SEARCH', 'Using Chroma semantic search with type=decision filter', {});\n              const chromaResults = await this.queryChroma(query, Math.min((filters.limit || 20) * 2, 100), { type: 'decision' });\n              const obsIds = chromaResults.ids;\n\n              if (obsIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(obsIds, { ...filters, type: 'decision' });\n                // Preserve Chroma ranking order\n                results.sort((a, b) => obsIds.indexOf(a.id) - obsIds.indexOf(b.id));\n              }\n            } else {\n              // No query: get all decisions, rank by \"decision\" keyword\n              logger.debug('SEARCH', 'Using metadata-first + semantic ranking for decisions', {});\n              const metadataResults = this.sessionSearch.findByType('decision', filters);\n\n              if (metadataResults.length > 0) {\n                const ids = metadataResults.map(obs => obs.id);\n                const chromaResults = await this.queryChroma('decision', Math.min(ids.length, 100));\n\n                const rankedIds: number[] = [];\n                for (const chromaId of chromaResults.ids) {\n                  if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                    rankedIds.push(chromaId);\n                  }\n                }\n\n                if (rankedIds.length > 0) {\n                  results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                  results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n                }\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma search failed, using SQLite fallback', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          results = this.sessionSearch.findByType('decision', filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No decision observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} decision(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: changes\n   */\n  async changes(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for change-type observations and change-related concepts\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid search for change-related observations', {});\n\n            // Get all observations with type=\"change\" or concepts containing change\n            const typeResults = this.sessionSearch.findByType('change', filters);\n            const conceptChangeResults = this.sessionSearch.findByConcept('change', filters);\n            const conceptWhatChangedResults = this.sessionSearch.findByConcept('what-changed', filters);\n\n            // Combine and deduplicate\n            const allIds = new Set<number>();\n            [...typeResults, ...conceptChangeResults, ...conceptWhatChangedResults].forEach(obs => allIds.add(obs.id));\n\n            if (allIds.size > 0) {\n              const idsArray = Array.from(allIds);\n              const chromaResults = await this.queryChroma('what changed', Math.min(idsArray.length, 100));\n\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (idsArray.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          const typeResults = this.sessionSearch.findByType('change', filters);\n          const conceptResults = this.sessionSearch.findByConcept('change', filters);\n          const whatChangedResults = this.sessionSearch.findByConcept('what-changed', filters);\n\n          const allIds = new Set<number>();\n          [...typeResults, ...conceptResults, ...whatChangedResults].forEach(obs => allIds.add(obs.id));\n\n          results = Array.from(allIds).map(id =>\n            typeResults.find(obs => obs.id === id) ||\n            conceptResults.find(obs => obs.id === id) ||\n            whatChangedResults.find(obs => obs.id === id)\n          ).filter(Boolean) as ObservationSearchResult[];\n\n          results.sort((a, b) => b.created_at_epoch - a.created_at_epoch);\n          results = results.slice(0, filters.limit || 20);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No change-related observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} change-related observation(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: how_it_works\n   */\n  async howItWorks(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for how-it-works concept observations\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for how-it-works', {});\n            const metadataResults = this.sessionSearch.findByConcept('how-it-works', filters);\n\n            if (metadataResults.length > 0) {\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma('how it works architecture', Math.min(ids.length, 100));\n\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          results = this.sessionSearch.findByConcept('how-it-works', filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No \"how it works\" observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} \"how it works\" observation(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: search_observations\n   */\n  async searchObservations(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search (Chroma + SQLite)', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100);\n            logger.debug('SEARCH', 'Chroma returned semantic matches', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated observations from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: search_sessions\n   */\n  async searchSessions(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: SessionSummarySearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for sessions', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100, { doc_type: 'session_summary' });\n            logger.debug('SEARCH', 'Chroma returned semantic matches for sessions', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getSessionSummariesByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated sessions from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No sessions found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} session(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((session, i) => this.formatter.formatSessionIndex(session, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: search_user_prompts\n   */\n  async searchUserPrompts(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: UserPromptSearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for user prompts', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100, { doc_type: 'user_prompt' });\n            logger.debug('SEARCH', 'Chroma returned semantic matches for prompts', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getUserPromptsByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated user prompts from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: query ? `No user prompts found matching \"${query}\"` : 'No user prompts found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} user prompt(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((prompt, i) => this.formatter.formatUserPromptIndex(prompt, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: find_by_concept\n   */\n  async findByConcept(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { concepts: concept, ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for concept search', {});\n\n            // Step 1: SQLite metadata filter (get all IDs with this concept)\n            const metadataResults = this.sessionSearch.findByConcept(concept, filters);\n            logger.debug('SEARCH', 'Found observations with concept', { concept, count: metadataResults.length });\n\n            if (metadataResults.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to concept)\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(concept, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked results by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (results.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only concept search', {});\n          results = this.sessionSearch.findByConcept(concept, filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found with concept \"${concept}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) with concept \"${concept}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: find_by_file\n   */\n  async findByFile(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { files: filePath, ...filters } = normalized;\n        let observations: ObservationSearchResult[] = [];\n        let sessions: SessionSummarySearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search for observations\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for file search', {});\n\n            // Step 1: SQLite metadata filter (get all results with this file)\n            const metadataResults = this.sessionSearch.findByFile(filePath, filters);\n            logger.debug('SEARCH', 'Found results for file', { file: filePath, observations: metadataResults.observations.length, sessions: metadataResults.sessions.length });\n\n            // Sessions: Keep as-is (already summarized, no semantic ranking needed)\n            sessions = metadataResults.sessions;\n\n            // Observations: Apply semantic ranking\n            if (metadataResults.observations.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to file path)\n              const ids = metadataResults.observations.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(filePath, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked observations by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                observations = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                observations.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (observations.length === 0 && sessions.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only file search', {});\n          const results = this.sessionSearch.findByFile(filePath, filters);\n          observations = results.observations;\n          sessions = results.sessions;\n        }\n\n        const totalResults = observations.length + sessions.length;\n\n        if (totalResults === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No results found for file \"${filePath}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${totalResults} result(s) for file \"${filePath}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults: string[] = [];\n\n        // Add observations\n        observations.forEach((obs, i) => {\n          formattedResults.push(this.formatter.formatObservationIndex(obs, i));\n        });\n\n        // Add sessions\n        sessions.forEach((session, i) => {\n          formattedResults.push(this.formatter.formatSessionIndex(session, i + observations.length));\n        });\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: find_by_type\n   */\n  async findByType(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { type, ...filters } = normalized;\n        const typeStr = Array.isArray(type) ? type.join(', ') : type;\n        let results: ObservationSearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for type search', {});\n\n            // Step 1: SQLite metadata filter (get all IDs with this type)\n            const metadataResults = this.sessionSearch.findByType(type, filters);\n            logger.debug('SEARCH', 'Found observations with type', { type: typeStr, count: metadataResults.length });\n\n            if (metadataResults.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to type)\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(typeStr, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked results by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (results.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only type search', {});\n          results = this.sessionSearch.findByType(type, filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found with type \"${typeStr}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) with type \"${typeStr}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: get_recent_context\n   */\n  async getRecentContext(args: any): Promise<any> {\n      try {\n        const project = args.project || basename(process.cwd());\n        const limit = args.limit || 3;\n\n        const sessions = this.sessionStore.getRecentSessionsWithStatus(project, limit);\n\n        if (sessions.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `# Recent Session Context\\n\\nNo previous sessions found for project \"${project}\".`\n            }]\n          };\n        }\n\n        const lines: string[] = [];\n        lines.push('# Recent Session Context');\n        lines.push('');\n        lines.push(`Showing last ${sessions.length} session(s) for **${project}**:`);\n        lines.push('');\n\n        for (const session of sessions) {\n          if (!session.sdk_session_id) continue;\n\n          lines.push('---');\n          lines.push('');\n\n          if (session.has_summary) {\n            const summary = this.sessionStore.getSummaryForSession(session.sdk_session_id);\n            if (summary) {\n              const promptLabel = summary.prompt_number ? ` (Prompt #${summary.prompt_number})` : '';\n              lines.push(`**Summary${promptLabel}**`);\n              lines.push('');\n\n              if (summary.request) lines.push(`**Request:** ${summary.request}`);\n              if (summary.completed) lines.push(`**Completed:** ${summary.completed}`);\n              if (summary.learned) lines.push(`**Learned:** ${summary.learned}`);\n              if (summary.next_steps) lines.push(`**Next Steps:** ${summary.next_steps}`);\n\n              // Handle files_read\n              if (summary.files_read) {\n                try {\n                  const filesRead = JSON.parse(summary.files_read);\n                  if (Array.isArray(filesRead) && filesRead.length > 0) {\n                    lines.push(`**Files Read:** ${filesRead.join(', ')}`);\n                  }\n                } catch {\n                  if (summary.files_read.trim()) {\n                    lines.push(`**Files Read:** ${summary.files_read}`);\n                  }\n                }\n              }\n\n              // Handle files_edited\n              if (summary.files_edited) {\n                try {\n                  const filesEdited = JSON.parse(summary.files_edited);\n                  if (Array.isArray(filesEdited) && filesEdited.length > 0) {\n                    lines.push(`**Files Edited:** ${filesEdited.join(', ')}`);\n                  }\n                } catch {\n                  if (summary.files_edited.trim()) {\n                    lines.push(`**Files Edited:** ${summary.files_edited}`);\n                  }\n                }\n              }\n\n              const date = new Date(summary.created_at).toLocaleString();\n              lines.push(`**Date:** ${date}`);\n            }\n          } else if (session.status === 'active') {\n            lines.push('**In Progress**');\n            lines.push('');\n\n            if (session.user_prompt) {\n              lines.push(`**Request:** ${session.user_prompt}`);\n            }\n\n            const observations = this.sessionStore.getObservationsForSession(session.sdk_session_id);\n            if (observations.length > 0) {\n              lines.push('');\n              lines.push(`**Observations (${observations.length}):**`);\n              for (const obs of observations) {\n                lines.push(`- ${obs.title}`);\n              }\n            } else {\n              lines.push('');\n              lines.push('*No observations yet*');\n            }\n\n            lines.push('');\n            lines.push('**Status:** Active - summary pending');\n\n            const date = new Date(session.started_at).toLocaleString();\n            lines.push(`**Date:** ${date}`);\n          } else {\n            lines.push(`**${session.status.charAt(0).toUpperCase() + session.status.slice(1)}**`);\n            lines.push('');\n\n            if (session.user_prompt) {\n              lines.push(`**Request:** ${session.user_prompt}`);\n            }\n\n            lines.push('');\n            lines.push(`**Status:** ${session.status} - no summary available`);\n\n            const date = new Date(session.started_at).toLocaleString();\n            lines.push(`**Date:** ${date}`);\n          }\n\n          lines.push('');\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Failed to get recent context: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: get_context_timeline\n   */\n  async getContextTimeline(args: any): Promise<any> {\n      try {\n        const { anchor, depth_before = 10, depth_after = 10, project } = args;\n        const cwd = process.cwd();\n        let anchorEpoch: number;\n        let anchorId: string | number = anchor;\n\n        // Resolve anchor and get timeline data\n        let timelineData;\n        if (typeof anchor === 'number') {\n          // Observation ID - use ID-based boundary detection\n          const obs = this.sessionStore.getObservationById(anchor);\n          if (!obs) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Observation #${anchor} not found`\n              }],\n              isError: true\n            };\n          }\n          anchorEpoch = obs.created_at_epoch;\n          timelineData = this.sessionStore.getTimelineAroundObservation(anchor, anchorEpoch, depth_before, depth_after, project);\n        } else if (typeof anchor === 'string') {\n          // Session ID or ISO timestamp\n          if (anchor.startsWith('S') || anchor.startsWith('#S')) {\n            const sessionId = anchor.replace(/^#?S/, '');\n            const sessionNum = parseInt(sessionId, 10);\n            const sessions = this.sessionStore.getSessionSummariesByIds([sessionNum]);\n            if (sessions.length === 0) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Session #${sessionNum} not found`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = sessions[0].created_at_epoch;\n            anchorId = `S${sessionNum}`;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          } else {\n            // ISO timestamp\n            const date = new Date(anchor);\n            if (isNaN(date.getTime())) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Invalid timestamp: ${anchor}`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = date.getTime(); // Keep as milliseconds\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          }\n        } else {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Invalid anchor: must be observation ID (number), session ID (e.g., \"S123\"), or ISO timestamp'\n            }],\n            isError: true\n          };\n        }\n\n        // Combine, sort, and filter timeline items\n        const items: TimelineItem[] = [\n          ...timelineData.observations.map(obs => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n          ...timelineData.sessions.map(sess => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n          ...timelineData.prompts.map(prompt => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n        ];\n        items.sort((a, b) => a.epoch - b.epoch);\n        const filteredItems = this.timelineService.filterByDepth(items, anchorId, anchorEpoch, depth_before, depth_after);\n\n        if (!filteredItems || filteredItems.length === 0) {\n          const anchorDate = new Date(anchorEpoch).toLocaleString();\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No context found around ${anchorDate} (${depth_before} records before, ${depth_after} records after)`\n            }]\n          };\n        }\n\n        // Format results matching context-hook.ts exactly\n        const lines: string[] = [];\n\n        // Header\n        lines.push(`# Timeline around anchor: ${anchorId}`);\n        lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n        lines.push('');\n\n\n        // Group by day\n        const dayMap = new Map<string, TimelineItem[]>();\n        for (const item of filteredItems) {\n          const day = formatDate(item.epoch);\n          if (!dayMap.has(day)) {\n            dayMap.set(day, []);\n          }\n          dayMap.get(day)!.push(item);\n        }\n\n        // Sort days chronologically\n        const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n          const aDate = new Date(a[0]).getTime();\n          const bDate = new Date(b[0]).getTime();\n          return aDate - bDate;\n        });\n\n        // Render each day\n        for (const [day, dayItems] of sortedDays) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          let currentFile: string | null = null;\n          let lastTime = '';\n          let tableOpen = false;\n\n          for (const item of dayItems) {\n            const isAnchor = (\n              (typeof anchorId === 'number' && item.type === 'observation' && item.data.id === anchorId) ||\n              (typeof anchorId === 'string' && anchorId.startsWith('S') && item.type === 'session' && `S${item.data.id}` === anchorId)\n            );\n\n            if (item.type === 'session') {\n              // Close any open table\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              // Render session\n              const sess = item.data as SessionSummarySearchResult;\n              const title = sess.request || 'Session summary';\n              const marker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n\n              lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})${marker}`);\n              lines.push('');\n            } else if (item.type === 'prompt') {\n              // Close any open table\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              // Render prompt\n              const prompt = item.data as UserPromptSearchResult;\n              const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n              lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n              lines.push(`> ${truncated}`);\n              lines.push('');\n            } else if (item.type === 'observation') {\n              // Render observation in table\n              const obs = item.data as ObservationSearchResult;\n              const file = extractFirstFile(obs.files_modified, cwd);\n\n              // Check if we need a new file section\n              if (file !== currentFile) {\n                // Close previous table\n                if (tableOpen) {\n                  lines.push('');\n                }\n\n                // File header\n                lines.push(`**${file}**`);\n                lines.push(`| ID | Time | T | Title | Tokens |`);\n                lines.push(`|----|------|---|-------|--------|`);\n\n                currentFile = file;\n                tableOpen = true;\n                lastTime = '';\n              }\n\n              // Map observation type to emoji\n              const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n              const time = formatTime(item.epoch);\n              const title = obs.title || 'Untitled';\n              const tokens = estimateTokens(obs.narrative);\n\n              const showTime = time !== lastTime;\n              const timeDisplay = showTime ? time : '\u2033';\n              lastTime = time;\n\n              const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n              lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n            }\n          }\n\n          // Close final table if open\n          if (tableOpen) {\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n\n  /**\n   * Tool handler: get_timeline_by_query\n   */\n  async getTimelineByQuery(args: any): Promise<any> {\n      try {\n        const { query, mode = 'auto', depth_before = 10, depth_after = 10, limit = 5, project } = args;\n        const cwd = process.cwd();\n\n        // Step 1: Search for observations\n        let results: ObservationSearchResult[] = [];\n\n        // Use hybrid search if available\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for timeline query', {});\n            const chromaResults = await this.queryChroma(query, 100);\n            logger.debug('SEARCH', 'Chroma returned semantic matches for timeline', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              if (recentIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit: mode === 'auto' ? 1 : limit });\n                logger.debug('SEARCH', 'Hydrated observations from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found matching \"${query}\". Try a different search query.`\n            }]\n          };\n        }\n\n        // Step 2: Handle based on mode\n        if (mode === 'interactive') {\n          // Return formatted index of top results for LLM to choose from\n          const lines: string[] = [];\n          lines.push(`# Timeline Anchor Search Results`);\n          lines.push('');\n          lines.push(`Found ${results.length} observation(s) matching \"${query}\"`);\n          lines.push('');\n          lines.push(`To get timeline context around any of these observations, use the \\`get_context_timeline\\` tool with the observation ID as the anchor.`);\n          lines.push('');\n          lines.push(`**Top ${results.length} matches:**`);\n          lines.push('');\n\n          for (let i = 0; i < results.length; i++) {\n            const obs = results[i];\n            const title = obs.title || `Observation #${obs.id}`;\n            const date = new Date(obs.created_at_epoch).toLocaleString();\n            const type = obs.type ? `[${obs.type}]` : '';\n\n            lines.push(`${i + 1}. **${type} ${title}**`);\n            lines.push(`   - ID: ${obs.id}`);\n            lines.push(`   - Date: ${date}`);\n            if (obs.subtitle) {\n              lines.push(`   - ${obs.subtitle}`);\n            }\n            lines.push('');\n          }\n\n          return {\n            content: [{\n              type: 'text' as const,\n              text: lines.join('\\n')\n            }]\n          };\n        } else {\n          // Auto mode: Use top result as timeline anchor\n          const topResult = results[0];\n          logger.debug('SEARCH', 'Auto mode: Using observation as timeline anchor', { observationId: topResult.id });\n\n          // Get timeline around this observation\n          const timelineData = this.sessionStore.getTimelineAroundObservation(\n            topResult.id,\n            topResult.created_at_epoch,\n            depth_before,\n            depth_after,\n            project\n          );\n\n          // Combine, sort, and filter timeline items\n          const items: TimelineItem[] = [\n            ...(timelineData.observations || []).map(obs => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n            ...(timelineData.sessions || []).map(sess => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n            ...(timelineData.prompts || []).map(prompt => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n          ];\n          items.sort((a, b) => a.epoch - b.epoch);\n          const filteredItems = this.timelineService.filterByDepth(items, topResult.id, 0, depth_before, depth_after);\n\n          if (!filteredItems || filteredItems.length === 0) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Found observation #${topResult.id} matching \"${query}\", but no timeline context available (${depth_before} records before, ${depth_after} records after).`\n              }]\n            };\n          }\n\n          // Format timeline (reused from get_context_timeline)\n          const lines: string[] = [];\n\n          // Header\n          lines.push(`# Timeline for query: \"${query}\"`);\n          lines.push(`**Anchor:** Observation #${topResult.id} - ${topResult.title || 'Untitled'}`);\n          lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n          lines.push('');\n\n\n          // Group by day\n          const dayMap = new Map<string, TimelineItem[]>();\n          for (const item of filteredItems) {\n            const day = formatDate(item.epoch);\n            if (!dayMap.has(day)) {\n              dayMap.set(day, []);\n            }\n            dayMap.get(day)!.push(item);\n          }\n\n          // Sort days chronologically\n          const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n            const aDate = new Date(a[0]).getTime();\n            const bDate = new Date(b[0]).getTime();\n            return aDate - bDate;\n          });\n\n          // Render each day\n          for (const [day, dayItems] of sortedDays) {\n            lines.push(`### ${day}`);\n            lines.push('');\n\n            let currentFile: string | null = null;\n            let lastTime = '';\n            let tableOpen = false;\n\n            for (const item of dayItems) {\n              const isAnchor = (item.type === 'observation' && item.data.id === topResult.id);\n\n              if (item.type === 'session') {\n                // Close any open table\n                if (tableOpen) {\n                  lines.push('');\n                  tableOpen = false;\n                  currentFile = null;\n                  lastTime = '';\n                }\n\n                // Render session\n                const sess = item.data as SessionSummarySearchResult;\n                const title = sess.request || 'Session summary';\n\n                lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})`);\n                lines.push('');\n              } else if (item.type === 'prompt') {\n                // Close any open table\n                if (tableOpen) {\n                  lines.push('');\n                  tableOpen = false;\n                  currentFile = null;\n                  lastTime = '';\n                }\n\n                // Render prompt\n                const prompt = item.data as UserPromptSearchResult;\n                const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n                lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n                lines.push(`> ${truncated}`);\n                lines.push('');\n              } else if (item.type === 'observation') {\n                // Render observation in table\n                const obs = item.data as ObservationSearchResult;\n                const file = extractFirstFile(obs.files_modified, cwd);\n\n                // Check if we need a new file section\n                if (file !== currentFile) {\n                  // Close previous table\n                  if (tableOpen) {\n                    lines.push('');\n                  }\n\n                  // File header\n                  lines.push(`**${file}**`);\n                  lines.push(`| ID | Time | T | Title | Tokens |`);\n                  lines.push(`|----|------|---|-------|--------|`);\n\n                  currentFile = file;\n                  tableOpen = true;\n                  lastTime = '';\n                }\n\n                // Map observation type to emoji\n                const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n                const time = formatTime(item.epoch);\n                const title = obs.title || 'Untitled';\n                const tokens = estimateTokens(obs.narrative);\n\n                const showTime = time !== lastTime;\n                const timeDisplay = showTime ? time : '\u2033';\n                lastTime = time;\n\n                const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n                lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n              }\n            }\n\n            // Close final table if open\n            if (tableOpen) {\n              lines.push('');\n            }\n          }\n\n          return {\n            content: [{\n              type: 'text' as const,\n              text: lines.join('\\n')\n            }]\n          };\n        }\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }\n}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_constructor_25": {
      "name": "constructor",
      "type": "method",
      "start_line": 25,
      "end_line": 31,
      "content_hash": "69ff8f3da1b166d1bc87b742f2d73e865cf04cf2",
      "content": "  constructor(\n    private sessionSearch: SessionSearch,\n    private sessionStore: SessionStore,\n    private chromaSync: ChromaSync,\n    private formatter: FormattingService,\n    private timelineService: TimelineService\n  ) {}",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_queryChroma_36": {
      "name": "queryChroma",
      "type": "method",
      "start_line": 36,
      "end_line": 42,
      "content_hash": "5a03a5023bd533f743407038622240de018c669f",
      "content": "  private async queryChroma(\n    query: string,\n    limit: number,\n    whereFilter?: Record<string, any>\n  ): Promise<{ ids: number[]; distances: number[]; metadatas: any[] }> {\n    return await this.chromaSync.queryChroma(query, limit, whereFilter);\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_normalizeParams_48": {
      "name": "normalizeParams",
      "type": "method",
      "start_line": 48,
      "end_line": 82,
      "content_hash": "facc7c6afa9baf445e1c54423a82a9d18f9b3e3b",
      "content": "  private normalizeParams(args: any): any {\n    const normalized: any = { ...args };\n\n    // Parse comma-separated concepts into array\n    if (normalized.concepts && typeof normalized.concepts === 'string') {\n      normalized.concepts = normalized.concepts.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated files into array\n    if (normalized.files && typeof normalized.files === 'string') {\n      normalized.files = normalized.files.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated obs_type into array\n    if (normalized.obs_type && typeof normalized.obs_type === 'string') {\n      normalized.obs_type = normalized.obs_type.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Parse comma-separated type (for filterSchema) into array\n    if (normalized.type && typeof normalized.type === 'string' && normalized.type.includes(',')) {\n      normalized.type = normalized.type.split(',').map((s: string) => s.trim()).filter(Boolean);\n    }\n\n    // Flatten dateStart/dateEnd into dateRange object\n    if (normalized.dateStart || normalized.dateEnd) {\n      normalized.dateRange = {\n        start: normalized.dateStart,\n        end: normalized.dateEnd\n      };\n      delete normalized.dateStart;\n      delete normalized.dateEnd;\n    }\n\n    return normalized;\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_search_87": {
      "name": "search",
      "type": "method",
      "start_line": 87,
      "end_line": 341,
      "content_hash": "62613d33de05c835bad0f46c1bddcf6787a25801",
      "content": "  async search(args: any): Promise<any> {\n      try {\n        // Normalize URL-friendly params to internal format\n        const normalized = this.normalizeParams(args);\n        const { query, type, obs_type, concepts, files, format, ...options } = normalized;\n        let observations: ObservationSearchResult[] = [];\n        let sessions: SessionSummarySearchResult[] = [];\n        let prompts: UserPromptSearchResult[] = [];\n        let chromaFailed = false;\n\n        // Determine which types to query based on type filter\n        const searchObservations = !type || type === 'observations';\n        const searchSessions = !type || type === 'sessions';\n        const searchPrompts = !type || type === 'prompts';\n\n        // PATH 1: FILTER-ONLY (no query text) - Skip Chroma/FTS5, use direct SQLite filtering\n        // This path enables date filtering which Chroma cannot do (requires direct SQLite access)\n        if (!query) {\n          logger.debug('SEARCH', 'Filter-only query (no query text), using direct SQLite filtering', { enablesDateFilters: true });\n          const obsOptions = { ...options, type: obs_type, concepts, files };\n          if (searchObservations) {\n            observations = this.sessionSearch.searchObservations(undefined, obsOptions);\n          }\n          if (searchSessions) {\n            sessions = this.sessionSearch.searchSessions(undefined, options);\n          }\n          if (searchPrompts) {\n            prompts = this.sessionSearch.searchUserPrompts(undefined, options);\n          }\n        }\n        // PATH 2: CHROMA SEMANTIC SEARCH (query text + Chroma available)\n        else if (this.chromaSync) {\n          let chromaSucceeded = false;\n          try {\n            logger.debug('SEARCH', 'Using ChromaDB semantic search', { typeFilter: type || 'all' });\n\n            // Build Chroma where filter for doc_type\n            let whereFilter: Record<string, any> | undefined;\n            if (type === 'observations') {\n              whereFilter = { doc_type: 'observation' };\n            } else if (type === 'sessions') {\n              whereFilter = { doc_type: 'session_summary' };\n            } else if (type === 'prompts') {\n              whereFilter = { doc_type: 'user_prompt' };\n            }\n\n            // Step 1: Chroma semantic search with optional type filter\n            const chromaResults = await this.queryChroma(query, 100, whereFilter);\n            chromaSucceeded = true; // Chroma didn't throw error\n            logger.debug('SEARCH', 'ChromaDB returned semantic matches', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentMetadata = chromaResults.metadatas.map((meta, idx) => ({\n                id: chromaResults.ids[idx],\n                meta,\n                isRecent: meta && meta.created_at_epoch > ninetyDaysAgo\n              })).filter(item => item.isRecent);\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentMetadata.length });\n\n              // Step 3: Categorize IDs by document type\n              const obsIds: number[] = [];\n              const sessionIds: number[] = [];\n              const promptIds: number[] = [];\n\n              for (const item of recentMetadata) {\n                const docType = item.meta?.doc_type;\n                if (docType === 'observation' && searchObservations) {\n                  obsIds.push(item.id);\n                } else if (docType === 'session_summary' && searchSessions) {\n                  sessionIds.push(item.id);\n                } else if (docType === 'user_prompt' && searchPrompts) {\n                  promptIds.push(item.id);\n                }\n              }\n\n              logger.debug('SEARCH', 'Categorized results by type', { observations: obsIds.length, sessions: sessionIds.length, prompts: promptIds.length });\n\n              // Step 4: Hydrate from SQLite with additional filters\n              if (obsIds.length > 0) {\n                // Apply obs_type, concepts, files filters if provided\n                const obsOptions = { ...options, type: obs_type, concepts, files };\n                observations = this.sessionStore.getObservationsByIds(obsIds, obsOptions);\n              }\n              if (sessionIds.length > 0) {\n                sessions = this.sessionStore.getSessionSummariesByIds(sessionIds, { orderBy: 'date_desc', limit: options.limit, project: options.project });\n              }\n              if (promptIds.length > 0) {\n                prompts = this.sessionStore.getUserPromptsByIds(promptIds, { orderBy: 'date_desc', limit: options.limit, project: options.project });\n              }\n\n              logger.debug('SEARCH', 'Hydrated results from SQLite', { observations: observations.length, sessions: sessions.length, prompts: prompts.length });\n            } else {\n              // Chroma returned 0 results - this is the correct answer, don't fall back to FTS5\n              logger.debug('SEARCH', 'ChromaDB found no matches (final result, no FTS5 fallback)', {});\n            }\n          } catch (chromaError: any) {\n            chromaFailed = true;\n            logger.debug('SEARCH', 'ChromaDB failed - semantic search unavailable', { error: chromaError.message });\n            logger.debug('SEARCH', 'Install UVX/Python to enable vector search', { url: 'https://docs.astral.sh/uv/getting-started/installation/' });\n            // Set empty results - will show error message to user\n            observations = [];\n            sessions = [];\n            prompts = [];\n          }\n        }\n        // ChromaDB not initialized - mark as failed to show proper error message\n        else if (query) {\n          chromaFailed = true;\n          logger.debug('SEARCH', 'ChromaDB not initialized - semantic search unavailable', {});\n          logger.debug('SEARCH', 'Install UVX/Python to enable vector search', { url: 'https://docs.astral.sh/uv/getting-started/installation/' });\n          observations = [];\n          sessions = [];\n          prompts = [];\n        }\n\n        const totalResults = observations.length + sessions.length + prompts.length;\n\n        // JSON format: return raw data for programmatic access (e.g., export scripts)\n        if (format === 'json') {\n          return {\n            observations,\n            sessions,\n            prompts,\n            totalResults,\n            query: query || ''\n          };\n        }\n\n        if (totalResults === 0) {\n          if (chromaFailed) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `\u26a0\ufe0f  Vector search failed - semantic search unavailable.\\n\\nTo enable semantic search:\\n1. Install uv: https://docs.astral.sh/uv/getting-started/installation/\\n2. Restart the worker: npm run worker:restart\\n\\nNote: You can still use filter-only searches (date ranges, types, files) without a query term.`\n              }]\n            };\n          }\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No results found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Combine all results with timestamps for unified sorting\n        interface CombinedResult {\n          type: 'observation' | 'session' | 'prompt';\n          data: any;\n          epoch: number;\n          created_at: string;\n        }\n\n        const allResults: CombinedResult[] = [\n          ...observations.map(obs => ({\n            type: 'observation' as const,\n            data: obs,\n            epoch: obs.created_at_epoch,\n            created_at: obs.created_at\n          })),\n          ...sessions.map(sess => ({\n            type: 'session' as const,\n            data: sess,\n            epoch: sess.created_at_epoch,\n            created_at: sess.created_at\n          })),\n          ...prompts.map(prompt => ({\n            type: 'prompt' as const,\n            data: prompt,\n            epoch: prompt.created_at_epoch,\n            created_at: prompt.created_at\n          }))\n        ];\n\n        // Sort by date\n        if (options.orderBy === 'date_desc') {\n          allResults.sort((a, b) => b.epoch - a.epoch);\n        } else if (options.orderBy === 'date_asc') {\n          allResults.sort((a, b) => a.epoch - b.epoch);\n        }\n\n        // Apply limit across all types\n        const limitedResults = allResults.slice(0, options.limit || 20);\n\n        // Group by date, then by file within each day\n        const cwd = process.cwd();\n        const resultsByDate = groupByDate(limitedResults, item => item.created_at);\n\n        // Build output with date/file grouping\n        const lines: string[] = [];\n        lines.push(`Found ${totalResults} result(s) matching \"${query}\" (${observations.length} obs, ${sessions.length} sessions, ${prompts.length} prompts)`);\n        lines.push('');\n\n        for (const [day, dayResults] of resultsByDate) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          // Group by file within this day\n          const resultsByFile = new Map<string, CombinedResult[]>();\n          for (const result of dayResults) {\n            let file = 'General';\n            if (result.type === 'observation') {\n              file = extractFirstFile(result.data.files_modified, cwd);\n            }\n            if (!resultsByFile.has(file)) {\n              resultsByFile.set(file, []);\n            }\n            resultsByFile.get(file)!.push(result);\n          }\n\n          // Render each file section\n          for (const [file, fileResults] of resultsByFile) {\n            lines.push(`**${file}**`);\n            lines.push(this.formatter.formatSearchTableHeader());\n\n            let lastTime = '';\n            for (const result of fileResults) {\n              if (result.type === 'observation') {\n                const formatted = this.formatter.formatObservationSearchRow(result.data as ObservationSearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              } else if (result.type === 'session') {\n                const formatted = this.formatter.formatSessionSearchRow(result.data as SessionSummarySearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              } else {\n                const formatted = this.formatter.formatUserPromptSearchRow(result.data as UserPromptSearchResult, lastTime);\n                lines.push(formatted.row);\n                lastTime = formatted.time;\n              }\n            }\n\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_timeline_346": {
      "name": "timeline",
      "type": "method",
      "start_line": 346,
      "end_line": 629,
      "content_hash": "168cabc0734dd83392215291e0a52f0859cf4c71",
      "content": "  async timeline(args: any): Promise<any> {\n      try {\n        const { anchor, query, depth_before = 10, depth_after = 10, project } = args;\n        const cwd = process.cwd();\n\n        // Validate: must provide either anchor or query, not both\n        if (!anchor && !query) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Error: Must provide either \"anchor\" or \"query\" parameter'\n            }],\n            isError: true\n          };\n        }\n\n        if (anchor && query) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Error: Cannot provide both \"anchor\" and \"query\" parameters. Use one or the other.'\n            }],\n            isError: true\n          };\n        }\n\n        let anchorId: string | number;\n        let anchorEpoch: number;\n        let timelineData: any;\n\n        // MODE 1: Query-based timeline\n        if (query) {\n          // Step 1: Search for observations\n          let results: ObservationSearchResult[] = [];\n\n          if (this.chromaSync) {\n            try {\n              logger.debug('SEARCH', 'Using hybrid semantic search for timeline query', {});\n              const chromaResults = await this.queryChroma(query, 100);\n              logger.debug('SEARCH', 'Chroma returned semantic matches for timeline', { matchCount: chromaResults?.ids?.length ?? 0 });\n\n              if (chromaResults?.ids && chromaResults.ids.length > 0) {\n                const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n                const recentIds = chromaResults.ids.filter((_id, idx) => {\n                  const meta = chromaResults.metadatas[idx];\n                  return meta && meta.created_at_epoch > ninetyDaysAgo;\n                });\n\n                if (recentIds.length > 0) {\n                  results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit: 1 });\n                }\n              }\n            } catch (chromaError: any) {\n              logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n            }\n          }\n\n          if (results.length === 0) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `No observations found matching \"${query}\". Try a different search query.`\n              }]\n            };\n          }\n\n          // Use top result as anchor\n          const topResult = results[0];\n          anchorId = topResult.id;\n          anchorEpoch = topResult.created_at_epoch;\n          logger.debug('SEARCH', 'Query mode: Using observation as timeline anchor', { observationId: topResult.id });\n          timelineData = this.sessionStore.getTimelineAroundObservation(topResult.id, topResult.created_at_epoch, depth_before, depth_after, project);\n        }\n        // MODE 2: Anchor-based timeline\n        else if (typeof anchor === 'number') {\n          // Observation ID\n          const obs = this.sessionStore.getObservationById(anchor);\n          if (!obs) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Observation #${anchor} not found`\n              }],\n              isError: true\n            };\n          }\n          anchorId = anchor;\n          anchorEpoch = obs.created_at_epoch;\n          timelineData = this.sessionStore.getTimelineAroundObservation(anchor, anchorEpoch, depth_before, depth_after, project);\n        } else if (typeof anchor === 'string') {\n          // Session ID or ISO timestamp\n          if (anchor.startsWith('S') || anchor.startsWith('#S')) {\n            const sessionId = anchor.replace(/^#?S/, '');\n            const sessionNum = parseInt(sessionId, 10);\n            const sessions = this.sessionStore.getSessionSummariesByIds([sessionNum]);\n            if (sessions.length === 0) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Session #${sessionNum} not found`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = sessions[0].created_at_epoch;\n            anchorId = `S${sessionNum}`;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          } else {\n            // ISO timestamp\n            const date = new Date(anchor);\n            if (isNaN(date.getTime())) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Invalid timestamp: ${anchor}`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = date.getTime();\n            anchorId = anchor;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          }\n        } else {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Invalid anchor: must be observation ID (number), session ID (e.g., \"S123\"), or ISO timestamp'\n            }],\n            isError: true\n          };\n        }\n\n        // Combine, sort, and filter timeline items\n        const items: TimelineItem[] = [\n          ...(timelineData.observations || []).map((obs: any) => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n          ...(timelineData.sessions || []).map((sess: any) => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n          ...(timelineData.prompts || []).map((prompt: any) => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n        ];\n        items.sort((a, b) => a.epoch - b.epoch);\n        const filteredItems = this.timelineService.filterByDepth(items, anchorId, anchorEpoch, depth_before, depth_after);\n\n        if (!filteredItems || filteredItems.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: query\n                ? `Found observation matching \"${query}\", but no timeline context available (${depth_before} records before, ${depth_after} records after).`\n                : `No context found around anchor (${depth_before} records before, ${depth_after} records after)`\n            }]\n          };\n        }\n\n        // Format results\n        const lines: string[] = [];\n\n        // Header\n        if (query) {\n          const anchorObs = filteredItems.find(item => item.type === 'observation' && item.data.id === anchorId);\n          const anchorTitle = anchorObs && anchorObs.type === 'observation' ? ((anchorObs.data as ObservationSearchResult).title || 'Untitled') : 'Unknown';\n          lines.push(`# Timeline for query: \"${query}\"`);\n          lines.push(`**Anchor:** Observation #${anchorId} - ${anchorTitle}`);\n        } else {\n          lines.push(`# Timeline around anchor: ${anchorId}`);\n        }\n\n        lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n        lines.push('');\n\n\n        // Group by day\n        const dayMap = new Map<string, TimelineItem[]>();\n        for (const item of filteredItems) {\n          const day = formatDate(item.epoch);\n          if (!dayMap.has(day)) {\n            dayMap.set(day, []);\n          }\n          dayMap.get(day)!.push(item);\n        }\n\n        // Sort days chronologically\n        const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n          const aDate = new Date(a[0]).getTime();\n          const bDate = new Date(b[0]).getTime();\n          return aDate - bDate;\n        });\n\n        // Render each day\n        for (const [day, dayItems] of sortedDays) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          let currentFile: string | null = null;\n          let lastTime = '';\n          let tableOpen = false;\n\n          for (const item of dayItems) {\n            const isAnchor = (\n              (typeof anchorId === 'number' && item.type === 'observation' && item.data.id === anchorId) ||\n              (typeof anchorId === 'string' && anchorId.startsWith('S') && item.type === 'session' && `S${item.data.id}` === anchorId)\n            );\n\n            if (item.type === 'session') {\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              const sess = item.data as SessionSummarySearchResult;\n              const title = sess.request || 'Session summary';\n              const marker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n\n              lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})${marker}`);\n              lines.push('');\n            } else if (item.type === 'prompt') {\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              const prompt = item.data as UserPromptSearchResult;\n              const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n              lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n              lines.push(`> ${truncated}`);\n              lines.push('');\n            } else if (item.type === 'observation') {\n              const obs = item.data as ObservationSearchResult;\n              const file = extractFirstFile(obs.files_modified, cwd);\n\n              if (file !== currentFile) {\n                if (tableOpen) {\n                  lines.push('');\n                }\n\n                lines.push(`**${file}**`);\n                lines.push(`| ID | Time | T | Title | Tokens |`);\n                lines.push(`|----|------|---|-------|--------|`);\n\n                currentFile = file;\n                tableOpen = true;\n                lastTime = '';\n              }\n\n              const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n              const time = formatTime(item.epoch);\n              const title = obs.title || 'Untitled';\n              const tokens = estimateTokens(obs.narrative);\n\n              const showTime = time !== lastTime;\n              const timeDisplay = showTime ? time : '\u2033';\n              lastTime = time;\n\n              const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n              lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n            }\n          }\n\n          if (tableOpen) {\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_decisions_634": {
      "name": "decisions",
      "type": "method",
      "start_line": 634,
      "end_line": 713,
      "content_hash": "a12bd5d7ea6f40fd6eceff90c6cc9dde009d6cbb",
      "content": "  async decisions(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for decision-type observations\n        if (this.chromaSync) {\n          try {\n            if (query) {\n              // Semantic search filtered to decision type\n              logger.debug('SEARCH', 'Using Chroma semantic search with type=decision filter', {});\n              const chromaResults = await this.queryChroma(query, Math.min((filters.limit || 20) * 2, 100), { type: 'decision' });\n              const obsIds = chromaResults.ids;\n\n              if (obsIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(obsIds, { ...filters, type: 'decision' });\n                // Preserve Chroma ranking order\n                results.sort((a, b) => obsIds.indexOf(a.id) - obsIds.indexOf(b.id));\n              }\n            } else {\n              // No query: get all decisions, rank by \"decision\" keyword\n              logger.debug('SEARCH', 'Using metadata-first + semantic ranking for decisions', {});\n              const metadataResults = this.sessionSearch.findByType('decision', filters);\n\n              if (metadataResults.length > 0) {\n                const ids = metadataResults.map(obs => obs.id);\n                const chromaResults = await this.queryChroma('decision', Math.min(ids.length, 100));\n\n                const rankedIds: number[] = [];\n                for (const chromaId of chromaResults.ids) {\n                  if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                    rankedIds.push(chromaId);\n                  }\n                }\n\n                if (rankedIds.length > 0) {\n                  results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                  results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n                }\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma search failed, using SQLite fallback', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          results = this.sessionSearch.findByType('decision', filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No decision observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} decision(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_changes_718": {
      "name": "changes",
      "type": "method",
      "start_line": 718,
      "end_line": 805,
      "content_hash": "8a6421ea5326df2fbee24a13f1f7a7252fbfc86d",
      "content": "  async changes(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for change-type observations and change-related concepts\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid search for change-related observations', {});\n\n            // Get all observations with type=\"change\" or concepts containing change\n            const typeResults = this.sessionSearch.findByType('change', filters);\n            const conceptChangeResults = this.sessionSearch.findByConcept('change', filters);\n            const conceptWhatChangedResults = this.sessionSearch.findByConcept('what-changed', filters);\n\n            // Combine and deduplicate\n            const allIds = new Set<number>();\n            [...typeResults, ...conceptChangeResults, ...conceptWhatChangedResults].forEach(obs => allIds.add(obs.id));\n\n            if (allIds.size > 0) {\n              const idsArray = Array.from(allIds);\n              const chromaResults = await this.queryChroma('what changed', Math.min(idsArray.length, 100));\n\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (idsArray.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          const typeResults = this.sessionSearch.findByType('change', filters);\n          const conceptResults = this.sessionSearch.findByConcept('change', filters);\n          const whatChangedResults = this.sessionSearch.findByConcept('what-changed', filters);\n\n          const allIds = new Set<number>();\n          [...typeResults, ...conceptResults, ...whatChangedResults].forEach(obs => allIds.add(obs.id));\n\n          results = Array.from(allIds).map(id =>\n            typeResults.find(obs => obs.id === id) ||\n            conceptResults.find(obs => obs.id === id) ||\n            whatChangedResults.find(obs => obs.id === id)\n          ).filter(Boolean) as ObservationSearchResult[];\n\n          results.sort((a, b) => b.created_at_epoch - a.created_at_epoch);\n          results = results.slice(0, filters.limit || 20);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No change-related observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} change-related observation(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_howItWorks_810": {
      "name": "howItWorks",
      "type": "method",
      "start_line": 810,
      "end_line": 875,
      "content_hash": "c0a59467f2fa68d2fb735c6a70d134c2250506b5",
      "content": "  async howItWorks(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Search for how-it-works concept observations\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for how-it-works', {});\n            const metadataResults = this.sessionSearch.findByConcept('how-it-works', filters);\n\n            if (metadataResults.length > 0) {\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma('how it works architecture', Math.min(ids.length, 100));\n\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          results = this.sessionSearch.findByConcept('how-it-works', filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'No \"how it works\" observations found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} \"how it works\" observation(s)\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchObservations_880": {
      "name": "searchObservations",
      "type": "method",
      "start_line": 880,
      "end_line": 945,
      "content_hash": "52f9e668ae9d2094c0c273ff5374b4a70944d00d",
      "content": "  async searchObservations(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search (Chroma + SQLite)', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100);\n            logger.debug('SEARCH', 'Chroma returned semantic matches', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated observations from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchSessions_950": {
      "name": "searchSessions",
      "type": "method",
      "start_line": 950,
      "end_line": 1015,
      "content_hash": "55c4bd86ada0d6b4dedb8548887bcc8d1c226c4d",
      "content": "  async searchSessions(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: SessionSummarySearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for sessions', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100, { doc_type: 'session_summary' });\n            logger.debug('SEARCH', 'Chroma returned semantic matches for sessions', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getSessionSummariesByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated sessions from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No sessions found matching \"${query}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} session(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((session, i) => this.formatter.formatSessionIndex(session, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_searchUserPrompts_1020": {
      "name": "searchUserPrompts",
      "type": "method",
      "start_line": 1020,
      "end_line": 1085,
      "content_hash": "cb0cd687770517d9f2c8f649255dda1b82c88729",
      "content": "  async searchUserPrompts(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { query, ...options } = normalized;\n        let results: UserPromptSearchResult[] = [];\n\n        // Vector-first search via ChromaDB\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for user prompts', {});\n\n            // Step 1: Chroma semantic search (top 100)\n            const chromaResults = await this.queryChroma(query, 100, { doc_type: 'user_prompt' });\n            logger.debug('SEARCH', 'Chroma returned semantic matches for prompts', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Step 2: Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              // Step 3: Hydrate from SQLite in temporal order\n              if (recentIds.length > 0) {\n                const limit = options.limit || 20;\n                results = this.sessionStore.getUserPromptsByIds(recentIds, { orderBy: 'date_desc', limit });\n                logger.debug('SEARCH', 'Hydrated user prompts from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: query ? `No user prompts found matching \"${query}\"` : 'No user prompts found'\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} user prompt(s) matching \"${query}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((prompt, i) => this.formatter.formatUserPromptIndex(prompt, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByConcept_1090": {
      "name": "findByConcept",
      "type": "method",
      "start_line": 1090,
      "end_line": 1167,
      "content_hash": "b0d0bab81c2f23576cd4a94aba402a378ba7189d",
      "content": "  async findByConcept(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { concepts: concept, ...filters } = normalized;\n        let results: ObservationSearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for concept search', {});\n\n            // Step 1: SQLite metadata filter (get all IDs with this concept)\n            const metadataResults = this.sessionSearch.findByConcept(concept, filters);\n            logger.debug('SEARCH', 'Found observations with concept', { concept, count: metadataResults.length });\n\n            if (metadataResults.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to concept)\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(concept, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked results by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (results.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only concept search', {});\n          results = this.sessionSearch.findByConcept(concept, filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found with concept \"${concept}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) with concept \"${concept}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByFile_1172": {
      "name": "findByFile",
      "type": "method",
      "start_line": 1172,
      "end_line": 1268,
      "content_hash": "ae81b7137eaa95f7065e31dbb4ccc7e225adfcb8",
      "content": "  async findByFile(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { files: filePath, ...filters } = normalized;\n        let observations: ObservationSearchResult[] = [];\n        let sessions: SessionSummarySearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search for observations\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for file search', {});\n\n            // Step 1: SQLite metadata filter (get all results with this file)\n            const metadataResults = this.sessionSearch.findByFile(filePath, filters);\n            logger.debug('SEARCH', 'Found results for file', { file: filePath, observations: metadataResults.observations.length, sessions: metadataResults.sessions.length });\n\n            // Sessions: Keep as-is (already summarized, no semantic ranking needed)\n            sessions = metadataResults.sessions;\n\n            // Observations: Apply semantic ranking\n            if (metadataResults.observations.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to file path)\n              const ids = metadataResults.observations.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(filePath, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked observations by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                observations = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                observations.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (observations.length === 0 && sessions.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only file search', {});\n          const results = this.sessionSearch.findByFile(filePath, filters);\n          observations = results.observations;\n          sessions = results.sessions;\n        }\n\n        const totalResults = observations.length + sessions.length;\n\n        if (totalResults === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No results found for file \"${filePath}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${totalResults} result(s) for file \"${filePath}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults: string[] = [];\n\n        // Add observations\n        observations.forEach((obs, i) => {\n          formattedResults.push(this.formatter.formatObservationIndex(obs, i));\n        });\n\n        // Add sessions\n        sessions.forEach((session, i) => {\n          formattedResults.push(this.formatter.formatSessionIndex(session, i + observations.length));\n        });\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_findByType_1273": {
      "name": "findByType",
      "type": "method",
      "start_line": 1273,
      "end_line": 1351,
      "content_hash": "cdf45a345fc46b58f93b5f90ca6ea3f6c6b6fed5",
      "content": "  async findByType(args: any): Promise<any> {\n      try {\n        const normalized = this.normalizeParams(args);\n        const { type, ...filters } = normalized;\n        const typeStr = Array.isArray(type) ? type.join(', ') : type;\n        let results: ObservationSearchResult[] = [];\n\n        // Metadata-first, semantic-enhanced search\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using metadata-first + semantic ranking for type search', {});\n\n            // Step 1: SQLite metadata filter (get all IDs with this type)\n            const metadataResults = this.sessionSearch.findByType(type, filters);\n            logger.debug('SEARCH', 'Found observations with type', { type: typeStr, count: metadataResults.length });\n\n            if (metadataResults.length > 0) {\n              // Step 2: Chroma semantic ranking (rank by relevance to type)\n              const ids = metadataResults.map(obs => obs.id);\n              const chromaResults = await this.queryChroma(typeStr, Math.min(ids.length, 100));\n\n              // Intersect: Keep only IDs that passed metadata filter, in semantic rank order\n              const rankedIds: number[] = [];\n              for (const chromaId of chromaResults.ids) {\n                if (ids.includes(chromaId) && !rankedIds.includes(chromaId)) {\n                  rankedIds.push(chromaId);\n                }\n              }\n\n              logger.debug('SEARCH', 'Chroma ranked results by semantic relevance', { count: rankedIds.length });\n\n              // Step 3: Hydrate in semantic rank order\n              if (rankedIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(rankedIds, { limit: filters.limit || 20 });\n                // Restore semantic ranking order\n                results.sort((a, b) => rankedIds.indexOf(a.id) - rankedIds.indexOf(b.id));\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma ranking failed, using SQLite order', { error: chromaError.message });\n            // Fall through to SQLite fallback\n          }\n        }\n\n        // Fall back to SQLite-only if Chroma unavailable or failed\n        if (results.length === 0) {\n          logger.debug('SEARCH', 'Using SQLite-only type search', {});\n          results = this.sessionSearch.findByType(type, filters);\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found with type \"${typeStr}\"`\n            }]\n          };\n        }\n\n        // Format as table\n        const header = `Found ${results.length} observation(s) with type \"${typeStr}\"\\n\\n${this.formatter.formatTableHeader()}`;\n        const formattedResults = results.map((obs, i) => this.formatter.formatObservationIndex(obs, i));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: header + '\\n' + formattedResults.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Search failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getRecentContext_1356": {
      "name": "getRecentContext",
      "type": "method",
      "start_line": 1356,
      "end_line": 1485,
      "content_hash": "739f0094f7e39b8b8b7906276968adbf2aa2877d",
      "content": "  async getRecentContext(args: any): Promise<any> {\n      try {\n        const project = args.project || basename(process.cwd());\n        const limit = args.limit || 3;\n\n        const sessions = this.sessionStore.getRecentSessionsWithStatus(project, limit);\n\n        if (sessions.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `# Recent Session Context\\n\\nNo previous sessions found for project \"${project}\".`\n            }]\n          };\n        }\n\n        const lines: string[] = [];\n        lines.push('# Recent Session Context');\n        lines.push('');\n        lines.push(`Showing last ${sessions.length} session(s) for **${project}**:`);\n        lines.push('');\n\n        for (const session of sessions) {\n          if (!session.sdk_session_id) continue;\n\n          lines.push('---');\n          lines.push('');\n\n          if (session.has_summary) {\n            const summary = this.sessionStore.getSummaryForSession(session.sdk_session_id);\n            if (summary) {\n              const promptLabel = summary.prompt_number ? ` (Prompt #${summary.prompt_number})` : '';\n              lines.push(`**Summary${promptLabel}**`);\n              lines.push('');\n\n              if (summary.request) lines.push(`**Request:** ${summary.request}`);\n              if (summary.completed) lines.push(`**Completed:** ${summary.completed}`);\n              if (summary.learned) lines.push(`**Learned:** ${summary.learned}`);\n              if (summary.next_steps) lines.push(`**Next Steps:** ${summary.next_steps}`);\n\n              // Handle files_read\n              if (summary.files_read) {\n                try {\n                  const filesRead = JSON.parse(summary.files_read);\n                  if (Array.isArray(filesRead) && filesRead.length > 0) {\n                    lines.push(`**Files Read:** ${filesRead.join(', ')}`);\n                  }\n                } catch {\n                  if (summary.files_read.trim()) {\n                    lines.push(`**Files Read:** ${summary.files_read}`);\n                  }\n                }\n              }\n\n              // Handle files_edited\n              if (summary.files_edited) {\n                try {\n                  const filesEdited = JSON.parse(summary.files_edited);\n                  if (Array.isArray(filesEdited) && filesEdited.length > 0) {\n                    lines.push(`**Files Edited:** ${filesEdited.join(', ')}`);\n                  }\n                } catch {\n                  if (summary.files_edited.trim()) {\n                    lines.push(`**Files Edited:** ${summary.files_edited}`);\n                  }\n                }\n              }\n\n              const date = new Date(summary.created_at).toLocaleString();\n              lines.push(`**Date:** ${date}`);\n            }\n          } else if (session.status === 'active') {\n            lines.push('**In Progress**');\n            lines.push('');\n\n            if (session.user_prompt) {\n              lines.push(`**Request:** ${session.user_prompt}`);\n            }\n\n            const observations = this.sessionStore.getObservationsForSession(session.sdk_session_id);\n            if (observations.length > 0) {\n              lines.push('');\n              lines.push(`**Observations (${observations.length}):**`);\n              for (const obs of observations) {\n                lines.push(`- ${obs.title}`);\n              }\n            } else {\n              lines.push('');\n              lines.push('*No observations yet*');\n            }\n\n            lines.push('');\n            lines.push('**Status:** Active - summary pending');\n\n            const date = new Date(session.started_at).toLocaleString();\n            lines.push(`**Date:** ${date}`);\n          } else {\n            lines.push(`**${session.status.charAt(0).toUpperCase() + session.status.slice(1)}**`);\n            lines.push('');\n\n            if (session.user_prompt) {\n              lines.push(`**Request:** ${session.user_prompt}`);\n            }\n\n            lines.push('');\n            lines.push(`**Status:** ${session.status} - no summary available`);\n\n            const date = new Date(session.started_at).toLocaleString();\n            lines.push(`**Date:** ${date}`);\n          }\n\n          lines.push('');\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Failed to get recent context: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getContextTimeline_1490": {
      "name": "getContextTimeline",
      "type": "method",
      "start_line": 1490,
      "end_line": 1707,
      "content_hash": "253729badf62af68117388964f53cf42b28c1774",
      "content": "  async getContextTimeline(args: any): Promise<any> {\n      try {\n        const { anchor, depth_before = 10, depth_after = 10, project } = args;\n        const cwd = process.cwd();\n        let anchorEpoch: number;\n        let anchorId: string | number = anchor;\n\n        // Resolve anchor and get timeline data\n        let timelineData;\n        if (typeof anchor === 'number') {\n          // Observation ID - use ID-based boundary detection\n          const obs = this.sessionStore.getObservationById(anchor);\n          if (!obs) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Observation #${anchor} not found`\n              }],\n              isError: true\n            };\n          }\n          anchorEpoch = obs.created_at_epoch;\n          timelineData = this.sessionStore.getTimelineAroundObservation(anchor, anchorEpoch, depth_before, depth_after, project);\n        } else if (typeof anchor === 'string') {\n          // Session ID or ISO timestamp\n          if (anchor.startsWith('S') || anchor.startsWith('#S')) {\n            const sessionId = anchor.replace(/^#?S/, '');\n            const sessionNum = parseInt(sessionId, 10);\n            const sessions = this.sessionStore.getSessionSummariesByIds([sessionNum]);\n            if (sessions.length === 0) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Session #${sessionNum} not found`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = sessions[0].created_at_epoch;\n            anchorId = `S${sessionNum}`;\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          } else {\n            // ISO timestamp\n            const date = new Date(anchor);\n            if (isNaN(date.getTime())) {\n              return {\n                content: [{\n                  type: 'text' as const,\n                  text: `Invalid timestamp: ${anchor}`\n                }],\n                isError: true\n              };\n            }\n            anchorEpoch = date.getTime(); // Keep as milliseconds\n            timelineData = this.sessionStore.getTimelineAroundTimestamp(anchorEpoch, depth_before, depth_after, project);\n          }\n        } else {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: 'Invalid anchor: must be observation ID (number), session ID (e.g., \"S123\"), or ISO timestamp'\n            }],\n            isError: true\n          };\n        }\n\n        // Combine, sort, and filter timeline items\n        const items: TimelineItem[] = [\n          ...timelineData.observations.map(obs => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n          ...timelineData.sessions.map(sess => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n          ...timelineData.prompts.map(prompt => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n        ];\n        items.sort((a, b) => a.epoch - b.epoch);\n        const filteredItems = this.timelineService.filterByDepth(items, anchorId, anchorEpoch, depth_before, depth_after);\n\n        if (!filteredItems || filteredItems.length === 0) {\n          const anchorDate = new Date(anchorEpoch).toLocaleString();\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No context found around ${anchorDate} (${depth_before} records before, ${depth_after} records after)`\n            }]\n          };\n        }\n\n        // Format results matching context-hook.ts exactly\n        const lines: string[] = [];\n\n        // Header\n        lines.push(`# Timeline around anchor: ${anchorId}`);\n        lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n        lines.push('');\n\n\n        // Group by day\n        const dayMap = new Map<string, TimelineItem[]>();\n        for (const item of filteredItems) {\n          const day = formatDate(item.epoch);\n          if (!dayMap.has(day)) {\n            dayMap.set(day, []);\n          }\n          dayMap.get(day)!.push(item);\n        }\n\n        // Sort days chronologically\n        const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n          const aDate = new Date(a[0]).getTime();\n          const bDate = new Date(b[0]).getTime();\n          return aDate - bDate;\n        });\n\n        // Render each day\n        for (const [day, dayItems] of sortedDays) {\n          lines.push(`### ${day}`);\n          lines.push('');\n\n          let currentFile: string | null = null;\n          let lastTime = '';\n          let tableOpen = false;\n\n          for (const item of dayItems) {\n            const isAnchor = (\n              (typeof anchorId === 'number' && item.type === 'observation' && item.data.id === anchorId) ||\n              (typeof anchorId === 'string' && anchorId.startsWith('S') && item.type === 'session' && `S${item.data.id}` === anchorId)\n            );\n\n            if (item.type === 'session') {\n              // Close any open table\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              // Render session\n              const sess = item.data as SessionSummarySearchResult;\n              const title = sess.request || 'Session summary';\n              const marker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n\n              lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})${marker}`);\n              lines.push('');\n            } else if (item.type === 'prompt') {\n              // Close any open table\n              if (tableOpen) {\n                lines.push('');\n                tableOpen = false;\n                currentFile = null;\n                lastTime = '';\n              }\n\n              // Render prompt\n              const prompt = item.data as UserPromptSearchResult;\n              const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n              lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n              lines.push(`> ${truncated}`);\n              lines.push('');\n            } else if (item.type === 'observation') {\n              // Render observation in table\n              const obs = item.data as ObservationSearchResult;\n              const file = extractFirstFile(obs.files_modified, cwd);\n\n              // Check if we need a new file section\n              if (file !== currentFile) {\n                // Close previous table\n                if (tableOpen) {\n                  lines.push('');\n                }\n\n                // File header\n                lines.push(`**${file}**`);\n                lines.push(`| ID | Time | T | Title | Tokens |`);\n                lines.push(`|----|------|---|-------|--------|`);\n\n                currentFile = file;\n                tableOpen = true;\n                lastTime = '';\n              }\n\n              // Map observation type to emoji\n              const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n              const time = formatTime(item.epoch);\n              const title = obs.title || 'Untitled';\n              const tokens = estimateTokens(obs.narrative);\n\n              const showTime = time !== lastTime;\n              const timeDisplay = showTime ? time : '\u2033';\n              lastTime = time;\n\n              const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n              lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n            }\n          }\n\n          // Close final table if open\n          if (tableOpen) {\n            lines.push('');\n          }\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: lines.join('\\n')\n          }]\n        };\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    },
    "method_getTimelineByQuery_1712": {
      "name": "getTimelineByQuery",
      "type": "method",
      "start_line": 1712,
      "end_line": 1952,
      "content_hash": "a99cc1a7bc7c287758bebf14ce37cb85d44aeff4",
      "content": "  async getTimelineByQuery(args: any): Promise<any> {\n      try {\n        const { query, mode = 'auto', depth_before = 10, depth_after = 10, limit = 5, project } = args;\n        const cwd = process.cwd();\n\n        // Step 1: Search for observations\n        let results: ObservationSearchResult[] = [];\n\n        // Use hybrid search if available\n        if (this.chromaSync) {\n          try {\n            logger.debug('SEARCH', 'Using hybrid semantic search for timeline query', {});\n            const chromaResults = await this.queryChroma(query, 100);\n            logger.debug('SEARCH', 'Chroma returned semantic matches for timeline', { matchCount: chromaResults.ids.length });\n\n            if (chromaResults.ids.length > 0) {\n              // Filter by recency (90 days)\n              const ninetyDaysAgo = Date.now() - RECENCY_WINDOW_MS;\n              const recentIds = chromaResults.ids.filter((_id, idx) => {\n                const meta = chromaResults.metadatas[idx];\n                return meta && meta.created_at_epoch > ninetyDaysAgo;\n              });\n\n              logger.debug('SEARCH', 'Results within 90-day window', { count: recentIds.length });\n\n              if (recentIds.length > 0) {\n                results = this.sessionStore.getObservationsByIds(recentIds, { orderBy: 'date_desc', limit: mode === 'auto' ? 1 : limit });\n                logger.debug('SEARCH', 'Hydrated observations from SQLite', { count: results.length });\n              }\n            }\n          } catch (chromaError: any) {\n            logger.debug('SEARCH', 'Chroma query failed - no results (FTS5 fallback removed)', { error: chromaError.message });\n          }\n        }\n\n        if (results.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: `No observations found matching \"${query}\". Try a different search query.`\n            }]\n          };\n        }\n\n        // Step 2: Handle based on mode\n        if (mode === 'interactive') {\n          // Return formatted index of top results for LLM to choose from\n          const lines: string[] = [];\n          lines.push(`# Timeline Anchor Search Results`);\n          lines.push('');\n          lines.push(`Found ${results.length} observation(s) matching \"${query}\"`);\n          lines.push('');\n          lines.push(`To get timeline context around any of these observations, use the \\`get_context_timeline\\` tool with the observation ID as the anchor.`);\n          lines.push('');\n          lines.push(`**Top ${results.length} matches:**`);\n          lines.push('');\n\n          for (let i = 0; i < results.length; i++) {\n            const obs = results[i];\n            const title = obs.title || `Observation #${obs.id}`;\n            const date = new Date(obs.created_at_epoch).toLocaleString();\n            const type = obs.type ? `[${obs.type}]` : '';\n\n            lines.push(`${i + 1}. **${type} ${title}**`);\n            lines.push(`   - ID: ${obs.id}`);\n            lines.push(`   - Date: ${date}`);\n            if (obs.subtitle) {\n              lines.push(`   - ${obs.subtitle}`);\n            }\n            lines.push('');\n          }\n\n          return {\n            content: [{\n              type: 'text' as const,\n              text: lines.join('\\n')\n            }]\n          };\n        } else {\n          // Auto mode: Use top result as timeline anchor\n          const topResult = results[0];\n          logger.debug('SEARCH', 'Auto mode: Using observation as timeline anchor', { observationId: topResult.id });\n\n          // Get timeline around this observation\n          const timelineData = this.sessionStore.getTimelineAroundObservation(\n            topResult.id,\n            topResult.created_at_epoch,\n            depth_before,\n            depth_after,\n            project\n          );\n\n          // Combine, sort, and filter timeline items\n          const items: TimelineItem[] = [\n            ...(timelineData.observations || []).map(obs => ({ type: 'observation' as const, data: obs, epoch: obs.created_at_epoch })),\n            ...(timelineData.sessions || []).map(sess => ({ type: 'session' as const, data: sess, epoch: sess.created_at_epoch })),\n            ...(timelineData.prompts || []).map(prompt => ({ type: 'prompt' as const, data: prompt, epoch: prompt.created_at_epoch }))\n          ];\n          items.sort((a, b) => a.epoch - b.epoch);\n          const filteredItems = this.timelineService.filterByDepth(items, topResult.id, 0, depth_before, depth_after);\n\n          if (!filteredItems || filteredItems.length === 0) {\n            return {\n              content: [{\n                type: 'text' as const,\n                text: `Found observation #${topResult.id} matching \"${query}\", but no timeline context available (${depth_before} records before, ${depth_after} records after).`\n              }]\n            };\n          }\n\n          // Format timeline (reused from get_context_timeline)\n          const lines: string[] = [];\n\n          // Header\n          lines.push(`# Timeline for query: \"${query}\"`);\n          lines.push(`**Anchor:** Observation #${topResult.id} - ${topResult.title || 'Untitled'}`);\n          lines.push(`**Window:** ${depth_before} records before \u2192 ${depth_after} records after | **Items:** ${filteredItems?.length ?? 0}`);\n          lines.push('');\n\n\n          // Group by day\n          const dayMap = new Map<string, TimelineItem[]>();\n          for (const item of filteredItems) {\n            const day = formatDate(item.epoch);\n            if (!dayMap.has(day)) {\n              dayMap.set(day, []);\n            }\n            dayMap.get(day)!.push(item);\n          }\n\n          // Sort days chronologically\n          const sortedDays = Array.from(dayMap.entries()).sort((a, b) => {\n            const aDate = new Date(a[0]).getTime();\n            const bDate = new Date(b[0]).getTime();\n            return aDate - bDate;\n          });\n\n          // Render each day\n          for (const [day, dayItems] of sortedDays) {\n            lines.push(`### ${day}`);\n            lines.push('');\n\n            let currentFile: string | null = null;\n            let lastTime = '';\n            let tableOpen = false;\n\n            for (const item of dayItems) {\n              const isAnchor = (item.type === 'observation' && item.data.id === topResult.id);\n\n              if (item.type === 'session') {\n                // Close any open table\n                if (tableOpen) {\n                  lines.push('');\n                  tableOpen = false;\n                  currentFile = null;\n                  lastTime = '';\n                }\n\n                // Render session\n                const sess = item.data as SessionSummarySearchResult;\n                const title = sess.request || 'Session summary';\n\n                lines.push(`**\ud83c\udfaf #S${sess.id}** ${title} (${formatDateTime(item.epoch)})`);\n                lines.push('');\n              } else if (item.type === 'prompt') {\n                // Close any open table\n                if (tableOpen) {\n                  lines.push('');\n                  tableOpen = false;\n                  currentFile = null;\n                  lastTime = '';\n                }\n\n                // Render prompt\n                const prompt = item.data as UserPromptSearchResult;\n                const truncated = prompt.prompt_text.length > 100 ? prompt.prompt_text.substring(0, 100) + '...' : prompt.prompt_text;\n\n                lines.push(`**\ud83d\udcac User Prompt #${prompt.prompt_number}** (${formatDateTime(item.epoch)})`);\n                lines.push(`> ${truncated}`);\n                lines.push('');\n              } else if (item.type === 'observation') {\n                // Render observation in table\n                const obs = item.data as ObservationSearchResult;\n                const file = extractFirstFile(obs.files_modified, cwd);\n\n                // Check if we need a new file section\n                if (file !== currentFile) {\n                  // Close previous table\n                  if (tableOpen) {\n                    lines.push('');\n                  }\n\n                  // File header\n                  lines.push(`**${file}**`);\n                  lines.push(`| ID | Time | T | Title | Tokens |`);\n                  lines.push(`|----|------|---|-------|--------|`);\n\n                  currentFile = file;\n                  tableOpen = true;\n                  lastTime = '';\n                }\n\n                // Map observation type to emoji\n                const icon = ModeManager.getInstance().getTypeIcon(obs.type);\n\n                const time = formatTime(item.epoch);\n                const title = obs.title || 'Untitled';\n                const tokens = estimateTokens(obs.narrative);\n\n                const showTime = time !== lastTime;\n                const timeDisplay = showTime ? time : '\u2033';\n                lastTime = time;\n\n                const anchorMarker = isAnchor ? ' \u2190 **ANCHOR**' : '';\n                lines.push(`| #${obs.id} | ${timeDisplay} | ${icon} | ${title}${anchorMarker} | ~${tokens} |`);\n              }\n            }\n\n            // Close final table if open\n            if (tableOpen) {\n              lines.push('');\n            }\n          }\n\n          return {\n            content: [{\n              type: 'text' as const,\n              text: lines.join('\\n')\n            }]\n          };\n        }\n      } catch (error: any) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `Timeline query failed: ${error.message}`\n          }],\n          isError: true\n        };\n      }\n  }",
      "pseudo": "",
      "tags": [],
      "qdrant_ids": []
    }
  }
}