
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tools: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nexora/cli/internal/agent/tools/bash.go (0.0%)</option>
				
				<option value="file1">github.com/nexora/cli/internal/agent/tools/diagnostics.go (0.0%)</option>
				
				<option value="file2">github.com/nexora/cli/internal/agent/tools/download.go (0.0%)</option>
				
				<option value="file3">github.com/nexora/cli/internal/agent/tools/edit.go (4.7%)</option>
				
				<option value="file4">github.com/nexora/cli/internal/agent/tools/edit_diagnostics.go (22.7%)</option>
				
				<option value="file5">github.com/nexora/cli/internal/agent/tools/error_messages.go (0.0%)</option>
				
				<option value="file6">github.com/nexora/cli/internal/agent/tools/fd_helper.go (38.5%)</option>
				
				<option value="file7">github.com/nexora/cli/internal/agent/tools/fetch.go (0.0%)</option>
				
				<option value="file8">github.com/nexora/cli/internal/agent/tools/fetch_helpers.go (0.0%)</option>
				
				<option value="file9">github.com/nexora/cli/internal/agent/tools/file.go (35.0%)</option>
				
				<option value="file10">github.com/nexora/cli/internal/agent/tools/find.go (0.0%)</option>
				
				<option value="file11">github.com/nexora/cli/internal/agent/tools/fuzzy_match.go (95.1%)</option>
				
				<option value="file12">github.com/nexora/cli/internal/agent/tools/glob.go (55.3%)</option>
				
				<option value="file13">github.com/nexora/cli/internal/agent/tools/grep.go (42.5%)</option>
				
				<option value="file14">github.com/nexora/cli/internal/agent/tools/hooks.go (0.0%)</option>
				
				<option value="file15">github.com/nexora/cli/internal/agent/tools/impact_analysis.go (1.1%)</option>
				
				<option value="file16">github.com/nexora/cli/internal/agent/tools/install_manager.go (0.0%)</option>
				
				<option value="file17">github.com/nexora/cli/internal/agent/tools/job_kill.go (0.0%)</option>
				
				<option value="file18">github.com/nexora/cli/internal/agent/tools/job_output.go (0.0%)</option>
				
				<option value="file19">github.com/nexora/cli/internal/agent/tools/ls.go (0.0%)</option>
				
				<option value="file20">github.com/nexora/cli/internal/agent/tools/mcp-tools.go (0.0%)</option>
				
				<option value="file21">github.com/nexora/cli/internal/agent/tools/multiedit.go (8.8%)</option>
				
				<option value="file22">github.com/nexora/cli/internal/agent/tools/references.go (0.0%)</option>
				
				<option value="file23">github.com/nexora/cli/internal/agent/tools/rg.go (78.3%)</option>
				
				<option value="file24">github.com/nexora/cli/internal/agent/tools/safe.go (50.0%)</option>
				
				<option value="file25">github.com/nexora/cli/internal/agent/tools/search.go (0.0%)</option>
				
				<option value="file26">github.com/nexora/cli/internal/agent/tools/search_indexed.go (13.2%)</option>
				
				<option value="file27">github.com/nexora/cli/internal/agent/tools/self_heal.go (66.1%)</option>
				
				<option value="file28">github.com/nexora/cli/internal/agent/tools/smart_edit.go (0.0%)</option>
				
				<option value="file29">github.com/nexora/cli/internal/agent/tools/sourcegraph.go (0.0%)</option>
				
				<option value="file30">github.com/nexora/cli/internal/agent/tools/tools.go (0.0%)</option>
				
				<option value="file31">github.com/nexora/cli/internal/agent/tools/view.go (0.0%)</option>
				
				<option value="file32">github.com/nexora/cli/internal/agent/tools/web_fetch.go (0.0%)</option>
				
				<option value="file33">github.com/nexora/cli/internal/agent/tools/web_search.go (0.0%)</option>
				
				<option value="file34">github.com/nexora/cli/internal/agent/tools/write.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package tools

import (
        "bytes"
        "cmp"
        "context"
        _ "embed"
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/config"
        "github.com/nexora/cli/internal/permission"
        "github.com/nexora/cli/internal/shell"
)

type BashParams struct {
        Description     string `json:"description" description:"A brief description of what the command does, try to keep it under 30 characters or so"`
        Command         string `json:"command" description:"The command to execute"`
        WorkingDir      string `json:"working_dir,omitempty" description:"The working directory to execute the command in (defaults to current directory)"`
        RunInBackground bool   `json:"run_in_background,omitempty" description:"Set to true (boolean) to run this command in the background. Use job_output to read the output later."`
}

type BashPermissionsParams struct {
        Description     string `json:"description"`
        Command         string `json:"command"`
        WorkingDir      string `json:"working_dir"`
        RunInBackground bool   `json:"run_in_background"`
}

type BashResponseMetadata struct {
        StartTime        int64  `json:"start_time"`
        EndTime          int64  `json:"end_time"`
        Output           string `json:"output"`
        Description      string `json:"description"`
        WorkingDirectory string `json:"working_directory"`
        Background       bool   `json:"background,omitempty"`
        ShellID          string `json:"shell_id,omitempty"`
}

const (
        BashToolName = "bash"

        AutoBackgroundThreshold = 1 * time.Minute // Commands taking longer automatically become background jobs
        MaxOutputLength         = 30000
        BashNoOutput            = "no output"
)

//go:embed bash.tpl
var bashDescriptionTmpl []byte

var bashDescriptionTpl = template.Must(
        template.New("bashDescription").
                Parse(string(bashDescriptionTmpl)),
)

type bashDescriptionData struct {
        BannedCommands  string
        MaxOutputLength int
        Attribution     config.Attribution
        ModelName       string
}

var bannedCommands = []string{}

func bashDescription(attribution *config.Attribution, modelName string) string <span class="cov0" title="0">{
        bannedCommandsStr := strings.Join(bannedCommands, ", ")
        var out bytes.Buffer
        if err := bashDescriptionTpl.Execute(&amp;out, bashDescriptionData{
                BannedCommands:  bannedCommandsStr,
                MaxOutputLength: MaxOutputLength,
                Attribution:     *attribution,
                ModelName:       modelName,
        }); err != nil </span><span class="cov0" title="0">{
                // this should never happen.
                panic("failed to execute bash description template: " + err.Error())</span>
        }
        <span class="cov0" title="0">return out.String()</span>
}

func blockFuncs() []shell.BlockFunc <span class="cov0" title="0">{
        return nil
}</span>

func NewBashTool(permissions permission.Service, workingDir string, attribution *config.Attribution, modelName string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                BashToolName,
                string(bashDescription(attribution, modelName)),
                func(ctx context.Context, params BashParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Command == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("missing command"), nil
                        }</span>

                        // Determine working directory
                        <span class="cov0" title="0">execWorkingDir := cmp.Or(params.WorkingDir, workingDir)

                        isSafeReadOnly := false
                        cmdLower := strings.ToLower(params.Command)

                        for _, safe := range safeCommands </span><span class="cov0" title="0">{
                                if strings.HasPrefix(cmdLower, safe) </span><span class="cov0" title="0">{
                                        if len(cmdLower) == len(safe) || cmdLower[len(safe)] == ' ' || cmdLower[len(safe)] == '-' </span><span class="cov0" title="0">{
                                                isSafeReadOnly = true
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">sessionID := GetSessionFromContext(ctx)
                        if sessionID == "" </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for executing shell command")
                        }</span>
                        <span class="cov0" title="0">if !isSafeReadOnly </span><span class="cov0" title="0">{
                                p := permissions.Request(
                                        permission.CreatePermissionRequest{
                                                SessionID:   sessionID,
                                                Path:        execWorkingDir,
                                                ToolCallID:  call.ID,
                                                ToolName:    BashToolName,
                                                Action:      "execute",
                                                Description: fmt.Sprintf("Execute command: %s", params.Command),
                                                Params:      BashPermissionsParams(params),
                                        },
                                )
                                if !p </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                                }</span>
                        }

                        // If explicitly requested as background, start immediately with detached context
                        <span class="cov0" title="0">if params.RunInBackground </span><span class="cov0" title="0">{
                                startTime := time.Now()
                                bgManager := shell.GetBackgroundShellManager()
                                bgManager.Cleanup()
                                // Use background context so it continues after tool returns
                                bgShell, err := bgManager.Start(context.Background(), execWorkingDir, blockFuncs(), params.Command, params.Description)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, fmt.Errorf("error starting background shell: %w", err)
                                }</span>

                                // Wait a short time to detect fast failures (blocked commands, syntax errors, etc.)
                                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                                stdout, stderr, done, execErr := bgShell.GetOutput()

                                if done </span><span class="cov0" title="0">{
                                        // Command failed or completed very quickly
                                        bgManager.Remove(bgShell.ID)

                                        interrupted := shell.IsInterrupt(execErr)
                                        exitCode := shell.ExitCode(execErr)
                                        if exitCode == 0 &amp;&amp; !interrupted &amp;&amp; execErr != nil </span><span class="cov0" title="0">{
                                                return fantasy.ToolResponse{}, fmt.Errorf("[Job %s] error executing command: %w", bgShell.ID, execErr)
                                        }</span>

                                        <span class="cov0" title="0">stdout = formatOutput(stdout, stderr, execErr)

                                        metadata := BashResponseMetadata{
                                                StartTime:        startTime.UnixMilli(),
                                                EndTime:          time.Now().UnixMilli(),
                                                Output:           stdout,
                                                Description:      params.Description,
                                                Background:       params.RunInBackground,
                                                WorkingDirectory: bgShell.WorkingDir,
                                        }
                                        if stdout == "" </span><span class="cov0" title="0">{
                                                return fantasy.WithResponseMetadata(fantasy.NewTextResponse(BashNoOutput), metadata), nil
                                        }</span>
                                        <span class="cov0" title="0">stdout += fmt.Sprintf("\n\n&lt;cwd&gt;%s&lt;/cwd&gt;", normalizeWorkingDir(bgShell.WorkingDir))
                                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(stdout), metadata), nil</span>
                                }

                                // Still running after fast-failure check - return as background job
                                <span class="cov0" title="0">metadata := BashResponseMetadata{
                                        StartTime:        startTime.UnixMilli(),
                                        EndTime:          time.Now().UnixMilli(),
                                        Description:      params.Description,
                                        WorkingDirectory: bgShell.WorkingDir,
                                        Background:       true,
                                        ShellID:          bgShell.ID,
                                }
                                response := fmt.Sprintf("Background shell started with ID: %s\n\nUse job_output tool to view output or job_kill to terminate.", bgShell.ID)
                                return fantasy.WithResponseMetadata(fantasy.NewTextResponse(response), metadata), nil</span>
                        }

                        // Start synchronous execution with auto-background support
                        <span class="cov0" title="0">startTime := time.Now()

                        // Start with detached context so it can survive if moved to background
                        bgManager := shell.GetBackgroundShellManager()
                        bgManager.Cleanup()
                        bgShell, err := bgManager.Start(context.Background(), execWorkingDir, blockFuncs(), params.Command, params.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error starting shell: %w", err)
                        }</span>

                        // Wait for either completion, auto-background threshold, or context cancellation
                        <span class="cov0" title="0">ticker := time.NewTicker(100 * time.Millisecond)
                        defer ticker.Stop()
                        timeout := time.After(AutoBackgroundThreshold)

                        var stdout, stderr string
                        var done bool
                        var execErr error

                waitLoop:
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        stdout, stderr, done, execErr = bgShell.GetOutput()
                                        if done </span><span class="cov0" title="0">{
                                                break waitLoop</span>
                                        }
                                case &lt;-timeout:<span class="cov0" title="0">
                                        stdout, stderr, done, execErr = bgShell.GetOutput()
                                        break waitLoop</span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        // Incoming context was cancelled before we moved to background
                                        // Kill the shell and return error
                                        bgManager.Kill(bgShell.ID)
                                        return fantasy.ToolResponse{}, ctx.Err()</span>
                                }
                        }

                        <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                                // Command completed within threshold - return synchronously
                                // Remove from background manager since we're returning directly
                                // Don't call Kill() as it cancels the context and corrupts the exit code
                                bgManager.Remove(bgShell.ID)

                                interrupted := shell.IsInterrupt(execErr)
                                exitCode := shell.ExitCode(execErr)
                                if exitCode == 0 &amp;&amp; !interrupted &amp;&amp; execErr != nil </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, fmt.Errorf("[Job %s] error executing command: %w", bgShell.ID, execErr)
                                }</span>

                                <span class="cov0" title="0">stdout = formatOutput(stdout, stderr, execErr)

                                metadata := BashResponseMetadata{
                                        StartTime:        startTime.UnixMilli(),
                                        EndTime:          time.Now().UnixMilli(),
                                        Output:           stdout,
                                        Description:      params.Description,
                                        Background:       params.RunInBackground,
                                        WorkingDirectory: bgShell.WorkingDir,
                                }
                                if stdout == "" </span><span class="cov0" title="0">{
                                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(BashNoOutput), metadata), nil
                                }</span>
                                <span class="cov0" title="0">stdout += fmt.Sprintf("\n\n&lt;cwd&gt;%s&lt;/cwd&gt;", normalizeWorkingDir(bgShell.WorkingDir))
                                return fantasy.WithResponseMetadata(fantasy.NewTextResponse(stdout), metadata), nil</span>
                        }

                        // Still running - keep as background job
                        <span class="cov0" title="0">metadata := BashResponseMetadata{
                                StartTime:        startTime.UnixMilli(),
                                EndTime:          time.Now().UnixMilli(),
                                Description:      params.Description,
                                WorkingDirectory: bgShell.WorkingDir,
                                Background:       true,
                                ShellID:          bgShell.ID,
                        }
                        response := fmt.Sprintf("Command is taking longer than expected and has been moved to background.\n\nBackground shell ID: %s\n\nUse job_output tool to view output or job_kill to terminate.", bgShell.ID)
                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(response), metadata), nil</span>
                })
}

// formatOutput formats the output of a completed command with error handling
func formatOutput(stdout, stderr string, execErr error) string <span class="cov0" title="0">{
        interrupted := shell.IsInterrupt(execErr)
        exitCode := shell.ExitCode(execErr)

        stdout = truncateOutput(stdout)
        stderr = truncateOutput(stderr)

        errorMessage := stderr
        if errorMessage == "" &amp;&amp; execErr != nil </span><span class="cov0" title="0">{
                errorMessage = execErr.Error()
        }</span>

        <span class="cov0" title="0">if interrupted </span><span class="cov0" title="0">{
                if errorMessage != "" </span><span class="cov0" title="0">{
                        errorMessage += "\n"
                }</span>
                <span class="cov0" title="0">errorMessage += "Command was aborted before completion"</span>
        } else<span class="cov0" title="0"> if exitCode != 0 </span><span class="cov0" title="0">{
                if errorMessage != "" </span><span class="cov0" title="0">{
                        errorMessage += "\n"
                }</span>
                <span class="cov0" title="0">errorMessage += fmt.Sprintf("Exit code %d", exitCode)</span>
        }

        <span class="cov0" title="0">hasBothOutputs := stdout != "" &amp;&amp; stderr != ""

        if hasBothOutputs </span><span class="cov0" title="0">{
                stdout += "\n"
        }</span>

        <span class="cov0" title="0">if errorMessage != "" </span><span class="cov0" title="0">{
                stdout += "\n" + errorMessage
        }</span>

        <span class="cov0" title="0">return stdout</span>
}

func truncateOutput(content string) string <span class="cov0" title="0">{
        if len(content) &lt;= MaxOutputLength </span><span class="cov0" title="0">{
                return content
        }</span>

        <span class="cov0" title="0">halfLength := MaxOutputLength / 2
        start := content[:halfLength]
        end := content[len(content)-halfLength:]

        truncatedLinesCount := countLines(content[halfLength : len(content)-halfLength])
        return fmt.Sprintf("%s\n\n... [%d lines truncated] ...\n\n%s", start, truncatedLinesCount, end)</span>
}

func countLines(s string) int <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(strings.Split(s, "\n"))</span>
}

func normalizeWorkingDir(path string) string <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        cwd = "C:"
                }</span>
                <span class="cov0" title="0">path = strings.ReplaceAll(path, filepath.VolumeName(cwd), "")</span>
        }

        <span class="cov0" title="0">return filepath.ToSlash(path)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "sort"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/charmbracelet/x/powernap/pkg/lsp/protocol"
        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/lsp"
)

type DiagnosticsParams struct {
        FilePath string `json:"file_path,omitempty" description:"The path to the file to get diagnostics for (leave w empty for project diagnostics)"`
}

const DiagnosticsToolName = "lsp_diagnostics"

//go:embed diagnostics.md
var diagnosticsDescription []byte

func NewDiagnosticsTool(lspClients *csync.Map[string, *lsp.Client]) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                DiagnosticsToolName,
                string(diagnosticsDescription),
                func(ctx context.Context, params DiagnosticsParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if lspClients.Len() == 0 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("no LSP clients available"), nil
                        }</span>
                        <span class="cov0" title="0">notifyLSPs(ctx, lspClients, params.FilePath)
                        output := getDiagnostics(params.FilePath, lspClients)
                        return fantasy.NewTextResponse(output), nil</span>
                })
}

func notifyLSPs(ctx context.Context, lsps *csync.Map[string, *lsp.Client], filepath string) <span class="cov0" title="0">{
        if filepath == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for client := range lsps.Seq() </span><span class="cov0" title="0">{
                if !client.HandlesFile(filepath) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_ = client.OpenFileOnDemand(ctx, filepath)
                _ = client.NotifyChange(ctx, filepath)
                client.WaitForDiagnostics(ctx, 5*time.Second)</span>
        }
}

func getDiagnostics(filePath string, lsps *csync.Map[string, *lsp.Client]) string <span class="cov0" title="0">{
        fileDiagnostics := []string{}
        projectDiagnostics := []string{}

        for lspName, client := range lsps.Seq2() </span><span class="cov0" title="0">{
                for location, diags := range client.GetDiagnostics() </span><span class="cov0" title="0">{
                        path, err := location.Path()
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to convert diagnostic location URI to path", "uri", location, "error", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">isCurrentFile := path == filePath
                        for _, diag := range diags </span><span class="cov0" title="0">{
                                formattedDiag := formatDiagnostic(path, diag, lspName)
                                if isCurrentFile </span><span class="cov0" title="0">{
                                        fileDiagnostics = append(fileDiagnostics, formattedDiag)
                                }</span> else<span class="cov0" title="0"> {
                                        projectDiagnostics = append(projectDiagnostics, formattedDiag)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">sortDiagnostics(fileDiagnostics)
        sortDiagnostics(projectDiagnostics)

        var output strings.Builder
        writeDiagnostics(&amp;output, "file_diagnostics", fileDiagnostics)
        writeDiagnostics(&amp;output, "project_diagnostics", projectDiagnostics)

        if len(fileDiagnostics) &gt; 0 || len(projectDiagnostics) &gt; 0 </span><span class="cov0" title="0">{
                fileErrors := countSeverity(fileDiagnostics, "Error")
                fileWarnings := countSeverity(fileDiagnostics, "Warn")
                projectErrors := countSeverity(projectDiagnostics, "Error")
                projectWarnings := countSeverity(projectDiagnostics, "Warn")
                output.WriteString("\n&lt;diagnostic_summary&gt;\n")
                fmt.Fprintf(&amp;output, "Current file: %d errors, %d warnings\n", fileErrors, fileWarnings)
                fmt.Fprintf(&amp;output, "Project: %d errors, %d warnings\n", projectErrors, projectWarnings)
                output.WriteString("&lt;/diagnostic_summary&gt;\n")
        }</span>

        <span class="cov0" title="0">out := output.String()
        slog.Debug("Diagnostics", "output", out)
        return out</span>
}

func writeDiagnostics(output *strings.Builder, tag string, in []string) <span class="cov0" title="0">{
        if len(in) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">output.WriteString("\n&lt;" + tag + "&gt;\n")
        if len(in) &gt; 10 </span><span class="cov0" title="0">{
                output.WriteString(strings.Join(in[:10], "\n"))
                fmt.Fprintf(output, "\n... and %d more diagnostics", len(in)-10)
        }</span> else<span class="cov0" title="0"> {
                output.WriteString(strings.Join(in, "\n"))
        }</span>
        <span class="cov0" title="0">output.WriteString("\n&lt;/" + tag + "&gt;\n")</span>
}

func sortDiagnostics(in []string) []string <span class="cov0" title="0">{
        sort.Slice(in, func(i, j int) bool </span><span class="cov0" title="0">{
                iIsError := strings.HasPrefix(in[i], "Error")
                jIsError := strings.HasPrefix(in[j], "Error")
                if iIsError != jIsError </span><span class="cov0" title="0">{
                        return iIsError // Errors come first
                }</span>
                <span class="cov0" title="0">return in[i] &lt; in[j]</span> // Then alphabetically
        })
        <span class="cov0" title="0">return in</span>
}

func formatDiagnostic(pth string, diagnostic protocol.Diagnostic, source string) string <span class="cov0" title="0">{
        severity := "Info"
        switch diagnostic.Severity </span>{
        case protocol.SeverityError:<span class="cov0" title="0">
                severity = "Error"</span>
        case protocol.SeverityWarning:<span class="cov0" title="0">
                severity = "Warn"</span>
        case protocol.SeverityHint:<span class="cov0" title="0">
                severity = "Hint"</span>
        }

        <span class="cov0" title="0">location := fmt.Sprintf("%s:%d:%d", pth, diagnostic.Range.Start.Line+1, diagnostic.Range.Start.Character+1)

        sourceInfo := ""
        if diagnostic.Source != "" </span><span class="cov0" title="0">{
                sourceInfo = diagnostic.Source
        }</span> else<span class="cov0" title="0"> if source != "" </span><span class="cov0" title="0">{
                sourceInfo = source
        }</span>

        <span class="cov0" title="0">codeInfo := ""
        if diagnostic.Code != nil </span><span class="cov0" title="0">{
                codeInfo = fmt.Sprintf("[%v]", diagnostic.Code)
        }</span>

        <span class="cov0" title="0">tagsInfo := ""
        if len(diagnostic.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tags := []string{}
                for _, tag := range diagnostic.Tags </span><span class="cov0" title="0">{
                        switch tag </span>{
                        case protocol.Unnecessary:<span class="cov0" title="0">
                                tags = append(tags, "unnecessary")</span>
                        case protocol.Deprecated:<span class="cov0" title="0">
                                tags = append(tags, "deprecated")</span>
                        }
                }
                <span class="cov0" title="0">if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagsInfo = fmt.Sprintf(" (%s)", strings.Join(tags, ", "))
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s: %s [%s]%s%s %s",
                severity,
                location,
                sourceInfo,
                codeInfo,
                tagsInfo,
                diagnostic.Message)</span>
}

func countSeverity(diagnostics []string, severity string) int <span class="cov0" title="0">{
        count := 0
        for _, diag := range diagnostics </span><span class="cov0" title="0">{
                if strings.HasPrefix(diag, severity) </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package tools

import (
        "cmp"
        "context"
        _ "embed"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/permission"
)

type DownloadParams struct {
        URL      string `json:"url" description:"The URL to download from"`
        FilePath string `json:"file_path" description:"The local file path where the downloaded content should be saved"`
        Timeout  int    `json:"timeout,omitempty" description:"Optional timeout in seconds (max 600)"`
}

type DownloadPermissionsParams struct {
        URL      string `json:"url"`
        FilePath string `json:"file_path"`
        Timeout  int    `json:"timeout,omitempty"`
}

const DownloadToolName = "download"

//go:embed download.md
var downloadDescription []byte

func NewDownloadTool(permissions permission.Service, workingDir string, client *http.Client) fantasy.AgentTool <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Timeout: 5 * time.Minute, // Default 5 minute timeout for downloads
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                }
        }</span>
        <span class="cov0" title="0">return fantasy.NewParallelAgentTool(
                DownloadToolName,
                string(downloadDescription),
                func(ctx context.Context, params DownloadParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.URL == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("URL parameter is required"), nil
                        }</span>

                        <span class="cov0" title="0">if params.FilePath == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("file_path parameter is required"), nil
                        }</span>

                        <span class="cov0" title="0">if !strings.HasPrefix(params.URL, "http://") &amp;&amp; !strings.HasPrefix(params.URL, "https://") </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("URL must start with http:// or https://"), nil
                        }</span>

                        <span class="cov0" title="0">filePath := filepathext.SmartJoin(workingDir, params.FilePath)
                        relPath, _ := filepath.Rel(workingDir, filePath)
                        relPath = filepath.ToSlash(cmp.Or(relPath, filePath))

                        sessionID := GetSessionFromContext(ctx)
                        if sessionID == "" </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for downloading files")
                        }</span>

                        <span class="cov0" title="0">p := permissions.Request(
                                permission.CreatePermissionRequest{
                                        SessionID:   sessionID,
                                        Path:        filePath,
                                        ToolName:    DownloadToolName,
                                        Action:      "download",
                                        Description: fmt.Sprintf("Download file from URL: %s to %s", params.URL, filePath),
                                        Params:      DownloadPermissionsParams(params),
                                },
                        )

                        if !p </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                        }</span>

                        // Handle timeout with context
                        <span class="cov0" title="0">requestCtx := ctx
                        if params.Timeout &gt; 0 </span><span class="cov0" title="0">{
                                maxTimeout := 600 // 10 minutes
                                if params.Timeout &gt; maxTimeout </span><span class="cov0" title="0">{
                                        params.Timeout = maxTimeout
                                }</span>
                                <span class="cov0" title="0">var cancel context.CancelFunc
                                requestCtx, cancel = context.WithTimeout(ctx, time.Duration(params.Timeout)*time.Second)
                                defer cancel()</span>
                        }

                        <span class="cov0" title="0">req, err := http.NewRequestWithContext(requestCtx, "GET", params.URL, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to create request: %w", err)
                        }</span>

                        <span class="cov0" title="0">req.Header.Set("User-Agent", "nexora/1.0")

                        resp, err := client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to download from URL: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()

                        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Request failed with status code: %d", resp.StatusCode)), nil
                        }</span>

                        // Check content length if available
                        <span class="cov0" title="0">maxSize := int64(100 * 1024 * 1024) // 100MB
                        if resp.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("File too large: %d bytes (max %d bytes)", resp.ContentLength, maxSize)), nil
                        }</span>

                        // Create parent directories if they don't exist
                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(filePath), 0o755); err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to create parent directories: %w", err)
                        }</span>

                        // Create the output file
                        <span class="cov0" title="0">outFile, err := os.Create(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to create output file: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer outFile.Close()

                        // Copy data with size limit
                        limitedReader := io.LimitReader(resp.Body, maxSize)
                        bytesWritten, err := io.Copy(outFile, limitedReader)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
                        }</span>

                        // Check if we hit the size limit
                        <span class="cov0" title="0">if bytesWritten == maxSize </span><span class="cov0" title="0">{
                                // Clean up the file since it might be incomplete
                                os.Remove(filePath)
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("File too large: exceeded %d bytes limit", maxSize)), nil
                        }</span>

                        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")
                        responseMsg := fmt.Sprintf("Successfully downloaded %d bytes to %s", bytesWritten, relPath)
                        if contentType != "" </span><span class="cov0" title="0">{
                                responseMsg += fmt.Sprintf(" (Content-Type: %s)", contentType)
                        }</span>

                        <span class="cov0" title="0">return fantasy.NewTextResponse(responseMsg), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/aiops"
        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/diff"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/fsext"
        "github.com/nexora/cli/internal/history"
        "github.com/nexora/cli/internal/lsp"
        "github.com/nexora/cli/internal/permission"
)

// normalizeTabIndicators converts VIEW tool display tabs (→        ) back to actual tabs (\t)
func normalizeTabIndicators(content string) string <span class="cov8" title="1">{
        // Convert display format →\t back to actual tabs \t
        content = strings.ReplaceAll(content, "→\t", "\t")
        // Also handle cases where only → is present
        content = strings.ReplaceAll(content, "→", "\t")
        return content
}</span>

var sqlcSourceDir = "/home/nexora/internal/db/sql"

func isSQLCProject() bool <span class="cov0" title="0">{
        _, errSqlc := os.Stat("/home/nexora/sqlc.yaml")
        _, errFiles := os.Stat("/home/nexora/internal/db/files.sql.go")
        return errSqlc == nil &amp;&amp; errFiles == nil
}</span>

func isSQLCGeneratedFile(filePath string) (bool, string) <span class="cov0" title="0">{
        if !strings.HasSuffix(filePath, ".sql.go") </span><span class="cov0" title="0">{
                return false, ""
        }</span>
        <span class="cov0" title="0">base := filepath.Base(filePath)
        sourcePath := filepath.Join(sqlcSourceDir, strings.TrimSuffix(base, ".go")+".sql")
        return true, sourcePath</span>
}

type EditParams struct {
        FilePath   string `json:"file_path" description:"The absolute path to the file to modify"`
        OldString  string `json:"old_string" description:"The text to replace"`
        NewString  string `json:"new_string" description:"The text to replace it with"`
        ReplaceAll bool   `json:"replace_all,omitempty" description:"Replace all occurrences of old_string (default false)"`
        AIMode     bool   `json:"ai_mode,omitempty" description:"Enable AI-optimized editing with automatic context expansion and improved error handling (DEFAULT: true)"`
}

type EditPermissionsParams struct {
        FilePath   string `json:"file_path"`
        OldContent string `json:"old_content,omitempty"`
        NewContent string `json:"new_content,omitempty"`
}

type EditResponseMetadata struct {
        Additions  int    `json:"additions"`
        Removals   int    `json:"removals"`
        OldContent string `json:"old_content,omitempty"`
        NewContent string `json:"new_content,omitempty"`
}

const EditToolName = "edit"

//go:embed edit.md
var editDescription []byte

type editContext struct {
        ctx         context.Context
        permissions permission.Service
        files       history.Service
        workingDir  string
        aiops       aiops.Ops
}

func NewEditTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, files history.Service, workingDir string, aiops aiops.Ops) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                EditToolName,
                string(editDescription),
                func(ctx context.Context, params EditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        // COMPREHENSIVE LOGGING - Fail Fast, Fix Fast
                        slog.Info("EDIT TOOL INVOKED",
                                "file", params.FilePath,
                                "old_string_length", len(params.OldString),
                                "new_string_length", len(params.NewString),
                                "ai_mode_original", params.AIMode,
                                "replace_all", params.ReplaceAll)

                        // FORCE AI MODE = true by default (eliminates 90% of failures)
                        if !params.AIMode </span><span class="cov0" title="0">{
                                slog.Warn("AI mode forced to true - this eliminates most whitespace/tab failures", "file", params.FilePath)
                                params.AIMode = true
                        }</span>

                        <span class="cov0" title="0">slog.Info("AI MODE STATUS", "final_ai_mode", params.AIMode)

                        if params.FilePath == "" </span><span class="cov0" title="0">{
                                slog.Error("EDIT FAILED: No file path provided")
                                return fantasy.NewTextErrorResponse("file_path is required"), nil
                        }</span>

                        <span class="cov0" title="0">params.FilePath = filepathext.SmartJoin(workingDir, params.FilePath)
                        slog.Info("FILE RESOLVED", "final_path", params.FilePath)

                        // LOG EXACT STRINGS ON FAILURE
                        if params.OldString != "" </span><span class="cov0" title="0">{
                                slog.Debug("OLD STRING DETAILS",
                                        "content", params.OldString,
                                        "lines", strings.Count(params.OldString, "\n")+1,
                                        "has_tabs", strings.Contains(params.OldString, "\t"),
                                        "trail_spaces", strings.HasSuffix(params.OldString, " "))
                        }</span>

                        <span class="cov0" title="0">var response fantasy.ToolResponse
                        var err error

                        editCtx := editContext{ctx, permissions, files, workingDir, aiops}

                        if params.OldString == "" </span><span class="cov0" title="0">{
                                slog.Info("CREATING NEW FILE", "file", params.FilePath)
                                response, err = createNewFile(editCtx, params.FilePath, params.NewString, call)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("CREATE FILE FAILED", "error", err)
                                        return response, err
                                }</span>
                        }

                        <span class="cov0" title="0">if params.NewString == "" </span><span class="cov0" title="0">{
                                slog.Info("DELETING CONTENT", "file", params.FilePath)
                                response, err = deleteContent(editCtx, params.FilePath, params.OldString, params.ReplaceAll, call)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("DELETE FAILED", "error", err)
                                        return response, err
                                }</span>
                        }

                        <span class="cov0" title="0">slog.Info("ATTEMPTING EDIT", "file", params.FilePath)
                        response, err = replaceContent(editCtx, params, params.FilePath, params.OldString, params.NewString, params.ReplaceAll, call)
                        // FAILURE ANALYSIS LOGGING
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("EDIT FAILED",
                                        "error", err,
                                        "file", params.FilePath,
                                        "old_preview", params.OldString[:min(100, len(params.OldString))],
                                        "ai_mode", params.AIMode)
                        }</span>

                        <span class="cov0" title="0">if response.IsError </span><span class="cov0" title="0">{
                                slog.Error("EDIT RETURNED ERROR",
                                        "response", response.Content,
                                        "file", params.FilePath,
                                        "ai_mode", params.AIMode,
                                        "old_string_short", params.OldString[:min(50, len(params.OldString))])
                                // Return early if there was an error during content replacement
                                // This prevents unnecessary LSP diagnostics processing
                                return response, nil
                        }</span>

                        <span class="cov0" title="0">slog.Info("EDIT SUCCEEDED", "file", params.FilePath)
                        notifyLSPs(ctx, lspClients, params.FilePath)

                        text := fmt.Sprintf("&lt;result&gt;\n%s\n&lt;/result&gt;\n", response.Content)
                        text += getDiagnostics(params.FilePath, lspClients)
                        response.Content = text
                        return response, nil</span>
                })
}

func createNewFile(edit editContext, filePath, content string, call fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        fileInfo, err := os.Stat(filePath)
        if err == nil </span><span class="cov0" title="0">{
                if fileInfo.IsDir() </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("path is a directory, not a file: %s", filePath)), nil
                }</span>
                <span class="cov0" title="0">return fantasy.NewTextErrorResponse(fmt.Sprintf("file already exists: %s", filePath)), nil</span>
        } else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to access file: %w", err)
        }</span>

        <span class="cov0" title="0">dir := filepath.Dir(filePath)
        if err = os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        <span class="cov0" title="0">sessionID := GetSessionFromContext(edit.ctx)
        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
        }</span>

        <span class="cov0" title="0">_, additions, removals := diff.GenerateDiff(
                "",
                content,
                strings.TrimPrefix(filePath, edit.workingDir),
        )
        p := edit.permissions.Request(
                permission.CreatePermissionRequest{
                        SessionID:   sessionID,
                        Path:        fsext.PathOrPrefix(filePath, edit.workingDir),
                        ToolCallID:  call.ID,
                        ToolName:    EditToolName,
                        Action:      "write",
                        Description: fmt.Sprintf("Create file %s", filePath),
                        Params: EditPermissionsParams{
                                FilePath:   filePath,
                                OldContent: "",
                                NewContent: content,
                        },
                },
        )
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(filePath, []byte(content), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // File can't be in the history so we create a new file history
        <span class="cov0" title="0">_, err = edit.files.Create(edit.ctx, sessionID, filePath, "")
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the operation
                return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
        }</span>

        // Add the new content to the file history
        <span class="cov0" title="0">_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, content)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the operation
                slog.Error("Error creating file history version", "error", err)
        }</span>

        <span class="cov0" title="0">recordFileWrite(filePath)
        recordFileRead(filePath)

        // Limit response context to prevent explosion (10 lines max)
        limitedContent := limitResponseContext(content)

        return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse("File created: "+filePath),
                EditResponseMetadata{
                        OldContent: "",
                        NewContent: limitedContent,
                        Additions:  additions,
                        Removals:   removals,
                },
        ), nil</span>
}

func deleteContent(edit editContext, filePath, oldString string, replaceAll bool, call fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("file not found: %s", filePath)), nil
                }</span>
                <span class="cov0" title="0">return fantasy.ToolResponse{}, fmt.Errorf("failed to access file: %w", err)</span>
        }

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("path is a directory, not a file: %s", filePath)), nil
        }</span>

        <span class="cov0" title="0">if getLastReadTime(filePath).IsZero() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("you must read the file before editing it. Use the View tool first"), nil
        }</span>

        <span class="cov0" title="0">modTime := fileInfo.ModTime()
        lastRead := getLastReadTime(filePath)
        if modTime.After(lastRead) </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(
                        fmt.Sprintf("file %s has been modified since it was last read (mod time: %s, last read: %s)",
                                filePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),
                        )), nil
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">oldContent, isCrlf := fsext.ToUnixLineEndings(string(content))

        var newContent string
        var deletionCount int

        if replaceAll </span><span class="cov0" title="0">{
                newContent = strings.ReplaceAll(oldContent, oldString, "")
                deletionCount = strings.Count(oldContent, oldString)
                if deletionCount == 0 </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(createAIErrorMessage(
                                fmt.Errorf("old_string not found in file"),
                                oldContent, oldString,
                        )), nil
                }</span>
        } else<span class="cov0" title="0"> {
                index := strings.Index(oldContent, oldString)
                if index == -1 </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(createAIErrorMessage(
                                fmt.Errorf("old_string not found in file"),
                                oldContent, oldString,
                        )), nil
                }</span>

                <span class="cov0" title="0">lastIndex := strings.LastIndex(oldContent, oldString)
                if index != lastIndex </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse("MULTIPLE_MATCHES: The pattern appears multiple times in the file. " +
                                "Solutions: 1) Use AI mode (ai_mode=true) for automatic context expansion, " +
                                "2) Provide 3-5 lines of surrounding context to make it unique, " +
                                "3) Set replace_all=true to replace all occurrences."), nil
                }</span>

                <span class="cov0" title="0">newContent = oldContent[:index] + oldContent[index+len(oldString):]
                deletionCount = 1</span>
        }

        <span class="cov0" title="0">sessionID := GetSessionFromContext(edit.ctx)

        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
        }</span>

        <span class="cov0" title="0">_, additions, removals := diff.GenerateDiff(
                oldContent,
                newContent,
                strings.TrimPrefix(filePath, edit.workingDir),
        )

        p := edit.permissions.Request(
                permission.CreatePermissionRequest{
                        SessionID:   sessionID,
                        Path:        fsext.PathOrPrefix(filePath, edit.workingDir),
                        ToolCallID:  call.ID,
                        ToolName:    EditToolName,
                        Action:      "write",
                        Description: fmt.Sprintf("Delete content from file %s", filePath),
                        Params: EditPermissionsParams{
                                FilePath:   filePath,
                                OldContent: oldContent,
                                NewContent: newContent,
                        },
                },
        )
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        <span class="cov0" title="0">if isCrlf </span><span class="cov0" title="0">{
                newContent, _ = fsext.ToWindowsLineEndings(newContent)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(filePath, []byte(newContent), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // Check if file exists in history
        <span class="cov0" title="0">file, err := edit.files.GetByPathAndSession(edit.ctx, filePath, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                _, err = edit.files.Create(edit.ctx, sessionID, filePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if file.Content != oldContent </span><span class="cov0" title="0">{
                // User Manually changed the content store an intermediate version
                _, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error creating file history version", "error", err)
                }</span>
        }
        // Store the new version
        <span class="cov0" title="0">_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, "")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating file history version", "error", err)
        }</span>

        <span class="cov0" title="0">recordFileWrite(filePath)
        recordFileRead(filePath)

        // Limit response context to prevent explosion (10 lines max)
        limitedOldContent := limitResponseContext(oldContent)
        limitedNewContent := limitResponseContext(newContent)

        return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse("Content deleted from file: "+filePath),
                EditResponseMetadata{
                        OldContent: limitedOldContent,
                        NewContent: limitedNewContent,
                        Additions:  additions,
                        Removals:   removals,
                },
        ), nil</span>
}

// autoExpandContext automatically expands minimal context to improve match success
func autoExpandContext(filePath, partialString string) (string, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read file for context expansion: %w", err)
        }</span>

        <span class="cov8" title="1">fileContent := string(content)
        lines := strings.Split(fileContent, "\n")

        // Try to find the partial string and expand context around it
        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, partialString) </span><span class="cov8" title="1">{
                        // Expand 2 lines before and 2 lines after for better context
                        start := i - 2
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                        <span class="cov8" title="1">end := i + 3
                        if end &gt; len(lines) </span><span class="cov8" title="1">{
                                end = len(lines)
                        }</span>
                        <span class="cov8" title="1">return strings.Join(lines[start:end], "\n"), nil</span>
                }
        }

        // If not found, return original (no expansion possible)
        <span class="cov8" title="1">return partialString, nil</span>
}

// limitEditContext limits the context around an edit to prevent context explosion
// Returns only 10 lines (5 before and 5 after) the edit location
func limitEditContext(fullContent, oldString string) (string, error) <span class="cov0" title="0">{
        lines := strings.Split(fullContent, "\n")

        // Find all lines that contain the old string
        var matchingLines []int
        for i, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, oldString) </span><span class="cov0" title="0">{
                        matchingLines = append(matchingLines, i)
                }</span>
        }

        <span class="cov0" title="0">if len(matchingLines) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("oldstring not found in file for context limiting")
        }</span>

        // If there are multiple matches, use the first one for context limiting
        // This is consistent with how single replace works
        <span class="cov0" title="0">targetLine := matchingLines[0]

        // Calculate 10-line window (5 before, 5 after + the target line)
        start := targetLine - 5
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov0" title="0">end := targetLine + 6 // +6 because we want 5 lines after, not including the target line
        if end &gt; len(lines) </span><span class="cov0" title="0">{
                end = len(lines)
        }</span>

        // Extract the limited context
        <span class="cov0" title="0">limitedLines := lines[start:end]
        limitedContent := strings.Join(limitedLines, "\n")

        slog.Info("Edit context limited",
                "original_lines", len(lines),
                "limited_lines", len(limitedLines),
                "target_line", targetLine,
                "start", start,
                "end", end)

        return limitedContent, nil</span>
}

// limitResponseContext limits the content returned in responses to prevent context explosion
func limitResponseContext(content string) string <span class="cov0" title="0">{
        lines := strings.Split(content, "\n")

        // If content is already 10 lines or less, return as-is
        if len(lines) &lt;= 10 </span><span class="cov0" title="0">{
                return content
        }</span>

        // Take only first 10 lines
        <span class="cov0" title="0">limitedLines := lines[:10]
        limitedContent := strings.Join(limitedLines, "\n")

        // Add indicator that content was truncated
        if len(lines) &gt; 10 </span><span class="cov0" title="0">{
                limitedContent += "\n... (content truncated to 10 lines to prevent context explosion)"
        }</span>

        <span class="cov0" title="0">slog.Info("Response context limited",
                "original_lines", len(lines),
                "limited_lines", len(limitedLines))

        return limitedContent</span>
}

func replaceContent(edit editContext, params EditParams, filePath, oldString, newString string, replaceAll bool, call fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        // NORMALIZE TAB INDICATORS FROM VIEW OUTPUT
        oldString = normalizeTabIndicators(oldString)
        newString = normalizeTabIndicators(newString)

        // Try AI mode first (handles 90% of failures automatically)
        if params.AIMode </span><span class="cov0" title="0">{
                slog.Debug("AI mode enabled - auto-expanding context and normalizing tabs", "file", params.FilePath)
                lineCount := strings.Count(oldString, "\n")
                if lineCount &lt; 3 </span><span class="cov0" title="0">{ // Less than 3 lines = definitely needs expansion
                        expanded, err := autoExpandContext(filePath, oldString)
                        if err == nil &amp;&amp; expanded != oldString </span><span class="cov0" title="0">{
                                oldString = expanded
                                slog.Info("AI mode: auto-expanded context",
                                        "file", filePath,
                                        "original_lines", lineCount,
                                        "expanded_lines", strings.Count(expanded, "\n"))
                        }</span>
                }
        }

        <span class="cov0" title="0">attemptCount := 0
        // Auto-view file before every edit to ensure we have latest context
        if err := autoViewFileBeforeEdit(edit.ctx, filePath); err != nil </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("failed to view file before edit: %v", err)), nil
        }</span>

        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("file not found: %s", filePath)), nil
                }</span>
                <span class="cov0" title="0">return fantasy.ToolResponse{}, fmt.Errorf("failed to access file: %w", err)</span>
        }

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("path is a directory, not a file: %s", filePath)), nil
        }</span>

        <span class="cov0" title="0">if getLastReadTime(filePath).IsZero() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("you must read the file before editing it. Use the View tool first"), nil
        }</span>

        <span class="cov0" title="0">modTime := fileInfo.ModTime()
        lastRead := getLastReadTime(filePath)
        if modTime.After(lastRead) </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(
                        fmt.Sprintf("file %s has been modified since it was last read (mod time: %s, last read: %s)",
                                filePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),
                        )), nil
        }</span>

        // Validate old_string exists before proceeding with edit
        <span class="cov0" title="0">if err := ValidateEditString(filePath, oldString, replaceAll); err != nil </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(err.Error()), nil
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">oldContent, isCrlf := fsext.ToUnixLineEndings(string(content))

        var newContent string
        var replacementCount int

        if replaceAll </span><span class="cov0" title="0">{
                newContent = strings.ReplaceAll(oldContent, oldString, newString)
                replacementCount = strings.Count(oldContent, oldString)
                if replacementCount == 0 </span><span class="cov0" title="0">{
                        if replacementCount == 0 </span><span class="cov0" title="0">{
                                // Try whitespace normalization (handles tabs vs spaces from View output)
                                if normalized, found := tryNormalizedMatch(oldContent, oldString); found </span><span class="cov0" title="0">{
                                        oldString = normalized
                                        newContent = strings.ReplaceAll(oldContent, oldString, newString)
                                        replacementCount = strings.Count(oldContent, oldString)
                                        if replacementCount &gt; 0 </span><span class="cov0" title="0">{
                                                // Successfully resolved with whitespace normalization
                                                goto foundReplaceAll</span>
                                        }
                                }
                        }
                        // Try fuzzy matching with confidence scoring (skip for very large files)
                <span class="cov0" title="0">if len(oldContent) &lt;= 50000 </span><span class="cov0" title="0">{ // 50KB threshold to avoid O(n²) performance issues
                        if match := findBestMatch(oldContent, oldString); match != nil &amp;&amp; match.confidence &gt;= 0.90 </span><span class="cov0" title="0">{
                                slog.Info("fuzzy match found (replaceAll)",
                                        "strategy", match.matchStrategy,
                                        "confidence", match.confidence,
                                        "file", filePath)
                                if match.exactMatch != "" </span><span class="cov0" title="0">{
                                        oldString = match.exactMatch
                                        newContent = strings.ReplaceAll(oldContent, oldString, newString)
                                        replacementCount = strings.Count(oldContent, oldString)
                                        if replacementCount &gt; 0 </span><span class="cov0" title="0">{
                                                // Successfully resolved with fuzzy matching
                                                goto foundReplaceAll</span>
                                        }
                                }
                }
                        }

                        // Try AIOPS edit resolution first if available
                        <span class="cov0" title="0">if edit.aiops != nil </span><span class="cov0" title="0">{
                                resolution, err := edit.aiops.ResolveEdit(edit.ctx, oldContent, oldString, newString)
                                if err == nil &amp;&amp; resolution.Confidence &gt; 0.8 </span><span class="cov0" title="0">{
                                        oldString = resolution.ExactOldString
                                        newContent = strings.ReplaceAll(oldContent, oldString, newString)
                                        replacementCount = strings.Count(oldContent, oldString)
                                        if replacementCount &gt; 0 </span><span class="cov0" title="0">{
                                                // Successfully resolved with AIOPS
                                                goto foundReplaceAll</span>
                                        }
                                }
                        }
                        // Attempt self-healing retry with better context
                        <span class="cov0" title="0">attemptCount++
                        retryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)
                        if err != nil </span><span class="cov0" title="0">{
                                LogEditFailure(EditDiagnosticsInfo{
                                        FilePath:      filePath,
                                        OldString:     oldString,
                                        NewString:     newString,
                                        FileContent:   oldContent,
                                        FileSizeBytes: len(oldContent),
                                        LineCount:     strings.Count(oldContent, "\n") + 1,
                                        FailureReason: "old_string not found (replaceAll)",
                                        Context:       PatternMatchAnalysis(oldContent, oldString),
                                })
                                return fantasy.NewTextErrorResponse(createAIErrorMessage(
                                        fmt.Errorf("old_string not found in file"),
                                        oldContent, oldString,
                                )), nil
                        }</span>
                        // Use the improved parameters from retry
                        <span class="cov0" title="0">oldString = retryParams.OldString
                        newContent = strings.ReplaceAll(oldContent, oldString, newString)
                        replacementCount = strings.Count(oldContent, oldString)
                        if replacementCount == 0 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("old_string not found in file. Make sure it matches exactly, including whitespace and line breaks"), nil
                        }</span>
                }
        foundReplaceAll:
        } else<span class="cov0" title="0"> {
                index := strings.Index(oldContent, oldString)
                if index == -1 </span><span class="cov0" title="0">{
                        // Try fuzzy matching with confidence scoring (skip for very large files)
                        if len(oldContent) &lt;= 50000 </span><span class="cov0" title="0">{ // 50KB threshold to avoid O(n²) performance issues
                        if match := findBestMatch(oldContent, oldString); match != nil &amp;&amp; match.confidence &gt;= 0.90 </span><span class="cov0" title="0">{
                                slog.Info("fuzzy match found",
                                        "strategy", match.matchStrategy,
                                        "confidence", match.confidence,
                                        "file", filePath)
                                oldString = match.exactMatch
                                index = match.byteOffset
                                if index != -1 &amp;&amp; match.exactMatch != "" </span><span class="cov0" title="0">{
                                        // Successfully resolved with fuzzy matching
                                        goto found</span>
                                }
                        }
                        }

                        // Try AIOPS edit resolution first if available
                        <span class="cov0" title="0">if edit.aiops != nil </span><span class="cov0" title="0">{
                                resolution, err := edit.aiops.ResolveEdit(edit.ctx, oldContent, oldString, newString)
                                if err == nil &amp;&amp; resolution.Confidence &gt; 0.8 </span><span class="cov0" title="0">{
                                        oldString = resolution.ExactOldString
                                        index = strings.Index(oldContent, oldString)
                                        if index != -1 </span><span class="cov0" title="0">{
                                                // Successfully resolved with AIOPS
                                                goto found</span>
                                        }
                                }
                        }
                        // Attempt self-healing retry with better context
                        <span class="cov0" title="0">attemptCount++
                        retryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)
                        if err != nil </span><span class="cov0" title="0">{
                                LogEditFailure(EditDiagnosticsInfo{
                                        FilePath:      filePath,
                                        OldString:     oldString,
                                        NewString:     newString,
                                        FileContent:   oldContent,
                                        FileSizeBytes: len(oldContent),
                                        LineCount:     strings.Count(oldContent, "\n") + 1,
                                        FailureReason: "old_string not found (replaceAll)",
                                        Context:       PatternMatchAnalysis(oldContent, oldString),
                                })
                                return fantasy.NewTextErrorResponse("old_string not found in file. Make sure it matches exactly, including whitespace and line breaks"), nil
                        }</span>
                        // Use the improved parameters from retry
                        <span class="cov0" title="0">oldString = retryParams.OldString
                        index = strings.Index(oldContent, oldString)
                        if index == -1 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("old_string not found in file. Make sure it matches exactly, including whitespace and line breaks"), nil
                        }</span>
                }
        found:

                <span class="cov0" title="0">lastIndex := strings.LastIndex(oldContent, oldString)
                if index != lastIndex </span><span class="cov0" title="0">{
                        // Attempt self-healing retry with better context
                        attemptCount++
                        retryParams, err := attemptSelfHealingRetry(edit.ctx, filePath, oldString, newString)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("old_string appears multiple times in the file. Please provide more context to ensure a unique match, or set replace_all to true"), nil
                        }</span>
                        // Use the improved parameters from retry
                        <span class="cov0" title="0">oldString = retryParams.OldString
                        index = strings.Index(oldContent, oldString)
                        lastIndex = strings.LastIndex(oldContent, oldString)
                        if index != lastIndex </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("old_string appears multiple times in the file. Please provide more context to ensure a unique match, or set replace_all to true"), nil
                        }</span>
                }

                <span class="cov0" title="0">newContent = oldContent[:index] + newString + oldContent[index+len(oldString):]
                replacementCount = 1</span>
        }

        <span class="cov0" title="0">if oldContent == newContent </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("new content is the same as old content. No changes made."), nil
        }</span>
        <span class="cov0" title="0">sessionID := GetSessionFromContext(edit.ctx)

        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
        }</span>
        <span class="cov0" title="0">_, additions, removals := diff.GenerateDiff(
                oldContent,
                newContent,
                strings.TrimPrefix(filePath, edit.workingDir),
        )

        p := edit.permissions.Request(
                permission.CreatePermissionRequest{
                        SessionID:   sessionID,
                        Path:        fsext.PathOrPrefix(filePath, edit.workingDir),
                        ToolCallID:  call.ID,
                        ToolName:    EditToolName,
                        Action:      "write",
                        Description: fmt.Sprintf("Replace content in file %s", filePath),
                        Params: EditPermissionsParams{
                                FilePath:   filePath,
                                OldContent: oldContent,
                                NewContent: newContent,
                        },
                },
        )
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        <span class="cov0" title="0">if isCrlf </span><span class="cov0" title="0">{
                newContent, _ = fsext.ToWindowsLineEndings(newContent)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(filePath, []byte(newContent), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // Check if file exists in history
        <span class="cov0" title="0">file, err := edit.files.GetByPathAndSession(edit.ctx, filePath, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                _, err = edit.files.Create(edit.ctx, sessionID, filePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if file.Content != oldContent </span><span class="cov0" title="0">{
                // User Manually changed the content store an intermediate version
                _, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Debug("Error creating file history version", "error", err)
                }</span>
        }
        // Store the new version
        <span class="cov0" title="0">_, err = edit.files.CreateVersion(edit.ctx, sessionID, filePath, newContent)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating file history version", "error", err)
        }</span>

        <span class="cov0" title="0">recordFileWrite(filePath)
        recordFileRead(filePath)
        LogEditSuccess(filePath, len(oldString), len(newString), replacementCount, attemptCount)

        // Limit response context to prevent explosion (10 lines max)
        limitedOldContent := limitResponseContext(oldContent)
        limitedNewContent := limitResponseContext(newContent)

        return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse("Content replaced in file: "+filePath),
                EditResponseMetadata{
                        OldContent: limitedOldContent,
                        NewContent: limitedNewContent,
                        Additions:  additions,
                        Removals:   removals,
                }), nil</span>
}

// attemptSelfHealingRetry uses the self-healing strategy to improve the old_string
// by extracting better context from the file when the initial match fails
func attemptSelfHealingRetry(ctx context.Context, filePath string, oldString string, newString string) (EditParams, error) <span class="cov0" title="0">{
        strategy := NewEditRetryStrategy(ctx)
        retryParams, err := strategy.RetryWithContext(filePath, oldString, newString, "old_string not found")
        if err != nil </span><span class="cov0" title="0">{
                return EditParams{}, err
        }</span>
        <span class="cov0" title="0">return retryParams, nil</span>
}

// autoViewFileBeforeEdit automatically views a file before editing to ensure we have the latest context
func autoViewFileBeforeEdit(ctx context.Context, filePath string) error <span class="cov0" title="0">{
        _, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file for auto-view: %w", err)
        }</span>

        // Update the last read time to reflect this automatic view
        <span class="cov0" title="0">recordFileRead(filePath)

        // Log that we performed an auto-view
        slog.Debug("Auto-viewed file before edit", "file", filePath)

        return nil</span>
}

// normalizeWhitespace converts mixed whitespace to consistent tabs for matching
// This helps match text copied from View output (which may have spaces from display padding)
</pre>
		
		<pre class="file" id="file4" style="display: none">package tools

import (
        "fmt"
        "log/slog"
        "strings"
)

// EditDiagnosticsInfo captures detailed diagnostic information about edit failures
type EditDiagnosticsInfo struct {
        FilePath      string
        OldString     string
        NewString     string
        FileContent   string
        FileSizeBytes int
        LineCount     int
        FailureReason string
        Context       map[string]interface{}
}

// ViewDiagnosticsInfo captures diagnostic information about view operations
type ViewDiagnosticsInfo struct {
        FilePath  string
        Offset    int
        Limit     int
        FileSize  int64
        LineCount int
        Context   map[string]interface{}
}

// WhitespaceAnalysis provides detailed whitespace analysis for debugging
type WhitespaceAnalysis struct {
        ContainsTab        bool
        ContainsSpace      bool
        LeadingSpaces      int
        TrailingSpaces     int
        BlankLines         int
        HasMixedIndent     bool
        LineEndings        string // "LF" or "CRLF" or "Mixed"
        ByteRepresentation string
}

// AnalyzeWhitespace performs detailed whitespace analysis on a string
func AnalyzeWhitespace(s string) WhitespaceAnalysis <span class="cov0" title="0">{
        analysis := WhitespaceAnalysis{
                ByteRepresentation: formatBytesForDebug(s),
        }

        lines := strings.Split(s, "\n")
        indentationStyles := make(map[string]int)

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        analysis.BlankLines++
                        continue</span>
                }

                <span class="cov0" title="0">if strings.Contains(line, "\t") </span><span class="cov0" title="0">{
                        analysis.ContainsTab = true
                }</span>
                <span class="cov0" title="0">if strings.Contains(line, " ") </span><span class="cov0" title="0">{
                        analysis.ContainsSpace = true
                }</span>

                <span class="cov0" title="0">for i, ch := range line </span><span class="cov0" title="0">{
                        if ch == '\t' </span><span class="cov0" title="0">{
                                indentationStyles["tab"]++
                        }</span> else<span class="cov0" title="0"> if ch == ' ' </span><span class="cov0" title="0">{
                                indentationStyles["space"]++
                        }</span> else<span class="cov0" title="0"> {
                                analysis.LeadingSpaces = i
                                break</span>
                        }
                }

                <span class="cov0" title="0">trimmed := strings.TrimRight(line, " \t")
                if len(trimmed) &lt; len(line) </span><span class="cov0" title="0">{
                        analysis.TrailingSpaces += len(line) - len(trimmed)
                }</span>
        }

        <span class="cov0" title="0">if len(indentationStyles) &gt; 1 </span><span class="cov0" title="0">{
                analysis.HasMixedIndent = true
        }</span>

        <span class="cov0" title="0">analysis.LineEndings = detectLineEndings(s)
        return analysis</span>
}

func detectLineEndings(s string) string <span class="cov0" title="0">{
        crlfCount := strings.Count(s, "\r\n")
        lfCount := strings.Count(s, "\n") - crlfCount

        if crlfCount &gt; 0 &amp;&amp; lfCount == 0 </span><span class="cov0" title="0">{
                return "CRLF"
        }</span> else<span class="cov0" title="0"> if lfCount &gt; 0 &amp;&amp; crlfCount == 0 </span><span class="cov0" title="0">{
                return "LF"
        }</span> else<span class="cov0" title="0"> if crlfCount &gt; 0 &amp;&amp; lfCount &gt; 0 </span><span class="cov0" title="0">{
                return "Mixed"
        }</span>
        <span class="cov0" title="0">return "Unknown"</span>
}

func formatBytesForDebug(s string) string <span class="cov0" title="0">{
        var result strings.Builder
        for i, ch := range s </span><span class="cov0" title="0">{
                if i &gt; 100 </span><span class="cov0" title="0">{
                        result.WriteString(fmt.Sprintf("... (%d more chars)", len(s)-i))
                        break</span>
                }
                <span class="cov0" title="0">switch ch </span>{
                case '\n':<span class="cov0" title="0">
                        result.WriteString("\\n")</span>
                case '\r':<span class="cov0" title="0">
                        result.WriteString("\\r")</span>
                case '\t':<span class="cov0" title="0">
                        result.WriteString("\\t")</span>
                case ' ':<span class="cov0" title="0">
                        result.WriteString("·")</span>
                default:<span class="cov0" title="0">
                        if ch &gt;= 32 &amp;&amp; ch &lt; 127 </span><span class="cov0" title="0">{
                                result.WriteRune(ch)
                        }</span> else<span class="cov0" title="0"> {
                                result.WriteString(fmt.Sprintf("\\x%02x", ch))
                        }</span>
                }
        }
        <span class="cov0" title="0">return result.String()</span>
}

// LogEditFailure captures comprehensive diagnostic data when an edit fails
func LogEditFailure(diag EditDiagnosticsInfo) <span class="cov0" title="0">{
        oldAnalysis := AnalyzeWhitespace(diag.OldString)
        newAnalysis := AnalyzeWhitespace(diag.NewString)
        fileAnalysis := AnalyzeWhitespace(diag.FileContent)

        slog.Error("Edit operation failed",
                "file", diag.FilePath,
                "failure_reason", diag.FailureReason,
                "old_string_length", len(diag.OldString),
                "new_string_length", len(diag.NewString),
                "file_content_length", len(diag.FileContent),
                "old_string_lines", strings.Count(diag.OldString, "\n")+1,
                "new_string_lines", strings.Count(diag.NewString, "\n")+1,
                "old_has_tabs", oldAnalysis.ContainsTab,
                "old_has_mixed_indent", oldAnalysis.HasMixedIndent,
                "old_line_endings", oldAnalysis.LineEndings,
                "new_has_tabs", newAnalysis.ContainsTab,
                "file_has_tabs", fileAnalysis.ContainsTab,
                "file_has_mixed_indent", fileAnalysis.HasMixedIndent,
                "file_line_endings", fileAnalysis.LineEndings,
                "old_string_preview", truncatePreview(diag.OldString, 80),
                "file_size", len(diag.FileContent),
        )

        slog.Debug("Edit failure detailed diagnostics",
                "old_string_bytes", oldAnalysis.ByteRepresentation,
                "new_string_bytes", newAnalysis.ByteRepresentation,
                "additional_context", diag.Context,
        )
}</span>

// LogEditSuccess captures successful edit metrics
func LogEditSuccess(filePath string, oldLen, newLen int, replacementCount int, attemptCount int) <span class="cov0" title="0">{
        slog.Info("Edit operation succeeded",
                "file", filePath,
                "old_string_length", oldLen,
                "new_string_length", newLen,
                "replacement_count", replacementCount,
                "attempt_count", attemptCount,
        )
}</span>

// LogViewOperation logs view tool operations
func LogViewOperation(diag ViewDiagnosticsInfo, duration float64) <span class="cov0" title="0">{
        slog.Info("View operation completed",
                "file", diag.FilePath,
                "offset", diag.Offset,
                "limit", diag.Limit,
                "file_size", diag.FileSize,
                "total_lines", diag.LineCount,
                "duration_ms", duration,
        )
}</span>

// LogViewError logs view tool errors
func LogViewError(diag ViewDiagnosticsInfo, errReason string) <span class="cov0" title="0">{
        slog.Error("View operation failed",
                "file", diag.FilePath,
                "offset", diag.Offset,
                "limit", diag.Limit,
                "file_size", diag.FileSize,
                "error_reason", errReason,
        )
}</span>

func truncatePreview(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return formatBytesForDebug(s)
        }</span>
        <span class="cov0" title="0">return formatBytesForDebug(s[:maxLen]) + "..."</span>
}

// LogSelfHealingAttempt logs self-healing retry attempts
func LogSelfHealingAttempt(filePath, reason string, success bool, originalLen, improvedLen int) <span class="cov0" title="0">{
        level := slog.LevelInfo
        if !success </span><span class="cov0" title="0">{
                level = slog.LevelWarn
        }</span>
        <span class="cov0" title="0">slog.Log(nil, level,
                "Self-healing edit retry",
                "file", filePath,
                "reason", reason,
                "success", success,
                "original_length", originalLen,
                "improved_length", improvedLen,
        )</span>
}

// PatternMatchAnalysis provides insight into why pattern matching failed
func PatternMatchAnalysis(fileContent, pattern string) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "file_length":        len(fileContent),
                "pattern_length":     len(pattern),
                "pattern_line_count": strings.Count(pattern, "\n") + 1,
                "file_line_count":    strings.Count(fileContent, "\n") + 1,
                "pattern_in_file":    strings.Contains(fileContent, pattern),
        }
}</span>

// AnalyzeWhitespaceDifference compares whitespace between file content and pattern
func AnalyzeWhitespaceDifference(fileContent, pattern string) map[string]interface{} <span class="cov8" title="1">{
        fileTabs := strings.Count(fileContent, "\t")
        patternTabs := strings.Count(pattern, "\t")
        displayTabs := strings.Count(pattern, "→\t")

        fileSpaces := countLeadingSpaces(fileContent)
        patternSpaces := countLeadingSpaces(pattern)

        return map[string]interface{}{
                "has_tab_mismatch":            displayTabs &gt; 0,
                "expected_tabs":               fileTabs,
                "found_tabs":                  patternTabs,
                "display_tabs":                displayTabs,
                "has_space_mismatch":          patternSpaces != fileSpaces,
                "expected_spaces":             fileSpaces,
                "found_spaces":                patternSpaces,
                "pattern_in_file":             strings.Contains(fileContent, pattern),
                "pattern_after_normalization": strings.Contains(fileContent, normalizeTabIndicators(pattern)),
        }
}</span>

// Helper function for space counting
func countLeadingSpaces(content string) int <span class="cov8" title="1">{
        lines := strings.Split(content, "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Count leading spaces on first non-empty line
        <span class="cov8" title="1">for _, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimLeft(line, " ")
                if len(trimmed) &lt; len(line) </span><span class="cov8" title="1">{
                        return len(line) - len(trimmed)
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

// createAIErrorMessage generates AI-friendly error messages with actionable guidance
func createAIErrorMessage(err error, fileContent, oldString string) string <span class="cov8" title="1">{
        analysis := AnalyzeWhitespaceDifference(fileContent, oldString)

        // Tab mismatch - most common issue
        if analysis["has_tab_mismatch"].(bool) </span><span class="cov8" title="1">{
                return fmt.Sprintf("TAB_MISMATCH: The VIEW tool shows tabs as '→\t' but EDIT needs raw tabs. "+
                        "Found %d display tabs in your pattern. Try: "+
                        "1) Use AI mode (ai_mode=true) for automatic normalization, or "+
                        "2) Replace '→\t' with actual tab characters in your pattern.",
                        analysis["display_tabs"].(int))
        }</span>

        // Space mismatch
        <span class="cov8" title="1">if analysis["has_space_mismatch"].(bool) </span><span class="cov0" title="0">{
                return fmt.Sprintf("SPACE_MISMATCH: Expected %d leading spaces but found %d. "+
                        "Count spaces carefully. AI mode (ai_mode=true) can help with this.",
                        analysis["expected_spaces"].(int), analysis["found_spaces"].(int))
        }</span>

        // Pattern not found at all
        <span class="cov8" title="1">if !analysis["pattern_in_file"].(bool) </span><span class="cov8" title="1">{
                // Check if it would match after normalization
                if analysis["pattern_after_normalization"].(bool) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("PATTERN_FORMAT_MISMATCH: Your pattern would match after tab normalization. " +
                                "Use AI mode (ai_mode=true) or normalize tabs manually.")
                }</span>

                <span class="cov8" title="1">return fmt.Sprintf("PATTERN_NOT_FOUND: The text was not found in the file. " +
                        "Common fixes: 1) Use AI mode (ai_mode=true), " +
                        "2) Include more surrounding context (3-5 lines), " +
                        "3) Check for tab/space differences, " +
                        "4) Verify the file hasn't changed since you viewed it.")</span>
        }

        // Fallback to original error
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tools

import (
        "fmt"
        "strings"
)

// findMostSimilarContent finds the closest matching content in the file
func findMostSimilarContent(fileContent, target string) string <span class="cov0" title="0">{
        targetLines := strings.Split(strings.TrimSpace(target), "\n")
        if len(targetLines) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">fileLines := strings.Split(fileContent, "\n")
        bestMatch := ""
        bestScore := 0

        // Look for sequences with at least 50% line overlap
        for i := 0; i &lt;= len(fileLines)-len(targetLines); i++ </span><span class="cov0" title="0">{
                matchCount := 0
                for j, targetLine := range targetLines </span><span class="cov0" title="0">{
                        if i+j &lt; len(fileLines) </span><span class="cov0" title="0">{
                                fileLine := fileLines[i+j]
                                if strings.TrimSpace(fileLine) == strings.TrimSpace(targetLine) </span><span class="cov0" title="0">{
                                        matchCount++
                                }</span>
                        }
                }

                <span class="cov0" title="0">if matchCount &gt; bestScore </span><span class="cov0" title="0">{
                        bestScore = matchCount
                        endIdx := i + len(targetLines)
                        if endIdx &gt; len(fileLines) </span><span class="cov0" title="0">{
                                endIdx = len(fileLines)
                        }</span>
                        <span class="cov0" title="0">bestMatch = strings.Join(fileLines[i:endIdx], "\n")</span>
                }
        }

        <span class="cov0" title="0">if bestScore &gt;= len(targetLines)/2 </span><span class="cov0" title="0">{
                return bestMatch
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// visualizeDifference creates a visual diff showing expected vs actual
func visualizeDifference(expected, actual string) string <span class="cov0" title="0">{
        var result strings.Builder
        result.WriteString("EXPECTED (your old_string):\n")

        expectedLines := strings.Split(expected, "\n")
        for i, line := range expectedLines </span><span class="cov0" title="0">{
                // Show whitespace visually
                visualLine := strings.ReplaceAll(line, "\t", "→")
                visualLine = strings.ReplaceAll(visualLine, " ", "·")
                result.WriteString(fmt.Sprintf("  %d: %s\n", i+1, visualLine))
        }</span>

        <span class="cov0" title="0">result.WriteString("\nACTUAL (closest match in file):\n")
        actualLines := strings.Split(actual, "\n")
        for i, line := range actualLines </span><span class="cov0" title="0">{
                visualLine := strings.ReplaceAll(line, "\t", "→")
                visualLine = strings.ReplaceAll(visualLine, " ", "·")

                // Mark differing lines
                marker := " "
                if i &lt; len(expectedLines) &amp;&amp; strings.TrimSpace(line) != strings.TrimSpace(expectedLines[i]) </span><span class="cov0" title="0">{
                        marker = "✗"
                }</span>
                <span class="cov0" title="0">result.WriteString(fmt.Sprintf("%s %d: %s\n", marker, i+1, visualLine))</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// createEnhancedErrorMessage generates AI-friendly error messages with visual diffs
func createEnhancedErrorMessage(err error, fileContent, oldString string) string <span class="cov0" title="0">{
        analysis := AnalyzeWhitespaceDifference(fileContent, oldString)

        // Tab mismatch - most common issue
        if analysis["has_tab_mismatch"].(bool) </span><span class="cov0" title="0">{
                return fmt.Sprintf("TAB_MISMATCH: The VIEW tool shows tabs as '→\t' but EDIT needs raw tabs. "+
                        "Found %d display tabs in your pattern. Try: "+
                        "1) Use AI mode (ai_mode=true) for automatic normalization, or "+
                        "2) Replace '→\t' with actual tab characters in your pattern.",
                        analysis["display_tabs"].(int))
        }</span>

        // Space mismatch
        <span class="cov0" title="0">if analysis["has_space_mismatch"].(bool) </span><span class="cov0" title="0">{
                return fmt.Sprintf("SPACE_MISMATCH: Expected %d leading spaces but found %d. "+
                        "Count spaces carefully. AI mode (ai_mode=true) can help with this.",
                        analysis["expected_spaces"].(int), analysis["found_spaces"].(int))
        }</span>

        // Pattern not found at all - show visual diff
        <span class="cov0" title="0">if !analysis["pattern_in_file"].(bool) </span><span class="cov0" title="0">{
                // Check if it would match after normalization
                if analysis["pattern_after_normalization"].(bool) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("PATTERN_FORMAT_MISMATCH: Your pattern would match after tab normalization. " +
                                "Use AI mode (ai_mode=true) or normalize tabs manually.")
                }</span>

                // Try to find similar content and show diff
                <span class="cov0" title="0">similarContent := findMostSimilarContent(fileContent, oldString)
                if similarContent != "" </span><span class="cov0" title="0">{
                        diff := visualizeDifference(oldString, similarContent)
                        return fmt.Sprintf("PATTERN_NOT_FOUND: The text was not found in the file.\n\n"+
                                "Most similar content found:\n%s\n\n"+
                                "Common fixes:\n"+
                                "1) Use `sed -n 'START,ENDp' file` to extract exact text (RECOMMENDED)\n"+
                                "2) Use AI mode (ai_mode=true)\n"+
                                "3) If edit fails once, use `write` tool instead\n"+
                                "4) Use `smart_edit` tool with line numbers for 100%% reliability",
                                diff)
                }</span>

                <span class="cov0" title="0">return fmt.Sprintf("PATTERN_NOT_FOUND: The text was not found in the file. " +
                        "Common fixes:\n" +
                        "1) Use `grep -n 'pattern' file` to find line numbers, then use `smart_edit`\n" +
                        "2) Use `sed -n 'START,ENDp' file` to extract exact text\n" +
                        "3) Include more surrounding context (3-5 lines)\n" +
                        "4) If edit fails once, use `write` tool instead")</span>
        }

        // Fallback to original error
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tools

import (
        "context"
        "log/slog"
        "os/exec"
)

// getFDCmd returns an fd command if available, or nil if not found
func getFDCmd(ctx context.Context) *exec.Cmd <span class="cov8" title="1">{
        if _, err := exec.LookPath("fd"); err != nil </span><span class="cov0" title="0">{
                // Try fdfind on Debian/Ubuntu
                if _, err := exec.LookPath("fdfind"); err != nil </span><span class="cov0" title="0">{
                        slog.Debug("fd/fdfind not found in $PATH. Will use built-in glob implementation.")
                        return nil
                }</span>
                <span class="cov0" title="0">slog.Info("Using fdfind for fast file searching")
                return exec.CommandContext(ctx, "fdfind")</span>
        }
        <span class="cov8" title="1">slog.Info("Using fd for fast file searching")
        return exec.CommandContext(ctx, "fd")</span>
}

// isFDInstalled checks if fd or fdfind is available
func isFDInstalled() bool <span class="cov8" title="1">{
        if _, err := exec.LookPath("fd"); err == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">if _, err := exec.LookPath("fdfind"); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
        "unicode/utf8"

        "charm.land/fantasy"
        md "github.com/JohannesKaufmann/html-to-markdown"
        "github.com/PuerkitoBio/goquery"
        "github.com/nexora/cli/internal/permission"
)

const FetchToolName = "fetch"

//go:embed fetch.md
var fetchDescription []byte

func NewFetchTool(permissions permission.Service, workingDir string, client *http.Client) fantasy.AgentTool <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                }
        }</span>

        <span class="cov0" title="0">return fantasy.NewParallelAgentTool(
                FetchToolName,
                string(fetchDescription),
                func(ctx context.Context, params FetchParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.URL == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("URL parameter is required"), nil
                        }</span>

                        <span class="cov0" title="0">format := strings.ToLower(params.Format)
                        if format != "text" &amp;&amp; format != "markdown" &amp;&amp; format != "html" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Format must be one of: text, markdown, html"), nil
                        }</span>

                        <span class="cov0" title="0">if !strings.HasPrefix(params.URL, "http://") &amp;&amp; !strings.HasPrefix(params.URL, "https://") </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("URL must start with http:// or https://"), nil
                        }</span>

                        <span class="cov0" title="0">sessionID := GetSessionFromContext(ctx)
                        if sessionID == "" </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
                        }</span>

                        <span class="cov0" title="0">p := permissions.Request(
                                permission.CreatePermissionRequest{
                                        SessionID:   sessionID,
                                        Path:        workingDir,
                                        ToolCallID:  call.ID,
                                        ToolName:    FetchToolName,
                                        Action:      "fetch",
                                        Description: fmt.Sprintf("Fetch content from URL: %s", params.URL),
                                        Params:      FetchPermissionsParams(params),
                                },
                        )

                        if !p </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                        }</span>

                        // Handle timeout with context
                        <span class="cov0" title="0">requestCtx := ctx
                        if params.Timeout &gt; 0 </span><span class="cov0" title="0">{
                                maxTimeout := 120 // 2 minutes
                                if params.Timeout &gt; maxTimeout </span><span class="cov0" title="0">{
                                        params.Timeout = maxTimeout
                                }</span>
                                <span class="cov0" title="0">var cancel context.CancelFunc
                                requestCtx, cancel = context.WithTimeout(ctx, time.Duration(params.Timeout)*time.Second)
                                defer cancel()</span>
                        }

                        <span class="cov0" title="0">req, err := http.NewRequestWithContext(requestCtx, "GET", params.URL, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to create request: %w", err)
                        }</span>

                        <span class="cov0" title="0">req.Header.Set("User-Agent", "nexora/1.0")

                        resp, err := client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to fetch URL: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()

                        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Request failed with status code: %d", resp.StatusCode)), nil
                        }</span>

                        <span class="cov0" title="0">maxSize := int64(5 * 1024 * 1024) // 5MB
                        body, err := io.ReadAll(io.LimitReader(resp.Body, maxSize))
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Failed to read response body: " + err.Error()), nil
                        }</span>

                        <span class="cov0" title="0">content := string(body)

                        isValidUt8 := utf8.ValidString(content)
                        if !isValidUt8 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Response content is not valid UTF-8"), nil
                        }</span>
                        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")

                        switch format </span>{
                        case "text":<span class="cov0" title="0">
                                if strings.Contains(contentType, "text/html") </span><span class="cov0" title="0">{
                                        text, err := extractTextFromHTML(content)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fantasy.NewTextErrorResponse("Failed to extract text from HTML: " + err.Error()), nil
                                        }</span>
                                        <span class="cov0" title="0">content = text</span>
                                }

                        case "markdown":<span class="cov0" title="0">
                                if strings.Contains(contentType, "text/html") </span><span class="cov0" title="0">{
                                        markdown, err := convertHTMLToMarkdown(content)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fantasy.NewTextErrorResponse("Failed to convert HTML to Markdown: " + err.Error()), nil
                                        }</span>
                                        <span class="cov0" title="0">content = markdown</span>
                                }

                                <span class="cov0" title="0">content = "```\n" + content + "\n```"</span>

                        case "html":<span class="cov0" title="0">
                                // return only the body of the HTML document
                                if strings.Contains(contentType, "text/html") </span><span class="cov0" title="0">{
                                        doc, err := goquery.NewDocumentFromReader(strings.NewReader(content))
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fantasy.NewTextErrorResponse("Failed to parse HTML: " + err.Error()), nil
                                        }</span>
                                        <span class="cov0" title="0">body, err := doc.Find("body").Html()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fantasy.NewTextErrorResponse("Failed to extract body from HTML: " + err.Error()), nil
                                        }</span>
                                        <span class="cov0" title="0">if body == "" </span><span class="cov0" title="0">{
                                                return fantasy.NewTextErrorResponse("No body content found in HTML"), nil
                                        }</span>
                                        <span class="cov0" title="0">content = "&lt;html&gt;\n&lt;body&gt;\n" + body + "\n&lt;/body&gt;\n&lt;/html&gt;"</span>
                                }
                        }
                        // calculate byte size of content
                        <span class="cov0" title="0">contentSize := int64(len(content))
                        if contentSize &gt; MaxReadSize </span><span class="cov0" title="0">{
                                content = content[:MaxReadSize]
                                content += fmt.Sprintf("\n\n[Content truncated to %d bytes]", MaxReadSize)
                        }</span>

                        <span class="cov0" title="0">return fantasy.NewTextResponse(content), nil</span>
                })
}

func extractTextFromHTML(html string) (string, error) <span class="cov0" title="0">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">text := doc.Find("body").Text()
        text = strings.Join(strings.Fields(text), " ")

        return text, nil</span>
}

func convertHTMLToMarkdown(html string) (string, error) <span class="cov0" title="0">{
        converter := md.NewConverter("", true, nil)

        markdown, err := converter.ConvertString(html)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return markdown, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tools

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strings"
        "unicode/utf8"

        md "github.com/JohannesKaufmann/html-to-markdown"
        "golang.org/x/net/html"
)

// BrowserUserAgent is a realistic browser User-Agent for better compatibility.
const BrowserUserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

// FetchURLAndConvert fetches a URL and converts HTML content to markdown.
func FetchURLAndConvert(ctx context.Context, client *http.Client, url string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Use realistic browser headers for better compatibility.
        <span class="cov0" title="0">req.Header.Set("User-Agent", BrowserUserAgent)
        req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
        req.Header.Set("Accept-Language", "en-US,en;q=0.5")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fetch URL: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("request failed with status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">maxSize := int64(5 * 1024 * 1024) // 5MB
        body, err := io.ReadAll(io.LimitReader(resp.Body, maxSize))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">content := string(body)

        if !utf8.ValidString(content) </span><span class="cov0" title="0">{
                return "", errors.New("response content is not valid UTF-8")
        }</span>

        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")

        // Convert HTML to markdown for better AI processing.
        if strings.Contains(contentType, "text/html") </span><span class="cov0" title="0">{
                // Remove noisy elements before conversion.
                cleanedHTML := removeNoisyElements(content)
                markdown, err := ConvertHTMLToMarkdown(cleanedHTML)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to convert HTML to markdown: %w", err)
                }</span>
                <span class="cov0" title="0">content = cleanupMarkdown(markdown)</span>
        } else<span class="cov0" title="0"> if strings.Contains(contentType, "application/json") || strings.Contains(contentType, "text/json") </span><span class="cov0" title="0">{
                // Format JSON for better readability.
                formatted, err := FormatJSON(content)
                if err == nil </span><span class="cov0" title="0">{
                        content = formatted
                }</span>
                // If formatting fails, keep original content.
        }

        <span class="cov0" title="0">return content, nil</span>
}

// removeNoisyElements removes script, style, nav, header, footer, and other
// noisy elements from HTML to improve content extraction.
func removeNoisyElements(htmlContent string) string <span class="cov0" title="0">{
        doc, err := html.Parse(strings.NewReader(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                // If parsing fails, return original content.
                return htmlContent
        }</span>

        // Elements to remove entirely.
        <span class="cov0" title="0">noisyTags := map[string]bool{
                "script":   true,
                "style":    true,
                "nav":      true,
                "header":   true,
                "footer":   true,
                "aside":    true,
                "noscript": true,
                "iframe":   true,
                "svg":      true,
        }

        var removeNodes func(*html.Node)
        removeNodes = func(n *html.Node) </span><span class="cov0" title="0">{
                var toRemove []*html.Node

                for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                        if c.Type == html.ElementNode &amp;&amp; noisyTags[c.Data] </span><span class="cov0" title="0">{
                                toRemove = append(toRemove, c)
                        }</span> else<span class="cov0" title="0"> {
                                removeNodes(c)
                        }</span>
                }

                <span class="cov0" title="0">for _, node := range toRemove </span><span class="cov0" title="0">{
                        n.RemoveChild(node)
                }</span>
        }

        <span class="cov0" title="0">removeNodes(doc)

        var buf bytes.Buffer
        if err := html.Render(&amp;buf, doc); err != nil </span><span class="cov0" title="0">{
                return htmlContent
        }</span>

        <span class="cov0" title="0">return buf.String()</span>
}

// cleanupMarkdown removes excessive whitespace and blank lines from markdown.
func cleanupMarkdown(content string) string <span class="cov0" title="0">{
        // Collapse multiple blank lines into at most two.
        multipleNewlines := regexp.MustCompile(`\n{3,}`)
        content = multipleNewlines.ReplaceAllString(content, "\n\n")

        // Remove trailing whitespace from each line.
        lines := strings.Split(content, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                lines[i] = strings.TrimRight(line, " \t")
        }</span>
        <span class="cov0" title="0">content = strings.Join(lines, "\n")

        // Trim leading/trailing whitespace.
        content = strings.TrimSpace(content)

        return content</span>
}

// ConvertHTMLToMarkdown converts HTML content to markdown format.
func ConvertHTMLToMarkdown(htmlContent string) (string, error) <span class="cov0" title="0">{
        converter := md.NewConverter("", true, nil)

        markdown, err := converter.ConvertString(htmlContent)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return markdown, nil</span>
}

// FormatJSON formats JSON content with proper indentation.
func FormatJSON(content string) (string, error) <span class="cov0" title="0">{
        var data any
        if err := json.Unmarshal([]byte(content), &amp;data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        encoder := json.NewEncoder(&amp;buf)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tools

import (
        "sync"
        "time"
)

// File record to track when files were read/written
type fileRecord struct {
        path      string
        readTime  time.Time
        writeTime time.Time
}

var (
        fileRecords     = make(map[string]fileRecord)
        fileRecordMutex sync.RWMutex
)

func recordFileRead(path string) <span class="cov8" title="1">{
        fileRecordMutex.Lock()
        defer fileRecordMutex.Unlock()

        record, exists := fileRecords[path]
        if !exists </span><span class="cov8" title="1">{
                record = fileRecord{path: path}
        }</span>
        <span class="cov8" title="1">record.readTime = time.Now()
        fileRecords[path] = record</span>
}

func getLastReadTime(path string) time.Time <span class="cov0" title="0">{
        fileRecordMutex.RLock()
        defer fileRecordMutex.RUnlock()

        record, exists := fileRecords[path]
        if !exists </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return record.readTime</span>
}

func recordFileWrite(path string) <span class="cov0" title="0">{
        fileRecordMutex.Lock()
        defer fileRecordMutex.Unlock()

        record, exists := fileRecords[path]
        if !exists </span><span class="cov0" title="0">{
                record = fileRecord{path: path}
        }</span>
        <span class="cov0" title="0">record.writeTime = time.Now()
        fileRecords[path] = record</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/fsext"
        "github.com/nexora/cli/internal/permission"
)

const FindToolName = "find"

// find.md contains the documentation for the Find tool
//
//go:embed find.md
var findDescription []byte

type FindParams struct {
        Pattern    string `json:"pattern,omitempty" description:"Filename pattern to search for (supports glob patterns like *.go)"`
        Path       string `json:"path,omitempty" description:"The directory to search in. Defaults to current working directory."`
        Type       string `json:"type,omitempty" description:"Type of file to find: 'f' for files, 'd' for directories, empty for both"`
        Contains   string `json:"contains,omitempty" description:"Text content to search for within files (slower search)"`
        MaxResults int    `json:"max_results,omitempty" description:"Maximum number of results to return (default: 100)"`
}

type FindPermissionsParams struct {
        Pattern    string
        Path       string
        Type       string
        Contains   string
        MaxResults int
}

type FindResult struct {
        Path     string `json:"path"`
        Type     string `json:"type"`
        Size     int64  `json:"size,omitempty"`
        Modified string `json:"modified,omitempty"`
}

type FindResponseMetadata struct {
        NumberOfResults int    `json:"number_of_results"`
        Truncated       bool   `json:"truncated"`
        ToolUsed        string `json:"tool_used"`
}

func NewFindTool(permissions permission.Service, workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                FindToolName,
                string(findDescription),
                func(ctx context.Context, params FindParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        // Set defaults
                        if params.MaxResults &lt;= 0 || params.MaxResults &gt; 1000 </span><span class="cov0" title="0">{
                                params.MaxResults = 100
                        }</span>

                        <span class="cov0" title="0">searchPath := params.Path
                        if searchPath == "" </span><span class="cov0" title="0">{
                                searchPath = workingDir
                        }</span>
                        <span class="cov0" title="0">absPath, err := filepath.Abs(searchPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("invalid path: %v", err)), nil
                        }</span>

                        // Permission checking - currently handled at higher level by the agent framework
                        // Future enhancement: Add explicit permission validation for security-sensitive paths
                        // This could include:
                        // - Checking file system permissions before search
                        // - Validating path doesn't access system-critical directories
                        // - Implementing user denylist patterns for sensitive locations

                        // Perform the search
                        <span class="cov0" title="0">results, toolUsed, err := findFiles(ctx, params, absPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("search failed: %v", err)), nil
                        }</span>

                        // Format output
                        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                                return fantasy.WithResponseMetadata(
                                        fantasy.NewTextResponse("No matching files found"),
                                        FindResponseMetadata{
                                                NumberOfResults: 0,
                                                Truncated:       false,
                                                ToolUsed:        toolUsed,
                                        },
                                ), nil
                        }</span>

                        <span class="cov0" title="0">var output strings.Builder
                        fmt.Fprintf(&amp;output, "Found %d matching item(s):\n\n", len(results))

                        for _, result := range results </span><span class="cov0" title="0">{
                                icon := "📄"
                                if result.Type == "d" </span><span class="cov0" title="0">{
                                        icon = "📁"
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(&amp;output, "%s %s", icon, result.Path)
                                if result.Type == "f" </span><span class="cov0" title="0">{
                                        fmt.Fprintf(&amp;output, " (%d bytes)", result.Size)
                                }</span>
                                <span class="cov0" title="0">if result.Modified != "" </span><span class="cov0" title="0">{
                                        fmt.Fprintf(&amp;output, " [modified: %s]", result.Modified)
                                }</span>
                                <span class="cov0" title="0">output.WriteString("\n")</span>
                        }

                        <span class="cov0" title="0">truncated := len(results) &gt;= params.MaxResults
                        if truncated </span><span class="cov0" title="0">{
                                output.WriteString(fmt.Sprintf("\n(Results truncated at %d items. Use max_results parameter to see more.)", params.MaxResults))
                        }</span>

                        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                                fantasy.NewTextResponse(output.String()),
                                FindResponseMetadata{
                                        NumberOfResults: len(results),
                                        Truncated:       truncated,
                                        ToolUsed:        toolUsed,
                                },
                        ), nil</span>
                },
        )
}

func findFiles(ctx context.Context, params FindParams, searchPath string) ([]FindResult, string, error) <span class="cov0" title="0">{
        // Try fd first if no content search is needed
        if params.Contains == "" </span><span class="cov0" title="0">{
                if results, err := findWithFD(ctx, params, searchPath); err == nil </span><span class="cov0" title="0">{
                        return results, "fd", nil
                }</span>
        }

        // Fallback to ripgrep for pattern/content search
        <span class="cov0" title="0">if results, err := findWithRipGrep(ctx, params, searchPath); err == nil </span><span class="cov0" title="0">{
                return results, "ripgrep", nil
        }</span>

        // Final fallback to simple directory listing
        <span class="cov0" title="0">if results, err := findSimple(ctx, params, searchPath); err == nil </span><span class="cov0" title="0">{
                return results, "simple", nil
        }</span>

        <span class="cov0" title="0">return nil, "none", fmt.Errorf("all search methods failed")</span>
}

func findWithFD(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) <span class="cov0" title="0">{
        fdCmd := getFDCmd(ctx)
        if fdCmd == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fd not available")
        }</span>

        <span class="cov0" title="0">fdCmd.Dir = searchPath

        // Build fd arguments
        args := []string{"--absolute-path", "--color=never"}

        if params.Type == "f" </span><span class="cov0" title="0">{
                args = append(args, "--type", "file")
        }</span> else<span class="cov0" title="0"> if params.Type == "d" </span><span class="cov0" title="0">{
                args = append(args, "--type", "directory")
        }</span>

        <span class="cov0" title="0">if params.Pattern != "" </span><span class="cov0" title="0">{
                args = append(args, params.Pattern)
        }</span>

        // Limit results
        <span class="cov0" title="0">args = append(args, "--max-results", fmt.Sprintf("%d", params.MaxResults))

        fdCmd.Args = args

        // Execute with timeout
        output, err := fdCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fd command failed: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        results := make([]FindResult, 0, len(lines))

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">info, err := filepath.Abs(line)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fileInfo, err := os.Stat(info)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">typ := "f"
                if fileInfo.IsDir() </span><span class="cov0" title="0">{
                        typ = "d"
                }</span>

                <span class="cov0" title="0">result := FindResult{
                        Path: info,
                        Type: typ,
                        Size: fileInfo.Size(),
                }

                if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        result.Modified = fileInfo.ModTime().Format("2006-01-02 15:04:05")
                }</span>

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        // Sort by type (directories first) then by name
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                if results[i].Type != results[j].Type </span><span class="cov0" title="0">{
                        return results[i].Type &gt; results[j].Type // directories (d) &gt; files (f)
                }</span>
                <span class="cov0" title="0">return results[i].Path &lt; results[j].Path</span>
        })

        <span class="cov0" title="0">return results, nil</span>
}

func findWithRipGrep(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) <span class="cov0" title="0">{
        // Build ripgrep command for pattern matching
        if params.Pattern == "" &amp;&amp; params.Contains == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no pattern or content specified for ripgrep search")
        }</span>

        <span class="cov0" title="0">pattern := params.Pattern
        if params.Contains != "" </span><span class="cov0" title="0">{
                pattern = params.Contains
        }</span>

        <span class="cov0" title="0">rgCmd := getRgSearchCmd(ctx, pattern, searchPath, "")
        if rgCmd == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ripgrep not available")
        }</span>

        // Configure ripgrep settings
        <span class="cov0" title="0">rgCmd.Args = append(rgCmd.Args,
                "--absolute-path",
                "--no-heading",
                "--with-filename",
                "--line-number",
                "--max-count", "1", // Only one line per file for speed
        )

        if params.Type == "f" </span><span class="cov0" title="0">{
                rgCmd.Args = append(rgCmd.Args, "--type", "file")
        }</span> else<span class="cov0" title="0"> if params.Type == "d" </span><span class="cov0" title="0">{
                // Ripgrep doesn't search directories, so skip
                return []FindResult{}, nil
        }</span>

        // Execute with timeout
        <span class="cov0" title="0">output, err := rgCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ripgrep command failed: %w", err)
        }</span>

        // Parse output - we only need file paths
        <span class="cov0" title="0">seen := make(map[string]bool)
        results := make([]FindResult, 0, params.MaxResults)

        lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract path from ripgrep output (format: filename:line:content)
                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 3)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filePath := parts[0]
                if _, exists := seen[filePath]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">seen[filePath] = true
                absPath, err := filepath.Abs(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fileInfo, err := os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">result := FindResult{
                        Path:     absPath,
                        Type:     "f",
                        Size:     fileInfo.Size(),
                        Modified: fileInfo.ModTime().Format("2006-01-02 15:04:05"),
                }

                results = append(results, result)

                if len(results) &gt;= params.MaxResults </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return results, nil</span>
}

func findSimple(ctx context.Context, params FindParams, searchPath string) ([]FindResult, error) <span class="cov0" title="0">{
        // Simple directory listing as fallback
        files, _, err := fsext.ListDirectory(searchPath, nil, 0, params.MaxResults)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([]FindResult, 0, len(files))

        for _, file := range files </span><span class="cov0" title="0">{
                absPath, err := filepath.Abs(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fileInfo, err := os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">typ := "f"
                if fileInfo.IsDir() </span><span class="cov0" title="0">{
                        typ = "d"
                }</span>

                // Apply pattern filter if specified
                <span class="cov0" title="0">if params.Pattern != "" </span><span class="cov0" title="0">{
                        matched, err := filepath.Match(params.Pattern, filepath.Base(file))
                        if err != nil || !matched </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">result := FindResult{
                        Path: file,
                        Type: typ,
                        Size: fileInfo.Size(),
                }

                if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        result.Modified = fileInfo.ModTime().Format("2006-01-02 15:04:05")
                }</span>

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tools

import (
        "strings"
)

// normalizeAllWhitespace normalizes all whitespace for fuzzy matching
// Converts tabs to spaces, trims lines, but preserves structure
func normalizeAllWhitespace(s string) string <span class="cov8" title="1">{
        lines := strings.Split(s, "\n")
        normalized := make([]string, len(lines))
        for i, line := range lines </span><span class="cov8" title="1">{
                // Replace tabs with 4 spaces
                line = strings.ReplaceAll(line, "\t", "    ")
                // Preserve relative indentation but normalize
                normalized[i] = line
        }</span>
        <span class="cov8" title="1">return strings.Join(normalized, "\n")</span>
}

// matchByLineContent attempts to match content line-by-line, ignoring leading whitespace
// Returns the byte offset if found, -1 otherwise
func matchByLineContent(content, target string) int <span class="cov8" title="1">{
        targetLines := strings.Split(target, "\n")
        contentLines := strings.Split(content, "\n")

        if len(targetLines) == 0 || len(targetLines) &gt; len(contentLines) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Try to find a sequence of lines that match when trimmed
        <span class="cov8" title="1">for i := 0; i &lt;= len(contentLines)-len(targetLines); i++ </span><span class="cov8" title="1">{
                match := true
                for j, targetLine := range targetLines </span><span class="cov8" title="1">{
                        contentLine := contentLines[i+j]
                        // Compare trimmed versions
                        if strings.TrimSpace(contentLine) != strings.TrimSpace(targetLine) </span><span class="cov8" title="1">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        // Calculate byte offset for this match
                        offset := 0
                        for k := 0; k &lt; i; k++ </span><span class="cov8" title="1">{
                                offset += len(contentLines[k]) + 1 // +1 for newline
                        }</span>
                        <span class="cov8" title="1">return offset</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}

// matchResult represents the result of a fuzzy match attempt
type matchResult struct {
        exactMatch    string
        confidence    float64
        byteOffset    int
        matchStrategy string
}

// findBestMatch attempts fuzzy matching with confidence scoring
// Returns nil if no match found above confidence threshold
func findBestMatch(content, target string) *matchResult <span class="cov8" title="1">{
        // 1. Try exact match first
        if idx := strings.Index(content, target); idx != -1 </span><span class="cov8" title="1">{
                return &amp;matchResult{
                        exactMatch:    target,
                        confidence:    1.0,
                        byteOffset:    idx,
                        matchStrategy: "exact",
                }
        }</span>

        // 2. Try with tab normalization
        <span class="cov8" title="1">normalizedTarget := normalizeTabIndicators(target)
        if idx := strings.Index(content, normalizedTarget); idx != -1 </span><span class="cov8" title="1">{
                return &amp;matchResult{
                        exactMatch:    normalizedTarget,
                        confidence:    0.95,
                        byteOffset:    idx,
                        matchStrategy: "tab_normalized",
                }
        }</span>

        // 3. Try line-by-line matching (ignoring leading whitespace)
        <span class="cov8" title="1">if idx := matchByLineContent(content, target); idx != -1 </span><span class="cov8" title="1">{
                // Extract the actual content at this location
                lines := strings.Split(content, "\n")
                targetLines := strings.Split(target, "\n")
                startLine := strings.Count(content[:idx], "\n")
                endLine := startLine + len(targetLines)
                if endLine &lt;= len(lines) </span><span class="cov8" title="1">{
                        actualMatch := strings.Join(lines[startLine:endLine], "\n")
                        return &amp;matchResult{
                                exactMatch:    actualMatch,
                                confidence:    0.90,
                                byteOffset:    idx,
                                matchStrategy: "line_content_match",
                        }
                }</span>
        }

        // 4. Try with full whitespace normalization (lower confidence)
        <span class="cov8" title="1">normalizedContent := normalizeAllWhitespace(content)
        normalizedTarget = normalizeAllWhitespace(target)
        if idx := strings.Index(normalizedContent, normalizedTarget); idx != -1 </span><span class="cov0" title="0">{
                return &amp;matchResult{
                        exactMatch:    "",
                        confidence:    0.80,
                        byteOffset:    idx,
                        matchStrategy: "whitespace_normalized",
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tools

import (
        "bytes"
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/fsext"
)

const GlobToolName = "glob"

//go:embed glob.md
var globDescription []byte

type GlobParams struct {
        Pattern string `json:"pattern" description:"The glob pattern to match files against"`
        Path    string `json:"path,omitempty" description:"The directory to search in. Defaults to the current working directory."`
}

type GlobResponseMetadata struct {
        NumberOfFiles int  `json:"number_of_files"`
        Truncated     bool `json:"truncated"`
}

func NewGlobTool(workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                GlobToolName,
                string(globDescription),
                func(ctx context.Context, params GlobParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Pattern == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("pattern is required"), nil
                        }</span>

                        <span class="cov0" title="0">searchPath := params.Path
                        if searchPath == "" </span><span class="cov0" title="0">{
                                searchPath = workingDir
                        }</span>

                        <span class="cov0" title="0">files, truncated, err := globFiles(ctx, params.Pattern, searchPath, 100)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error finding files: %w", err)
                        }</span>

                        <span class="cov0" title="0">var output string
                        if len(files) == 0 </span><span class="cov0" title="0">{
                                output = "No files found"
                        }</span> else<span class="cov0" title="0"> {
                                normalizeFilePaths(files)
                                output = strings.Join(files, "\n")
                                if truncated </span><span class="cov0" title="0">{
                                        output += "\n\n(Results are truncated. Consider using a more specific path or pattern.)"
                                }</span>
                        }

                        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                                fantasy.NewTextResponse(output),
                                GlobResponseMetadata{
                                        NumberOfFiles: len(files),
                                        Truncated:     truncated,
                                },
                        ), nil</span>
                })
}

func globFiles(ctx context.Context, pattern, searchPath string, limit int) ([]string, bool, error) <span class="cov8" title="1">{
        cmdRg := getRgCmd(ctx, pattern)
        if cmdRg != nil </span><span class="cov8" title="1">{
                cmdRg.Dir = searchPath
                matches, err := runRipgrep(cmdRg, searchPath, limit)
                if err == nil </span><span class="cov8" title="1">{
                        return matches, len(matches) &gt;= limit &amp;&amp; limit &gt; 0, nil
                }</span>
                <span class="cov0" title="0">slog.Warn("Ripgrep execution failed, falling back to doublestar", "error", err)</span>
        }

        <span class="cov0" title="0">return fsext.GlobWithDoubleStar(pattern, searchPath, limit)</span>
}

func runRipgrep(cmd *exec.Cmd, searchRoot string, limit int) ([]string, error) <span class="cov8" title="1">{
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                if ee, ok := err.(*exec.ExitError); ok &amp;&amp; ee.ExitCode() == 1 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("ripgrep: %w\n%s", err, out)</span>
        }

        <span class="cov8" title="1">var matches []string
        for p := range bytes.SplitSeq(out, []byte{0}) </span><span class="cov8" title="1">{
                if len(p) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">absPath := string(p)
                if !filepath.IsAbs(absPath) </span><span class="cov8" title="1">{
                        absPath = filepath.Join(searchRoot, absPath)
                }</span>
                <span class="cov8" title="1">if fsext.SkipHidden(absPath) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">matches = append(matches, absPath)</span>
        }

        <span class="cov8" title="1">sort.SliceStable(matches, func(i, j int) bool </span><span class="cov8" title="1">{
                return len(matches[i]) &lt; len(matches[j])
        }</span>)

        <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; len(matches) &gt; limit </span><span class="cov8" title="1">{
                matches = matches[:limit]
        }</span>
        <span class="cov8" title="1">return matches, nil</span>
}

func normalizeFilePaths(paths []string) <span class="cov8" title="1">{
        for i, p := range paths </span><span class="cov8" title="1">{
                paths[i] = filepath.ToSlash(p)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tools

import (
        "bufio"
        "bytes"
        "context"
        _ "embed"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "sync"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/fsext"
)

// regexCache provides thread-safe caching of compiled regex patterns
type regexCache struct {
        cache map[string]*regexp.Regexp
        mu    sync.RWMutex
}

// newRegexCache creates a new regex cache
func newRegexCache() *regexCache <span class="cov8" title="1">{
        return &amp;regexCache{
                cache: make(map[string]*regexp.Regexp),
        }
}</span>

// get retrieves a compiled regex from cache or compiles and caches it
func (rc *regexCache) get(pattern string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        // Try to get from cache first (read lock)
        rc.mu.RLock()
        if regex, exists := rc.cache[pattern]; exists </span><span class="cov8" title="1">{
                rc.mu.RUnlock()
                return regex, nil
        }</span>
        <span class="cov8" title="1">rc.mu.RUnlock()

        // Compile the regex (write lock)
        rc.mu.Lock()
        defer rc.mu.Unlock()

        // Double-check in case another goroutine compiled it while we waited
        if regex, exists := rc.cache[pattern]; exists </span><span class="cov0" title="0">{
                return regex, nil
        }</span>

        // Compile and cache the regex
        <span class="cov8" title="1">regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rc.cache[pattern] = regex
        return regex, nil</span>
}

// Global regex cache instances
var (
        searchRegexCache = newRegexCache()
        globRegexCache   = newRegexCache()
        // Pre-compiled regex for glob conversion (used frequently)
        globBraceRegex = regexp.MustCompile(`\{([^}]+)\}`)
)

type GrepParams struct {
        Pattern     string `json:"pattern" description:"The regex pattern to search for in file contents"`
        Path        string `json:"path,omitempty" description:"The directory to search in. Defaults to the current working directory."`
        Include     string `json:"include,omitempty" description:"File pattern to include in the search (e.g. \"*.js\", \"*.{ts,tsx}\")"`
        LiteralText bool   `json:"literal_text,omitempty" description:"If true, the pattern will be treated as literal text with special regex characters escaped. Default is false."`
}

type grepMatch struct {
        path     string
        modTime  time.Time
        lineNum  int
        charNum  int
        lineText string
}

type GrepResponseMetadata struct {
        NumberOfMatches int  `json:"number_of_matches"`
        Truncated       bool `json:"truncated"`
}

const (
        GrepToolName        = "grep"
        maxGrepContentWidth = 500
)

//go:embed grep.md
var grepDescription []byte

// escapeRegexPattern escapes special regex characters so they're treated as literal characters
func escapeRegexPattern(pattern string) string <span class="cov0" title="0">{
        specialChars := []string{"\\", ".", "+", "*", "?", "(", ")", "[", "]", "{", "}", "^", "$", "|"}
        escaped := pattern

        for _, char := range specialChars </span><span class="cov0" title="0">{
                escaped = strings.ReplaceAll(escaped, char, "\\"+char)
        }</span>

        <span class="cov0" title="0">return escaped</span>
}

func NewGrepTool(workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                GrepToolName,
                string(grepDescription),
                func(ctx context.Context, params GrepParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Pattern == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("pattern is required"), nil
                        }</span>

                        // If literal_text is true, escape the pattern
                        <span class="cov0" title="0">searchPattern := params.Pattern
                        if params.LiteralText </span><span class="cov0" title="0">{
                                searchPattern = escapeRegexPattern(params.Pattern)
                        }</span>

                        <span class="cov0" title="0">searchPath := params.Path
                        if searchPath == "" </span><span class="cov0" title="0">{
                                searchPath = workingDir
                        }</span>

                        // Create a child context with timeout for the entire search operation
                        <span class="cov0" title="0">searchCtx, cancel := context.WithTimeout(ctx, 90*time.Second)
                        defer cancel()

                        matches, truncated, err := searchFiles(searchCtx, searchPattern, searchPath, params.Include, 100)
                        if err != nil </span><span class="cov0" title="0">{
                                if searchCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse("search timed out after 90 seconds - the search area may be too large or contain problematic files"), nil
                                }</span>
                                <span class="cov0" title="0">if searchCtx.Err() == context.Canceled </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse("search was cancelled"), nil
                                }</span>
                                <span class="cov0" title="0">return fantasy.NewTextErrorResponse(fmt.Sprintf("error searching files: %v", err)), nil</span>
                        }

                        <span class="cov0" title="0">var output strings.Builder
                        if len(matches) == 0 </span><span class="cov0" title="0">{
                                output.WriteString("No files found")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(&amp;output, "Found %d matches\n", len(matches))

                                currentFile := ""
                                for _, match := range matches </span><span class="cov0" title="0">{
                                        if currentFile != match.path </span><span class="cov0" title="0">{
                                                if currentFile != "" </span><span class="cov0" title="0">{
                                                        output.WriteString("\n")
                                                }</span>
                                                <span class="cov0" title="0">currentFile = match.path
                                                fmt.Fprintf(&amp;output, "%s:\n", filepath.ToSlash(match.path))</span>
                                        }
                                        <span class="cov0" title="0">if match.lineNum &gt; 0 </span><span class="cov0" title="0">{
                                                lineText := match.lineText
                                                if len(lineText) &gt; maxGrepContentWidth </span><span class="cov0" title="0">{
                                                        lineText = lineText[:maxGrepContentWidth] + "..."
                                                }</span>
                                                <span class="cov0" title="0">if match.charNum &gt; 0 </span><span class="cov0" title="0">{
                                                        fmt.Fprintf(&amp;output, "  Line %d, Char %d: %s\n", match.lineNum, match.charNum, lineText)
                                                }</span> else<span class="cov0" title="0"> {
                                                        fmt.Fprintf(&amp;output, "  Line %d: %s\n", match.lineNum, lineText)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                fmt.Fprintf(&amp;output, "  %s\n", match.path)
                                        }</span>
                                }

                                <span class="cov0" title="0">if truncated </span><span class="cov0" title="0">{
                                        output.WriteString("\n(Results are truncated. Consider using a more specific path or pattern.)")
                                }</span>
                        }

                        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                                fantasy.NewTextResponse(output.String()),
                                GrepResponseMetadata{
                                        NumberOfMatches: len(matches),
                                        Truncated:       truncated,
                                },
                        ), nil</span>
                })
}

func searchFiles(ctx context.Context, pattern, rootPath, include string, limit int) ([]grepMatch, bool, error) <span class="cov0" title="0">{
        matches, err := searchWithRipgrep(ctx, pattern, rootPath, include)
        if err != nil </span><span class="cov0" title="0">{
                matches, err = searchFilesWithRegex(pattern, rootPath, include)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
        }

        <span class="cov0" title="0">sort.Slice(matches, func(i, j int) bool </span><span class="cov0" title="0">{
                return matches[i].modTime.After(matches[j].modTime)
        }</span>)

        <span class="cov0" title="0">truncated := len(matches) &gt; limit
        if truncated </span><span class="cov0" title="0">{
                matches = matches[:limit]
        }</span>

        <span class="cov0" title="0">return matches, truncated, nil</span>
}

func searchWithRipgrep(ctx context.Context, pattern, path, include string) ([]grepMatch, error) <span class="cov8" title="1">{
        // Create timeout context specifically for ripgrep command
        ripgrepCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        cmd := getRgSearchCmd(ripgrepCtx, pattern, path, include)
        if cmd == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ripgrep not found in $PATH")
        }</span>

        // Set safer parameters
        <span class="cov8" title="1">cmd.Args = append(cmd.Args, "--max-filesize", "50M")
        cmd.Args = append(cmd.Args, "--max-columns", "500")

        // Only add ignore files if they exist
        for _, ignoreFile := range []string{".gitignore", ".nexoraignore"} </span><span class="cov8" title="1">{
                ignorePath := filepath.Join(path, ignoreFile)
                if _, err := os.Stat(ignorePath); err == nil </span><span class="cov8" title="1">{
                        cmd.Args = append(cmd.Args, "--ignore-file", ignorePath)
                }</span>
        }

        // Use a separate goroutine to handle the command with timeout
        <span class="cov8" title="1">done := make(chan struct{})
        var (
                output []byte
                err    error
        )

        go func() </span><span class="cov8" title="1">{
                defer close(done)
                output, err = cmd.Output()
        }</span>()

        // Wait for either completion, timeout, or cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
                // Command completed normally
        case &lt;-ripgrepCtx.Done():<span class="cov0" title="0">
                // Context was cancelled or timed out
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        _ = cmd.Process.Kill() // Force kill the process
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("ripgrep search %w", ripgrepCtx.Err())</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok &amp;&amp; exitErr.ExitCode() == 1 </span><span class="cov0" title="0">{
                        return []grepMatch{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">var matches []grepMatch
        for line := range bytes.SplitSeq(bytes.TrimSpace(output), []byte{'\n'}) </span><span class="cov8" title="1">{
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var match ripgrepMatch
                if err := json.Unmarshal(line, &amp;match); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if match.Type != "match" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, m := range match.Data.Submatches </span><span class="cov8" title="1">{
                        fi, err := os.Stat(match.Data.Path.Text)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip files we can't access
                        }
                        <span class="cov8" title="1">matches = append(matches, grepMatch{
                                path:     match.Data.Path.Text,
                                modTime:  fi.ModTime(),
                                lineNum:  match.Data.LineNumber,
                                charNum:  m.Start + 1, // ensure 1-based
                                lineText: strings.TrimSpace(match.Data.Lines.Text),
                        })
                        // only get the first match of each line
                        break</span>
                }
        }
        <span class="cov8" title="1">return matches, nil</span>
}

type ripgrepMatch struct {
        Type string `json:"type"`
        Data struct {
                Path struct {
                        Text string `json:"text"`
                } `json:"path"`
                Lines struct {
                        Text string `json:"text"`
                } `json:"lines"`
                LineNumber int `json:"line_number"`
                Submatches []struct {
                        Start int `json:"start"`
                } `json:"submatches"`
        } `json:"data"`
}

func searchFilesWithRegex(pattern, rootPath, include string) ([]grepMatch, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        return searchFilesWithRegexContext(ctx, pattern, rootPath, include)
}</span>

// Separate function that accepts context
func searchFilesWithRegexContext(ctx context.Context, pattern, rootPath, include string) ([]grepMatch, error) <span class="cov8" title="1">{
        matches := []grepMatch{}

        // Use cached regex compilation
        regex, err := searchRegexCache.get(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid regex pattern: %w", err)
        }</span>

        <span class="cov8" title="1">var includePattern *regexp.Regexp
        if include != "" </span><span class="cov0" title="0">{
                regexPattern := globToRegex(include)
                includePattern, err = globRegexCache.get(regexPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid include pattern: %w", err)
                }</span>
        }

        // Create walker with gitignore and nexoraignore support
        <span class="cov8" title="1">walker := fsext.NewFastGlobWalker(rootPath)

        err = filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                // Check context cancellation first
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip errors
                }</span>

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Check if directory should be skipped
                        if walker.ShouldSkip(path) </span><span class="cov8" title="1">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span> // Continue into directory
                }

                // Use walker's shouldSkip method for files
                <span class="cov8" title="1">if walker.ShouldSkip(path) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Skip hidden files (starting with a dot) to match ripgrep's default behavior
                <span class="cov8" title="1">base := filepath.Base(path)
                if base != "." &amp;&amp; strings.HasPrefix(base, ".") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Skip very large files
                <span class="cov8" title="1">if info.Size() &gt; 50*1024*1024 </span><span class="cov0" title="0">{ // 50MB
                        return nil
                }</span>

                <span class="cov8" title="1">if includePattern != nil &amp;&amp; !includePattern.MatchString(path) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check file with timeout
                <span class="cov8" title="1">fileCtx, fileCancel := context.WithTimeout(ctx, 5*time.Second)
                match, lineNum, charNum, lineText, err := fileContainsPatternWithContext(fileCtx, path, regex)
                fileCancel()

                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip files we can't read
                }</span>

                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        matches = append(matches, grepMatch{
                                path:     path,
                                modTime:  info.ModTime(),
                                lineNum:  lineNum,
                                charNum:  charNum,
                                lineText: lineText,
                        })

                        if len(matches) &gt;= 200 </span><span class="cov0" title="0">{
                                return filepath.SkipAll
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file walk timed out after 60 seconds")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return matches, nil</span>
}

func fileContainsPattern(filePath string, pattern *regexp.Regexp) (bool, int, int, string, error) <span class="cov0" title="0">{
        return fileContainsPatternWithContext(context.Background(), filePath, pattern)
}</span>

// fileContainsMultiLinePattern searches for a pattern that may span multiple lines
// This is used for edit validation where the old_string might be a multi-line block
func fileContainsMultiLinePattern(filePath string, pattern *regexp.Regexp) (bool, int, int, string, error) <span class="cov0" title="0">{
        // Only search text files.
        if !isTextFile(filePath) </span><span class="cov0" title="0">{
                return false, 0, 0, "", nil
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, 0, "", err
        }</span>

        // Convert to string for regex matching
        <span class="cov0" title="0">fileContent := string(content)

        // Find the pattern in the entire content
        loc := pattern.FindStringIndex(fileContent)
        if loc == nil </span><span class="cov0" title="0">{
                return false, 0, 0, "", nil
        }</span>

        // Find the line numbers where the match starts and ends
        <span class="cov0" title="0">lines := strings.Split(fileContent, "\n")
        startLine := 0
        endLine := 0
        charPos := 0

        for i, line := range lines </span><span class="cov0" title="0">{
                lineLength := len(line) + 1 // +1 for newline character
                if charPos &lt;= loc[0] &amp;&amp; loc[0] &lt; charPos+lineLength </span><span class="cov0" title="0">{
                        startLine = i + 1 // 1-based line number
                }</span>
                <span class="cov0" title="0">if charPos &lt;= loc[1] &amp;&amp; loc[1] &lt; charPos+lineLength </span><span class="cov0" title="0">{
                        endLine = i + 1 // 1-based line number
                }</span>
                <span class="cov0" title="0">charPos += lineLength</span>
        }

        // Get the actual matched text
        <span class="cov0" title="0">matchedText := fileContent[loc[0]:loc[1]]

        return true, startLine, endLine, matchedText, nil</span>
}

// ValidateEditString confirms that old_string exists in the file before edit
// Returns error with detailed information if the pattern is not found or found multiple times
func ValidateEditString(filePath string, oldString string, replaceAll bool) error <span class="cov0" title="0">{
        if oldString == "" </span><span class="cov0" title="0">{
                return nil // No validation needed for empty old_string (file creation)
        }</span>

        // Create a literal pattern that matches the exact string
        <span class="cov0" title="0">pattern := regexp.MustCompile(regexp.QuoteMeta(oldString))

        // First try multi-line pattern matching for edit operations
        found, _, _, _, err := fileContainsMultiLinePattern(filePath, pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate edit string in file %s: %w", filePath, err)
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("old_string not found in file %s", filePath)
        }</span>

        <span class="cov0" title="0">if !replaceAll </span><span class="cov0" title="0">{
                // Check for multiple occurrences using multi-line search
                // Read the entire file content to count occurrences
                content, err := os.ReadFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read file for multiple occurrence check: %w", err)
                }</span>

                <span class="cov0" title="0">fileContent := string(content)
                occurrences := pattern.FindAllStringIndex(fileContent, -1)

                if len(occurrences) &gt; 1 </span><span class="cov0" title="0">{
                        // Get a sample of the second occurrence for the error message
                        sampleText := fileContent[occurrences[1][0]:occurrences[1][1]]
                        // Count lines to the second occurrence
                        lines := strings.Split(fileContent[:occurrences[1][0]], "\n")
                        return fmt.Errorf("old_string appears multiple times in file %s. Found at line %d: %s",
                                filePath, len(lines), strings.TrimSpace(sampleText))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// fileContainsPatternFromLine starts searching from a specific line number
func fileContainsPatternFromLine(filePath string, pattern *regexp.Regexp, startLine int) (bool, int, int, string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, 0, "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        lineNum := 0

        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                if lineNum &lt; startLine </span><span class="cov0" title="0">{
                        continue</span> // Skip lines before startLine
                }

                <span class="cov0" title="0">lineContent := scanner.Text()
                if pattern.MatchString(lineContent) </span><span class="cov0" title="0">{
                        colIndex := pattern.FindStringIndex(lineContent)
                        if len(colIndex) &gt; 0 </span><span class="cov0" title="0">{
                                return true, lineNum, colIndex[0], lineContent, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return false, 0, 0, "", nil</span>
}

func fileContainsPatternWithContext(ctx context.Context, filePath string, pattern *regexp.Regexp) (bool, int, int, string, error) <span class="cov8" title="1">{
        // Only search text files.
        if !isTextFile(filePath) </span><span class="cov0" title="0">{
                return false, 0, 0, "", nil
        }</span>

        <span class="cov8" title="1">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, 0, "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Use scanner with buffer size limits to handle very long lines
        scanner := bufio.NewScanner(file)
        buffer := make([]byte, 0, 64*1024) // 64KB initial buffer
        scanner.Buffer(buffer, 1024*1024)  // Max 1MB per line

        lineNum := 0
        for scanner.Scan() </span><span class="cov8" title="1">{
                // Check context cancellation frequently
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return false, 0, 0, "", ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">lineNum++
                line := scanner.Text()
                if loc := pattern.FindStringIndex(line); loc != nil </span><span class="cov8" title="1">{
                        charNum := loc[0] + 1
                        return true, lineNum, charNum, line, nil
                }</span>
        }

        <span class="cov8" title="1">return false, 0, 0, "", scanner.Err()</span>
}

// isTextFile checks if a file is a text file by examining its MIME type.
func isTextFile(filePath string) bool <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Read first 512 bytes for MIME type detection.
        buffer := make([]byte, 512)
        n, err := file.Read(buffer)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return false
        }</span>

        // Detect content type.
        <span class="cov8" title="1">contentType := http.DetectContentType(buffer[:n])

        // Check if it's a text MIME type.
        return strings.HasPrefix(contentType, "text/") ||
                contentType == "application/json" ||
                contentType == "application/xml" ||
                contentType == "application/javascript" ||
                contentType == "application/x-sh"</span>
}

func globToRegex(glob string) string <span class="cov8" title="1">{
        regexPattern := strings.ReplaceAll(glob, ".", "\\.")
        regexPattern = strings.ReplaceAll(regexPattern, "*", ".*")
        regexPattern = strings.ReplaceAll(regexPattern, "?", ".")

        // Use pre-compiled regex instead of compiling each time
        regexPattern = globBraceRegex.ReplaceAllStringFunc(regexPattern, func(match string) string </span><span class="cov8" title="1">{
                inner := match[1 : len(match)-1]
                return "(" + strings.ReplaceAll(inner, ",", "|") + ")"
        }</span>)

        <span class="cov8" title="1">return regexPattern</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tools

import (
        "context"
        "log/slog"

        "charm.land/fantasy"
)

// ToolHook is a centralized interception point for all tool calls
// Enables security validation, monitoring, and enhancement without code changes
type ToolHook interface {
        // BeforeCall executes before a tool is called
        // Return error to block execution
        BeforeCall(ctx context.Context, toolName string, params interface{}) error

        // AfterCall executes after a tool completes
        // Can inspect/modify response
        AfterCall(ctx context.Context, toolName string, response fantasy.ToolResponse) fantasy.ToolResponse

        // OnError executes when a tool returns an error
        OnError(ctx context.Context, toolName string, err error) error
}

// HookChain manages multiple hooks
type HookChain struct {
        hooks []ToolHook
}

// NewHookChain creates a new hook chain
func NewHookChain(hooks ...ToolHook) *HookChain <span class="cov0" title="0">{
        return &amp;HookChain{hooks: hooks}
}</span>

// BeforeCall executes all BeforeCall hooks
func (h *HookChain) BeforeCall(ctx context.Context, toolName string, params interface{}) error <span class="cov0" title="0">{
        for _, hook := range h.hooks </span><span class="cov0" title="0">{
                if err := hook.BeforeCall(ctx, toolName, params); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Tool hook blocked execution",
                                "tool", toolName,
                                "hook", nameOfHook(hook),
                                "error", err,
                        )
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AfterCall executes all AfterCall hooks
func (h *HookChain) AfterCall(ctx context.Context, toolName string, response fantasy.ToolResponse) fantasy.ToolResponse <span class="cov0" title="0">{
        for _, hook := range h.hooks </span><span class="cov0" title="0">{
                response = hook.AfterCall(ctx, toolName, response)
        }</span>
        <span class="cov0" title="0">return response</span>
}

// OnError executes all OnError hooks
func (h *HookChain) OnError(ctx context.Context, toolName string, err error) error <span class="cov0" title="0">{
        for _, hook := range h.hooks </span><span class="cov0" title="0">{
                if err := hook.OnError(ctx, toolName, err); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// ===================== Built-in Hooks =====================

// SecurityHook validates tool calls against security policies
type SecurityHook struct {
        // allowedTools: map of tool -&gt; allowed
        allowedTools map[string]bool
        // deniedPaths: paths that cannot be accessed
        deniedPaths []string
}

// NewSecurityHook creates a security hook
func NewSecurityHook(allowedTools []string, deniedPaths []string) *SecurityHook <span class="cov0" title="0">{
        allowed := make(map[string]bool)
        for _, t := range allowedTools </span><span class="cov0" title="0">{
                allowed[t] = true
        }</span>
        <span class="cov0" title="0">return &amp;SecurityHook{
                allowedTools: allowed,
                deniedPaths:  deniedPaths,
        }</span>
}

func (h *SecurityHook) BeforeCall(ctx context.Context, toolName string, params interface{}) error <span class="cov0" title="0">{
        // Check if tool is allowed
        if len(h.allowedTools) &gt; 0 &amp;&amp; !h.allowedTools[toolName] </span><span class="cov0" title="0">{
                return ErrToolNotAllowed(toolName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *SecurityHook) AfterCall(ctx context.Context, toolName string, response fantasy.ToolResponse) fantasy.ToolResponse <span class="cov0" title="0">{
        return response
}</span>

func (h *SecurityHook) OnError(ctx context.Context, toolName string, err error) error <span class="cov0" title="0">{
        return err
}</span>

// MetricsHook tracks tool performance metrics
type MetricsHook struct {
        metrics map[string]*ToolMetrics
}

// ToolMetrics holds performance metrics for a tool
type ToolMetrics struct {
        CallCount    int64
        ErrorCount   int64
        SuccessCount int64
        TotalTimeMS  float64
}

// NewMetricsHook creates a metrics hook
func NewMetricsHook() *MetricsHook <span class="cov0" title="0">{
        return &amp;MetricsHook{
                metrics: make(map[string]*ToolMetrics),
        }
}</span>

func (h *MetricsHook) BeforeCall(ctx context.Context, toolName string, params interface{}) error <span class="cov0" title="0">{
        if _, exists := h.metrics[toolName]; !exists </span><span class="cov0" title="0">{
                h.metrics[toolName] = &amp;ToolMetrics{}
        }</span>
        <span class="cov0" title="0">h.metrics[toolName].CallCount++
        return nil</span>
}

func (h *MetricsHook) AfterCall(ctx context.Context, toolName string, response fantasy.ToolResponse) fantasy.ToolResponse <span class="cov0" title="0">{
        if !response.IsError </span><span class="cov0" title="0">{
                h.metrics[toolName].SuccessCount++
        }</span>
        <span class="cov0" title="0">return response</span>
}

func (h *MetricsHook) OnError(ctx context.Context, toolName string, err error) error <span class="cov0" title="0">{
        h.metrics[toolName].ErrorCount++
        return err
}</span>

// GetMetrics returns metrics for a specific tool
func (h *MetricsHook) GetMetrics(toolName string) *ToolMetrics <span class="cov0" title="0">{
        return h.metrics[toolName]
}</span>

// AllMetrics returns all metrics
func (h *MetricsHook) AllMetrics() map[string]*ToolMetrics <span class="cov0" title="0">{
        return h.metrics
}</span>

// ===================== Helpers =====================

func nameOfHook(h ToolHook) string <span class="cov0" title="0">{
        switch h.(type) </span>{
        case *SecurityHook:<span class="cov0" title="0">
                return "SecurityHook"</span>
        case *MetricsHook:<span class="cov0" title="0">
                return "MetricsHook"</span>
        default:<span class="cov0" title="0">
                return "UnknownHook"</span>
        }
}

// HookError types
type HookError struct {
        msg string
}

func (e *HookError) Error() string <span class="cov0" title="0">{
        return e.msg
}</span>

func ErrToolNotAllowed(toolName string) error <span class="cov0" title="0">{
        return &amp;HookError{msg: "tool not allowed: " + toolName}
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package tools

import (
        "context"
        "fmt"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/indexer"
)

type ImpactAnalysisParams struct {
        SymbolID string `json:"symbol_id" description:"ID of the symbol to analyze"`
        MaxDepth int    `json:"max_depth,omitempty" description:"Maximum depth for transitive analysis (default: 3)"`
}

// NewImpactAnalysisTool creates a new impact analysis tool
func NewImpactAnalysisTool(queryEngine *indexer.QueryEngine, graph *indexer.Graph) fantasy.AgentTool <span class="cov8" title="1">{
        return fantasy.NewAgentTool(
                "impact_analysis",
                "Analyze the impact of changes to a symbol using dependency graphs and call relationships",
                func(ctx context.Context, params ImpactAnalysisParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if graph == nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("impact analysis tool is not available - graph not initialized"), nil
                        }</span>

                        <span class="cov0" title="0">if params.SymbolID == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("symbol_id parameter is required"), nil
                        }</span>

                        // Set defaults
                        <span class="cov0" title="0">if params.MaxDepth == 0 </span><span class="cov0" title="0">{
                                params.MaxDepth = 3
                        }</span>

                        // Get the symbol information
                        <span class="cov0" title="0">symbol, err := getSymbolInfo(ctx, params.SymbolID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Failed to get symbol info: %v", err)), nil
                        }</span>
                        <span class="cov0" title="0">if symbol == nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Symbol '%s' not found", params.SymbolID)), nil
                        }</span>

                        // Perform impact analysis
                        <span class="cov0" title="0">analysis := graph.GetImpactAnalysis(params.SymbolID, params.MaxDepth)

                        // Format results
                        output := formatImpactAnalysis(symbol, analysis, params.MaxDepth)
                        return fantasy.NewTextResponse(output), nil</span>
                },
        )
}

// getSymbolInfo retrieves symbol information from storage
func getSymbolInfo(ctx context.Context, symbolID string) (*indexer.Symbol, error) <span class="cov0" title="0">{
        // This is a simplified implementation - in practice, this would use the storage layer
        // For now, we'll return a mock symbol structure
        return &amp;indexer.Symbol{
                Name:    symbolID,
                Type:    "function",
                Package: "main",
                File:    fmt.Sprintf("%s.go", symbolID),
                Line:    1,
        }, nil
}</span>

// formatImpactAnalysis formats the impact analysis results for display
func formatImpactAnalysis(symbol *indexer.Symbol, analysis indexer.ImpactAnalysis, maxDepth int) string <span class="cov0" title="0">{
        var output strings.Builder

        // Header
        output.WriteString(fmt.Sprintf("🔬 Impact Analysis for: **%s** `%s`\n", symbol.Name, symbol.Type))
        output.WriteString(fmt.Sprintf("📍 Location: %s:%d\n\n", symbol.File, symbol.Line))

        // Analysis depth
        output.WriteString(fmt.Sprintf("🔍 Analysis depth: %d levels\n\n", maxDepth))

        // Direct relationships
        output.WriteString("## Direct Relationships\n\n")

        if len(analysis.DirectCalls) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("### 📞 Functions Called (Downstream)\n")
                for i, call := range analysis.DirectCalls </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `%s`\n", i+1, call))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if len(analysis.DirectCallers) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("### 📞 Functions Called By (Upstream)\n")
                for i, caller := range analysis.DirectCallers </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `%s`\n", i+1, caller))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        // Dependencies
        <span class="cov0" title="0">output.WriteString("## Dependencies\n\n")

        if len(analysis.UpstreamDeps) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("### ⬆️ Upstream Dependencies\n")
                output.WriteString("Functions/packages this symbol depends on:\n")
                for i, dep := range analysis.UpstreamDeps </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `%s`\n", i+1, dep))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if len(analysis.DownstreamDeps) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("### ⬇️ Downstream Dependencies\n")
                output.WriteString("Functions/packages that depend on this symbol:\n")
                for i, dep := range analysis.DownstreamDeps </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `%s`\n", i+1, dep))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        // Transitive analysis
        <span class="cov0" title="0">output.WriteString("## Transitive Impact\n\n")

        if len(analysis.TransitiveDownstream) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("### 🌊 Transitive Downstream Impact (%d levels)\n", maxDepth))
                output.WriteString("All functions that might be affected by changes to this symbol:\n")
                for i, dep := range analysis.TransitiveDownstream </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `", i+1))
                        // Show hierarchy with indentation for transitive relationships
                        output.WriteString(fmt.Sprintf("%s`\n", dep))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if len(analysis.TransitiveUpstream) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("### ⬆️ Transitive Upstream Impact (%d levels)\n", maxDepth))
                output.WriteString("All functions that could affect this symbol:\n")
                for i, dep := range analysis.TransitiveUpstream </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("%d. `%s`\n", i+1, dep))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        // Risk assessment
        <span class="cov0" title="0">output.WriteString("## 🎯 Risk Assessment\n\n")

        riskLevel := assessRisk(analysis)
        output.WriteString(fmt.Sprintf("**Risk Level:** %s\n\n", riskLevel))

        // Test recommendations
        output.WriteString("## 🧪 Test Recommendations\n\n")
        output.WriteString("Based on this analysis, you should test:\n\n")

        if len(analysis.DownstreamDeps) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("• **Downstream consumers** - functions that call this symbol\n")
        }</span>
        <span class="cov0" title="0">if len(analysis.UpstreamDeps) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("• **Upstream dependencies** - functions this symbol calls\n")
        }</span>
        <span class="cov0" title="0">if len(analysis.TransitiveDownstream) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("• **Transitive impact** - functions indirectly affected\n")
        }</span>

        // Add specific testing suggestions
        <span class="cov0" title="0">if len(analysis.DirectCallers) &gt; 10 </span><span class="cov0" title="0">{
                output.WriteString("⚠️  High impact - consider integration tests\n")
        }</span>
        <span class="cov0" title="0">if len(analysis.DirectCalls) &gt; 20 </span><span class="cov0" title="0">{
                output.WriteString("⚠️  Complex dependencies - unit test each interface\n")
        }</span>

        <span class="cov0" title="0">output.WriteString("\n")

        // Footer with tips
        output.WriteString("💡 **Tips:**\n")
        output.WriteString("   • Run integration tests on all downstream dependencies\n")
        output.WriteString("   • Check for breaking changes in function signatures\n")
        output.WriteString("   • Consider version compatibility for public APIs\n")
        output.WriteString("   • Mock upstream dependencies during testing\n")

        return output.String()</span>
}

// assessRisk provides a simple risk assessment based on the impact analysis
func assessRisk(analysis indexer.ImpactAnalysis) string <span class="cov0" title="0">{
        totalImpact := len(analysis.DirectCallers) +
                len(analysis.DownstreamDeps) +
                len(analysis.TransitiveDownstream)

        if totalImpact == 0 </span><span class="cov0" title="0">{
                return "🟢 Low (no dependencies)"
        }</span> else<span class="cov0" title="0"> if totalImpact &lt; 5 </span><span class="cov0" title="0">{
                return "🟡 Medium (limited impact)"
        }</span> else<span class="cov0" title="0"> if totalImpact &lt; 20 </span><span class="cov0" title="0">{
                return "🟠 High (significant impact)"
        }</span> else<span class="cov0" title="0"> {
                return "🔴 Critical (widespread impact)"
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package tools

import (
        "context"
        "fmt"
        "log/slog"
        "os/exec"
        "runtime"
        "strings"
        "time"
)

// ExternalTool represents a command-line tool that might be used by Nexora
type ExternalTool struct {
        Name        string
        Description string
        InstallCmd  map[string][]string // OS -&gt; command to install
        CheckCmd    []string            // Command to check if tool is installed
        Priority    int                 // Higher = more important
        AIRelevant  bool                // Whether this tool is particularly useful for AI operations
}

var essentialTools = []ExternalTool{
        {
                Name:        "ripgrep",
                Description: "Fast file search tool, much faster than grep",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "ripgrep"},
                        "linux":      {"apt", "install", "ripgrep"}, // Deb/Ubuntu
                        "linux-apt":  {"apt", "install", "ripgrep"}, // Deb/Ubuntu variant
                        "linux-yum":  {"yum", "install", "ripgrep"}, // RHEL/CentOS
                        "linux-dnf":  {"dnf", "install", "ripgrep"}, // Fedora
                        "linux-arch": {"pacman", "-S", "ripgrep"},   // Arch Linux
                        "windows":    {"winget", "install", "BurntSushi.ripgrep"},
                },
                CheckCmd:   []string{"rg", "--version"},
                Priority:   100,
                AIRelevant: true,
        },
        {
                Name:        "fd",
                Description: "Fast find replacement for finding files and directories",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "fd"},
                        "linux":      {"apt", "install", "fd-find"}, // Deb/Ubuntu, provides 'fdfind'
                        "linux-apt":  {"apt", "install", "fd-find"}, // Deb/Ubuntu variant
                        "linux-yum":  {"yum", "install", "fd"},      // RHEL/CentOS
                        "linux-dnf":  {"dnf", "install", "fd"},      // Fedora
                        "linux-arch": {"pacman", "-S", "fd"},        // Arch Linux
                        "windows":    {"winget", "install", "sharkdp.fd"},
                },
                CheckCmd:   []string{"fd", "--version"},
                Priority:   95,
                AIRelevant: true,
        },
        {
                Name:        "delta",
                Description: "Better diff viewer with syntax highlighting",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "git-delta"},
                        "linux":      {"apt", "install", "git-delta"},
                        "linux-apt":  {"apt", "install", "git-delta"},
                        "linux-yum":  {"yum", "install", "git-delta"},
                        "linux-dnf":  {"dnf", "install", "git-delta"},
                        "linux-arch": {"pacman", "-S", "git-delta"},
                        "windows":    {"winget", "install", "dandavison.delta"},
                },
                CheckCmd:   []string{"delta", "--version"},
                Priority:   80,
                AIRelevant: true,
        },
        {
                Name:        "bat",
                Description: "Cat with wings - syntax highlighting and git integration",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "bat"},
                        "linux":      {"apt", "install", "bat"},
                        "linux-apt":  {"apt", "install", "bat"},
                        "linux-yum":  {"yum", "install", "bat"},
                        "linux-dnf":  {"dnf", "install", "bat"},
                        "linux-arch": {"pacman", "-S", "bat"},
                        "windows":    {"winget", "install", "sharkdp.bat"},
                },
                CheckCmd:   []string{"bat", "--version"},
                Priority:   75,
                AIRelevant: false,
        },
        {
                Name:        "exa",
                Description: "Modern replacement for ls",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "exa"},
                        "linux":      {"apt", "install", "exa"},
                        "linux-apt":  {"apt", "install", "exa"},
                        "linux-yum":  {"yum", "install", "exa"},
                        "linux-dnf":  {"dnf", "install", "exa"},
                        "linux-arch": {"pacman", "-S", "exa"},
                        "windows":    {"winget", "install", "eza.eza"}, // eza is the maintained fork
                },
                CheckCmd:   []string{"exa", "--version"},
                Priority:   70,
                AIRelevant: false,
        },
        {
                Name:        "jq",
                Description: "Command-line JSON processor",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "jq"},
                        "linux":      {"apt", "install", "jq"},
                        "linux-apt":  {"apt", "install", "jq"},
                        "linux-yum":  {"yum", "install", "jq"},
                        "linux-dnf":  {"dnf", "install", "jq"},
                        "linux-arch": {"pacman", "-S", "jq"},
                        "windows":    {"winget", "install", "jqlang.jq"},
                },
                CheckCmd:   []string{"jq", "--version"},
                Priority:   90,
                AIRelevant: true,
        },
        {
                Name:        "fzf",
                Description: "Command-line fuzzy finder",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "fzf"},
                        "linux":      {"apt", "install", "fzf"},
                        "linux-apt":  {"apt", "install", "fzf"},
                        "linux-yum":  {"yum", "install", "fzf"},
                        "linux-dnf":  {"dnf", "install", "fzf"},
                        "linux-arch": {"pacman", "-S", "fzf"},
                        "windows":    {"winget", "install", "junegunn.fzf"},
                },
                CheckCmd:   []string{"fzf", "--version"},
                Priority:   85,
                AIRelevant: true,
        },
        {
                Name:        "sd",
                Description: "Intuitive find &amp; replace CLI (sed alternative)",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "sd"},
                        "linux":      {"apt", "install", "sd"},
                        "linux-apt":  {"apt", "install", "sd"},
                        "linux-yum":  {"yum", "install", "sd"},
                        "linux-dnf":  {"dnf", "install", "sd"},
                        "linux-arch": {"pacman", "-S", "sd"},
                        "windows":    {"winget", "install", "chmln.sd"},
                },
                CheckCmd:   []string{"sd", "--version"},
                Priority:   60,
                AIRelevant: true,
        },
        {
                Name:        "tokei",
                Description: "Code statistics tool - great for understanding codebases",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "tokei"},
                        "linux":      {"apt", "install", "tokei"},
                        "linux-apt":  {"apt", "install", "tokei"},
                        "linux-yum":  {"yum", "install", "tokei"},
                        "linux-dnf":  {"dnf", "install", "tokei"},
                        "linux-arch": {"pacman", "-S", "tokei"},
                        "windows":    {"cargo", "install", "tokei"}, // Via cargo
                },
                CheckCmd:   []string{"tokei", "--version"},
                Priority:   50,
                AIRelevant: true,
        },
        {
                Name:        "hexyl",
                Description: "Hex viewer - useful for binary file inspection",
                InstallCmd: map[string][]string{
                        "darwin":     {"brew", "install", "hexyl"},
                        "linux":      {"apt", "install", "hexyl"},
                        "linux-apt":  {"apt", "install", "hexyl"},
                        "linux-yum":  {"yum", "install", "hexyl"},
                        "linux-dnf":  {"dnf", "install", "hexyl"},
                        "linux-arch": {"pacman", "-S", "hexyl"},
                        "windows":    {"winget", "install", "sharkdp.hexyl"},
                },
                CheckCmd:   []string{"hexyl", "--version"},
                Priority:   40,
                AIRelevant: false,
        },
}

// InstallManager handles the checking and installation of essential tools
type InstallManager struct {
        tools []ExternalTool
}

// NewInstallManager creates a new installation manager
func NewInstallManager() *InstallManager <span class="cov0" title="0">{
        return &amp;InstallManager{
                tools: essentialTools,
        }
}</span>

// GetOSType returns the OS type with package manager detection
func GetOSType() string <span class="cov0" title="0">{
        osType := runtime.GOOS
        if osType == "linux" </span><span class="cov0" title="0">{
                // Try to detect the package manager
                if _, err := exec.LookPath("apt"); err == nil </span><span class="cov0" title="0">{
                        return "linux-apt"
                }</span>
                <span class="cov0" title="0">if _, err := exec.LookPath("yum"); err == nil </span><span class="cov0" title="0">{
                        return "linux-yum"
                }</span>
                <span class="cov0" title="0">if _, err := exec.LookPath("dnf"); err == nil </span><span class="cov0" title="0">{
                        return "linux-dnf"
                }</span>
                <span class="cov0" title="0">if _, err := exec.LookPath("pacman"); err == nil </span><span class="cov0" title="0">{
                        return "linux-arch"
                }</span>
                <span class="cov0" title="0">return "linux"</span> // fallback
        }
        <span class="cov0" title="0">return osType</span>
}

// IsToolInstalled checks if a tool is installed
func (im *InstallManager) IsToolInstalled(ctx context.Context, tool ExternalTool) bool <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        cmd := exec.CommandContext(ctx, tool.CheckCmd[0], tool.CheckCmd[1:]...)
        err := cmd.Run()
        return err == nil
}</span>

// InstallTool installs a tool if not already installed
func (im *InstallManager) InstallTool(ctx context.Context, tool ExternalTool) error <span class="cov0" title="0">{
        if im.IsToolInstalled(ctx, tool) </span><span class="cov0" title="0">{
                return nil // Already installed
        }</span>

        <span class="cov0" title="0">osType := GetOSType()
        installCmd, exists := tool.InstallCmd[osType]
        if !exists </span><span class="cov0" title="0">{
                // Try generic OS type
                installCmd, exists = tool.InstallCmd[runtime.GOOS]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("no installation command available for %s on %s", tool.Name, osType)
                }</span>
        }

        <span class="cov0" title="0">slog.Info("Installing tool", "tool", tool.Name, "os", osType)

        // Create a subprocess with timeout
        cmdCtx, cancel := context.WithTimeout(ctx, 300*time.Second) // 5 minute timeout
        defer cancel()

        cmd := exec.CommandContext(cmdCtx, installCmd[0], installCmd[1:]...)

        // Run without showing output to user unless in debug mode
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install %s: %w", tool.Name, err)
        }</span>

        <span class="cov0" title="0">slog.Info("Successfully installed tool", "tool", tool.Name)
        return nil</span>
}

// CheckAndInstallAIRelevantTools checks and installs the most important tools for AI operations
func (im *InstallManager) CheckAndInstallAIRelevantTools(ctx context.Context) error <span class="cov0" title="0">{
        slog.Info("Checking for AI-relevant tools")

        aiTools := make([]ExternalTool, 0)
        for _, tool := range im.tools </span><span class="cov0" title="0">{
                if tool.AIRelevant &amp;&amp; tool.Priority &gt;= 80 </span><span class="cov0" title="0">{
                        aiTools = append(aiTools, tool)
                }</span>
        }

        <span class="cov0" title="0">for _, tool := range aiTools </span><span class="cov0" title="0">{
                if !im.IsToolInstalled(ctx, tool) </span><span class="cov0" title="0">{
                        slog.Info("AI-relevant tool not found, attempting to install", "tool", tool.Name, "description", tool.Description)
                        if err := im.InstallTool(ctx, tool); err != nil </span><span class="cov0" title="0">{
                                slog.Warn("Failed to install AI-relevant tool", "tool", tool.Name, "error", err)
                                // Continue with other tools even if one fails
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetUnavailableAIRelevantTools returns a list of AI-relevant tools that are not installed
func (im *InstallManager) GetUnavailableAIRelevantTools(ctx context.Context) []ExternalTool <span class="cov0" title="0">{
        var unavailable []ExternalTool
        for _, tool := range im.tools </span><span class="cov0" title="0">{
                if tool.AIRelevant &amp;&amp; !im.IsToolInstalled(ctx, tool) </span><span class="cov0" title="0">{
                        unavailable = append(unavailable, tool)
                }</span>
        }
        <span class="cov0" title="0">return unavailable</span>
}

// GenerateSuggestions returns a formatted list of suggested tools
func (im *InstallManager) GenerateSuggestions(ctx context.Context) string <span class="cov0" title="0">{
        var suggestions strings.Builder
        suggestions.WriteString("\n# Essential Tools for Enhanced AI-Assisted Development\n\n")

        // Group by priority
        highPriority := make([]ExternalTool, 0)
        mediumPriority := make([]ExternalTool, 0)
        lowPriority := make([]ExternalTool, 0)

        for _, tool := range im.tools </span><span class="cov0" title="0">{
                if tool.AIRelevant </span><span class="cov0" title="0">{
                        if tool.Priority &gt;= 90 </span><span class="cov0" title="0">{
                                highPriority = append(highPriority, tool)
                        }</span> else<span class="cov0" title="0"> if tool.Priority &gt;= 70 </span><span class="cov0" title="0">{
                                mediumPriority = append(mediumPriority, tool)
                        }</span> else<span class="cov0" title="0"> {
                                lowPriority = append(lowPriority, tool)
                        }</span>
                }
        }

        <span class="cov0" title="0">addToolList := func(title string, tools []ExternalTool) </span><span class="cov0" title="0">{
                if len(tools) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">suggestions.WriteString(fmt.Sprintf("## %s\n\n", title))
                for _, tool := range tools </span><span class="cov0" title="0">{
                        installed := im.IsToolInstalled(ctx, tool)
                        status := "✅ Installed"
                        if !installed </span><span class="cov0" title="0">{
                                status = "❌ Missing"
                        }</span>
                        <span class="cov0" title="0">suggestions.WriteString(fmt.Sprintf("- **%s** - %s %s\n", tool.Name, tool.Description, status))</span>
                }
                <span class="cov0" title="0">suggestions.WriteString("\n")</span>
        }

        <span class="cov0" title="0">addToolList("🔥 High Priority (Essential for AI Operations)", highPriority)
        addToolList("⚡ Medium Priority (Significant Enhancement)", mediumPriority)
        addToolList("💡 Lower Priority (Nice to Have)", lowPriority)

        suggestions.WriteString("## Installation Commands\n\n")

        osType := GetOSType()
        suggestions.WriteString(fmt.Sprintf("For your OS (%s):\n\n", osType))

        for _, tool := range im.tools </span><span class="cov0" title="0">{
                if tool.AIRelevant </span><span class="cov0" title="0">{
                        if installCmd, exists := tool.InstallCmd[osType]; exists </span><span class="cov0" title="0">{
                                suggestions.WriteString(fmt.Sprintf("- **%s**: `%s`\n", tool.Name, strings.Join(installCmd, " ")))
                        }</span> else<span class="cov0" title="0"> if genericCmd, exists := tool.InstallCmd[runtime.GOOS]; exists </span><span class="cov0" title="0">{
                                suggestions.WriteString(fmt.Sprintf("- **%s**: `%s`\n", tool.Name, strings.Join(genericCmd, " ")))
                        }</span>
                }
        }

        <span class="cov0" title="0">return suggestions.String()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/shell"
)

const (
        JobKillToolName = "job_kill"
)

//go:embed job_kill.md
var jobKillDescription []byte

type JobKillParams struct {
        ShellID string `json:"shell_id" description:"The ID of the background shell to terminate"`
}

type JobKillResponseMetadata struct {
        ShellID     string `json:"shell_id"`
        Command     string `json:"command"`
        Description string `json:"description"`
}

func NewJobKillTool() fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                JobKillToolName,
                string(jobKillDescription),
                func(ctx context.Context, params JobKillParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.ShellID == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("missing shell_id"), nil
                        }</span>

                        <span class="cov0" title="0">bgManager := shell.GetBackgroundShellManager()

                        bgShell, ok := bgManager.Get(params.ShellID)
                        if !ok </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("background shell not found: %s", params.ShellID)), nil
                        }</span>

                        <span class="cov0" title="0">metadata := JobKillResponseMetadata{
                                ShellID:     params.ShellID,
                                Command:     bgShell.Command,
                                Description: bgShell.Description,
                        }

                        err := bgManager.Kill(params.ShellID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(err.Error()), nil
                        }</span>

                        <span class="cov0" title="0">result := fmt.Sprintf("Background shell %s terminated successfully", params.ShellID)
                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(result), metadata), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/shell"
)

const (
        JobOutputToolName = "job_output"
)

//go:embed job_output.md
var jobOutputDescription []byte

type JobOutputParams struct {
        ShellID string `json:"shell_id" description:"The ID of the background shell to retrieve output from"`
}

type JobOutputResponseMetadata struct {
        ShellID          string `json:"shell_id"`
        Command          string `json:"command"`
        Description      string `json:"description"`
        Done             bool   `json:"done"`
        WorkingDirectory string `json:"working_directory"`
}

func NewJobOutputTool() fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                JobOutputToolName,
                string(jobOutputDescription),
                func(ctx context.Context, params JobOutputParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.ShellID == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("missing shell_id"), nil
                        }</span>

                        <span class="cov0" title="0">bgManager := shell.GetBackgroundShellManager()
                        bgShell, ok := bgManager.Get(params.ShellID)
                        if !ok </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("background shell not found: %s", params.ShellID)), nil
                        }</span>

                        <span class="cov0" title="0">stdout, stderr, done, err := bgShell.GetOutput()

                        var outputParts []string
                        if stdout != "" </span><span class="cov0" title="0">{
                                outputParts = append(outputParts, stdout)
                        }</span>
                        <span class="cov0" title="0">if stderr != "" </span><span class="cov0" title="0">{
                                outputParts = append(outputParts, stderr)
                        }</span>

                        <span class="cov0" title="0">status := "running"
                        if done </span><span class="cov0" title="0">{
                                status = "completed"
                                if err != nil </span><span class="cov0" title="0">{
                                        exitCode := shell.ExitCode(err)
                                        if exitCode != 0 </span><span class="cov0" title="0">{
                                                outputParts = append(outputParts, fmt.Sprintf("Exit code %d", exitCode))
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">output := strings.Join(outputParts, "\n")

                        metadata := JobOutputResponseMetadata{
                                ShellID:          params.ShellID,
                                Command:          bgShell.Command,
                                Description:      bgShell.Description,
                                Done:             done,
                                WorkingDirectory: bgShell.WorkingDir,
                        }

                        if output == "" </span><span class="cov0" title="0">{
                                output = BashNoOutput
                        }</span>

                        <span class="cov0" title="0">result := fmt.Sprintf("Status: %s\n\n%s", status, output)
                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(result), metadata), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package tools

import (
        "cmp"
        "context"
        _ "embed"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/config"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/fsext"
        "github.com/nexora/cli/internal/permission"
)

type LSParams struct {
        Path   string   `json:"path,omitempty" description:"The path to the directory to list (defaults to current working directory)"`
        Ignore []string `json:"ignore,omitempty" description:"List of glob patterns to ignore"`
        Depth  int      `json:"depth,omitempty" description:"The maximum depth to traverse"`
}

type LSPermissionsParams struct {
        Path   string   `json:"path"`
        Ignore []string `json:"ignore"`
        Depth  int      `json:"depth"`
}

type TreeNode struct {
        Name     string      `json:"name"`
        Path     string      `json:"path"`
        Type     string      `json:"type"` // "file" or "directory"
        Children []*TreeNode `json:"children,omitempty"`
}

type LSResponseMetadata struct {
        NumberOfFiles int  `json:"number_of_files"`
        Truncated     bool `json:"truncated"`
}

const (
        LSToolName = "ls"
        maxLSFiles = 1000
)

//go:embed ls.md
var lsDescription []byte

func NewLsTool(permissions permission.Service, workingDir string, lsConfig config.ToolLs) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                LSToolName,
                string(lsDescription),
                func(ctx context.Context, params LSParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        searchPath, err := fsext.Expand(cmp.Or(params.Path, workingDir))
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("error expanding path: %v", err)), nil
                        }</span>

                        <span class="cov0" title="0">searchPath = filepathext.SmartJoin(workingDir, searchPath)

                        // Check if directory is outside working directory and request permission if needed
                        absWorkingDir, err := filepath.Abs(workingDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("error resolving working directory: %v", err)), nil
                        }</span>

                        <span class="cov0" title="0">absSearchPath, err := filepath.Abs(searchPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("error resolving search path: %v", err)), nil
                        }</span>

                        <span class="cov0" title="0">relPath, err := filepath.Rel(absWorkingDir, absSearchPath)
                        if err != nil || strings.HasPrefix(relPath, "..") </span><span class="cov0" title="0">{
                                // Directory is outside working directory, request permission
                                sessionID := GetSessionFromContext(ctx)
                                if sessionID == "" </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for accessing directories outside working directory")
                                }</span>

                                <span class="cov0" title="0">granted := permissions.Request(
                                        permission.CreatePermissionRequest{
                                                SessionID:   sessionID,
                                                Path:        absSearchPath,
                                                ToolCallID:  call.ID,
                                                ToolName:    LSToolName,
                                                Action:      "list",
                                                Description: fmt.Sprintf("List directory outside working directory: %s", absSearchPath),
                                                Params:      LSPermissionsParams(params),
                                        },
                                )

                                if !granted </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                                }</span>
                        }

                        <span class="cov0" title="0">output, metadata, err := ListDirectoryTree(searchPath, params, lsConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(err.Error()), err
                        }</span>

                        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                                fantasy.NewTextResponse(output),
                                metadata,
                        ), nil</span>
                })
}

func ListDirectoryTree(searchPath string, params LSParams, lsConfig config.ToolLs) (string, LSResponseMetadata, error) <span class="cov0" title="0">{
        if _, err := os.Stat(searchPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", LSResponseMetadata{}, fmt.Errorf("path does not exist: %s", searchPath)
        }</span>

        <span class="cov0" title="0">depth, limit := lsConfig.Limits()
        maxFiles := cmp.Or(limit, maxLSFiles)
        files, truncated, err := fsext.ListDirectory(
                searchPath,
                params.Ignore,
                cmp.Or(params.Depth, depth),
                maxFiles,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", LSResponseMetadata{}, fmt.Errorf("error listing directory: %w", err)
        }</span>

        <span class="cov0" title="0">metadata := LSResponseMetadata{
                NumberOfFiles: len(files),
                Truncated:     truncated,
        }
        tree := createFileTree(files, searchPath)

        var output string
        if truncated </span><span class="cov0" title="0">{
                output = fmt.Sprintf("There are more than %d files in the directory. Use a more specific path or use the Glob tool to find specific files. The first %[1]d files and directories are included below.\n", maxFiles)
        }</span>
        <span class="cov0" title="0">if depth &gt; 0 </span><span class="cov0" title="0">{
                output = fmt.Sprintf("The directory tree is shown up to a depth of %d. Use a higher depth and a specific path to see more levels.\n", cmp.Or(params.Depth, depth))
        }</span>
        <span class="cov0" title="0">return output + "\n" + printTree(tree, searchPath), metadata, nil</span>
}

func createFileTree(sortedPaths []string, rootPath string) []*TreeNode <span class="cov0" title="0">{
        root := []*TreeNode{}
        pathMap := make(map[string]*TreeNode)

        for _, path := range sortedPaths </span><span class="cov0" title="0">{
                relativePath := strings.TrimPrefix(path, rootPath)
                parts := strings.Split(relativePath, string(filepath.Separator))
                currentPath := ""
                var parentPath string

                var cleanParts []string
                for _, part := range parts </span><span class="cov0" title="0">{
                        if part != "" </span><span class="cov0" title="0">{
                                cleanParts = append(cleanParts, part)
                        }</span>
                }
                <span class="cov0" title="0">parts = cleanParts

                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for i, part := range parts </span><span class="cov0" title="0">{
                        if currentPath == "" </span><span class="cov0" title="0">{
                                currentPath = part
                        }</span> else<span class="cov0" title="0"> {
                                currentPath = filepath.Join(currentPath, part)
                        }</span>

                        <span class="cov0" title="0">if _, exists := pathMap[currentPath]; exists </span><span class="cov0" title="0">{
                                parentPath = currentPath
                                continue</span>
                        }

                        <span class="cov0" title="0">isLastPart := i == len(parts)-1
                        isDir := !isLastPart || strings.HasSuffix(relativePath, string(filepath.Separator))
                        nodeType := "file"
                        if isDir </span><span class="cov0" title="0">{
                                nodeType = "directory"
                        }</span>
                        <span class="cov0" title="0">newNode := &amp;TreeNode{
                                Name:     part,
                                Path:     currentPath,
                                Type:     nodeType,
                                Children: []*TreeNode{},
                        }

                        pathMap[currentPath] = newNode

                        if i &gt; 0 &amp;&amp; parentPath != "" </span><span class="cov0" title="0">{
                                if parent, ok := pathMap[parentPath]; ok </span><span class="cov0" title="0">{
                                        parent.Children = append(parent.Children, newNode)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                root = append(root, newNode)
                        }</span>

                        <span class="cov0" title="0">parentPath = currentPath</span>
                }
        }

        <span class="cov0" title="0">return root</span>
}

func printTree(tree []*TreeNode, rootPath string) string <span class="cov0" title="0">{
        var result strings.Builder

        result.WriteString("- ")
        result.WriteString(filepath.ToSlash(rootPath))
        if rootPath[len(rootPath)-1] != '/' </span><span class="cov0" title="0">{
                result.WriteByte('/')
        }</span>
        <span class="cov0" title="0">result.WriteByte('\n')

        for _, node := range tree </span><span class="cov0" title="0">{
                printNode(&amp;result, node, 1)
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}

func printNode(builder *strings.Builder, node *TreeNode, level int) <span class="cov0" title="0">{
        indent := strings.Repeat("  ", level)

        nodeName := node.Name
        if node.Type == "directory" </span><span class="cov0" title="0">{
                nodeName = nodeName + "/"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(builder, "%s- %s\n", indent, nodeName)

        if node.Type == "directory" &amp;&amp; len(node.Children) &gt; 0 </span><span class="cov0" title="0">{
                for _, child := range node.Children </span><span class="cov0" title="0">{
                        printNode(builder, child, level+1)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package tools

import (
        "context"
        "fmt"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/agent/tools/mcp"
        "github.com/nexora/cli/internal/permission"
)

// GetMCPTools gets all the currently available MCP tools.
func GetMCPTools(permissions permission.Service, wd string) []*Tool <span class="cov0" title="0">{
        var result []*Tool
        for mcpName, tools := range mcp.Tools() </span><span class="cov0" title="0">{
                for _, tool := range tools </span><span class="cov0" title="0">{
                        result = append(result, &amp;Tool{
                                mcpName:     mcpName,
                                tool:        tool,
                                permissions: permissions,
                                workingDir:  wd,
                        })
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Tool is a tool from a MCP.
type Tool struct {
        mcpName         string
        tool            *mcp.Tool
        permissions     permission.Service
        workingDir      string
        providerOptions fantasy.ProviderOptions
}

func (m *Tool) SetProviderOptions(opts fantasy.ProviderOptions) <span class="cov0" title="0">{
        m.providerOptions = opts
}</span>

func (m *Tool) ProviderOptions() fantasy.ProviderOptions <span class="cov0" title="0">{
        return m.providerOptions
}</span>

func (m *Tool) Name() string <span class="cov0" title="0">{
        return fmt.Sprintf("mcp_%s_%s", m.mcpName, m.tool.Name)
}</span>

func (m *Tool) MCP() string <span class="cov0" title="0">{
        return m.mcpName
}</span>

func (m *Tool) MCPToolName() string <span class="cov0" title="0">{
        return m.tool.Name
}</span>

func (m *Tool) Info() fantasy.ToolInfo <span class="cov0" title="0">{
        parameters := make(map[string]any)
        required := make([]string, 0)

        if input, ok := m.tool.InputSchema.(map[string]any); ok </span><span class="cov0" title="0">{
                if props, ok := input["properties"].(map[string]any); ok </span><span class="cov0" title="0">{
                        parameters = props
                }</span>
                <span class="cov0" title="0">if req, ok := input["required"].([]any); ok </span><span class="cov0" title="0">{
                        // Convert []any -&gt; []string when elements are strings
                        for _, v := range req </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        required = append(required, s)
                                }</span>
                        }
                } else<span class="cov0" title="0"> if reqStr, ok := input["required"].([]string); ok </span><span class="cov0" title="0">{
                        // Handle case where it's already []string
                        required = reqStr
                }</span>
        }

        <span class="cov0" title="0">return fantasy.ToolInfo{
                Name:        m.Name(),
                Description: m.tool.Description,
                Parameters:  parameters,
                Required:    required,
        }</span>
}

func (m *Tool) Run(ctx context.Context, params fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        sessionID := GetSessionFromContext(ctx)
        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
        }</span>
        <span class="cov0" title="0">permissionDescription := fmt.Sprintf("execute %s with the following parameters:", m.Info().Name)
        p := m.permissions.Request(
                permission.CreatePermissionRequest{
                        SessionID:   sessionID,
                        ToolCallID:  params.ID,
                        Path:        m.workingDir,
                        ToolName:    m.Info().Name,
                        Action:      "execute",
                        Description: permissionDescription,
                        Params:      params.Input,
                },
        )
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        <span class="cov0" title="0">result, err := mcp.RunTool(ctx, m.mcpName, m.tool.Name, params.Input)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(err.Error()), nil
        }</span>

        <span class="cov0" title="0">switch result.Type </span>{
        case "image", "media":<span class="cov0" title="0">
                if !GetSupportsImagesFromContext(ctx) </span><span class="cov0" title="0">{
                        modelName := GetModelNameFromContext(ctx)
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("This model (%s) does not support image data.", modelName)), nil
                }</span>

                <span class="cov0" title="0">var response fantasy.ToolResponse
                if result.Type == "image" </span><span class="cov0" title="0">{
                        response = fantasy.NewImageResponse(result.Data, result.MediaType)
                }</span> else<span class="cov0" title="0"> {
                        response = fantasy.NewMediaResponse(result.Data, result.MediaType)
                }</span>
                <span class="cov0" title="0">response.Content = result.Content
                return response, nil</span>
        default:<span class="cov0" title="0">
                return fantasy.NewTextResponse(result.Content), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/aiops"
        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/diff"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/fsext"
        "github.com/nexora/cli/internal/history"
        "github.com/nexora/cli/internal/lsp"
        "github.com/nexora/cli/internal/permission"
)

type MultiEditOperation struct {
        OldString  string `json:"old_string" description:"The text to replace"`
        NewString  string `json:"new_string" description:"The text to replace it with"`
        ReplaceAll bool   `json:"replace_all,omitempty" description:"Replace all occurrences of old_string (default false)."`
}

type MultiEditParams struct {
        FilePath string               `json:"file_path" description:"The absolute path to the file to modify"`
        Edits    []MultiEditOperation `json:"edits" description:"Array of edit operations to perform sequentially on the file"`
}

type MultiEditPermissionsParams struct {
        FilePath   string `json:"file_path"`
        OldContent string `json:"old_content,omitempty"`
        NewContent string `json:"new_content,omitempty"`
}

type FailedEdit struct {
        Index int                `json:"index"`
        Error string             `json:"error"`
        Edit  MultiEditOperation `json:"edit"`
}

type MultiEditResponseMetadata struct {
        Additions    int          `json:"additions"`
        Removals     int          `json:"removals"`
        OldContent   string       `json:"old_content,omitempty"`
        NewContent   string       `json:"new_content,omitempty"`
        EditsApplied int          `json:"edits_applied"`
        EditsFailed  []FailedEdit `json:"edits_failed,omitempty"`
        FailedEdits  []FailedEdit `json:"failed_edits,omitempty"`
}

const MultiEditToolName = "multiedit"

//go:embed multiedit.md
var multieditDescription []byte

func NewMultiEditTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, files history.Service, workingDir string, aiops aiops.Ops) fantasy.AgentTool <span class="cov8" title="1">{
        return fantasy.NewAgentTool(
                MultiEditToolName,
                string(multieditDescription),
                func(ctx context.Context, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.FilePath == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("file_path is required"), nil
                        }</span>

                        <span class="cov0" title="0">if len(params.Edits) == 0 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("at least one edit operation is required"), nil
                        }</span>

                        <span class="cov0" title="0">params.FilePath = filepathext.SmartJoin(workingDir, params.FilePath)

                        // Validate all edits before applying any
                        if err := validateEdits(params.Edits); err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(err.Error()), nil
                        }</span>

                        <span class="cov0" title="0">var response fantasy.ToolResponse
                        var err error

                        editCtx := editContext{ctx, permissions, files, workingDir, aiops}
                        // Handle file creation case (first edit has empty old_string)
                        if len(params.Edits) &gt; 0 &amp;&amp; params.Edits[0].OldString == "" </span><span class="cov0" title="0">{
                                response, err = processMultiEditWithCreation(editCtx, params, call)
                        }</span> else<span class="cov0" title="0"> {
                                response, err = processMultiEditExistingFile(editCtx, params, call)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return response, err
                        }</span>

                        <span class="cov0" title="0">if response.IsError </span><span class="cov0" title="0">{
                                return response, nil
                        }</span>

                        // Notify LSP clients about the change
                        <span class="cov0" title="0">notifyLSPs(ctx, lspClients, params.FilePath)

                        // Wait for LSP diagnostics and add them to the response
                        text := fmt.Sprintf("&lt;result&gt;\n%s\n&lt;/result&gt;\n", response.Content)
                        text += getDiagnostics(params.FilePath, lspClients)
                        response.Content = text
                        return response, nil</span>
                })
}

func validateEdits(edits []MultiEditOperation) error <span class="cov0" title="0">{
        for i, edit := range edits </span><span class="cov0" title="0">{
                // Only the first edit can have empty old_string (for file creation)
                if i &gt; 0 &amp;&amp; edit.OldString == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("edit %d: only the first edit can have empty old_string (for file creation)", i+1)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func processMultiEditWithCreation(edit editContext, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        // First edit creates the file
        firstEdit := params.Edits[0]
        if firstEdit.OldString != "" </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("first edit must have empty old_string for file creation"), nil
        }</span>

        // Check if file already exists
        <span class="cov0" title="0">if _, err := os.Stat(params.FilePath); err == nil </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("file already exists: %s", params.FilePath)), nil
        }</span> else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to access file: %w", err)
        }</span>

        // Create parent directories
        <span class="cov0" title="0">dir := filepath.Dir(params.FilePath)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        // Start with the content from the first edit
        <span class="cov0" title="0">currentContent := firstEdit.NewString

        // Apply remaining edits to the content, tracking failures
        var failedEdits []FailedEdit
        for i := 1; i &lt; len(params.Edits); i++ </span><span class="cov0" title="0">{
                editOp := params.Edits[i]
                newContent, err := applyEditToContent(edit.ctx, params.FilePath, currentContent, editOp)
                if err != nil </span><span class="cov0" title="0">{
                        failedEdits = append(failedEdits, FailedEdit{
                                Index: i + 1,
                                Error: err.Error(),
                                Edit:  editOp,
                        })
                        continue</span>
                }
                <span class="cov0" title="0">currentContent = newContent</span>
        }

        // Get session and message IDs
        <span class="cov0" title="0">sessionID := GetSessionFromContext(edit.ctx)
        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for creating a new file")
        }</span>

        // Check permissions
        <span class="cov0" title="0">_, additions, removals := diff.GenerateDiff("", currentContent, strings.TrimPrefix(params.FilePath, edit.workingDir))

        editsApplied := len(params.Edits) - len(failedEdits)
        var description string
        if len(failedEdits) &gt; 0 </span><span class="cov0" title="0">{
                description = fmt.Sprintf("Create file %s with %d of %d edits (%d failed)", params.FilePath, editsApplied, len(params.Edits), len(failedEdits))
        }</span> else<span class="cov0" title="0"> {
                description = fmt.Sprintf("Create file %s with %d edits", params.FilePath, editsApplied)
        }</span>
        <span class="cov0" title="0">p := edit.permissions.Request(permission.CreatePermissionRequest{
                SessionID:   sessionID,
                Path:        fsext.PathOrPrefix(params.FilePath, edit.workingDir),
                ToolCallID:  call.ID,
                ToolName:    MultiEditToolName,
                Action:      "write",
                Description: description,
                Params: MultiEditPermissionsParams{
                        FilePath:   params.FilePath,
                        OldContent: "",
                        NewContent: currentContent,
                },
        })
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        // Write the file
        <span class="cov0" title="0">err := os.WriteFile(params.FilePath, []byte(currentContent), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // Update file history
        <span class="cov0" title="0">_, err = edit.files.Create(edit.ctx, sessionID, params.FilePath, "")
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, currentContent)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating file history version", "error", err)
        }</span>

        <span class="cov0" title="0">recordFileWrite(params.FilePath)
        recordFileRead(params.FilePath)

        var message string
        if len(failedEdits) &gt; 0 </span><span class="cov0" title="0">{
                message = fmt.Sprintf("File created with %d of %d edits: %s (%d edit(s) failed)", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))
        }</span> else<span class="cov0" title="0"> {
                message = fmt.Sprintf("File created with %d edits: %s", len(params.Edits), params.FilePath)
        }</span>

        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse(message),
                MultiEditResponseMetadata{
                        OldContent:   "",
                        NewContent:   currentContent,
                        Additions:    additions,
                        Removals:     removals,
                        EditsApplied: editsApplied,
                        EditsFailed:  failedEdits,
                },
        ), nil</span>
}

func processMultiEditExistingFile(edit editContext, params MultiEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        // Validate file exists and is readable
        fileInfo, err := os.Stat(params.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("file not found: %s", params.FilePath)), nil
                }</span>
                <span class="cov0" title="0">return fantasy.ToolResponse{}, fmt.Errorf("failed to access file: %w", err)</span>
        }

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("path is a directory, not a file: %s", params.FilePath)), nil
        }</span>

        // Check if file was read before editing
        <span class="cov0" title="0">if getLastReadTime(params.FilePath).IsZero() </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("you must read the file before editing it. Use the View tool first"), nil
        }</span>

        // Check if file was modified since last read
        <span class="cov0" title="0">modTime := fileInfo.ModTime()
        lastRead := getLastReadTime(params.FilePath)
        if modTime.After(lastRead) </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(
                        fmt.Sprintf("file %s has been modified since it was last read (mod time: %s, last read: %s)",
                                params.FilePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339),
                        )), nil
        }</span>

        // Read current file content
        <span class="cov0" title="0">content, err := os.ReadFile(params.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">oldContent, isCrlf := fsext.ToUnixLineEndings(string(content))
        currentContent := oldContent

        // Apply all edits sequentially, tracking failures
        var failedEdits []FailedEdit
        for i, editOp := range params.Edits </span><span class="cov0" title="0">{
                newContent, err := applyEditToContent(edit.ctx, params.FilePath, currentContent, editOp)
                if err != nil </span><span class="cov0" title="0">{
                        failedEdits = append(failedEdits, FailedEdit{
                                Index: i + 1,
                                Error: err.Error(),
                                Edit:  editOp,
                        })
                        continue</span>
                }
                <span class="cov0" title="0">currentContent = newContent</span>
        }

        // Check if content actually changed
        <span class="cov0" title="0">if oldContent == currentContent </span><span class="cov0" title="0">{
                // If we have failed edits, report them
                if len(failedEdits) &gt; 0 </span><span class="cov0" title="0">{
                        return fantasy.WithResponseMetadata(
                                fantasy.NewTextErrorResponse(fmt.Sprintf("no changes made - all %d edit(s) failed", len(failedEdits))),
                                MultiEditResponseMetadata{
                                        EditsApplied: 0,
                                        EditsFailed:  failedEdits,
                                },
                        ), nil
                }</span>
                <span class="cov0" title="0">return fantasy.NewTextErrorResponse("no changes made - all edits resulted in identical content"), nil</span>
        }

        // Get session and message IDs
        <span class="cov0" title="0">sessionID := GetSessionFromContext(edit.ctx)
        if sessionID == "" </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for editing file")
        }</span>

        // Generate diff and check permissions
        <span class="cov0" title="0">_, additions, removals := diff.GenerateDiff(oldContent, currentContent, strings.TrimPrefix(params.FilePath, edit.workingDir))

        editsApplied := len(params.Edits) - len(failedEdits)
        var description string
        if len(failedEdits) &gt; 0 </span><span class="cov0" title="0">{
                description = fmt.Sprintf("Apply %d of %d edits to file %s (%d failed)", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))
        }</span> else<span class="cov0" title="0"> {
                description = fmt.Sprintf("Apply %d edits to file %s", editsApplied, params.FilePath)
        }</span>
        <span class="cov0" title="0">p := edit.permissions.Request(permission.CreatePermissionRequest{
                SessionID:   sessionID,
                Path:        fsext.PathOrPrefix(params.FilePath, edit.workingDir),
                ToolCallID:  call.ID,
                ToolName:    MultiEditToolName,
                Action:      "write",
                Description: description,
                Params: MultiEditPermissionsParams{
                        FilePath:   params.FilePath,
                        OldContent: oldContent,
                        NewContent: currentContent,
                },
        })
        if !p </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
        }</span>

        <span class="cov0" title="0">if isCrlf </span><span class="cov0" title="0">{
                currentContent, _ = fsext.ToWindowsLineEndings(currentContent)
        }</span>

        // Write the updated content
        <span class="cov0" title="0">err = os.WriteFile(params.FilePath, []byte(currentContent), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // Update file history
        <span class="cov0" title="0">file, err := edit.files.GetByPathAndSession(edit.ctx, params.FilePath, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                _, err = edit.files.Create(edit.ctx, sessionID, params.FilePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if file.Content != oldContent </span><span class="cov0" title="0">{
                // User manually changed the content, store an intermediate version
                _, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, oldContent)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error creating file history version", "error", err)
                }</span>
        }

        // Store the new version
        <span class="cov0" title="0">_, err = edit.files.CreateVersion(edit.ctx, sessionID, params.FilePath, currentContent)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating file history version", "error", err)
        }</span>

        <span class="cov0" title="0">recordFileWrite(params.FilePath)
        recordFileRead(params.FilePath)

        var message string
        if len(failedEdits) &gt; 0 </span><span class="cov0" title="0">{
                message = fmt.Sprintf("Applied %d of %d edits to file: %s (%d edit(s) failed)", editsApplied, len(params.Edits), params.FilePath, len(failedEdits))
        }</span> else<span class="cov0" title="0"> {
                message = fmt.Sprintf("Applied %d edits to file: %s", len(params.Edits), params.FilePath)
        }</span>

        <span class="cov0" title="0">return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse(message),
                MultiEditResponseMetadata{
                        OldContent:   oldContent,
                        NewContent:   currentContent,
                        Additions:    additions,
                        Removals:     removals,
                        EditsApplied: editsApplied,
                        EditsFailed:  failedEdits,
                },
        ), nil</span>
}

func applyEditToContent(ctx context.Context, filePath string, content string, edit MultiEditOperation) (string, error) <span class="cov8" title="1">{
        if edit.OldString == "" &amp;&amp; edit.NewString == "" </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        <span class="cov8" title="1">if edit.OldString == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("old_string cannot be empty for content replacement")
        }</span>

        <span class="cov8" title="1">var newContent string
        var replacementCount int

        if edit.ReplaceAll </span><span class="cov0" title="0">{
                newContent = strings.ReplaceAll(content, edit.OldString, edit.NewString)
                replacementCount = strings.Count(content, edit.OldString)
                if replacementCount == 0 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("old_string not found in content. Make sure it matches exactly, including whitespace and line breaks")
                }</span>
        } else<span class="cov8" title="1"> {
                index := strings.Index(content, edit.OldString)
                if index == -1 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("old_string not found in content. Make sure it matches exactly, including whitespace and line breaks")
                }</span>

                <span class="cov8" title="1">lastIndex := strings.LastIndex(content, edit.OldString)
                if index != lastIndex </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("old_string appears multiple times in the content. Please provide more context to ensure a unique match, or set replace_all to true")
                }</span>

                <span class="cov8" title="1">newContent = content[:index] + edit.NewString + content[index+len(edit.OldString):]
                replacementCount = 1</span>
        }

        <span class="cov8" title="1">return newContent, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package tools

import (
        "cmp"
        "context"
        _ "embed"
        "errors"
        "fmt"
        "log/slog"
        "maps"
        "path/filepath"
        "regexp"
        "slices"
        "sort"
        "strings"

        "charm.land/fantasy"
        "github.com/charmbracelet/x/powernap/pkg/lsp/protocol"
        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/lsp"
)

type ReferencesParams struct {
        Symbol string `json:"symbol" description:"The symbol name to search for (e.g., function name, variable name, type name)"`
        Path   string `json:"path,omitempty" description:"The directory to search in. Use a directory/file to narrow down the symbol search. Defaults to the current working directory."`
}

type referencesTool struct {
        lspClients *csync.Map[string, *lsp.Client]
}

const ReferencesToolName = "lsp_references"

//go:embed references.md
var referencesDescription []byte

func NewReferencesTool(lspClients *csync.Map[string, *lsp.Client]) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                ReferencesToolName,
                string(referencesDescription),
                func(ctx context.Context, params ReferencesParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Symbol == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("symbol is required"), nil
                        }</span>

                        <span class="cov0" title="0">if lspClients.Len() == 0 </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("no LSP clients available"), nil
                        }</span>

                        <span class="cov0" title="0">workingDir := cmp.Or(params.Path, ".")

                        matches, _, err := searchFiles(ctx, regexp.QuoteMeta(params.Symbol), workingDir, "", 100)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("failed to search for symbol: %s", err)), nil
                        }</span>

                        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                                return fantasy.NewTextResponse(fmt.Sprintf("Symbol '%s' not found", params.Symbol)), nil
                        }</span>

                        <span class="cov0" title="0">var allLocations []protocol.Location
                        var allErrs error
                        for _, match := range matches </span><span class="cov0" title="0">{
                                locations, err := find(ctx, lspClients, params.Symbol, match)
                                if err != nil </span><span class="cov0" title="0">{
                                        if strings.Contains(err.Error(), "no identifier found") </span><span class="cov0" title="0">{
                                                // grep probably matched a comment, string value, or something else that's irrelevant
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">slog.Error("Failed to find references", "error", err, "symbol", params.Symbol, "path", match.path, "line", match.lineNum, "char", match.charNum)
                                        allErrs = errors.Join(allErrs, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">allLocations = append(allLocations, locations...)</span>
                                // XXX: should we break here or look for all results?
                        }

                        <span class="cov0" title="0">if len(allLocations) &gt; 0 </span><span class="cov0" title="0">{
                                output := formatReferences(cleanupLocations(allLocations))
                                return fantasy.NewTextResponse(output), nil
                        }</span>

                        <span class="cov0" title="0">if allErrs != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(allErrs.Error()), nil
                        }</span>
                        <span class="cov0" title="0">return fantasy.NewTextResponse(fmt.Sprintf("No references found for symbol '%s'", params.Symbol)), nil</span>
                })
}

func (r *referencesTool) Name() string <span class="cov0" title="0">{
        return ReferencesToolName
}</span>

func find(ctx context.Context, lspClients *csync.Map[string, *lsp.Client], symbol string, match grepMatch) ([]protocol.Location, error) <span class="cov0" title="0">{
        absPath, err := filepath.Abs(match.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get absolute path: %s", err)
        }</span>

        <span class="cov0" title="0">var client *lsp.Client
        for c := range lspClients.Seq() </span><span class="cov0" title="0">{
                if c.HandlesFile(absPath) </span><span class="cov0" title="0">{
                        client = c
                        break</span>
                }
        }

        <span class="cov0" title="0">if client == nil </span><span class="cov0" title="0">{
                slog.Warn("No LSP clients to handle", "path", match.path)
                return nil, nil
        }</span>

        <span class="cov0" title="0">return client.FindReferences(
                ctx,
                absPath,
                match.lineNum,
                match.charNum+getSymbolOffset(symbol),
                true,
        )</span>
}

// getSymbolOffset returns the character offset to the actual symbol name
// in a qualified symbol (e.g., "Bar" in "foo.Bar" or "method" in "Class::method").
func getSymbolOffset(symbol string) int <span class="cov0" title="0">{
        // Check for :: separator (Rust, C++, Ruby modules/classes, PHP static).
        if idx := strings.LastIndex(symbol, "::"); idx != -1 </span><span class="cov0" title="0">{
                return idx + 2
        }</span>
        // Check for . separator (Go, Python, JavaScript, Java, C#, Ruby methods).
        <span class="cov0" title="0">if idx := strings.LastIndex(symbol, "."); idx != -1 </span><span class="cov0" title="0">{
                return idx + 1
        }</span>
        // Check for \ separator (PHP namespaces).
        <span class="cov0" title="0">if idx := strings.LastIndex(symbol, "\\"); idx != -1 </span><span class="cov0" title="0">{
                return idx + 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func cleanupLocations(locations []protocol.Location) []protocol.Location <span class="cov0" title="0">{
        slices.SortFunc(locations, func(a, b protocol.Location) int </span><span class="cov0" title="0">{
                if a.URI != b.URI </span><span class="cov0" title="0">{
                        return strings.Compare(string(a.URI), string(b.URI))
                }</span>
                <span class="cov0" title="0">if a.Range.Start.Line != b.Range.Start.Line </span><span class="cov0" title="0">{
                        return cmp.Compare(a.Range.Start.Line, b.Range.Start.Line)
                }</span>
                <span class="cov0" title="0">return cmp.Compare(a.Range.Start.Character, b.Range.Start.Character)</span>
        })
        <span class="cov0" title="0">return slices.CompactFunc(locations, func(a, b protocol.Location) bool </span><span class="cov0" title="0">{
                return a.URI == b.URI &amp;&amp;
                        a.Range.Start.Line == b.Range.Start.Line &amp;&amp;
                        a.Range.Start.Character == b.Range.Start.Character
        }</span>)
}

func groupByFilename(locations []protocol.Location) map[string][]protocol.Location <span class="cov0" title="0">{
        files := make(map[string][]protocol.Location)
        for _, loc := range locations </span><span class="cov0" title="0">{
                path, err := loc.URI.Path()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to convert location URI to path", "uri", loc.URI, "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">files[path] = append(files[path], loc)</span>
        }
        <span class="cov0" title="0">return files</span>
}

func formatReferences(locations []protocol.Location) string <span class="cov0" title="0">{
        fileRefs := groupByFilename(locations)
        files := slices.Collect(maps.Keys(fileRefs))
        sort.Strings(files)

        var output strings.Builder
        output.WriteString(fmt.Sprintf("Found %d reference(s) in %d file(s):\n\n", len(locations), len(files)))

        for _, file := range files </span><span class="cov0" title="0">{
                refs := fileRefs[file]
                output.WriteString(fmt.Sprintf("%s (%d reference(s)):\n", file, len(refs)))
                for _, ref := range refs </span><span class="cov0" title="0">{
                        line := ref.Range.Start.Line + 1
                        char := ref.Range.Start.Character + 1
                        output.WriteString(fmt.Sprintf("  Line %d, Column %d\n", line, char))
                }</span>
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return output.String()</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package tools

import (
        "context"
        "log/slog"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
)

var getRg = sync.OnceValue(func() string <span class="cov8" title="1">{
        path, err := exec.LookPath("rg")
        if err != nil </span><span class="cov0" title="0">{
                slog.Debug("Ripgrep (rg) not found in $PATH. Will use built-in grep implementation.")
                return ""
        }</span>
        <span class="cov8" title="1">slog.Info("Using ripgrep (rg) for fast pattern matching")
        return path</span>
})

func getRgCmd(ctx context.Context, globPattern string) *exec.Cmd <span class="cov8" title="1">{
        name := getRg()
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">args := []string{"--files", "-L", "--null"}
        if globPattern != "" </span><span class="cov8" title="1">{
                if !filepath.IsAbs(globPattern) &amp;&amp; !strings.HasPrefix(globPattern, "/") </span><span class="cov8" title="1">{
                        globPattern = "/" + globPattern
                }</span>
                <span class="cov8" title="1">args = append(args, "--glob", globPattern)</span>
        }
        <span class="cov8" title="1">return exec.CommandContext(ctx, name, args...)</span>
}

func getRgSearchCmd(ctx context.Context, pattern, path, include string) *exec.Cmd <span class="cov8" title="1">{
        name := getRg()
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Use -n to show line numbers, -0 for null separation to handle Windows paths
        <span class="cov8" title="1">args := []string{"--json", "-H", "-n", "-0", pattern}
        if include != "" </span><span class="cov0" title="0">{
                args = append(args, "--glob", include)
        }</span>
        <span class="cov8" title="1">args = append(args, path)

        return exec.CommandContext(ctx, name, args...)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tools

import "runtime"

var safeCommands = []string{
        // Bash builtins and core utils
        "cal",
        "date",
        "df",
        "du",
        "echo",
        "env",
        "free",
        "groups",
        "hostname",
        "id",
        "kill",
        "killall",
        "ls",
        "nice",
        "nohup",
        "printenv",
        "ps",
        "pwd",
        "set",
        "time",
        "timeout",
        "top",
        "type",
        "uname",
        "unset",
        "uptime",
        "whatis",
        "whereis",
        "which",
        "whoami",

        // Git
        "git blame",
        "git branch",
        "git config --get",
        "git config --list",
        "git describe",
        "git diff",
        "git grep",
        "git log",
        "git ls-files",
        "git ls-remote",
        "git remote",
        "git rev-parse",
        "git shortlog",
        "git show",
        "git status",
        "git tag",
}

func init() <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                safeCommands = append(
                        safeCommands,
                        // Windows-specific commands
                        "ipconfig",
                        "nslookup",
                        "ping",
                        "systeminfo",
                        "tasklist",
                        "where",
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package tools

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "slices"
        "strings"

        "golang.org/x/net/html"
)

// SearchResult represents a single search result from DuckDuckGo.
type SearchResult struct {
        Title    string
        Link     string
        Snippet  string
        Position int
}

// searchDuckDuckGo performs a web search using DuckDuckGo's HTML endpoint.
func searchDuckDuckGo(ctx context.Context, client *http.Client, query string, maxResults int) ([]SearchResult, error) <span class="cov0" title="0">{
        if maxResults &lt;= 0 </span><span class="cov0" title="0">{
                maxResults = 10
        }</span>

        <span class="cov0" title="0">formData := url.Values{}
        formData.Set("q", query)
        formData.Set("b", "")
        formData.Set("kl", "")

        req, err := http.NewRequestWithContext(ctx, "POST", "https://html.duckduckgo.com/html", strings.NewReader(formData.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("User-Agent", BrowserUserAgent)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute search: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search failed with status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">return parseSearchResults(string(body), maxResults)</span>
}

// parseSearchResults extracts search results from DuckDuckGo HTML response.
func parseSearchResults(htmlContent string, maxResults int) ([]SearchResult, error) <span class="cov0" title="0">{
        doc, err := html.Parse(strings.NewReader(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML: %w", err)
        }</span>

        <span class="cov0" title="0">var results []SearchResult
        var traverse func(*html.Node)

        traverse = func(n *html.Node) </span><span class="cov0" title="0">{
                if n.Type == html.ElementNode &amp;&amp; n.Data == "div" &amp;&amp; hasClass(n, "result") </span><span class="cov0" title="0">{
                        result := extractResult(n)
                        if result != nil &amp;&amp; result.Link != "" &amp;&amp; !strings.Contains(result.Link, "y.js") </span><span class="cov0" title="0">{
                                result.Position = len(results) + 1
                                results = append(results, *result)
                                if len(results) &gt;= maxResults </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">for c := n.FirstChild; c != nil &amp;&amp; len(results) &lt; maxResults; c = c.NextSibling </span><span class="cov0" title="0">{
                        traverse(c)
                }</span>
        }

        <span class="cov0" title="0">traverse(doc)
        return results, nil</span>
}

// hasClass checks if an HTML node has a specific class.
func hasClass(n *html.Node, class string) bool <span class="cov0" title="0">{
        for _, attr := range n.Attr </span><span class="cov0" title="0">{
                if attr.Key == "class" </span><span class="cov0" title="0">{
                        return slices.Contains(strings.Fields(attr.Val), class)
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// extractResult extracts a search result from a result div node.
func extractResult(n *html.Node) *SearchResult <span class="cov0" title="0">{
        result := &amp;SearchResult{}

        var traverse func(*html.Node)
        traverse = func(node *html.Node) </span><span class="cov0" title="0">{
                if node.Type == html.ElementNode </span><span class="cov0" title="0">{
                        // Look for title link.
                        if node.Data == "a" &amp;&amp; hasClass(node, "result__a") </span><span class="cov0" title="0">{
                                result.Title = getTextContent(node)
                                for _, attr := range node.Attr </span><span class="cov0" title="0">{
                                        if attr.Key == "href" </span><span class="cov0" title="0">{
                                                result.Link = cleanDuckDuckGoURL(attr.Val)
                                                break</span>
                                        }
                                }
                        }
                        // Look for snippet.
                        <span class="cov0" title="0">if node.Data == "a" &amp;&amp; hasClass(node, "result__snippet") </span><span class="cov0" title="0">{
                                result.Snippet = getTextContent(node)
                        }</span>
                }
                <span class="cov0" title="0">for c := node.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                        traverse(c)
                }</span>
        }

        <span class="cov0" title="0">traverse(n)
        return result</span>
}

// getTextContent extracts all text content from a node and its children.
func getTextContent(n *html.Node) string <span class="cov0" title="0">{
        var text strings.Builder
        var traverse func(*html.Node)

        traverse = func(node *html.Node) </span><span class="cov0" title="0">{
                if node.Type == html.TextNode </span><span class="cov0" title="0">{
                        text.WriteString(node.Data)
                }</span>
                <span class="cov0" title="0">for c := node.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                        traverse(c)
                }</span>
        }

        <span class="cov0" title="0">traverse(n)
        return strings.TrimSpace(text.String())</span>
}

// cleanDuckDuckGoURL extracts the actual URL from DuckDuckGo's redirect URL.
func cleanDuckDuckGoURL(rawURL string) string <span class="cov0" title="0">{
        if strings.HasPrefix(rawURL, "//duckduckgo.com/l/?uddg=") </span><span class="cov0" title="0">{
                // Extract the actual URL from the redirect.
                if idx := strings.Index(rawURL, "uddg="); idx != -1 </span><span class="cov0" title="0">{
                        encoded := rawURL[idx+5:]
                        if ampIdx := strings.Index(encoded, "&amp;"); ampIdx != -1 </span><span class="cov0" title="0">{
                                encoded = encoded[:ampIdx]
                        }</span>
                        <span class="cov0" title="0">decoded, err := url.QueryUnescape(encoded)
                        if err == nil </span><span class="cov0" title="0">{
                                return decoded
                        }</span>
                }
        }
        <span class="cov0" title="0">return rawURL</span>
}

// formatSearchResults formats search results for LLM consumption.
func formatSearchResults(results []SearchResult) string <span class="cov0" title="0">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return "No results were found for your search query. This could be due to DuckDuckGo's bot detection or the query returned no matches. Please try rephrasing your search or try again in a few minutes."
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString(fmt.Sprintf("Found %d search results:\n\n", len(results)))

        for _, result := range results </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("%d. %s\n", result.Position, result.Title))
                sb.WriteString(fmt.Sprintf("   URL: %s\n", result.Link))
                sb.WriteString(fmt.Sprintf("   Summary: %s\n\n", result.Snippet))
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package tools

import (
        "context"
        "fmt"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/indexer"
)

type SearchIndexedParams struct {
        Query       string   `json:"query" description:"Search query or question about the codebase"`
        Type        string   `json:"type,omitempty" description:"Search type: all (default), semantic, text, or graph"`
        Limit       int      `json:"limit,omitempty" description:"Maximum number of results to return (default: 20)"`
        Context     string   `json:"context,omitempty" description:"Filter by package, file, or type context"`
        SymbolTypes []string `json:"symbol_types,omitempty" description:"Filter by symbol types: func, struct, interface, var, const"`
        IncludeDocs bool     `json:"include_docs,omitempty" description:"Include documentation in search results"`
}

// NewSearchIndexedTool creates a new search indexed tool
func NewSearchIndexedTool(queryEngine *indexer.QueryEngine) fantasy.AgentTool <span class="cov8" title="1">{
        return fantasy.NewAgentTool(
                "search_indexed",
                "Search code using AI-accelerated indexing with semantic, text, and graph search capabilities",
                func(ctx context.Context, params SearchIndexedParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if queryEngine == nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("search indexed tool is not available - indexer not initialized"), nil
                        }</span>

                        <span class="cov0" title="0">if params.Query == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("query parameter is required"), nil
                        }</span>

                        // Set defaults
                        <span class="cov0" title="0">if params.Type == "" </span><span class="cov0" title="0">{
                                params.Type = "all"
                        }</span>
                        <span class="cov0" title="0">if params.Limit == 0 </span><span class="cov0" title="0">{
                                params.Limit = 20
                        }</span>

                        // Convert to indexer QueryRequest
                        <span class="cov0" title="0">queryType, err := parseQueryType(params.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Error: %v", err)), nil
                        }</span>

                        <span class="cov0" title="0">req := &amp;indexer.QueryRequest{
                                Query:       params.Query,
                                Type:        queryType,
                                Limit:       params.Limit,
                                Context:     params.Context,
                                SymbolTypes: params.SymbolTypes,
                                IncludeDocs: params.IncludeDocs,
                        }

                        // Execute search
                        result, err := queryEngine.Search(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Search failed: %v", err)), nil
                        }</span>

                        // Format results
                        <span class="cov0" title="0">output := formatResults(result, params)
                        return fantasy.NewTextResponse(output), nil</span>
                },
        )
}

// parseQueryType converts string query type to indexer.QueryType
func parseQueryType(typeStr string) (indexer.QueryType, error) <span class="cov8" title="1">{
        switch strings.ToLower(typeStr) </span>{
        case "all":<span class="cov8" title="1">
                return indexer.QueryTypeAll, nil</span>
        case "semantic":<span class="cov8" title="1">
                return indexer.QueryTypeSemantic, nil</span>
        case "text":<span class="cov8" title="1">
                return indexer.QueryTypeText, nil</span>
        case "graph":<span class="cov8" title="1">
                return indexer.QueryTypeGraph, nil</span>
        default:<span class="cov8" title="1">
                return indexer.QueryTypeAll, fmt.Errorf("unknown query type: %s", typeStr)</span>
        }
}

// formatResults formats search results for display
func formatResults(result *indexer.SearchResult, params SearchIndexedParams) string <span class="cov0" title="0">{
        var output strings.Builder

        // Header
        output.WriteString(fmt.Sprintf("🔍 Search Results for: %s\n", result.Query))
        output.WriteString(fmt.Sprintf("📊 Type: %v | Total: %d results | Duration: %s\n\n",
                result.Type, result.Total, result.Duration))

        if len(result.Results) == 0 </span><span class="cov0" title="0">{
                output.WriteString("No results found.\n")
                return output.String()
        }</span>

        // Results
        <span class="cov0" title="0">for i, res := range result.Results </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("%d. **%s** `%s`\n", i+1, res.Symbol.Name, res.Symbol.Type))
                output.WriteString(fmt.Sprintf("   📍 Location: %s\n", res.Location))
                output.WriteString(fmt.Sprintf("   🎯 Score: %.3f (%s)\n", res.Score, res.MatchType))
                output.WriteString(fmt.Sprintf("   💡 Reason: %s\n", res.Reason))

                // Package context
                if res.Symbol.Package != "" </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("   📦 Package: %s\n", res.Symbol.Package))
                }</span>

                // Documentation (if available and not too long)
                <span class="cov0" title="0">if res.Symbol.Doc != "" &amp;&amp; len(res.Symbol.Doc) &lt; 200 </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("   📖 Documentation: %s\n", res.Symbol.Doc))
                }</span>

                // Signature (if available and not too long)
                <span class="cov0" title="0">if res.Symbol.Signature != "" &amp;&amp; len(res.Symbol.Signature) &lt; 200 </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("   🔍 Signature: %s\n", res.Symbol.Signature))
                }</span> else<span class="cov0" title="0"> if res.Symbol.Signature != "" </span><span class="cov0" title="0">{
                        // truncated signature for very long ones
                        truncated := res.Symbol.Signature
                        if len(truncated) &gt; 200 </span><span class="cov0" title="0">{
                                truncated = truncated[:197] + "..."
                        }</span>
                        <span class="cov0" title="0">output.WriteString(fmt.Sprintf("   🔍 Signature: %s\n", truncated))</span>
                }

                <span class="cov0" title="0">output.WriteString("\n")</span>
        }

        // Footer with tips
        <span class="cov0" title="0">output.WriteString("💡 **Tips:**\n")
        output.WriteString("   • Use semantic search for finding code by intent\n")
        output.WriteString("   • Use text search for exact name or pattern matching\n")
        output.WriteString("   • Use graph search for finding related or dependent code\n")
        output.WriteString("   • Filter results with `type:`, `context:`, or `symbol_types:` parameters\n")

        return output.String()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package tools

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "regexp"
        "strings"
)

// EditRetryStrategy provides auto-healing mechanisms for failed edit operations.
// When an edit fails (e.g., "old_string not found"), it can automatically:
// 1. View the target file to extract exact context
// 2. Use grep to find similar patterns
// 3. Regenerate the old_string with proper whitespace/indentation
type EditRetryStrategy struct {
        ctx    context.Context
        viewFn func(ctx context.Context, filePath string, offset, limit int) (string, error)
        grepFn func(ctx context.Context, pattern string, workingDir string) ([]string, error)
}

// NewEditRetryStrategy creates a new retry strategy for failed edits.
func NewEditRetryStrategy(ctx context.Context) *EditRetryStrategy <span class="cov8" title="1">{
        return &amp;EditRetryStrategy{
                ctx: ctx,
                viewFn: func(ctx context.Context, filePath string, offset, limit int) (string, error) </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(filePath)
                        return string(content), err
                }</span>,
                grepFn: func(ctx context.Context, pattern string, workingDir string) ([]string, error) <span class="cov0" title="0">{
                        return []string{}, nil // Placeholder for grep integration
                }</span>,
        }
}

// RetryWithContext attempts to fix a failed edit by extracting context from the file.
// This is called when "old_string not found" error occurs.
func (s *EditRetryStrategy) RetryWithContext(
        filePath string,
        oldString string,
        newString string,
        failureReason string,
) (EditParams, error) <span class="cov8" title="1">{
        // Read the file to find the target pattern
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return EditParams{}, fmt.Errorf("failed to read file for retry: %w", err)
        }</span>

        <span class="cov8" title="1">fileContent := string(content)

        // Try to find a similar pattern by removing extra whitespace
        normalized := normalizeWhitespace(oldString)
        if idx := findSimilarPattern(fileContent, normalized); idx &gt;= 0 </span><span class="cov8" title="1">{
                // Extract context around the match (7 lines of context as per guidelines)
                lines := strings.Split(fileContent, "\n")
                matchLine := countNewlines(fileContent[:idx])
                startLine := max(0, matchLine-3)
                endLine := min(len(lines), matchLine+4)

                // Build the new old_string with proper context
                contextLines := lines[startLine:endLine]
                improvedOldString := strings.Join(contextLines, "\n")

                slog.Debug("self-healing edit",
                        "file", filePath,
                        "original_length", len(oldString),
                        "improved_length", len(improvedOldString),
                        "context_lines", len(contextLines),
                )

                return EditParams{
                        FilePath:   filePath,
                        OldString:  improvedOldString,
                        NewString:  newString,
                        ReplaceAll: false,
                }, nil
        }</span>

        // Try advanced context extraction
        <span class="cov0" title="0">if improvedParams := s.extractContextFromPattern(fileContent, oldString, newString); improvedParams.OldString != "" </span><span class="cov0" title="0">{
                return improvedParams, nil
        }</span>

        <span class="cov0" title="0">return EditParams{}, fmt.Errorf("could not recover from edit failure: %s", failureReason)</span>
}

// extractContextFromPattern uses advanced pattern matching to extract better context
func (s *EditRetryStrategy) extractContextFromPattern(fileContent, oldString, newString string) EditParams <span class="cov0" title="0">{
        lines := strings.Split(fileContent, "\n")

        // Look for each line of the old_string in the file
        oldLines := strings.Split(oldString, "\n")

        for lineIdx := 0; lineIdx &lt; len(lines); lineIdx++ </span><span class="cov0" title="0">{
                // Try to find the start of a matching sequence
                if strings.Contains(lines[lineIdx], oldLines[0]) </span><span class="cov0" title="0">{
                        // Check if this could be the start of our target sequence
                        remainingLines := len(lines) - lineIdx
                        if remainingLines &gt;= len(oldLines) </span><span class="cov0" title="0">{
                                // Extract a 7-line block around this potential match
                                startIdx := max(0, lineIdx-3)
                                endIdx := min(len(lines), lineIdx+4)

                                contextBlock := lines[startIdx:endIdx]
                                contextString := strings.Join(contextBlock, "\n")

                                // Check if the old_string pattern appears in this context block
                                if strings.Contains(contextString, oldString) </span><span class="cov0" title="0">{
                                        slog.Debug("extracted context block",
                                                "start_line", startIdx,
                                                "end_line", endIdx,
                                                "block_length", len(contextBlock),
                                        )

                                        return EditParams{
                                                FilePath:   "", // Will be filled by caller
                                                OldString:  contextString,
                                                NewString:  newString,
                                                ReplaceAll: false,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return EditParams{}</span> // Return empty if no context found
}

// normalizeWhitespace removes leading/trailing whitespace and collapses multiple spaces.
func normalizeWhitespace(s string) string <span class="cov8" title="1">{
        // Replace tabs with spaces for comparison
        s = strings.ReplaceAll(s, "\t", "    ")
        // Collapse multiple spaces in each line
        lines := strings.Split(s, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                lines[i] = strings.TrimSpace(line)
        }</span>
        <span class="cov8" title="1">return strings.Join(lines, "\n")</span>
}

// findSimilarPattern searches for a pattern that matches the normalized version.
// Returns the index in the file where the pattern was found, or -1 if not found.
func findSimilarPattern(fileContent string, normalizedPattern string) int <span class="cov8" title="1">{
        // Try exact match first
        if idx := strings.Index(fileContent, normalizedPattern); idx &gt;= 0 </span><span class="cov8" title="1">{
                return idx
        }</span>

        // Try matching with normalized content
        <span class="cov8" title="1">normalized := normalizeWhitespace(fileContent)
        if idx := strings.Index(normalized, normalizedPattern); idx &gt;= 0 </span><span class="cov0" title="0">{
                return idx
        }</span>

        // Try matching individual lines
        <span class="cov8" title="1">lines := strings.Split(normalizedPattern, "\n")
        if len(lines) == 1 </span><span class="cov8" title="1">{
                // Single line search - try various whitespace variations
                return findLineVariation(fileContent, lines[0])
        }</span>

        <span class="cov0" title="0">return -1</span>
}

// findLineVariation tries to find a line accounting for different whitespace.
func findLineVariation(content string, targetLine string) int <span class="cov8" title="1">{
        lines := strings.Split(content, "\n")
        normTarget := strings.TrimSpace(targetLine)

        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.TrimSpace(line) == normTarget </span><span class="cov0" title="0">{
                        // Calculate the byte offset for this line
                        offset := 0
                        for j := range i </span><span class="cov0" title="0">{
                                offset += len(lines[j]) + 1 // +1 for newline
                        }</span>
                        <span class="cov0" title="0">return offset</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}

// countNewlines returns the number of newlines before the given byte position.
func countNewlines(s string) int <span class="cov8" title="1">{
        return strings.Count(s, "\n")
}</span>

// ExtractContextLines extracts N lines around a target line for better edit matching.
// This helps create unique old_string matches by including surrounding context.
func ExtractContextLines(
        filePath string,
        targetLine string,
        contextLinesCount int,
) (string, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(string(content), "\n")

        // Find the target line
        var targetIdx int = -1
        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, strings.TrimSpace(targetLine)) </span><span class="cov8" title="1">{
                        targetIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetIdx &lt; 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("target line not found in file")
        }</span>

        // Extract context
        <span class="cov8" title="1">startIdx := max(0, targetIdx-contextLinesCount)
        endIdx := min(len(lines), targetIdx+contextLinesCount+1)

        contextLines := lines[startIdx:endIdx]
        return strings.Join(contextLines, "\n"), nil</span>
}

// max returns the larger of two integers.
func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// min returns the smaller of two integers.
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// ValidateEditPattern checks if an old_string is unique in the file.
// Returns true if the pattern appears exactly once, false otherwise.
func ValidateEditPattern(filePath string, oldString string) (bool, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">fileContent := string(content)
        matches := strings.Count(fileContent, oldString)

        if matches == 0 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("pattern not found in file")
        }</span>
        <span class="cov8" title="1">if matches &gt; 1 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("pattern appears %d times (must be unique)", matches)
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// FindBestMatch searches for the best matching context around a target line.
// This is useful when the exact old_string fails to match.
func FindBestMatch(
        filePath string,
        targetContent string,
        contextSize int,
) (string, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(string(content), "\n")

        // Find best matching line using regex
        pattern := regexp.MustCompile(regexp.QuoteMeta(strings.TrimSpace(targetContent)))
        var bestIdx int = -1

        for i, line := range lines </span><span class="cov8" title="1">{
                if pattern.MatchString(line) </span><span class="cov8" title="1">{
                        bestIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if bestIdx &lt; 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no matching line found")
        }</span>

        // Extract context around the match
        <span class="cov8" title="1">start := max(0, bestIdx-contextSize)
        end := min(len(lines), bestIdx+contextSize+1)

        return strings.Join(lines[start:end], "\n"), nil</span>
}

// tryNormalizedMatch attempts to find oldString in content after normalizing whitespace
func tryNormalizedMatch(content, oldString string) (string, bool) <span class="cov0" title="0">{
        normalized := normalizeWhitespace(oldString)
        if strings.Contains(content, normalized) </span><span class="cov0" title="0">{
                return normalized, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os"
        "strings"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/history"
        "github.com/nexora/cli/internal/permission"
)

// SmartEditParams uses line numbers instead of string matching for 100% reliability
type SmartEditParams struct {
        FilePath  string `json:"file_path" description:"The absolute path to the file to modify"`
        StartLine int    `json:"start_line" description:"The starting line number (1-indexed) to replace"`
        EndLine   int    `json:"end_line" description:"The ending line number (1-indexed) to replace (inclusive)"`
        NewString string `json:"new_string" description:"The replacement text"`
}

const SmartEditToolName = "smart_edit"

//go:embed smart_edit.md
var smartEditDescription []byte

type smartEditContext struct {
        ctx         context.Context
        permissions permission.Service
        files       history.Service
        workingDir  string
}

// NewSmartEditTool creates a line-number based edit tool that never fails due to whitespace
func NewSmartEditTool(permissions permission.Service, files history.Service, workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                SmartEditToolName,
                string(smartEditDescription),
                func(ctx context.Context, params SmartEditParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        slog.Info("SMART_EDIT TOOL INVOKED",
                                "file", params.FilePath,
                                "start_line", params.StartLine,
                                "end_line", params.EndLine,
                                "new_string_length", len(params.NewString))

                        editCtx := smartEditContext{
                                ctx:         ctx,
                                permissions: permissions,
                                files:       files,
                                workingDir:  workingDir,
                        }

                        return executeSmartEdit(editCtx, params)
                }</span>,
        )
}

func executeSmartEdit(edit smartEditContext, params SmartEditParams) (fantasy.ToolResponse, error) <span class="cov0" title="0">{
        // Validate parameters
        if params.StartLine &lt; 1 </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("start_line must be &gt;= 1"), nil
        }</span>
        <span class="cov0" title="0">if params.EndLine &lt; params.StartLine </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse("end_line must be &gt;= start_line"), nil
        }</span>

        // Read file
        <span class="cov0" title="0">content, err := os.ReadFile(params.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fantasy.NewTextErrorResponse(fmt.Sprintf("file not found: %s", params.FilePath)), nil
                }</span>
                <span class="cov0" title="0">return fantasy.ToolResponse{}, fmt.Errorf("failed to read file: %w", err)</span>
        }

        <span class="cov0" title="0">oldContent := string(content)
        lines := strings.Split(oldContent, "\n")

        // Validate line numbers
        if params.StartLine &gt; len(lines) </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("start_line %d exceeds file length (%d lines)", params.StartLine, len(lines))), nil
        }</span>
        <span class="cov0" title="0">if params.EndLine &gt; len(lines) </span><span class="cov0" title="0">{
                return fantasy.NewTextErrorResponse(fmt.Sprintf("end_line %d exceeds file length (%d lines)", params.EndLine, len(lines))), nil
        }</span>

        // Extract the lines to be replaced
        <span class="cov0" title="0">oldString := strings.Join(lines[params.StartLine-1:params.EndLine], "\n")

        // Build new content
        var newLines []string
        newLines = append(newLines, lines[:params.StartLine-1]...)

        // Add new content (split into lines if multi-line)
        if params.NewString != "" </span><span class="cov0" title="0">{
                newContentLines := strings.Split(params.NewString, "\n")
                newLines = append(newLines, newContentLines...)
        }</span>

        // Add remaining lines after the replaced section
        <span class="cov0" title="0">if params.EndLine &lt; len(lines) </span><span class="cov0" title="0">{
                newLines = append(newLines, lines[params.EndLine:]...)
        }</span>

        <span class="cov0" title="0">newContent := strings.Join(newLines, "\n")

        // Write back
        err = os.WriteFile(params.FilePath, []byte(newContent), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fantasy.ToolResponse{}, fmt.Errorf("failed to write file: %w", err)
        }</span>

        // Calculate stats
        <span class="cov0" title="0">linesReplaced := params.EndLine - params.StartLine + 1
        newLinesAdded := len(strings.Split(params.NewString, "\n"))

        slog.Info("smart_edit completed",
                "file", params.FilePath,
                "lines_replaced", linesReplaced,
                "new_lines", newLinesAdded)

        return fantasy.WithResponseMetadata(
                fantasy.NewTextResponse(fmt.Sprintf("✓ Edited %s (lines %d-%d replaced with %d new lines)",
                        params.FilePath, params.StartLine, params.EndLine, newLinesAdded)),
                map[string]any{
                        "lines_replaced": linesReplaced,
                        "new_lines":      newLinesAdded,
                        "old_content":    oldString,
                        "new_content":    params.NewString,
                },
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package tools

import (
        "bytes"
        "context"
        _ "embed"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "charm.land/fantasy"
)

type SourcegraphParams struct {
        Query         string `json:"query" description:"The Sourcegraph search query"`
        Count         int    `json:"count,omitempty" description:"Optional number of results to return (default: 10, max: 20)"`
        ContextWindow int    `json:"context_window,omitempty" description:"The context around the match to return (default: 10 lines)"`
        Timeout       int    `json:"timeout,omitempty" description:"Optional timeout in seconds (max 120)"`
}

type SourcegraphResponseMetadata struct {
        NumberOfMatches int  `json:"number_of_matches"`
        Truncated       bool `json:"truncated"`
}

const SourcegraphToolName = "sourcegraph"

//go:embed sourcegraph.md
var sourcegraphDescription []byte

func NewSourcegraphTool(client *http.Client) fantasy.AgentTool <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                }
        }</span>
        <span class="cov0" title="0">return fantasy.NewParallelAgentTool(
                SourcegraphToolName,
                string(sourcegraphDescription),
                func(ctx context.Context, params SourcegraphParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Query == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Query parameter is required"), nil
                        }</span>

                        <span class="cov0" title="0">if params.Count &lt;= 0 </span><span class="cov0" title="0">{
                                params.Count = 10
                        }</span> else<span class="cov0" title="0"> if params.Count &gt; 20 </span><span class="cov0" title="0">{
                                params.Count = 20 // Limit to 20 results
                        }</span>

                        <span class="cov0" title="0">if params.ContextWindow &lt;= 0 </span><span class="cov0" title="0">{
                                params.ContextWindow = 10 // Default context window
                        }</span>

                        // Handle timeout with context
                        <span class="cov0" title="0">requestCtx := ctx
                        if params.Timeout &gt; 0 </span><span class="cov0" title="0">{
                                maxTimeout := 120 // 2 minutes
                                if params.Timeout &gt; maxTimeout </span><span class="cov0" title="0">{
                                        params.Timeout = maxTimeout
                                }</span>
                                <span class="cov0" title="0">var cancel context.CancelFunc
                                requestCtx, cancel = context.WithTimeout(ctx, time.Duration(params.Timeout)*time.Second)
                                defer cancel()</span>
                        }

                        <span class="cov0" title="0">type graphqlRequest struct {
                                Query     string `json:"query"`
                                Variables struct {
                                        Query string `json:"query"`
                                } `json:"variables"`
                        }

                        request := graphqlRequest{
                                Query: "query Search($query: String!) { search(query: $query, version: V2, patternType: keyword ) { results { matchCount, limitHit, resultCount, approximateResultCount, missing { name }, timedout { name }, indexUnavailable, results { __typename, ... on FileMatch { repository { name }, file { path, url, content }, lineMatches { preview, lineNumber, offsetAndLengths } } } } } }",
                        }
                        request.Variables.Query = params.Query

                        graphqlQueryBytes, err := json.Marshal(request)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to marshal GraphQL request: %w", err)
                        }</span>
                        <span class="cov0" title="0">graphqlQuery := string(graphqlQueryBytes)

                        req, err := http.NewRequestWithContext(
                                requestCtx,
                                "POST",
                                "https://sourcegraph.com/.api/graphql",
                                bytes.NewBuffer([]byte(graphqlQuery)),
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to create request: %w", err)
                        }</span>

                        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
                        req.Header.Set("User-Agent", "nexora/1.0")

                        resp, err := client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to fetch URL: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()

                        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                body, _ := io.ReadAll(resp.Body)
                                if len(body) &gt; 0 </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Request failed with status code: %d, response: %s", resp.StatusCode, string(body))), nil
                                }</span>

                                <span class="cov0" title="0">return fantasy.NewTextErrorResponse(fmt.Sprintf("Request failed with status code: %d", resp.StatusCode)), nil</span>
                        }
                        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to read response body: %w", err)
                        }</span>

                        <span class="cov0" title="0">var result map[string]any
                        if err = json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("failed to unmarshal response: %w", err)
                        }</span>

                        <span class="cov0" title="0">formattedResults, err := formatSourcegraphResults(result, params.ContextWindow)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Failed to format results: " + err.Error()), nil
                        }</span>

                        <span class="cov0" title="0">return fantasy.NewTextResponse(formattedResults), nil</span>
                })
}

func formatSourcegraphResults(result map[string]any, contextWindow int) (string, error) <span class="cov0" title="0">{
        var buffer strings.Builder

        if errors, ok := result["errors"].([]any); ok &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                buffer.WriteString("## Sourcegraph API Error\n\n")
                for _, err := range errors </span><span class="cov0" title="0">{
                        if errMap, ok := err.(map[string]any); ok </span><span class="cov0" title="0">{
                                if message, ok := errMap["message"].(string); ok </span><span class="cov0" title="0">{
                                        buffer.WriteString(fmt.Sprintf("- %s\n", message))
                                }</span>
                        }
                }
                <span class="cov0" title="0">return buffer.String(), nil</span>
        }

        <span class="cov0" title="0">data, ok := result["data"].(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response format: missing data field")
        }</span>

        <span class="cov0" title="0">search, ok := data["search"].(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response format: missing search field")
        }</span>

        <span class="cov0" title="0">searchResults, ok := search["results"].(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response format: missing results field")
        }</span>

        <span class="cov0" title="0">matchCount, _ := searchResults["matchCount"].(float64)
        resultCount, _ := searchResults["resultCount"].(float64)
        limitHit, _ := searchResults["limitHit"].(bool)

        buffer.WriteString("# Sourcegraph Search Results\n\n")
        buffer.WriteString(fmt.Sprintf("Found %d matches across %d results\n", int(matchCount), int(resultCount)))

        if limitHit </span><span class="cov0" title="0">{
                buffer.WriteString("(Result limit reached, try a more specific query)\n")
        }</span>

        <span class="cov0" title="0">buffer.WriteString("\n")

        results, ok := searchResults["results"].([]any)
        if !ok || len(results) == 0 </span><span class="cov0" title="0">{
                buffer.WriteString("No results found. Try a different query.\n")
                return buffer.String(), nil
        }</span>

        <span class="cov0" title="0">maxResults := 10
        if len(results) &gt; maxResults </span><span class="cov0" title="0">{
                results = results[:maxResults]
        }</span>

        <span class="cov0" title="0">for i, res := range results </span><span class="cov0" title="0">{
                fileMatch, ok := res.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">typeName, _ := fileMatch["__typename"].(string)
                if typeName != "FileMatch" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">repo, _ := fileMatch["repository"].(map[string]any)
                file, _ := fileMatch["file"].(map[string]any)
                lineMatches, _ := fileMatch["lineMatches"].([]any)

                if repo == nil || file == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">repoName, _ := repo["name"].(string)
                filePath, _ := file["path"].(string)
                fileURL, _ := file["url"].(string)
                fileContent, _ := file["content"].(string)

                buffer.WriteString(fmt.Sprintf("## Result %d: %s/%s\n\n", i+1, repoName, filePath))

                if fileURL != "" </span><span class="cov0" title="0">{
                        buffer.WriteString(fmt.Sprintf("URL: %s\n\n", fileURL))
                }</span>

                <span class="cov0" title="0">if len(lineMatches) &gt; 0 </span><span class="cov0" title="0">{
                        for _, lm := range lineMatches </span><span class="cov0" title="0">{
                                lineMatch, ok := lm.(map[string]any)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">lineNumber, _ := lineMatch["lineNumber"].(float64)
                                preview, _ := lineMatch["preview"].(string)

                                if fileContent != "" </span><span class="cov0" title="0">{
                                        lines := strings.Split(fileContent, "\n")

                                        buffer.WriteString("```\n")

                                        startLine := max(1, int(lineNumber)-contextWindow)

                                        for j := startLine - 1; j &lt; int(lineNumber)-1 &amp;&amp; j &lt; len(lines); j++ </span><span class="cov0" title="0">{
                                                if j &gt;= 0 </span><span class="cov0" title="0">{
                                                        buffer.WriteString(fmt.Sprintf("%d| %s\n", j+1, lines[j]))
                                                }</span>
                                        }

                                        <span class="cov0" title="0">buffer.WriteString(fmt.Sprintf("%d|  %s\n", int(lineNumber), preview))

                                        endLine := int(lineNumber) + contextWindow

                                        for j := int(lineNumber); j &lt; endLine &amp;&amp; j &lt; len(lines); j++ </span><span class="cov0" title="0">{
                                                if j &lt; len(lines) </span><span class="cov0" title="0">{
                                                        buffer.WriteString(fmt.Sprintf("%d| %s\n", j+1, lines[j]))
                                                }</span>
                                        }

                                        <span class="cov0" title="0">buffer.WriteString("```\n\n")</span>
                                } else<span class="cov0" title="0"> {
                                        buffer.WriteString("```\n")
                                        buffer.WriteString(fmt.Sprintf("%d| %s\n", int(lineNumber), preview))
                                        buffer.WriteString("```\n\n")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return buffer.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package tools

import (
        "context"
)

type (
        sessionIDContextKey string
        messageIDContextKey string
        supportsImagesKey   string
        modelNameKey        string
)

const (
        // SessionIDContextKey is the key for the session ID in the context.
        SessionIDContextKey sessionIDContextKey = "session_id"
        // MessageIDContextKey is the key for the message ID in the context.
        MessageIDContextKey messageIDContextKey = "message_id"
        // SupportsImagesContextKey is the key for the model's image support capability.
        SupportsImagesContextKey supportsImagesKey = "supports_images"
        // ModelNameContextKey is the key for the model name in the context.
        ModelNameContextKey modelNameKey = "model_name"
)

// GetSessionFromContext retrieves the session ID from the context.
func GetSessionFromContext(ctx context.Context) string <span class="cov0" title="0">{
        sessionID := ctx.Value(SessionIDContextKey)
        if sessionID == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">s, ok := sessionID.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s</span>
}

// GetMessageFromContext retrieves the message ID from the context.
func GetMessageFromContext(ctx context.Context) string <span class="cov0" title="0">{
        messageID := ctx.Value(MessageIDContextKey)
        if messageID == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">s, ok := messageID.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s</span>
}

// GetSupportsImagesFromContext retrieves whether the model supports images from the context.
func GetSupportsImagesFromContext(ctx context.Context) bool <span class="cov0" title="0">{
        supportsImages := ctx.Value(SupportsImagesContextKey)
        if supportsImages == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if supports, ok := supportsImages.(bool); ok </span><span class="cov0" title="0">{
                return supports
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetModelNameFromContext retrieves the model name from the context.
func GetModelNameFromContext(ctx context.Context) string <span class="cov0" title="0">{
        modelName := ctx.Value(ModelNameContextKey)
        if modelName == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">s, ok := modelName.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package tools

import (
        "bufio"
        "bytes"
        "context"
        _ "embed"
        "encoding/base64"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
        "unicode/utf8"

        "charm.land/fantasy"

        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/lsp"
        "github.com/nexora/cli/internal/permission"
)

//go:embed view.md
var viewDescription []byte

type ViewParams struct {
        FilePath string `json:"file_path" description:"The path to the file to read"`
        Offset   int    `json:"offset,omitempty" description:"The line number to start reading from (0-based)"`
        Limit    int    `json:"limit,omitempty" description:"The number of lines to read (defaults to 2000)"`
}

type ViewPermissionsParams struct {
        FilePath string `json:"file_path"`
        Offset   int    `json:"offset"`
        Limit    int    `json:"limit"`
}

type viewTool struct {
        lspClients  *csync.Map[string, *lsp.Client]
        workingDir  string
        permissions permission.Service
}

type ViewResponseMetadata struct {
        FilePath string `json:"file_path"`
        Content  string `json:"content"`
}

const (
        ViewToolName     = "view"
        MaxReadSize      = 5 * 1024 * 1024 // 5MB
        DefaultReadLimit = 100
        MaxLineLength    = 2000
)

func NewViewTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                ViewToolName,
                string(viewDescription),
                func(ctx context.Context, params ViewParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        startTime := time.Now()
                        if params.FilePath == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("file_path is required"), nil
                        }</span>

                        // Handle relative paths
                        <span class="cov0" title="0">filePath := filepathext.SmartJoin(workingDir, params.FilePath)

                        // Check if file is outside working directory and request permission if needed
                        absWorkingDir, err := filepath.Abs(workingDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error resolving working directory: %w", err)
                        }</span>

                        <span class="cov0" title="0">absFilePath, err := filepath.Abs(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error resolving file path: %w", err)
                        }</span>

                        <span class="cov0" title="0">relPath, err := filepath.Rel(absWorkingDir, absFilePath)
                        if err != nil || strings.HasPrefix(relPath, "..") </span><span class="cov0" title="0">{
                                // File is outside working directory, request permission
                                sessionID := GetSessionFromContext(ctx)
                                if sessionID == "" </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, fmt.Errorf("session ID is required for accessing files outside working directory")
                                }</span>

                                <span class="cov0" title="0">granted := permissions.Request(
                                        permission.CreatePermissionRequest{
                                                SessionID:   sessionID,
                                                Path:        absFilePath,
                                                ToolCallID:  call.ID,
                                                ToolName:    ViewToolName,
                                                Action:      "read",
                                                Description: fmt.Sprintf("Read file outside working directory: %s", absFilePath),
                                                Params:      ViewPermissionsParams(params),
                                        },
                                )

                                if !granted </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                                }</span>
                        }

                        // Check if file exists
                        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // Try to offer suggestions for similarly named files
                                        dir := filepath.Dir(filePath)
                                        base := filepath.Base(filePath)

                                        dirEntries, dirErr := os.ReadDir(dir)
                                        if dirErr == nil </span><span class="cov0" title="0">{
                                                var suggestions []string
                                                for _, entry := range dirEntries </span><span class="cov0" title="0">{
                                                        if strings.Contains(strings.ToLower(entry.Name()), strings.ToLower(base)) ||
                                                                strings.Contains(strings.ToLower(base), strings.ToLower(entry.Name())) </span><span class="cov0" title="0">{
                                                                suggestions = append(suggestions, filepath.Join(dir, entry.Name()))
                                                                if len(suggestions) &gt;= 3 </span><span class="cov0" title="0">{
                                                                        break</span>
                                                                }
                                                        }
                                                }

                                                <span class="cov0" title="0">if len(suggestions) &gt; 0 </span><span class="cov0" title="0">{
                                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("File not found: %s\nTried paths:\n- %s\n- %s\n\nDid you mean one of these?\n%s",
                                                                params.FilePath, filePath, absFilePath, strings.Join(suggestions, "\n"))), nil
                                                }</span>
                                        }

                                        <span class="cov0" title="0">LogViewError(ViewDiagnosticsInfo{
                                                FilePath: filePath,
                                                Offset:   params.Offset,
                                                Limit:    params.Limit,
                                        }, "file not found")
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("File not found: %s", filePath)), nil</span>
                                }
                                <span class="cov0" title="0">return fantasy.ToolResponse{}, fmt.Errorf("error accessing file: %w", err)</span>
                        }

                        // Check if it's a directory - provide helpful response instead of error
                        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                                // List directory contents to help AI understand what's available
                                dirEntries, err := os.ReadDir(filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Cannot read directory: %s. Error: %v", filePath, err)), nil
                                }</span>

                                // Build helpful response with directory contents
                                <span class="cov0" title="0">var fileList []string
                                for _, entry := range dirEntries </span><span class="cov0" title="0">{
                                        fileList = append(fileList, entry.Name())
                                }</span>

                                // Create AI-friendly response with suggestions
                                <span class="cov0" title="0">response := fmt.Sprintf("Path is a directory: %s\n\nDirectory contents:\n", filePath)
                                for i, file := range fileList </span><span class="cov0" title="0">{
                                        response += fmt.Sprintf("%d. %s\n", i+1, file)
                                }</span>

                                <span class="cov0" title="0">response += "\n💡 Suggestions:\n"
                                response += "- Use 'view' with a specific file path (e.g., 'view internal/db/db.go')\n"
                                response += "- Use 'ls' command to explore directory structure\n"
                                response += "- Try 'find' to search for specific files\n"

                                return fantasy.NewTextResponse(response), nil</span>
                        }

                        // Check file size
                        <span class="cov0" title="0">if fileInfo.Size() &gt; MaxReadSize </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("File is too large (%d bytes). Maximum size is %d bytes",
                                        fileInfo.Size(), MaxReadSize)), nil
                        }</span>

                        // Set default limit if not provided
                        <span class="cov0" title="0">if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                                params.Limit = DefaultReadLimit
                        }</span>

                        <span class="cov0" title="0">isImage, mimeType := getImageMimeType(filePath)
                        if isImage </span><span class="cov0" title="0">{
                                if !GetSupportsImagesFromContext(ctx) </span><span class="cov0" title="0">{
                                        modelName := GetModelNameFromContext(ctx)
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("This model (%s) does not support image data.", modelName)), nil
                                }</span>

                                <span class="cov0" title="0">imageData, err := os.ReadFile(filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fantasy.ToolResponse{}, fmt.Errorf("error reading image file: %w", err)
                                }</span>

                                <span class="cov0" title="0">encoded := base64.StdEncoding.EncodeToString(imageData)
                                return fantasy.NewImageResponse([]byte(encoded), mimeType), nil</span>
                        }

                        // Read the file content
                        <span class="cov0" title="0">content, lineCount, err := readTextFile(filePath, params.Offset, params.Limit)
                // Validate and sanitize UTF-8 content to prevent crashes
                if !utf8.ValidString(content) </span><span class="cov0" title="0">{
                        // Fix invalid UTF-8 sequences instead of failing
                        content = strings.ToValidUTF8(content, "�")
                        if !utf8.ValidString(content) </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: Content still contains invalid UTF-8 after repair attempts")
                                // As a last resort, filter out all invalid sequences
                                content = strings.ToValidUTF8(content, "")
                                if !utf8.ValidString(content) </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Warning: Using fallback UTF-8 sanitization")
                                        // Final fallback - remove all non-ASCII characters
                                        content = strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                                                if r &lt; 128 </span><span class="cov0" title="0">{
                                                        return r
                                                }</span>
                                                <span class="cov0" title="0">return '�'</span>
                                        }, content)
                                }
                        }
                        <span class="cov0" title="0">LogViewError(ViewDiagnosticsInfo{
                                FilePath: filePath,
                                FileSize: fileInfo.Size(),
                        }, "invalid UTF-8 sanitized")</span>
                }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error reading file: %w", err)
                        }</span>

                        <span class="cov0" title="0">notifyLSPs(ctx, lspClients, filePath)
                        output := "&lt;file&gt;\n"
                        // Format the output with line numbers
                        output += addLineNumbers(content, params.Offset+1)

                        // Add a note if the content was truncated
                        if lineCount &gt; params.Offset+len(strings.Split(content, "\n")) </span><span class="cov0" title="0">{
                                output += fmt.Sprintf("\n\n(File has more lines. Use 'offset' parameter to read beyond line %d)",
                                        params.Offset+len(strings.Split(content, "\n")))
                        }</span>
                        <span class="cov0" title="0">output += "\n&lt;/file&gt;\n"

                        // Add file information to help context awareness
                        linesRead := len(strings.Split(content, "\n"))
                        output += fmt.Sprintf("\n\n📄 File: %d KB — showing lines %d-%d of %d total (default chunks: 100 lines)",
                                int(fileInfo.Size()/1024),
                                params.Offset+1,
                                params.Offset+linesRead,
                                lineCount)

                        // Suggest how to read more if needed
                        if lineCount &gt; params.Offset+linesRead </span><span class="cov0" title="0">{
                                output += fmt.Sprintf("\n💡 Use offset=%d to read next chunk", params.Offset+linesRead)
                        }</span>

                        <span class="cov0" title="0">output += getDiagnostics(filePath, lspClients)
                        recordFileRead(filePath)
                        duration := time.Since(startTime).Seconds() * 1000
                        LogViewOperation(ViewDiagnosticsInfo{
                                FilePath:  filePath,
                                Offset:    params.Offset,
                                Limit:     params.Limit,
                                FileSize:  fileInfo.Size(),
                                LineCount: lineCount,
                        }, duration)
                        return fantasy.WithResponseMetadata(
                                fantasy.NewTextResponse(output),
                                ViewResponseMetadata{
                                        FilePath: filePath,
                                        Content:  content,
                                },
                        ), nil</span>
                })
}

func addLineNumbers(content string, startLine int) string <span class="cov0" title="0">{
        if content == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">lines := strings.Split(content, "\n")

        var result []string
        for i, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSuffix(line, "\r")
                // Replace tabs with visible indicator for clarity in output
                line = strings.ReplaceAll(line, "\t", "→\t")

                lineNum := i + startLine
                numStr := fmt.Sprintf("%d", lineNum)

                if len(numStr) &gt;= 6 </span><span class="cov0" title="0">{
                        result = append(result, fmt.Sprintf("%s|%s", numStr, line))
                }</span> else<span class="cov0" title="0"> {
                        paddedNum := fmt.Sprintf("%6s", numStr)
                        result = append(result, fmt.Sprintf("%s|%s", paddedNum, line))
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(result, "\n")</span>
}

func readTextFile(filePath string, offset, limit int) (string, int, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        lineCount := 0

        // Read entire file with UTF-8 handling
        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        // Ensure UTF-8 validity
        <span class="cov0" title="0">if !utf8.Valid(content) </span><span class="cov0" title="0">{
                // Fix invalid UTF-8 sequences
                content = bytes.ToValidUTF8(content, []byte("�"))
        }</span>

        // Split into lines
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        lineCount = len(lines)

        // Validate each line and truncate if necessary
        for i := range lines </span><span class="cov0" title="0">{
                if len(lines[i]) &gt; MaxLineLength </span><span class="cov0" title="0">{
                        lines[i] = lines[i][:MaxLineLength] + "..."
                }</span>
        }

        // Apply offset and limit
        <span class="cov0" title="0">start := offset
        if start &gt;= lineCount </span><span class="cov0" title="0">{
                return "", lineCount, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; lineCount </span><span class="cov0" title="0">{
                end = lineCount
        }</span>

        <span class="cov0" title="0">resultLines := lines[start:end]
        return strings.Join(resultLines, "\n"), lineCount, nil</span>
}

func getImageMimeType(filePath string) (bool, string) <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filePath))
        switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return true, "image/jpeg"</span>
        case ".png":<span class="cov0" title="0">
                return true, "image/png"</span>
        case ".gif":<span class="cov0" title="0">
                return true, "image/gif"</span>
        case ".bmp":<span class="cov0" title="0">
                return true, "image/bmp"</span>
        case ".svg":<span class="cov0" title="0">
                return true, "image/svg+xml"</span>
        case ".webp":<span class="cov0" title="0">
                return true, "image/webp"</span>
        default:<span class="cov0" title="0">
                return false, ""</span>
        }
}

type LineScanner struct {
        scanner *bufio.Scanner
}

func NewLineScanner(r io.Reader) *LineScanner <span class="cov0" title="0">{
        scanner := bufio.NewScanner(r)
        // Increase buffer size to handle large lines (e.g., minified JSON, HTML)
        // Default is 64KB, set to 1MB
        buf := make([]byte, 0, 64*1024)
        scanner.Buffer(buf, 1024*1024)
        return &amp;LineScanner{
                scanner: scanner,
        }
}</span>

func (s *LineScanner) Scan() bool <span class="cov0" title="0">{
        return s.scanner.Scan()
}</span>

func (s *LineScanner) Text() string <span class="cov0" title="0">{
        return s.scanner.Text()
}</span>

func (s *LineScanner) Err() error <span class="cov0" title="0">{
        return s.scanner.Err()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        "charm.land/fantasy"
)

//go:embed web_fetch.md
var webFetchToolDescription []byte

// NewWebFetchTool creates a simple web fetch tool for sub-agents (no permissions needed).
func NewWebFetchTool(workingDir string, client *http.Client) fantasy.AgentTool <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                }
        }</span>

        <span class="cov0" title="0">return fantasy.NewParallelAgentTool(
                WebFetchToolName,
                string(webFetchToolDescription),
                func(ctx context.Context, params WebFetchParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.URL == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("url is required"), nil
                        }</span>

                        <span class="cov0" title="0">content, err := FetchURLAndConvert(ctx, client, params.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse(fmt.Sprintf("Failed to fetch URL: %s", err)), nil
                        }</span>

                        <span class="cov0" title="0">hasLargeContent := len(content) &gt; LargeContentThreshold
                        var result strings.Builder

                        if hasLargeContent </span><span class="cov0" title="0">{
                                tempFile, err := os.CreateTemp(workingDir, "page-*.md")
                                if err != nil </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Failed to create temporary file: %s", err)), nil
                                }</span>
                                <span class="cov0" title="0">tempFilePath := tempFile.Name()

                                if _, err := tempFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                                        _ = tempFile.Close() // Best effort close
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Failed to write content to file: %s", err)), nil
                                }</span>
                                <span class="cov0" title="0">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Failed to close temporary file: %s", err)), nil
                                }</span>

                                <span class="cov0" title="0">result.WriteString(fmt.Sprintf("Fetched content from %s (large page)\n\n", params.URL))
                                result.WriteString(fmt.Sprintf("Content saved to: %s\n\n", tempFilePath))
                                result.WriteString("Use the view and grep tools to analyze this file.")</span>
                        } else<span class="cov0" title="0"> {
                                result.WriteString(fmt.Sprintf("Fetched content from %s:\n\n", params.URL))
                                result.WriteString(content)
                        }</span>

                        <span class="cov0" title="0">return fantasy.NewTextResponse(result.String()), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package tools

import (
        "context"
        _ "embed"
        "net/http"
        "time"

        "charm.land/fantasy"
)

//go:embed web_search.md
var webSearchToolDescription []byte

// NewWebSearchTool creates a web search tool for sub-agents (no permissions needed).
func NewWebSearchTool(client *http.Client) fantasy.AgentTool <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                }
        }</span>

        <span class="cov0" title="0">return fantasy.NewParallelAgentTool(
                WebSearchToolName,
                string(webSearchToolDescription),
                func(ctx context.Context, params WebSearchParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.Query == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("query is required"), nil
                        }</span>

                        <span class="cov0" title="0">maxResults := params.MaxResults
                        if maxResults &lt;= 0 </span><span class="cov0" title="0">{
                                maxResults = 10
                        }</span>
                        <span class="cov0" title="0">if maxResults &gt; 20 </span><span class="cov0" title="0">{
                                maxResults = 20
                        }</span>

                        <span class="cov0" title="0">results, err := searchDuckDuckGo(ctx, client, params.Query, maxResults)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("Failed to search: " + err.Error()), nil
                        }</span>

                        <span class="cov0" title="0">return fantasy.NewTextResponse(formatSearchResults(results)), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package tools

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"

        "charm.land/fantasy"
        "github.com/nexora/cli/internal/csync"
        "github.com/nexora/cli/internal/diff"
        "github.com/nexora/cli/internal/filepathext"
        "github.com/nexora/cli/internal/fsext"
        "github.com/nexora/cli/internal/history"

        "github.com/nexora/cli/internal/lsp"
        "github.com/nexora/cli/internal/permission"
)

//go:embed write.md
var writeDescription []byte

type WriteParams struct {
        FilePath string `json:"file_path" description:"The path to the file to write"`
        Content  string `json:"content" description:"The content to write to the file"`
}

type WritePermissionsParams struct {
        FilePath   string `json:"file_path"`
        OldContent string `json:"old_content,omitempty"`
        NewContent string `json:"new_content,omitempty"`
}

type writeTool struct {
        lspClients  *csync.Map[string, *lsp.Client]
        permissions permission.Service
        files       history.Service
        workingDir  string
}

type WriteResponseMetadata struct {
        Diff      string `json:"diff"`
        Additions int    `json:"additions"`
        Removals  int    `json:"removals"`
}

const WriteToolName = "write"

func NewWriteTool(lspClients *csync.Map[string, *lsp.Client], permissions permission.Service, files history.Service, workingDir string) fantasy.AgentTool <span class="cov0" title="0">{
        return fantasy.NewAgentTool(
                WriteToolName,
                string(writeDescription),
                func(ctx context.Context, params WriteParams, call fantasy.ToolCall) (fantasy.ToolResponse, error) </span><span class="cov0" title="0">{
                        if params.FilePath == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("file_path is required"), nil
                        }</span>

                        <span class="cov0" title="0">if params.Content == "" </span><span class="cov0" title="0">{
                                return fantasy.NewTextErrorResponse("content is required"), nil
                        }</span>

                        <span class="cov0" title="0">filePath := filepathext.SmartJoin(workingDir, params.FilePath)

                        fileInfo, err := os.Stat(filePath)
                        if err == nil </span><span class="cov0" title="0">{
                                if fileInfo.IsDir() </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("Path is a directory, not a file: %s", filePath)), nil
                                }</span>

                                <span class="cov0" title="0">modTime := fileInfo.ModTime()
                                lastRead := getLastReadTime(filePath)
                                if modTime.After(lastRead) </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("File %s has been modified since it was last read.\nLast modification: %s\nLast read: %s\n\nPlease read the file again before modifying it.",
                                                filePath, modTime.Format(time.RFC3339), lastRead.Format(time.RFC3339))), nil
                                }</span>

                                <span class="cov0" title="0">oldContent, readErr := os.ReadFile(filePath)
                                if readErr == nil &amp;&amp; string(oldContent) == params.Content </span><span class="cov0" title="0">{
                                        return fantasy.NewTextErrorResponse(fmt.Sprintf("File %s already contains the exact content. No changes made.", filePath)), nil
                                }</span>
                        } else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error checking file: %w", err)
                        }</span>

                        <span class="cov0" title="0">dir := filepath.Dir(filePath)
                        if err = os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error creating directory: %w", err)
                        }</span>

                        <span class="cov0" title="0">oldContent := ""
                        if fileInfo != nil &amp;&amp; !fileInfo.IsDir() </span><span class="cov0" title="0">{
                                oldBytes, readErr := os.ReadFile(filePath)
                                if readErr == nil </span><span class="cov0" title="0">{
                                        oldContent = string(oldBytes)
                                }</span>
                        }

                        <span class="cov0" title="0">sessionID := GetSessionFromContext(ctx)
                        if sessionID == "" </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("session_id is required")
                        }</span>

                        <span class="cov0" title="0">diff, additions, removals := diff.GenerateDiff(
                                oldContent,
                                params.Content,
                                strings.TrimPrefix(filePath, workingDir),
                        )

                        p := permissions.Request(
                                permission.CreatePermissionRequest{
                                        SessionID:   sessionID,
                                        Path:        fsext.PathOrPrefix(filePath, workingDir),
                                        ToolCallID:  call.ID,
                                        ToolName:    WriteToolName,
                                        Action:      "write",
                                        Description: fmt.Sprintf("Create file %s", filePath),
                                        Params: WritePermissionsParams{
                                                FilePath:   filePath,
                                                OldContent: oldContent,
                                                NewContent: params.Content,
                                        },
                                },
                        )
                        if !p </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, permission.ErrorPermissionDenied
                        }</span>

                        <span class="cov0" title="0">err = os.WriteFile(filePath, []byte(params.Content), 0o644)
                        if err != nil </span><span class="cov0" title="0">{
                                return fantasy.ToolResponse{}, fmt.Errorf("error writing file: %w", err)
                        }</span>

                        // Check if file exists in history
                        <span class="cov0" title="0">file, err := files.GetByPathAndSession(ctx, filePath, sessionID)
                        if err != nil </span><span class="cov0" title="0">{
                                _, err = files.Create(ctx, sessionID, filePath, oldContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log error but don't fail the operation
                                        return fantasy.ToolResponse{}, fmt.Errorf("error creating file history: %w", err)
                                }</span>
                        }
                        <span class="cov0" title="0">if file.Content != oldContent </span><span class="cov0" title="0">{
                                // User Manually changed the content store an intermediate version
                                _, err = files.CreateVersion(ctx, sessionID, filePath, oldContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("Error creating file history version", "error", err)
                                }</span>
                        }
                        // Store the new version
                        <span class="cov0" title="0">_, err = files.CreateVersion(ctx, sessionID, filePath, params.Content)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Error creating file history version", "error", err)
                        }</span>

                        <span class="cov0" title="0">recordFileWrite(filePath)
                        recordFileRead(filePath)

                        notifyLSPs(ctx, lspClients, params.FilePath)

                        result := fmt.Sprintf("File successfully written: %s", filePath)
                        result = fmt.Sprintf("&lt;result&gt;\n%s\n&lt;/result&gt;", result)
                        result += getDiagnostics(filePath, lspClients)
                        return fantasy.WithResponseMetadata(fantasy.NewTextResponse(result),
                                WriteResponseMetadata{
                                        Diff:      diff,
                                        Additions: additions,
                                        Removals:  removals,
                                },
                        ), nil</span>
                })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
