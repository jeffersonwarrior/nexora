// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: checkpoints.sql

package db

import (
	"context"
	"time"
)

const createCheckpoint = `-- name: CreateCheckpoint :one
INSERT INTO checkpoints (
    id,
    session_id,
    timestamp,
    token_count,
    message_count,
    context_hash,
    state,
    compressed,
    created_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    strftime('%s', 'now')
) RETURNING id, session_id, timestamp, token_count, message_count, context_hash, state, compressed, created_at
`

type CreateCheckpointParams struct {
	ID           string    `json:"id"`
	SessionID    string    `json:"session_id"`
	Timestamp    time.Time `json:"timestamp"`
	TokenCount   int64     `json:"token_count"`
	MessageCount int64     `json:"message_count"`
	ContextHash  string    `json:"context_hash"`
	State        []byte    `json:"state"`
	Compressed   bool      `json:"compressed"`
}

func (q *Queries) CreateCheckpoint(ctx context.Context, arg CreateCheckpointParams) (Checkpoint, error) {
	row := q.queryRow(ctx, q.createCheckpointStmt, createCheckpoint,
		arg.ID,
		arg.SessionID,
		arg.Timestamp,
		arg.TokenCount,
		arg.MessageCount,
		arg.ContextHash,
		arg.State,
		arg.Compressed,
	)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Timestamp,
		&i.TokenCount,
		&i.MessageCount,
		&i.ContextHash,
		&i.State,
		&i.Compressed,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCheckpoint = `-- name: DeleteCheckpoint :exec
DELETE FROM checkpoints
WHERE id = ?
`

func (q *Queries) DeleteCheckpoint(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteCheckpointStmt, deleteCheckpoint, id)
	return err
}

const deleteOldCheckpoints = `-- name: DeleteOldCheckpoints :exec
DELETE FROM checkpoints
WHERE checkpoints.session_id = ?
AND checkpoints.id NOT IN (
    SELECT c.id
    FROM checkpoints AS c
    WHERE c.session_id = ?
    ORDER BY c.timestamp DESC
    LIMIT ?
)
`

type DeleteOldCheckpointsParams struct {
	SessionID   string `json:"session_id"`
	SessionID_2 string `json:"session_id_2"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) DeleteOldCheckpoints(ctx context.Context, arg DeleteOldCheckpointsParams) error {
	_, err := q.exec(ctx, q.deleteOldCheckpointsStmt, deleteOldCheckpoints, arg.SessionID, arg.SessionID_2, arg.Limit)
	return err
}

const getCheckpoint = `-- name: GetCheckpoint :one
SELECT id, session_id, timestamp, token_count, message_count, context_hash, state, compressed, created_at
FROM checkpoints
WHERE id = ? LIMIT 1
`

func (q *Queries) GetCheckpoint(ctx context.Context, id string) (Checkpoint, error) {
	row := q.queryRow(ctx, q.getCheckpointStmt, getCheckpoint, id)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Timestamp,
		&i.TokenCount,
		&i.MessageCount,
		&i.ContextHash,
		&i.State,
		&i.Compressed,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestCheckpoint = `-- name: GetLatestCheckpoint :one
SELECT id, session_id, timestamp, token_count, message_count, context_hash, state, compressed, created_at
FROM checkpoints
WHERE session_id = ?
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestCheckpoint(ctx context.Context, sessionID string) (Checkpoint, error) {
	row := q.queryRow(ctx, q.getLatestCheckpointStmt, getLatestCheckpoint, sessionID)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Timestamp,
		&i.TokenCount,
		&i.MessageCount,
		&i.ContextHash,
		&i.State,
		&i.Compressed,
		&i.CreatedAt,
	)
	return i, err
}

const listCheckpoints = `-- name: ListCheckpoints :many
SELECT id, session_id, timestamp, token_count, message_count, context_hash, state, compressed, created_at
FROM checkpoints
WHERE session_id = ?
ORDER BY timestamp DESC
`

func (q *Queries) ListCheckpoints(ctx context.Context, sessionID string) ([]Checkpoint, error) {
	rows, err := q.query(ctx, q.listCheckpointsStmt, listCheckpoints, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Checkpoint{}
	for rows.Next() {
		var i Checkpoint
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Timestamp,
			&i.TokenCount,
			&i.MessageCount,
			&i.ContextHash,
			&i.State,
			&i.Compressed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
