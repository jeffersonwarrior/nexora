// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: prompts.sql

package db

import (
	"context"
	"database/sql"
)

const createPrompt = `-- name: CreatePrompt :one
INSERT INTO prompt_library (
    id,
    category,
    subcategory,
    title,
    description,
    content,
    content_hash,
    tags,
    author
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at
`

type CreatePromptParams struct {
	ID          string         `json:"id"`
	Category    string         `json:"category"`
	Subcategory sql.NullString `json:"subcategory"`
	Title       string         `json:"title"`
	Description string         `json:"description"`
	Content     string         `json:"content"`
	ContentHash sql.NullString `json:"content_hash"`
	Tags        sql.NullString `json:"tags"`
	Author      sql.NullString `json:"author"`
}

func (q *Queries) CreatePrompt(ctx context.Context, arg CreatePromptParams) (PromptLibrary, error) {
	row := q.queryRow(ctx, q.createPromptStmt, createPrompt,
		arg.ID,
		arg.Category,
		arg.Subcategory,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.ContentHash,
		arg.Tags,
		arg.Author,
	)
	var i PromptLibrary
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentHash,
		&i.Tags,
		&i.Variables,
		&i.Author,
		&i.Source,
		&i.SourceUrl,
		&i.Votes,
		&i.Rating,
		&i.UsageCount,
		&i.SuccessRate,
		&i.AvgTokens,
		&i.AvgLatencyMs,
		&i.LastUsedAt,
		&i.FavoritesCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePrompt = `-- name: DeletePrompt :exec
DELETE FROM prompt_library WHERE id = ?
`

func (q *Queries) DeletePrompt(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deletePromptStmt, deletePrompt, id)
	return err
}

const getPrompt = `-- name: GetPrompt :one
SELECT id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at FROM prompt_library WHERE id = ? LIMIT 1
`

func (q *Queries) GetPrompt(ctx context.Context, id string) (PromptLibrary, error) {
	row := q.queryRow(ctx, q.getPromptStmt, getPrompt, id)
	var i PromptLibrary
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentHash,
		&i.Tags,
		&i.Variables,
		&i.Author,
		&i.Source,
		&i.SourceUrl,
		&i.Votes,
		&i.Rating,
		&i.UsageCount,
		&i.SuccessRate,
		&i.AvgTokens,
		&i.AvgLatencyMs,
		&i.LastUsedAt,
		&i.FavoritesCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPromptsByTag = `-- name: GetPromptsByTag :many
SELECT id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at FROM prompt_library
WHERE tags LIKE '%' || ?1 || '%'
ORDER BY rating DESC
LIMIT ?2
`

type GetPromptsByTagParams struct {
	Tag   sql.NullString `json:"tag"`
	Limit int64          `json:"limit"`
}

func (q *Queries) GetPromptsByTag(ctx context.Context, arg GetPromptsByTagParams) ([]PromptLibrary, error) {
	rows, err := q.query(ctx, q.getPromptsByTagStmt, getPromptsByTag, arg.Tag, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromptLibrary{}
	for rows.Next() {
		var i PromptLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentHash,
			&i.Tags,
			&i.Variables,
			&i.Author,
			&i.Source,
			&i.SourceUrl,
			&i.Votes,
			&i.Rating,
			&i.UsageCount,
			&i.SuccessRate,
			&i.AvgTokens,
			&i.AvgLatencyMs,
			&i.LastUsedAt,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUsage = `-- name: IncrementUsage :exec
UPDATE prompt_library
SET usage_count = usage_count + 1,
    last_used_at = strftime('%s', 'now')
WHERE id = ?
`

func (q *Queries) IncrementUsage(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.incrementUsageStmt, incrementUsage, id)
	return err
}

const listPrompts = `-- name: ListPrompts :many
SELECT id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at FROM prompt_library
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPromptsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPrompts(ctx context.Context, arg ListPromptsParams) ([]PromptLibrary, error) {
	rows, err := q.query(ctx, q.listPromptsStmt, listPrompts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromptLibrary{}
	for rows.Next() {
		var i PromptLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentHash,
			&i.Tags,
			&i.Variables,
			&i.Author,
			&i.Source,
			&i.SourceUrl,
			&i.Votes,
			&i.Rating,
			&i.UsageCount,
			&i.SuccessRate,
			&i.AvgTokens,
			&i.AvgLatencyMs,
			&i.LastUsedAt,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromptsByCategory = `-- name: ListPromptsByCategory :many
SELECT id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at FROM prompt_library
WHERE category = ?
ORDER BY rating DESC, usage_count DESC
LIMIT ?
`

type ListPromptsByCategoryParams struct {
	Category string `json:"category"`
	Limit    int64  `json:"limit"`
}

func (q *Queries) ListPromptsByCategory(ctx context.Context, arg ListPromptsByCategoryParams) ([]PromptLibrary, error) {
	rows, err := q.query(ctx, q.listPromptsByCategoryStmt, listPromptsByCategory, arg.Category, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromptLibrary{}
	for rows.Next() {
		var i PromptLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentHash,
			&i.Tags,
			&i.Variables,
			&i.Author,
			&i.Source,
			&i.SourceUrl,
			&i.Votes,
			&i.Rating,
			&i.UsageCount,
			&i.SuccessRate,
			&i.AvgTokens,
			&i.AvgLatencyMs,
			&i.LastUsedAt,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopPrompts = `-- name: ListTopPrompts :many
SELECT id, category, subcategory, title, description, content, content_hash, tags, variables, author, source, source_url, votes, rating, usage_count, success_rate, avg_tokens, avg_latency_ms, last_used_at, favorites_count, created_at, updated_at FROM prompt_library
ORDER BY rating DESC, usage_count DESC
LIMIT ?
`

func (q *Queries) ListTopPrompts(ctx context.Context, limit int64) ([]PromptLibrary, error) {
	rows, err := q.query(ctx, q.listTopPromptsStmt, listTopPrompts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromptLibrary{}
	for rows.Next() {
		var i PromptLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentHash,
			&i.Tags,
			&i.Variables,
			&i.Author,
			&i.Source,
			&i.SourceUrl,
			&i.Votes,
			&i.Rating,
			&i.UsageCount,
			&i.SuccessRate,
			&i.AvgTokens,
			&i.AvgLatencyMs,
			&i.LastUsedAt,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPrompts = `-- name: SearchPrompts :many
SELECT p.id, p.category, p.subcategory, p.title, p.description, p.content, p.content_hash, p.tags, p.variables, p.author, p.source, p.source_url, p.votes, p.rating, p.usage_count, p.success_rate, p.avg_tokens, p.avg_latency_ms, p.last_used_at, p.favorites_count, p.created_at, p.updated_at FROM prompt_library p
WHERE p.rowid IN (
    SELECT f.rowid FROM prompt_library_fts f WHERE f.title MATCH ? OR f.description MATCH ? OR f.content MATCH ? OR f.tags MATCH ?
)
LIMIT ?
`

type SearchPromptsParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Content     string `json:"content"`
	Tags        string `json:"tags"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) SearchPrompts(ctx context.Context, arg SearchPromptsParams) ([]PromptLibrary, error) {
	rows, err := q.query(ctx, q.searchPromptsStmt, searchPrompts,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.Tags,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromptLibrary{}
	for rows.Next() {
		var i PromptLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentHash,
			&i.Tags,
			&i.Variables,
			&i.Author,
			&i.Source,
			&i.SourceUrl,
			&i.Votes,
			&i.Rating,
			&i.UsageCount,
			&i.SuccessRate,
			&i.AvgTokens,
			&i.AvgLatencyMs,
			&i.LastUsedAt,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePrompt = `-- name: UpdatePrompt :exec
UPDATE prompt_library
SET title = ?,
    description = ?,
    content = ?,
    content_hash = ?,
    tags = ?,
    updated_at = strftime('%s', 'now')
WHERE id = ?
`

type UpdatePromptParams struct {
	Title       string         `json:"title"`
	Description string         `json:"description"`
	Content     string         `json:"content"`
	ContentHash sql.NullString `json:"content_hash"`
	Tags        sql.NullString `json:"tags"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdatePrompt(ctx context.Context, arg UpdatePromptParams) error {
	_, err := q.exec(ctx, q.updatePromptStmt, updatePrompt,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.ContentHash,
		arg.Tags,
		arg.ID,
	)
	return err
}

const updateRating = `-- name: UpdateRating :exec
UPDATE prompt_library
SET rating = ?1,
    votes = votes + 1,
    updated_at = strftime('%s', 'now')
WHERE id = ?2
`

type UpdateRatingParams struct {
	Rating sql.NullFloat64 `json:"rating"`
	ID     string          `json:"id"`
}

func (q *Queries) UpdateRating(ctx context.Context, arg UpdateRatingParams) error {
	_, err := q.exec(ctx, q.updateRatingStmt, updateRating, arg.Rating, arg.ID)
	return err
}
